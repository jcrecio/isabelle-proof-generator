{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/UserGuide.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma (in vars) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\"", "lemma (in vars) \"\\<Gamma>,{}\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\"", "lemma (in vars) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\"", "lemma (in vars)\n  \"\\<Gamma>,{}\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          WHILE \\<acute>M \\<noteq> a\n          INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n          DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma (in Square_impl)\nshows \"\\<forall>n. \\<Gamma>\\<turnstile>\\<lbrace>\\<acute>N = n\\<rbrace>  \\<acute>R :== PROC Square(\\<acute>N) \\<lbrace>\\<acute>R = n * n\\<rbrace>\"", "lemma (in Square_impl) Square_spec:\nshows \"\\<forall>n. \\<Gamma>\\<turnstile>\\<lbrace>\\<acute>N = n\\<rbrace>  \\<acute>R :== PROC Square(\\<acute>N) \\<lbrace>\\<acute>R = n * n\\<rbrace>\"", "lemma (in Square_impl)\n  shows \"\\<Gamma>\\<turnstile>\\<lbrace>\\<acute>I = 2\\<rbrace> \\<acute>R :== CALL Square(\\<acute>I) \\<lbrace>\\<acute>R = 4\\<rbrace>\"", "lemma (in Square_impl)\n  shows \"\\<Gamma>\\<turnstile>\\<lbrace>\\<acute>I = 2\\<rbrace> \\<acute>R :== CALL Square(\\<acute>I) \\<lbrace>\\<acute>R = 4\\<rbrace>\"", "lemma fac_simp [simp]: \"0 < i \\<Longrightarrow>  fac i = i * fac (i - 1)\"", "lemma (in Fac_impl)\nshows \"\\<forall>n. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace> \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac n\\<rbrace>\"", "lemma (in append_impl) append_spec1:\nshows \"\\<forall>\\<sigma> Ps Qs.\n  \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n     \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma (in append_impl)\nshows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>cont=c\\<rbrace> \\<acute>p :== CALL append(Null,Null) \\<lbrace>\\<acute>cont=c\\<rbrace>\"", "lemma (in append_impl) append_modifies:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>} \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n             {t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in append_impl) shows \"{t. t may_only_modify_globals Z in [next]}\n       =\n       {t. \\<exists>next. globals t=update id id next_' (K_statefun next) (globals Z)}\"", "lemma (in append_impl)\nshows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>cont=c\\<rbrace> \\<acute>p :== CALL append(Null,Null) \\<lbrace>\\<acute>cont=c\\<rbrace>\"", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n       WHILE \\<acute>M \\<noteq> a\n       INV \\<lbrace>\\<acute>S = \\<acute>M * b \\<and> \\<acute>M \\<le> a\\<rbrace>\n       VAR MEASURE a - \\<acute>M\n       DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n       \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma (in Fac_impl) Fac_spec':\nshows \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} \\<acute>R :==  PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\"", "lemma (in append_impl) append_spec2:\nshows \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\\<^sub>t\n  \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n  \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma (in pedal_coast_clique)\nshows \"(\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M) UNIV) \\<and>\n         (\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M) UNIV)\"", "lemma (in pedal_coast_clique)\nshows \"(\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M) UNIV) \\<and>\n         (\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M) UNIV)\"", "lemma (in pedal_coast_clique)\nshows \"(\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M) UNIV) \\<and>\n         (\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M) UNIV)\"", "lemma (in vars) \"\\<Gamma>\\<turnstile>\\<lbrace>True\\<rbrace> \\<acute>M :==\\<^sub>g (\\<acute>M + 1) div \\<acute>N \\<lbrace>True\\<rbrace>\"", "lemma (in insert_impl) insert_modifies:\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>} \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n        {t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in insert_impl) insert_spec:\n  \"\\<forall>\\<sigma> Ps . \\<Gamma>\\<turnstile>\n  \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and> sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n      \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n    \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n  \\<lbrace>\\<exists>Qs. List \\<acute>p \\<acute>next Qs \\<and> sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont  Qs) \\<and>\n        set Qs = insert \\<^bsup>\\<sigma>\\<^esup>r (set Ps) \\<and>\n        (\\<forall>x. x \\<notin> set Qs \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma (in insertSort_impl) insertSort_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>} \\<acute>p :== PROC insertSort(\\<acute>p)\n    {t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in insertSort_impl) insertSort_spec:\nshows \"\\<forall>\\<sigma> Ps.\n  \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<rbrace>\n       \\<acute>p :== PROC insertSort(\\<acute>p)\n     \\<lbrace>\\<exists>Qs. List \\<acute>p \\<acute>next Qs \\<and> sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont Qs) \\<and>\n           set Qs = set Ps\\<rbrace>\"", "lemma (in vars) \"\\<Gamma>\\<turnstile> {\\<sigma>}\n            \\<acute>I :== \\<acute>M;;\n            ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                         \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                        \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n           \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\"", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> {\\<sigma>}\n  \\<acute>I :== \\<acute>M;;\n  ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n    \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n    \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n  \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\"", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> {\\<sigma>}\n   \\<acute>I :== \\<acute>M;;\n   ANNO (n,i,m). \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and> \\<acute>N=n \\<and> \\<acute>I=i \\<and> \\<acute>M=m\\<rbrace>\n     \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n   \\<lbrace>\\<acute>M = n \\<and> \\<acute>N = i\\<rbrace>\n  \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\"", "lemma (in vars) foo_lemma:\n  \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace> \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n             \\<lbrace>\\<acute>N = n + 1 \\<and> \\<acute>M = m + 1\\<rbrace>\"", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n       LEMMA foo_lemma\n             \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n       END;;\n       \\<acute>N :== \\<acute>N + 1\n       \\<lbrace>\\<acute>N = n + 2 \\<and> \\<acute>M = m + 1\\<rbrace>\"", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n           LEMMA foo_lemma\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n           END;;\n           LEMMA foo_lemma\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n           END\n      \\<lbrace>\\<acute>N = n + 2 \\<and> \\<acute>M = m + 2\\<rbrace>\"", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1;;\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n      \\<lbrace>\\<acute>N = n + 2 \\<and> \\<acute>M = m + 2\\<rbrace>\"", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M=0 \\<and> \\<acute>N=0\\<rbrace>\n      WHILE (\\<acute>M < i)\n      INV \\<lbrace>\\<acute>M \\<le> i \\<and> (\\<acute>M \\<noteq> 0 \\<longrightarrow> \\<acute>N = j) \\<and> \\<acute>N \\<le> j\\<rbrace>\n      VAR MEASURE (i - \\<acute>M)\n      DO\n         \\<acute>N :== 0;;\n         WHILE (\\<acute>N < j)\n         FIX m.\n         INV \\<lbrace>\\<acute>M=m \\<and> \\<acute>N \\<le> j\\<rbrace>\n         VAR MEASURE (j - \\<acute>N)\n         DO\n           \\<acute>N :== \\<acute>N + 1\n         OD;;\n       \\<acute>M :== \\<acute>M + 1\n       OD\n       \\<lbrace>\\<acute>M=i \\<and> (\\<acute>M\\<noteq>0 \\<longrightarrow> \\<acute>N=j)\\<rbrace>\"", "lemma (in append'_impl) append'_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC append'(\\<acute>p,\\<acute>q)\n        {t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in append'_impl) append'_spec:\n  shows \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\n            \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n                \\<acute>p :== PROC append'(\\<acute>p,\\<acute>q)\n            \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], "translations": [["", "lemma (in vars) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace>\n                    \\<acute>N :== 2 * \\<acute>N\n                    \\<lbrace>\\<acute>N = 10\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N. N = 5 \\<Longrightarrow> 2 * N = 10", "txt \\<open>@{subgoals}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N. N = 5 \\<Longrightarrow> 2 * N = 10", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "txt \\<open>@{subgoals}\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We enable the locale of statespace \\<open>vars\\<close> by the\n\\texttt{in vars} directive.  The verification condition generator is\ninvoked via the \\<open>vcg\\<close> method and leaves us with the expected\nsubgoal that can be proved by simplification.\\<close>"], ["", "text (in vars) \\<open>\n If we refer to components (variables) of the state-space of the program\n we always mark these with \\<open>\\<acute>\\<close> (in assertions and also in the\n program itself). It is the acute-symbol and is present on\n most keyboards. The assertions of the Hoare tuple are\n ordinary Isabelle sets. As we usually want to refer to the state space\n in the assertions, we provide special brackets for them. They can be written\n as {\\verb+{| |}+} in ASCII or \\<open>\\<lbrace> \\<rbrace>\\<close> with symbols. Internally,\n marking variables has two effects. First of all we refer to the implicit\n state and secondary we get rid of the suffix \\<open>_'\\<close>.\n So the assertion @{term \"{|\\<acute>N = 5|}\"} internally gets expanded to\n \\<open>{s. locals s \\<cdot>N_' = 5}\\<close> written in ordinary set comprehension notation of\n Isabelle. It describes the set of states where the \\<open>N_'\\<close> component\n is equal to \\<open>5\\<close>.\n An empty context and an empty postcondition for abrupt termination can be\n omitted. The lemma above is a shorthand for\n  \\<open>\\<Gamma>,{}\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>,{}\\<close>.\n\\<close>"], ["", "text \\<open>We can step through verification condition generation by the\nmethod \\<open>vcg_step\\<close>.\n\\<close>"], ["", "lemma (in vars) \"\\<Gamma>,{}\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace>\n                    \\<acute>N :== 2 * \\<acute>N\n                    \\<lbrace>\\<acute>N = 10\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> \\<lbrace>2 * \\<acute>N = 10\\<rbrace>", "txt \\<open>@{subgoals}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> \\<lbrace>2 * \\<acute>N = 10\\<rbrace>", "txt \\<open>The last step of verification condition generation,\n         transforms the inclusion of state sets to the corresponding\n         predicate on components of the state space.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> \\<lbrace>2 * \\<acute>N = 10\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N. N = 5 \\<Longrightarrow> 2 * N = 10", "txt \\<open>@{subgoals}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N. N = 5 \\<Longrightarrow> 2 * N = 10", "by simp"], ["", "text \\<open>\nAlthough our assertions work semantically on the state space, stepping\nthrough verification condition generation ``feels'' like the expected\nsyntactic substitutions of traditional Hoare logic. This is achieved\nby light simplification on the assertions calculated by the Hoare rules.\n\\<close>"], ["", "lemma (in vars) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace>\n                    \\<acute>N :== 2 * \\<acute>N\n                    \\<lbrace>\\<acute>N = 10\\<rbrace>", "apply (rule HoarePartial.Basic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> _Collect s\n                 (s\\<lparr>locals :=\n                             locals\n                              s\\<langle>N_' :=\n    2 * (locals s\\<cdot>N_')\\<rangle>\\<rparr>\n                  \\<in> \\<lbrace>\\<acute>N = 10\\<rbrace>)", "txt \\<open>@{subgoals}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> _Collect s\n                 (s\\<lparr>locals :=\n                             locals\n                              s\\<langle>N_' :=\n    2 * (locals s\\<cdot>N_')\\<rangle>\\<rparr>\n                  \\<in> \\<lbrace>\\<acute>N = 10\\<rbrace>)", "apply (simp only: mem_Collect_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> _Collect s\n                 (locals\n                   (s\\<lparr>locals :=\n                               locals\n                                s\\<langle>N_' :=\n      2 * (locals s\\<cdot>N_')\\<rangle>\\<rparr>)\\<cdot>N_' =\n                  10)", "txt \\<open>@{subgoals}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> _Collect s\n                 (locals\n                   (s\\<lparr>locals :=\n                               locals\n                                s\\<langle>N_' :=\n      2 * (locals s\\<cdot>N_')\\<rangle>\\<rparr>)\\<cdot>N_' =\n                  10)", "apply (tactic\n    \\<open>Hoare.BasicSimpTac @{context} Hoare.Function false\n       [] (K all_tac) 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> \\<lbrace>2 * \\<acute>N = 10\\<rbrace>", "txt \\<open>@{subgoals}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> \\<lbrace>2 * \\<acute>N = 10\\<rbrace>", "by simp"], ["", "text \\<open>The next example shows how we deal with the while loop. Note the\ninvariant annotation.\n\\<close>"], ["", "lemma (in vars)\n  \"\\<Gamma>,{}\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          WHILE \\<acute>M \\<noteq> a\n          INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n          DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a\n                    INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S + b = (M + 1) * b\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S = a * b", "txt \\<open>@{subgoals [display]}\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S + b = (M + 1) * b\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S = a * b", "txt \\<open>The verification condition generator gives us three proof obligations,\n         stemming from the path from the precondition to the invariant,\n         from the invariant together with loop condition through the\n         loop body to the invariant, and finally from the invariant together\n         with the negated loop condition to the postcondition.\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S + b = (M + 1) * b\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S = a * b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Procedures\\<close>"], ["", "subsubsection \\<open>Declaration\\<close>"], ["", "text \\<open>\nOur first procedure is a simple square procedure. We provide the\ncommand \\isacommand{procedures}, to declare and define a\nprocedure.\n\\<close>"], ["", "procedures\n  Square (N::nat|R::nat)\n  where I::nat in\n  \"\\<acute>R :== \\<acute>N * \\<acute>N\""], ["", "text \\<open>A procedure is given by the signature of the procedure\nfollowed by the procedure body.  The signature consists of the name of\nthe procedure and a list of parameters together with their types. The\nparameters in front of the pipe \\<open>|\\<close> are value parameters and\nbehind the pipe are the result parameters. Value parameters model call\nby value semantics. The value of a result parameter at the end of the\nprocedure is passed back to the caller. Local variables follow the\n\\<open>where\\<close>. If there are no local variables the \\<open>where \\<dots>\nin\\<close> can be omitted. The variable @{term \"I\"} is actually unused in\nthe body, but is used in the examples below.\\<close>"], ["", "text \\<open>\nThe procedures command provides convenient syntax\nfor procedure calls (that creates the proper @{term init}, @{term return} and\n@{term result} functions on the fly) and creates locales and statespaces to\nreason about the procedure. The purpose of locales is to set up logical contexts\nto support modular reasoning. Locales can be seen as freeze-dried proof contexts that\nget alive as you setup a new lemma or theorem (\\cite{Ballarin-04-locales}).\nThe locale the user deals with is named \\<open>Square_impl\\<close>.\n It defines the procedure name (internally   @{term \"Square_'proc\"}), the procedure body\n(named \\<open>Square_body\\<close>) and the statespaces for parameters and local and\nglobal variables.\nMoreover it contains the\nassumption @{term \"\\<Gamma> Square_'proc = Some Square_body\"}, which states\nthat the procedure is properly defined in the procedure context.\n\nThe purpose of the locale is to give us easy means to setup the context\nin which we prove programs correct.\nIn this locale the procedure context @{term \"\\<Gamma>\"} is fixed.\nSo we always use this letter for the procedure\nspecification. This is crucial, if we prove programs under the\nassumption of some procedure specifications.\n\\<close>"], ["", "(*<*)"], ["", "context Square_impl\nbegin"], ["", "(*>*)"], ["", "text \\<open>The procedures command generates syntax, so that we can\neither write \\<open>CALL Square(\\<acute>I,\\<acute>R)\\<close> or @{term \"\\<acute>I :== CALL\nSquare(\\<acute>R)\"} for the procedure call. The internal term is the\nfollowing:\n\\<close>"], ["", "(*<*)"], ["", "declare [[hoare_use_call_tr' = false]]"], ["", "(*>*)"], ["", "text \\<open>\\small @{term [display] \"CALL Square(\\<acute>I,\\<acute>R)\"}\\<close>"], ["", "(*<*)"], ["", "declare [[hoare_use_call_tr' = true]]"], ["", "(*>*)"], ["", "text \\<open>Note the\n        additional decoration (with the procedure name) of the parameter and\n         local variable names.\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"], ["", "text \\<open>The abstract syntax for the\nprocedure call is @{term \"call init p return result\"}.  The @{term\n\"init\"} function copies the values of the actual parameters to the\nformal parameters, the @{term return} function copies the global\nvariables back (in our case there are no global variables), and the\n@{term \"result\"} function additionally copies the values of the formal\nresult parameters to the actual locations. Actual value parameters can\nbe all kind of expressions, since we only need their value. But result\nparameters must be proper ``lvalues'': variables (including\ndereferenced pointers) or array locations, since we have to assign\nvalues to them.\n\\<close>"], ["", "subsubsection \\<open>Verification\\<close>"], ["", "text (in Square_impl) \\<open>\nA procedure specification is an ordinary Hoare tuple.\nWe use the parameterless\ncall for the specification; \\<open>\\<acute>R :== PROC Square(\\<acute>N)\\<close> is syntactic sugar\nfor \\<open>Call Square_'proc\\<close>. This emphasises that the specification\ndescribes the internal behaviour of the procedure, whereas parameter passing\ncorresponds to the procedure call.\nThe following precondition fixes the current value \\<open>\\<acute>N\\<close> to the logical\nvariable @{term n}.\nUniversal quantification of @{term \"n\"} enables us to adapt\nthe specification to an actual parameter. The specification is\nused in the rule for procedure call when we come upon a call to @{term Square}.\nThus @{term \"n\"} plays the role of the auxiliary variable @{term \"Z\"}.\n\\<close>"], ["", "text \\<open>To verify the procedure we need to verify the body. We use\na derived variant of the general recursion rule, tailored for non recursive procedures:\n@{thm [source] HoarePartial.ProcNoRec1}:\n\\begin{center}\n@{thm [mode=Rule,mode=ParenStmt] HoarePartial.ProcNoRec1 [no_vars]}\n\\end{center}\nThe naming convention for the rule\nis the following: The \\<open>1\\<close> expresses that we look at one\n procedure, and \\<open>NoRec\\<close> that the procedure is non\nrecursive.\n\\<close>"], ["", "lemma (in Square_impl)\nshows \"\\<forall>n. \\<Gamma>\\<turnstile>\\<lbrace>\\<acute>N = n\\<rbrace>  \\<acute>R :== PROC Square(\\<acute>N) \\<lbrace>\\<acute>R = n * n\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       \\<acute>R :== PROC Square(\\<acute>N)\n                       \\<lbrace>\\<acute>R = n * n\\<rbrace>", "txt \\<open>The directive \\<open>in\\<close> has the effect that\nthe context of the locale @{term \"Square_impl\"} is included to the current\nlemma, and that the lemma is added as a fact to the locale, after it is proven. The\nnext time locale @{term \"Square_impl\"} is invoked this lemma is immediately available\nas fact, which the verification condition generator can use.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       \\<acute>R :== PROC Square(\\<acute>N)\n                       \\<lbrace>\\<acute>R = n * n\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       \\<acute>R :== \\<acute>N * \\<acute>N\n                       \\<lbrace>\\<acute>R = n * n\\<rbrace>", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       \\<acute>R :== \\<acute>N * \\<acute>N\n                       \\<lbrace>\\<acute>R = n * n\\<rbrace>", "txt \\<open>The method \\<open>hoare_rule\\<close>, like \\<open>rule\\<close> applies a\n     single rule, but additionally does some ``obvious'' steps:\n     It solves the canonical side-conditions of various Hoare-rules and it\n     automatically expands the\n     procedure body: With @{thm [source] Square_impl}:  @{thm [names_short] Square_impl [no_vars]} we\n     get the procedure body out of the procedure context @{term \"\\<Gamma>\"};\n     with @{thm [source] Square_body_def}: @{thm [names_short] Square_body_def [no_vars]} we\n     can unfold the definition of the body.\n\n     The proof is finished by the vcg and simp.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       \\<acute>R :== \\<acute>N * \\<acute>N\n                       \\<lbrace>\\<acute>R = n * n\\<rbrace>", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       \\<acute>R :== \\<acute>N * \\<acute>N\n                       \\<lbrace>\\<acute>R = n * n\\<rbrace>", "by vcg simp"], ["", "text \\<open>If the procedure is non recursive and there is no specification given, the\nverification condition generator automatically expands the body.\\<close>"], ["", "lemma (in Square_impl) Square_spec:\nshows \"\\<forall>n. \\<Gamma>\\<turnstile>\\<lbrace>\\<acute>N = n\\<rbrace>  \\<acute>R :== PROC Square(\\<acute>N) \\<lbrace>\\<acute>R = n * n\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       \\<acute>R :== PROC Square(\\<acute>N)\n                       \\<lbrace>\\<acute>R = n * n\\<rbrace>", "by vcg simp"], ["", "text \\<open>An important naming convention is to name the specification as\n\\<open><procedure-name>_spec\\<close>. The verification condition generator refers to\nthis name in order to search for a specification in the theorem database.\n\\<close>"], ["", "subsubsection \\<open>Usage\\<close>"], ["", "text\\<open>Let us see how we can use procedure specifications.\\<close>"], ["", "(* FIXME: maybe don't show this at all *)"], ["", "lemma (in Square_impl)\n  shows \"\\<Gamma>\\<turnstile>\\<lbrace>\\<acute>I = 2\\<rbrace> \\<acute>R :== CALL Square(\\<acute>I) \\<lbrace>\\<acute>R = 4\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>I = 2\\<rbrace>\n                    \\<acute>R :== CALL Square(\\<acute>I)\n                    \\<lbrace>\\<acute>R = 4\\<rbrace>", "txt \\<open>Remember that we have already proven @{thm [source] \"Square_spec\"} in the locale\n  \\<open>Square_impl\\<close>. This is crucial for\n  verification condition generation. When reaching a procedure call,\n  it looks for the specification (by its name) and applies the\n  rule @{thm [source,mode=ParenStmt] HoarePartial.ProcSpec}\ninstantiated with the specification\n  (as last premise).\n  Before we apply the verification condition generator, let us\n  take some time to think of what we can expect.\n  Let's look at the specification @{thm [source] Square_spec} again:\n  @{thm [display] Square_spec [no_vars]}\n  The specification talks about the formal parameters @{term \"N\"} and\n  @{term R}. The precondition @{term \"\\<lbrace>\\<acute>N = n\\<rbrace>\"} just fixes the initial\n  value of \\<open>N\\<close>.\n  The actual parameters are @{term \"I\"} and @{term \"R\"}. We\n  have to adapt the specification to this calling context.\n  @{term \"\\<forall>n. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>I = n\\<rbrace> \\<acute>R :== CALL Square(\\<acute>I) \\<lbrace>\\<acute>R = n * n\\<rbrace>\"}.\n  From the postcondition @{term \"\\<lbrace>\\<acute>R = n * n\\<rbrace>\"} we\n  have to derive the actual postcondition @{term \"\\<lbrace>\\<acute>R = 4\\<rbrace>\"}. So\n  we gain something like: @{term \"\\<lbrace>n * n = (4::nat)\\<rbrace>\"}.\n  The precondition is @{term \"\\<lbrace>\\<acute>I = 2\\<rbrace>\"} and the specification\n  tells us @{term \"\\<lbrace>\\<acute>I = n\\<rbrace>\"} for the pre-state. So the value of @{term n}\n  is the value of @{term I} in the pre-state. So we arrive at\n  @{term \"\\<lbrace>\\<acute>I = 2\\<rbrace> \\<subseteq> \\<lbrace>\\<acute>I * \\<acute>I = 4\\<rbrace>\"}.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>I = 2\\<rbrace>\n                    \\<acute>R :== CALL Square(\\<acute>I)\n                    \\<lbrace>\\<acute>R = 4\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<forall>t.\n                            \\<^bsup>t\\<^esup>R =\n                            \\<acute>I * \\<acute>I \\<longrightarrow>\n                            \\<acute>I * \\<acute>I = 4\\<rbrace>", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<forall>t.\n                            \\<^bsup>t\\<^esup>R =\n                            \\<acute>I * \\<acute>I \\<longrightarrow>\n                            \\<acute>I * \\<acute>I = 4\\<rbrace>", "txt \\<open>\n  The second set looks slightly more involved:\n    @{term \"\\<lbrace>\\<forall>t. \\<^bsup>t\\<^esup>R = \\<acute>I * \\<acute>I \\<longrightarrow> \\<acute>I * \\<acute>I = 4\\<rbrace>\"}, this is an artefact from the\n  procedure call rule. Originally \\<open>\\<acute>I * \\<acute>I = 4\\<close> was \\<open>\\<^bsup>t\\<^esup>R = 4\\<close>. Where\n  @{term \"t\"} denotes the final state of the procedure and the superscript notation\n  allows to select a component from a particular state.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<forall>t.\n                            \\<^bsup>t\\<^esup>R =\n                            \\<acute>I * \\<acute>I \\<longrightarrow>\n                            \\<acute>I * \\<acute>I = 4\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I = 2 \\<Longrightarrow>\n       \\<forall>R. R = I * I \\<longrightarrow> I * I = 4", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I = 2 \\<Longrightarrow>\n       \\<forall>R. R = I * I \\<longrightarrow> I * I = 4", "by simp"], ["", "text \\<open>\nThe adaption of the procedure specification to the actual calling\ncontext is done due to the @{term init}, @{term return} and @{term result} functions\nin the rule @{thm [source] HoarePartial.ProcSpec} (or in the variant\n@{thm [source] HoarePartial.ProcSpecNoAbrupt} which already\nincorporates the fact that the postcondition for abrupt termination\nis the empty set). For the readers interested in the internals,\nhere a version without vcg.\n\\<close>"], ["", "lemma (in Square_impl)\n  shows \"\\<Gamma>\\<turnstile>\\<lbrace>\\<acute>I = 2\\<rbrace> \\<acute>R :== CALL Square(\\<acute>I) \\<lbrace>\\<acute>R = 4\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>I = 2\\<rbrace>\n                    \\<acute>R :== CALL Square(\\<acute>I)\n                    \\<lbrace>\\<acute>R = 4\\<rbrace>", "apply (rule HoarePartial.ProcSpecNoAbrupt [OF _ _ Square_spec])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> _Collect s\n                 (\\<exists>Z.\n                     s\\<lparr>locals :=\n                                locals\n                                 s\\<langle>N_'Square_' :=\n       locals s\\<cdot>I_'Square_'\\<rangle>\\<rparr>\n                     \\<in> \\<lbrace>\\<acute>N = Z\\<rbrace> \\<and>\n                     (\\<forall>t.\n                         t \\<in> \\<lbrace>\\<acute>R =\n    Z * Z\\<rbrace> \\<longrightarrow>\n                         s\\<lparr>globals := globals t\\<rparr>\n                         \\<in> ?R s t))\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R s t) \\<acute>R :== locals t\\<cdot>R_'Square_'\n                       \\<lbrace>\\<acute>R = 4\\<rbrace>", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> _Collect s\n                 (\\<exists>Z.\n                     s\\<lparr>locals :=\n                                locals\n                                 s\\<langle>N_'Square_' :=\n       locals s\\<cdot>I_'Square_'\\<rangle>\\<rparr>\n                     \\<in> \\<lbrace>\\<acute>N = Z\\<rbrace> \\<and>\n                     (\\<forall>t.\n                         t \\<in> \\<lbrace>\\<acute>R =\n    Z * Z\\<rbrace> \\<longrightarrow>\n                         s\\<lparr>globals := globals t\\<rparr>\n                         \\<in> ?R s t))\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R s t) \\<acute>R :== locals t\\<cdot>R_'Square_'\n                       \\<lbrace>\\<acute>R = 4\\<rbrace>", "txt \\<open>This is the raw verification condition,\n         It is interesting to see how the auxiliary variable @{term \"Z\"} is\n         actually used. It is unified with @{term n} of the specification and\n         fixes the state after parameter passing.\n\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> _Collect s\n                 (\\<exists>Z.\n                     s\\<lparr>locals :=\n                                locals\n                                 s\\<langle>N_'Square_' :=\n       locals s\\<cdot>I_'Square_'\\<rangle>\\<rparr>\n                     \\<in> \\<lbrace>\\<acute>N = Z\\<rbrace> \\<and>\n                     (\\<forall>t.\n                         t \\<in> \\<lbrace>\\<acute>R =\n    Z * Z\\<rbrace> \\<longrightarrow>\n                         s\\<lparr>globals := globals t\\<rparr>\n                         \\<in> ?R s t))\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R s t) \\<acute>R :== locals t\\<cdot>R_'Square_'\n                       \\<lbrace>\\<acute>R = 4\\<rbrace>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> _Collect s\n                 (\\<forall>t.\n                     locals t\\<cdot>R_'Square_' =\n                     (locals s\\<cdot>I_'Square_') *\n                     (locals s\\<cdot>I_'Square_') \\<longrightarrow>\n                     s\\<lparr>globals := globals t\\<rparr> \\<in> ?R s t)\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R s t) \\<acute>R :== locals t\\<cdot>R_'Square_'\n                       \\<lbrace>\\<acute>R = 4\\<rbrace>", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> _Collect s\n                 (\\<forall>t.\n                     locals t\\<cdot>R_'Square_' =\n                     (locals s\\<cdot>I_'Square_') *\n                     (locals s\\<cdot>I_'Square_') \\<longrightarrow>\n                     s\\<lparr>globals := globals t\\<rparr> \\<in> ?R s t)\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R s t) \\<acute>R :== locals t\\<cdot>R_'Square_'\n                       \\<lbrace>\\<acute>R = 4\\<rbrace>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R s t) \\<acute>R :== locals t\\<cdot>R_'Square_'\n                       \\<lbrace>\\<acute>R = 4\\<rbrace>\n 2. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> _Collect s\n                 (\\<forall>t.\n                     locals t\\<cdot>R_'Square_' =\n                     (locals s\\<cdot>I_'Square_') *\n                     (locals s\\<cdot>I_'Square_') \\<longrightarrow>\n                     s\\<lparr>globals := globals t\\<rparr> \\<in> ?R s t)", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> _Collect s\n                 (\\<forall>t.\n                     locals t\\<cdot>R_'Square_' =\n                     (locals s\\<cdot>I_'Square_') *\n                     (locals s\\<cdot>I_'Square_') \\<longrightarrow>\n                     s\\<lparr>globals := globals t\\<rparr>\n                     \\<in> \\<lbrace>\\<^bsup>t\\<^esup>R = 4\\<rbrace>)", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>I = 2\\<rbrace>\n    \\<subseteq> _Collect s\n                 (\\<forall>t.\n                     locals t\\<cdot>R_'Square_' =\n                     (locals s\\<cdot>I_'Square_') *\n                     (locals s\\<cdot>I_'Square_') \\<longrightarrow>\n                     s\\<lparr>globals := globals t\\<rparr>\n                     \\<in> \\<lbrace>\\<^bsup>t\\<^esup>R = 4\\<rbrace>)", "apply (auto intro: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Recursion\\<close>"], ["", "text \\<open>We want to define a procedure for the factorial. We first\ndefine a HOL function that calculates it, to specify the procedure later on.\n\\<close>"], ["", "primrec fac:: \"nat \\<Rightarrow> nat\"\nwhere\n\"fac 0 = 1\" |\n\"fac (Suc n) = (Suc n) * fac n\""], ["", "(*<*)"], ["", "lemma fac_simp [simp]: \"0 < i \\<Longrightarrow>  fac i = i * fac (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<Longrightarrow> fac i = i * fac (i - 1)", "by (cases i) simp_all"], ["", "(*>*)"], ["", "text \\<open>Now we define the procedure.\\<close>"], ["", "procedures\n  Fac (N::nat | R::nat)\n  \"IF \\<acute>N = 0 THEN \\<acute>R :== 1\n   ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n        \\<acute>R :== \\<acute>N * \\<acute>R\n   FI\""], ["", "text \\<open>\nNow let us prove that our implementation of @{term \"Fac\"} meets its specification.\n\\<close>"], ["", "lemma (in Fac_impl)\nshows \"\\<forall>n. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace> \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac n\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R = fac n\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>,(\\<Union>n.\n                    {(\\<lbrace>\\<acute>N = n\\<rbrace>, Fac_'proc,\n                      \\<lbrace>\\<acute>R = fac n\\<rbrace>, {})})\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R = fac n\\<rbrace>", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>,(\\<Union>n.\n                    {(\\<lbrace>\\<acute>N = n\\<rbrace>, Fac_'proc,\n                      \\<lbrace>\\<acute>R = fac n\\<rbrace>, {})})\n          \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R = fac n\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "txt \"@{subgoals[display]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nSince the factorial is implemented recursively,\nthe main ingredient of this proof is, to assume that the specification holds for\nthe recursive call of @{term Fac} and prove the body correct.\nThe assumption for recursive calls is added to the context by\nthe rule @{thm [source] HoarePartial.ProcRec1}\n(also derived from the general rule for mutually recursive procedures):\n\\begin{center}\n@{thm [mode=Rule,mode=ParenStmt] HoarePartial.ProcRec1 [no_vars]}\n\\end{center}\nThe verification condition generator infers the specification out of the\ncontext @{term \"\\<Theta>\"} when it encounters a recursive call of the factorial.\n\\<close>"], ["", "subsection \\<open>Global Variables and Heap \\label{sec:VcgHeap}\\<close>"], ["", "text \\<open>\nNow we define and verify some procedures on heap-lists. We consider\nlist structures consisting of two fields, a content element @{term \"cont\"} and\na reference to the next list element @{term \"next\"}. We model this by the\nfollowing state space where every field has its own heap.\n\\<close>"], ["", "hoarestate globals_heap =\n  \"next\" :: \"ref \\<Rightarrow> ref\"\n  cont :: \"ref \\<Rightarrow> nat\""], ["", "text \\<open>It is mandatory to start the state name with `globals'. This is exploited\nby the syntax translations to store the components in the @{const globals} part\nof the state.\n\\<close>"], ["", "text \\<open>Updates to global components inside a procedure are\nalways propagated to the caller. This is implicitly done by the\nparameter passing syntax translations.\n\\<close>"], ["", "text \\<open>We first define an append function on lists. It takes two\nreferences as parameters. It appends the list referred to by the first\nparameter with the list referred to by the second parameter. The statespace\nof the global variables has to be imported.\n\\<close>"], ["", "procedures (imports globals_heap)\n  append(p :: ref, q::ref | p::ref)\n    \"IF \\<acute>p=Null THEN \\<acute>p :== \\<acute>q\n     ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\\<acute>q) FI\""], ["", "(*<*)"], ["", "context append_impl\nbegin"], ["", "(*>*)"], ["", "text \\<open>\nThe difference of a global and a local variable is that global\nvariables are automatically copied back to the procedure caller.\nWe can study this effect on the translation of @{term \"\\<acute>p :== CALL append(\\<acute>p,\\<acute>q)\"}:\n\\<close>"], ["", "(*<*)"], ["", "declare [[hoare_use_call_tr' = false]]"], ["", "(*>*)"], ["", "text \\<open>\n@{term [display] \"\\<acute>p :== CALL append(\\<acute>p,\\<acute>q)\"}\n\\<close>"], ["", "(*<*)"], ["", "declare [[hoare_use_call_tr' = true]]"], ["", "end"], ["", "(*>*)"], ["", "text \\<open>Below we give two specifications this time.\nOne captures the functional behaviour and focuses on the\nentities that are potentially modified by the procedure, the second one\nis a pure frame condition.\n\\<close>"], ["", "text \\<open>\nThe functional specification below introduces two logical variables besides the\nstate space variable @{term \"\\<sigma>\"}, namely @{term \"Ps\"} and @{term \"Qs\"}.\nThey are universally quantified and range over both the pre-and the postcondition, so\nthat we are able to properly instantiate the specification\nduring the proofs. The syntax \\<open>\\<lbrace>\\<sigma>. \\<dots>\\<rbrace>\\<close> is a shorthand to fix the current\nstate: \\<open>{s. \\<sigma> = s \\<dots>}\\<close>. Moreover \\<open>\\<^bsup>\\<sigma>\\<^esup>x\\<close> abbreviates\nthe lookup of variable \\<open>x\\<close> in the state\n\\<open>\\<sigma>\\<close>.\n\nThe approach to specify procedures on lists\nbasically follows \\cite{MehtaN-CADE03}. From the pointer structure\nin the heap we (relationally) abstract to HOL lists of references. Then\nwe can specify further properties on the level of HOL lists, rather then\non the heap. The basic abstractions are:\n\n@{thm [display] Path.simps [no_vars]}\n\n@{term [show_types] \"Path x h y ps\"}: @{term ps} is a list of references that we can obtain\nout of the heap @{term h} by starting with the reference @{term x}, following\nthe references in @{term h} up to the reference @{term y}.\n\n\n@{thm [display] List_def [no_vars]}\n\nA list @{term \"List p h ps\"} is a path starting in @{term p} and ending up\nin @{term Null}.\n\\<close>"], ["", "lemma (in append_impl) append_spec1:\nshows \"\\<forall>\\<sigma> Ps Qs.\n  \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n     \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps Qs.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps \\<and>\n   List \\<acute>q \\<acute>next Qs \\<and>\n   set Ps \\<inter> set Qs = {}\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n                       ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                         \\<acute>q)\n                       FI\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "txt \\<open>@{subgoals [margin=80,display]}\nNote that @{term \"hoare_rule\"} takes care of multiple auxiliary variables!\n@{thm [source] HoarePartial.ProcRec1} has only one auxiliary variable, namely @{term Z}.\nBut the type of @{term Z} can be instantiated arbitrarily. So \\<open>hoare_rule\\<close>\ninstantiates @{term Z} with the tuple @{term \"(\\<sigma>,Ps,Qs)\"} and derives a proper variant\nof the rule. Therefore \\<open>hoare_rule\\<close> depends on the proper quantification of\nauxiliary variables!\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps Qs.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps \\<and>\n   List \\<acute>q \\<acute>next Qs \\<and>\n   set Ps \\<inter> set Qs = {}\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n                       ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                         \\<acute>q)\n                       FI\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps Qs next p q.\n       \\<lbrakk>List p next Ps; List q next Qs;\n        set Ps \\<inter> set Qs = {}\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          List q next (Ps @ Qs) \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              next x = next x)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Psa.\n                              List (next p) next Psa \\<and>\n                              (\\<exists>Qsa.\n                                  List q next Qsa \\<and>\n                                  set Psa \\<inter> set Qsa = {} \\<and>\n                                  (\\<forall>nexta pa.\nList pa nexta (Psa @ Qsa) \\<and>\n(\\<forall>x.\n    x \\<notin> set Psa \\<longrightarrow> nexta x = next x) \\<longrightarrow>\nList p (nexta(p := pa)) (Ps @ Qs) \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow> (nexta(p := pa)) x = next x)))))", "txt \\<open>@{subgoals [display]}\nFor each branch of the \\<open>IF\\<close> statement we have one conjunct to prove. The\n\\<open>THEN\\<close> branch starts with \\<open>p = Null \\<longrightarrow> \\<dots>\\<close> and the \\<open>ELSE\\<close> branch\nwith \\<open>p \\<noteq> Null \\<longrightarrow> \\<dots>\\<close>. Let us focus on the \\<open>ELSE\\<close> branch, were the\nrecursive call to append occurs. First of all we have to prove that the precondition for\nthe recursive call is fulfilled. That means we have to provide some witnesses for\nthe lists @{term Psa} and @{term Qsa} which are referenced by \\<open>p\\<rightarrow>next\\<close> (now\nwritten as @{term \"next p\"}) and @{term q}. Then we have to show that we can\nderive the overall postcondition from the postcondition of the recursive call. The\nstate components that have changed by the recursive call are the ones with the suffix\n\\<open>a\\<close>, like \\<open>nexta\\<close> and \\<open>pa\\<close>.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps Qs next p q.\n       \\<lbrakk>List p next Ps; List q next Qs;\n        set Ps \\<inter> set Qs = {}\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          List q next (Ps @ Qs) \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              next x = next x)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Psa.\n                              List (next p) next Psa \\<and>\n                              (\\<exists>Qsa.\n                                  List q next Qsa \\<and>\n                                  set Psa \\<inter> set Qsa = {} \\<and>\n                                  (\\<forall>nexta pa.\nList pa nexta (Psa @ Qsa) \\<and>\n(\\<forall>x.\n    x \\<notin> set Psa \\<longrightarrow> nexta x = next x) \\<longrightarrow>\nList p (nexta(p := pa)) (Ps @ Qs) \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow> (nexta(p := pa)) x = next x)))))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>If the verification condition generator works on a procedure\ncall it checks whether it can find a modifies clause in the\ncontext. If one is present the procedure call is simplified before the\nHoare rule @{thm [source] HoarePartial.ProcSpec} is\napplied. Simplification of the procedure call means that the ``copy\nback'' of the global components is simplified. Only those components\nthat occur in the modifies clause are actually copied back.  This\nsimplification is justified by the rule @{thm [source]\nHoarePartial.ProcModifyReturn}.\nSo after this simplification all global\ncomponents that do not appear in the modifies clause are treated\nas local variables.\\<close>"], ["", "text \\<open>We study the effect of the modifies clause on the following\nexamples, where we want to prove that @{term \"append\"} does not change\nthe @{term \"cont\"} part of the heap.\n\\<close>"], ["", "lemma (in append_impl)\nshows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>cont=c\\<rbrace> \\<acute>p :== CALL append(Null,Null) \\<lbrace>\\<acute>cont=c\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(Null,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(Null,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "note append_spec = append_spec1"], ["proof (state)\nthis:\n  \\<forall>\\<sigma> Ps Qs.\n     \\<Gamma>\n        \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n   Ps \\<and>\n  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n                     \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n                     \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                              (\\<forall>x.\n                                  x \\<notin> set Ps \\<longrightarrow>\n                                  x\\<rightarrow>\\<acute>next =\n                                  \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(Null,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(Null,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next.\n       \\<exists>Ps.\n          List Null next Ps \\<and>\n          (\\<exists>Qs.\n              List Null next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              (\\<forall>conta nexta p.\n                  List p nexta (Ps @ Qs) \\<and>\n                  (\\<forall>x.\n                      x \\<notin> set Ps \\<longrightarrow>\n                      nexta x = next x) \\<longrightarrow>\n                  conta = cont))", "txt \\<open>@{subgoals [display]}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next.\n       \\<exists>Ps.\n          List Null next Ps \\<and>\n          (\\<exists>Qs.\n              List Null next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              (\\<forall>conta nexta p.\n                  List p nexta (Ps @ Qs) \\<and>\n                  (\\<forall>x.\n                      x \\<notin> set Ps \\<longrightarrow>\n                      nexta x = next x) \\<longrightarrow>\n                  conta = cont))", "txt \\<open>Only focus on the very last line: @{term conta} is the heap component\n      after the procedure call,\n      and @{term cont} the heap component before the procedure call. Since\n      we have not added the modified clause we do not know that they have\n      to be equal.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next.\n       \\<exists>Ps.\n          List Null next Ps \\<and>\n          (\\<exists>Qs.\n              List Null next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              (\\<forall>conta nexta p.\n                  List p nexta (Ps @ Qs) \\<and>\n                  (\\<forall>x.\n                      x \\<notin> set Ps \\<longrightarrow>\n                      nexta x = next x) \\<longrightarrow>\n                  conta = cont))", "oops"], ["", "text \\<open>\nWe now add the frame condition.\nThe list in the modifies clause names all global state components that\nmay be changed by the procedure. Note that we know from the modifies clause\nthat the @{term cont} parts are not changed. Also a small\nside note on the syntax. We use ordinary brackets in the postcondition\nof the modifies clause, and also the state components do not carry the\nacute, because we explicitly note the state @{term t} here.\n\\<close>"], ["", "lemma (in append_impl) append_modifies:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>} \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n             {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n      (_Collect t (t may_only_modify_globals \\<sigma> in [next]))", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, append_'proc,\n                      _Collect t\n                       (t may_only_modify_globals \\<sigma> in [next]),\n                      {})})\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n      ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n        \\<acute>q)\n      FI\n      (_Collect t (t may_only_modify_globals \\<sigma> in [next]))", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We tell the verification condition generator to use only the\nmodifies clauses and not to search for functional specifications by\nthe parameter \\<open>spec=modifies\\<close>. It also tries to solve the\nverification conditions automatically. Again it is crucial to name\nthe lemma with this naming scheme, since the verfication condition\ngenerator searches for these names.\n\\<close>"], ["", "text \\<open>The modifies clause is equal to a state update specification\nof the following form.\n\\<close>"], ["", "lemma (in append_impl) shows \"{t. t may_only_modify_globals Z in [next]}\n       =\n       {t. \\<exists>next. globals t=update id id next_' (K_statefun next) (globals Z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect t (t may_only_modify_globals Z in [next]) =\n    _Collect t\n     (\\<exists>next.\n         globals t = update id id next_' (K_statefun next) (globals Z))", "apply (unfold mex_def meq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect t\n     (\\<exists>next_'a.\n         globals t = update id id next_' (K_statefun next_'a) (globals Z)) =\n    _Collect t\n     (\\<exists>next.\n         globals t = update id id next_' (K_statefun next) (globals Z))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Now that we have proven the frame-condition, it is available within\nthe locale \\<open>append_impl\\<close> and the \\<open>vcg\\<close> exploits it.\\<close>"], ["", "lemma (in append_impl)\nshows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>cont=c\\<rbrace> \\<acute>p :== CALL append(Null,Null) \\<lbrace>\\<acute>cont=c\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(Null,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(Null,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "note append_spec = append_spec1"], ["proof (state)\nthis:\n  \\<forall>\\<sigma> Ps Qs.\n     \\<Gamma>\n        \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n   Ps \\<and>\n  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n                     \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n                     \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                              (\\<forall>x.\n                                  x \\<notin> set Ps \\<longrightarrow>\n                                  x\\<rightarrow>\\<acute>next =\n                                  \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(Null,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(Null,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next.\n       \\<exists>Ps.\n          List Null next Ps \\<and>\n          (\\<exists>Qs.\n              List Null next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              (\\<forall>nexta p.\n                  List p nexta (Ps @ Qs) \\<and>\n                  (\\<forall>x.\n                      x \\<notin> set Ps \\<longrightarrow>\n                      nexta x = next x) \\<longrightarrow>\n                  cont = cont))", "txt \\<open>@{subgoals [display]}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next.\n       \\<exists>Ps.\n          List Null next Ps \\<and>\n          (\\<exists>Qs.\n              List Null next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              (\\<forall>nexta p.\n                  List p nexta (Ps @ Qs) \\<and>\n                  (\\<forall>x.\n                      x \\<notin> set Ps \\<longrightarrow>\n                      nexta x = next x) \\<longrightarrow>\n                  cont = cont))", "txt \\<open>With a modifies clause present we know that no change to @{term cont}\n      has occurred.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next.\n       \\<exists>Ps.\n          List Null next Ps \\<and>\n          (\\<exists>Qs.\n              List Null next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              (\\<forall>nexta p.\n                  List p nexta (Ps @ Qs) \\<and>\n                  (\\<forall>x.\n                      x \\<notin> set Ps \\<longrightarrow>\n                      nexta x = next x) \\<longrightarrow>\n                  cont = cont))", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>cont = c\\<rbrace>\n                  \\<acute>p :== CALL append(Null,Null)\n                  \\<lbrace>\\<acute>cont = c\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nOf course we could add the modifies clause to the functional specification as\nwell. But separating both has the advantage that we split up the verification\nwork. We can make use of the modifies clause before we apply the\nfunctional specification in a fully automatic fashion.\n\\<close>"], ["", "text \\<open>\nTo prove that a procedure respects the modifies clause, we only need\nthe modifies clauses of the procedures called in the body. We do not need\nthe functional specifications. So we can always prove the modifies\nclause without functional specifications, but we may need the modifies\nclause to prove the functional specifications. So usually the modifies clause is\nproved before the proof of the functional specification, so that it can already be used\nby the verification condition generator.\n\\<close>"], ["", "subsection \\<open>Total Correctness\\<close>"], ["", "text \\<open>When proving total correctness the additional proof burden to\nthe user is to come up with a well-founded relation and to prove that\ncertain states get smaller according to this relation. Proving that a\nrelation is well-founded can be quite hard. But fortunately there are\nways to construct and stick together relations so that they are\nwell-founded by construction. This infrastructure is already present\nin Isabelle/HOL.  For example, @{term \"measure f\"} is always well-founded;\nthe lexicographic product of two well-founded relations is again\nwell-founded and the inverse image construction @{term \"inv_image\"} of\na well-founded relation is again well-founded. The constructions are\nbest explained by some equations:\n\n@{thm in_measure_iff [no_vars]}\\\\\n@{thm in_lex_iff [no_vars]}\\\\\n@{thm in_inv_image_iff [no_vars]}\n\nAnother useful construction is \\<open><*mlex*>\\<close> which is a combination\nof a measure and a lexicographic product:\n\n@{thm in_mlex_iff [no_vars]}\\\\\nIn contrast to the lexicographic product it does not construct a product type.\nThe state may either decrease according to the measure function @{term f} or the\nmeasure stays the same and the state decreases because of the relation @{term r}.\n\nLets look at a loop:\n\\<close>"], ["", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n       WHILE \\<acute>M \\<noteq> a\n       INV \\<lbrace>\\<acute>S = \\<acute>M * b \\<and> \\<acute>M \\<le> a\\<rbrace>\n       VAR MEASURE a - \\<acute>M\n       DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n       \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M = 0 \\<and>\n                                     \\<acute>S = 0\\<rbrace>\n                            WHILE \\<acute>M \\<noteq> a\n                            INV \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n   \\<acute>M \\<le> a\\<rbrace>\n                            VAR measure\n                                 (\\<lambda>s. a - (locals s\\<cdot>M_')) \n                            DO \\<acute>S :== \\<acute>S + b;;\n                               \\<acute>M :== \\<acute>M + 1 \n                            OD\n                            \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S.\n       \\<lbrakk>M = 0; S = 0\\<rbrakk>\n       \\<Longrightarrow> S = M * b \\<and> M \\<le> a\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<le> a; M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> a - (M + 1) < a - M \\<and>\n                         S + b = (M + 1) * b \\<and> M + 1 \\<le> a\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<le> a; \\<not> M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S = a * b", "txt \\<open>@{subgoals [display]}\nThe first conjunct of the second subgoal is the proof obligation that the\nvariant decreases in the loop body.\n\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S.\n       \\<lbrakk>M = 0; S = 0\\<rbrakk>\n       \\<Longrightarrow> S = M * b \\<and> M \\<le> a\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<le> a; M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> a - (M + 1) < a - M \\<and>\n                         S + b = (M + 1) * b \\<and> M + 1 \\<le> a\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<le> a; \\<not> M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S = a * b", "by auto"], ["", "text \\<open>The variant annotation is preceded by \\<open>VAR\\<close>. The capital \\<open>MEASURE\\<close>\nis a shorthand for \\<open>measure (\\<lambda>s. a - \\<^bsup>s\\<^esup>M)\\<close>. Analogous there is a capital\n\\<open><*MLEX*>\\<close>.\n\\<close>"], ["", "lemma (in Fac_impl) Fac_spec':\nshows \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} \\<acute>R :==  PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                               \\<lbrace>\\<acute>R =\n  fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply (hoare_rule HoareTotal.ProcRec1 [where r=\"measure (\\<lambda>(s,p). \\<^bsup>s\\<^esup>N)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N\n                               < \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>'\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                               ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                                 \\<acute>R :== \\<acute>N * \\<acute>R\n                               FI\n                               \\<lbrace>\\<acute>R =\n  fac \\<^bsup>\\<sigma>'\\<^esup>N\\<rbrace>", "txt \\<open>In case of the factorial the parameter @{term N} decreases in every call. This\nis easily expressed by the measure function. Note that the well-founded relation for\nrecursive procedures is formally defined on tuples\ncontaining the state space and the procedure name.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N\n                               < \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>'\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                               ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                                 \\<acute>R :== \\<acute>N * \\<acute>R\n                               FI\n                               \\<lbrace>\\<acute>R =\n  fac \\<^bsup>\\<sigma>'\\<^esup>N\\<rbrace>", "txt \\<open>@{subgoals [display]}\nThe initial call to the factorial is in state @{term \"\\<sigma>\"}. Note that in the\nprecondition @{term \"{\\<sigma>} \\<inter> {\\<sigma>'}\"}, @{term \"\\<sigma>'\"} stems from the lemma we want to prove\nand @{term \"\\<sigma>\"} stems from the recursion rule for total correctness. Both are\nsynonym for the initial state. To use the assumption in the Hoare context we\nhave to show that the call to the factorial is invoked on a smaller @{term N} compared\nto the initial \\<open>\\<^bsup>\\<sigma>\\<^esup>N\\<close>.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N\n                               < \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>'\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                               ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                                 \\<acute>R :== \\<acute>N * \\<acute>R\n                               FI\n                               \\<lbrace>\\<acute>R =\n  fac \\<^bsup>\\<sigma>'\\<^esup>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        N - 1 < N \\<and>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "txt \\<open>@{subgoals [display]}\nThe tribute to termination is that we have to show \\<open>N - 1 < N\\<close> in case of\nthe recursive call.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        N - 1 < N \\<and>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "by simp"], ["", "lemma (in append_impl) append_spec2:\nshows \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\\<^sub>t\n  \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n  \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. List \\<acute>p\n             \\<acute>next Ps \\<and>\n            List \\<acute>q \\<acute>next Qs \\<and>\n            set Ps \\<inter> set Qs = {}\\<rbrace>\n                               \\<acute>p :== PROC append(\\<acute>p,\n                               \\<acute>q)\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (Ps @ Qs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Ps \\<longrightarrow>\n      x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoareTotal.ProcRec1\n           [where r=\"measure (\\<lambda>(s,p). length (list \\<^bsup>s\\<^esup>p \\<^bsup>s\\<^esup>next))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>' Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma>' Ps Qs.\n                    {(\\<lbrace>\\<sigma>'. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace> \\<inter>\n                      \\<lbrace>length (list \\<acute>p \\<acute>next)\n                               < length\n                                  (list \\<^bsup>\\<sigma>\\<^esup>p\n                                    \\<^bsup>\\<sigma>\\<^esup>next)\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>'\\<^esup>next\n                                    x)\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                \\<lbrace>\\<sigma>'. List \\<acute>p\n               \\<acute>next Ps \\<and>\n              List \\<acute>q \\<acute>next Qs \\<and>\n              set Ps \\<inter> set Qs = {}\\<rbrace>)\n                               IF \\<acute>p = Null\n                               THEN \\<acute>p :== \\<acute>q\n                               ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                                 \\<acute>q)\n                               FI\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (Ps @ Qs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Ps \\<longrightarrow>\n      x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>'\\<^esup>next x)\\<rbrace>", "txt \\<open>In case of the append function the length of the list referenced by @{term p}\ndecreases in every recursive call.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>' Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma>' Ps Qs.\n                    {(\\<lbrace>\\<sigma>'. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace> \\<inter>\n                      \\<lbrace>length (list \\<acute>p \\<acute>next)\n                               < length\n                                  (list \\<^bsup>\\<sigma>\\<^esup>p\n                                    \\<^bsup>\\<sigma>\\<^esup>next)\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>'\\<^esup>next\n                                    x)\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                \\<lbrace>\\<sigma>'. List \\<acute>p\n               \\<acute>next Ps \\<and>\n              List \\<acute>q \\<acute>next Qs \\<and>\n              set Ps \\<inter> set Qs = {}\\<rbrace>)\n                               IF \\<acute>p = Null\n                               THEN \\<acute>p :== \\<acute>q\n                               ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                                 \\<acute>q)\n                               FI\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (Ps @ Qs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Ps \\<longrightarrow>\n      x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>'\\<^esup>next x)\\<rbrace>", "txt \\<open>@{subgoals [margin=80,display]}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>' Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma>' Ps Qs.\n                    {(\\<lbrace>\\<sigma>'. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace> \\<inter>\n                      \\<lbrace>length (list \\<acute>p \\<acute>next)\n                               < length\n                                  (list \\<^bsup>\\<sigma>\\<^esup>p\n                                    \\<^bsup>\\<sigma>\\<^esup>next)\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>'\\<^esup>next\n                                    x)\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                \\<lbrace>\\<sigma>'. List \\<acute>p\n               \\<acute>next Ps \\<and>\n              List \\<acute>q \\<acute>next Qs \\<and>\n              set Ps \\<inter> set Qs = {}\\<rbrace>)\n                               IF \\<acute>p = Null\n                               THEN \\<acute>p :== \\<acute>q\n                               ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                                 \\<acute>q)\n                               FI\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (Ps @ Qs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Ps \\<longrightarrow>\n      x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>'\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps Qs next p q.\n       \\<lbrakk>List p next Ps; List q next Qs;\n        set Ps \\<inter> set Qs = {}\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          List q next (Ps @ Qs) \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              next x = next x)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Psa.\n                              List (next p) next Psa \\<and>\n                              (\\<exists>Qsa.\n                                  List q next Qsa \\<and>\n                                  set Psa \\<inter> set Qsa = {} \\<and>\n                                  length (list (next p) next)\n                                  < length (list p next) \\<and>\n                                  (\\<forall>nexta pa.\nList pa nexta (Psa @ Qsa) \\<and>\n(\\<forall>x.\n    x \\<notin> set Psa \\<longrightarrow> nexta x = next x) \\<longrightarrow>\nList p (nexta(p := pa)) (Ps @ Qs) \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow> (nexta(p := pa)) x = next x)))))", "apply (fastforce simp add: List_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nIn case of the lists above, we have used a relational list abstraction @{term List}\nto construct the HOL lists @{term Ps} and @{term Qs} for the pre- and postcondition.\nTo supply a proper measure function we use a functional abstraction @{term list}.\nThe functional abstraction can be defined by means of the relational list abstraction,\nsince the lists are already uniquely determined by the relational abstraction:\n\n@{thm islist_def [no_vars]}\\\\\n@{thm list_def [no_vars]}\n\n\\isacommand{lemma} @{thm List_conv_islist_list [no_vars]}\n\\<close>"], ["", "text \\<open>\nThe next contrived example is taken from \\cite{Homeier-95-vcg}, to illustrate\na more complex termination criterion for mutually recursive procedures. The procedures\ndo not calculate anything useful.\n\n\\<close>"], ["", "procedures\n  pedal(N::nat,M::nat)\n  \"IF 0 < \\<acute>N THEN\n     IF 0 < \\<acute>M THEN\n       CALL coast(\\<acute>N- 1,\\<acute>M- 1) FI;;\n       CALL pedal(\\<acute>N- 1,\\<acute>M)\n     FI\"\n  and\n\n  coast(N::nat,M::nat)\n  \"CALL pedal(\\<acute>N,\\<acute>M);;\n   IF 0 < \\<acute>M THEN CALL coast(\\<acute>N,\\<acute>M- 1) FI\""], ["", "text \\<open>\nIn the recursive calls in procedure \\<open>pedal\\<close> the first argument always decreases.\nIn the body of \\<open>coast\\<close> in the recursive call of \\<open>coast\\<close> the second\nargument decreases, but in the call to \\<open>pedal\\<close> no argument decreases.\nTherefore an relation only on the state space is insufficient. We have to\ntake the procedure names into account, too.\nWe consider the procedure \\<open>coast\\<close> to be ``bigger'' than \\<open>pedal\\<close>\nwhen we construct a well-founded relation on the product of state space and procedure\nnames.\n\\<close>"], ["", "ML \\<open>ML_Thms.bind_thm (\"HoareTotal_ProcRec2\", Hoare.gen_proc_rec @{context} Hoare.Total 2)\\<close>"], ["", "text \\<open>\n  We provide the ML function {\\tt gen\\_proc\\_rec} to\nautomatically derive a convenient rule for recursion for a given number of mutually\nrecursive procedures.\n\\<close>"], ["", "lemma (in pedal_coast_clique)\nshows \"(\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M) UNIV) \\<and>\n         (\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<sigma>.\n        \\<Gamma>\n           \\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M)\n                                UNIV) \\<and>\n    (\\<forall>\\<sigma>.\n        \\<Gamma>\n           \\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M)\n                                UNIV)", "apply (hoare_rule HoareTotal_ProcRec2\n            [where r= \"((\\<lambda>(s,p). \\<^bsup>s\\<^esup>N) <*mlex*>\n                           (\\<lambda>(s,p). \\<^bsup>s\\<^esup>M) <*mlex*>\n                           measure (\\<lambda>(s,p). if p = coast_'proc then 1 else 0))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               UNIV", "txt \\<open>We can directly express the termination condition described above with\n  the \\<open><*mlex*>\\<close> construction. Either state component \\<open>N\\<close> decreases,\n  or it stays the same and \\<open>M\\<close> decreases or this also stays the same, but\n  then the procedure name has to decrease.\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               UNIV", "txt \\<open>@{subgoals [margin=80,display]}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               UNIV", "apply  simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M =\n                                \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - Suc 0)\n                               FI\n                               UNIV", "txt \\<open>@{subgoals [margin=75,display]}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M =\n                                \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - Suc 0)\n                               FI\n                               UNIV", "by (vcg,simp)+"], ["", "text \\<open>We can achieve the same effect without \\<open><*mlex*>\\<close> by using\n the ordinary lexicographic product \\<open><*lex*>\\<close>, \\<open>inv_image\\<close> and\n \\<open>measure\\<close>\n\\<close>"], ["", "lemma (in pedal_coast_clique)\nshows \"(\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M) UNIV) \\<and>\n         (\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<sigma>.\n        \\<Gamma>\n           \\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M)\n                                UNIV) \\<and>\n    (\\<forall>\\<sigma>.\n        \\<Gamma>\n           \\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M)\n                                UNIV)", "apply (hoare_rule HoareTotal_ProcRec2\n          [where r= \"inv_image (measure (\\<lambda>m. m) <*lex*>\n                                        measure (\\<lambda>m. m) <*lex*>\n                                        measure (\\<lambda>p. if p = coast_'proc then 1 else 0))\n                           (\\<lambda>(s,p). (\\<^bsup>s\\<^esup>N,\\<^bsup>s\\<^esup>M,p))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               UNIV", "txt \\<open>With the lexicographic product we construct a well-founded relation on\n         triples of type @{typ \"(nat\\<times>nat\\<times>string)\"}. With @{term inv_image} we project\n         the components out of the state-space and the procedure names to this\n         triple.\n\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               UNIV", "txt \\<open>@{subgoals [margin=75,display]}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if pedal_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if pedal_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                (if coast_'proc = coast_'proc then 1 else 0)\n                                < (if coast_'proc = coast_'proc then 1\n                                   else 0))\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               UNIV", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                                \\<acute>M =\n                                \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                               \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                               \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - Suc 0)\n                               FI\n                               UNIV", "by (vcg,force)+"], ["", "text \\<open>By doing some arithmetic we can express the termination condition with a single\nmeasure function.\n\\<close>"], ["", "lemma (in pedal_coast_clique)\nshows \"(\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M) UNIV) \\<and>\n         (\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<sigma>.\n        \\<Gamma>\n           \\<turnstile>\\<^sub>t {\\<sigma>} PROC pedal(\\<acute>N,\\<acute>M)\n                                UNIV) \\<and>\n    (\\<forall>\\<sigma>.\n        \\<Gamma>\n           \\<turnstile>\\<^sub>t {\\<sigma>} PROC coast(\\<acute>N,\\<acute>M)\n                                UNIV)", "apply(hoare_rule HoareTotal_ProcRec2\n       [where r= \"measure (\\<lambda>(s,p). \\<^bsup>s\\<^esup>N + \\<^bsup>s\\<^esup>M + (if p = coast_'proc then 1 else 0))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M +\n                               (if pedal_'proc = coast_'proc then 1 else 0)\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M +\n                                 (if pedal_'proc = coast_'proc then 1\n                                  else 0)\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M +\n                               (if coast_'proc = coast_'proc then 1 else 0)\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M +\n                                 (if pedal_'proc = coast_'proc then 1\n                                  else 0)\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M +\n                               (if pedal_'proc = coast_'proc then 1 else 0)\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M +\n                                 (if coast_'proc = coast_'proc then 1\n                                  else 0)\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M +\n                               (if coast_'proc = coast_'proc then 1 else 0)\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M +\n                                 (if coast_'proc = coast_'proc then 1\n                                  else 0)\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               UNIV", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>Suc (\\<acute>N + \\<acute>M)\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M\n                               < Suc (\\<^bsup>\\<sigma>\\<^esup>N +\n\\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - Suc 0)\n                               FI\n                               UNIV", "txt \\<open>@{subgoals [margin=75,display]}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>Suc (\\<acute>N + \\<acute>M)\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0,\\<acute>M)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M\n                               < Suc (\\<^bsup>\\<sigma>\\<^esup>N +\n\\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>,\n                      pedal_'proc, UNIV, {})}) \\<union>\n                (\\<Union>x.\n                    {({x} \\<inter>\n                      \\<lbrace>\\<acute>N + \\<acute>M\n                               < \\<^bsup>\\<sigma>\\<^esup>N +\n                                 \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                      coast_'proc, UNIV, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - Suc 0)\n                               FI\n                               UNIV", "by (vcg,simp,arith?)+"], ["", "subsection \\<open>Guards\\<close>"], ["", "text (in vars) \\<open>The purpose of a guard is to guard the {\\bf (sub-) expressions} of a\nstatement against runtime faults. Typical runtime faults are array bound violations,\ndereferencing null pointers or arithmetical overflow. Guards make the potential\nruntime faults explicit, since the expressions themselves never ``fail'' because\nthey are ordinary HOL expressions. To relieve the user from typing in lots of standard\nguards for every subexpression, we supply some input syntax for the common\nlanguage constructs that automatically generate the guards.\nFor example the guarded assignment \\<open>\\<acute>M :==\\<^sub>g (\\<acute>M + 1) div \\<acute>N\\<close> gets expanded to\nguarded command @{term \"\\<acute>M :==\\<^sub>g (\\<acute>M + 1) div \\<acute>N\"}. Here @{term \"in_range\"} is\nuninterpreted by now.\n\\<close>"], ["", "lemma (in vars) \"\\<Gamma>\\<turnstile>\\<lbrace>True\\<rbrace> \\<acute>M :==\\<^sub>g (\\<acute>M + 1) div \\<acute>N \\<lbrace>True\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    (False,\n                     \\<lbrace>in_range (\\<acute>M + 1) \\<and>\n                              \\<acute>N \\<noteq> 0 \\<and>\n                              in_range\n                               ((\\<acute>M + 1) div \\<acute>N)\\<rbrace>)\n                    \\<longmapsto> \\<acute>M :==\n                                  (\\<acute>M + 1) div \\<acute>N\n                    \\<lbrace>True\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N.\n       True \\<Longrightarrow>\n       in_range (M + 1) \\<and> N \\<noteq> 0 \\<and> in_range ((M + 1) div N)", "txt \\<open>@{subgoals}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N.\n       True \\<Longrightarrow>\n       in_range (M + 1) \\<and> N \\<noteq> 0 \\<and> in_range ((M + 1) div N)", "oops"], ["", "text \\<open>\nThe user can supply on (overloaded) definition of \\<open>in_range\\<close>\nto fit to his needs.\n\nCurrently guards are generated for:\n\n\\begin{itemize}\n\\item overflow and underflow of numbers (\\<open>in_range\\<close>). For subtraction of\n      natural numbers \\<open>a - b\\<close> the guard \\<open>b \\<le> a\\<close> is generated instead\n      of \\<open>in_range\\<close> to guard against underflows.\n\\item division by \\<open>0\\<close>\n\\item dereferencing of @{term Null} pointers\n\\item array bound violations\n\\end{itemize}\n\nFollowing (input) variants of guarded statements are available:\n\n\\begin{itemize}\n\\item Assignment: \\<open>\\<dots> :==\\<^sub>g \\<dots>\\<close>\n\\item If: \\<open>IF\\<^sub>g \\<dots>\\<close>\n\\item While: \\<open>WHILE\\<^sub>g \\<dots>\\<close>\n\\item Call: \\<open>CALL\\<^sub>g \\<dots>\\<close> or \\<open>\\<dots> :== CALL\\<^sub>g \\<dots>\\<close>\n\\end{itemize}\n\\<close>"], ["", "subsection \\<open>Miscellaneous Techniques\\<close>"], ["", "subsubsection \\<open>Modifies Clause\\<close>"], ["", "text \\<open>We look at some issues regarding the modifies clause with the example\nof insertion sort for heap lists.\n\\<close>"], ["", "primrec sorted:: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list  \\<Rightarrow> bool\"\nwhere\n\"sorted le [] = True\" |\n\"sorted le (x#xs) = ((\\<forall>y\\<in>set xs. le x y) \\<and> sorted le xs)\""], ["", "procedures (imports globals_heap)\n  insert(r::ref,p::ref | p::ref)\n    \"IF \\<acute>r=Null THEN SKIP\n     ELSE IF \\<acute>p=Null THEN \\<acute>p :== \\<acute>r;; \\<acute>p\\<rightarrow>\\<acute>next :== Null\n          ELSE IF \\<acute>r\\<rightarrow>\\<acute>cont \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n               THEN \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>p;; \\<acute>p:==\\<acute>r\n               ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL insert(\\<acute>r,\\<acute>p\\<rightarrow>\\<acute>next)\n               FI\n          FI\n     FI\""], ["", "lemma (in insert_impl) insert_modifies:\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>} \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n        {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n      (_Collect t (t may_only_modify_globals \\<sigma> in [next]))", "by (hoare_rule HoarePartial.ProcRec1) (vcg spec=modifies)"], ["", "lemma (in insert_impl) insert_spec:\n  \"\\<forall>\\<sigma> Ps . \\<Gamma>\\<turnstile>\n  \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and> sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n      \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n    \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n  \\<lbrace>\\<exists>Qs. List \\<acute>p \\<acute>next Qs \\<and> sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont  Qs) \\<and>\n        set Qs = insert \\<^bsup>\\<sigma>\\<^esup>r (set Ps) \\<and>\n        (\\<forall>x. x \\<notin> set Qs \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    UserGuide.sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n    \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n                       \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   UserGuide.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs =\n                                   {\\<^bsup>\\<sigma>\\<^esup>r} \\<union>\n                                   set Ps \\<and>\n                                   (\\<forall>x.\n x \\<notin> set Qs \\<longrightarrow>\n x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    UserGuide.sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n    \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n                       \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   UserGuide.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs =\n                                   {\\<^bsup>\\<sigma>\\<^esup>r} \\<union>\n                                   set Ps \\<and>\n                                   (\\<forall>x.\n x \\<notin> set Qs \\<longrightarrow>\n x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps \\<and>\n   UserGuide.sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n   \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>,\n                      insert_'proc,\n                      \\<lbrace>\\<exists>Qs.\n                                  List \\<acute>p \\<acute>next Qs \\<and>\n                                  UserGuide.sorted (\\<le>)\n                                   (map \\<^bsup>\\<sigma>\\<^esup>cont\n                                     Qs) \\<and>\n                                  set Qs =\n                                  {\\<^bsup>\\<sigma>\\<^esup>r} \\<union>\n                                  set Ps \\<and>\n                                  (\\<forall>x.\nx \\<notin> set Qs \\<longrightarrow>\nx\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    UserGuide.sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n    \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n                       IF \\<acute>r = Null THEN SKIP\n                       ELSE IF \\<acute>p = Null\n                            THEN \\<acute>p :== \\<acute>r;;\n                              \\<acute>p\\<rightarrow>\\<acute>next :== Null\n                            ELSE IF \\<acute>r\\<rightarrow>\\<acute>cont\n                                    \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n                                 THEN \\<acute>r\\<rightarrow>\\<acute>next :==\n\\<acute>p;;\n                                   \\<acute>p :== \\<acute>r\n                                 ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL insert(\\<acute>r,\n                                   \\<acute>p\\<rightarrow>\\<acute>next)\n                                 FI\n                            FI\n                       FI\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   UserGuide.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs =\n                                   {\\<^bsup>\\<sigma>\\<^esup>r} \\<union>\n                                   set Ps \\<and>\n                                   (\\<forall>x.\n x \\<notin> set Qs \\<longrightarrow>\n x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps\\<rbrakk>\n       \\<Longrightarrow> (r = Null \\<longrightarrow>\n                          (\\<exists>Qs.\n                              List p next Qs \\<and>\n                              UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                              set Qs = {r} \\<union> set Ps \\<and>\n                              (\\<forall>x.\n                                  x \\<notin> set Qs \\<longrightarrow>\n                                  next x = next x))) \\<and>\n                         (r \\<noteq> Null \\<longrightarrow>\n                          (p = Null \\<longrightarrow>\n                           (\\<exists>Qs.\n                               List r (next(r := Null)) Qs \\<and>\n                               UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                               set Qs = {r} \\<union> set Ps \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Qs \\<longrightarrow>\n                                   (next(r := Null)) x = next x))) \\<and>\n                          (p \\<noteq> Null \\<longrightarrow>\n                           (cont r \\<le> cont p \\<longrightarrow>\n                            (\\<exists>Qs.\n                                List r (next(r := p)) Qs \\<and>\n                                UserGuide.sorted (\\<le>)\n                                 (map cont Qs) \\<and>\n                                set Qs = {r} \\<union> set Ps \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Qs \\<longrightarrow>\n                                    (next(r := p)) x = next x))) \\<and>\n                           (\\<not> cont r \\<le> cont p \\<longrightarrow>\n                            (\\<exists>Psa.\n                                List (next p) next Psa \\<and>\n                                UserGuide.sorted (\\<le>)\n                                 (map cont Psa) \\<and>\n                                r \\<noteq> Null \\<and>\n                                r \\<notin> set Psa \\<and>\n                                (\\<forall>nexta pa.\n                                    (\\<exists>Qs.\n  List pa nexta Qs \\<and>\n  UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n  set Qs = {r} \\<union> set Psa \\<and>\n  (\\<forall>x.\n      x \\<notin> set Qs \\<longrightarrow>\n      nexta x = next x)) \\<longrightarrow>\n                                    (\\<exists>Qs.\n  List p (nexta(p := pa)) Qs \\<and>\n  UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n  set Qs = {r} \\<union> set Ps \\<and>\n  (\\<forall>x.\n      x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))))))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r = Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p next Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = {r} \\<union> set Ps \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                next x = next x)\n 2. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p = Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := Null)) Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = {r} \\<union> set Ps \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := Null)) x = next x)\n 3. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := p)) Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = {r} \\<union> set Ps \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := p)) x = next x)\n 4. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; \\<not> cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List (next p) next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Psa) \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = {r} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pa)) Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = {r} \\<union> set Ps \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))", "apply    fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p = Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := Null)) Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = {r} \\<union> set Ps \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := Null)) x = next x)\n 2. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := p)) Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = {r} \\<union> set Ps \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := p)) x = next x)\n 3. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; \\<not> cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List (next p) next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Psa) \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = {r} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pa)) Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = {r} \\<union> set Ps \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := p)) Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = {r} \\<union> set Ps \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := p)) x = next x)\n 2. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; \\<not> cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List (next p) next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Psa) \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = {r} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pa)) Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = {r} \\<union> set Ps \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; UserGuide.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; \\<not> cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List (next p) next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Psa) \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = {r} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pa)) Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = {r} \\<union> set Ps \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next p r ps nexta pa Qs.\n       \\<lbrakk>r \\<noteq> Null; p \\<noteq> Null;\n        \\<not> cont r \\<le> cont p; List (next p) next ps;\n        \\<forall>x\\<in>set ps. cont p \\<le> cont x;\n        UserGuide.sorted (\\<le>) (map cont ps); r \\<noteq> p;\n        r \\<notin> set ps; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {r} \\<union> set ps;\n        \\<forall>x.\n           x \\<noteq> r \\<and> x \\<notin> set ps \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            (\\<exists>ps.\n                                Qs = p # ps \\<and>\n                                List pa (nexta(p := pa)) ps) \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = {r, p} \\<union> set ps \\<and>\n                            (\\<forall>x.\n                                (x = p \\<longrightarrow>\n                                 p \\<notin> set Qs \\<longrightarrow>\n                                 pa = next p) \\<and>\n                                (x \\<noteq> p \\<longrightarrow>\n                                 x \\<notin> set Qs \\<longrightarrow>\n                                 nexta x = next x))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text \\<open>\nIn the postcondition of the functional specification there is a small but\nimportant subtlety. Whenever we talk about the @{term \"cont\"} part we refer to\nthe one of the pre-state.\nThe reason is that we have separated out the information that @{term \"cont\"} is not\nmodified by the procedure, to the modifies clause. So whenever we talk about unmodified\nparts in the postcondition we have to use the pre-state part, or explicitly\nstate an equality in the postcondition.\nThe reason is simple. If the postcondition would talk about \\<open>\\<acute>cont\\<close>\ninstead of \\mbox{\\<open>\\<^bsup>\\<sigma>\\<^esup>cont\\<close>}, we get a new instance of \\<open>cont\\<close> during\nverification and the postcondition would only state something about this\nnew instance. But as the verification condition generator uses the\nmodifies clause the caller of @{term \"insert\"} instead still has the\nold \\<open>cont\\<close> after the call. Thats the sense of the modifies clause.\nSo the caller and the specification simply talk about two different things,\nwithout being able to relate them (unless an explicit equality is added to\nthe specification).\n\\<close>"], ["", "subsubsection \\<open>Annotations\\<close>"], ["", "text \\<open>\nAnnotations (like loop invariants)\nare mere syntactic sugar of statements that are used by the \\<open>vcg\\<close>.\nLogically a statement with an annotation is\nequal to the statement without it. Hence annotations can be introduced by the user\nwhile building a proof:\n\n@{thm [source] HoarePartial.annotateI}: @{thm [mode=Rule] HoarePartial.annotateI [no_vars]}\n\nWhen introducing annotations it can easily happen that these mess around with the\nnesting of sequential composition. Then after stripping the annotations the resulting statement\nis no longer syntactically identical to original one, only equivalent modulo associativity of sequential composition. The following rule also deals with this case:\n\n@{thm [source] HoarePartial.annotate_normI}: @{thm [mode=Rule] HoarePartial.annotate_normI [no_vars]}\n\\<close>"], ["", "text_raw \\<open>\\paragraph{Loop Annotations}\n\\mbox{}\n\\medskip\n\n\\mbox{}\n\\<close>"], ["", "procedures (imports globals_heap)\n  insertSort(p::ref| p::ref)\n  where r::ref q::ref in\n    \"\\<acute>r:==Null;;\n     WHILE (\\<acute>p \\<noteq> Null) DO\n       \\<acute>q :== \\<acute>p;;\n       \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n       \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r)\n     OD;;\n     \\<acute>p:==\\<acute>r\""], ["", "lemma (in insertSort_impl) insertSort_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>} \\<acute>p :== PROC insertSort(\\<acute>p)\n    {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>p :== PROC insertSort(\\<acute>p)\n      (_Collect t (t may_only_modify_globals \\<sigma> in [next]))", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, insertSort_'proc,\n                      _Collect t\n                       (t may_only_modify_globals \\<sigma> in [next]),\n                      {})})\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>r :== Null;;\n      WHILE \\<acute>p \\<noteq> Null \n      DO \\<acute>q :== \\<acute>p;;\n         \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r) \n      OD;;\n      \\<acute>p :== \\<acute>r\n      (_Collect t (t may_only_modify_globals \\<sigma> in [next]))", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Insertion sort is not implemented recursively here, but with a\nloop. Note that the while loop is not annotated with an invariant in the\nprocedure definition. The invariant only comes into play during verification.\nTherefore we annotate the loop first, before we run the \\<open>vcg\\<close>.\n\\<close>"], ["", "lemma (in insertSort_impl) insertSort_spec:\nshows \"\\<forall>\\<sigma> Ps.\n  \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<rbrace>\n       \\<acute>p :== PROC insertSort(\\<acute>p)\n     \\<lbrace>\\<exists>Qs. List \\<acute>p \\<acute>next Qs \\<and> sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont Qs) \\<and>\n           set Qs = set Ps\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       \\<acute>p :== PROC insertSort(\\<acute>p)\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   UserGuide.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs = set Ps\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps\\<rbrace>,\n                      insertSort_'proc,\n                      \\<lbrace>\\<exists>Qs.\n                                  List \\<acute>p \\<acute>next Qs \\<and>\n                                  UserGuide.sorted (\\<le>)\n                                   (map \\<^bsup>\\<sigma>\\<^esup>cont\n                                     Qs) \\<and>\n                                  set Qs = set Ps\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       \\<acute>r :== Null;;\n                       WHILE \\<acute>p \\<noteq> Null \n                       DO \\<acute>q :== \\<acute>p;;\n                          \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                          \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r) \n                       OD;;\n                       \\<acute>p :== \\<acute>r\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   UserGuide.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs = set Ps\\<rbrace>", "apply (hoare_rule anno=\n         \"\\<acute>r :== Null;;\n         WHILE \\<acute>p \\<noteq> Null\n         INV \\<lbrace>\\<exists>Qs Rs. List \\<acute>p \\<acute>next Qs \\<and> List \\<acute>r \\<acute>next Rs \\<and>\n                  set Qs \\<inter> set Rs = {} \\<and>\n                  sorted (\\<le>) (map \\<acute>cont Rs) \\<and> set Qs \\<union> set Rs = set Ps \\<and>\n                  \\<acute>cont = \\<^bsup>\\<sigma>\\<^esup>cont \\<rbrace>\n          DO \\<acute>q :== \\<acute>p;; \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;; \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r) OD;;\n          \\<acute>p :== \\<acute>r\" in HoarePartial.annotateI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> Ps.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps\\<rbrace>,\n                      insertSort_'proc,\n                      \\<lbrace>\\<exists>Qs.\n                                  List \\<acute>p \\<acute>next Qs \\<and>\n                                  UserGuide.sorted (\\<le>)\n                                   (map \\<^bsup>\\<sigma>\\<^esup>cont\n                                     Qs) \\<and>\n                                  set Qs = set Ps\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       \\<acute>r :== Null;;\n                       WHILE \\<acute>p \\<noteq> Null\n                       INV \\<lbrace>\\<exists>Qs Rs.\n List \\<acute>p \\<acute>next Qs \\<and>\n List \\<acute>r \\<acute>next Rs \\<and>\n set Qs \\<inter> set Rs = {} \\<and>\n UserGuide.sorted (\\<le>) (map \\<acute>cont Rs) \\<and>\n set Qs \\<union> set Rs = set Ps \\<and>\n \\<acute>cont = \\<^bsup>\\<sigma>\\<^esup>cont\\<rbrace> \n                       DO \\<acute>q :== \\<acute>p;;\n                          \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                          \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r) \n                       OD;;\n                       \\<acute>p :== \\<acute>r\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   UserGuide.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs = set Ps\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps cont next p.\n       List p next Ps \\<Longrightarrow>\n       \\<exists>Qs Rs.\n          List p next Qs \\<and>\n          List Null next Rs \\<and>\n          set Qs \\<inter> set Rs = {} \\<and>\n          UserGuide.sorted (\\<le>) (map cont Rs) \\<and>\n          set Qs \\<union> set Rs = set Ps \\<and> cont = cont\n 2. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = {p} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))\n 3. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r next Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = set Ps", "txt \\<open>\\<open>\\<dots>\\<close>\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps cont next p.\n       List p next Ps \\<Longrightarrow>\n       \\<exists>Qs Rs.\n          List p next Qs \\<and>\n          List Null next Rs \\<and>\n          set Qs \\<inter> set Rs = {} \\<and>\n          UserGuide.sorted (\\<le>) (map cont Rs) \\<and>\n          set Qs \\<union> set Rs = set Ps \\<and> cont = cont\n 2. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = {p} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))\n 3. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r next Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = set Ps", "(*<*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps cont next p.\n       List p next Ps \\<Longrightarrow>\n       \\<exists>Qs Rs.\n          List p next Qs \\<and>\n          List Null next Rs \\<and>\n          set Qs \\<inter> set Rs = {} \\<and>\n          UserGuide.sorted (\\<le>) (map cont Rs) \\<and>\n          set Qs \\<union> set Rs = set Ps \\<and> cont = cont\n 2. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = {p} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))\n 3. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r next Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = set Ps", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = {p} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))\n 2. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r next Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = set Ps", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r next Qs \\<and>\n                            UserGuide.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = set Ps\n 2. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = {p} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            UserGuide.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    UserGuide.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = {p} \\<union> set Psa \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  UserGuide.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List (next p) nexta Qs \\<and>\n                            p \\<notin> set Qs \\<and>\n                            set Qs \\<inter> set Rs = {} \\<and>\n                            {p} \\<union> (set Qs \\<union> set Rs) = set Ps", "apply (rule_tac x=ps in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> List (next p) nexta ps \\<and>\n                         p \\<notin> set ps \\<and>\n                         set ps \\<inter> set Rs = {} \\<and>\n                         {p} \\<union> (set ps \\<union> set Rs) = set Ps", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> List (next p) nexta ps\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union> (set ps \\<union> set Rs) = set Ps", "apply    (rule heap_eq_ListI1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> List (next p)\n                          (?h160 cont Ps next p r ps Rs nexta pa Qs) ps\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set ps.\n                            nexta x =\n                            ?h160 cont Ps next p r ps Rs nexta pa Qs x\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 5. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union> (set ps \\<union> set Rs) = set Ps", "apply     assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set ps. nexta x = next x\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union> (set ps \\<union> set Rs) = set Ps", "apply    clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs x.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x;\n        x \\<in> set ps\\<rbrakk>\n       \\<Longrightarrow> nexta x = next x\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union> (set ps \\<union> set Rs) = set Ps", "apply    (subgoal_tac \"x\\<noteq>p \\<and> x \\<notin> set Rs\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs x.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x;\n        x \\<in> set ps; x \\<noteq> p \\<and> x \\<notin> set Rs\\<rbrakk>\n       \\<Longrightarrow> nexta x = next x\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs x.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x;\n        x \\<in> set ps\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> p \\<and> x \\<notin> set Rs\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 5. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        UserGuide.sorted (\\<le>) (map cont Rs);\n        {p} \\<union> (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        UserGuide.sorted (\\<le>) (map cont Qs);\n        set Qs = {p} \\<union> set Rs;\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union> (set ps \\<union> set Rs) = set Ps", "apply     auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text \\<open>The method \\<open>hoare_rule\\<close> automatically solves the side-condition\n        that the annotated\n        program is the same as the original one after stripping the annotations.\\<close>"], ["", "text_raw \\<open>\\paragraph{Specification Annotations}\n\\mbox{}\n\\medskip\n\n\\mbox{}\n\\<close>"], ["", "text \\<open>\nWhen verifying a larger block of program text, it might be useful to split up\nthe block and to prove the parts in isolation. This is especially useful to\nisolate loops. On the level of the Hoare calculus\nthe parts can then be combined with the consequence rule. To automate this\nprocess we introduce the derived command @{term specAnno}, which allows to introduce\na Hoare tuple (inclusive auxiliary variables) in the program text:\n\n@{thm specAnno_def [no_vars]}\n\nThe whole annotation reduces to the body @{term \"c undefined\"}. The\ntype of the assertions @{term \"P\"}, @{term \"Q\"} and @{term \"A\"} is\n@{typ \"'a \\<Rightarrow> 's set\"} and the type of command @{term c} is @{typ \"'a \\<Rightarrow> ('s,'p,'f) com\"}.\nAll entities formally depend on an auxiliary (logical) variable of type @{typ \"'a\"}.\nThe body @{term \"c\"} formally also depends on this variable, since a nested annotation\nor loop invariant may also depend on this logical variable. But the raw body without\nannotations does not depend on the logical variable. The logical variable is only\nused by the verification condition generator. We express this by defining the\nwhole @{term specAnno} to be equivalent with the body applied to an arbitrary\nvariable.\n\nThe Hoare rule for \\<open>specAnno\\<close> is mainly an instance of the consequence rule:\n\n@{thm [mode=Rule,mode=ParenStmt] HoarePartial.SpecAnno [no_vars]}\n\nThe side-condition @{term \"\\<forall>Z. c Z = c undefined\"} expresses the intention of body @{term c}\nexplained above: The raw body is independent of the auxiliary variable. This\nside-condition is solved automatically by the \\<open>vcg\\<close>. The concrete syntax for\nthis specification annotation is shown in the following example:\n\\<close>"], ["", "lemma (in vars) \"\\<Gamma>\\<turnstile> {\\<sigma>}\n            \\<acute>I :== \\<acute>M;;\n            ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                         \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                        \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n           \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>I :== \\<acute>M;;\n                    ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I =\n            \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                    \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>,\n                    {}\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>", "txt \\<open>With the annotation we can name an intermediate state @{term \\<tau>}. Since the\n       postcondition refers to @{term \"\\<sigma>\"} we have to link the information about\n       the equivalence of \\<open>\\<^bsup>\\<tau>\\<^esup>I\\<close> and \\<open>\\<^bsup>\\<sigma>\\<^esup>M\\<close> in the specification in order\n       to be able to derive the postcondition.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>I :== \\<acute>M;;\n                    ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I =\n            \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                    \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>,\n                    {}\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?R \\<subseteq> \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                            (\\<forall>t.\n                                \\<^bsup>t\\<^esup>M = \\<acute>N \\<and>\n                                \\<^bsup>t\\<^esup>N =\n                                \\<acute>I \\<longrightarrow>\n                                \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                                \\<acute>I =\n                                \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>\n 2. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<tau>. \\<acute>I =\n  \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                       \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                       \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and>\n                                \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n 3. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>I :== \\<acute>M ?R", "apply   vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<tau>. \\<acute>I =\n  \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                       \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                       \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and>\n                                \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n 2. \\<Gamma>\n       \\<turnstile> {\\<sigma>} \\<acute>I :== \\<acute>M\n                    \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                             (\\<forall>t.\n                                 \\<^bsup>t\\<^esup>M = \\<acute>N \\<and>\n                                 \\<^bsup>t\\<^esup>N =\n                                 \\<acute>I \\<longrightarrow>\n                                 \\<acute>N =\n                                 \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>", "txt \\<open>@{subgoals [display]}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<tau>. \\<acute>I =\n  \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                       \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                       \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and>\n                                \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n 2. \\<Gamma>\n       \\<turnstile> {\\<sigma>} \\<acute>I :== \\<acute>M\n                    \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                             (\\<forall>t.\n                                 \\<^bsup>t\\<^esup>M = \\<acute>N \\<and>\n                                 \\<^bsup>t\\<^esup>N =\n                                 \\<acute>I \\<longrightarrow>\n                                 \\<acute>N =\n                                 \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>", "txt \\<open>The first subgoal is the isolated Hoare tuple. The second one is the\n       side-condition of the consequence rule that allows us to derive the outermost\n       pre/post condition from our inserted specification.\n       \\<open>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M\\<close> is the precondition of the specification,\n       The second conjunct is a simplified version of\n       \\<open>\\<forall>t. \\<^bsup>t\\<^esup>M = \\<acute>N \\<and> \\<^bsup>t\\<^esup>N = \\<acute>I \\<longrightarrow> \\<^bsup>t\\<^esup>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<^bsup>t\\<^esup>N = \\<^bsup>\\<sigma>\\<^esup>M\\<close> expressing that the\n       postcondition of the specification implies the outermost postcondition.\n\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<tau>. \\<acute>I =\n  \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                       \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                       \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and>\n                                \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n 2. \\<Gamma>\n       \\<turnstile> {\\<sigma>} \\<acute>I :== \\<acute>M\n                    \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                             (\\<forall>t.\n                                 \\<^bsup>t\\<^esup>M = \\<acute>N \\<and>\n                                 \\<^bsup>t\\<^esup>N =\n                                 \\<acute>I \\<longrightarrow>\n                                 \\<acute>N =\n                                 \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>", "apply  vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M I N. I = M \\<Longrightarrow> N = N \\<and> I = I\n 2. \\<Gamma>\n       \\<turnstile> {\\<sigma>} \\<acute>I :== \\<acute>M\n                    \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                             (\\<forall>t.\n                                 \\<^bsup>t\\<^esup>M = \\<acute>N \\<and>\n                                 \\<^bsup>t\\<^esup>N =\n                                 \\<acute>I \\<longrightarrow>\n                                 \\<acute>N =\n                                 \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>", "txt \\<open>@{subgoals [display]}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M I N. I = M \\<Longrightarrow> N = N \\<and> I = I\n 2. \\<Gamma>\n       \\<turnstile> {\\<sigma>} \\<acute>I :== \\<acute>M\n                    \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                             (\\<forall>t.\n                                 \\<^bsup>t\\<^esup>M = \\<acute>N \\<and>\n                                 \\<^bsup>t\\<^esup>N =\n                                 \\<acute>I \\<longrightarrow>\n                                 \\<acute>N =\n                                 \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>} \\<acute>I :== \\<acute>M\n                    \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                             (\\<forall>t.\n                                 \\<^bsup>t\\<^esup>M = \\<acute>N \\<and>\n                                 \\<^bsup>t\\<^esup>N =\n                                 \\<acute>I \\<longrightarrow>\n                                 \\<acute>N =\n                                 \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N.\n       M = M \\<and>\n       (\\<forall>Ma Na.\n           Ma = N \\<and> Na = M \\<longrightarrow> N = N \\<and> M = M)", "txt \\<open>@{subgoals [display]}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N.\n       M = M \\<and>\n       (\\<forall>Ma Na.\n           Ma = N \\<and> Na = M \\<longrightarrow> N = N \\<and> M = M)", "by simp"], ["", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> {\\<sigma>}\n  \\<acute>I :== \\<acute>M;;\n  ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n    \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n    \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n  \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>I :== \\<acute>M;;\n                    ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I =\n            \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                    \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>,\n                    {}\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M N.\n       M = M \\<and>\n       (\\<forall>Ma Na.\n           Ma = N \\<and> Na = M \\<longrightarrow> N = N \\<and> M = M)\n 2. \\<And>M I N. I = M \\<Longrightarrow> N = N \\<and> I = I", "txt \\<open>@{subgoals [display]}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M N.\n       M = M \\<and>\n       (\\<forall>Ma Na.\n           Ma = N \\<and> Na = M \\<longrightarrow> N = N \\<and> M = M)\n 2. \\<And>M I N. I = M \\<Longrightarrow> N = N \\<and> I = I", "by simp_all"], ["", "text \\<open>Note that \\<open>vcg_step\\<close> changes the order of sequential composition, to\nallow the user to decompose sequences by repeated calls to \\<open>vcg_step\\<close>, whereas\n\\<open>vcg\\<close> preserves the order.\n\nThe above example illustrates how we can introduce a new logical state variable\n@{term \"\\<tau>\"}. You can introduce multiple variables by using a tuple:\n\n\n\n\\<close>"], ["", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> {\\<sigma>}\n   \\<acute>I :== \\<acute>M;;\n   ANNO (n,i,m). \\<lbrace>\\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M \\<and> \\<acute>N=n \\<and> \\<acute>I=i \\<and> \\<acute>M=m\\<rbrace>\n     \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n   \\<lbrace>\\<acute>M = n \\<and> \\<acute>N = i\\<rbrace>\n  \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>I :== \\<acute>M;;\n                    ANNO (n, i,\n                    m). \\<lbrace>\\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                                 \\<acute>N = n \\<and>\n                                 \\<acute>I = i \\<and> \\<acute>M = m\\<rbrace>\n                    \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = n \\<and> \\<acute>N = i\\<rbrace>,{}\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M N.\n       M = M \\<and>\n       (\\<forall>Ma Na.\n           Ma = N \\<and> Na = M \\<longrightarrow> N = N \\<and> M = M)\n 2. \\<And>M I N. I = M \\<Longrightarrow> N = N \\<and> I = I", "txt \\<open>@{subgoals [display]}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M N.\n       M = M \\<and>\n       (\\<forall>Ma Na.\n           Ma = N \\<and> Na = M \\<longrightarrow> N = N \\<and> M = M)\n 2. \\<And>M I N. I = M \\<Longrightarrow> N = N \\<and> I = I", "by simp_all"], ["", "text_raw \\<open>\\paragraph{Lemma Annotations}\n\\mbox{}\n\\medskip\n\n\\mbox{}\n\n\\<close>"], ["", "text \\<open>\nThe specification annotations described before split the verification\ninto several Hoare triples which result in several subgoals. If we\ninstead want to proof the Hoare triples independently as\nseparate lemmas we can use the \\<open>LEMMA\\<close> annotation to plug together the\nlemmas. It\ninserts the lemma in the same fashion as the specification annotation.\n\\<close>"], ["", "lemma (in vars) foo_lemma:\n  \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace> \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n             \\<lbrace>\\<acute>N = n + 1 \\<and> \\<acute>M = m + 1\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n                       \\<acute>N :== \\<acute>N + 1;;\n                       \\<acute>M :== \\<acute>M + 1\n                       \\<lbrace>\\<acute>N = n + 1 \\<and>\n                                \\<acute>M = m + 1\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N. N + 1 = N + 1 \\<and> M + 1 = M + 1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n       LEMMA foo_lemma\n             \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n       END;;\n       \\<acute>N :== \\<acute>N + 1\n       \\<lbrace>\\<acute>N = n + 2 \\<and> \\<acute>M = m + 1\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n                     LEMMA foo_lemma \\<acute>N :== \\<acute>N + 1;;\n                    \\<acute>M :== \\<acute>M + 1 END;;\n                    \\<acute>N :== \\<acute>N + 1\n                    \\<lbrace>\\<acute>N = n + 2 \\<and>\n                             \\<acute>M = m + 1\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N.\n       \\<forall>Ma Na.\n          Na = N + 1 \\<and> Ma = M + 1 \\<longrightarrow>\n          N + 1 + 1 = N + 2 \\<and> M + 1 = M + 1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n           LEMMA foo_lemma\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n           END;;\n           LEMMA foo_lemma\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n           END\n      \\<lbrace>\\<acute>N = n + 2 \\<and> \\<acute>M = m + 2\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n                     LEMMA foo_lemma \\<acute>N :== \\<acute>N + 1;;\n                    \\<acute>M :== \\<acute>M + 1 END;;\n                     LEMMA foo_lemma \\<acute>N :== \\<acute>N + 1;;\n                    \\<acute>M :== \\<acute>M + 1 END\n                    \\<lbrace>\\<acute>N = n + 2 \\<and>\n                             \\<acute>M = m + 2\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N.\n       \\<forall>Ma Na.\n          Na = N + 1 \\<and> Ma = M + 1 \\<longrightarrow>\n          (\\<forall>Ma Na.\n              Na = N + 1 + 1 \\<and> Ma = M + 1 + 1 \\<longrightarrow>\n              N + 1 + 1 = N + 2 \\<and> M + 1 + 1 = M + 2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1;;\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n      \\<lbrace>\\<acute>N = n + 2 \\<and> \\<acute>M = m + 2\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n                    \\<acute>N :== \\<acute>N + 1;;\n                    \\<acute>M :== \\<acute>M + 1;;\n                    \\<acute>N :== \\<acute>N + 1;;\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>N = n + 2 \\<and>\n                             \\<acute>M = m + 2\\<rbrace>", "apply (hoare_rule anno=\n          \"LEMMA foo_lemma\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n           END;;\n           LEMMA foo_lemma\n              \\<acute>N :== \\<acute>N + 1;; \\<acute>M :== \\<acute>M + 1\n           END\"\n          in HoarePartial.annotate_normI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = n \\<and> \\<acute>M = m\\<rbrace>\n                     LEMMA foo_lemma \\<acute>N :== \\<acute>N + 1;;\n                    \\<acute>M :== \\<acute>M + 1 END;;\n                     LEMMA foo_lemma \\<acute>N :== \\<acute>N + 1;;\n                    \\<acute>M :== \\<acute>M + 1 END\n                    \\<lbrace>\\<acute>N = n + 2 \\<and>\n                             \\<acute>M = m + 2\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N.\n       \\<forall>Ma Na.\n          Na = N + 1 \\<and> Ma = M + 1 \\<longrightarrow>\n          (\\<forall>Ma Na.\n              Na = N + 1 + 1 \\<and> Ma = M + 1 + 1 \\<longrightarrow>\n              N + 1 + 1 = N + 2 \\<and> M + 1 + 1 = M + 2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Total Correctness of Nested Loops\\<close>"], ["", "text \\<open>\nWhen proving termination of nested loops it is sometimes necessary to express that\nthe loop variable of the outer loop is not modified in the inner loop. To express this\none has to fix the value of the outer loop variable before the inner loop and use this value\nin the invariant of the inner loop. This can be achieved by surrounding the inner while loop\nwith an \\<open>ANNO\\<close> specification as explained previously. However, this\nleads to repeating the invariant of the inner loop three times: in the invariant itself and\nin the the pre- and postcondition of the \\<open>ANNO\\<close> specification. Moreover one has\nto deal with the additional subgoal introduced by \\<open>ANNO\\<close> that expresses how\nthe pre- and postcondition is connected to the invariant. To avoid this extra specification\nand verification work, we introduce an variant of the annotated while-loop, where one can\nintroduce logical variables by \\<open>FIX\\<close>. As for the \\<open>ANNO\\<close> specification\nmultiple logical variables can be introduced via a tuple (\\<open>FIX (a,b,c).\\<close>).\n\nThe Hoare logic rule for the augmented while-loop is a mixture of the invariant rule for\nloops and the consequence rule for \\<open>ANNO\\<close>:\n\n\\begin{center}\n@{thm [mode=Rule,mode=ParenStmt] HoareTotal.WhileAnnoFix' [no_vars]}\n\\end{center}\n\nThe first premise expresses that the precondition implies the invariant and that\nthe invariant together with the negated loop condition implies the postcondition. Since\nboth implications may depend on the choice of the auxiliary variable @{term \"Z\"} these two\nimplications are expressed in a single premise and not in two of them as for the usual while\nrule. The second premise is the preservation of the invariant by the loop body. And the third\npremise is the side-condition that the computational part of the body does not depend on\nthe auxiliary variable. Finally the last premise is the well-foundedness of the variant.\nThe last two premises are usually discharged automatically by the verification condition\ngenerator. Hence usually two subgoals remain for the user, stemming from the first two\npremises.\n\nThe following example illustrates the usage of this rule. The outer loop increments the\nloop variable @{term \"M\"} while the inner loop increments @{term \"N\"}. To discharge the\nproof obligation for the termination of the outer loop, we need to know that the inner loop\ndoes not mess around with @{term \"M\"}. This is expressed by introducing the logical variable\n@{term \"m\"} and fixing the value of @{term \"M\"} to it.\n\\<close>"], ["", "lemma (in vars)\n  \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M=0 \\<and> \\<acute>N=0\\<rbrace>\n      WHILE (\\<acute>M < i)\n      INV \\<lbrace>\\<acute>M \\<le> i \\<and> (\\<acute>M \\<noteq> 0 \\<longrightarrow> \\<acute>N = j) \\<and> \\<acute>N \\<le> j\\<rbrace>\n      VAR MEASURE (i - \\<acute>M)\n      DO\n         \\<acute>N :== 0;;\n         WHILE (\\<acute>N < j)\n         FIX m.\n         INV \\<lbrace>\\<acute>M=m \\<and> \\<acute>N \\<le> j\\<rbrace>\n         VAR MEASURE (j - \\<acute>N)\n         DO\n           \\<acute>N :== \\<acute>N + 1\n         OD;;\n       \\<acute>M :== \\<acute>M + 1\n       OD\n       \\<lbrace>\\<acute>M=i \\<and> (\\<acute>M\\<noteq>0 \\<longrightarrow> \\<acute>N=j)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M = 0 \\<and>\n                                     \\<acute>N = 0\\<rbrace>\n                            WHILE \\<acute>M < i\n                            INV \\<lbrace>\\<acute>M \\<le> i \\<and>\n   (\\<acute>M \\<noteq> 0 \\<longrightarrow> \\<acute>N = j) \\<and>\n   \\<acute>N \\<le> j\\<rbrace>\n                            VAR measure\n                                 (\\<lambda>s. i - (locals s\\<cdot>M_')) \n                            DO \\<acute>N :== 0;;\n                               WHILE \\<lbrace>\\<acute>N < j\\<rbrace> FIX m.\n                               INV \\<lbrace>\\<acute>M = m \\<and>\n      \\<acute>N \\<le> j\\<rbrace>\n                               VAR measure\n                                    (\\<lambda>s. j - (locals s\\<cdot>N_')) \n                               (\\<acute>N :== \\<acute>N + 1);;\n                               \\<acute>M :== \\<acute>M + 1 \n                            OD\n                            \\<lbrace>\\<acute>M = i \\<and>\n                                     (\\<acute>M \\<noteq> 0 \\<longrightarrow>\n\\<acute>N = j)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M N.\n       \\<lbrakk>M = 0; N = 0\\<rbrakk>\n       \\<Longrightarrow> M \\<le> i \\<and>\n                         (M \\<noteq> 0 \\<longrightarrow> N = j) \\<and>\n                         N \\<le> j\n 2. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        M < i\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> j \\<and>\n                         (\\<forall>Ma N.\n                             Ma = M \\<and>\n                             N \\<le> j \\<and> \\<not> N < j \\<longrightarrow>\n                             i - (M + 1) < i - M \\<and>\n                             M + 1 \\<le> i \\<and>\n                             (M + 1 \\<noteq> 0 \\<longrightarrow> N = j))\n 3. \\<And>M N.\n       \\<lbrakk>N \\<le> j; N < j\\<rbrakk>\n       \\<Longrightarrow> j - (N + 1) < j - N \\<and>\n                         M = M \\<and> N + 1 \\<le> j\n 4. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        \\<not> M < i\\<rbrakk>\n       \\<Longrightarrow> M = i \\<and> (M \\<noteq> 0 \\<longrightarrow> N = j)", "txt \\<open>@{subgoals [display]}\n\nThe first subgoal is from the precondition to the invariant of the outer loop.\nThe fourth subgoal is from the invariant together with the negated loop condition\nof the outer loop to the postcondition. The subgoals two and three are from the body\nof the outer while loop which is mainly the inner while loop. Because we introduce the\nlogical variable @{term \"m\"} here, the while Rule described above is used instead of the\nordinary while Rule. That is why we end up with two subgoals for the inner loop. Subgoal\ntwo is from the invariant and the loop condition of the outer loop to the invariant\nof the inner loop. And at the same time from the invariant of the inner loop to the\ninvariant of the outer loop (together with the proof obligation that the measure of the\nouter loop decreases). The universal quantified variables @{term \"Ma\"} and @{term \"N\"} are\nthe ``fresh'' state variables introduced for the final state of the inner loop.\nThe equality @{term \"Ma=M\"} is the result of the equality \\<open>\\<acute>M=m\\<close> in the inner\ninvariant. Subgoal three is the preservation of the invariant by the\ninner loop body (together with the proof obligation that the measure of\nthe inner loop decreases).\n\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M N.\n       \\<lbrakk>M = 0; N = 0\\<rbrakk>\n       \\<Longrightarrow> M \\<le> i \\<and>\n                         (M \\<noteq> 0 \\<longrightarrow> N = j) \\<and>\n                         N \\<le> j\n 2. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        M < i\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> j \\<and>\n                         (\\<forall>Ma N.\n                             Ma = M \\<and>\n                             N \\<le> j \\<and> \\<not> N < j \\<longrightarrow>\n                             i - (M + 1) < i - M \\<and>\n                             M + 1 \\<le> i \\<and>\n                             (M + 1 \\<noteq> 0 \\<longrightarrow> N = j))\n 3. \\<And>M N.\n       \\<lbrakk>N \\<le> j; N < j\\<rbrakk>\n       \\<Longrightarrow> j - (N + 1) < j - N \\<and>\n                         M = M \\<and> N + 1 \\<le> j\n 4. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        \\<not> M < i\\<rbrakk>\n       \\<Longrightarrow> M = i \\<and> (M \\<noteq> 0 \\<longrightarrow> N = j)", "(*<*)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M N.\n       \\<lbrakk>M = 0; N = 0\\<rbrakk>\n       \\<Longrightarrow> M \\<le> i \\<and>\n                         (M \\<noteq> 0 \\<longrightarrow> N = j) \\<and>\n                         N \\<le> j\n 2. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        M < i\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> j \\<and>\n                         (\\<forall>Ma N.\n                             Ma = M \\<and>\n                             N \\<le> j \\<and> \\<not> N < j \\<longrightarrow>\n                             i - (M + 1) < i - M \\<and>\n                             M + 1 \\<le> i \\<and>\n                             (M + 1 \\<noteq> 0 \\<longrightarrow> N = j))\n 3. \\<And>M N.\n       \\<lbrakk>N \\<le> j; N < j\\<rbrakk>\n       \\<Longrightarrow> j - (N + 1) < j - N \\<and>\n                         M = M \\<and> N + 1 \\<le> j\n 4. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        \\<not> M < i\\<rbrakk>\n       \\<Longrightarrow> M = i \\<and> (M \\<noteq> 0 \\<longrightarrow> N = j)", "apply    (simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        M < i\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> j \\<and>\n                         (\\<forall>Ma N.\n                             Ma = M \\<and>\n                             N \\<le> j \\<and> \\<not> N < j \\<longrightarrow>\n                             i - (M + 1) < i - M \\<and>\n                             M + 1 \\<le> i \\<and>\n                             (M + 1 \\<noteq> 0 \\<longrightarrow> N = j))\n 2. \\<And>M N.\n       \\<lbrakk>N \\<le> j; N < j\\<rbrakk>\n       \\<Longrightarrow> j - (N + 1) < j - N \\<and>\n                         M = M \\<and> N + 1 \\<le> j\n 3. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        \\<not> M < i\\<rbrakk>\n       \\<Longrightarrow> M = i \\<and> (M \\<noteq> 0 \\<longrightarrow> N = j)", "apply   (simp,arith)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M N.\n       \\<lbrakk>N \\<le> j; N < j\\<rbrakk>\n       \\<Longrightarrow> j - (N + 1) < j - N \\<and>\n                         M = M \\<and> N + 1 \\<le> j\n 2. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        \\<not> M < i\\<rbrakk>\n       \\<Longrightarrow> M = i \\<and> (M \\<noteq> 0 \\<longrightarrow> N = j)", "apply  (simp,arith)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection \\<open>Functional Correctness, Termination and Runtime Faults\\<close>"], ["", "text \\<open>\nTotal correctness of a program with guards conceptually leads to three verification\ntasks.\n\\begin{itemize}\n\\item functional (partial) correctness\n\\item absence of runtime faults\n\\item termination\n\\end{itemize}\n\nIn case of a modifies specification the functional correctness part\ncan be solved automatically. But the absence of runtime faults and\ntermination may be non trivial.  Fortunately the modifies clause is\nusually just a helpful companion of another specification that\nexpresses the ``real'' functional behaviour. Therefor the task to\nprove the absence of runtime faults and termination can be dealt with\nduring the proof of this functional specification. In most cases the\nabsence of runtime faults and termination heavily build on the\nfunctional specification parts.  So after all there is no reason why\nwe should again prove the absence of runtime faults and termination\nfor the modifies clause. Therefor it suffices to have partial\ncorrectness of the modifies clause for a program were all guards are\nignored.  This leads to the following pattern:\\<close>"], ["", "procedures foo (N::nat|M::nat)\n  \"\\<acute>M :== \\<acute>M\n   \\<comment> \\<open>think of body with guards instead\\<close>\"\n\n  foo_spec: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t (P \\<sigma>) \\<acute>M :== PROC foo(\\<acute>N) (Q \\<sigma>)\"\n  foo_modifies: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>} \\<acute>M :== PROC foo(\\<acute>N)\n                   {t. t may_only_modify_globals \\<sigma> in []}\""], ["", "text \\<open>\nThe verification condition generator can solve those modifies clauses automatically\nand can use them to simplify calls to \\<open>foo\\<close> even in the context of total\ncorrectness.\n\\<close>"], ["", "subsection \\<open>Procedures and Locales \\label{sec:Locales}\\<close>"], ["", "text \\<open>\nVerification of a larger program is organised on the granularity of procedures.\nWe proof the procedures in a bottom up fashion.  Of course you can also always use Isabelle's\ndummy proof \\<open>sorry\\<close> to prototype your formalisation. So you can write the\ntheory in a bottom up fashion but actually prove the lemmas in any other order.\n\nHere are some explanations of handling of locales. In the examples below, consider\n\\<open>proc\\<^sub>1\\<close> and \\<open>proc\\<^sub>2\\<close> to be ``leaf'' procedures, which do not call any\nother procedure.\nProcedure \\<open>proc\\<close> directly calls \\<open>proc\\<^sub>1\\<close> and \\<open>proc\\<^sub>2\\<close>.\n\n\\isacommand{lemma} (\\isacommand{in} \\<open>proc\\<^sub>1_impl\\<close>) \\<open>proc\\<^sub>1_modifies\\<close>:\\\\\n\\isacommand{shows} \\<open>\\<dots>\\<close>\n\nAfter the proof of \\<open>proc\\<^sub>1_modifies\\<close>, the \\isacommand{in} directive\nstores the lemma in the\nlocale \\<open>proc\\<^sub>1_impl\\<close>. When we later on include \\<open>proc\\<^sub>1_impl\\<close> or prove\nanother theorem in locale \\<open>proc\\<^sub>1_impl\\<close> the lemma \\<open>proc\\<^sub>1_modifies\\<close>\nwill already be available as fact.\n\n\\isacommand{lemma} (\\isacommand{in} \\<open>proc\\<^sub>1_impl\\<close>) \\<open>proc\\<^sub>1_spec\\<close>:\\\\\n\\isacommand{shows} \\<open>\\<dots>\\<close>\n\n\\isacommand{lemma} (\\isacommand{in} \\<open>proc\\<^sub>2_impl\\<close>) \\<open>proc\\<^sub>2_modifies\\<close>:\\\\\n\\isacommand{shows} \\<open>\\<dots>\\<close>\n\n\\isacommand{lemma} (\\isacommand{in} \\<open>proc\\<^sub>2_impl\\<close>) \\<open>proc\\<^sub>2_spec\\<close>:\\\\\n\\isacommand{shows} \\<open>\\<dots>\\<close>\n\n\n\\isacommand{lemma} (\\isacommand{in} \\<open>proc_impl\\<close>) \\<open>proc_modifies\\<close>:\\\\\n\\isacommand{shows} \\<open>\\<dots>\\<close>\n\nNote that we do not explicitly include anything about \\<open>proc\\<^sub>1\\<close> or\n\\<open>proc\\<^sub>2\\<close> here. This is handled automatically. When defining\nan \\<open>impl\\<close>-locale it imports all \\<open>impl\\<close>-locales of procedures that are\ncalled in the body. In case of \\<open>proc_impl\\<close> this means, that \\<open>proc\\<^sub>1_impl\\<close>\nand \\<open>proc\\<^sub>2_impl\\<close> are imported. This has the neat effect that all theorems that\nare proven in \\<open>proc\\<^sub>1_impl\\<close> and \\<open>proc\\<^sub>2_impl\\<close> are also present\nin \\<open>proc_impl\\<close>.\n\n\\isacommand{lemma} (\\isacommand{in} \\<open>proc_impl\\<close>) \\<open>proc_spec\\<close>:\\\\\n\\isacommand{shows} \\<open>\\<dots>\\<close>\n\nAs we have seen in this example you only have to prove a procedure in its own\n\\<open>impl\\<close> locale. You do not have to include any other locale.\n\\<close>"], ["", "subsection \\<open>Records \\label{sec:records}\\<close>"], ["", "text \\<open>\nBefore @{term \"statespaces\"} where introduced the state was represented as a @{term \"record\"}.\nThis is still supported. Compared to the flexibility of statespaces there are some drawbacks\nin particular with respect to modularity. Even names of local variables and\nparameters are globally visible and records can only be extended in a linear fashion, whereas\nstatespaces also allow multiple inheritance. The usage of records is quite similar to the usage of statespaces.\nWe repeat the example of an append function for heap lists.\nFirst we define the global components.\nAgain the appearance of the prefix `globals' is mandatory. This is the way the syntax layer distinguishes local and global variables.\n\\<close>"], ["", "record globals_list =\n  next_' :: \"ref \\<Rightarrow> ref\"\n  cont_' :: \"ref \\<Rightarrow> nat\""], ["", "text \\<open>The local variables also have to be defined as a record before the actual definition\nof the procedure. The parent record \\<open>state\\<close> defines a generic @{term \"globals\"}\nfield as a place-holder for the record of global components. In contrast to the\nstatespace approach there is no single @{term \"locals\"} slot. The local components are\njust added to the record.\n\\<close>"], ["", "record 'g list_vars = \"'g state\" +\n  p_'    :: \"ref\"\n  q_'    :: \"ref\"\n  r_'    :: \"ref\"\n  root_' :: \"ref\"\n  tmp_'  :: \"ref\""], ["", "text \\<open>Since the parameters and local variables are determined by the record, there are\nno type annotations or definitions of local variables while defining a procedure.\n\\<close>"], ["", "procedures\n  append'(p,q|p) =\n    \"IF \\<acute>p=Null THEN \\<acute>p :== \\<acute>q\n     ELSE \\<acute>p \\<rightarrow>\\<acute>next:== CALL append'(\\<acute>p\\<rightarrow>\\<acute>next,\\<acute>q) FI\""], ["", "text \\<open>As in the statespace approach, a locale called \\<open>append'_impl\\<close> is created.\nNote that we do not give any explicit information which global or local state-record to use.\nSince the records are already defined we rely on Isabelle's type inference.\nDealing with the locale is analogous to the case with statespaces.\n\\<close>"], ["", "lemma (in append'_impl) append'_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC append'(\\<acute>p,\\<acute>q)\n        {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>}\n                       \\<acute>p :== PROC append'(\\<acute>p,\\<acute>q)\n                       (_Collect t\n                         (t may_only_modify_globals \\<sigma> in [next]))", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, append'_'proc,\n                      _Collect t\n                       (t may_only_modify_globals \\<sigma> in [next]),\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n                       ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append'(\\<acute>p\\<rightarrow>\\<acute>next,\n                         \\<acute>q)\n                       FI\n                       (_Collect t\n                         (t may_only_modify_globals \\<sigma> in [next]))", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in append'_impl) append'_spec:\n  shows \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\n            \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n                \\<acute>p :== PROC append'(\\<acute>p,\\<acute>q)\n            \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       \\<acute>p :== PROC append'(\\<acute>p,\\<acute>q)\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps Qs.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps \\<and>\n   List \\<acute>q \\<acute>next Qs \\<and>\n   set Ps \\<inter> set Qs = {}\\<rbrace>,\n                      append'_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n                       ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append'(\\<acute>p\\<rightarrow>\\<acute>next,\n                         \\<acute>q)\n                       FI\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps Qs next p q.\n       \\<lbrakk>List p next Ps; List q next Qs;\n        set Ps \\<inter> set Qs = {}\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          List q next (Ps @ Qs) \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              next x = next x)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Psa.\n                              List (next p) next Psa \\<and>\n                              (\\<exists>Qsa.\n                                  List q next Qsa \\<and>\n                                  set Psa \\<inter> set Qsa = {} \\<and>\n                                  (\\<forall>nexta pa.\nList pa nexta (Psa @ Qsa) \\<and>\n(\\<forall>x.\n    x \\<notin> set Psa \\<longrightarrow> nexta x = next x) \\<longrightarrow>\nList p (nexta(p := pa)) (Ps @ Qs) \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow> (nexta(p := pa)) x = next x)))))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nHowever, in some corner cases the inferred state type in a procedure definition\ncan be too general which raises problems when  attempting to proof a suitable\nspecifications in the locale.\nConsider for example the simple procedure body @{term \"\\<acute>p :== NULL\"} for a procedure\n\\<open>init\\<close>.\n\\<close>"], ["", "procedures init (|p) =\n  \"\\<acute>p:== Null\""], ["", "text \\<open>\nHere Isabelle can only\ninfer the local variable record. Since no reference to any global variable is\nmade the type fixed for the global variables (in the locale \\<open>init'_impl\\<close>) is a\ntype variable say @{typ \"'g\"} and not a @{term \"globals_list\"} record. Any specification\nmentioning @{term \"next\"} or @{term \"cont\"} restricts the state type and cannot be\nadded to the locale \\<open>init_impl\\<close>. Hence we have to restrict the body\n@{term \"\\<acute>p :== NULL\"} in the first place by adding a typing annotation:\n\\<close>"], ["", "procedures init' (|p) =\n  \"\\<acute>p:== Null::(('a globals_list_scheme, 'b) list_vars_scheme, char list, 'c) com\""], ["", "subsubsection \\<open>Extending State Spaces\\<close>"], ["", "text \\<open>\nThe records in Isabelle are\nextensible \\cite{Nipkow-02-hol,NaraschewskiW-TPHOLs98}. In principle this can be exploited\nduring verification. The state space can be extended while we we add procedures.\nBut there is one major drawback:\n\\begin{itemize}\n  \\item records can only be extended in a linear fashion (there is no multiple inheritance)\n\\end{itemize}\n\nYou can extend both the main state record as well as the record for the global variables.\n\\<close>"], ["", "subsubsection \\<open>Mapping Variables to Record Fields\\<close>"], ["", "text \\<open>\nGenerally the state space (global and local variables) is flat and all components\nare accessible from everywhere. Locality or globality of variables is achieved by\nthe proper \\<open>init\\<close> and \\<open>return\\<close>/\\<open>result\\<close> functions in procedure\ncalls. What is the best way to map programming language variables to the state records?\nOne way is to disambiguate all names, by using the procedure names as prefix or the\nstructure names for heap components. This leads to long names and lots of\nrecord components. But for local variables this is not necessary, since\nvariable @{term i} of procedure @{term A} and variable @{term \"i\"} of procedure @{term B}\ncan be mapped to the same record component, without any harm, provided they have the\nsame logical type. Therefor for local variables it is preferable to map them per type. You\nonly have to distinguish a variable with the same name if they have a different type.\nNote that all pointers just have logical type \\<open>ref\\<close>. So you even do not\nhave to distinguish between a  pointer \\<open>p\\<close> to a integer and a pointer \\<open>p\\<close> to\na list.\nFor global components (global variables and heap structures) you have to disambiguate the\nname. But hopefully the field names of structures have different names anyway.\nAlso note that there is no notion of hiding of a global component by a local one in\nthe logic. You have to disambiguate global and local names!\nAs the names of the components show up in the specifications and the\nproof obligations, names are even more important as for programming. Try to\nfind meaningful and short names, to avoid cluttering up your reasoning.\n\\<close>"], ["", "(*<*)"], ["", "text \\<open>\nin locales, includes, spec or impl?\nNames: per type not per procedure\\<dots>\ndowngrading total to partial\\<dots>\n\\<close>"], ["", "(*>*)"], ["", "text \\<open>\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}