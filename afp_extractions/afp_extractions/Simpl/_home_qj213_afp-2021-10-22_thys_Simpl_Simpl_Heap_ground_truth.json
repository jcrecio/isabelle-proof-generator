{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/Simpl_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma finite_nat_ex_max:\n  assumes fin: \"finite (N::nat set)\"\n  shows \"\\<exists>m. \\<forall>n\\<in>N. n < m\"", "lemma infinite_nat: \"\\<not>finite (UNIV::nat set)\"", "lemma infinite_ref [simp,intro]: \"\\<not>finite (UNIV::ref set)\"", "lemma new_notin [simp,intro]:\n \"finite A \\<Longrightarrow> new (A) \\<notin> A\"", "lemma new_not_Null [simp,intro]:\n  \"finite A \\<Longrightarrow> new (A) \\<noteq> Null\""], "translations": [["", "lemma finite_nat_ex_max:\n  assumes fin: \"finite (N::nat set)\"\n  shows \"\\<exists>m. \\<forall>n\\<in>N. n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. \\<forall>n\\<in>N. n < m", "using fin"], ["proof (prove)\nusing this:\n  finite N\n\ngoal (1 subgoal):\n 1. \\<exists>m. \\<forall>n\\<in>N. n < m", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>m. \\<forall>n\\<in>{}. n < m\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>m. \\<forall>n\\<in>F. n < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. \\<forall>n\\<in>insert x F. n < m", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>m. \\<forall>n\\<in>{}. n < m\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>m. \\<forall>n\\<in>F. n < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. \\<forall>n\\<in>insert x F. n < m", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. \\<forall>n\\<in>{}. n < m", "by auto"], ["proof (state)\nthis:\n  \\<exists>m. \\<forall>n\\<in>{}. n < m\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>m. \\<forall>n\\<in>F. n < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. \\<forall>n\\<in>insert x F. n < m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>m. \\<forall>n\\<in>F. n < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. \\<forall>n\\<in>insert x F. n < m", "case (insert k N)"], ["proof (state)\nthis:\n  finite N\n  k \\<notin> N\n  \\<exists>m. \\<forall>n\\<in>N. n < m\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>m. \\<forall>n\\<in>F. n < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. \\<forall>n\\<in>insert x F. n < m", "have \"\\<exists>m. \\<forall>n\\<in>N. n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. \\<forall>n\\<in>N. n < m", "by fact"], ["proof (state)\nthis:\n  \\<exists>m. \\<forall>n\\<in>N. n < m\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>m. \\<forall>n\\<in>F. n < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. \\<forall>n\\<in>insert x F. n < m", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. \\<forall>n\\<in>N. n < m", "obtain m where m_max: \"\\<forall>n\\<in>N. n < m\""], ["proof (prove)\nusing this:\n  \\<exists>m. \\<forall>n\\<in>N. n < m\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<forall>n\\<in>N. n < m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>n\\<in>N. n < m\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>m. \\<forall>n\\<in>F. n < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. \\<forall>n\\<in>insert x F. n < m", "show \"\\<exists>m. \\<forall>n\\<in>insert k N. n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. \\<forall>n\\<in>insert k N. n < m", "proof (rule exI [where x=\"Suc (max k m)\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>insert k N. n < Suc (max k m)", "qed (insert m_max, auto simp add: max_def)"], ["proof (state)\nthis:\n  \\<exists>m. \\<forall>n\\<in>insert k N. n < m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_nat: \"\\<not>finite (UNIV::nat set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "assume fin: \"finite (UNIV::nat set)\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  finite UNIV", "obtain m::nat where \"\\<forall>n\\<in>UNIV. n < m\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<forall>n\\<in>UNIV. n < m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule finite_nat_ex_max [elim_format] ) auto"], ["proof (state)\nthis:\n  \\<forall>n\\<in>UNIV. n < m\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>n\\<in>UNIV. n < m\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "have \"m\\<in>UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> UNIV", ".."], ["proof (state)\nthis:\n  m \\<in> UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>UNIV. n < m\n  m \\<in> UNIV", "show False"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>UNIV. n < m\n  m \\<in> UNIV\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_ref [simp,intro]: \"\\<not>finite (UNIV::ref set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "assume \"finite (UNIV::ref set)\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "hence \"finite (range Rep_ref)\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite (range Rep_ref)", "by simp"], ["proof (state)\nthis:\n  finite (range Rep_ref)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  finite (range Rep_ref)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "have \"range Rep_ref = ref\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range Rep_ref = ref", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. range Rep_ref \\<subseteq> ref\n 2. ref \\<subseteq> range Rep_ref", "show \"range Rep_ref \\<subseteq> ref\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range Rep_ref \\<subseteq> ref", "by (simp add: ref_def)"], ["proof (state)\nthis:\n  range Rep_ref \\<subseteq> ref\n\ngoal (1 subgoal):\n 1. ref \\<subseteq> range Rep_ref", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<subseteq> range Rep_ref", "show \"ref \\<subseteq> range Rep_ref\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref \\<subseteq> range Rep_ref", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ref \\<Longrightarrow> x \\<in> range Rep_ref", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ref \\<Longrightarrow> x \\<in> range Rep_ref", "assume x: \"x \\<in> ref\""], ["proof (state)\nthis:\n  x \\<in> ref\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ref \\<Longrightarrow> x \\<in> range Rep_ref", "show \"x \\<in> range Rep_ref\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range Rep_ref", "by (rule Rep_ref_induct) (auto simp add: ref_def)"], ["proof (state)\nthis:\n  x \\<in> range Rep_ref\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ref \\<subseteq> range Rep_ref\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range Rep_ref = ref\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  finite (range Rep_ref)\n  range Rep_ref = ref", "have \"finite ref\""], ["proof (prove)\nusing this:\n  finite (range Rep_ref)\n  range Rep_ref = ref\n\ngoal (1 subgoal):\n 1. finite ref", "by simp"], ["proof (state)\nthis:\n  finite ref\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  finite ref\n\ngoal (1 subgoal):\n 1. False", "by (simp add: ref_def infinite_nat)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "consts Null :: ref"], ["", "definition new :: \"ref set \\<Rightarrow> ref\" where\n  \"new A = (SOME a. a \\<notin> {Null} \\<union> A)\""], ["", "text \\<open>\n  Constant @{const \"Null\"} can be defined later on.  Conceptually\n  @{const \"Null\"} and @{const \"new\"} are \\<open>fixes\\<close> of a locale\n  with @{prop \"finite A \\<Longrightarrow> new A \\<notin> A \\<union> {Null}\"}.  But since definitions\n  relative to a locale do not yet work in Isabelle2005 we use this\n  workaround to avoid lots of parameters in definitions.\n\\<close>"], ["", "lemma new_notin [simp,intro]:\n \"finite A \\<Longrightarrow> new (A) \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> new A \\<notin> A", "apply (unfold new_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    (SOME a. a \\<notin> {Null} \\<union> A) \\<notin> A", "apply (rule someI2_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> \\<exists>a. a \\<notin> {Null} \\<union> A\n 2. \\<And>x.\n       \\<lbrakk>finite A; x \\<notin> {Null} \\<union> A\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> A", "apply (fastforce intro: ex_new_if_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite A; x \\<notin> {Null} \\<union> A\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> A", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma new_not_Null [simp,intro]:\n  \"finite A \\<Longrightarrow> new (A) \\<noteq> Null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> new A \\<noteq> Null", "apply (unfold new_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    (SOME a. a \\<notin> {Null} \\<union> A) \\<noteq> Null", "apply (rule someI2_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> \\<exists>a. a \\<notin> {Null} \\<union> A\n 2. \\<And>x.\n       \\<lbrakk>finite A; x \\<notin> {Null} \\<union> A\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> Null", "apply (fastforce intro: ex_new_if_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite A; x \\<notin> {Null} \\<union> A\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> Null", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}