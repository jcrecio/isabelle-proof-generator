{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/ex/ProcParExSP.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma DynProcProcPar':\n assumes adapt: \"P \\<subseteq> {s. p s = q \\<and>\n         (\\<exists>Z. init s \\<in> P' Z \\<and>\n              (\\<forall>t \\<in> Q' Z. return s t \\<in> R s t) \\<and>\n              (\\<forall>t \\<in> A' Z. return s t \\<in> A))}\"\n assumes result: \"\\<forall>s t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(R s t) result s t Q,A\"\n assumes q: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) Call q (Q' Z),(A' Z)\"\n shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P dynCall init p return result Q,A\"", "lemma conseq_exploit_pre':\n             \"\\<lbrakk>\\<forall>s \\<in> S. \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P) c Q,A\\<rbrakk>\n              \\<Longrightarrow>\n              \\<Gamma>,\\<Theta>\\<turnstile> (P \\<inter> S)c Q,A\"", "lemma conseq_exploit_pre'':\n             \"\\<lbrakk>\\<forall>Z. \\<forall>s \\<in> S Z.  \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)\\<rbrakk>\n              \\<Longrightarrow>\n              \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S Z)c (Q Z),(A Z)\"", "lemma conseq_exploit_pre''':\n             \"\\<lbrakk>\\<forall>s \\<in> S. \\<forall>Z. \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)\\<rbrakk>\n              \\<Longrightarrow>\n              \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S)c (Q Z),(A Z)\"", "lemma (in Max_impl ) Max_spec1:\nshows\n\"\\<forall>\\<sigma> leq. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> \\<lbrace> (\\<forall>\\<tau>. \\<Gamma>\\<turnstile>{\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n      (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\"", "lemma (in Max_impl) Max_spec2:\nshows\n\"\\<forall>\\<sigma> leq. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> \\<lbrace>(\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n      (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\"", "lemma (in Max_impl) Max_spec3:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace>  \\<inter>\n   \\<lbrace>(\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n     (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\"", "lemma (in Max_impl) Max_spec4:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<inter> \\<lbrace>\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\"", "lemma (in Max_test)\n  shows\n  \"\\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>k = mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\"", "lemma (in Max_impl) Max_spec5:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<inter> \\<lbrace>\\<forall>n' m'. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>i=n' \\<and> \\<acute>j=m'\\<rbrace> \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq n' m')\\<rbrace>\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\"", "lemma (in LEQ_impl)\n LEQ_spec: \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>i=n \\<and> \\<acute>j=m\\<rbrace>  PROC LEQ(\\<acute>i,\\<acute>j,\\<acute>r) \\<lbrace>\\<acute>r = (n \\<le> m)\\<rbrace>\"", "lemma (in Max_test')\n  shows\n  \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>\""], "translations": [["", "lemma DynProcProcPar':\n assumes adapt: \"P \\<subseteq> {s. p s = q \\<and>\n         (\\<exists>Z. init s \\<in> P' Z \\<and>\n              (\\<forall>t \\<in> Q' Z. return s t \\<in> R s t) \\<and>\n              (\\<forall>t \\<in> A' Z. return s t \\<in> A))}\"\n assumes result: \"\\<forall>s t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(R s t) result s t Q,A\"\n assumes q: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) Call q (Q' Z),(A' Z)\"\n shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P dynCall init p return result Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P dynCall init p return result Q,A", "apply (rule HoarePartial.DynProcProcPar [OF _ result q])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> {s. p s = q \\<and>\n                      (\\<exists>Z.\n                          init s \\<in> P' Z \\<and>\n                          (\\<forall>\\<tau>.\n                              \\<tau> \\<in> Q' Z \\<longrightarrow>\n                              return s \\<tau> \\<in> R s \\<tau>) \\<and>\n                          (\\<forall>\\<tau>.\n                              \\<tau> \\<in> A' Z \\<longrightarrow>\n                              return s \\<tau> \\<in> A))}", "apply (insert adapt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> {s. p s = q \\<and>\n                      (\\<exists>Z.\n                          init s \\<in> P' Z \\<and>\n                          (\\<forall>t\\<in>Q' Z.\n                              return s t \\<in> R s t) \\<and>\n                          (\\<forall>t\\<in>A' Z.\n                              return s t \\<in> A))} \\<Longrightarrow>\n    P \\<subseteq> {s. p s = q \\<and>\n                      (\\<exists>Z.\n                          init s \\<in> P' Z \\<and>\n                          (\\<forall>\\<tau>.\n                              \\<tau> \\<in> Q' Z \\<longrightarrow>\n                              return s \\<tau> \\<in> R s \\<tau>) \\<and>\n                          (\\<forall>\\<tau>.\n                              \\<tau> \\<in> A' Z \\<longrightarrow>\n                              return s \\<tau> \\<in> A))}", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma conseq_exploit_pre':\n             \"\\<lbrakk>\\<forall>s \\<in> S. \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P) c Q,A\\<rbrakk>\n              \\<Longrightarrow>\n              \\<Gamma>,\\<Theta>\\<turnstile> (P \\<inter> S)c Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> ({s} \\<inter> P) c Q,A \\<Longrightarrow>\n    \\<Gamma>,\\<Theta>\\<turnstile> (P \\<inter> S) c Q,A", "apply (rule HoarePartialDef.Conseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> ({s} \\<inter> P) c Q,A \\<Longrightarrow>\n    \\<forall>s\\<in>P \\<inter> S.\n       \\<exists>P' Q' A'.\n          \\<Gamma>,\\<Theta>\\<turnstile> P' c Q',A' \\<and>\n          s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s\\<in>S.\n                   \\<Gamma>,\\<Theta>\\<turnstile> ({s} \\<inter> P) c Q,A;\n        s \\<in> P; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\\<turnstile> P' c Q',A' \\<and>\n                            s \\<in> P' \\<and>\n                            Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "by (metis IntI insertI1 subset_refl)"], ["", "lemma conseq_exploit_pre'':\n             \"\\<lbrakk>\\<forall>Z. \\<forall>s \\<in> S Z.  \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)\\<rbrakk>\n              \\<Longrightarrow>\n              \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S Z)c (Q Z),(A Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Z.\n       \\<forall>s\\<in>S Z.\n          \\<Gamma>,\\<Theta>\n             \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z) \\<Longrightarrow>\n    \\<forall>Z.\n       \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S Z) c (Q Z),(A Z)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<forall>Z.\n          \\<forall>s\\<in>S Z.\n             \\<Gamma>,\\<Theta>\n                \\<turnstile> ({s} \\<inter> P Z) c (Q Z),\n                             (A Z) \\<Longrightarrow>\n       \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S Z) c (Q Z),(A Z)", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<forall>Z.\n          \\<forall>s\\<in>S Z.\n             \\<Gamma>,\\<Theta>\n                \\<turnstile> ({s} \\<inter> P Z) c (Q Z),\n                             (A Z) \\<Longrightarrow>\n       \\<forall>s\\<in>S Z.\n          \\<Gamma>,\\<Theta>\\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma conseq_exploit_pre''':\n             \"\\<lbrakk>\\<forall>s \\<in> S. \\<forall>Z. \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)\\<rbrakk>\n              \\<Longrightarrow>\n              \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S)c (Q Z),(A Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       \\<forall>Z.\n          \\<Gamma>,\\<Theta>\n             \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z) \\<Longrightarrow>\n    \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S) c (Q Z),(A Z)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<forall>s\\<in>S.\n          \\<forall>Z.\n             \\<Gamma>,\\<Theta>\n                \\<turnstile> ({s} \\<inter> P Z) c (Q Z),\n                             (A Z) \\<Longrightarrow>\n       \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S) c (Q Z),(A Z)", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<forall>s\\<in>S.\n          \\<forall>Z.\n             \\<Gamma>,\\<Theta>\n                \\<turnstile> ({s} \\<inter> P Z) c (Q Z),\n                             (A Z) \\<Longrightarrow>\n       \\<forall>s\\<in>S.\n          \\<Gamma>,\\<Theta>\\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "procedures compare(i::nat,j::nat|r::bool) \"NoBody\""], ["", "print_locale! compare_signature"], ["", "context compare_impl\nbegin"], ["", "declare [[hoare_use_call_tr' = false]]"], ["", "term \"\\<acute>r :== CALL compare(\\<acute>i,\\<acute>j)\""], ["", "declare [[hoare_use_call_tr' = true]]"], ["", "end"], ["", "(* FIXME: typing issue with modifies locale*)"], ["", "procedures\n  LEQ (i::nat,j::nat | r::bool) \"\\<acute>r :== \\<acute>i \\<le> \\<acute>j\"\n  LEQ_spec: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>}  PROC LEQ(\\<acute>i,\\<acute>j,\\<acute>r) \\<lbrace>\\<acute>r = (\\<^bsup>\\<sigma>\\<^esup>i \\<le> \\<^bsup>\\<sigma>\\<^esup>j)\\<rbrace>\"\n\n  LEQ_modifies: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} PROC LEQ(\\<acute>i,\\<acute>j,\\<acute>r) {t. t may_only_modify_globals \\<sigma> in []}\""], ["", "definition mx:: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  where \"mx leq a b = (if leq a b then a else b)\""], ["", "procedures (imports compare_signature)\n  Max (compare::string, n::nat, m::nat | k::nat)\n  where b::bool\n  in\n  \"\\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\"\n\n  Max_spec: \"\\<And>leq. \\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> {s. (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n              (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\\<acute>j) {t. t may_only_modify_globals \\<tau> in []})})\n    PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m,\\<acute>k)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["", "context Max_spec\nbegin"], ["", "thm Max_spec"], ["", "end"], ["", "context Max_impl\nbegin"], ["", "term \"\\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m)\""], ["", "declare [[hoare_use_call_tr' = false]]"], ["", "term \"\\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m)\""], ["", "declare [[hoare_use_call_tr' = true]]"], ["", "end"], ["", "lemma (in Max_impl ) Max_spec1:\nshows\n\"\\<forall>\\<sigma> leq. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> \\<lbrace> (\\<forall>\\<tau>. \\<Gamma>\\<turnstile>{\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n      (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq.\n       \\<forall>s\\<in>\\<lbrace>(\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {s. \\<^bsup>s\\<^esup>r =\n                 leq \\<^bsup>\\<tau>\\<^esup>i\n                  \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                               (\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {t. t may_not_modify_globals \\<tau>})\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k =\n                                   mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                    \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       s \\<in> \\<lbrace>(\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {s. \\<^bsup>s\\<^esup>r =\n          leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                        (\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {t. t may_not_modify_globals \\<tau>})\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                                   \\<acute>j)\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                           \\<acute>j)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                                   \\<acute>j)\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                           \\<acute>j)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "fix \\<sigma>:: \"('a, 'b, 'c, 'd) stateSP_scheme\" and s::\"('a, 'b, 'c, 'd) stateSP_scheme\" and leq"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                                   \\<acute>j)\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                           \\<acute>j)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "assume compare_spec:\n       \"\\<forall>\\<tau>. \\<Gamma>\\<turnstile>{\\<tau>} \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>\""], ["proof (state)\nthis:\n  \\<forall>\\<tau>.\n     \\<Gamma>\n        \\<turnstile> {\\<tau>}\n                     \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                     \\<acute>j)\n                     \\<lbrace>\\<acute>r =\n                              leq \\<^bsup>\\<tau>\\<^esup>i\n                               \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                                   \\<acute>j)\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                           \\<acute>j)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "assume compare_modifies:\n        \"\\<forall>\\<tau>. \\<Gamma>\\<turnstile>{\\<tau>} \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\\<acute>j)\n                {t. t may_only_modify_globals \\<tau> in []}\""], ["proof (state)\nthis:\n  \\<forall>\\<tau>.\n     \\<Gamma>\n        \\<turnstile> {\\<tau>}\n                     \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                     \\<acute>j)\n                     {t. t may_not_modify_globals \\<tau>}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                                   \\<acute>j)\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                           \\<acute>j)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "show \"\\<Gamma>\\<turnstile>({s} \\<inter> {\\<sigma>})\n            \\<acute>b :== DYNCALL \\<acute>compare (\\<acute>n,\\<acute>m);;\n            IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n            \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                    \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                    \\<acute>m);;\n                    IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                    ELSE \\<acute>k :== \\<acute>m FI\n                    \\<lbrace>\\<acute>k =\n                             mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>compare m n.\n       compare = compare \\<and>\n       (\\<forall>r.\n           r = leq n m \\<longrightarrow>\n           (leq n m \\<longrightarrow> n = mx leq n m) \\<and>\n           (\\<not> leq n m \\<longrightarrow> m = mx leq n m))", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                  \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                  \\<acute>m);;\n                  IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                  ELSE \\<acute>k :== \\<acute>m FI\n                  \\<lbrace>\\<acute>k =\n                           mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                            \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Max_impl) Max_spec2:\nshows\n\"\\<forall>\\<sigma> leq. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> \\<lbrace>(\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n      (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq.\n       \\<forall>s\\<in>\\<lbrace>(\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {s. \\<^bsup>s\\<^esup>r =\n                 leq \\<^bsup>\\<tau>\\<^esup>i\n                  \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                               (\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {t. t may_not_modify_globals \\<tau>})\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k =\n                                   mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                    \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       s \\<in> \\<lbrace>(\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {s. \\<^bsup>s\\<^esup>r =\n          leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                        (\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {t. t may_not_modify_globals \\<tau>})\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                                   \\<acute>j)\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                           \\<acute>j)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare m n.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>} Call compare\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>} Call compare\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> compare = compare \\<and>\n                         (\\<forall>r.\n                             r = leq n m \\<longrightarrow>\n                             (leq n m \\<longrightarrow>\n                              n = mx leq n m) \\<and>\n                             (\\<not> leq n m \\<longrightarrow>\n                              m = mx leq n m))", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in Max_impl) Max_spec3:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace>  \\<inter>\n   \\<lbrace>(\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n     (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>r =\n                   leq \\<^bsup>\\<tau>\\<^esup>i\n                    \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<forall>s\\<in>\\<lbrace>(\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {s. \\<^bsup>s\\<^esup>r =\n                 leq \\<^bsup>\\<tau>\\<^esup>i\n                  \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                               (\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {t. t may_not_modify_globals \\<tau>})\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter>\n                           \\<lbrace>\\<acute>n = n \\<and>\n                                    \\<acute>m = m\\<rbrace>)\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       s \\<in> \\<lbrace>(\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {s. \\<^bsup>s\\<^esup>r =\n          leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j}) \\<and>\n                        (\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {t. t may_not_modify_globals \\<tau>})\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                                   \\<acute>j)\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                           \\<acute>j)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter>\n    \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>)\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare m n.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>} Call compare\n                                   \\<lbrace>\\<acute>r =\n      leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>} Call compare\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> compare = compare \\<and>\n                         (\\<forall>r.\n                             r = leq n m \\<longrightarrow>\n                             (leq n m \\<longrightarrow>\n                              n = mx leq n m) \\<and>\n                             (\\<not> leq n m \\<longrightarrow>\n                              m = mx leq n m))", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in Max_impl) Max_spec4:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<inter> \\<lbrace>\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq \\<^bsup>\\<tau>\\<^esup>i \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>\\<tau>.\n                                    \\<Gamma>\n \\<turnstile> {\\<tau>} Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>r =\n                  leq \\<^bsup>\\<tau>\\<^esup>i\n                   \\<^bsup>\\<tau>\\<^esup>j}\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>\\<tau>.\n                                    \\<Gamma>\n \\<turnstile> {\\<tau>} Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>r =\n                  leq \\<^bsup>\\<tau>\\<^esup>i\n                   \\<^bsup>\\<tau>\\<^esup>j}\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>\\<tau>.\n                                    \\<Gamma>\n \\<turnstile> {\\<tau>} Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>r =\n                  leq \\<^bsup>\\<tau>\\<^esup>i\n                   \\<^bsup>\\<tau>\\<^esup>j}\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<forall>s\\<in>\\<lbrace>\\<forall>\\<tau>.\n                                  \\<Gamma>\n                                     \\<turnstile> {\\<tau>}\n            Call \\<acute>compare\n            {s. \\<^bsup>s\\<^esup>r =\n                leq \\<^bsup>\\<tau>\\<^esup>i\n                 \\<^bsup>\\<tau>\\<^esup>j}\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter>\n                           \\<lbrace>\\<acute>n = n \\<and>\n                                    \\<acute>m = m\\<rbrace>)\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       s \\<in> \\<lbrace>\\<forall>\\<tau>.\n                           \\<Gamma>\n                              \\<turnstile> {\\<tau>} Call \\<acute>compare\n     {s. \\<^bsup>s\\<^esup>r =\n         leq \\<^bsup>\\<tau>\\<^esup>i\n          \\<^bsup>\\<tau>\\<^esup>j}\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       \\<forall>\\<tau>.\n          \\<Gamma>\n             \\<turnstile> {\\<tau>}\n                          \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                          \\<acute>j)\n                          \\<lbrace>\\<acute>r =\n                                   leq \\<^bsup>\\<tau>\\<^esup>i\n                                    \\<^bsup>\\<tau>\\<^esup>j\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare m n.\n       \\<forall>\\<tau>.\n          \\<Gamma>\n             \\<turnstile> {\\<tau>} Call compare\n                          \\<lbrace>\\<acute>r =\n                                   leq \\<^bsup>\\<tau>\\<^esup>i\n                                    \\<^bsup>\\<tau>\\<^esup>j\\<rbrace> \\<Longrightarrow>\n       compare = compare \\<and>\n       (\\<forall>r.\n           r = leq n m \\<longrightarrow>\n           (leq n m \\<longrightarrow> n = mx leq n m) \\<and>\n           (\\<not> leq n m \\<longrightarrow> m = mx leq n m))", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "print_locale Max_spec"], ["", "(* We have to rename the parameters of the compare procedure to match the LEQ procedure *)"], ["", "locale Max_test = Max_spec where\n        i_'compare_' = i_'LEQ_' and\n        j_'compare_' = j_'LEQ_' and\n        r_'compare_' = r_'LEQ_'\n       + LEQ_spec + LEQ_modifies"], ["", "lemma (in Max_test)\n  shows\n  \"\\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>k = mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                    \\<lbrace>\\<acute>k =\n                             mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                    \\<lbrace>\\<acute>k =\n                             mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "note Max_spec = Max_spec [where leq=\"(\\<le>)\"]"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>\n        \\<turnstile> ({\\<sigma>} \\<inter>\n                      \\<lbrace>(\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {s. \\<^bsup>s\\<^esup>r =\n                 (\\<^bsup>\\<tau>\\<^esup>i\n                  \\<le> \\<^bsup>\\<tau>\\<^esup>j)}) \\<and>\n                               (\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                     \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                     \\<acute>m)\n                     \\<lbrace>\\<acute>k =\n                              mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                               \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                    \\<lbrace>\\<acute>k =\n                             mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                    \\<lbrace>\\<acute>k =\n                             mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (\\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> (Collect ((=) \\<tau>))\n                           \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                           \\<lbrace>\\<acute>r =\n                                    (\\<^bsup>\\<tau>\\<^esup>i\n                                     \\<le> \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n       (\\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> (Collect ((=) \\<tau>))\n                           \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                           {t. t may_not_modify_globals \\<tau>}) \\<and>\n       (\\<forall>k.\n           k = mx (\\<le>) n m \\<longrightarrow>\n           mx (\\<le>) n m = mx (\\<le>) n m)", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<tau>.\n        \\<Gamma>\n           \\<turnstile> {\\<tau>} \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                        \\<lbrace>\\<acute>r =\n                                 (\\<^bsup>\\<tau>\\<^esup>i\n                                  \\<le> \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>) \\<and>\n    (\\<forall>\\<tau>.\n        \\<Gamma>\n           \\<turnstile> {\\<tau>} \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                        {t. t may_not_modify_globals \\<tau>})", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> {\\<tau>} \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                       \\<lbrace>\\<acute>r =\n                                (\\<^bsup>\\<tau>\\<^esup>i\n                                 \\<le> \\<^bsup>\\<tau>\\<^esup>j)\\<rbrace>\n 2. \\<forall>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> {\\<tau>} \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                       {t. t may_not_modify_globals \\<tau>}", "apply (rule LEQ_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> {\\<tau>} \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                       {t. t may_not_modify_globals \\<tau>}", "apply (rule LEQ_modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> {\\<sigma>}\n                  \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                  \\<lbrace>\\<acute>k =\n                           mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                            \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Max_impl) Max_spec5:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<inter> \\<lbrace>\\<forall>n' m'. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>i=n' \\<and> \\<acute>j=m'\\<rbrace> \\<acute>r :== PROC \\<acute>compare(\\<acute>i,\\<acute>j) \\<lbrace>\\<acute>r = (leq n' m')\\<rbrace>\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>n' m'.\n                                    \\<Gamma>\n \\<turnstile> {s. \\<^bsup>s\\<^esup>i = n' \\<and> \\<^bsup>s\\<^esup>j = m'}\n              Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>r = leq n' m'}\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>n' m'.\n                                    \\<Gamma>\n \\<turnstile> {s. \\<^bsup>s\\<^esup>i = n' \\<and> \\<^bsup>s\\<^esup>j = m'}\n              Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>r = leq n' m'}\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>n' m'.\n                                    \\<Gamma>\n \\<turnstile> {s. \\<^bsup>s\\<^esup>i = n' \\<and> \\<^bsup>s\\<^esup>j = m'}\n              Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>r = leq n' m'}\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<forall>s\\<in>\\<lbrace>\\<forall>n' m'.\n                                  \\<Gamma>\n                                     \\<turnstile> {s.\n             \\<^bsup>s\\<^esup>i = n' \\<and> \\<^bsup>s\\<^esup>j = m'}\n            Call \\<acute>compare\n            {s. \\<^bsup>s\\<^esup>r = leq n' m'}\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter>\n                           \\<lbrace>\\<acute>n = n \\<and>\n                                    \\<acute>m = m\\<rbrace>)\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       s \\<in> \\<lbrace>\\<forall>n' m'.\n                           \\<Gamma>\n                              \\<turnstile> {s.\n      \\<^bsup>s\\<^esup>i = n' \\<and> \\<^bsup>s\\<^esup>j = m'}\n     Call \\<acute>compare\n     {s. \\<^bsup>s\\<^esup>r = leq n' m'}\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       \\<forall>n' m'.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>\\<acute>i = n' \\<and>\n                                   \\<acute>j = m'\\<rbrace>\n                          \\<acute>r :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>i,\n                          \\<acute>j)\n                          \\<lbrace>\\<acute>r =\n                                   leq n' m'\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare m n.\n       \\<forall>n' m'.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>\\<acute>i = n' \\<and>\n                                   \\<acute>j = m'\\<rbrace>\n                          Call compare\n                          \\<lbrace>\\<acute>r =\n                                   leq n' m'\\<rbrace> \\<Longrightarrow>\n       compare = compare \\<and>\n       (\\<forall>r.\n           r = leq n m \\<longrightarrow>\n           (leq n m \\<longrightarrow> n = mx leq n m) \\<and>\n           (\\<not> leq n m \\<longrightarrow> m = mx leq n m))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare m n.\n       \\<forall>n' m'.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>\\<acute>i = n' \\<and>\n                                   \\<acute>j = m'\\<rbrace>\n                          Call compare\n                          \\<lbrace>\\<acute>r =\n                                   leq n' m'\\<rbrace> \\<Longrightarrow>\n       (leq n m \\<longrightarrow> n = mx leq n m) \\<and>\n       (\\<not> leq n m \\<longrightarrow> m = mx leq n m)", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in LEQ_impl)\n LEQ_spec: \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>i=n \\<and> \\<acute>j=m\\<rbrace>  PROC LEQ(\\<acute>i,\\<acute>j,\\<acute>r) \\<lbrace>\\<acute>r = (n \\<le> m)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>i = n \\<and> \\<acute>j = m\\<rbrace>\n                       \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                       \\<lbrace>\\<acute>r = (n \\<le> m)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j. (i \\<le> j) = (i \\<le> j)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "print_locale Max_impl"], ["", "locale Max_test' = Max_impl where\n        i_'compare_' = i_'LEQ_' and\n        j_'compare_' = j_'LEQ_' and\n        r_'compare_' = r_'LEQ_'\n        + LEQ_impl"], ["", "lemma (in Max_test')\n  shows\n  \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>", "note Max_spec = Max_spec5"], ["proof (state)\nthis:\n  \\<forall>n m leq.\n     \\<Gamma>\n        \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                               \\<acute>m = m\\<rbrace> \\<inter>\n                      \\<lbrace>\\<forall>n' m'.\n                                  \\<Gamma>\n                                     \\<turnstile> {s.\n             \\<^bsup>s\\<^esup>i = n' \\<and> \\<^bsup>s\\<^esup>j = m'}\n            Call \\<acute>compare\n            {s. \\<^bsup>s\\<^esup>r = leq n' m'}\\<rbrace>)\n                     \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                     \\<acute>m)\n                     \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<exists>leq.\n          (\\<forall>n' m'.\n              \\<Gamma>\n                 \\<turnstile> \\<lbrace>\\<acute>i = n' \\<and>\n \\<acute>j = m'\\<rbrace>\n                              \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                              \\<lbrace>\\<acute>r =\n leq n' m'\\<rbrace>) \\<and>\n          (\\<forall>k.\n              k = mx leq n m \\<longrightarrow> mx leq n m = mx (\\<le>) n m)", "apply (rule_tac x=\"(\\<le>)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (\\<forall>n' m'.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>\\<acute>i = n' \\<and>\n                                    \\<acute>j = m'\\<rbrace>\n                           \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                           \\<lbrace>\\<acute>r =\n                                    (n' \\<le> m')\\<rbrace>) \\<and>\n       (\\<forall>k.\n           k = mx (\\<le>) n m \\<longrightarrow>\n           mx (\\<le>) n m = mx (\\<le>) n m)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' m'.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>i = n' \\<and>\n                                \\<acute>j = m'\\<rbrace>\n                       \\<acute>r :== PROC LEQ(\\<acute>i,\\<acute>j)\n                       \\<lbrace>\\<acute>r = (n' \\<le> m')\\<rbrace>", "apply (rule LEQ_spec [rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>n m.\n     \\<Gamma>\n        \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                     \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                     \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}