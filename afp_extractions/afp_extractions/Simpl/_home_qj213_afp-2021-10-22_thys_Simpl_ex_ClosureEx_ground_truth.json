{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/ex/ClosureEx.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma upd\\<^sub>n_ap: \"upd\\<^sub>n (fst (ap es (es',p))) = upd\\<^sub>n es' \\<circ> upd\\<^sub>n es\"", "lemma\n\"\\<Gamma>\\<turnstile>\\<lbrace>\\<acute>n=n\\<^sub>0 \\<and> (\\<forall>i j. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=i \\<and> \\<acute>m=j\\<rbrace> callClosure upd\\<^sub>n \\<acute>e \\<lbrace>\\<acute>r=i + j\\<rbrace>)\\<rbrace>\n      \\<acute>e :== (ap [(''n'',\\<acute>n)] \\<acute>e)\n   \\<lbrace>\\<forall>j. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>m=j\\<rbrace> callClosure upd\\<^sub>n \\<acute>e \\<lbrace>\\<acute>r=n\\<^sub>0 + j\\<rbrace>\\<rbrace>\"", "lemma (in Inc_impl)\n \"\\<forall>i p. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> \\<acute>r :== PROC Inc(\\<acute>p) \\<lbrace>\\<acute>r=i+1 \\<and> \\<acute>p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>\"", "lemma (in NewCounter_impl')\nshows\n  \"\\<forall>alloc. \\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace> \\<acute>c :== PROC NewCounter()\n          \\<lbrace>\\<exists>p. p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n               (\\<forall>i. \\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> callClosure upd \\<acute>c \\<lbrace>\\<acute>r=i+1 \\<and> p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>)\\<rbrace>\"", "lemma (in NewCounter_impl')\n\nshows\n  \"\\<forall>alloc. \\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace> \\<acute>c :== PROC NewCounter()\n          \\<lbrace>\\<exists>p. p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n               (\\<forall>i. \\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> callClosure upd \\<acute>c \\<lbrace>\\<acute>r=i+1 \\<and> p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>)\\<rbrace>\"", "lemma (in NewCounter_impl')\nshows NewCounter_spec:\n  \"\\<forall>alloc. \\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free \\<and> \\<acute>alloc=alloc\\<rbrace> \\<acute>c :== PROC NewCounter()\n          \\<lbrace>\\<exists>p. p \\<notin> set alloc \\<and> p \\<in> set \\<acute>alloc \\<and> p \\<noteq> Null \\<and> p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n               (\\<forall>i. \\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> callClosure upd \\<acute>c \\<lbrace>\\<acute>r=i+1 \\<and> p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>)\\<rbrace>\"", "lemma \"\\<Gamma>\\<turnstile>\\<lbrace>\\<exists>p. p \\<noteq> Null \\<and> p\\<rightarrow>\\<acute>cnt = i \\<and>\n              (\\<forall>i. \\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> callClosure upd \\<acute>c \\<lbrace>\\<acute>r=i+1 \\<and> p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>)\\<rbrace>\n           dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>r_' := r_' t\\<rparr>))\n           \\<lbrace>\\<acute>r=i+1\\<rbrace>\"", "lemma (in NewCounter_impl')\n shows \"\\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n             \\<acute>c :== CALL NewCounter ();;\n             dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>r_' := r_' t\\<rparr>))\n           \\<lbrace>\\<acute>r=1\\<rbrace>\"", "lemma (in NewCounter_impl')\n shows \"\\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n             \\<acute>c :== CALL NewCounter ();;\n             dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>r_' := r_' t\\<rparr>));;\n             dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>r_' := r_' t\\<rparr>))\n           \\<lbrace>\\<acute>r=2\\<rbrace>\"", "lemma (in NewCounter_impl')\n shows \"\\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n             \\<acute>c :== CALL NewCounter ();;\n             \\<acute>d :== \\<acute>c;;\n             dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>n_' := r_' t\\<rparr>));;\n             dynCallClosure (\\<lambda>s. s) upd d_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>m_' := r_' t\\<rparr>));;\n             \\<acute>r :== \\<acute>n + \\<acute>m\n           \\<lbrace>\\<acute>r=3\\<rbrace>\""], "translations": [["", "lemma upd\\<^sub>n_ap: \"upd\\<^sub>n (fst (ap es (es',p))) = upd\\<^sub>n es' \\<circ> upd\\<^sub>n es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd\\<^sub>n (fst (ap es (es', p))) =\n    upd\\<^sub>n es' \\<circ> upd\\<^sub>n es", "by (simp add: upd\\<^sub>n_def gen_upd_ap)"], ["", "lemma\n\"\\<Gamma>\\<turnstile>\\<lbrace>\\<acute>n=n\\<^sub>0 \\<and> (\\<forall>i j. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=i \\<and> \\<acute>m=j\\<rbrace> callClosure upd\\<^sub>n \\<acute>e \\<lbrace>\\<acute>r=i + j\\<rbrace>)\\<rbrace>\n      \\<acute>e :== (ap [(''n'',\\<acute>n)] \\<acute>e)\n   \\<lbrace>\\<forall>j. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>m=j\\<rbrace> callClosure upd\\<^sub>n \\<acute>e \\<lbrace>\\<acute>r=n\\<^sub>0 + j\\<rbrace>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>n = n\\<^sub>0 \\<and>\n                             (\\<forall>i j.\n                                 \\<Gamma>\n                                    \\<turnstile> {s.\n            \\<^bsup>s\\<^esup>n = i \\<and> \\<^bsup>s\\<^esup>m = j}\n           callClosure upd\\<^sub>n \\<acute>e\n           {s. \\<^bsup>s\\<^esup>r = i + j})\\<rbrace>\n                    \\<acute>e :== ap [(''n'', \\<acute>n)] \\<acute>e\n                    \\<lbrace>\\<forall>j.\n                                \\<Gamma>\n                                   \\<turnstile> {s. \\<^bsup>s\\<^esup>m = j}\n          callClosure upd\\<^sub>n \\<acute>e\n          {s. \\<^bsup>s\\<^esup>r = n\\<^sub>0 + j}\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>n = n\\<^sub>0 \\<and>\n             (\\<forall>i j.\n                 \\<Gamma>\n                    \\<turnstile> {s. \\<^bsup>s\\<^esup>n = i \\<and>\n                                     \\<^bsup>s\\<^esup>m = j}\n                                 callClosure upd\\<^sub>n \\<acute>e\n                                 {s. \\<^bsup>s\\<^esup>r = i + j})\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<forall>j.\n                            \\<Gamma>\n                               \\<turnstile> {s. \\<^bsup>s\\<^esup>m = j}\n      callClosure upd\\<^sub>n (ap [(''n'', \\<acute>n)] \\<acute>e)\n      {s. \\<^bsup>s\\<^esup>r = n\\<^sub>0 + j}\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<forall>i j.\n                   \\<Gamma>\n                      \\<turnstile> \\<lbrace>\\<acute>n = i \\<and>\n      \\<acute>m = j\\<rbrace>\n                                   callClosure upd\\<^sub>n (e_' x)\n                                   \\<lbrace>\\<acute>r = i + j\\<rbrace>;\n        n\\<^sub>0 = n_' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>\\<acute>m = j\\<rbrace>\n   callClosure upd\\<^sub>n (ap [(''n'', n_' x)] (e_' x))\n   \\<lbrace>\\<acute>r = \\<^bsup>x\\<^esup>n + j\\<rbrace>", "apply (rule ap_closure [where var=var\\<^sub>n, folded upd\\<^sub>n_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<forall>i j.\n                   \\<Gamma>\n                      \\<turnstile> \\<lbrace>\\<acute>n = i \\<and>\n      \\<acute>m = j\\<rbrace>\n                                   callClosure upd\\<^sub>n (e_' x)\n                                   \\<lbrace>\\<acute>r = i + j\\<rbrace>;\n        n\\<^sub>0 = n_' x\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<acute>m = j\\<rbrace>\n                         \\<subseteq> {s.\n\\<exists>P' Q' A'.\n   \\<Gamma>\\<turnstile> P' callClosure upd\\<^sub>n (e_' x) Q',A' \\<and>\n   upd\\<^sub>n [(''n'', n_' x)] s \\<in> P' \\<and>\n   Q' \\<subseteq> \\<lbrace>\\<acute>r =\n                           \\<^bsup>x\\<^esup>n + j\\<rbrace> \\<and>\n   A' \\<subseteq> {}}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>i j.\n                   \\<Gamma>\n                      \\<turnstile> \\<lbrace>\\<acute>n = i \\<and>\n      \\<acute>m = j\\<rbrace>\n                                   callClosure upd\\<^sub>n (e_' x)\n                                   \\<lbrace>\\<acute>r = i + j\\<rbrace>;\n        n\\<^sub>0 = n_' x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P'\n      callClosure upd\\<^sub>n (e_' x) Q' \\<and>\n                            upd\\<^sub>n [(''n'', n_' x)] xa \\<in> P' \\<and>\n                            Q' \\<subseteq> \\<lbrace>\\<acute>r =\n              \\<^bsup>x\\<^esup>n + \\<^bsup>xa\\<^esup>m\\<rbrace>", "apply (rename_tac s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>i j.\n                   \\<Gamma>\n                      \\<turnstile> \\<lbrace>\\<acute>n = i \\<and>\n      \\<acute>m = j\\<rbrace>\n                                   callClosure upd\\<^sub>n (e_' s)\n                                   \\<lbrace>\\<acute>r = i + j\\<rbrace>;\n        n\\<^sub>0 = n_' s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P'\n      callClosure upd\\<^sub>n (e_' s) Q' \\<and>\n                            upd\\<^sub>n [(''n'', n_' s)] s' \\<in> P' \\<and>\n                            Q' \\<subseteq> \\<lbrace>\\<acute>r =\n              \\<^bsup>s\\<^esup>n + \\<^bsup>s'\\<^esup>m\\<rbrace>", "apply (erule_tac x=\"n_' s\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>n\\<^sub>0 = n_' s;\n        \\<forall>j.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>\\<acute>n = \\<^bsup>s\\<^esup>n \\<and>\n                                    \\<acute>m = j\\<rbrace>\n                           callClosure upd\\<^sub>n (e_' s)\n                           \\<lbrace>\\<acute>r =\n                                    \\<^bsup>s\\<^esup>n + j\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P'\n      callClosure upd\\<^sub>n (e_' s) Q' \\<and>\n                            upd\\<^sub>n [(''n'', n_' s)] s' \\<in> P' \\<and>\n                            Q' \\<subseteq> \\<lbrace>\\<acute>r =\n              \\<^bsup>s\\<^esup>n + \\<^bsup>s'\\<^esup>m\\<rbrace>", "apply (erule_tac x=\"m_' s'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>n\\<^sub>0 = n_' s;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>\\<acute>n = \\<^bsup>s\\<^esup>n \\<and>\n                                 \\<acute>m = \\<^bsup>s'\\<^esup>m\\<rbrace>\n                        callClosure upd\\<^sub>n (e_' s)\n                        \\<lbrace>\\<acute>r =\n                                 \\<^bsup>s\\<^esup>n +\n                                 \\<^bsup>s'\\<^esup>m\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P'\n      callClosure upd\\<^sub>n (e_' s) Q' \\<and>\n                            upd\\<^sub>n [(''n'', n_' s)] s' \\<in> P' \\<and>\n                            Q' \\<subseteq> \\<lbrace>\\<acute>r =\n              \\<^bsup>s\\<^esup>n + \\<^bsup>s'\\<^esup>m\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>n\\<^sub>0 = n_' s;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>\\<acute>n = \\<^bsup>s\\<^esup>n \\<and>\n                                 \\<acute>m = \\<^bsup>s'\\<^esup>m\\<rbrace>\n                        callClosure upd\\<^sub>n (e_' s)\n                        \\<lbrace>\\<acute>r =\n                                 \\<^bsup>s\\<^esup>n +\n                                 \\<^bsup>s'\\<^esup>m\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q'.\n                            \\<Gamma>\n                               \\<turnstile> (?P'18 s s')\n      callClosure upd\\<^sub>n (e_' s) Q' \\<and>\n                            upd\\<^sub>n [(''n'', n_' s)] s'\n                            \\<in> ?P'18 s s' \\<and>\n                            Q' \\<subseteq> \\<lbrace>\\<acute>r =\n              \\<^bsup>s\\<^esup>n + \\<^bsup>s'\\<^esup>m\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>n\\<^sub>0 = n_' s;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>\\<acute>n = \\<^bsup>s\\<^esup>n \\<and>\n                                 \\<acute>m = \\<^bsup>s'\\<^esup>m\\<rbrace>\n                        callClosure upd\\<^sub>n (e_' s)\n                        \\<lbrace>\\<acute>r =\n                                 \\<^bsup>s\\<^esup>n +\n                                 \\<^bsup>s'\\<^esup>m\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'18 s s')\n   callClosure upd\\<^sub>n (e_' s) (?Q'20 s s') \\<and>\n                         upd\\<^sub>n [(''n'', n_' s)] s'\n                         \\<in> ?P'18 s s' \\<and>\n                         ?Q'20 s s'\n                         \\<subseteq> \\<lbrace>\\<acute>r =\n        \\<^bsup>s\\<^esup>n + \\<^bsup>s'\\<^esup>m\\<rbrace>", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>n\\<^sub>0 = n_' s;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>\\<acute>n = \\<^bsup>s\\<^esup>n \\<and>\n                                 \\<acute>m = \\<^bsup>s'\\<^esup>m\\<rbrace>\n                        callClosure upd\\<^sub>n (e_' s)\n                        \\<lbrace>\\<acute>r =\n                                 \\<^bsup>s\\<^esup>n +\n                                 \\<^bsup>s'\\<^esup>m\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'18 s s')\n   callClosure upd\\<^sub>n (e_' s) (?Q'20 s s')\n 2. \\<And>s s'.\n       \\<lbrakk>n\\<^sub>0 = n_' s;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>\\<acute>n = \\<^bsup>s\\<^esup>n \\<and>\n                                 \\<acute>m = \\<^bsup>s'\\<^esup>m\\<rbrace>\n                        callClosure upd\\<^sub>n (e_' s)\n                        \\<lbrace>\\<acute>r =\n                                 \\<^bsup>s\\<^esup>n +\n                                 \\<^bsup>s'\\<^esup>m\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> upd\\<^sub>n [(''n'', n_' s)] s'\n                         \\<in> ?P'18 s s' \\<and>\n                         ?Q'20 s s'\n                         \\<subseteq> \\<lbrace>\\<acute>r =\n        \\<^bsup>s\\<^esup>n + \\<^bsup>s'\\<^esup>m\\<rbrace>", "apply (assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>n\\<^sub>0 = n_' s;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>\\<acute>n = \\<^bsup>s\\<^esup>n \\<and>\n                                 \\<acute>m = \\<^bsup>s'\\<^esup>m\\<rbrace>\n                        callClosure upd\\<^sub>n (e_' s)\n                        \\<lbrace>\\<acute>r =\n                                 \\<^bsup>s\\<^esup>n +\n                                 \\<^bsup>s'\\<^esup>m\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> upd\\<^sub>n [(''n'', n_' s)] s'\n                         \\<in> \\<lbrace>\\<acute>n =\n  \\<^bsup>s\\<^esup>n \\<and>\n  \\<acute>m = \\<^bsup>s'\\<^esup>m\\<rbrace> \\<and>\n                         \\<lbrace>\\<acute>r =\n                                  \\<^bsup>s\\<^esup>n +\n                                  \\<^bsup>s'\\<^esup>m\\<rbrace>\n                         \\<subseteq> \\<lbrace>\\<acute>r =\n        \\<^bsup>s\\<^esup>n + \\<^bsup>s'\\<^esup>m\\<rbrace>", "apply (simp add: upd\\<^sub>n_def gen_upd_def var\\<^sub>n_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"var = [''p''\\<mapsto> (\\<lambda>x. p_'_update (\\<lambda>_. x))]\""], ["", "definition \"upd = gen_upd var\""], ["", "procedures Inc(p|r) =\n \"\\<acute>p\\<rightarrow>\\<acute>cnt :== \\<acute>p\\<rightarrow>\\<acute>cnt + 1;;\n  \\<acute>r :== \\<acute>p\\<rightarrow>\\<acute>cnt\""], ["", "lemma (in Inc_impl)\n \"\\<forall>i p. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> \\<acute>r :== PROC Inc(\\<acute>p) \\<lbrace>\\<acute>r=i+1 \\<and> \\<acute>p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i p.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>p\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       \\<acute>r :== PROC Inc(\\<acute>p)\n                       \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                \\<acute>p\\<rightarrow>\\<acute>cnt =\n                                i + 1\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt p.\n       (cnt(p := cnt p + 1)) p = cnt p + 1 \\<and>\n       (cnt(p := cnt p + 1)) p = cnt p + 1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "procedures (imports Inc_signature) NewCounter(|c) =\n\"\\<acute>p :== NEW 1 [\\<acute>cnt :== 0];;\n \\<acute>c :== ([(''p'',\\<acute>p)],Inc_'proc)\""], ["", "locale NewCounter_impl' = NewCounter_impl + Inc_impl"], ["", "lemma (in NewCounter_impl')\nshows\n  \"\\<forall>alloc. \\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace> \\<acute>c :== PROC NewCounter()\n          \\<lbrace>\\<exists>p. p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n               (\\<forall>i. \\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> callClosure upd \\<acute>c \\<lbrace>\\<acute>r=i+1 \\<and> p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>alloc.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                       \\<acute>c :== PROC NewCounter()\n                       \\<lbrace>\\<exists>p.\n                                   p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n                                   (\\<forall>i.\n \\<Gamma>\n    \\<turnstile> {s. \\<^bsup>s\\<^esup>cnt p = i} callClosure upd \\<acute>c\n                 {s. \\<^bsup>s\\<^esup>r = i + 1 \\<and>\n                     \\<^bsup>s\\<^esup>cnt p = i + 1})\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       1 \\<le> free \\<Longrightarrow>\n       (1 \\<le> free \\<longrightarrow>\n        (\\<exists>p.\n            (cnt(new (set alloc) := 0)) p = 0 \\<and>\n            (\\<forall>i.\n                \\<Gamma>\n                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n   i\\<rbrace>\n                                callClosure upd\n                                 ([(''p'', new (set alloc))], Inc_'proc)\n                                \\<lbrace>\\<acute>r = i + 1 \\<and>\n   p\\<rightarrow>\\<acute>cnt = i + 1\\<rbrace>))) \\<and>\n       (\\<not> 1 \\<le> free \\<longrightarrow>\n        (\\<exists>p.\n            cnt p = 0 \\<and>\n            (\\<forall>i.\n                \\<Gamma>\n                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n   i\\<rbrace>\n                                callClosure upd ([(''p'', Null)], Inc_'proc)\n                                \\<lbrace>\\<acute>r = i + 1 \\<and>\n   p\\<rightarrow>\\<acute>cnt = i + 1\\<rbrace>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<exists>p.\n          (p = new (set alloc) \\<longrightarrow>\n           (\\<forall>i.\n               \\<Gamma>\n                  \\<turnstile> \\<lbrace>new\n   (set alloc)\\<rightarrow>\\<acute>cnt =\n  i\\<rbrace>\n                               callClosure upd\n                                ([(''p'', new (set alloc))], Inc_'proc)\n                               \\<lbrace>\\<acute>r = Suc i \\<and>\n  new (set alloc)\\<rightarrow>\\<acute>cnt = Suc i\\<rbrace>)) \\<and>\n          (p \\<noteq> new (set alloc) \\<longrightarrow>\n           cnt p = 0 \\<and>\n           (\\<forall>i.\n               \\<Gamma>\n                  \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n  i\\<rbrace>\n                               callClosure upd\n                                ([(''p'', new (set alloc))], Inc_'proc)\n                               \\<lbrace>\\<acute>r = Suc i \\<and>\n  p\\<rightarrow>\\<acute>cnt = Suc i\\<rbrace>))", "apply (rule_tac x=\"new (set alloc)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       (new (set alloc) = new (set alloc) \\<longrightarrow>\n        (\\<forall>i.\n            \\<Gamma>\n               \\<turnstile> \\<lbrace>new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     i\\<rbrace>\n                            callClosure upd\n                             ([(''p'', new (set alloc))], Inc_'proc)\n                            \\<lbrace>\\<acute>r = Suc i \\<and>\n                                     new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     Suc i\\<rbrace>)) \\<and>\n       (new (set alloc) \\<noteq> new (set alloc) \\<longrightarrow>\n        cnt (new (set alloc)) = 0 \\<and>\n        (\\<forall>i.\n            \\<Gamma>\n               \\<turnstile> \\<lbrace>new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     i\\<rbrace>\n                            callClosure upd\n                             ([(''p'', new (set alloc))], Inc_'proc)\n                            \\<lbrace>\\<acute>r = Suc i \\<and>\n                                     new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     Suc i\\<rbrace>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<forall>i.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   i\\<rbrace>\n                          callClosure upd\n                           ([(''p'', new (set alloc))], Inc_'proc)\n                          \\<lbrace>\\<acute>r = Suc i \\<and>\n                                   new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   Suc i\\<rbrace>", "apply (simp add: callClosure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<forall>i.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   i\\<rbrace>\n                          Basic (upd [(''p'', new (set alloc))]);;\n                          \\<acute>r :== PROC Inc(\\<acute>p)\n                          \\<lbrace>\\<acute>r = Suc i \\<and>\n                                   new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   Suc i\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> (?R20 alloc free i)\n                       \\<acute>p\\<rightarrow>\\<acute>cnt :==\n                       \\<acute>p\\<rightarrow>\\<acute>cnt + 1;;\n                       \\<acute>r :== \\<acute>p\\<rightarrow>\\<acute>cnt\n                       \\<lbrace>\\<acute>r = Suc i \\<and>\n                                new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                Suc i\\<rbrace>\n 2. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       (?R20 alloc free i)", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> (?R20 alloc free i)\n                       \\<acute>p\\<rightarrow>\\<acute>cnt :==\n                       \\<acute>p\\<rightarrow>\\<acute>cnt + 1\n                       \\<lbrace>\\<acute>p\\<rightarrow>\\<acute>cnt =\n                                Suc i \\<and>\n                                new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                Suc i\\<rbrace>\n 2. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       (?R20 alloc free i)", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       \\<lbrace>(\\<acute>cnt\n                                 (\\<acute>p :=\n                                    \\<acute>p\\<rightarrow>\\<acute>cnt + 1))\n                                 \\<acute>p =\n                                Suc i \\<and>\n                                (\\<acute>cnt\n                                 (\\<acute>p :=\n                                    \\<acute>p\\<rightarrow>\\<acute>cnt + 1))\n                                 (new (set alloc)) =\n                                Suc i\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n       \\<subseteq> {s. ((cnt_' (globals (upd [(''p'', new (set alloc))] s)))\n                        (p_' (upd [(''p'', new (set alloc))] s) :=\n                           cnt_'\n                            (globals (upd [(''p'', new (set alloc))] s))\n                            (p_' (upd [(''p'', new (set alloc))] s)) +\n                           1))\n                        (p_' (upd [(''p'', new (set alloc))] s)) =\n                       Suc i \\<and>\n                       ((cnt_' (globals (upd [(''p'', new (set alloc))] s)))\n                        (p_' (upd [(''p'', new (set alloc))] s) :=\n                           cnt_'\n                            (globals (upd [(''p'', new (set alloc))] s))\n                            (p_' (upd [(''p'', new (set alloc))] s)) +\n                           1))\n                        (new (set alloc)) =\n                       Suc i}", "apply (simp add: upd_def var_def gen_upd_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in NewCounter_impl')\n\nshows\n  \"\\<forall>alloc. \\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace> \\<acute>c :== PROC NewCounter()\n          \\<lbrace>\\<exists>p. p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n               (\\<forall>i. \\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> callClosure upd \\<acute>c \\<lbrace>\\<acute>r=i+1 \\<and> p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>alloc.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                       \\<acute>c :== PROC NewCounter()\n                       \\<lbrace>\\<exists>p.\n                                   p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n                                   (\\<forall>i.\n \\<Gamma>\n    \\<turnstile> {s. \\<^bsup>s\\<^esup>cnt p = i} callClosure upd \\<acute>c\n                 {s. \\<^bsup>s\\<^esup>r = i + 1 \\<and>\n                     \\<^bsup>s\\<^esup>cnt p = i + 1})\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       1 \\<le> free \\<Longrightarrow>\n       (1 \\<le> free \\<longrightarrow>\n        (\\<exists>p.\n            (cnt(new (set alloc) := 0)) p = 0 \\<and>\n            (\\<forall>i.\n                \\<Gamma>\n                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n   i\\<rbrace>\n                                callClosure upd\n                                 ([(''p'', new (set alloc))], Inc_'proc)\n                                \\<lbrace>\\<acute>r = i + 1 \\<and>\n   p\\<rightarrow>\\<acute>cnt = i + 1\\<rbrace>))) \\<and>\n       (\\<not> 1 \\<le> free \\<longrightarrow>\n        (\\<exists>p.\n            cnt p = 0 \\<and>\n            (\\<forall>i.\n                \\<Gamma>\n                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n   i\\<rbrace>\n                                callClosure upd ([(''p'', Null)], Inc_'proc)\n                                \\<lbrace>\\<acute>r = i + 1 \\<and>\n   p\\<rightarrow>\\<acute>cnt = i + 1\\<rbrace>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<exists>p.\n          (p = new (set alloc) \\<longrightarrow>\n           (\\<forall>i.\n               \\<Gamma>\n                  \\<turnstile> \\<lbrace>new\n   (set alloc)\\<rightarrow>\\<acute>cnt =\n  i\\<rbrace>\n                               callClosure upd\n                                ([(''p'', new (set alloc))], Inc_'proc)\n                               \\<lbrace>\\<acute>r = Suc i \\<and>\n  new (set alloc)\\<rightarrow>\\<acute>cnt = Suc i\\<rbrace>)) \\<and>\n          (p \\<noteq> new (set alloc) \\<longrightarrow>\n           cnt p = 0 \\<and>\n           (\\<forall>i.\n               \\<Gamma>\n                  \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n  i\\<rbrace>\n                               callClosure upd\n                                ([(''p'', new (set alloc))], Inc_'proc)\n                               \\<lbrace>\\<acute>r = Suc i \\<and>\n  p\\<rightarrow>\\<acute>cnt = Suc i\\<rbrace>))", "apply (rule_tac x=\"new (set alloc)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       (new (set alloc) = new (set alloc) \\<longrightarrow>\n        (\\<forall>i.\n            \\<Gamma>\n               \\<turnstile> \\<lbrace>new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     i\\<rbrace>\n                            callClosure upd\n                             ([(''p'', new (set alloc))], Inc_'proc)\n                            \\<lbrace>\\<acute>r = Suc i \\<and>\n                                     new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     Suc i\\<rbrace>)) \\<and>\n       (new (set alloc) \\<noteq> new (set alloc) \\<longrightarrow>\n        cnt (new (set alloc)) = 0 \\<and>\n        (\\<forall>i.\n            \\<Gamma>\n               \\<turnstile> \\<lbrace>new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     i\\<rbrace>\n                            callClosure upd\n                             ([(''p'', new (set alloc))], Inc_'proc)\n                            \\<lbrace>\\<acute>r = Suc i \\<and>\n                                     new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     Suc i\\<rbrace>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<forall>i.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   i\\<rbrace>\n                          callClosure upd\n                           ([(''p'', new (set alloc))], Inc_'proc)\n                          \\<lbrace>\\<acute>r = Suc i \\<and>\n                                   new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   Suc i\\<rbrace>", "apply (simp add: callClosure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<forall>i.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   i\\<rbrace>\n                          Basic (upd [(''p'', new (set alloc))]);;\n                          \\<acute>r :== PROC Inc(\\<acute>p)\n                          \\<lbrace>\\<acute>r = Suc i \\<and>\n                                   new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   Suc i\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> (?R20 alloc free i)\n                       \\<acute>p\\<rightarrow>\\<acute>cnt :==\n                       \\<acute>p\\<rightarrow>\\<acute>cnt + 1;;\n                       \\<acute>r :== \\<acute>p\\<rightarrow>\\<acute>cnt\n                       \\<lbrace>\\<acute>r = Suc i \\<and>\n                                new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                Suc i\\<rbrace>\n 2. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       (?R20 alloc free i)", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> (?R20 alloc free i)\n                       \\<acute>p\\<rightarrow>\\<acute>cnt :==\n                       \\<acute>p\\<rightarrow>\\<acute>cnt + 1\n                       \\<lbrace>\\<acute>p\\<rightarrow>\\<acute>cnt =\n                                Suc i \\<and>\n                                new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                Suc i\\<rbrace>\n 2. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       (?R20 alloc free i)", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       \\<lbrace>(\\<acute>cnt\n                                 (\\<acute>p :=\n                                    \\<acute>p\\<rightarrow>\\<acute>cnt + 1))\n                                 \\<acute>p =\n                                Suc i \\<and>\n                                (\\<acute>cnt\n                                 (\\<acute>p :=\n                                    \\<acute>p\\<rightarrow>\\<acute>cnt + 1))\n                                 (new (set alloc)) =\n                                Suc i\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n       \\<subseteq> {s. ((cnt_' (globals (upd [(''p'', new (set alloc))] s)))\n                        (p_' (upd [(''p'', new (set alloc))] s) :=\n                           cnt_'\n                            (globals (upd [(''p'', new (set alloc))] s))\n                            (p_' (upd [(''p'', new (set alloc))] s)) +\n                           1))\n                        (p_' (upd [(''p'', new (set alloc))] s)) =\n                       Suc i \\<and>\n                       ((cnt_' (globals (upd [(''p'', new (set alloc))] s)))\n                        (p_' (upd [(''p'', new (set alloc))] s) :=\n                           cnt_'\n                            (globals (upd [(''p'', new (set alloc))] s))\n                            (p_' (upd [(''p'', new (set alloc))] s)) +\n                           1))\n                        (new (set alloc)) =\n                       Suc i}", "apply (simp add: upd_def var_def gen_upd_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in NewCounter_impl')\nshows NewCounter_spec:\n  \"\\<forall>alloc. \\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free \\<and> \\<acute>alloc=alloc\\<rbrace> \\<acute>c :== PROC NewCounter()\n          \\<lbrace>\\<exists>p. p \\<notin> set alloc \\<and> p \\<in> set \\<acute>alloc \\<and> p \\<noteq> Null \\<and> p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n               (\\<forall>i. \\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> callClosure upd \\<acute>c \\<lbrace>\\<acute>r=i+1 \\<and> p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>alloc.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free \\<and>\n                                \\<acute>alloc = alloc\\<rbrace>\n                       \\<acute>c :== PROC NewCounter()\n                       \\<lbrace>\\<exists>p.\n                                   p \\<notin> set alloc \\<and>\n                                   p \\<in> set \\<acute>alloc \\<and>\n                                   p \\<noteq> Null \\<and>\n                                   p\\<rightarrow>\\<acute>cnt = 0 \\<and>\n                                   (\\<forall>i.\n \\<Gamma>\n    \\<turnstile> {s. \\<^bsup>s\\<^esup>cnt p = i} callClosure upd \\<acute>c\n                 {s. \\<^bsup>s\\<^esup>r = i + 1 \\<and>\n                     \\<^bsup>s\\<^esup>cnt p = i + 1})\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       1 \\<le> free \\<Longrightarrow>\n       (1 \\<le> free \\<longrightarrow>\n        (\\<exists>p.\n            p \\<notin> set alloc \\<and>\n            p \\<in> set (new (set alloc) # alloc) \\<and>\n            p \\<noteq> Null \\<and>\n            (cnt(new (set alloc) := 0)) p = 0 \\<and>\n            (\\<forall>i.\n                \\<Gamma>\n                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n   i\\<rbrace>\n                                callClosure upd\n                                 ([(''p'', new (set alloc))], Inc_'proc)\n                                \\<lbrace>\\<acute>r = i + 1 \\<and>\n   p\\<rightarrow>\\<acute>cnt = i + 1\\<rbrace>))) \\<and>\n       (\\<not> 1 \\<le> free \\<longrightarrow>\n        (\\<exists>p.\n            p \\<notin> set alloc \\<and>\n            p \\<in> set alloc \\<and>\n            p \\<noteq> Null \\<and>\n            cnt p = 0 \\<and>\n            (\\<forall>i.\n                \\<Gamma>\n                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n   i\\<rbrace>\n                                callClosure upd ([(''p'', Null)], Inc_'proc)\n                                \\<lbrace>\\<acute>r = i + 1 \\<and>\n   p\\<rightarrow>\\<acute>cnt = i + 1\\<rbrace>)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<exists>p.\n          (p = new (set alloc) \\<longrightarrow>\n           (\\<forall>i.\n               \\<Gamma>\n                  \\<turnstile> \\<lbrace>new\n   (set alloc)\\<rightarrow>\\<acute>cnt =\n  i\\<rbrace>\n                               callClosure upd\n                                ([(''p'', new (set alloc))], Inc_'proc)\n                               \\<lbrace>\\<acute>r = Suc i \\<and>\n  new (set alloc)\\<rightarrow>\\<acute>cnt = Suc i\\<rbrace>)) \\<and>\n          (p \\<noteq> new (set alloc) \\<longrightarrow>\n           p \\<notin> set alloc \\<and>\n           p \\<in> set alloc \\<and>\n           p \\<noteq> Null \\<and>\n           cnt p = 0 \\<and>\n           (\\<forall>i.\n               \\<Gamma>\n                  \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n  i\\<rbrace>\n                               callClosure upd\n                                ([(''p'', new (set alloc))], Inc_'proc)\n                               \\<lbrace>\\<acute>r = Suc i \\<and>\n  p\\<rightarrow>\\<acute>cnt = Suc i\\<rbrace>))", "apply (rule_tac x=\"new (set alloc)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cnt alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       (new (set alloc) = new (set alloc) \\<longrightarrow>\n        (\\<forall>i.\n            \\<Gamma>\n               \\<turnstile> \\<lbrace>new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     i\\<rbrace>\n                            callClosure upd\n                             ([(''p'', new (set alloc))], Inc_'proc)\n                            \\<lbrace>\\<acute>r = Suc i \\<and>\n                                     new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     Suc i\\<rbrace>)) \\<and>\n       (new (set alloc) \\<noteq> new (set alloc) \\<longrightarrow>\n        new (set alloc) \\<notin> set alloc \\<and>\n        new (set alloc) \\<in> set alloc \\<and>\n        new (set alloc) \\<noteq> Null \\<and>\n        cnt (new (set alloc)) = 0 \\<and>\n        (\\<forall>i.\n            \\<Gamma>\n               \\<turnstile> \\<lbrace>new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     i\\<rbrace>\n                            callClosure upd\n                             ([(''p'', new (set alloc))], Inc_'proc)\n                            \\<lbrace>\\<acute>r = Suc i \\<and>\n                                     new\n(set alloc)\\<rightarrow>\\<acute>cnt =\n                                     Suc i\\<rbrace>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<forall>i.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   i\\<rbrace>\n                          callClosure upd\n                           ([(''p'', new (set alloc))], Inc_'proc)\n                          \\<lbrace>\\<acute>r = Suc i \\<and>\n                                   new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   Suc i\\<rbrace>", "apply (simp add: callClosure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<forall>i.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   i\\<rbrace>\n                          Basic (upd [(''p'', new (set alloc))]);;\n                          \\<acute>r :== PROC Inc(\\<acute>p)\n                          \\<lbrace>\\<acute>r = Suc i \\<and>\n                                   new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                   Suc i\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> (?R22 alloc free i)\n                       \\<acute>p\\<rightarrow>\\<acute>cnt :==\n                       \\<acute>p\\<rightarrow>\\<acute>cnt + 1;;\n                       \\<acute>r :== \\<acute>p\\<rightarrow>\\<acute>cnt\n                       \\<lbrace>\\<acute>r = Suc i \\<and>\n                                new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                Suc i\\<rbrace>\n 2. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       (?R22 alloc free i)", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> (?R22 alloc free i)\n                       \\<acute>p\\<rightarrow>\\<acute>cnt :==\n                       \\<acute>p\\<rightarrow>\\<acute>cnt + 1\n                       \\<lbrace>\\<acute>p\\<rightarrow>\\<acute>cnt =\n                                Suc i \\<and>\n                                new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                Suc i\\<rbrace>\n 2. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       (?R22 alloc free i)", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt =\n                                i\\<rbrace>\n                       Basic (upd [(''p'', new (set alloc))])\n                       \\<lbrace>(\\<acute>cnt\n                                 (\\<acute>p :=\n                                    \\<acute>p\\<rightarrow>\\<acute>cnt + 1))\n                                 \\<acute>p =\n                                Suc i \\<and>\n                                (\\<acute>cnt\n                                 (\\<acute>p :=\n                                    \\<acute>p\\<rightarrow>\\<acute>cnt + 1))\n                                 (new (set alloc)) =\n                                Suc i\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free i.\n       Suc 0 \\<le> free \\<Longrightarrow>\n       \\<lbrace>new (set alloc)\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n       \\<subseteq> {s. ((cnt_' (globals (upd [(''p'', new (set alloc))] s)))\n                        (p_' (upd [(''p'', new (set alloc))] s) :=\n                           cnt_'\n                            (globals (upd [(''p'', new (set alloc))] s))\n                            (p_' (upd [(''p'', new (set alloc))] s)) +\n                           1))\n                        (p_' (upd [(''p'', new (set alloc))] s)) =\n                       Suc i \\<and>\n                       ((cnt_' (globals (upd [(''p'', new (set alloc))] s)))\n                        (p_' (upd [(''p'', new (set alloc))] s) :=\n                           cnt_'\n                            (globals (upd [(''p'', new (set alloc))] s))\n                            (p_' (upd [(''p'', new (set alloc))] s)) +\n                           1))\n                        (new (set alloc)) =\n                       Suc i}", "apply (simp add: upd_def var_def gen_upd_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<Gamma>\\<turnstile>\\<lbrace>\\<exists>p. p \\<noteq> Null \\<and> p\\<rightarrow>\\<acute>cnt = i \\<and>\n              (\\<forall>i. \\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace> callClosure upd \\<acute>c \\<lbrace>\\<acute>r=i+1 \\<and> p\\<rightarrow>\\<acute>cnt = i+1\\<rbrace>)\\<rbrace>\n           dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>r_' := r_' t\\<rparr>))\n           \\<lbrace>\\<acute>r=i+1\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<exists>p.\n                                p \\<noteq> Null \\<and>\n                                p\\<rightarrow>\\<acute>cnt = i \\<and>\n                                (\\<forall>i.\n                                    \\<Gamma>\n \\<turnstile> {s. \\<^bsup>s\\<^esup>cnt p = i} callClosure upd \\<acute>c\n              {s. \\<^bsup>s\\<^esup>r = i + 1 \\<and>\n                  \\<^bsup>s\\<^esup>cnt p = i + 1})\\<rbrace>\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    \\<lbrace>\\<acute>r = i + 1\\<rbrace>", "apply (rule conseq_extract_pre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>\\<lbrace>\\<exists>p.\n                               p \\<noteq> Null \\<and>\n                               p\\<rightarrow>\\<acute>cnt = i \\<and>\n                               (\\<forall>i.\n                                   \\<Gamma>\n\\<turnstile> {s. \\<^bsup>s\\<^esup>cnt p = i} callClosure upd \\<acute>c\n             {s. \\<^bsup>s\\<^esup>r = i + 1 \\<and>\n                 \\<^bsup>s\\<^esup>cnt p = i + 1})\\<rbrace>.\n       \\<Gamma>\n          \\<turnstile> {s}\n                       dynCallClosure (\\<lambda>s. s) upd c_'\n                        (\\<lambda>s t. s\n                            \\<lparr>globals := globals t\\<rparr>)\n                        (\\<lambda>s t. \\<acute>r :== r_' t)\n                       \\<lbrace>\\<acute>r = i + 1\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> {s}\n   dynCallClosure (\\<lambda>s. s) upd c_'\n    (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n    (\\<lambda>s t. \\<acute>r :== r_' t)\n   \\<lbrace>\\<acute>r = \\<^bsup>s\\<^esup>cnt p + 1\\<rbrace>", "apply (rule dynCallClosureFix)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> {s}\n                         \\<subseteq> {sa.\n\\<exists>Z.\n   ?cl'10 s p = c_' sa \\<and>\n   sa \\<in> ?P'10 s p Z \\<and>\n   (\\<forall>t\\<in>?Q'10 s p Z.\n       sa\\<lparr>globals := globals t\\<rparr> \\<in> ?R10 s p sa t) \\<and>\n   (\\<forall>t\\<in>?A'10 s p Z.\n       sa\\<lparr>globals := globals t\\<rparr> \\<in> {})}\n 2. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa t.\n                            \\<Gamma>\n                               \\<turnstile> (?R10 s p sa t)\n      \\<acute>r :== r_' t\n      \\<lbrace>\\<acute>r = \\<^bsup>s\\<^esup>cnt p + 1\\<rbrace>\n 3. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Z.\n                            \\<Gamma>\n                               \\<turnstile> (?P'10 s p Z)\n      callClosure upd (?cl'10 s p) (?Q'10 s p Z),(?A'10 s p Z)", "apply (simp only: Ball_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> {s}\n                         \\<subseteq> {sa.\n\\<exists>Z.\n   ?cl'10 s p = c_' sa \\<and>\n   sa \\<in> ?P'10 s p Z \\<and>\n   (\\<forall>x.\n       x \\<in> ?Q'10 s p Z \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> ?R10 s p sa x) \\<and>\n   (\\<forall>x.\n       x \\<in> ?A'10 s p Z \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> {})}\n 2. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa t.\n                            \\<Gamma>\n                               \\<turnstile> (?R10 s p sa t)\n      \\<acute>r :== r_' t\n      \\<lbrace>\\<acute>r = \\<^bsup>s\\<^esup>cnt p + 1\\<rbrace>\n 3. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Z.\n                            \\<Gamma>\n                               \\<turnstile> (?P'10 s p Z)\n      callClosure upd (?cl'10 s p) (?Q'10 s p Z),(?A'10 s p Z)", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Z.\n                            \\<Gamma>\n                               \\<turnstile> (?P'10 s p Z)\n      callClosure upd (?cl'10 s p) (?Q'10 s p Z),(?A'10 s p Z)\n 2. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> {s}\n                         \\<subseteq> {sa.\n\\<exists>Z.\n   ?cl'10 s p = c_' sa \\<and>\n   sa \\<in> ?P'10 s p Z \\<and>\n   (\\<forall>x.\n       x \\<in> ?Q'10 s p Z \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> ?R10 s p sa x) \\<and>\n   (\\<forall>x.\n       x \\<in> ?A'10 s p Z \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> {})}\n 3. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa t.\n                            \\<Gamma>\n                               \\<turnstile> (?R10 s p sa t)\n      \\<acute>r :== r_' t\n      \\<lbrace>\\<acute>r = \\<^bsup>s\\<^esup>cnt p + 1\\<rbrace>", "apply (assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> {s}\n                         \\<subseteq> {sa.\n\\<exists>Z.\n   c_' s = c_' sa \\<and>\n   sa \\<in> \\<lbrace>p\\<rightarrow>\\<acute>cnt = Z\\<rbrace> \\<and>\n   (\\<forall>x.\n       x \\<in> \\<lbrace>\\<acute>r = Z + 1 \\<and>\n                        p\\<rightarrow>\\<acute>cnt =\n                        Z + 1\\<rbrace> \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> ?R10 s p sa x) \\<and>\n   (\\<forall>x.\n       x \\<in> {} \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> {})}\n 2. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa t.\n                            \\<Gamma>\n                               \\<turnstile> (?R10 s p sa t)\n      \\<acute>r :== r_' t\n      \\<lbrace>\\<acute>r = \\<^bsup>s\\<^esup>cnt p + 1\\<rbrace>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sa t.\n                            \\<Gamma>\n                               \\<turnstile> (?R10 s p sa t)\n      \\<acute>r :== r_' t\n      \\<lbrace>\\<acute>r = \\<^bsup>s\\<^esup>cnt p + 1\\<rbrace>\n 2. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> {s}\n                         \\<subseteq> {sa.\n\\<exists>Z.\n   c_' s = c_' sa \\<and>\n   sa \\<in> \\<lbrace>p\\<rightarrow>\\<acute>cnt = Z\\<rbrace> \\<and>\n   (\\<forall>x.\n       x \\<in> \\<lbrace>\\<acute>r = Z + 1 \\<and>\n                        p\\<rightarrow>\\<acute>cnt =\n                        Z + 1\\<rbrace> \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> ?R10 s p sa x) \\<and>\n   (\\<forall>x.\n       x \\<in> {} \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' s)\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>;\n        i = cnt_' (globals s) p\\<rbrakk>\n       \\<Longrightarrow> {s}\n                         \\<subseteq> {sa.\n\\<exists>Z.\n   c_' s = c_' sa \\<and>\n   sa \\<in> \\<lbrace>p\\<rightarrow>\\<acute>cnt = Z\\<rbrace> \\<and>\n   (\\<forall>x.\n       x \\<in> \\<lbrace>\\<acute>r = Z + 1 \\<and>\n                        p\\<rightarrow>\\<acute>cnt =\n                        Z + 1\\<rbrace> \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr>\n       \\<in> \\<lbrace>\\<^bsup>x\\<^esup>r =\n                      \\<^bsup>s\\<^esup>cnt p + 1\\<rbrace>) \\<and>\n   (\\<forall>x.\n       x \\<in> {} \\<longrightarrow>\n       sa\\<lparr>globals := globals x\\<rparr> \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p cnt c.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd c\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z.\n                            c = c \\<and>\n                            cnt p = Z \\<and>\n                            (\\<forall>cnta r.\n                                r = Z + 1 \\<and>\n                                cnta p = Z + 1 \\<longrightarrow>\n                                r = cnt p + 1) \\<and>\n                            (False \\<longrightarrow> False)", "apply (simp only: simp_thms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p cnt c.\n       \\<lbrakk>p \\<noteq> Null;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd c\n                           \\<lbrace>\\<acute>r = i + 1 \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    i + 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cnta r.\n                            r = cnt p + 1 \\<and>\n                            cnta p = cnt p + 1 \\<longrightarrow>\n                            r = cnt p + 1", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in NewCounter_impl')\n shows \"\\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n             \\<acute>c :== CALL NewCounter ();;\n             dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>r_' := r_' t\\<rparr>))\n           \\<lbrace>\\<acute>r=1\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    \\<lbrace>\\<acute>r = 1\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma>\n       \\<turnstile> ?R dynCallClosure (\\<lambda>s. s) upd c_'\n                        (\\<lambda>s t. s\n                            \\<lparr>globals := globals t\\<rparr>)\n                        (\\<lambda>s t. \\<acute>r :== r_' t)\n                    \\<lbrace>\\<acute>r = 1\\<rbrace>\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter() ?R", "apply (rule dynCallClosure)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?R \\<subseteq> {s. \\<exists>P' Q' A'.\n                          \\<Gamma>\n                             \\<turnstile> P' callClosure upd (c_' s) Q',\n    A' \\<and>\n                          s \\<in> P' \\<and>\n                          (\\<forall>t\\<in>Q'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> ?R1 s t) \\<and>\n                          (\\<forall>t\\<in>A'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> {})}\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R1 s t) \\<acute>r :== r_' t\n                       \\<lbrace>\\<acute>r = 1\\<rbrace>\n 3. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter() ?R", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R1 s t) \\<acute>r :== r_' t\n                       \\<lbrace>\\<acute>r = 1\\<rbrace>\n 2. ?R \\<subseteq> {s. \\<exists>P' Q' A'.\n                          \\<Gamma>\n                             \\<turnstile> P' callClosure upd (c_' s) Q',\n    A' \\<and>\n                          s \\<in> P' \\<and>\n                          (\\<forall>t\\<in>Q'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> ?R1 s t) \\<and>\n                          (\\<forall>t\\<in>A'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> {})}\n 3. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter() ?R", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?R \\<subseteq> {s. \\<exists>P' Q' A'.\n                          \\<Gamma>\n                             \\<turnstile> P' callClosure upd (c_' s) Q',\n    A' \\<and>\n                          s \\<in> P' \\<and>\n                          (\\<forall>t\\<in>Q'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> \\<lbrace>\\<^bsup>t\\<^esup>r =\n       1\\<rbrace>) \\<and>\n                          (\\<forall>t\\<in>A'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> {})}\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter() ?R", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter()\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (c_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> \\<lbrace>\\<^bsup>t\\<^esup>r =\n        1\\<rbrace>) \\<and>\n                           (\\<forall>t\\<in>A'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n    \\<subseteq> {s. 1 \\<le> free_' (globals s) \\<and>\n                    (\\<forall>t.\n                        (\\<exists>p.\n                            p \\<notin> set (alloc_' (globals s)) \\<and>\n                            p \\<in> set (alloc_' (globals t)) \\<and>\n                            p \\<noteq> Null \\<and>\n                            cnt_' (globals t) p = 0 \\<and>\n                            (\\<forall>i.\n                                \\<Gamma>\n                                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n                   i\\<rbrace>\n          callClosure upd (c_' t)\n          \\<lbrace>\\<acute>r = i + 1 \\<and>\n                   p\\<rightarrow>\\<acute>cnt =\n                   i + 1\\<rbrace>)) \\<longrightarrow>\n                        (\\<exists>P' Q' A'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t) Q',\n      A' \\<and>\n                            s\\<lparr>globals := globals t,\n                                c_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = 1) \\<and>\n                            (\\<forall>t\\<in>A'. False)))}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>globals := globals t,\n                                c_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = Suc 0)", "apply (erule_tac x=0 in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>globals := globals t,\n                                c_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = Suc 0)", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q'.\n                            \\<Gamma>\n                               \\<turnstile> (?P'34 x t p)\n      callClosure upd (c_' t) Q' \\<and>\n                            x\\<lparr>globals := globals t,\n                                c_' := c_' t\\<rparr>\n                            \\<in> ?P'34 x t p \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = Suc 0)", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'34 x t p)\n   callClosure upd (c_' t) (?Q'36 x t p) \\<and>\n                         x\\<lparr>globals := globals t, c_' := c_' t\\<rparr>\n                         \\<in> ?P'34 x t p \\<and>\n                         (\\<forall>t\\<in>?Q'36 x t p. r_' t = Suc 0)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'34 x t p)\n   callClosure upd (c_' t) (?Q'36 x t p)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>globals := globals t, c_' := c_' t\\<rparr>\n                         \\<in> ?P'34 x t p \\<and>\n                         (\\<forall>t\\<in>?Q'36 x t p. r_' t = Suc 0)", "apply (assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>globals := globals t, c_' := c_' t\\<rparr>\n                         \\<in> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n  0\\<rbrace> \\<and>\n                         (\\<forall>t\\<in>\\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>.\n                             r_' t = Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in NewCounter_impl')\n shows \"\\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n             \\<acute>c :== CALL NewCounter ();;\n             dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>r_' := r_' t\\<rparr>));;\n             dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>r_' := r_' t\\<rparr>))\n           \\<lbrace>\\<acute>r=2\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t);;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    \\<lbrace>\\<acute>r = 2\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma>\n       \\<turnstile> ?R dynCallClosure (\\<lambda>s. s) upd c_'\n                        (\\<lambda>s t. s\n                            \\<lparr>globals := globals t\\<rparr>)\n                        (\\<lambda>s t. \\<acute>r :== r_' t)\n                    \\<lbrace>\\<acute>r = 2\\<rbrace>\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    ?R", "apply (rule dynCallClosure)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?R \\<subseteq> {s. \\<exists>P' Q' A'.\n                          \\<Gamma>\n                             \\<turnstile> P' callClosure upd (c_' s) Q',\n    A' \\<and>\n                          s \\<in> P' \\<and>\n                          (\\<forall>t\\<in>Q'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> ?R1 s t) \\<and>\n                          (\\<forall>t\\<in>A'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> {})}\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R1 s t) \\<acute>r :== r_' t\n                       \\<lbrace>\\<acute>r = 2\\<rbrace>\n 3. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    ?R", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R1 s t) \\<acute>r :== r_' t\n                       \\<lbrace>\\<acute>r = 2\\<rbrace>\n 2. ?R \\<subseteq> {s. \\<exists>P' Q' A'.\n                          \\<Gamma>\n                             \\<turnstile> P' callClosure upd (c_' s) Q',\n    A' \\<and>\n                          s \\<in> P' \\<and>\n                          (\\<forall>t\\<in>Q'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> ?R1 s t) \\<and>\n                          (\\<forall>t\\<in>A'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> {})}\n 3. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    ?R", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?R \\<subseteq> {s. \\<exists>P' Q' A'.\n                          \\<Gamma>\n                             \\<turnstile> P' callClosure upd (c_' s) Q',\n    A' \\<and>\n                          s \\<in> P' \\<and>\n                          (\\<forall>t\\<in>Q'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> \\<lbrace>\\<^bsup>t\\<^esup>r =\n       2\\<rbrace>) \\<and>\n                          (\\<forall>t\\<in>A'.\n                              s\\<lparr>globals := globals t\\<rparr>\n                              \\<in> {})}\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    ?R", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (c_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> \\<lbrace>\\<^bsup>t\\<^esup>r =\n        2\\<rbrace>) \\<and>\n                           (\\<forall>t\\<in>A'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma>\n       \\<turnstile> ?R13\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>r :== r_' t)\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (c_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'. r_' t = 2) \\<and>\n                           (\\<forall>t\\<in>A'. False)}\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter() ?R13", "apply (rule dynCallClosure)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?R13\n    \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<Gamma>\n                          \\<turnstile> P' callClosure upd (c_' s) Q',\n A' \\<and>\n                       s \\<in> P' \\<and>\n                       (\\<forall>t\\<in>Q'.\n                           s\\<lparr>globals := globals t\\<rparr>\n                           \\<in> ?R14 s t) \\<and>\n                       (\\<forall>t\\<in>A'.\n                           s\\<lparr>globals := globals t\\<rparr> \\<in> {})}\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R14 s t) \\<acute>r :== r_' t\n                       {s. \\<exists>P' Q' A'.\n                              \\<Gamma>\n                                 \\<turnstile> P' callClosure upd (c_' s) Q',\n        A' \\<and>\n                              s \\<in> P' \\<and>\n                              (\\<forall>t\\<in>Q'. r_' t = 2) \\<and>\n                              (\\<forall>t\\<in>A'. False)}\n 3. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter() ?R13", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R14 s t) \\<acute>r :== r_' t\n                       {s. \\<exists>P' Q' A'.\n                              \\<Gamma>\n                                 \\<turnstile> P' callClosure upd (c_' s) Q',\n        A' \\<and>\n                              s \\<in> P' \\<and>\n                              (\\<forall>t\\<in>Q'. r_' t = 2) \\<and>\n                              (\\<forall>t\\<in>A'. False)}\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter()\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (c_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> ?R14 s t) \\<and>\n                           (\\<forall>t\\<in>A'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter()\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (c_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {s.\n\\<exists>P' Q' A'.\n   \\<Gamma>\\<turnstile> P' callClosure upd (c_' s) Q',A' \\<and>\n   s\\<lparr>r_' := r_' t\\<rparr> \\<in> P' \\<and>\n   (\\<forall>t\\<in>Q'. r_' t = 2) \\<and> (\\<forall>t\\<in>A'. False)}) \\<and>\n                           (\\<forall>t\\<in>A'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n    \\<subseteq> {s. 1 \\<le> free_' (globals s) \\<and>\n                    (\\<forall>t.\n                        (\\<exists>p.\n                            p \\<notin> set (alloc_' (globals s)) \\<and>\n                            p \\<in> set (alloc_' (globals t)) \\<and>\n                            p \\<noteq> Null \\<and>\n                            cnt_' (globals t) p = 0 \\<and>\n                            (\\<forall>i.\n                                \\<Gamma>\n                                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n                   i\\<rbrace>\n          callClosure upd (c_' t)\n          \\<lbrace>\\<acute>r = i + 1 \\<and>\n                   p\\<rightarrow>\\<acute>cnt =\n                   i + 1\\<rbrace>)) \\<longrightarrow>\n                        (\\<exists>P' Q' A'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t) Q',\n      A' \\<and>\n                            s\\<lparr>globals := globals t,\n                                c_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>ta\\<in>Q'.\n                                \\<exists>P' Q' A'.\n                                   \\<Gamma>\n\\<turnstile> P' callClosure upd (c_' t) Q',A' \\<and>\n                                   s\\<lparr>c_' := c_' t,\n globals := globals ta, r_' := r_' ta\\<rparr>\n                                   \\<in> P' \\<and>\n                                   (\\<forall>t\\<in>Q'. r_' t = 2) \\<and>\n                                   (\\<forall>t\\<in>A'. False)) \\<and>\n                            (\\<forall>t\\<in>A'. False)))}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>globals := globals t,\n                                c_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>ta\\<in>Q'.\n                                \\<exists>P' Q'.\n                                   \\<Gamma>\n\\<turnstile> P' callClosure upd (c_' t) Q' \\<and>\n                                   x\\<lparr>c_' := c_' t,\n globals := globals ta, r_' := r_' ta\\<rparr>\n                                   \\<in> P' \\<and>\n                                   (\\<forall>t\\<in>Q'. r_' t = 2))", "apply (subgoal_tac \"\\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace> callClosure upd (c_' t) \\<lbrace>\\<acute>r = Suc 0 \\<and> p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>globals := globals t,\n                                c_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>ta\\<in>Q'.\n                                \\<exists>P' Q'.\n                                   \\<Gamma>\n\\<turnstile> P' callClosure upd (c_' t) Q' \\<and>\n                                   x\\<lparr>c_' := c_' t,\n globals := globals ta, r_' := r_' ta\\<rparr>\n                                   \\<in> P' \\<and>\n                                   (\\<forall>t\\<in>Q'. r_' t = 2))\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q'.\n                            \\<Gamma>\n                               \\<turnstile> (?P'46 x t p)\n      callClosure upd (c_' t) Q' \\<and>\n                            x\\<lparr>globals := globals t,\n                                c_' := c_' t\\<rparr>\n                            \\<in> ?P'46 x t p \\<and>\n                            (\\<forall>ta\\<in>Q'.\n                                \\<exists>P' Q'.\n                                   \\<Gamma>\n\\<turnstile> P' callClosure upd (c_' t) Q' \\<and>\n                                   x\\<lparr>c_' := c_' t,\n globals := globals ta, r_' := r_' ta\\<rparr>\n                                   \\<in> P' \\<and>\n                                   (\\<forall>t\\<in>Q'. r_' t = 2))\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'46 x t p)\n   callClosure upd (c_' t) (?Q'48 x t p) \\<and>\n                         x\\<lparr>globals := globals t, c_' := c_' t\\<rparr>\n                         \\<in> ?P'46 x t p \\<and>\n                         (\\<forall>ta\\<in>?Q'48 x t p.\n                             \\<exists>P' Q'.\n                                \\<Gamma>\n                                   \\<turnstile> P' callClosure upd (c_' t)\n          Q' \\<and>\n                                x\\<lparr>c_' := c_' t,\n                                    globals := globals ta,\n                                    r_' := r_' ta\\<rparr>\n                                \\<in> P' \\<and>\n                                (\\<forall>t\\<in>Q'. r_' t = 2))\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'46 x t p)\n   callClosure upd (c_' t) (?Q'48 x t p)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>globals := globals t, c_' := c_' t\\<rparr>\n                         \\<in> ?P'46 x t p \\<and>\n                         (\\<forall>ta\\<in>?Q'48 x t p.\n                             \\<exists>P' Q'.\n                                \\<Gamma>\n                                   \\<turnstile> P' callClosure upd (c_' t)\n          Q' \\<and>\n                                x\\<lparr>c_' := c_' t,\n                                    globals := globals ta,\n                                    r_' := r_' ta\\<rparr>\n                                \\<in> P' \\<and>\n                                (\\<forall>t\\<in>Q'. r_' t = 2))\n 3. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>globals := globals t, c_' := c_' t\\<rparr>\n                         \\<in> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n  0\\<rbrace> \\<and>\n                         (\\<forall>ta\\<in>\\<lbrace>\\<acute>r = Suc 0 \\<and>\n             p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>.\n                             \\<exists>P' Q'.\n                                \\<Gamma>\n                                   \\<turnstile> P' callClosure upd (c_' t)\n          Q' \\<and>\n                                x\\<lparr>c_' := c_' t,\n                                    globals := globals ta,\n                                    r_' := r_' ta\\<rparr>\n                                \\<in> P' \\<and>\n                                (\\<forall>t\\<in>Q'. r_' t = 2))\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        r_' ta = Suc 0; cnt_' (globals ta) p = Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>c_' := c_' t, globals := globals ta,\n                                r_' := Suc 0\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (erule_tac x=1 in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>c_' := c_' t, globals := globals ta,\n                                r_' := Suc 0\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q'.\n                            \\<Gamma>\n                               \\<turnstile> (?P'60 x t p ta)\n      callClosure upd (c_' t) Q' \\<and>\n                            x\\<lparr>c_' := c_' t, globals := globals ta,\n                                r_' := Suc 0\\<rparr>\n                            \\<in> ?P'60 x t p ta \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'60 x t p ta)\n   callClosure upd (c_' t) (?Q'62 x t p ta) \\<and>\n                         x\\<lparr>c_' := c_' t, globals := globals ta,\n                             r_' := Suc 0\\<rparr>\n                         \\<in> ?P'60 x t p ta \\<and>\n                         (\\<forall>t\\<in>?Q'62 x t p ta. r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'60 x t p ta)\n   callClosure upd (c_' t) (?Q'62 x t p ta)\n 2. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>c_' := c_' t, globals := globals ta,\n                             r_' := Suc 0\\<rparr>\n                         \\<in> ?P'60 x t p ta \\<and>\n                         (\\<forall>t\\<in>?Q'62 x t p ta. r_' t = 2)\n 3. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>c_' := c_' t, globals := globals ta,\n                             r_' := Suc 0\\<rparr>\n                         \\<in> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n  1\\<rbrace> \\<and>\n                         (\\<forall>t\\<in>\\<lbrace>\\<acute>r = Suc 1 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 1\\<rbrace>.\n                             r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (erule allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n                                 ?i67 x t p\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc (?i67 x t p) \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc (?i67 x t p)\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in NewCounter_impl')\n shows \"\\<Gamma>\\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n             \\<acute>c :== CALL NewCounter ();;\n             \\<acute>d :== \\<acute>c;;\n             dynCallClosure (\\<lambda>s. s) upd c_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>n_' := r_' t\\<rparr>));;\n             dynCallClosure (\\<lambda>s. s) upd d_' (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                         (\\<lambda>s t. Basic (\\<lambda>u. u\\<lparr>m_' := r_' t\\<rparr>));;\n             \\<acute>r :== \\<acute>n + \\<acute>m\n           \\<lbrace>\\<acute>r=3\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c;;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>n :== r_' t);;\n                    dynCallClosure (\\<lambda>s. s) upd d_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>m :== r_' t);;\n                    \\<acute>r :== \\<acute>n + \\<acute>m\n                    \\<lbrace>\\<acute>r = 3\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c;;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>n :== r_' t);;\n                    dynCallClosure (\\<lambda>s. s) upd d_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>m :== r_' t)\n                    \\<lbrace>\\<acute>n + \\<acute>m = 3\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma>\n       \\<turnstile> ?R3\n                    dynCallClosure (\\<lambda>s. s) upd d_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>m :== r_' t)\n                    \\<lbrace>\\<acute>n + \\<acute>m = 3\\<rbrace>\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c;;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>n :== r_' t)\n                    ?R3", "apply (rule dynCallClosure)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?R3\n    \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<Gamma>\n                          \\<turnstile> P' callClosure upd (d_' s) Q',\n A' \\<and>\n                       s \\<in> P' \\<and>\n                       (\\<forall>t\\<in>Q'.\n                           s\\<lparr>globals := globals t\\<rparr>\n                           \\<in> ?R4 s t) \\<and>\n                       (\\<forall>t\\<in>A'.\n                           s\\<lparr>globals := globals t\\<rparr> \\<in> {})}\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R4 s t) \\<acute>m :== r_' t\n                       \\<lbrace>\\<acute>n + \\<acute>m = 3\\<rbrace>\n 3. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c;;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>n :== r_' t)\n                    ?R3", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R4 s t) \\<acute>m :== r_' t\n                       \\<lbrace>\\<acute>n + \\<acute>m = 3\\<rbrace>\n 2. ?R3\n    \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<Gamma>\n                          \\<turnstile> P' callClosure upd (d_' s) Q',\n A' \\<and>\n                       s \\<in> P' \\<and>\n                       (\\<forall>t\\<in>Q'.\n                           s\\<lparr>globals := globals t\\<rparr>\n                           \\<in> ?R4 s t) \\<and>\n                       (\\<forall>t\\<in>A'.\n                           s\\<lparr>globals := globals t\\<rparr> \\<in> {})}\n 3. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c;;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>n :== r_' t)\n                    ?R3", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?R3\n    \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<Gamma>\n                          \\<turnstile> P' callClosure upd (d_' s) Q',\n A' \\<and>\n                       s \\<in> P' \\<and>\n                       (\\<forall>t\\<in>Q'.\n                           s\\<lparr>globals := globals t\\<rparr>\n                           \\<in> \\<lbrace>\\<acute>n + \\<^bsup>t\\<^esup>r =\n    3\\<rbrace>) \\<and>\n                       (\\<forall>t\\<in>A'.\n                           s\\<lparr>globals := globals t\\<rparr> \\<in> {})}\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c;;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>n :== r_' t)\n                    ?R3", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c;;\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>n :== r_' t)\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (d_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> \\<lbrace>\\<acute>n +\n        \\<^bsup>t\\<^esup>r =\n        3\\<rbrace>) \\<and>\n                           (\\<forall>t\\<in>A'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma>\n       \\<turnstile> ?R16\n                    dynCallClosure (\\<lambda>s. s) upd c_'\n                     (\\<lambda>s t. s\\<lparr>globals := globals t\\<rparr>)\n                     (\\<lambda>s t. \\<acute>n :== r_' t)\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (d_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'. n_' s + r_' t = 3) \\<and>\n                           (\\<forall>t\\<in>A'. False)}\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c\n                    ?R16", "apply (rule dynCallClosure)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?R16\n    \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<Gamma>\n                          \\<turnstile> P' callClosure upd (c_' s) Q',\n A' \\<and>\n                       s \\<in> P' \\<and>\n                       (\\<forall>t\\<in>Q'.\n                           s\\<lparr>globals := globals t\\<rparr>\n                           \\<in> ?R17 s t) \\<and>\n                       (\\<forall>t\\<in>A'.\n                           s\\<lparr>globals := globals t\\<rparr> \\<in> {})}\n 2. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R17 s t) \\<acute>n :== r_' t\n                       {s. \\<exists>P' Q' A'.\n                              \\<Gamma>\n                                 \\<turnstile> P' callClosure upd (d_' s) Q',\n        A' \\<and>\n                              s \\<in> P' \\<and>\n                              (\\<forall>t\\<in>Q'. n_' s + r_' t = 3) \\<and>\n                              (\\<forall>t\\<in>A'. False)}\n 3. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c\n                    ?R16", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s t.\n       \\<Gamma>\n          \\<turnstile> (?R17 s t) \\<acute>n :== r_' t\n                       {s. \\<exists>P' Q' A'.\n                              \\<Gamma>\n                                 \\<turnstile> P' callClosure upd (d_' s) Q',\n        A' \\<and>\n                              s \\<in> P' \\<and>\n                              (\\<forall>t\\<in>Q'. n_' s + r_' t = 3) \\<and>\n                              (\\<forall>t\\<in>A'. False)}\n 2. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (c_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> ?R17 s t) \\<and>\n                           (\\<forall>t\\<in>A'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter();;\n                    \\<acute>d :== \\<acute>c\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (c_' s) Q',\n     A' \\<and>\n                           s \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {s.\n\\<exists>P' Q' A'.\n   \\<Gamma>\\<turnstile> P' callClosure upd (d_' s) Q',A' \\<and>\n   s\\<lparr>n_' := r_' t\\<rparr> \\<in> P' \\<and>\n   (\\<forall>ta\\<in>Q'. r_' t + r_' ta = 3) \\<and>\n   (\\<forall>t\\<in>A'. False)}) \\<and>\n                           (\\<forall>t\\<in>A'.\n                               s\\<lparr>globals := globals t\\<rparr>\n                               \\<in> {})}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n                    \\<acute>c :== CALL NewCounter()\n                    {s. \\<exists>P' Q' A'.\n                           \\<Gamma>\n                              \\<turnstile> P' callClosure upd (c_' s) Q',\n     A' \\<and>\n                           s\\<lparr>d_' := c_' s\\<rparr> \\<in> P' \\<and>\n                           (\\<forall>t\\<in>Q'.\n                               \\<exists>P' Q' A'.\n                                  \\<Gamma>\n                                     \\<turnstile> P' callClosure upd (c_' s)\n            Q',A' \\<and>\n                                  s\\<lparr>d_' := c_' s,\nglobals := globals t, n_' := r_' t\\<rparr>\n                                  \\<in> P' \\<and>\n                                  (\\<forall>ta\\<in>Q'.\nr_' t + r_' ta = 3) \\<and>\n                                  (\\<forall>t\\<in>A'. False)) \\<and>\n                           (\\<forall>t\\<in>A'. False)}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>1 \\<le> \\<acute>free\\<rbrace>\n    \\<subseteq> {s. 1 \\<le> free_' (globals s) \\<and>\n                    (\\<forall>t.\n                        (\\<exists>p.\n                            p \\<notin> set (alloc_' (globals s)) \\<and>\n                            p \\<in> set (alloc_' (globals t)) \\<and>\n                            p \\<noteq> Null \\<and>\n                            cnt_' (globals t) p = 0 \\<and>\n                            (\\<forall>i.\n                                \\<Gamma>\n                                   \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n                   i\\<rbrace>\n          callClosure upd (c_' t)\n          \\<lbrace>\\<acute>r = i + 1 \\<and>\n                   p\\<rightarrow>\\<acute>cnt =\n                   i + 1\\<rbrace>)) \\<longrightarrow>\n                        (\\<exists>P' Q' A'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t) Q',\n      A' \\<and>\n                            s\\<lparr>globals := globals t, c_' := c_' t,\n                                d_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>ta\\<in>Q'.\n                                \\<exists>P' Q' A'.\n                                   \\<Gamma>\n\\<turnstile> P' callClosure upd (c_' t) Q',A' \\<and>\n                                   s\\<lparr>c_' := c_' t, d_' := c_' t,\n globals := globals ta, n_' := r_' ta\\<rparr>\n                                   \\<in> P' \\<and>\n                                   (\\<forall>t\\<in>Q'.\n r_' ta + r_' t = 3) \\<and>\n                                   (\\<forall>t\\<in>A'. False)) \\<and>\n                            (\\<forall>t\\<in>A'. False)))}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>globals := globals t, c_' := c_' t,\n                                d_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>ta\\<in>Q'.\n                                \\<exists>P' Q'.\n                                   \\<Gamma>\n\\<turnstile> P' callClosure upd (c_' t) Q' \\<and>\n                                   x\\<lparr>c_' := c_' t, d_' := c_' t,\n globals := globals ta, n_' := r_' ta\\<rparr>\n                                   \\<in> P' \\<and>\n                                   (\\<forall>t\\<in>Q'. r_' ta + r_' t = 3))", "apply (subgoal_tac \"\\<Gamma>\\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace> callClosure upd (c_' t) \\<lbrace>\\<acute>r = Suc 0 \\<and> p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>globals := globals t, c_' := c_' t,\n                                d_' := c_' t\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>ta\\<in>Q'.\n                                \\<exists>P' Q'.\n                                   \\<Gamma>\n\\<turnstile> P' callClosure upd (c_' t) Q' \\<and>\n                                   x\\<lparr>c_' := c_' t, d_' := c_' t,\n globals := globals ta, n_' := r_' ta\\<rparr>\n                                   \\<in> P' \\<and>\n                                   (\\<forall>t\\<in>Q'. r_' ta + r_' t = 3))\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q'.\n                            \\<Gamma>\n                               \\<turnstile> (?P'52 x t p)\n      callClosure upd (c_' t) Q' \\<and>\n                            x\\<lparr>globals := globals t, c_' := c_' t,\n                                d_' := c_' t\\<rparr>\n                            \\<in> ?P'52 x t p \\<and>\n                            (\\<forall>ta\\<in>Q'.\n                                \\<exists>P' Q'.\n                                   \\<Gamma>\n\\<turnstile> P' callClosure upd (c_' t) Q' \\<and>\n                                   x\\<lparr>c_' := c_' t, d_' := c_' t,\n globals := globals ta, n_' := r_' ta\\<rparr>\n                                   \\<in> P' \\<and>\n                                   (\\<forall>t\\<in>Q'. r_' ta + r_' t = 3))\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'52 x t p)\n   callClosure upd (c_' t) (?Q'54 x t p) \\<and>\n                         x\\<lparr>globals := globals t, c_' := c_' t,\n                             d_' := c_' t\\<rparr>\n                         \\<in> ?P'52 x t p \\<and>\n                         (\\<forall>ta\\<in>?Q'54 x t p.\n                             \\<exists>P' Q'.\n                                \\<Gamma>\n                                   \\<turnstile> P' callClosure upd (c_' t)\n          Q' \\<and>\n                                x\\<lparr>c_' := c_' t, d_' := c_' t,\n                                    globals := globals ta,\n                                    n_' := r_' ta\\<rparr>\n                                \\<in> P' \\<and>\n                                (\\<forall>t\\<in>Q'. r_' ta + r_' t = 3))\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'52 x t p)\n   callClosure upd (c_' t) (?Q'54 x t p)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>globals := globals t, c_' := c_' t,\n                             d_' := c_' t\\<rparr>\n                         \\<in> ?P'52 x t p \\<and>\n                         (\\<forall>ta\\<in>?Q'54 x t p.\n                             \\<exists>P' Q'.\n                                \\<Gamma>\n                                   \\<turnstile> P' callClosure upd (c_' t)\n          Q' \\<and>\n                                x\\<lparr>c_' := c_' t, d_' := c_' t,\n                                    globals := globals ta,\n                                    n_' := r_' ta\\<rparr>\n                                \\<in> P' \\<and>\n                                (\\<forall>t\\<in>Q'. r_' ta + r_' t = 3))\n 3. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 0\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 0 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 0\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>globals := globals t, c_' := c_' t,\n                             d_' := c_' t\\<rparr>\n                         \\<in> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n  0\\<rbrace> \\<and>\n                         (\\<forall>ta\\<in>\\<lbrace>\\<acute>r = Suc 0 \\<and>\n             p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>.\n                             \\<exists>P' Q'.\n                                \\<Gamma>\n                                   \\<turnstile> P' callClosure upd (c_' t)\n          Q' \\<and>\n                                x\\<lparr>c_' := c_' t, d_' := c_' t,\n                                    globals := globals ta,\n                                    n_' := r_' ta\\<rparr>\n                                \\<in> P' \\<and>\n                                (\\<forall>t\\<in>Q'. r_' ta + r_' t = 3))\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>;\n        r_' ta = Suc 0; cnt_' (globals ta) p = Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>c_' := c_' t, d_' := c_' t,\n                                globals := globals ta, n_' := Suc 0\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (erule_tac x=1 in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q'.\n                            \\<Gamma>\n                               \\<turnstile> P' callClosure upd (c_' t)\n      Q' \\<and>\n                            x\\<lparr>c_' := c_' t, d_' := c_' t,\n                                globals := globals ta, n_' := Suc 0\\<rparr>\n                            \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q'.\n                            \\<Gamma>\n                               \\<turnstile> (?P'66 x t p ta)\n      callClosure upd (c_' t) Q' \\<and>\n                            x\\<lparr>c_' := c_' t, d_' := c_' t,\n                                globals := globals ta, n_' := Suc 0\\<rparr>\n                            \\<in> ?P'66 x t p ta \\<and>\n                            (\\<forall>t\\<in>Q'. r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'66 x t p ta)\n   callClosure upd (c_' t) (?Q'68 x t p ta) \\<and>\n                         x\\<lparr>c_' := c_' t, d_' := c_' t,\n                             globals := globals ta, n_' := Suc 0\\<rparr>\n                         \\<in> ?P'66 x t p ta \\<and>\n                         (\\<forall>t\\<in>?Q'68 x t p ta. r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> (?P'66 x t p ta)\n   callClosure upd (c_' t) (?Q'68 x t p ta)\n 2. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>c_' := c_' t, d_' := c_' t,\n                             globals := globals ta, n_' := Suc 0\\<rparr>\n                         \\<in> ?P'66 x t p ta \\<and>\n                         (\\<forall>t\\<in>?Q'68 x t p ta. r_' t = 2)\n 3. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t p ta.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0; r_' ta = Suc 0;\n        cnt_' (globals ta) p = Suc 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = 1\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc 1 \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc 1\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> x\\<lparr>c_' := c_' t, d_' := c_' t,\n                             globals := globals ta, n_' := Suc 0\\<rparr>\n                         \\<in> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n  1\\<rbrace> \\<and>\n                         (\\<forall>t\\<in>\\<lbrace>\\<acute>r = Suc 1 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 1\\<rbrace>.\n                             r_' t = 2)\n 2. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<forall>i.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt = i\\<rbrace>\n                           callClosure upd (c_' t)\n                           \\<lbrace>\\<acute>r = Suc i \\<and>\n                                    p\\<rightarrow>\\<acute>cnt =\n                                    Suc i\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply (erule allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t p.\n       \\<lbrakk>Suc 0 \\<le> free_' (globals x);\n        p \\<notin> set (alloc_' (globals x));\n        p \\<in> set (alloc_' (globals t)); p \\<noteq> Null;\n        cnt_' (globals t) p = 0;\n        \\<Gamma>\n           \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n                                 ?i73 x t p\\<rbrace>\n                        callClosure upd (c_' t)\n                        \\<lbrace>\\<acute>r = Suc (?i73 x t p) \\<and>\n                                 p\\<rightarrow>\\<acute>cnt =\n                                 Suc (?i73 x t p)\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> \\<lbrace>p\\<rightarrow>\\<acute>cnt =\n            0\\<rbrace>\n   callClosure upd (c_' t)\n   \\<lbrace>\\<acute>r = Suc 0 \\<and>\n            p\\<rightarrow>\\<acute>cnt = Suc 0\\<rbrace>", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}