{"file_name": "/home/qj213/afp-2021-10-22/thys/Concurrent_Revisions/Data.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Concurrent_Revisions", "problem_names": ["lemma dom_combination_dom_union: \"dom (\\<tau>;;\\<tau>') = dom \\<tau> \\<union> dom \\<tau>'\"", "lemma injective_cntxt [simp]: \"(\\<E>[e1] = \\<E>[e2]) = (e1 = e2)\"", "lemma VE_empty_cntxt [simp]: \"(VE v = \\<E>[e]) = (\\<E> = \\<box> \\<and> VE v = e)\"", "lemma plugged_redex_not_val [simp]: \"redex r \\<Longrightarrow> (\\<E> \\<lhd> r) \\<noteq> (VE t)\"", "lemma plug_decomposition_equivalence: \"redex r \\<Longrightarrow> decompose e \\<E> r = (\\<E>[r] = e)\"", "lemma unique_decomposition: \"decompose e \\<E>\\<^sub>1 r\\<^sub>1 \\<Longrightarrow> decompose e \\<E>\\<^sub>2 r\\<^sub>2 \\<Longrightarrow> \\<E>\\<^sub>1 = \\<E>\\<^sub>2 \\<and> r\\<^sub>1 = r\\<^sub>2\"", "lemma completion_eq [simp]:\n  assumes\n    red_e: \"redex r\" and\n    red_e': \"redex r'\"\n  shows \"(\\<E>[r] = \\<E>'[r']) = (\\<E> = \\<E>' \\<and> r = r')\""], "translations": [["", "lemma dom_combination_dom_union: \"dom (\\<tau>;;\\<tau>') = dom \\<tau> \\<union> dom \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<tau>;;\\<tau>') = dom \\<tau> \\<union> dom \\<tau>'", "by auto"], ["", "subsection \\<open>Values, expressions and execution contexts\\<close>"], ["", "datatype const = Unit | F | T"], ["", "datatype (RID\\<^sub>V: 'r, LID\\<^sub>V: 'l,'v) val = \n  CV const\n| Var 'v\n| Loc 'l\n| Rid 'r\n| Lambda 'v \"('r,'l,'v) expr\"\nand (RID\\<^sub>E: 'r, LID\\<^sub>E: 'l,'v) expr =\n  VE \"('r,'l,'v) val\"\n| Apply \"('r,'l,'v) expr\" \"('r,'l,'v) expr\"\n| Ite \"('r,'l,'v) expr\" \"('r,'l,'v) expr\" \"('r,'l,'v) expr\"\n| Ref \"('r,'l,'v) expr\"\n| Read \"('r,'l,'v) expr\"\n| Assign \"('r,'l,'v) expr\" \"('r,'l,'v) expr\"\n| Rfork \"('r,'l,'v) expr\"\n| Rjoin \"('r,'l,'v) expr\""], ["", "datatype (RID\\<^sub>C: 'r, LID\\<^sub>C: 'l,'v) cntxt = \n  Hole (\"\\<box>\")\n| ApplyL\\<^sub>\\<E> \"('r,'l,'v) cntxt\" \"('r,'l,'v) expr\" \n| ApplyR\\<^sub>\\<E> \"('r,'l,'v) val\" \"('r,'l,'v) cntxt\"\n| Ite\\<^sub>\\<E> \"('r,'l,'v) cntxt\" \"('r,'l,'v) expr\" \"('r,'l,'v) expr\"\n| Ref\\<^sub>\\<E> \"('r,'l,'v) cntxt\"\n| Read\\<^sub>\\<E> \"('r,'l,'v) cntxt\"\n| AssignL\\<^sub>\\<E> \"('r,'l,'v) cntxt\" \"('r,'l,'v) expr\"\n| AssignR\\<^sub>\\<E> 'l \"('r,'l,'v) cntxt\"\n| Rjoin\\<^sub>\\<E> \"('r,'l,'v) cntxt\""], ["", "subsection \\<open>Plugging and decomposing\\<close>"], ["", "fun plug :: \"('r,'l,'v) cntxt \\<Rightarrow> ('r,'l,'v) expr \\<Rightarrow> ('r,'l,'v) expr\" (infix \"\\<lhd>\" 60) where\n  \"\\<box> \\<lhd> e = e\"\n| \"ApplyL\\<^sub>\\<E> \\<E> e1 \\<lhd> e = Apply (\\<E> \\<lhd> e) e1\"\n| \"ApplyR\\<^sub>\\<E> val \\<E> \\<lhd> e = Apply (VE val) (\\<E> \\<lhd> e)\"\n| \"Ite\\<^sub>\\<E> \\<E> e1 e2 \\<lhd> e = Ite (\\<E> \\<lhd> e) e1 e2\"\n| \"Ref\\<^sub>\\<E> \\<E> \\<lhd> e = Ref (\\<E> \\<lhd> e)\"\n| \"Read\\<^sub>\\<E> \\<E> \\<lhd> e = Read (\\<E> \\<lhd> e)\"\n| \"AssignL\\<^sub>\\<E> \\<E> e1 \\<lhd> e = Assign (\\<E> \\<lhd> e) e1\"\n| \"AssignR\\<^sub>\\<E> l \\<E> \\<lhd> e = Assign (VE (Loc l)) (\\<E> \\<lhd> e)\"\n| \"Rjoin\\<^sub>\\<E> \\<E> \\<lhd> e = Rjoin (\\<E> \\<lhd> e)\""], ["", "translations\n  \"\\<E>[x]\" \\<rightleftharpoons> \"\\<E> \\<lhd> x\""], ["", "lemma injective_cntxt [simp]: \"(\\<E>[e1] = \\<E>[e2]) = (e1 = e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<E> [e1] = \\<E> [e2]) = (e1 = e2)", "by (induction \\<E>) auto"], ["", "lemma VE_empty_cntxt [simp]: \"(VE v = \\<E>[e]) = (\\<E> = \\<box> \\<and> VE v = e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (VE v = \\<E> [e]) = (\\<E> = \\<box> \\<and> VE v = e)", "by (cases \\<E>, auto)"], ["", "inductive redex :: \"('r,'l,'v) expr \\<Rightarrow> bool\" where\n  app: \"redex (Apply (VE (Lambda x e)) (VE v))\"\n| iteTrue: \"redex (Ite (VE (CV T)) e1 e2)\"\n| iteFalse: \"redex (Ite (VE (CV F)) e1 e2)\"\n| ref: \"redex (Ref (VE v))\"\n| read: \"redex (Read (VE (Loc l)))\"\n| assign: \"redex (Assign (VE (Loc l)) (VE v))\"\n| rfork: \"redex (Rfork e)\"\n| rjoin: \"redex (Rjoin (VE (Rid r)))\""], ["", "inductive_simps redex_simps [simp]: \"redex e\""], ["", "inductive_cases redexE [elim]: \"redex e\""], ["", "lemma plugged_redex_not_val [simp]: \"redex r \\<Longrightarrow> (\\<E> \\<lhd> r) \\<noteq> (VE t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redex r \\<Longrightarrow> \\<E> [r] \\<noteq> VE t", "by (cases \\<E>) auto"], ["", "inductive decompose :: \"('r,'l,'v) expr \\<Rightarrow> ('r,'l,'v) cntxt \\<Rightarrow> ('r,'l,'v) expr \\<Rightarrow> bool\" where\n  top_redex: \"redex e \\<Longrightarrow> decompose e \\<box> e\"\n| lapply: \"\\<lbrakk> \\<not>redex (Apply e\\<^sub>1 e\\<^sub>2); decompose e\\<^sub>1 \\<E> r \\<rbrakk> \\<Longrightarrow> decompose (Apply e\\<^sub>1 e\\<^sub>2) (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) r\"\n| rapply: \"\\<lbrakk> \\<not>redex (Apply (VE v) e); decompose e \\<E> r \\<rbrakk> \\<Longrightarrow> decompose (Apply (VE v) e) (ApplyR\\<^sub>\\<E> v \\<E>) r\"\n| ite: \"\\<lbrakk> \\<not>redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3); decompose e\\<^sub>1 \\<E> r \\<rbrakk> \\<Longrightarrow> decompose (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3) (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) r\"\n| ref: \"\\<lbrakk> \\<not>redex (Ref e); decompose e \\<E> r \\<rbrakk> \\<Longrightarrow> decompose (Ref e) (Ref\\<^sub>\\<E> \\<E>) r\"\n| read: \"\\<lbrakk> \\<not>redex (Read e); decompose e \\<E> r \\<rbrakk> \\<Longrightarrow> decompose (Read e) (Read\\<^sub>\\<E> \\<E>) r\"\n| lassign: \"\\<lbrakk> \\<not>redex (Assign e\\<^sub>1 e\\<^sub>2); decompose e\\<^sub>1 \\<E> r \\<rbrakk> \\<Longrightarrow> decompose (Assign e\\<^sub>1 e\\<^sub>2) (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) r\"\n| rassign: \"\\<lbrakk> \\<not>redex (Assign (VE (Loc l)) e\\<^sub>2); decompose e\\<^sub>2 \\<E> r \\<rbrakk> \\<Longrightarrow> decompose (Assign (VE (Loc l)) e\\<^sub>2) (AssignR\\<^sub>\\<E> l \\<E>) r\"\n| rjoin:  \"\\<lbrakk> \\<not>redex (Rjoin e); decompose e \\<E> r \\<rbrakk> \\<Longrightarrow> decompose (Rjoin e) (Rjoin\\<^sub>\\<E> \\<E>) r\""], ["", "inductive_cases decomposeE [elim]: \"decompose e \\<E> r\""], ["", "lemma plug_decomposition_equivalence: \"redex r \\<Longrightarrow> decompose e \\<E> r = (\\<E>[r] = e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redex r \\<Longrightarrow> decompose e \\<E> r = (\\<E> [r] = e)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>redex r; decompose e \\<E> r\\<rbrakk>\n    \\<Longrightarrow> \\<E> [r] = e\n 2. \\<lbrakk>redex r; \\<E> [r] = e\\<rbrakk>\n    \\<Longrightarrow> decompose e \\<E> r", "assume x: \"decompose e \\<E> r\""], ["proof (state)\nthis:\n  decompose e \\<E> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>redex r; decompose e \\<E> r\\<rbrakk>\n    \\<Longrightarrow> \\<E> [r] = e\n 2. \\<lbrakk>redex r; \\<E> [r] = e\\<rbrakk>\n    \\<Longrightarrow> decompose e \\<E> r", "show \"\\<E>[r] = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> [r] = e", "proof (use x in \\<open>induct rule: decompose.induct\\<close>)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>e. redex e \\<Longrightarrow> \\<box> [e] = e\n 2. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Apply e\\<^sub>1 e\\<^sub>2\n 3. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 4. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 5. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 6. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 7. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 8. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 9. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "case (top_redex e)"], ["proof (state)\nthis:\n  redex e\n\ngoal (9 subgoals):\n 1. \\<And>e. redex e \\<Longrightarrow> \\<box> [e] = e\n 2. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Apply e\\<^sub>1 e\\<^sub>2\n 3. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 4. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 5. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 6. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 7. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 8. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 9. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "thus \"\\<box>[e] = e\""], ["proof (prove)\nusing this:\n  redex e\n\ngoal (1 subgoal):\n 1. \\<box> [e] = e", "by simp"], ["proof (state)\nthis:\n  \\<box> [e] = e\n\ngoal (8 subgoals):\n 1. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Apply e\\<^sub>1 e\\<^sub>2\n 2. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 3. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 4. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 5. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 6. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 7. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 8. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Apply e\\<^sub>1 e\\<^sub>2\n 2. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 3. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 4. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 5. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 6. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 7. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 8. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "case (lapply e\\<^sub>1 e\\<^sub>2 \\<E> r)"], ["proof (state)\nthis:\n  \\<not> redex (Apply e\\<^sub>1 e\\<^sub>2)\n  decompose e\\<^sub>1 \\<E> r\n  \\<E> [r] = e\\<^sub>1\n\ngoal (8 subgoals):\n 1. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Apply e\\<^sub>1 e\\<^sub>2\n 2. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 3. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 4. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 5. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 6. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 7. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 8. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "have \"(ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] = Apply (\\<E>[r]) e\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] = Apply (\\<E> [r]) e\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] = Apply (\\<E> [r]) e\\<^sub>2\n\ngoal (8 subgoals):\n 1. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Apply e\\<^sub>1 e\\<^sub>2\n 2. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 3. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 4. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 5. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 6. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 7. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 8. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "also"], ["proof (state)\nthis:\n  (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] = Apply (\\<E> [r]) e\\<^sub>2\n\ngoal (8 subgoals):\n 1. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Apply e\\<^sub>1 e\\<^sub>2\n 2. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 3. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 4. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 5. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 6. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 7. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 8. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "have \"... = Apply e\\<^sub>1 e\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Apply (\\<E> [r]) e\\<^sub>2 = Apply e\\<^sub>1 e\\<^sub>2", "using \\<open>\\<E>[r] = e\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  \\<E> [r] = e\\<^sub>1\n\ngoal (1 subgoal):\n 1. Apply (\\<E> [r]) e\\<^sub>2 = Apply e\\<^sub>1 e\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  Apply (\\<E> [r]) e\\<^sub>2 = Apply e\\<^sub>1 e\\<^sub>2\n\ngoal (8 subgoals):\n 1. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Apply e\\<^sub>1 e\\<^sub>2\n 2. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 3. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 4. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 5. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 6. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 7. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 8. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "then"], ["proof (chain)\npicking this:\n  Apply (\\<E> [r]) e\\<^sub>2 = Apply e\\<^sub>1 e\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  Apply (\\<E> [r]) e\\<^sub>2 = Apply e\\<^sub>1 e\\<^sub>2\n\ngoal (1 subgoal):\n 1. (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] = Apply e\\<^sub>1 e\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  (ApplyL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] = Apply e\\<^sub>1 e\\<^sub>2\n\ngoal (7 subgoals):\n 1. \\<And>v e \\<E> r.\n       \\<lbrakk>\\<not> redex (Apply (VE v) e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (ApplyR\\<^sub>\\<E> v \\<E>) [r] = Apply (VE v) e\n 2. \\<And>e\\<^sub>1 e\\<^sub>2 e\\<^sub>3 \\<E> r.\n       \\<lbrakk>\\<not> redex (Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Ite\\<^sub>\\<E> \\<E> e\\<^sub>2 e\\<^sub>3) [r] =\n                         Ite e\\<^sub>1 e\\<^sub>2 e\\<^sub>3\n 3. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Ref e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Ref\\<^sub>\\<E> \\<E>) [r] = Ref e\n 4. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Read e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Read\\<^sub>\\<E> \\<E>) [r] = Read e\n 5. \\<And>e\\<^sub>1 e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign e\\<^sub>1 e\\<^sub>2);\n        decompose e\\<^sub>1 \\<E> r; \\<E> [r] = e\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (AssignL\\<^sub>\\<E> \\<E> e\\<^sub>2) [r] =\n                         Assign e\\<^sub>1 e\\<^sub>2\n 6. \\<And>l e\\<^sub>2 \\<E> r.\n       \\<lbrakk>\\<not> redex (Assign (VE (Loc l)) e\\<^sub>2);\n        decompose e\\<^sub>2 \\<E> r; \\<E> [r] = e\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (AssignR\\<^sub>\\<E> l \\<E>) [r] =\n                         Assign (VE (Loc l)) e\\<^sub>2\n 7. \\<And>e \\<E> r.\n       \\<lbrakk>\\<not> redex (Rjoin e); decompose e \\<E> r;\n        \\<E> [r] = e\\<rbrakk>\n       \\<Longrightarrow> (Rjoin\\<^sub>\\<E> \\<E>) [r] = Rjoin e", "qed simp+"], ["proof (state)\nthis:\n  \\<E> [r] = e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>redex r; \\<E> [r] = e\\<rbrakk>\n    \\<Longrightarrow> decompose e \\<E> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>redex r; \\<E> [r] = e\\<rbrakk>\n    \\<Longrightarrow> decompose e \\<E> r", "assume red: \"redex r\" and  eq: \"\\<E>[r] = e\""], ["proof (state)\nthis:\n  redex r\n  \\<E> [r] = e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>redex r; \\<E> [r] = e\\<rbrakk>\n    \\<Longrightarrow> decompose e \\<E> r", "have \"decompose (\\<E>[r]) \\<E> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose (\\<E> [r]) \\<E> r", "by (induct \\<E>) (use red in \\<open>auto intro: decompose.intros\\<close>)"], ["proof (state)\nthis:\n  decompose (\\<E> [r]) \\<E> r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>redex r; \\<E> [r] = e\\<rbrakk>\n    \\<Longrightarrow> decompose e \\<E> r", "thus \"decompose e \\<E> r\""], ["proof (prove)\nusing this:\n  decompose (\\<E> [r]) \\<E> r\n\ngoal (1 subgoal):\n 1. decompose e \\<E> r", "by (simp add: eq)"], ["proof (state)\nthis:\n  decompose e \\<E> r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_decomposition: \"decompose e \\<E>\\<^sub>1 r\\<^sub>1 \\<Longrightarrow> decompose e \\<E>\\<^sub>2 r\\<^sub>2 \\<Longrightarrow> \\<E>\\<^sub>1 = \\<E>\\<^sub>2 \\<and> r\\<^sub>1 = r\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>decompose e \\<E>\\<^sub>1 r\\<^sub>1;\n     decompose e \\<E>\\<^sub>2 r\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<E>\\<^sub>1 = \\<E>\\<^sub>2 \\<and>\n                      r\\<^sub>1 = r\\<^sub>2", "by (induct arbitrary: \\<E>\\<^sub>2 rule: decompose.induct) auto"], ["", "lemma completion_eq [simp]:\n  assumes\n    red_e: \"redex r\" and\n    red_e': \"redex r'\"\n  shows \"(\\<E>[r] = \\<E>'[r']) = (\\<E> = \\<E>' \\<and> r = r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<E> [r] = \\<E>' [r']) = (\\<E> = \\<E>' \\<and> r = r')", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> \\<E> = \\<E>' \\<and> r = r'\n 2. \\<E> = \\<E>' \\<and> r = r' \\<Longrightarrow> \\<E> [r] = \\<E>' [r']", "show \"\\<E>[r] = \\<E>'[r'] \\<Longrightarrow> \\<E> = \\<E>' \\<and> r = r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> \\<E> = \\<E>' \\<and> r = r'", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> \\<E> = \\<E>'\n 2. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> r = r'", "assume eq: \"\\<E>[r] = \\<E>'[r']\""], ["proof (state)\nthis:\n  \\<E> [r] = \\<E>' [r']\n\ngoal (2 subgoals):\n 1. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> \\<E> = \\<E>'\n 2. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> r = r'", "have \"decompose (\\<E>[r]) \\<E> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose (\\<E> [r]) \\<E> r", "using plug_decomposition_equivalence red_e"], ["proof (prove)\nusing this:\n  redex ?r \\<Longrightarrow> decompose ?e ?\\<E> ?r = (?\\<E> [?r] = ?e)\n  redex r\n\ngoal (1 subgoal):\n 1. decompose (\\<E> [r]) \\<E> r", "by blast"], ["proof (state)\nthis:\n  decompose (\\<E> [r]) \\<E> r\n\ngoal (2 subgoals):\n 1. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> \\<E> = \\<E>'\n 2. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> r = r'", "hence fst_decomp:\"decompose (\\<E>'[r']) \\<E> r\""], ["proof (prove)\nusing this:\n  decompose (\\<E> [r]) \\<E> r\n\ngoal (1 subgoal):\n 1. decompose (\\<E>' [r']) \\<E> r", "by (simp add: eq)"], ["proof (state)\nthis:\n  decompose (\\<E>' [r']) \\<E> r\n\ngoal (2 subgoals):\n 1. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> \\<E> = \\<E>'\n 2. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> r = r'", "have snd_decomp: \"decompose (\\<E>'[r']) \\<E>' r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose (\\<E>' [r']) \\<E>' r'", "using plug_decomposition_equivalence red_e'"], ["proof (prove)\nusing this:\n  redex ?r \\<Longrightarrow> decompose ?e ?\\<E> ?r = (?\\<E> [?r] = ?e)\n  redex r'\n\ngoal (1 subgoal):\n 1. decompose (\\<E>' [r']) \\<E>' r'", "by blast"], ["proof (state)\nthis:\n  decompose (\\<E>' [r']) \\<E>' r'\n\ngoal (2 subgoals):\n 1. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> \\<E> = \\<E>'\n 2. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> r = r'", "show cntxts_eq: \"\\<E> = \\<E>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> = \\<E>'", "using fst_decomp snd_decomp unique_decomposition"], ["proof (prove)\nusing this:\n  decompose (\\<E>' [r']) \\<E> r\n  decompose (\\<E>' [r']) \\<E>' r'\n  \\<lbrakk>decompose ?e ?\\<E>\\<^sub>1 ?r\\<^sub>1;\n   decompose ?e ?\\<E>\\<^sub>2 ?r\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<E>\\<^sub>1 = ?\\<E>\\<^sub>2 \\<and>\n                    ?r\\<^sub>1 = ?r\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<E> = \\<E>'", "by blast"], ["proof (state)\nthis:\n  \\<E> = \\<E>'\n\ngoal (1 subgoal):\n 1. \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> r = r'", "show \"r = r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = r'", "using cntxts_eq eq"], ["proof (prove)\nusing this:\n  \\<E> = \\<E>'\n  \\<E> [r] = \\<E>' [r']\n\ngoal (1 subgoal):\n 1. r = r'", "by simp"], ["proof (state)\nthis:\n  r = r'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<E> [r] = \\<E>' [r'] \\<Longrightarrow> \\<E> = \\<E>' \\<and> r = r'\n\ngoal (1 subgoal):\n 1. \\<E> = \\<E>' \\<and> r = r' \\<Longrightarrow> \\<E> [r] = \\<E>' [r']", "qed simp"], ["", "subsection \\<open>Stores and states\\<close>"], ["", "type_synonym ('r,'l,'v) store = \"'l \\<rightharpoonup> ('r,'l,'v) val\""], ["", "type_synonym ('r,'l,'v) local_state = \"('r,'l,'v) store \\<times> ('r,'l,'v) store \\<times> ('r,'l,'v) expr\""], ["", "type_synonym ('r,'l,'v) global_state = \"'r \\<rightharpoonup> ('r,'l,'v) local_state\""], ["", "fun doms :: \"('r,'l,'v) local_state \\<Rightarrow> 'l set\" where\n  \"doms (\\<sigma>,\\<tau>,e) = dom \\<sigma> \\<union> dom \\<tau>\""], ["", "fun LID_snapshot :: \"('r,'l,'v) local_state \\<Rightarrow> ('r,'l,'v) store\" (\"_\\<^sub>\\<sigma>\" 200) where\n  \"LID_snapshot (\\<sigma>,\\<tau>,e) = \\<sigma>\""], ["", "fun LID_local_store :: \"('r,'l,'v) local_state \\<Rightarrow> ('r,'l,'v) store\" (\"_\\<^sub>\\<tau>\" 200) where\n  \"LID_local_store (\\<sigma>,\\<tau>,e) = \\<tau>\""], ["", "fun LID_expression :: \"('r,'l,'v) local_state \\<Rightarrow> ('r,'l,'v) expr\" (\"_\\<^sub>e\" 200) where\n  \"LID_expression (\\<sigma>,\\<tau>,e) = e\""], ["", "end"]]}