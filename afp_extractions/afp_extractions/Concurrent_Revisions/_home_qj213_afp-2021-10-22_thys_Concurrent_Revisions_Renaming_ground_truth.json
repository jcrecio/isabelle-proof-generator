{"file_name": "/home/qj213/afp-2021-10-22/thys/Concurrent_Revisions/Renaming.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Concurrent_Revisions", "problem_names": ["lemma \\<R>\\<^sub>S_implements_renaming: \"bij \\<beta> \\<Longrightarrow> is_store_renaming \\<alpha> \\<beta> \\<sigma> (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>)\"", "lemma \\<R>\\<^sub>G_implements_renaming: \"bij \\<alpha> \\<Longrightarrow> is_global_renaming \\<alpha> \\<beta> s (\\<R>\\<^sub>G \\<alpha> \\<beta> s)\"", "lemma \\<R>\\<^sub>SI [intro]:\n  assumes\n    bij_\\<beta>: \"bij \\<beta>\" and\n    none_case: \"\\<And>l. \\<sigma> l = None \\<Longrightarrow> \\<sigma>' (\\<beta> l) = None\" and\n    some_case: \"\\<And>l v. \\<sigma> l = Some v \\<Longrightarrow> \\<sigma>' (\\<beta> l) = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\"\n  shows\n    \"\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma> = \\<sigma>'\"", "lemma \\<R>\\<^sub>GI [intro]: \n  assumes\n    bij_\\<alpha>: \"bij \\<alpha>\" and\n    none_case: \"\\<And>r. s r = None \\<Longrightarrow> s' (\\<alpha> r) = None\" and\n    some_case: \"\\<And>r \\<sigma> \\<tau> e. s r = Some (\\<sigma>,\\<tau>,e) \\<Longrightarrow> s' (\\<alpha> r) = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>,\\<tau>,e))\"\n  shows\n    \"\\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\"", "lemma \\<R>\\<^sub>S_id [simp]: \"\\<R>\\<^sub>S id id \\<sigma> = \\<sigma>\"", "lemma \\<R>\\<^sub>L_id [simp]: \"\\<R>\\<^sub>L id id ls = ls\"", "lemma \\<R>\\<^sub>G_id [simp]: \"\\<R>\\<^sub>G id id s = s\"", "lemma \\<R>\\<^sub>S_comp [simp]: \"\\<lbrakk> bij \\<beta>; bij \\<beta>' \\<rbrakk> \\<Longrightarrow> \\<R>\\<^sub>S \\<alpha>' \\<beta>' (\\<R>\\<^sub>S \\<alpha> \\<beta> s) = \\<R>\\<^sub>S (\\<alpha>' \\<circ> \\<alpha>) (\\<beta>' \\<circ> \\<beta>) s\"", "lemma \\<R>\\<^sub>L_comp [simp]: \"\\<lbrakk> bij \\<beta>; bij \\<beta>' \\<rbrakk> \\<Longrightarrow> \\<R>\\<^sub>L \\<alpha>' \\<beta>' (\\<R>\\<^sub>L \\<alpha> \\<beta> ls) = \\<R>\\<^sub>L (\\<alpha>' \\<circ> \\<alpha>) (\\<beta>' \\<circ> \\<beta>) ls\"", "lemma \\<R>\\<^sub>G_comp [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<alpha>'; bij \\<beta>; bij \\<beta>' \\<rbrakk> \\<Longrightarrow> \\<R>\\<^sub>G \\<alpha>' \\<beta>' (\\<R>\\<^sub>G \\<alpha> \\<beta> s) = \\<R>\\<^sub>G (\\<alpha>' \\<circ> \\<alpha>) (\\<beta>' \\<circ> \\<beta>) s\"", "lemma \\<R>\\<^sub>V_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>V (inv \\<alpha>) (inv \\<beta>) v' = v) = (\\<R>\\<^sub>V \\<alpha> \\<beta> v = v')\"", "lemma \\<R>\\<^sub>E_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>E (inv \\<alpha>) (inv \\<beta>) e' = e) = (\\<R>\\<^sub>E \\<alpha> \\<beta> e = e')\"", "lemma \\<R>\\<^sub>C_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>C (inv \\<alpha>) (inv \\<beta>) \\<E>' = \\<E>) = (\\<R>\\<^sub>C \\<alpha> \\<beta> \\<E> = \\<E>')\"", "lemma \\<R>\\<^sub>S_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>S (inv \\<alpha>) (inv \\<beta>) \\<sigma>' = \\<sigma>) = (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma> = \\<sigma>')\"", "lemma \\<R>\\<^sub>L_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>L (inv \\<alpha>) (inv \\<beta>) ls' = ls) = (\\<R>\\<^sub>L \\<alpha> \\<beta> ls = ls')\"", "lemma \\<R>\\<^sub>G_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>G (inv \\<alpha>) (inv \\<beta>) s' = s) = (\\<R>\\<^sub>G \\<alpha> \\<beta> s = s')\"", "lemma eq_statesI [intro]:\n  \"\\<R>\\<^sub>G \\<alpha> \\<beta> s = s' \\<Longrightarrow> bij \\<alpha> \\<Longrightarrow> bij \\<beta> \\<Longrightarrow> s \\<approx> s'\"", "lemma eq_statesE [elim]:\n  \"s \\<approx> s' \\<Longrightarrow> (\\<And>\\<alpha> \\<beta>. \\<R>\\<^sub>G \\<alpha> \\<beta> s = s' \\<Longrightarrow> bij \\<alpha> \\<Longrightarrow> bij \\<beta> \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma \\<alpha>\\<beta>_refl: \"s \\<approx> s\"", "lemma \\<alpha>\\<beta>_trans: \"s \\<approx> s' \\<Longrightarrow> s' \\<approx> s'' \\<Longrightarrow> s \\<approx> s''\"", "lemma \\<alpha>\\<beta>_sym: \"s \\<approx> s' \\<Longrightarrow> s' \\<approx> s\"", "lemma renaming_distr_completion [simp]:\n  \"\\<R>\\<^sub>E \\<alpha> \\<beta> (\\<E>[e]) = ((\\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>)[\\<R>\\<^sub>E \\<alpha> \\<beta> e])\"", "lemma renaming_distr_combination [simp]: \n  \"\\<R>\\<^sub>S \\<alpha> \\<beta> (\\<sigma>;;\\<tau>) = (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>;;\\<R>\\<^sub>S \\<alpha> \\<beta> \\<tau>)\"", "lemma renaming_distr_store [simp]:\n  \"bij \\<beta> \\<Longrightarrow> \\<R>\\<^sub>S \\<alpha> \\<beta> (\\<sigma>(l \\<mapsto> v)) = \\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>(\\<beta> l \\<mapsto> \\<R>\\<^sub>V \\<alpha> \\<beta> v)\"", "lemma renaming_distr_global [simp]:\n  \"bij \\<alpha> \\<Longrightarrow> \\<R>\\<^sub>G \\<alpha> \\<beta> (s(r \\<mapsto> ls)) = \\<R>\\<^sub>G \\<alpha> \\<beta> s(\\<alpha> r \\<mapsto> \\<R>\\<^sub>L \\<alpha> \\<beta> ls)\"\n  \"bij \\<alpha> \\<Longrightarrow> \\<R>\\<^sub>G \\<alpha> \\<beta> (s(r := None)) = (\\<R>\\<^sub>G \\<alpha> \\<beta> s)(\\<alpha> r := None)\"", "lemma rename_empty [simp]:\n  \"\\<R>\\<^sub>S \\<alpha> \\<beta> \\<epsilon> = \\<epsilon>\"\n  \"\\<R>\\<^sub>G \\<alpha> \\<beta> \\<epsilon> = \\<epsilon>\"", "lemma swap_bij: \n  \"bij (id(x := x', x' := x))\" (is \"bij ?f\")", "lemma id_trivial_update [simp]: \"id(x := x) = id\"", "lemma eliminate_renaming_val_expr [simp]:\n  fixes\n    v :: \"('r,'l,'v) val\" and\n    e :: \"('r,'l,'v) expr\"\n  shows\n    \"l \\<notin> LID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v = \\<R>\\<^sub>V \\<alpha> \\<beta> v\"\n    \"l \\<notin> LID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e = \\<R>\\<^sub>E \\<alpha> \\<beta> e\"\n    \"r \\<notin> RID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v = \\<R>\\<^sub>V \\<alpha> \\<beta> v\"\n    \"r \\<notin> RID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e = \\<R>\\<^sub>E \\<alpha> \\<beta> e\"", "lemma eliminate_renaming_cntxt [simp]:\n  \"r \\<notin> RID\\<^sub>C \\<E> \\<Longrightarrow> \\<R>\\<^sub>C (\\<alpha>(r := r')) \\<beta> \\<E> = \\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>\"\n  \"l \\<notin> LID\\<^sub>C \\<E> \\<Longrightarrow> \\<R>\\<^sub>C \\<alpha> (\\<beta>(l := l')) \\<E> = \\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>\"", "lemma eliminate_swap_val [simp, intro]:\n  \"r \\<notin> RID\\<^sub>V v \\<Longrightarrow> r' \\<notin> RID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V (id(r := r', r' := r)) id v = v\"\n  \"l \\<notin> LID\\<^sub>V v \\<Longrightarrow> l' \\<notin> LID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V id (id(l := l', l' := l)) v = v\"", "lemma eliminate_swap_expr [simp, intro]:\n  \"r \\<notin> RID\\<^sub>E e \\<Longrightarrow> r' \\<notin> RID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E (id(r := r', r' := r)) id e = e\"\n  \"l \\<notin> LID\\<^sub>E e \\<Longrightarrow> l' \\<notin> LID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E id (id(l := l', l' := l)) e = e\"", "lemma eliminate_swap_cntxt [simp, intro]:\n  \"r \\<notin> RID\\<^sub>C \\<E> \\<Longrightarrow> r' \\<notin> RID\\<^sub>C \\<E> \\<Longrightarrow> \\<R>\\<^sub>C (id(r := r', r' := r)) id \\<E> = \\<E>\"\n  \"l \\<notin> LID\\<^sub>C \\<E> \\<Longrightarrow> l' \\<notin> LID\\<^sub>C \\<E> \\<Longrightarrow> \\<R>\\<^sub>C id (id(l := l', l' := l)) \\<E> = \\<E>\"", "lemma eliminate_swap_store_rid [simp, intro]:\n  \"r \\<notin> RID\\<^sub>S \\<sigma> \\<Longrightarrow> r' \\<notin> RID\\<^sub>S \\<sigma> \\<Longrightarrow> \\<R>\\<^sub>S (id(r := r', r' := r)) id \\<sigma> = \\<sigma>\"", "lemma eliminate_swap_store_lid [simp, intro]:\n  \"l \\<notin> LID\\<^sub>S \\<sigma> \\<Longrightarrow> l' \\<notin> LID\\<^sub>S \\<sigma> \\<Longrightarrow> \\<R>\\<^sub>S id (id(l := l', l' := l)) \\<sigma> = \\<sigma>\"", "lemma eliminate_swap_global_rid [simp, intro]:\n  \"r \\<notin> RID\\<^sub>G s \\<Longrightarrow> r' \\<notin> RID\\<^sub>G s \\<Longrightarrow> \\<R>\\<^sub>G (id(r := r', r' := r)) id s = s\"", "lemma eliminate_swap_global_lid [simp, intro]:\n  \"l \\<notin> LID\\<^sub>G s \\<Longrightarrow> l' \\<notin> LID\\<^sub>G s \\<Longrightarrow> \\<R>\\<^sub>G id (id(l := l', l' := l)) s = s\""], "translations": [["", "lemma \\<R>\\<^sub>S_implements_renaming: \"bij \\<beta> \\<Longrightarrow> is_store_renaming \\<alpha> \\<beta> \\<sigma> (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<beta> \\<Longrightarrow>\n    is_store_renaming \\<alpha> \\<beta> \\<sigma>\n     (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij \\<beta> \\<Longrightarrow>\n    is_store_renaming \\<alpha> \\<beta> \\<sigma>\n     (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>)", "assume \"bij \\<beta>\""], ["proof (state)\nthis:\n  bij \\<beta>\n\ngoal (1 subgoal):\n 1. bij \\<beta> \\<Longrightarrow>\n    is_store_renaming \\<alpha> \\<beta> \\<sigma>\n     (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>)", "hence \"inj \\<beta>\""], ["proof (prove)\nusing this:\n  bij \\<beta>\n\ngoal (1 subgoal):\n 1. inj \\<beta>", "using bij_def"], ["proof (prove)\nusing this:\n  bij \\<beta>\n  bij ?f = (inj ?f \\<and> surj ?f)\n\ngoal (1 subgoal):\n 1. inj \\<beta>", "by auto"], ["proof (state)\nthis:\n  inj \\<beta>\n\ngoal (1 subgoal):\n 1. bij \\<beta> \\<Longrightarrow>\n    is_store_renaming \\<alpha> \\<beta> \\<sigma>\n     (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj \\<beta>\n\ngoal (1 subgoal):\n 1. is_store_renaming \\<alpha> \\<beta> \\<sigma>\n     (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>)", "by (auto simp add: is_store_renaming_def option.case_eq_if)"], ["proof (state)\nthis:\n  is_store_renaming \\<alpha> \\<beta> \\<sigma>\n   (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun \\<R>\\<^sub>L :: \"('r \\<Rightarrow> 'r) \\<Rightarrow> ('l \\<Rightarrow> 'l) \\<Rightarrow> ('r,'l,'v) local_state \\<Rightarrow> ('r,'l,'v) local_state\" where\n  \"\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>,\\<tau>,e) = (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>, \\<R>\\<^sub>S \\<alpha> \\<beta> \\<tau>, \\<R>\\<^sub>E \\<alpha> \\<beta> e)\""], ["", "definition is_global_renaming :: \"('r \\<Rightarrow> 'r) \\<Rightarrow> ('l \\<Rightarrow> 'l) \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> bool\" where \n  \"is_global_renaming \\<alpha> \\<beta> s s' \\<equiv> \\<forall>r. case s r of None \\<Rightarrow> s' (\\<alpha> r) = None | Some ls \\<Rightarrow> s' (\\<alpha> r) = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)\""], ["", "fun \\<R>\\<^sub>G :: \"('r \\<Rightarrow> 'r) \\<Rightarrow> ('l \\<Rightarrow> 'l) \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> ('r,'l,'v) global_state\" where\n  \"\\<R>\\<^sub>G \\<alpha> \\<beta> s r = s (inv \\<alpha> r) \\<bind> (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls))\""], ["", "lemma \\<R>\\<^sub>G_implements_renaming: \"bij \\<alpha> \\<Longrightarrow> is_global_renaming \\<alpha> \\<beta> s (\\<R>\\<^sub>G \\<alpha> \\<beta> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<alpha> \\<Longrightarrow>\n    is_global_renaming \\<alpha> \\<beta> s (\\<R>\\<^sub>G \\<alpha> \\<beta> s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij \\<alpha> \\<Longrightarrow>\n    is_global_renaming \\<alpha> \\<beta> s (\\<R>\\<^sub>G \\<alpha> \\<beta> s)", "assume \"bij \\<alpha>\""], ["proof (state)\nthis:\n  bij \\<alpha>\n\ngoal (1 subgoal):\n 1. bij \\<alpha> \\<Longrightarrow>\n    is_global_renaming \\<alpha> \\<beta> s (\\<R>\\<^sub>G \\<alpha> \\<beta> s)", "hence \"inj \\<alpha>\""], ["proof (prove)\nusing this:\n  bij \\<alpha>\n\ngoal (1 subgoal):\n 1. inj \\<alpha>", "using bij_def"], ["proof (prove)\nusing this:\n  bij \\<alpha>\n  bij ?f = (inj ?f \\<and> surj ?f)\n\ngoal (1 subgoal):\n 1. inj \\<alpha>", "by auto"], ["proof (state)\nthis:\n  inj \\<alpha>\n\ngoal (1 subgoal):\n 1. bij \\<alpha> \\<Longrightarrow>\n    is_global_renaming \\<alpha> \\<beta> s (\\<R>\\<^sub>G \\<alpha> \\<beta> s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj \\<alpha>\n\ngoal (1 subgoal):\n 1. is_global_renaming \\<alpha> \\<beta> s (\\<R>\\<^sub>G \\<alpha> \\<beta> s)", "by (auto simp add: is_global_renaming_def option.case_eq_if)"], ["proof (state)\nthis:\n  is_global_renaming \\<alpha> \\<beta> s (\\<R>\\<^sub>G \\<alpha> \\<beta> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Introduction rules\\<close>"], ["", "lemma \\<R>\\<^sub>SI [intro]:\n  assumes\n    bij_\\<beta>: \"bij \\<beta>\" and\n    none_case: \"\\<And>l. \\<sigma> l = None \\<Longrightarrow> \\<sigma>' (\\<beta> l) = None\" and\n    some_case: \"\\<And>l v. \\<sigma> l = Some v \\<Longrightarrow> \\<sigma>' (\\<beta> l) = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\"\n  shows\n    \"\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma> = \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma> = \\<sigma>'", "proof (rule ext, subst \\<R>\\<^sub>S.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<sigma> (inv \\<beta> x) \\<bind>\n       (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n       \\<sigma>' x", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<sigma> (inv \\<beta> x) \\<bind>\n       (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n       \\<sigma>' x", "show \"\\<sigma> (inv \\<beta> l) \\<bind> (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) = \\<sigma>' l\" (is \"?lhs = \\<sigma>' l\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "proof (cases \"\\<sigma> (inv \\<beta> l) = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> (inv \\<beta> l) = None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l\n 2. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "case True"], ["proof (state)\nthis:\n  \\<sigma> (inv \\<beta> l) = None\n\ngoal (2 subgoals):\n 1. \\<sigma> (inv \\<beta> l) = None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l\n 2. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "have lhs_none: \"?lhs = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    None", "by (simp add: True)"], ["proof (state)\nthis:\n  \\<sigma> (inv \\<beta> l) \\<bind>\n  (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n  None\n\ngoal (2 subgoals):\n 1. \\<sigma> (inv \\<beta> l) = None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l\n 2. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "have \"\\<sigma>' (\\<beta> (inv \\<beta> l)) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>' (\\<beta> (inv \\<beta> l)) = None", "by (simp add: none_case True)"], ["proof (state)\nthis:\n  \\<sigma>' (\\<beta> (inv \\<beta> l)) = None\n\ngoal (2 subgoals):\n 1. \\<sigma> (inv \\<beta> l) = None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l\n 2. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "hence rhs_none: \"\\<sigma>' l = None\""], ["proof (prove)\nusing this:\n  \\<sigma>' (\\<beta> (inv \\<beta> l)) = None\n\ngoal (1 subgoal):\n 1. \\<sigma>' l = None", "by (simp add: bij_\\<beta> bijection.intro bijection.inv_right)"], ["proof (state)\nthis:\n  \\<sigma>' l = None\n\ngoal (2 subgoals):\n 1. \\<sigma> (inv \\<beta> l) = None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l\n 2. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "by (simp add: lhs_none rhs_none)"], ["proof (state)\nthis:\n  \\<sigma> (inv \\<beta> l) \\<bind>\n  (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n  \\<sigma>' l\n\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "case False"], ["proof (state)\nthis:\n  \\<sigma> (inv \\<beta> l) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "from this"], ["proof (chain)\npicking this:\n  \\<sigma> (inv \\<beta> l) \\<noteq> None", "obtain v where is_some: \"\\<sigma> (inv \\<beta> l) = Some v\""], ["proof (prove)\nusing this:\n  \\<sigma> (inv \\<beta> l) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> (inv \\<beta> l) = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma> (inv \\<beta> l) = Some v\n\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "hence lhs_some: \"?lhs = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\""], ["proof (prove)\nusing this:\n  \\<sigma> (inv \\<beta> l) = Some v\n\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)", "by auto"], ["proof (state)\nthis:\n  \\<sigma> (inv \\<beta> l) \\<bind>\n  (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n  Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\n\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "have \"\\<sigma>' (\\<beta> (inv \\<beta> l)) = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>' (\\<beta> (inv \\<beta> l)) =\n    Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)", "by (simp add: is_some some_case)"], ["proof (state)\nthis:\n  \\<sigma>' (\\<beta> (inv \\<beta> l)) =\n  Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\n\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "hence rhs_some: \"\\<sigma>' l = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\""], ["proof (prove)\nusing this:\n  \\<sigma>' (\\<beta> (inv \\<beta> l)) =\n  Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\n\ngoal (1 subgoal):\n 1. \\<sigma>' l = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)", "by (simp add: bij_\\<beta> bijection.intro bijection.inv_right)"], ["proof (state)\nthis:\n  \\<sigma>' l = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\n\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<noteq> None \\<Longrightarrow>\n    \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "then"], ["proof (chain)\npicking this:\n  \\<sigma>' l = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' l = Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)\n\ngoal (1 subgoal):\n 1. \\<sigma> (inv \\<beta> l) \\<bind>\n    (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n    \\<sigma>' l", "by (simp add: lhs_some)"], ["proof (state)\nthis:\n  \\<sigma> (inv \\<beta> l) \\<bind>\n  (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n  \\<sigma>' l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma> (inv \\<beta> l) \\<bind>\n  (\\<lambda>v. Some (\\<R>\\<^sub>V \\<alpha> \\<beta> v)) =\n  \\<sigma>' l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<R>\\<^sub>GI [intro]: \n  assumes\n    bij_\\<alpha>: \"bij \\<alpha>\" and\n    none_case: \"\\<And>r. s r = None \\<Longrightarrow> s' (\\<alpha> r) = None\" and\n    some_case: \"\\<And>r \\<sigma> \\<tau> e. s r = Some (\\<sigma>,\\<tau>,e) \\<Longrightarrow> s' (\\<alpha> r) = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>,\\<tau>,e))\"\n  shows\n    \"\\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>G \\<alpha> \\<beta> s = s'", "proof (rule ext, subst \\<R>\\<^sub>G.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       s (inv \\<alpha> x) \\<bind>\n       (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n       s' x", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       s (inv \\<alpha> x) \\<bind>\n       (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n       s' x", "show \"s (inv \\<alpha> r) \\<bind> (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) = s' r\" (is \"?lhs = s' r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "proof (cases \"s (inv \\<alpha> r) = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s (inv \\<alpha> r) = None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r\n 2. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "case True"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) = None\n\ngoal (2 subgoals):\n 1. s (inv \\<alpha> r) = None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r\n 2. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "have lhs_none: \"?lhs = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    None", "by (simp add: True)"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) \\<bind>\n  (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n  None\n\ngoal (2 subgoals):\n 1. s (inv \\<alpha> r) = None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r\n 2. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "have \"s' (\\<alpha> (inv \\<alpha> r)) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' (\\<alpha> (inv \\<alpha> r)) = None", "by (simp add: none_case True)"], ["proof (state)\nthis:\n  s' (\\<alpha> (inv \\<alpha> r)) = None\n\ngoal (2 subgoals):\n 1. s (inv \\<alpha> r) = None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r\n 2. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "hence rhs_none: \"s' r = None\""], ["proof (prove)\nusing this:\n  s' (\\<alpha> (inv \\<alpha> r)) = None\n\ngoal (1 subgoal):\n 1. s' r = None", "by (simp add: bij_\\<alpha> bijection.intro bijection.inv_right)"], ["proof (state)\nthis:\n  s' r = None\n\ngoal (2 subgoals):\n 1. s (inv \\<alpha> r) = None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r\n 2. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "by (simp add: lhs_none rhs_none)"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) \\<bind>\n  (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n  s' r\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "case False"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) \\<noteq> None\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "from this"], ["proof (chain)\npicking this:\n  s (inv \\<alpha> r) \\<noteq> None", "obtain ls where \"s (inv \\<alpha> r) = Some ls\""], ["proof (prove)\nusing this:\n  s (inv \\<alpha> r) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>ls.\n        s (inv \\<alpha> r) = Some ls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) = Some ls\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "from this"], ["proof (chain)\npicking this:\n  s (inv \\<alpha> r) = Some ls", "obtain \\<sigma> \\<tau> e where is_some: \"s (inv \\<alpha> r) = Some (\\<sigma>, \\<tau>, e)\""], ["proof (prove)\nusing this:\n  s (inv \\<alpha> r) = Some ls\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> \\<tau> e.\n        s (inv \\<alpha> r) = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ls) blast"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) = Some (\\<sigma>, \\<tau>, e)\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "hence lhs_some: \"?lhs = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))\""], ["proof (prove)\nusing this:\n  s (inv \\<alpha> r) = Some (\\<sigma>, \\<tau>, e)\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))", "by auto"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) \\<bind>\n  (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n  Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "have \"s' (\\<alpha> (inv \\<alpha> r)) = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' (\\<alpha> (inv \\<alpha> r)) =\n    Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))", "by (simp add: is_some some_case)"], ["proof (state)\nthis:\n  s' (\\<alpha> (inv \\<alpha> r)) =\n  Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "hence rhs_some: \"s' r = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))\""], ["proof (prove)\nusing this:\n  s' (\\<alpha> (inv \\<alpha> r)) =\n  Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))\n\ngoal (1 subgoal):\n 1. s' r = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))", "by (simp add: bij_\\<alpha> bijection.intro bijection.inv_right)"], ["proof (state)\nthis:\n  s' r = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<noteq> None \\<Longrightarrow>\n    s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "then"], ["proof (chain)\npicking this:\n  s' r = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))", "show ?thesis"], ["proof (prove)\nusing this:\n  s' r = Some (\\<R>\\<^sub>L \\<alpha> \\<beta> (\\<sigma>, \\<tau>, e))\n\ngoal (1 subgoal):\n 1. s (inv \\<alpha> r) \\<bind>\n    (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n    s' r", "by (simp add: lhs_some)"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) \\<bind>\n  (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n  s' r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s (inv \\<alpha> r) \\<bind>\n  (\\<lambda>ls. Some (\\<R>\\<^sub>L \\<alpha> \\<beta> ls)) =\n  s' r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Renaming-equivalence\\<close>"], ["", "subsubsection Identity"], ["", "declare val.map_id [simp]"], ["", "declare expr.map_id [simp]"], ["", "declare cntxt.map_id [simp]"], ["", "lemma \\<R>\\<^sub>S_id [simp]: \"\\<R>\\<^sub>S id id \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>S id id \\<sigma> = \\<sigma>", "by auto"], ["", "lemma \\<R>\\<^sub>L_id [simp]: \"\\<R>\\<^sub>L id id ls = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>L id id ls = ls", "by (cases ls) simp"], ["", "lemma \\<R>\\<^sub>G_id [simp]: \"\\<R>\\<^sub>G id id s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>G id id s = s", "by auto"], ["", "subsubsection Composition"], ["", "declare val.map_comp [simp]"], ["", "declare expr.map_comp [simp]"], ["", "declare cntxt.map_comp [simp]"], ["", "lemma \\<R>\\<^sub>S_comp [simp]: \"\\<lbrakk> bij \\<beta>; bij \\<beta>' \\<rbrakk> \\<Longrightarrow> \\<R>\\<^sub>S \\<alpha>' \\<beta>' (\\<R>\\<^sub>S \\<alpha> \\<beta> s) = \\<R>\\<^sub>S (\\<alpha>' \\<circ> \\<alpha>) (\\<beta>' \\<circ> \\<beta>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<beta>; bij \\<beta>'\\<rbrakk>\n    \\<Longrightarrow> \\<R>\\<^sub>S \\<alpha>' \\<beta>'\n                       (\\<R>\\<^sub>S \\<alpha> \\<beta> s) =\n                      \\<R>\\<^sub>S (\\<alpha>' \\<circ> \\<alpha>)\n                       (\\<beta>' \\<circ> \\<beta>) s", "by (auto simp add: o_inv_distrib)"], ["", "lemma \\<R>\\<^sub>L_comp [simp]: \"\\<lbrakk> bij \\<beta>; bij \\<beta>' \\<rbrakk> \\<Longrightarrow> \\<R>\\<^sub>L \\<alpha>' \\<beta>' (\\<R>\\<^sub>L \\<alpha> \\<beta> ls) = \\<R>\\<^sub>L (\\<alpha>' \\<circ> \\<alpha>) (\\<beta>' \\<circ> \\<beta>) ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<beta>; bij \\<beta>'\\<rbrakk>\n    \\<Longrightarrow> \\<R>\\<^sub>L \\<alpha>' \\<beta>'\n                       (\\<R>\\<^sub>L \\<alpha> \\<beta> ls) =\n                      \\<R>\\<^sub>L (\\<alpha>' \\<circ> \\<alpha>)\n                       (\\<beta>' \\<circ> \\<beta>) ls", "by (cases ls) simp"], ["", "lemma \\<R>\\<^sub>G_comp [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<alpha>'; bij \\<beta>; bij \\<beta>' \\<rbrakk> \\<Longrightarrow> \\<R>\\<^sub>G \\<alpha>' \\<beta>' (\\<R>\\<^sub>G \\<alpha> \\<beta> s) = \\<R>\\<^sub>G (\\<alpha>' \\<circ> \\<alpha>) (\\<beta>' \\<circ> \\<beta>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<alpha>; bij \\<alpha>'; bij \\<beta>; bij \\<beta>'\\<rbrakk>\n    \\<Longrightarrow> \\<R>\\<^sub>G \\<alpha>' \\<beta>'\n                       (\\<R>\\<^sub>G \\<alpha> \\<beta> s) =\n                      \\<R>\\<^sub>G (\\<alpha>' \\<circ> \\<alpha>)\n                       (\\<beta>' \\<circ> \\<beta>) s", "by (rule ext) (auto simp add: o_inv_distrib)"], ["", "subsubsection Inverse"], ["", "lemma \\<R>\\<^sub>V_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>V (inv \\<alpha>) (inv \\<beta>) v' = v) = (\\<R>\\<^sub>V \\<alpha> \\<beta> v = v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<alpha>; bij \\<beta>\\<rbrakk>\n    \\<Longrightarrow> (\\<R>\\<^sub>V (inv \\<alpha>) (inv \\<beta>) v' = v) =\n                      (\\<R>\\<^sub>V \\<alpha> \\<beta> v = v')", "by (auto simp add: bijection.intro bijection.inv_comp_right bijection.inv_comp_left)"], ["", "lemma \\<R>\\<^sub>E_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>E (inv \\<alpha>) (inv \\<beta>) e' = e) = (\\<R>\\<^sub>E \\<alpha> \\<beta> e = e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<alpha>; bij \\<beta>\\<rbrakk>\n    \\<Longrightarrow> (\\<R>\\<^sub>E (inv \\<alpha>) (inv \\<beta>) e' = e) =\n                      (\\<R>\\<^sub>E \\<alpha> \\<beta> e = e')", "by (auto simp add: bijection.intro bijection.inv_comp_right bijection.inv_comp_left)"], ["", "lemma \\<R>\\<^sub>C_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>C (inv \\<alpha>) (inv \\<beta>) \\<E>' = \\<E>) = (\\<R>\\<^sub>C \\<alpha> \\<beta> \\<E> = \\<E>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<alpha>; bij \\<beta>\\<rbrakk>\n    \\<Longrightarrow> (\\<R>\\<^sub>C (inv \\<alpha>) (inv \\<beta>) \\<E>' =\n                       \\<E>) =\n                      (\\<R>\\<^sub>C \\<alpha> \\<beta> \\<E> = \\<E>')", "by (auto simp add: bijection.intro bijection.inv_comp_right bijection.inv_comp_left)"], ["", "lemma \\<R>\\<^sub>S_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>S (inv \\<alpha>) (inv \\<beta>) \\<sigma>' = \\<sigma>) = (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma> = \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<alpha>; bij \\<beta>\\<rbrakk>\n    \\<Longrightarrow> (\\<R>\\<^sub>S (inv \\<alpha>) (inv \\<beta>) \\<sigma>' =\n                       \\<sigma>) =\n                      (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma> = \\<sigma>')", "by (auto simp add: bij_imp_bij_inv bijection.intro bijection.inv_comp_right bijection.inv_comp_left)"], ["", "lemma \\<R>\\<^sub>L_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>L (inv \\<alpha>) (inv \\<beta>) ls' = ls) = (\\<R>\\<^sub>L \\<alpha> \\<beta> ls = ls')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<alpha>; bij \\<beta>\\<rbrakk>\n    \\<Longrightarrow> (\\<R>\\<^sub>L (inv \\<alpha>) (inv \\<beta>) ls' = ls) =\n                      (\\<R>\\<^sub>L \\<alpha> \\<beta> ls = ls')", "by (auto simp add: bij_imp_bij_inv bijection.intro bijection.inv_comp_right bijection.inv_comp_left)"], ["", "lemma \\<R>\\<^sub>G_inv [simp]: \"\\<lbrakk> bij \\<alpha>; bij \\<beta> \\<rbrakk> \\<Longrightarrow> (\\<R>\\<^sub>G (inv \\<alpha>) (inv \\<beta>) s' = s) = (\\<R>\\<^sub>G \\<alpha> \\<beta> s = s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij \\<alpha>; bij \\<beta>\\<rbrakk>\n    \\<Longrightarrow> (\\<R>\\<^sub>G (inv \\<alpha>) (inv \\<beta>) s' = s) =\n                      (\\<R>\\<^sub>G \\<alpha> \\<beta> s = s')", "by (auto simp add: bij_imp_bij_inv bijection.intro bijection.inv_comp_right bijection.inv_comp_left)"], ["", "subsubsection Equivalence"], ["", "definition eq_states :: \"('r,'l,'v) global_state \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> bool\" (\"_ \\<approx> _\" [100, 100]) where\n  \"s \\<approx> s' \\<equiv> \\<exists>\\<alpha> \\<beta>. bij \\<alpha> \\<and> bij \\<beta> \\<and> \\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\""], ["", "lemma eq_statesI [intro]:\n  \"\\<R>\\<^sub>G \\<alpha> \\<beta> s = s' \\<Longrightarrow> bij \\<alpha> \\<Longrightarrow> bij \\<beta> \\<Longrightarrow> s \\<approx> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<R>\\<^sub>G \\<alpha> \\<beta> s = s'; bij \\<alpha>;\n     bij \\<beta>\\<rbrakk>\n    \\<Longrightarrow> s \\<approx> s'", "using eq_states_def"], ["proof (prove)\nusing this:\n  ?s \\<approx> ?s' \\<equiv>\n  \\<exists>\\<alpha> \\<beta>.\n     bij \\<alpha> \\<and>\n     bij \\<beta> \\<and> \\<R>\\<^sub>G \\<alpha> \\<beta> ?s = ?s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<R>\\<^sub>G \\<alpha> \\<beta> s = s'; bij \\<alpha>;\n     bij \\<beta>\\<rbrakk>\n    \\<Longrightarrow> s \\<approx> s'", "by auto"], ["", "lemma eq_statesE [elim]:\n  \"s \\<approx> s' \\<Longrightarrow> (\\<And>\\<alpha> \\<beta>. \\<R>\\<^sub>G \\<alpha> \\<beta> s = s' \\<Longrightarrow> bij \\<alpha> \\<Longrightarrow> bij \\<beta> \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<approx> s';\n     \\<And>\\<alpha> \\<beta>.\n        \\<lbrakk>\\<R>\\<^sub>G \\<alpha> \\<beta> s = s'; bij \\<alpha>;\n         bij \\<beta>\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "using eq_states_def"], ["proof (prove)\nusing this:\n  ?s \\<approx> ?s' \\<equiv>\n  \\<exists>\\<alpha> \\<beta>.\n     bij \\<alpha> \\<and>\n     bij \\<beta> \\<and> \\<R>\\<^sub>G \\<alpha> \\<beta> ?s = ?s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<approx> s';\n     \\<And>\\<alpha> \\<beta>.\n        \\<lbrakk>\\<R>\\<^sub>G \\<alpha> \\<beta> s = s'; bij \\<alpha>;\n         bij \\<beta>\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by blast"], ["", "lemma \\<alpha>\\<beta>_refl: \"s \\<approx> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<approx> s", "by (rule eq_statesI[of id id s]) auto"], ["", "lemma \\<alpha>\\<beta>_trans: \"s \\<approx> s' \\<Longrightarrow> s' \\<approx> s'' \\<Longrightarrow> s \\<approx> s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<approx> s'; s' \\<approx> s''\\<rbrakk>\n    \\<Longrightarrow> s \\<approx> s''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<approx> s'; s' \\<approx> s''\\<rbrakk>\n    \\<Longrightarrow> s \\<approx> s''", "assume \"s \\<approx> s'\""], ["proof (state)\nthis:\n  s \\<approx> s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<approx> s'; s' \\<approx> s''\\<rbrakk>\n    \\<Longrightarrow> s \\<approx> s''", "from this"], ["proof (chain)\npicking this:\n  s \\<approx> s'", "obtain \\<alpha> \\<beta> where s_s': \"bij \\<alpha>\" \"bij \\<beta>\" \"\\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\""], ["proof (prove)\nusing this:\n  s \\<approx> s'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> \\<beta>.\n        \\<lbrakk>bij \\<alpha>; bij \\<beta>;\n         \\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bij \\<alpha>\n  bij \\<beta>\n  \\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<approx> s'; s' \\<approx> s''\\<rbrakk>\n    \\<Longrightarrow> s \\<approx> s''", "assume \"s' \\<approx> s''\""], ["proof (state)\nthis:\n  s' \\<approx> s''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<approx> s'; s' \\<approx> s''\\<rbrakk>\n    \\<Longrightarrow> s \\<approx> s''", "from this"], ["proof (chain)\npicking this:\n  s' \\<approx> s''", "obtain \\<alpha>' \\<beta>' where s'_s'': \"bij \\<alpha>'\" \"bij \\<beta>'\" \"\\<R>\\<^sub>G \\<alpha>' \\<beta>' s' = s''\""], ["proof (prove)\nusing this:\n  s' \\<approx> s''\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>' \\<beta>'.\n        \\<lbrakk>bij \\<alpha>'; bij \\<beta>';\n         \\<R>\\<^sub>G \\<alpha>' \\<beta>' s' = s''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bij \\<alpha>'\n  bij \\<beta>'\n  \\<R>\\<^sub>G \\<alpha>' \\<beta>' s' = s''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<approx> s'; s' \\<approx> s''\\<rbrakk>\n    \\<Longrightarrow> s \\<approx> s''", "show \"s \\<approx> s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<approx> s''", "by (rule eq_statesI[of \"\\<alpha>' \\<circ> \\<alpha>\" \"\\<beta>' \\<circ> \\<beta>\"]) (use s_s' s'_s'' in \\<open>auto simp add: bij_comp\\<close>)"], ["proof (state)\nthis:\n  s \\<approx> s''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<alpha>\\<beta>_sym: \"s \\<approx> s' \\<Longrightarrow> s' \\<approx> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<approx> s' \\<Longrightarrow> s' \\<approx> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<approx> s' \\<Longrightarrow> s' \\<approx> s", "assume \"s \\<approx> s'\""], ["proof (state)\nthis:\n  s \\<approx> s'\n\ngoal (1 subgoal):\n 1. s \\<approx> s' \\<Longrightarrow> s' \\<approx> s", "from this"], ["proof (chain)\npicking this:\n  s \\<approx> s'", "obtain \\<alpha> \\<beta> where s_s': \"bij \\<alpha>\" \"bij \\<beta>\" \"\\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\""], ["proof (prove)\nusing this:\n  s \\<approx> s'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> \\<beta>.\n        \\<lbrakk>bij \\<alpha>; bij \\<beta>;\n         \\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bij \\<alpha>\n  bij \\<beta>\n  \\<R>\\<^sub>G \\<alpha> \\<beta> s = s'\n\ngoal (1 subgoal):\n 1. s \\<approx> s' \\<Longrightarrow> s' \\<approx> s", "show \"s' \\<approx> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<approx> s", "by (rule eq_statesI[of \"inv \\<alpha>\" \"inv \\<beta>\"]) (use s_s' in \\<open>auto simp add: bij_imp_bij_inv\\<close>)"], ["proof (state)\nthis:\n  s' \\<approx> s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Distributive laws\\<close>"], ["", "subsubsection Expression"], ["", "lemma renaming_distr_completion [simp]:\n  \"\\<R>\\<^sub>E \\<alpha> \\<beta> (\\<E>[e]) = ((\\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>)[\\<R>\\<^sub>E \\<alpha> \\<beta> e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>E \\<alpha> \\<beta> (\\<E> [e]) =\n    (\\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>) [\\<R>\\<^sub>E \\<alpha> \\<beta> e]", "by (induct \\<E>) simp+"], ["", "subsubsection Store"], ["", "lemma renaming_distr_combination [simp]: \n  \"\\<R>\\<^sub>S \\<alpha> \\<beta> (\\<sigma>;;\\<tau>) = (\\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>;;\\<R>\\<^sub>S \\<alpha> \\<beta> \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>S \\<alpha> \\<beta> (\\<sigma>;;\\<tau>) =\n    (\\<R>\\<^sub>S \\<alpha> \\<beta>\n      \\<sigma>;;\\<R>\\<^sub>S \\<alpha> \\<beta> \\<tau>)", "by (rule ext) auto"], ["", "lemma renaming_distr_store [simp]:\n  \"bij \\<beta> \\<Longrightarrow> \\<R>\\<^sub>S \\<alpha> \\<beta> (\\<sigma>(l \\<mapsto> v)) = \\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>(\\<beta> l \\<mapsto> \\<R>\\<^sub>V \\<alpha> \\<beta> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<beta> \\<Longrightarrow>\n    \\<R>\\<^sub>S \\<alpha> \\<beta> (\\<sigma>(l \\<mapsto> v)) =\n    \\<R>\\<^sub>S \\<alpha> \\<beta> \\<sigma>(\\<beta> l \\<mapsto>\n    \\<R>\\<^sub>V \\<alpha> \\<beta> v)", "by (auto simp add: bijection.intro bijection.inv_left_eq_iff)"], ["", "(* distribution law for local follows from the definition *)"], ["", "subsubsection Global"], ["", "lemma renaming_distr_global [simp]:\n  \"bij \\<alpha> \\<Longrightarrow> \\<R>\\<^sub>G \\<alpha> \\<beta> (s(r \\<mapsto> ls)) = \\<R>\\<^sub>G \\<alpha> \\<beta> s(\\<alpha> r \\<mapsto> \\<R>\\<^sub>L \\<alpha> \\<beta> ls)\"\n  \"bij \\<alpha> \\<Longrightarrow> \\<R>\\<^sub>G \\<alpha> \\<beta> (s(r := None)) = (\\<R>\\<^sub>G \\<alpha> \\<beta> s)(\\<alpha> r := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bij \\<alpha> \\<Longrightarrow>\n     \\<R>\\<^sub>G \\<alpha> \\<beta> (s(r \\<mapsto> ls)) =\n     \\<R>\\<^sub>G \\<alpha> \\<beta> s(\\<alpha> r \\<mapsto>\n     \\<R>\\<^sub>L \\<alpha> \\<beta> ls)) &&&\n    (bij \\<alpha> \\<Longrightarrow>\n     \\<R>\\<^sub>G \\<alpha> \\<beta> (s(r := None)) =\n     (\\<R>\\<^sub>G \\<alpha> \\<beta> s)(\\<alpha> r := None))", "by (auto simp add: bijection.intro bijection.inv_left_eq_iff)"], ["", "subsection \\<open>Miscellaneous laws\\<close>"], ["", "lemma rename_empty [simp]:\n  \"\\<R>\\<^sub>S \\<alpha> \\<beta> \\<epsilon> = \\<epsilon>\"\n  \"\\<R>\\<^sub>G \\<alpha> \\<beta> \\<epsilon> = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>S \\<alpha> \\<beta> \\<epsilon> = \\<epsilon> &&&\n    \\<R>\\<^sub>G \\<alpha> \\<beta> \\<epsilon> = \\<epsilon>", "by auto"], ["", "subsection Swaps"], ["", "lemma swap_bij: \n  \"bij (id(x := x', x' := x))\" (is \"bij ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (id(x := x', x' := x))", "proof (rule bijI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj (id(x := x', x' := x))\n 2. surj (id(x := x', x' := x))", "show \"inj ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (id(x := x', x' := x))", "by (simp add: inj_on_def)"], ["proof (state)\nthis:\n  inj (id(x := x', x' := x))\n\ngoal (1 subgoal):\n 1. surj (id(x := x', x' := x))", "show \"surj ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (id(x := x', x' := x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. range (id(x := x', x' := x)) \\<subseteq> UNIV\n 2. UNIV \\<subseteq> range (id(x := x', x' := x))", "show \"UNIV \\<subseteq> range (id(x := x', x' := x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> range (id(x := x', x' := x))", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> UNIV \\<Longrightarrow> xa \\<in> range (id(x := x', x' := x))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> UNIV \\<Longrightarrow> xa \\<in> range (id(x := x', x' := x))", "assume \"y \\<in> (UNIV :: 'a set)\""], ["proof (state)\nthis:\n  y \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> UNIV \\<Longrightarrow> xa \\<in> range (id(x := x', x' := x))", "show \"y \\<in> range (id(x := x', x' := x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> range (id(x := x', x' := x))", "by (cases \"y = x\"; cases \"y = x'\") auto"], ["proof (state)\nthis:\n  y \\<in> range (id(x := x', x' := x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UNIV \\<subseteq> range (id(x := x', x' := x))\n\ngoal (1 subgoal):\n 1. range (id(x := x', x' := x)) \\<subseteq> UNIV", "qed simp"], ["proof (state)\nthis:\n  surj (id(x := x', x' := x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma id_trivial_update [simp]: \"id(x := x) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id(x := x) = id", "by auto"], ["", "(* for solving trivial peaks *)"], ["", "lemma eliminate_renaming_val_expr [simp]:\n  fixes\n    v :: \"('r,'l,'v) val\" and\n    e :: \"('r,'l,'v) expr\"\n  shows\n    \"l \\<notin> LID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v = \\<R>\\<^sub>V \\<alpha> \\<beta> v\"\n    \"l \\<notin> LID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e = \\<R>\\<^sub>E \\<alpha> \\<beta> e\"\n    \"r \\<notin> RID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v = \\<R>\\<^sub>V \\<alpha> \\<beta> v\"\n    \"r \\<notin> RID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e = \\<R>\\<^sub>E \\<alpha> \\<beta> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l \\<notin> LID\\<^sub>V v \\<Longrightarrow>\n      \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n      \\<R>\\<^sub>V \\<alpha> \\<beta> v) &&&\n     (l \\<notin> LID\\<^sub>E e \\<Longrightarrow>\n      \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n      \\<R>\\<^sub>E \\<alpha> \\<beta> e)) &&&\n    (r \\<notin> RID\\<^sub>V v \\<Longrightarrow>\n     \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v =\n     \\<R>\\<^sub>V \\<alpha> \\<beta> v) &&&\n    (r \\<notin> RID\\<^sub>E e \\<Longrightarrow>\n     \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e =\n     \\<R>\\<^sub>E \\<alpha> \\<beta> e)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. l \\<notin> LID\\<^sub>V v \\<Longrightarrow>\n    \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n    \\<R>\\<^sub>V \\<alpha> \\<beta> v\n 2. l \\<notin> LID\\<^sub>E e \\<Longrightarrow>\n    \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n    \\<R>\\<^sub>E \\<alpha> \\<beta> e\n 3. r \\<notin> RID\\<^sub>V v \\<Longrightarrow>\n    \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v =\n    \\<R>\\<^sub>V \\<alpha> \\<beta> v\n 4. r \\<notin> RID\\<^sub>E e \\<Longrightarrow>\n    \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e =\n    \\<R>\\<^sub>E \\<alpha> \\<beta> e", "have \"(\\<forall>\\<alpha> \\<beta> r r'. r \\<notin> RID\\<^sub>V v \\<longrightarrow> \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v = \\<R>\\<^sub>V \\<alpha> \\<beta> v) \\<and>\n    (\\<forall>\\<alpha> \\<beta> r r'. r \\<notin> RID\\<^sub>E e \\<longrightarrow> \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e = \\<R>\\<^sub>E \\<alpha> \\<beta> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<alpha> \\<beta> r r'.\n        r \\<notin> RID\\<^sub>V v \\<longrightarrow>\n        \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v =\n        \\<R>\\<^sub>V \\<alpha> \\<beta> v) \\<and>\n    (\\<forall>\\<alpha> \\<beta> r r'.\n        r \\<notin> RID\\<^sub>E e \\<longrightarrow>\n        \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e =\n        \\<R>\\<^sub>E \\<alpha> \\<beta> e)", "by (induct rule: val_expr.induct) simp+"], ["proof (state)\nthis:\n  (\\<forall>\\<alpha> \\<beta> r r'.\n      r \\<notin> RID\\<^sub>V v \\<longrightarrow>\n      \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v =\n      \\<R>\\<^sub>V \\<alpha> \\<beta> v) \\<and>\n  (\\<forall>\\<alpha> \\<beta> r r'.\n      r \\<notin> RID\\<^sub>E e \\<longrightarrow>\n      \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e =\n      \\<R>\\<^sub>E \\<alpha> \\<beta> e)\n\ngoal (4 subgoals):\n 1. l \\<notin> LID\\<^sub>V v \\<Longrightarrow>\n    \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n    \\<R>\\<^sub>V \\<alpha> \\<beta> v\n 2. l \\<notin> LID\\<^sub>E e \\<Longrightarrow>\n    \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n    \\<R>\\<^sub>E \\<alpha> \\<beta> e\n 3. r \\<notin> RID\\<^sub>V v \\<Longrightarrow>\n    \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v =\n    \\<R>\\<^sub>V \\<alpha> \\<beta> v\n 4. r \\<notin> RID\\<^sub>E e \\<Longrightarrow>\n    \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e =\n    \\<R>\\<^sub>E \\<alpha> \\<beta> e", "thus \n    \"r \\<notin> RID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v = \\<R>\\<^sub>V \\<alpha> \\<beta> v\" \n    \"r \\<notin> RID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e = \\<R>\\<^sub>E \\<alpha> \\<beta> e\""], ["proof (prove)\nusing this:\n  (\\<forall>\\<alpha> \\<beta> r r'.\n      r \\<notin> RID\\<^sub>V v \\<longrightarrow>\n      \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v =\n      \\<R>\\<^sub>V \\<alpha> \\<beta> v) \\<and>\n  (\\<forall>\\<alpha> \\<beta> r r'.\n      r \\<notin> RID\\<^sub>E e \\<longrightarrow>\n      \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e =\n      \\<R>\\<^sub>E \\<alpha> \\<beta> e)\n\ngoal (1 subgoal):\n 1. (r \\<notin> RID\\<^sub>V v \\<Longrightarrow>\n     \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v =\n     \\<R>\\<^sub>V \\<alpha> \\<beta> v) &&&\n    (r \\<notin> RID\\<^sub>E e \\<Longrightarrow>\n     \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e =\n     \\<R>\\<^sub>E \\<alpha> \\<beta> e)", "by simp+"], ["proof (state)\nthis:\n  r \\<notin> RID\\<^sub>V v \\<Longrightarrow>\n  \\<R>\\<^sub>V (\\<alpha>(r := r')) \\<beta> v =\n  \\<R>\\<^sub>V \\<alpha> \\<beta> v\n  r \\<notin> RID\\<^sub>E e \\<Longrightarrow>\n  \\<R>\\<^sub>E (\\<alpha>(r := r')) \\<beta> e =\n  \\<R>\\<^sub>E \\<alpha> \\<beta> e\n\ngoal (2 subgoals):\n 1. l \\<notin> LID\\<^sub>V v \\<Longrightarrow>\n    \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n    \\<R>\\<^sub>V \\<alpha> \\<beta> v\n 2. l \\<notin> LID\\<^sub>E e \\<Longrightarrow>\n    \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n    \\<R>\\<^sub>E \\<alpha> \\<beta> e", "have \"(\\<forall>\\<alpha> \\<beta> l l'. l \\<notin> LID\\<^sub>V v \\<longrightarrow> \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v = \\<R>\\<^sub>V \\<alpha> \\<beta> v) \\<and>\n    (\\<forall>\\<alpha> \\<beta> l l'. l \\<notin> LID\\<^sub>E e \\<longrightarrow> \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e = \\<R>\\<^sub>E \\<alpha> \\<beta> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<alpha> \\<beta> l l'.\n        l \\<notin> LID\\<^sub>V v \\<longrightarrow>\n        \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n        \\<R>\\<^sub>V \\<alpha> \\<beta> v) \\<and>\n    (\\<forall>\\<alpha> \\<beta> l l'.\n        l \\<notin> LID\\<^sub>E e \\<longrightarrow>\n        \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n        \\<R>\\<^sub>E \\<alpha> \\<beta> e)", "by (induct rule: val_expr.induct) simp+"], ["proof (state)\nthis:\n  (\\<forall>\\<alpha> \\<beta> l l'.\n      l \\<notin> LID\\<^sub>V v \\<longrightarrow>\n      \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n      \\<R>\\<^sub>V \\<alpha> \\<beta> v) \\<and>\n  (\\<forall>\\<alpha> \\<beta> l l'.\n      l \\<notin> LID\\<^sub>E e \\<longrightarrow>\n      \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n      \\<R>\\<^sub>E \\<alpha> \\<beta> e)\n\ngoal (2 subgoals):\n 1. l \\<notin> LID\\<^sub>V v \\<Longrightarrow>\n    \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n    \\<R>\\<^sub>V \\<alpha> \\<beta> v\n 2. l \\<notin> LID\\<^sub>E e \\<Longrightarrow>\n    \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n    \\<R>\\<^sub>E \\<alpha> \\<beta> e", "thus \n    \"l \\<notin> LID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v = \\<R>\\<^sub>V \\<alpha> \\<beta> v\" and\n    \"l \\<notin> LID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e = \\<R>\\<^sub>E \\<alpha> \\<beta> e\""], ["proof (prove)\nusing this:\n  (\\<forall>\\<alpha> \\<beta> l l'.\n      l \\<notin> LID\\<^sub>V v \\<longrightarrow>\n      \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n      \\<R>\\<^sub>V \\<alpha> \\<beta> v) \\<and>\n  (\\<forall>\\<alpha> \\<beta> l l'.\n      l \\<notin> LID\\<^sub>E e \\<longrightarrow>\n      \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n      \\<R>\\<^sub>E \\<alpha> \\<beta> e)\n\ngoal (1 subgoal):\n 1. (l \\<notin> LID\\<^sub>V v \\<Longrightarrow>\n     \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n     \\<R>\\<^sub>V \\<alpha> \\<beta> v) &&&\n    (l \\<notin> LID\\<^sub>E e \\<Longrightarrow>\n     \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n     \\<R>\\<^sub>E \\<alpha> \\<beta> e)", "by simp+"], ["proof (state)\nthis:\n  l \\<notin> LID\\<^sub>V v \\<Longrightarrow>\n  \\<R>\\<^sub>V \\<alpha> (\\<beta>(l := l')) v =\n  \\<R>\\<^sub>V \\<alpha> \\<beta> v\n  l \\<notin> LID\\<^sub>E e \\<Longrightarrow>\n  \\<R>\\<^sub>E \\<alpha> (\\<beta>(l := l')) e =\n  \\<R>\\<^sub>E \\<alpha> \\<beta> e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eliminate_renaming_cntxt [simp]:\n  \"r \\<notin> RID\\<^sub>C \\<E> \\<Longrightarrow> \\<R>\\<^sub>C (\\<alpha>(r := r')) \\<beta> \\<E> = \\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>\"\n  \"l \\<notin> LID\\<^sub>C \\<E> \\<Longrightarrow> \\<R>\\<^sub>C \\<alpha> (\\<beta>(l := l')) \\<E> = \\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<notin> RID\\<^sub>C \\<E> \\<Longrightarrow>\n     \\<R>\\<^sub>C (\\<alpha>(r := r')) \\<beta> \\<E> =\n     \\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>) &&&\n    (l \\<notin> LID\\<^sub>C \\<E> \\<Longrightarrow>\n     \\<R>\\<^sub>C \\<alpha> (\\<beta>(l := l')) \\<E> =\n     \\<R>\\<^sub>C \\<alpha> \\<beta> \\<E>)", "by (induct \\<E> rule: cntxt.induct) auto"], ["", "lemma eliminate_swap_val [simp, intro]:\n  \"r \\<notin> RID\\<^sub>V v \\<Longrightarrow> r' \\<notin> RID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V (id(r := r', r' := r)) id v = v\"\n  \"l \\<notin> LID\\<^sub>V v \\<Longrightarrow> l' \\<notin> LID\\<^sub>V v \\<Longrightarrow> \\<R>\\<^sub>V id (id(l := l', l' := l)) v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r \\<notin> RID\\<^sub>V v; r' \\<notin> RID\\<^sub>V v\\<rbrakk>\n     \\<Longrightarrow> \\<R>\\<^sub>V (id(r := r', r' := r)) id v = v) &&&\n    (\\<lbrakk>l \\<notin> LID\\<^sub>V v; l' \\<notin> LID\\<^sub>V v\\<rbrakk>\n     \\<Longrightarrow> \\<R>\\<^sub>V id (id(l := l', l' := l)) v = v)", "by simp+"], ["", "lemma eliminate_swap_expr [simp, intro]:\n  \"r \\<notin> RID\\<^sub>E e \\<Longrightarrow> r' \\<notin> RID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E (id(r := r', r' := r)) id e = e\"\n  \"l \\<notin> LID\\<^sub>E e \\<Longrightarrow> l' \\<notin> LID\\<^sub>E e \\<Longrightarrow> \\<R>\\<^sub>E id (id(l := l', l' := l)) e = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r \\<notin> RID\\<^sub>E e; r' \\<notin> RID\\<^sub>E e\\<rbrakk>\n     \\<Longrightarrow> \\<R>\\<^sub>E (id(r := r', r' := r)) id e = e) &&&\n    (\\<lbrakk>l \\<notin> LID\\<^sub>E e; l' \\<notin> LID\\<^sub>E e\\<rbrakk>\n     \\<Longrightarrow> \\<R>\\<^sub>E id (id(l := l', l' := l)) e = e)", "by simp+"], ["", "lemma eliminate_swap_cntxt [simp, intro]:\n  \"r \\<notin> RID\\<^sub>C \\<E> \\<Longrightarrow> r' \\<notin> RID\\<^sub>C \\<E> \\<Longrightarrow> \\<R>\\<^sub>C (id(r := r', r' := r)) id \\<E> = \\<E>\"\n  \"l \\<notin> LID\\<^sub>C \\<E> \\<Longrightarrow> l' \\<notin> LID\\<^sub>C \\<E> \\<Longrightarrow> \\<R>\\<^sub>C id (id(l := l', l' := l)) \\<E> = \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r \\<notin> RID\\<^sub>C \\<E>;\n      r' \\<notin> RID\\<^sub>C \\<E>\\<rbrakk>\n     \\<Longrightarrow> \\<R>\\<^sub>C (id(r := r', r' := r)) id \\<E> =\n                       \\<E>) &&&\n    (\\<lbrakk>l \\<notin> LID\\<^sub>C \\<E>;\n      l' \\<notin> LID\\<^sub>C \\<E>\\<rbrakk>\n     \\<Longrightarrow> \\<R>\\<^sub>C id (id(l := l', l' := l)) \\<E> = \\<E>)", "by simp+"], ["", "lemma eliminate_swap_store_rid [simp, intro]:\n  \"r \\<notin> RID\\<^sub>S \\<sigma> \\<Longrightarrow> r' \\<notin> RID\\<^sub>S \\<sigma> \\<Longrightarrow> \\<R>\\<^sub>S (id(r := r', r' := r)) id \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<notin> RID\\<^sub>S \\<sigma>;\n     r' \\<notin> RID\\<^sub>S \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<R>\\<^sub>S (id(r := r', r' := r)) id \\<sigma> =\n                      \\<sigma>", "by (rule \\<R>\\<^sub>SI) (auto simp add: swap_bij RID\\<^sub>S_def domIff ranI)"], ["", "lemma eliminate_swap_store_lid [simp, intro]:\n  \"l \\<notin> LID\\<^sub>S \\<sigma> \\<Longrightarrow> l' \\<notin> LID\\<^sub>S \\<sigma> \\<Longrightarrow> \\<R>\\<^sub>S id (id(l := l', l' := l)) \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<notin> LID\\<^sub>S \\<sigma>;\n     l' \\<notin> LID\\<^sub>S \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<R>\\<^sub>S id (id(l := l', l' := l)) \\<sigma> =\n                      \\<sigma>", "by (rule \\<R>\\<^sub>SI) (auto simp add: swap_bij LID\\<^sub>S_def domIff ranI)"], ["", "lemma eliminate_swap_global_rid [simp, intro]:\n  \"r \\<notin> RID\\<^sub>G s \\<Longrightarrow> r' \\<notin> RID\\<^sub>G s \\<Longrightarrow> \\<R>\\<^sub>G (id(r := r', r' := r)) id s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<notin> RID\\<^sub>G s; r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n    \\<Longrightarrow> \\<R>\\<^sub>G (id(r := r', r' := r)) id s = s", "by (rule \\<R>\\<^sub>GI[OF swap_bij], ((rule sym, auto)[1])+)"], ["", "lemma eliminate_swap_global_lid [simp, intro]:\n  \"l \\<notin> LID\\<^sub>G s \\<Longrightarrow> l' \\<notin> LID\\<^sub>G s \\<Longrightarrow> \\<R>\\<^sub>G id (id(l := l', l' := l)) s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<notin> LID\\<^sub>G s; l' \\<notin> LID\\<^sub>G s\\<rbrakk>\n    \\<Longrightarrow> \\<R>\\<^sub>G id (id(l := l', l' := l)) s = s", "by (rule \\<R>\\<^sub>GI) (auto simp add: ID_distr_global_conditional)"], ["", "end"]]}