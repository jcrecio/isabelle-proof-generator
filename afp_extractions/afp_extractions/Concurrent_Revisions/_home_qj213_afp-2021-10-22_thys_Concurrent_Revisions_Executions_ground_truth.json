{"file_name": "/home/qj213/afp-2021-10-22/thys/Concurrent_Revisions/Executions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Concurrent_Revisions", "problem_names": ["lemma valid_stepI [intro]:\n  \"revision_step r s s' \\<Longrightarrow> s \\<leadsto> s'\"", "lemma valid_stepE [dest]:\n  \"s \\<leadsto> s' \\<Longrightarrow> \\<exists>r. revision_step r s s'\"", "lemma refl_rewritesI [intro]: \"s \\<leadsto> s' \\<Longrightarrow> s \\<leadsto>\\<^sup>= s'\"", "lemma inductive_invariantI [intro]:\n  \"(\\<And>s. initial_state s \\<Longrightarrow> P s) \\<Longrightarrow> (\\<And>s s'. s \\<leadsto> s' \\<Longrightarrow> P s \\<Longrightarrow> P s') \\<Longrightarrow> inductive_invariant P\"", "lemma inductive_invariant_is_execution_invariant: \"reachable s \\<Longrightarrow> inductive_invariant P \\<Longrightarrow> P s\"", "lemma nice_ind_inv_is_inductive_invariant: \"inductive_invariant (\\<lambda>s. \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s)\"", "lemma transition_relations_equivalent: \"reachable s \\<Longrightarrow> revision_step r s s' = revision_step_relaxed r s s'\"", "lemma finite_occurrences_val_expr [simp]:\n  fixes \n    v :: \"('r,'l,'v) val\" and\n    e :: \"('r,'l,'v) expr\"\n  shows\n  \"finite (RID\\<^sub>V v)\"\n  \"finite (RID\\<^sub>E e)\"\n  \"finite (LID\\<^sub>V v)\"\n  \"finite (LID\\<^sub>E e)\"", "lemma store_finite_upd [intro]:\n  \"finite (RID\\<^sub>S \\<tau>) \\<Longrightarrow> finite (RID\\<^sub>S (\\<tau>(l := None)))\" \n  \"finite (LID\\<^sub>S \\<tau>) \\<Longrightarrow> finite (LID\\<^sub>S (\\<tau>(l := None)))\"", "lemma finite_state_imp_restriction_finite [intro]: \n  \"finite (RID\\<^sub>G s) \\<Longrightarrow> finite (RID\\<^sub>G (s(r := None)))\"\n  \"finite (LID\\<^sub>G s) \\<Longrightarrow> finite (LID\\<^sub>G (s(r := None)))\"", "lemma local_state_of_finite_restricted_global_state_is_finite [intro]: \n  \"s r' = Some ls \\<Longrightarrow> finite (RID\\<^sub>G (s(r := None))) \\<Longrightarrow> r \\<noteq> r' \\<Longrightarrow> finite (RID\\<^sub>L ls)\"\n  \"s r' = Some ls \\<Longrightarrow> finite (LID\\<^sub>G (s(r := None))) \\<Longrightarrow> r \\<noteq> r' \\<Longrightarrow> finite (LID\\<^sub>L ls)\"", "lemma empty_map_finite [simp]: \n  \"finite (RID\\<^sub>S \\<epsilon>)\" \n  \"finite (LID\\<^sub>S \\<epsilon>)\" \n  \"finite (RID\\<^sub>G \\<epsilon>)\" \n  \"finite (LID\\<^sub>G \\<epsilon>)\"", "lemma finite_combination [intro]:\n  \"finite (RID\\<^sub>S \\<sigma>) \\<Longrightarrow> finite (RID\\<^sub>S \\<tau>) \\<Longrightarrow> finite (RID\\<^sub>S (\\<sigma>;;\\<tau>))\"\n  \"finite (LID\\<^sub>S \\<sigma>) \\<Longrightarrow> finite (LID\\<^sub>S \\<tau>) \\<Longrightarrow> finite (LID\\<^sub>S (\\<sigma>;;\\<tau>))\"", "lemma RID\\<^sub>G_finite_invariant:\n  assumes\n    step: \"revision_step r s s'\" and\n    fin: \"finite (RID\\<^sub>G s)\"\nshows\n    \"finite (RID\\<^sub>G s')\"", "lemma RID\\<^sub>L_finite_invariant:\n  assumes\n    step: \"revision_step r s s'\" and\n    fin: \"finite (LID\\<^sub>G s)\"\nshows\n    \"finite (LID\\<^sub>G s')\"", "lemma reachable_imp_identifiers_finite:\n  assumes reach: \"reachable s\"\n  shows \n    \"finite (RID\\<^sub>G s)\"\n    \"finite (LID\\<^sub>G s)\"", "lemma reachable_imp_identifiers_available:\n  assumes \n    \"reachable (s :: ('r,'l,'v) global_state)\"\n  shows \n    \"infinite (UNIV :: 'r set) \\<Longrightarrow> \\<exists>r. r \\<notin> RID\\<^sub>G s\"\n    \"infinite (UNIV :: 'l set) \\<Longrightarrow> \\<exists>l. l \\<notin> LID\\<^sub>G s\"", "lemma initial_state_reachable:\n  assumes \"program_expr e\"\n  shows \"reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>,\\<epsilon>,e)))\"", "lemma reachability_closed_under_execution_step:\n  assumes\n    reach: \"reachable s\" and\n    step: \"revision_step r s s'\"\n  shows \"reachable s'\"", "lemma reachability_closed_under_execution: \"reachable s \\<Longrightarrow> s \\<leadsto>\\<^sup>* s' \\<Longrightarrow> reachable s'\""], "translations": [["", "lemma valid_stepI [intro]:\n  \"revision_step r s s' \\<Longrightarrow> s \\<leadsto> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revision_step r s s' \\<Longrightarrow> s \\<leadsto> s'", "using steps_def"], ["proof (prove)\nusing this:\n  [\\<leadsto>] = {(s, s') |s s'. \\<exists>r. revision_step r s s'}\n\ngoal (1 subgoal):\n 1. revision_step r s s' \\<Longrightarrow> s \\<leadsto> s'", "by auto"], ["", "lemma valid_stepE [dest]:\n  \"s \\<leadsto> s' \\<Longrightarrow> \\<exists>r. revision_step r s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<leadsto> s' \\<Longrightarrow> \\<exists>r. revision_step r s s'", "by (simp add: steps_def)"], ["", "subsubsection Closures"], ["", "abbreviation refl_trans_step_rel :: \"('r,'l,'v) global_state \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> bool\"(infix \"\\<leadsto>\\<^sup>*\" 60) where\n  \"s \\<leadsto>\\<^sup>* s' \\<equiv> (s,s') \\<in> [\\<leadsto>]\\<^sup>*\""], ["", "abbreviation refl_step_rel :: \"('r,'l,'v) global_state \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> bool\" (infix \"\\<leadsto>\\<^sup>=\" 60) where\n  \"s \\<leadsto>\\<^sup>= s' \\<equiv> (s,s') \\<in> [\\<leadsto>]\\<^sup>=\""], ["", "lemma refl_rewritesI [intro]: \"s \\<leadsto> s' \\<Longrightarrow> s \\<leadsto>\\<^sup>= s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<leadsto> s' \\<Longrightarrow> (s, s') \\<in> [\\<leadsto>]\\<^sup>=", "by blast"], ["", "subsection Properties"], ["", "abbreviation program_expr :: \"('r,'l,'v) expr \\<Rightarrow> bool\" where\n  \"program_expr e \\<equiv> LID\\<^sub>E e = {} \\<and> RID\\<^sub>E e = {}\""], ["", "abbreviation initializes :: \"('r,'l,'v) global_state \\<Rightarrow> ('r,'l,'v) expr \\<Rightarrow> bool\" where\n  \"initializes s e \\<equiv> \\<exists>r. s = (\\<epsilon>(r \\<mapsto>(\\<epsilon>,\\<epsilon>,e))) \\<and> program_expr e\""], ["", "abbreviation initial_state :: \"('r,'l,'v) global_state \\<Rightarrow> bool\" where\n  \"initial_state s \\<equiv> \\<exists>e. initializes s e\""], ["", "definition execution :: \"('r,'l,'v) expr \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> bool\" where\n  \"execution e s s' \\<equiv> initializes s e \\<and> s \\<leadsto>\\<^sup>* s'\""], ["", "definition maximal_execution :: \"('r,'l,'v) expr \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> bool\" where\n  \"maximal_execution e s s' \\<equiv> execution e s s' \\<and> (\\<nexists>s''. s' \\<leadsto> s'')\""], ["", "definition reachable :: \"('r,'l,'v) global_state \\<Rightarrow> bool\" where\n  \"reachable s \\<equiv> \\<exists>e s'. execution e s' s\""], ["", "definition terminates_in :: \"('r,'l,'v) expr \\<Rightarrow> ('r,'l,'v) global_state \\<Rightarrow> bool\" (infix \"\\<down>\" 60) where\n  \"e \\<down> s' \\<equiv> \\<exists>s. maximal_execution e s s'\""], ["", "subsection Invariants"], ["", "subsubsection \\<open>Inductive invariance\\<close>"], ["", "definition inductive_invariant :: \"(('r,'l,'v) global_state \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"inductive_invariant P \\<equiv> (\\<forall>s. initial_state s \\<longrightarrow> P s) \\<and> (\\<forall>s s'. s \\<leadsto> s' \\<longrightarrow> P s \\<longrightarrow> P s')\""], ["", "lemma inductive_invariantI [intro]:\n  \"(\\<And>s. initial_state s \\<Longrightarrow> P s) \\<Longrightarrow> (\\<And>s s'. s \\<leadsto> s' \\<Longrightarrow> P s \\<Longrightarrow> P s') \\<Longrightarrow> inductive_invariant P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                \\<exists>e r.\n                   s = \\<epsilon>(r \\<mapsto>\n                   (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                   program_expr e \\<Longrightarrow>\n                P s;\n     \\<And>s s'.\n        \\<lbrakk>s \\<leadsto> s'; P s\\<rbrakk>\n        \\<Longrightarrow> P s'\\<rbrakk>\n    \\<Longrightarrow> inductive_invariant P", "by (auto simp add: inductive_invariant_def)"], ["", "lemma inductive_invariant_is_execution_invariant: \"reachable s \\<Longrightarrow> inductive_invariant P \\<Longrightarrow> P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s; inductive_invariant P\\<rbrakk>\n    \\<Longrightarrow> P s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s; inductive_invariant P\\<rbrakk>\n    \\<Longrightarrow> P s", "assume reach: \"reachable s\" and ind_inv: \"inductive_invariant P\""], ["proof (state)\nthis:\n  reachable s\n  inductive_invariant P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s; inductive_invariant P\\<rbrakk>\n    \\<Longrightarrow> P s", "then"], ["proof (chain)\npicking this:\n  reachable s\n  inductive_invariant P", "obtain e initial n where initializes: \"initializes initial e\" and trace: \"(initial,s) \\<in> [\\<leadsto>]^^n\""], ["proof (prove)\nusing this:\n  reachable s\n  inductive_invariant P\n\ngoal (1 subgoal):\n 1. (\\<And>initial e n.\n        \\<lbrakk>\\<exists>r.\n                    initial = \\<epsilon>(r \\<mapsto>\n                    (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                    program_expr e;\n         (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis execution_def reachable_def rtrancl_power)"], ["proof (state)\nthis:\n  \\<exists>r.\n     initial = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n  (initial, s) \\<in> [\\<leadsto>] ^^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s; inductive_invariant P\\<rbrakk>\n    \\<Longrightarrow> P s", "thus \"P s\""], ["proof (prove)\nusing this:\n  \\<exists>r.\n     initial = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n  (initial, s) \\<in> [\\<leadsto>] ^^ n\n\ngoal (1 subgoal):\n 1. P s", "proof (induct n arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<exists>r.\n                   initial = \\<epsilon>(r \\<mapsto>\n                   (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                   program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ 0\\<rbrakk>\n       \\<Longrightarrow> P s\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "case 0"], ["proof (state)\nthis:\n  \\<exists>r.\n     initial = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n  (initial, s) \\<in> [\\<leadsto>] ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<exists>r.\n                   initial = \\<epsilon>(r \\<mapsto>\n                   (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                   program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ 0\\<rbrakk>\n       \\<Longrightarrow> P s\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "have \"initial = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial = s", "using \"0.prems\"(2)"], ["proof (prove)\nusing this:\n  (initial, s) \\<in> [\\<leadsto>] ^^ 0\n\ngoal (1 subgoal):\n 1. initial = s", "by auto"], ["proof (state)\nthis:\n  initial = s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<exists>r.\n                   initial = \\<epsilon>(r \\<mapsto>\n                   (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                   program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ 0\\<rbrakk>\n       \\<Longrightarrow> P s\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "hence \"initial_state s\""], ["proof (prove)\nusing this:\n  initial = s\n\ngoal (1 subgoal):\n 1. \\<exists>e r.\n       s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n       program_expr e", "using initializes"], ["proof (prove)\nusing this:\n  initial = s\n  \\<exists>r.\n     initial = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n\ngoal (1 subgoal):\n 1. \\<exists>e r.\n       s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n       program_expr e", "by blast"], ["proof (state)\nthis:\n  \\<exists>e r.\n     s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<exists>r.\n                   initial = \\<epsilon>(r \\<mapsto>\n                   (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                   program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ 0\\<rbrakk>\n       \\<Longrightarrow> P s\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "then"], ["proof (chain)\npicking this:\n  \\<exists>e r.\n     s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>e r.\n     s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n\ngoal (1 subgoal):\n 1. P s", "using ind_inv inductive_invariant_def"], ["proof (prove)\nusing this:\n  \\<exists>e r.\n     s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n  inductive_invariant P\n  inductive_invariant ?P \\<equiv>\n  (\\<forall>s.\n      (\\<exists>e r.\n          s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n          program_expr e) \\<longrightarrow>\n      ?P s) \\<and>\n  (\\<forall>s s'.\n      s \\<leadsto> s' \\<longrightarrow> ?P s \\<longrightarrow> ?P s')\n\ngoal (1 subgoal):\n 1. P s", "by auto"], ["proof (state)\nthis:\n  P s\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>r.\n              initial = \\<epsilon>(r \\<mapsto>\n              (\\<epsilon>, \\<epsilon>, e)) \\<and>\n              program_expr e;\n   (initial, ?s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n  \\<Longrightarrow> P ?s\n  \\<exists>r.\n     initial = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n  (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "obtain s' where nfold: \"(initial, s') \\<in> [\\<leadsto>]^^n\" and step: \"s' \\<leadsto> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>(initial, s') \\<in> [\\<leadsto>] ^^ n;\n         s' \\<leadsto> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.prems(2)"], ["proof (prove)\nusing this:\n  (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>(initial, s') \\<in> [\\<leadsto>] ^^ n;\n         s' \\<leadsto> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (initial, s') \\<in> [\\<leadsto>] ^^ n\n  s' \\<leadsto> s\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "have \"P s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s'", "using Suc(1) nfold initializes"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>r.\n              initial = \\<epsilon>(r \\<mapsto>\n              (\\<epsilon>, \\<epsilon>, e)) \\<and>\n              program_expr e;\n   (initial, ?s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n  \\<Longrightarrow> P ?s\n  (initial, s') \\<in> [\\<leadsto>] ^^ n\n  \\<exists>r.\n     initial = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n\ngoal (1 subgoal):\n 1. P s'", "by blast"], ["proof (state)\nthis:\n  P s'\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<exists>r.\n                               initial = \\<epsilon>(r \\<mapsto>\n                               (\\<epsilon>, \\<epsilon>, e)) \\<and>\n                               program_expr e;\n                    (initial, s) \\<in> [\\<leadsto>] ^^ n\\<rbrakk>\n                   \\<Longrightarrow> P s;\n        \\<exists>r.\n           initial = \\<epsilon>(r \\<mapsto>\n           (\\<epsilon>, \\<epsilon>, e)) \\<and>\n           program_expr e;\n        (initial, s) \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> P s", "then"], ["proof (chain)\npicking this:\n  P s'", "show ?case"], ["proof (prove)\nusing this:\n  P s'\n\ngoal (1 subgoal):\n 1. P s", "using ind_inv step inductive_invariant_def"], ["proof (prove)\nusing this:\n  P s'\n  inductive_invariant P\n  s' \\<leadsto> s\n  inductive_invariant ?P \\<equiv>\n  (\\<forall>s.\n      (\\<exists>e r.\n          s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n          program_expr e) \\<longrightarrow>\n      ?P s) \\<and>\n  (\\<forall>s s'.\n      s \\<leadsto> s' \\<longrightarrow> ?P s \\<longrightarrow> ?P s')\n\ngoal (1 subgoal):\n 1. P s", "by auto"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Subsumption is invariant\\<close>"], ["", "lemma nice_ind_inv_is_inductive_invariant: \"inductive_invariant (\\<lambda>s. \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inductive_invariant (\\<lambda>s. \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s)", "proof (rule inductive_invariantI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<exists>e r.\n          s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n          program_expr e \\<Longrightarrow>\n       \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<leadsto> s';\n        \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<^sub>G s' \\<and> \\<A>\\<^sub>G s'", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<exists>e r.\n          s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n          program_expr e \\<Longrightarrow>\n       \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<leadsto> s';\n        \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<^sub>G s' \\<and> \\<A>\\<^sub>G s'", "assume \"initial_state s\""], ["proof (state)\nthis:\n  \\<exists>e r.\n     s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<exists>e r.\n          s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n          program_expr e \\<Longrightarrow>\n       \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<leadsto> s';\n        \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<^sub>G s' \\<and> \\<A>\\<^sub>G s'", "then"], ["proof (chain)\npicking this:\n  \\<exists>e r.\n     s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e", "obtain e r where s: \"s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\" and prog_expr_e: \"program_expr e\""], ["proof (prove)\nusing this:\n  \\<exists>e r.\n     s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n\ngoal (1 subgoal):\n 1. (\\<And>r e.\n        \\<lbrakk>s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e));\n         program_expr e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n  program_expr e\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<exists>e r.\n          s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n          program_expr e \\<Longrightarrow>\n       \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<leadsto> s';\n        \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<^sub>G s' \\<and> \\<A>\\<^sub>G s'", "show \"\\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<S>\\<^sub>G s\n 2. \\<A>\\<^sub>G s", "show \"\\<S>\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<^sub>G s", "proof (rule domains_subsume_globallyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "fix r' \\<sigma>' \\<tau>' e'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "assume s_r': \"s r' = Some (\\<sigma>',\\<tau>',e')\""], ["proof (state)\nthis:\n  s r' = Some (\\<sigma>', \\<tau>', e')\n\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "have \"r' = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' = r", "using s s_r' prog_expr_e"], ["proof (prove)\nusing this:\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n  s r' = Some (\\<sigma>', \\<tau>', e')\n  program_expr e\n\ngoal (1 subgoal):\n 1. r' = r", "by (meson domI domIff fun_upd_other)"], ["proof (state)\nthis:\n  r' = r\n\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "hence \"LID\\<^sub>L (\\<sigma>',\\<tau>',e') = LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e)\""], ["proof (prove)\nusing this:\n  r' = r\n\ngoal (1 subgoal):\n 1. LID\\<^sub>L (\\<sigma>', \\<tau>', e') =\n    LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e)", "using s s_r'"], ["proof (prove)\nusing this:\n  r' = r\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n  s r' = Some (\\<sigma>', \\<tau>', e')\n\ngoal (1 subgoal):\n 1. LID\\<^sub>L (\\<sigma>', \\<tau>', e') =\n    LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e)", "by auto"], ["proof (state)\nthis:\n  LID\\<^sub>L (\\<sigma>', \\<tau>', e') =\n  LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e)\n\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "also"], ["proof (state)\nthis:\n  LID\\<^sub>L (\\<sigma>', \\<tau>', e') =\n  LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e)\n\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "have \"... = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e) = {}", "using prog_expr_e"], ["proof (prove)\nusing this:\n  program_expr e\n\ngoal (1 subgoal):\n 1. LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e) = {}", "by auto"], ["proof (state)\nthis:\n  LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e) = {}\n\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "also"], ["proof (state)\nthis:\n  LID\\<^sub>L (\\<epsilon>, \\<epsilon>, e) = {}\n\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "have \"... = dom \\<sigma>' \\<union> dom \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = dom \\<sigma>' \\<union> dom \\<tau>'", "using \\<open>r' = r\\<close> s s_r'"], ["proof (prove)\nusing this:\n  r' = r\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n  s r' = Some (\\<sigma>', \\<tau>', e')\n\ngoal (1 subgoal):\n 1. {} = dom \\<sigma>' \\<union> dom \\<tau>'", "by auto"], ["proof (state)\nthis:\n  {} = dom \\<sigma>' \\<union> dom \\<tau>'\n\ngoal (1 subgoal):\n 1. \\<And>r \\<sigma> \\<tau> e.\n       s r = Some (\\<sigma>, \\<tau>, e) \\<Longrightarrow>\n       \\<S> (\\<sigma>, \\<tau>, e)", "finally"], ["proof (chain)\npicking this:\n  LID\\<^sub>L (\\<sigma>', \\<tau>', e') = dom \\<sigma>' \\<union> dom \\<tau>'", "show \"\\<S> (\\<sigma>', \\<tau>', e')\""], ["proof (prove)\nusing this:\n  LID\\<^sub>L (\\<sigma>', \\<tau>', e') = dom \\<sigma>' \\<union> dom \\<tau>'\n\ngoal (1 subgoal):\n 1. \\<S> (\\<sigma>', \\<tau>', e')", "by (simp add: domains_subsume_def)"], ["proof (state)\nthis:\n  \\<S> (\\<sigma>', \\<tau>', e')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<S>\\<^sub>G s\n\ngoal (1 subgoal):\n 1. \\<A>\\<^sub>G s", "show \"\\<A>\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A>\\<^sub>G s", "proof (rule subsumes_accessible_globallyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>1 \\<sigma>\\<^sub>1 \\<tau>\\<^sub>1 e\\<^sub>1 r\\<^sub>2\n       \\<sigma>\\<^sub>2 \\<tau>\\<^sub>2 e\\<^sub>2.\n       \\<lbrakk>s r\\<^sub>1 =\n                Some (\\<sigma>\\<^sub>1, \\<tau>\\<^sub>1, e\\<^sub>1);\n        s r\\<^sub>2 =\n        Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<A> r\\<^sub>1 r\\<^sub>2 s", "fix r\\<^sub>1 \\<sigma>\\<^sub>1 \\<tau>\\<^sub>1 e\\<^sub>1 r\\<^sub>2 \\<sigma>\\<^sub>2 \\<tau>\\<^sub>2 e\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>1 \\<sigma>\\<^sub>1 \\<tau>\\<^sub>1 e\\<^sub>1 r\\<^sub>2\n       \\<sigma>\\<^sub>2 \\<tau>\\<^sub>2 e\\<^sub>2.\n       \\<lbrakk>s r\\<^sub>1 =\n                Some (\\<sigma>\\<^sub>1, \\<tau>\\<^sub>1, e\\<^sub>1);\n        s r\\<^sub>2 =\n        Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<A> r\\<^sub>1 r\\<^sub>2 s", "assume s_r1: \"s r\\<^sub>1 = Some (\\<sigma>\\<^sub>1, \\<tau>\\<^sub>1, e\\<^sub>1)\" and s_r2: \"s r\\<^sub>2 = Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\""], ["proof (state)\nthis:\n  s r\\<^sub>1 = Some (\\<sigma>\\<^sub>1, \\<tau>\\<^sub>1, e\\<^sub>1)\n  s r\\<^sub>2 = Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>1 \\<sigma>\\<^sub>1 \\<tau>\\<^sub>1 e\\<^sub>1 r\\<^sub>2\n       \\<sigma>\\<^sub>2 \\<tau>\\<^sub>2 e\\<^sub>2.\n       \\<lbrakk>s r\\<^sub>1 =\n                Some (\\<sigma>\\<^sub>1, \\<tau>\\<^sub>1, e\\<^sub>1);\n        s r\\<^sub>2 =\n        Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<A> r\\<^sub>1 r\\<^sub>2 s", "have \"r\\<^sub>2 = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sub>2 = r", "using s s_r2 prog_expr_e"], ["proof (prove)\nusing this:\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n  s r\\<^sub>2 = Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\n  program_expr e\n\ngoal (1 subgoal):\n 1. r\\<^sub>2 = r", "by (meson domI domIff fun_upd_other)"], ["proof (state)\nthis:\n  r\\<^sub>2 = r\n\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>1 \\<sigma>\\<^sub>1 \\<tau>\\<^sub>1 e\\<^sub>1 r\\<^sub>2\n       \\<sigma>\\<^sub>2 \\<tau>\\<^sub>2 e\\<^sub>2.\n       \\<lbrakk>s r\\<^sub>1 =\n                Some (\\<sigma>\\<^sub>1, \\<tau>\\<^sub>1, e\\<^sub>1);\n        s r\\<^sub>2 =\n        Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<A> r\\<^sub>1 r\\<^sub>2 s", "hence \"\\<sigma>\\<^sub>2 = \\<epsilon>\""], ["proof (prove)\nusing this:\n  r\\<^sub>2 = r\n\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>2 = \\<epsilon>", "using s s_r2"], ["proof (prove)\nusing this:\n  r\\<^sub>2 = r\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n  s r\\<^sub>2 = Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>2 = \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>2 = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>1 \\<sigma>\\<^sub>1 \\<tau>\\<^sub>1 e\\<^sub>1 r\\<^sub>2\n       \\<sigma>\\<^sub>2 \\<tau>\\<^sub>2 e\\<^sub>2.\n       \\<lbrakk>s r\\<^sub>1 =\n                Some (\\<sigma>\\<^sub>1, \\<tau>\\<^sub>1, e\\<^sub>1);\n        s r\\<^sub>2 =\n        Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<A> r\\<^sub>1 r\\<^sub>2 s", "hence \"LID\\<^sub>S \\<sigma>\\<^sub>2 = {}\""], ["proof (prove)\nusing this:\n  \\<sigma>\\<^sub>2 = \\<epsilon>\n\ngoal (1 subgoal):\n 1. LID\\<^sub>S \\<sigma>\\<^sub>2 = {}", "by auto"], ["proof (state)\nthis:\n  LID\\<^sub>S \\<sigma>\\<^sub>2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>1 \\<sigma>\\<^sub>1 \\<tau>\\<^sub>1 e\\<^sub>1 r\\<^sub>2\n       \\<sigma>\\<^sub>2 \\<tau>\\<^sub>2 e\\<^sub>2.\n       \\<lbrakk>s r\\<^sub>1 =\n                Some (\\<sigma>\\<^sub>1, \\<tau>\\<^sub>1, e\\<^sub>1);\n        s r\\<^sub>2 =\n        Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<A> r\\<^sub>1 r\\<^sub>2 s", "thus \"\\<A> r\\<^sub>1 r\\<^sub>2 s\""], ["proof (prove)\nusing this:\n  LID\\<^sub>S \\<sigma>\\<^sub>2 = {}\n\ngoal (1 subgoal):\n 1. \\<A> r\\<^sub>1 r\\<^sub>2 s", "using s_r2"], ["proof (prove)\nusing this:\n  LID\\<^sub>S \\<sigma>\\<^sub>2 = {}\n  s r\\<^sub>2 = Some (\\<sigma>\\<^sub>2, \\<tau>\\<^sub>2, e\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<A> r\\<^sub>1 r\\<^sub>2 s", "by auto"], ["proof (state)\nthis:\n  \\<A> r\\<^sub>1 r\\<^sub>2 s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<A>\\<^sub>G s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<leadsto> s';\n        \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<^sub>G s' \\<and> \\<A>\\<^sub>G s'", "qed (use step_preserves_\\<S>\\<^sub>G_and_\\<A>\\<^sub>G in auto)"], ["", "corollary reachable_imp_\\<S>\\<^sub>G: \"reachable s \\<Longrightarrow> \\<S>\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable s \\<Longrightarrow> \\<S>\\<^sub>G s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable s \\<Longrightarrow> \\<S>\\<^sub>G s", "assume reach: \"reachable s\""], ["proof (state)\nthis:\n  reachable s\n\ngoal (1 subgoal):\n 1. reachable s \\<Longrightarrow> \\<S>\\<^sub>G s", "have \"\\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s", "by (rule inductive_invariant_is_execution_invariant[OF reach nice_ind_inv_is_inductive_invariant])"], ["proof (state)\nthis:\n  \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\n\ngoal (1 subgoal):\n 1. reachable s \\<Longrightarrow> \\<S>\\<^sub>G s", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<S>\\<^sub>G s \\<and> \\<A>\\<^sub>G s\n\ngoal (1 subgoal):\n 1. \\<S>\\<^sub>G s", "by auto"], ["proof (state)\nthis:\n  \\<S>\\<^sub>G s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transition_relations_equivalent: \"reachable s \\<Longrightarrow> revision_step r s s' = revision_step_relaxed r s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable s \\<Longrightarrow>\n    revision_step r s s' = revision_step_relaxed r s s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable s \\<Longrightarrow>\n    revision_step r s s' = revision_step_relaxed r s s'", "assume reach: \"reachable s\""], ["proof (state)\nthis:\n  reachable s\n\ngoal (1 subgoal):\n 1. reachable s \\<Longrightarrow>\n    revision_step r s s' = revision_step_relaxed r s s'", "have doms_sub_local: \"\\<S>\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<^sub>G s", "by (rule reachable_imp_\\<S>\\<^sub>G[OF reach])"], ["proof (state)\nthis:\n  \\<S>\\<^sub>G s\n\ngoal (1 subgoal):\n 1. reachable s \\<Longrightarrow>\n    revision_step r s s' = revision_step_relaxed r s s'", "show \"revision_step r s s' = revision_step_relaxed r s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revision_step r s s' = revision_step_relaxed r s s'", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. revision_step r s s' \\<Longrightarrow> revision_step_relaxed r s s'\n 2. revision_step_relaxed r s s' \\<Longrightarrow> revision_step r s s'", "assume step: \"revision_step r s s'\""], ["proof (state)\nthis:\n  revision_step r s s'\n\ngoal (2 subgoals):\n 1. revision_step r s s' \\<Longrightarrow> revision_step_relaxed r s s'\n 2. revision_step_relaxed r s s' \\<Longrightarrow> revision_step r s s'", "show \"revision_step_relaxed r s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revision_step_relaxed r s s'", "proof (use step in \\<open>induct rule: revision_stepE\\<close>)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'", "case (new \\<sigma> \\<tau> \\<E> v l)"], ["proof (state)\nthis:\n  s' = s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]))\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])\n  l \\<notin> LID\\<^sub>G s\n\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'", "have \"revision_step_relaxed r s (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revision_step_relaxed r s\n     (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))", "proof (rule revision_step_relaxed.new)"], ["proof (state)\ngoal (2 subgoals):\n 1. s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])\n 2. l \\<notin> \\<Union> {doms ls |ls. ls \\<in> ran s}", "show \"l \\<notin> \\<Union> { doms ls | ls. ls \\<in> ran s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<notin> \\<Union> {doms ls |ls. ls \\<in> ran s}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<in> \\<Union> {doms ls |ls. ls \\<in> ran s} \\<Longrightarrow> False", "assume \"l \\<in> \\<Union> { doms ls | ls. ls \\<in> ran s}\""], ["proof (state)\nthis:\n  l \\<in> \\<Union> {doms ls |ls. ls \\<in> ran s}\n\ngoal (1 subgoal):\n 1. l \\<in> \\<Union> {doms ls |ls. ls \\<in> ran s} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  l \\<in> \\<Union> {doms ls |ls. ls \\<in> ran s}", "obtain ls where in_ran: \"ls \\<in> ran s\" and in_doms: \"l \\<in> doms ls\""], ["proof (prove)\nusing this:\n  l \\<in> \\<Union> {doms ls |ls. ls \\<in> ran s}\n\ngoal (1 subgoal):\n 1. (\\<And>ls.\n        \\<lbrakk>ls \\<in> ran s; l \\<in> doms ls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ls \\<in> ran s\n  l \\<in> doms ls\n\ngoal (1 subgoal):\n 1. l \\<in> \\<Union> {doms ls |ls. ls \\<in> ran s} \\<Longrightarrow> False", "from in_doms"], ["proof (chain)\npicking this:\n  l \\<in> doms ls", "have \"l \\<in> LID\\<^sub>L ls\""], ["proof (prove)\nusing this:\n  l \\<in> doms ls\n\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>L ls", "by (cases ls) auto"], ["proof (state)\nthis:\n  l \\<in> LID\\<^sub>L ls\n\ngoal (1 subgoal):\n 1. l \\<in> \\<Union> {doms ls |ls. ls \\<in> ran s} \\<Longrightarrow> False", "have \"l \\<in> LID\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s", "have \"ls \\<in> {ls. \\<exists>r. s r = Some ls}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> {ls. \\<exists>r. s r = Some ls}", "by (metis (full_types) in_ran ran_def)"], ["proof (state)\nthis:\n  ls \\<in> {ls. \\<exists>r. s r = Some ls}\n\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s", "then"], ["proof (chain)\npicking this:\n  ls \\<in> {ls. \\<exists>r. s r = Some ls}", "show ?thesis"], ["proof (prove)\nusing this:\n  ls \\<in> {ls. \\<exists>r. s r = Some ls}\n\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s", "using \\<open>l \\<in> LID\\<^sub>L ls\\<close>"], ["proof (prove)\nusing this:\n  ls \\<in> {ls. \\<exists>r. s r = Some ls}\n  l \\<in> LID\\<^sub>L ls\n\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s", "by blast"], ["proof (state)\nthis:\n  l \\<in> LID\\<^sub>G s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<in> LID\\<^sub>G s\n\ngoal (1 subgoal):\n 1. l \\<in> \\<Union> {doms ls |ls. ls \\<in> ran s} \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  l \\<in> LID\\<^sub>G s\n\ngoal (1 subgoal):\n 1. False", "using new"], ["proof (prove)\nusing this:\n  l \\<in> LID\\<^sub>G s\n  s' = s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]))\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])\n  l \\<notin> LID\\<^sub>G s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<notin> \\<Union> {doms ls |ls. ls \\<in> ran s}\n\ngoal (1 subgoal):\n 1. s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])", "qed (simp add: new.hyps(2))"], ["proof (state)\nthis:\n  revision_step_relaxed r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))\n\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  revision_step_relaxed r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))\n\ngoal (1 subgoal):\n 1. revision_step_relaxed r s s'", "using new.hyps(1)"], ["proof (prove)\nusing this:\n  revision_step_relaxed r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))\n  s' = s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]))\n\ngoal (1 subgoal):\n 1. revision_step_relaxed r s s'", "by blast"], ["proof (state)\nthis:\n  revision_step_relaxed r s s'\n\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step_relaxed r s s'", "qed (use revision_step_relaxed.intros in simp)+"], ["proof (state)\nthis:\n  revision_step_relaxed r s s'\n\ngoal (1 subgoal):\n 1. revision_step_relaxed r s s' \\<Longrightarrow> revision_step r s s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. revision_step_relaxed r s s' \\<Longrightarrow> revision_step r s s'", "assume step: \"revision_step_relaxed r s s'\""], ["proof (state)\nthis:\n  revision_step_relaxed r s s'\n\ngoal (1 subgoal):\n 1. revision_step_relaxed r s s' \\<Longrightarrow> revision_step r s s'", "show \"revision_step r s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revision_step r s s'", "proof (use step in \\<open>induct rule: revision_step_relaxedE\\<close>)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        \\<forall>x.\n           (\\<forall>a aa.\n               x = dom a \\<union> dom aa \\<longrightarrow>\n               (\\<forall>b. (a, aa, b) \\<notin> ran s)) \\<or>\n           l \\<notin> x\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "case (new \\<sigma> \\<tau> \\<E> v l)"], ["proof (state)\nthis:\n  s' = s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]))\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])\n  \\<forall>x.\n     (\\<forall>a aa.\n         x = dom a \\<union> dom aa \\<longrightarrow>\n         (\\<forall>b. (a, aa, b) \\<notin> ran s)) \\<or>\n     l \\<notin> x\n\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        \\<forall>x.\n           (\\<forall>a aa.\n               x = dom a \\<union> dom aa \\<longrightarrow>\n               (\\<forall>b. (a, aa, b) \\<notin> ran s)) \\<or>\n           l \\<notin> x\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "have \"revision_step r s (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revision_step r s\n     (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))", "proof (rule revision_step.new)"], ["proof (state)\ngoal (2 subgoals):\n 1. s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])\n 2. l \\<notin> LID\\<^sub>G s", "show \"s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])", "by (simp add: new.hyps(2))"], ["proof (state)\nthis:\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)])\n\ngoal (1 subgoal):\n 1. l \\<notin> LID\\<^sub>G s", "show \"l \\<notin> LID\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<notin> LID\\<^sub>G s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s \\<Longrightarrow> False", "assume \"l \\<in> LID\\<^sub>G s\""], ["proof (state)\nthis:\n  l \\<in> LID\\<^sub>G s\n\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  l \\<in> LID\\<^sub>G s", "obtain r' \\<sigma>' \\<tau>' e' where s_r': \"s r' = Some (\\<sigma>',\\<tau>',e')\" and l_in_local: \"l \\<in> LID\\<^sub>L (\\<sigma>',\\<tau>',e')\""], ["proof (prove)\nusing this:\n  l \\<in> LID\\<^sub>G s\n\ngoal (1 subgoal):\n 1. (\\<And>r' \\<sigma>' \\<tau>' e'.\n        \\<lbrakk>s r' = Some (\\<sigma>', \\<tau>', e');\n         l \\<in> LID\\<^sub>L (\\<sigma>', \\<tau>', e')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s r' = Some (\\<sigma>', \\<tau>', e')\n  l \\<in> LID\\<^sub>L (\\<sigma>', \\<tau>', e')\n\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s \\<Longrightarrow> False", "hence \"l \\<in> dom \\<sigma>' \\<union> dom \\<tau>'\""], ["proof (prove)\nusing this:\n  s r' = Some (\\<sigma>', \\<tau>', e')\n  l \\<in> LID\\<^sub>L (\\<sigma>', \\<tau>', e')\n\ngoal (1 subgoal):\n 1. l \\<in> dom \\<sigma>' \\<union> dom \\<tau>'", "by (metis (no_types, lifting) domains_subsume_def domains_subsume_globally_def doms.simps doms_sub_local rev_subsetD)"], ["proof (state)\nthis:\n  l \\<in> dom \\<sigma>' \\<union> dom \\<tau>'\n\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>G s \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  l \\<in> dom \\<sigma>' \\<union> dom \\<tau>'\n\ngoal (1 subgoal):\n 1. False", "by (meson s_r' new.hyps(3) ranI)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<notin> LID\\<^sub>G s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  revision_step r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))\n\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        \\<forall>x.\n           (\\<forall>a aa.\n               x = dom a \\<union> dom aa \\<longrightarrow>\n               (\\<forall>b. (a, aa, b) \\<notin> ran s)) \\<or>\n           l \\<notin> x\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "then"], ["proof (chain)\npicking this:\n  revision_step r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))", "show ?case"], ["proof (prove)\nusing this:\n  revision_step r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))\n\ngoal (1 subgoal):\n 1. revision_step r s s'", "using new.hyps(1)"], ["proof (prove)\nusing this:\n  revision_step r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)])))\n  s' = s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]))\n\ngoal (1 subgoal):\n 1. revision_step r s s'", "by blast"], ["proof (state)\nthis:\n  revision_step r s s'\n\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "case (get \\<sigma> \\<tau> \\<E> l)"], ["proof (state)\nthis:\n  s' = s(r \\<mapsto>\n  (\\<sigma>, \\<tau>,\n   \\<E> [VE (the (if \\<tau> l = None then \\<sigma> l else \\<tau> l))]))\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\n\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "have \"revision_step r s (s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (the ((\\<sigma>;;\\<tau>) l))])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revision_step r s\n     (s(r \\<mapsto>\n      (\\<sigma>, \\<tau>, \\<E> [VE (the ((\\<sigma>;;\\<tau>) l))])))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\n 2. l \\<in> dom (\\<sigma>;;\\<tau>)", "show \"s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])", "by (simp add: get.hyps(2))"], ["proof (state)\nthis:\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\n\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "show \"l \\<in> dom (\\<sigma>;;\\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "have \"l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])", "by simp"], ["proof (state)\nthis:\n  l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\n\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "hence \"l \\<in> dom \\<sigma> \\<union> dom \\<tau>\""], ["proof (prove)\nusing this:\n  l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\n\ngoal (1 subgoal):\n 1. l \\<in> dom \\<sigma> \\<union> dom \\<tau>", "using domains_subsume_def domains_subsume_globally_def doms_sub_local get.hyps(2)"], ["proof (prove)\nusing this:\n  l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\n  \\<S> ?ls = (LID\\<^sub>L ?ls \\<subseteq> doms ?ls)\n  \\<S>\\<^sub>G ?s =\n  (\\<forall>r ls. ?s r = Some ls \\<longrightarrow> \\<S> ls)\n  \\<S>\\<^sub>G s\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\n\ngoal (1 subgoal):\n 1. l \\<in> dom \\<sigma> \\<union> dom \\<tau>", "by fastforce"], ["proof (state)\nthis:\n  l \\<in> dom \\<sigma> \\<union> dom \\<tau>\n\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "thus \"l \\<in> dom (\\<sigma>;;\\<tau>)\""], ["proof (prove)\nusing this:\n  l \\<in> dom \\<sigma> \\<union> dom \\<tau>\n\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "by (simp add: dom_combination_dom_union)"], ["proof (state)\nthis:\n  l \\<in> dom (\\<sigma>;;\\<tau>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<in> dom (\\<sigma>;;\\<tau>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  revision_step r s\n   (s(r \\<mapsto>\n    (\\<sigma>, \\<tau>, \\<E> [VE (the ((\\<sigma>;;\\<tau>) l))])))\n\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 8. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "then"], ["proof (chain)\npicking this:\n  revision_step r s\n   (s(r \\<mapsto>\n    (\\<sigma>, \\<tau>, \\<E> [VE (the ((\\<sigma>;;\\<tau>) l))])))", "show ?case"], ["proof (prove)\nusing this:\n  revision_step r s\n   (s(r \\<mapsto>\n    (\\<sigma>, \\<tau>, \\<E> [VE (the ((\\<sigma>;;\\<tau>) l))])))\n\ngoal (1 subgoal):\n 1. revision_step r s s'", "using get.hyps(1)"], ["proof (prove)\nusing this:\n  revision_step r s\n   (s(r \\<mapsto>\n    (\\<sigma>, \\<tau>, \\<E> [VE (the ((\\<sigma>;;\\<tau>) l))])))\n  s' = s(r \\<mapsto>\n  (\\<sigma>, \\<tau>,\n   \\<E> [VE (the (if \\<tau> l = None then \\<sigma> l else \\<tau> l))]))\n\ngoal (1 subgoal):\n 1. revision_step r s s'", "by auto"], ["proof (state)\nthis:\n  revision_step r s s'\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "case (set \\<sigma> \\<tau> \\<E> l v)"], ["proof (state)\nthis:\n  s' = s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]))\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "have \"revision_step r s (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revision_step r s\n     (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)])))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\n 2. l \\<in> dom (\\<sigma>;;\\<tau>)", "show \"s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])", "by (simp add: set.hyps(2))"], ["proof (state)\nthis:\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\n\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "show \"l \\<in> dom (\\<sigma>;;\\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "have \"l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> LID\\<^sub>L\n             (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])", "by simp"], ["proof (state)\nthis:\n  l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\n\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "hence \"l \\<in> dom \\<sigma> \\<union> dom \\<tau>\""], ["proof (prove)\nusing this:\n  l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\n\ngoal (1 subgoal):\n 1. l \\<in> dom \\<sigma> \\<union> dom \\<tau>", "using domains_subsume_def domains_subsume_globally_def doms_sub_local set.hyps(2)"], ["proof (prove)\nusing this:\n  l \\<in> LID\\<^sub>L (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\n  \\<S> ?ls = (LID\\<^sub>L ?ls \\<subseteq> doms ?ls)\n  \\<S>\\<^sub>G ?s =\n  (\\<forall>r ls. ?s r = Some ls \\<longrightarrow> \\<S> ls)\n  \\<S>\\<^sub>G s\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\n\ngoal (1 subgoal):\n 1. l \\<in> dom \\<sigma> \\<union> dom \\<tau>", "by fastforce"], ["proof (state)\nthis:\n  l \\<in> dom \\<sigma> \\<union> dom \\<tau>\n\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "thus \"l \\<in> dom (\\<sigma>;;\\<tau>)\""], ["proof (prove)\nusing this:\n  l \\<in> dom \\<sigma> \\<union> dom \\<tau>\n\ngoal (1 subgoal):\n 1. l \\<in> dom (\\<sigma>;;\\<tau>)", "by (simp add: dom_combination_dom_union)"], ["proof (state)\nthis:\n  l \\<in> dom (\\<sigma>;;\\<tau>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<in> dom (\\<sigma>;;\\<tau>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  revision_step r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)])))\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r =\n        Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 7. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "then"], ["proof (chain)\npicking this:\n  revision_step r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)])))", "show ?case"], ["proof (prove)\nusing this:\n  revision_step r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)])))\n\ngoal (1 subgoal):\n 1. revision_step r s s'", "using set.hyps(1)"], ["proof (prove)\nusing this:\n  revision_step r s\n   (s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)])))\n  s' = s(r \\<mapsto> (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]))\n\ngoal (1 subgoal):\n 1. revision_step r s s'", "by blast"], ["proof (state)\nthis:\n  revision_step r s s'\n\ngoal (6 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 4. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 5. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'\n 6. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> revision_step r s s'", "qed (simp add: revision_step.intros)+"], ["proof (state)\nthis:\n  revision_step r s s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  revision_step r s s' = revision_step_relaxed r s s'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Finitude is invariant\\<close>"], ["", "lemma finite_occurrences_val_expr [simp]:\n  fixes \n    v :: \"('r,'l,'v) val\" and\n    e :: \"('r,'l,'v) expr\"\n  shows\n  \"finite (RID\\<^sub>V v)\"\n  \"finite (RID\\<^sub>E e)\"\n  \"finite (LID\\<^sub>V v)\"\n  \"finite (LID\\<^sub>E e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite (RID\\<^sub>V v) &&& finite (RID\\<^sub>E e)) &&&\n    finite (LID\\<^sub>V v) &&& finite (LID\\<^sub>E e)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (RID\\<^sub>V v)\n 2. finite (RID\\<^sub>E e)\n 3. finite (LID\\<^sub>V v)\n 4. finite (LID\\<^sub>E e)", "have \"(finite (RID\\<^sub>V v) \\<and> finite (LID\\<^sub>V v)) \\<and> finite (RID\\<^sub>E e) \\<and> finite (LID\\<^sub>E e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite (RID\\<^sub>V v) \\<and> finite (LID\\<^sub>V v)) \\<and>\n    finite (RID\\<^sub>E e) \\<and> finite (LID\\<^sub>E e)", "by (induct rule: val_expr.induct) auto"], ["proof (state)\nthis:\n  (finite (RID\\<^sub>V v) \\<and> finite (LID\\<^sub>V v)) \\<and>\n  finite (RID\\<^sub>E e) \\<and> finite (LID\\<^sub>E e)\n\ngoal (4 subgoals):\n 1. finite (RID\\<^sub>V v)\n 2. finite (RID\\<^sub>E e)\n 3. finite (LID\\<^sub>V v)\n 4. finite (LID\\<^sub>E e)", "thus  \n    \"finite (RID\\<^sub>V v)\"\n    \"finite (RID\\<^sub>E e)\"\n    \"finite (LID\\<^sub>V v)\"\n    \"finite (LID\\<^sub>E e)\""], ["proof (prove)\nusing this:\n  (finite (RID\\<^sub>V v) \\<and> finite (LID\\<^sub>V v)) \\<and>\n  finite (RID\\<^sub>E e) \\<and> finite (LID\\<^sub>E e)\n\ngoal (1 subgoal):\n 1. (finite (RID\\<^sub>V v) &&& finite (RID\\<^sub>E e)) &&&\n    finite (LID\\<^sub>V v) &&& finite (LID\\<^sub>E e)", "by auto"], ["proof (state)\nthis:\n  finite (RID\\<^sub>V v)\n  finite (RID\\<^sub>E e)\n  finite (LID\\<^sub>V v)\n  finite (LID\\<^sub>E e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma store_finite_upd [intro]:\n  \"finite (RID\\<^sub>S \\<tau>) \\<Longrightarrow> finite (RID\\<^sub>S (\\<tau>(l := None)))\" \n  \"finite (LID\\<^sub>S \\<tau>) \\<Longrightarrow> finite (LID\\<^sub>S (\\<tau>(l := None)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite (RID\\<^sub>S \\<tau>) \\<Longrightarrow>\n     finite (RID\\<^sub>S (\\<tau>(l := None)))) &&&\n    (finite (LID\\<^sub>S \\<tau>) \\<Longrightarrow>\n     finite (LID\\<^sub>S (\\<tau>(l := None))))", "apply (meson ID_restricted_store_subset_store(1) finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>S \\<tau>) \\<Longrightarrow>\n    finite (LID\\<^sub>S (\\<tau>(l := None)))", "by (simp add: ID_restricted_store_subset_store(2) rev_finite_subset)"], ["", "lemma finite_state_imp_restriction_finite [intro]: \n  \"finite (RID\\<^sub>G s) \\<Longrightarrow> finite (RID\\<^sub>G (s(r := None)))\"\n  \"finite (LID\\<^sub>G s) \\<Longrightarrow> finite (LID\\<^sub>G (s(r := None)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite (RID\\<^sub>G s) \\<Longrightarrow>\n     finite (RID\\<^sub>G (s(r := None)))) &&&\n    (finite (LID\\<^sub>G s) \\<Longrightarrow>\n     finite (LID\\<^sub>G (s(r := None))))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (RID\\<^sub>G s) \\<Longrightarrow>\n    finite (RID\\<^sub>G (s(r := None)))\n 2. finite (LID\\<^sub>G s) \\<Longrightarrow>\n    finite (LID\\<^sub>G (s(r := None)))", "assume \"finite (RID\\<^sub>G s)\""], ["proof (state)\nthis:\n  finite (RID\\<^sub>G s)\n\ngoal (2 subgoals):\n 1. finite (RID\\<^sub>G s) \\<Longrightarrow>\n    finite (RID\\<^sub>G (s(r := None)))\n 2. finite (LID\\<^sub>G s) \\<Longrightarrow>\n    finite (LID\\<^sub>G (s(r := None)))", "thus \"finite (RID\\<^sub>G (s(r := None)))\""], ["proof (prove)\nusing this:\n  finite (RID\\<^sub>G s)\n\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G (s(r := None)))", "by (meson infinite_super ID_restricted_global_subset_unrestricted)"], ["proof (state)\nthis:\n  finite (RID\\<^sub>G (s(r := None)))\n\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s) \\<Longrightarrow>\n    finite (LID\\<^sub>G (s(r := None)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s) \\<Longrightarrow>\n    finite (LID\\<^sub>G (s(r := None)))", "assume fin: \"finite (LID\\<^sub>G s)\""], ["proof (state)\nthis:\n  finite (LID\\<^sub>G s)\n\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s) \\<Longrightarrow>\n    finite (LID\\<^sub>G (s(r := None)))", "have \"LID\\<^sub>G (s(r := None)) \\<subseteq> LID\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LID\\<^sub>G (s(r := None)) \\<subseteq> LID\\<^sub>G s", "by auto"], ["proof (state)\nthis:\n  LID\\<^sub>G (s(r := None)) \\<subseteq> LID\\<^sub>G s\n\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s) \\<Longrightarrow>\n    finite (LID\\<^sub>G (s(r := None)))", "thus \"finite (LID\\<^sub>G (s(r := None)))\""], ["proof (prove)\nusing this:\n  LID\\<^sub>G (s(r := None)) \\<subseteq> LID\\<^sub>G s\n\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G (s(r := None)))", "using fin finite_subset"], ["proof (prove)\nusing this:\n  LID\\<^sub>G (s(r := None)) \\<subseteq> LID\\<^sub>G s\n  finite (LID\\<^sub>G s)\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G (s(r := None)))", "by auto"], ["proof (state)\nthis:\n  finite (LID\\<^sub>G (s(r := None)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma local_state_of_finite_restricted_global_state_is_finite [intro]: \n  \"s r' = Some ls \\<Longrightarrow> finite (RID\\<^sub>G (s(r := None))) \\<Longrightarrow> r \\<noteq> r' \\<Longrightarrow> finite (RID\\<^sub>L ls)\"\n  \"s r' = Some ls \\<Longrightarrow> finite (LID\\<^sub>G (s(r := None))) \\<Longrightarrow> r \\<noteq> r' \\<Longrightarrow> finite (LID\\<^sub>L ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>s r' = Some ls; finite (RID\\<^sub>G (s(r := None)));\n      r \\<noteq> r'\\<rbrakk>\n     \\<Longrightarrow> finite (RID\\<^sub>L ls)) &&&\n    (\\<lbrakk>s r' = Some ls; finite (LID\\<^sub>G (s(r := None)));\n      r \\<noteq> r'\\<rbrakk>\n     \\<Longrightarrow> finite (LID\\<^sub>L ls))", "apply (metis (no_types, lifting) ID_distr_global(1) finite_Un finite_insert fun_upd_triv fun_upd_twist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s r' = Some ls; finite (LID\\<^sub>G (s(r := None)));\n     r \\<noteq> r'\\<rbrakk>\n    \\<Longrightarrow> finite (LID\\<^sub>L ls)", "by (metis ID_distr_global(2) finite_Un fun_upd_triv fun_upd_twist)"], ["", "lemma empty_map_finite [simp]: \n  \"finite (RID\\<^sub>S \\<epsilon>)\" \n  \"finite (LID\\<^sub>S \\<epsilon>)\" \n  \"finite (RID\\<^sub>G \\<epsilon>)\" \n  \"finite (LID\\<^sub>G \\<epsilon>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite (RID\\<^sub>S \\<epsilon>) &&&\n     finite (LID\\<^sub>S \\<epsilon>)) &&&\n    finite (RID\\<^sub>G \\<epsilon>) &&& finite (LID\\<^sub>G \\<epsilon>)", "by (simp add: RID\\<^sub>S_def LID\\<^sub>S_def RID\\<^sub>G_def LID\\<^sub>G_def)+"], ["", "lemma finite_combination [intro]:\n  \"finite (RID\\<^sub>S \\<sigma>) \\<Longrightarrow> finite (RID\\<^sub>S \\<tau>) \\<Longrightarrow> finite (RID\\<^sub>S (\\<sigma>;;\\<tau>))\"\n  \"finite (LID\\<^sub>S \\<sigma>) \\<Longrightarrow> finite (LID\\<^sub>S \\<tau>) \\<Longrightarrow> finite (LID\\<^sub>S (\\<sigma>;;\\<tau>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>finite (RID\\<^sub>S \\<sigma>);\n      finite (RID\\<^sub>S \\<tau>)\\<rbrakk>\n     \\<Longrightarrow> finite (RID\\<^sub>S (\\<sigma>;;\\<tau>))) &&&\n    (\\<lbrakk>finite (LID\\<^sub>S \\<sigma>);\n      finite (LID\\<^sub>S \\<tau>)\\<rbrakk>\n     \\<Longrightarrow> finite (LID\\<^sub>S (\\<sigma>;;\\<tau>)))", "by (meson finite_UnI rev_finite_subset ID_combination_subset_union)+"], ["", "lemma RID\\<^sub>G_finite_invariant:\n  assumes\n    step: \"revision_step r s s'\" and\n    fin: \"finite (RID\\<^sub>G s)\"\nshows\n    \"finite (RID\\<^sub>G s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s')", "proof (use step in \\<open>cases rule: revision_stepE\\<close>)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')", "case (join \\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v)"], ["proof (state)\nthis:\n  s' = (s(r \\<mapsto> (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n  (r' := None)\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))])\n  s r' = Some (\\<sigma>', \\<tau>', VE v)\n\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')", "hence \"r \\<noteq> r'\""], ["proof (prove)\nusing this:\n  s' = (s(r \\<mapsto> (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n  (r' := None)\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))])\n  s r' = Some (\\<sigma>', \\<tau>', VE v)\n\ngoal (1 subgoal):\n 1. r \\<noteq> r'", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> r'\n\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')", "then"], ["proof (chain)\npicking this:\n  r \\<noteq> r'", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<noteq> r'\n\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s')", "by (metis (mono_tags, lifting) ID_distr_global(1) ID_distr_local(2) fin finite_Un finite_combination(1) finite_insert finite_occurrences_val_expr(2) finite_state_imp_restriction_finite(1) join local_state_of_finite_restricted_global_state_is_finite(1))"], ["proof (state)\nthis:\n  finite (RID\\<^sub>G s')\n\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')\n 8. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s')", "qed (use fin in \\<open>auto simp add: ID_distr_global_conditional\\<close>)"], ["", "lemma RID\\<^sub>L_finite_invariant:\n  assumes\n    step: \"revision_step r s s'\" and\n    fin: \"finite (LID\\<^sub>G s)\"\nshows\n    \"finite (LID\\<^sub>G s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s')", "proof (use step in \\<open>cases rule: revision_stepE\\<close>)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')", "case (join \\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v)"], ["proof (state)\nthis:\n  s' = (s(r \\<mapsto> (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n  (r' := None)\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))])\n  s r' = Some (\\<sigma>', \\<tau>', VE v)\n\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')", "hence \"r \\<noteq> r'\""], ["proof (prove)\nusing this:\n  s' = (s(r \\<mapsto> (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n  (r' := None)\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))])\n  s r' = Some (\\<sigma>', \\<tau>', VE v)\n\ngoal (1 subgoal):\n 1. r \\<noteq> r'", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> r'\n\ngoal (9 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 8. \\<And>\\<sigma> \\<tau> \\<E> r' \\<sigma>' \\<tau>' v.\n       \\<lbrakk>s' =\n                (s(r \\<mapsto>\n                 (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n                (r' := None);\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = Some (\\<sigma>', \\<tau>', VE v)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 9. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')", "then"], ["proof (chain)\npicking this:\n  r \\<noteq> r'", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<noteq> r'\n\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s')", "using join assms"], ["proof (prove)\nusing this:\n  r \\<noteq> r'\n  s' = (s(r \\<mapsto> (\\<sigma>, \\<tau>;;\\<tau>', \\<E> [VE (CV Unit)])))\n  (r' := None)\n  s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))])\n  s r' = Some (\\<sigma>', \\<tau>', VE v)\n  revision_step r s s'\n  finite (LID\\<^sub>G s)\n\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s')", "by (metis (mono_tags, lifting) ID_distr_global(2) ID_distr_local(1) fin finite_Un finite_combination(2) finite_occurrences_val_expr(4) finite_state_imp_restriction_finite(2) join local_state_of_finite_restricted_global_state_is_finite(2))"], ["proof (state)\nthis:\n  finite (LID\\<^sub>G s')\n\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> \\<tau> \\<E> x e v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>, \\<E> [subst (VE v) x e]));\n        s r =\n        Some\n         (\\<sigma>, \\<tau>, \\<E> [Apply (VE (Lambda x e)) (VE v)])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 2. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e1]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV T)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 3. \\<And>\\<sigma> \\<tau> \\<E> e1 e2.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [e2]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ite (VE (CV F)) e1 e2])\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 4. \\<And>\\<sigma> \\<tau> \\<E> v l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (Loc l)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Ref (VE v)]);\n        l \\<notin> LID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 5. \\<And>\\<sigma> \\<tau> \\<E> l.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>,\n                 \\<E>\n                  [VE (the (if \\<tau> l = None then \\<sigma> l\n                            else \\<tau> l))]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Read (VE (Loc l))]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 6. \\<And>\\<sigma> \\<tau> \\<E> l v.\n       \\<lbrakk>s' = s(r \\<mapsto>\n                (\\<sigma>, \\<tau>(l \\<mapsto> v), \\<E> [VE (CV Unit)]));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Assign (VE (Loc l)) (VE v)]);\n        l \\<in> dom (\\<sigma>;;\\<tau>)\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 7. \\<And>\\<sigma> \\<tau> \\<E> e r'.\n       \\<lbrakk>s' = s(r \\<mapsto> (\\<sigma>, \\<tau>, \\<E> [VE (Rid r')]),\n                r' \\<mapsto> (\\<sigma>;;\\<tau>, \\<epsilon>, e));\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rfork e]);\n        r' \\<notin> RID\\<^sub>G s\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')\n 8. \\<And>\\<sigma> \\<tau> \\<E> r'.\n       \\<lbrakk>s' = \\<epsilon>;\n        s r = Some (\\<sigma>, \\<tau>, \\<E> [Rjoin (VE (Rid r'))]);\n        s r' = None\\<rbrakk>\n       \\<Longrightarrow> finite (LID\\<^sub>G s')", "qed (use fin in \\<open>auto simp add: ID_distr_global_conditional\\<close>)"], ["", "lemma reachable_imp_identifiers_finite:\n  assumes reach: \"reachable s\"\n  shows \n    \"finite (RID\\<^sub>G s)\"\n    \"finite (LID\\<^sub>G s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s) &&& finite (LID\\<^sub>G s)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (RID\\<^sub>G s)\n 2. finite (LID\\<^sub>G s)", "from reach"], ["proof (chain)\npicking this:\n  reachable s", "obtain e r where exec: \"execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>,\\<epsilon>,e))) s\""], ["proof (prove)\nusing this:\n  reachable s\n\ngoal (1 subgoal):\n 1. (\\<And>e r.\n        execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n         s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using reachable_def execution_def"], ["proof (prove)\nusing this:\n  reachable s\n  reachable ?s \\<equiv> \\<exists>e s'. execution e s' ?s\n  execution ?e ?s ?s' \\<equiv>\n  (\\<exists>r.\n      ?s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, ?e)) \\<and>\n      program_expr ?e) \\<and>\n  ?s \\<leadsto>\\<^sup>* ?s'\n\ngoal (1 subgoal):\n 1. (\\<And>e r.\n        execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n         s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))) s\n\ngoal (2 subgoals):\n 1. finite (RID\\<^sub>G s)\n 2. finite (LID\\<^sub>G s)", "hence prog_exp: \"program_expr e\""], ["proof (prove)\nusing this:\n  execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))) s\n\ngoal (1 subgoal):\n 1. program_expr e", "by (meson execution_def)"], ["proof (state)\nthis:\n  program_expr e\n\ngoal (2 subgoals):\n 1. finite (RID\\<^sub>G s)\n 2. finite (LID\\<^sub>G s)", "obtain n where n_reachable: \"(\\<epsilon>(r \\<mapsto> (\\<epsilon>,\\<epsilon>,e)), s) \\<in> [\\<leadsto>]^^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using exec"], ["proof (prove)\nusing this:\n  execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))) s\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson execution_def rtrancl_imp_relpow)"], ["proof (state)\nthis:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n  \\<in> [\\<leadsto>] ^^ n\n\ngoal (2 subgoals):\n 1. finite (RID\\<^sub>G s)\n 2. finite (LID\\<^sub>G s)", "hence \"finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\""], ["proof (prove)\nusing this:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n  \\<in> [\\<leadsto>] ^^ n\n\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)", "proof (induct n arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n       \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow>\n       finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "case 0"], ["proof (state)\nthis:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n  \\<in> [\\<leadsto>] ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n       \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow>\n       finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "hence s: \"s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\""], ["proof (prove)\nusing this:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n  \\<in> [\\<leadsto>] ^^ 0\n\ngoal (1 subgoal):\n 1. s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))", "by auto"], ["proof (state)\nthis:\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n       \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow>\n       finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "hence rid_dom: \"dom s = {r}\""], ["proof (prove)\nusing this:\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n\ngoal (1 subgoal):\n 1. dom s = {r}", "by auto"], ["proof (state)\nthis:\n  dom s = {r}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n       \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow>\n       finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "hence rid_ran: \"\\<Union> (RID\\<^sub>L ` ran s) = {}\""], ["proof (prove)\nusing this:\n  dom s = {r}\n\ngoal (1 subgoal):\n 1. \\<Union> (RID\\<^sub>L ` ran s) = {}", "using s"], ["proof (prove)\nusing this:\n  dom s = {r}\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n\ngoal (1 subgoal):\n 1. \\<Union> (RID\\<^sub>L ` ran s) = {}", "by (auto simp add: prog_exp)"], ["proof (state)\nthis:\n  \\<Union> (RID\\<^sub>L ` ran s) = {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n       \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow>\n       finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "have rids: \"RID\\<^sub>G s = {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RID\\<^sub>G s = {r}", "by (unfold RID\\<^sub>G_def, use rid_dom rid_ran in auto)"], ["proof (state)\nthis:\n  RID\\<^sub>G s = {r}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n       \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow>\n       finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "have lid_ran: \"\\<Union> (LID\\<^sub>L ` ran s) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (LID\\<^sub>L ` ran s) = {}", "using s"], ["proof (prove)\nusing this:\n  s = \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e))\n\ngoal (1 subgoal):\n 1. \\<Union> (LID\\<^sub>L ` ran s) = {}", "by (auto simp add: prog_exp)"], ["proof (state)\nthis:\n  \\<Union> (LID\\<^sub>L ` ran s) = {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n       \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow>\n       finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "hence lids: \"LID\\<^sub>G s = {}\""], ["proof (prove)\nusing this:\n  \\<Union> (LID\\<^sub>L ` ran s) = {}\n\ngoal (1 subgoal):\n 1. LID\\<^sub>G s = {}", "by (unfold LID\\<^sub>G_def, simp)"], ["proof (state)\nthis:\n  LID\\<^sub>G s = {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n       \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow>\n       finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "thus ?case"], ["proof (prove)\nusing this:\n  LID\\<^sub>G s = {}\n\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)", "using rids lids"], ["proof (prove)\nusing this:\n  LID\\<^sub>G s = {}\n  RID\\<^sub>G s = {r}\n  LID\\<^sub>G s = {}\n\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)", "by simp"], ["proof (state)\nthis:\n  finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "case (Suc n)"], ["proof (state)\nthis:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), ?s)\n  \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n  finite (RID\\<^sub>G ?s) \\<and> finite (LID\\<^sub>G ?s)\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n  \\<in> [\\<leadsto>] ^^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "then"], ["proof (chain)\npicking this:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), ?s)\n  \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n  finite (RID\\<^sub>G ?s) \\<and> finite (LID\\<^sub>G ?s)\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n  \\<in> [\\<leadsto>] ^^ Suc n", "obtain s' where \n      n_steps: \"(\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s') \\<in> [\\<leadsto>]^^n\" and \n      step: \"s' \\<leadsto> s\""], ["proof (prove)\nusing this:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), ?s)\n  \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n  finite (RID\\<^sub>G ?s) \\<and> finite (LID\\<^sub>G ?s)\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n  \\<in> [\\<leadsto>] ^^ Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>(\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s')\n                 \\<in> [\\<leadsto>] ^^ n;\n         s' \\<leadsto> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson relpow_Suc_E)"], ["proof (state)\nthis:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s')\n  \\<in> [\\<leadsto>] ^^ n\n  s' \\<leadsto> s\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "have fin_rid: \"finite (RID\\<^sub>G s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s')", "using Suc.hyps n_steps"], ["proof (prove)\nusing this:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), ?s)\n  \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n  finite (RID\\<^sub>G ?s) \\<and> finite (LID\\<^sub>G ?s)\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s')\n  \\<in> [\\<leadsto>] ^^ n\n\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s')", "by blast"], ["proof (state)\nthis:\n  finite (RID\\<^sub>G s')\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "have fin_lid: \"finite (LID\\<^sub>G s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s')", "using Suc.hyps n_steps"], ["proof (prove)\nusing this:\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), ?s)\n  \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n  finite (RID\\<^sub>G ?s) \\<and> finite (LID\\<^sub>G ?s)\n  (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s')\n  \\<in> [\\<leadsto>] ^^ n\n\ngoal (1 subgoal):\n 1. finite (LID\\<^sub>G s')", "by blast"], ["proof (state)\nthis:\n  finite (LID\\<^sub>G s')\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n                   \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s);\n        (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)), s)\n        \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (RID\\<^sub>G s) \\<and>\n                         finite (LID\\<^sub>G s)", "thus ?case"], ["proof (prove)\nusing this:\n  finite (LID\\<^sub>G s')\n\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)", "by (meson RID\\<^sub>G_finite_invariant RID\\<^sub>L_finite_invariant fin_rid local.step valid_stepE)"], ["proof (state)\nthis:\n  finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n\ngoal (2 subgoals):\n 1. finite (RID\\<^sub>G s)\n 2. finite (LID\\<^sub>G s)", "thus \"finite (RID\\<^sub>G s)\" \"finite (LID\\<^sub>G s)\""], ["proof (prove)\nusing this:\n  finite (RID\\<^sub>G s) \\<and> finite (LID\\<^sub>G s)\n\ngoal (1 subgoal):\n 1. finite (RID\\<^sub>G s) &&& finite (LID\\<^sub>G s)", "by auto"], ["proof (state)\nthis:\n  finite (RID\\<^sub>G s)\n  finite (LID\\<^sub>G s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_imp_identifiers_available:\n  assumes \n    \"reachable (s :: ('r,'l,'v) global_state)\"\n  shows \n    \"infinite (UNIV :: 'r set) \\<Longrightarrow> \\<exists>r. r \\<notin> RID\\<^sub>G s\"\n    \"infinite (UNIV :: 'l set) \\<Longrightarrow> \\<exists>l. l \\<notin> LID\\<^sub>G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (infinite UNIV \\<Longrightarrow>\n     \\<exists>r. r \\<notin> RID\\<^sub>G s) &&&\n    (infinite UNIV \\<Longrightarrow> \\<exists>l. l \\<notin> LID\\<^sub>G s)", "by (simp add: assms ex_new_if_finite reachable_imp_identifiers_finite)+"], ["", "subsubsection \\<open>Reachability is invariant\\<close>"], ["", "lemma initial_state_reachable:\n  assumes \"program_expr e\"\n  shows \"reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>,\\<epsilon>,e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))", "have \"initializes (\\<epsilon>(r \\<mapsto> (\\<epsilon>,\\<epsilon>,e))) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ra.\n       \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) = \\<epsilon>(ra \n       \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n       program_expr e", "using assms"], ["proof (prove)\nusing this:\n  program_expr e\n\ngoal (1 subgoal):\n 1. \\<exists>ra.\n       \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) = \\<epsilon>(ra \n       \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n       program_expr e", "by auto"], ["proof (state)\nthis:\n  \\<exists>ra.\n     \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) = \\<epsilon>(ra \n     \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n\ngoal (1 subgoal):\n 1. reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))", "hence \"execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>,\\<epsilon>,e))) (\\<epsilon>(r \\<mapsto> (\\<epsilon>,\\<epsilon>,e)))\""], ["proof (prove)\nusing this:\n  \\<exists>ra.\n     \\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) = \\<epsilon>(ra \n     \\<mapsto> (\\<epsilon>, \\<epsilon>, e)) \\<and>\n     program_expr e\n\ngoal (1 subgoal):\n 1. execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n     (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))", "by (simp add: execution_def)"], ["proof (state)\nthis:\n  execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n\ngoal (1 subgoal):\n 1. reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n\ngoal (1 subgoal):\n 1. reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))", "using reachable_def"], ["proof (prove)\nusing this:\n  execution e (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n   (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n  reachable ?s \\<equiv> \\<exists>e s'. execution e s' ?s\n\ngoal (1 subgoal):\n 1. reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))", "by blast"], ["proof (state)\nthis:\n  reachable (\\<epsilon>(r \\<mapsto> (\\<epsilon>, \\<epsilon>, e)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachability_closed_under_execution_step:\n  assumes\n    reach: \"reachable s\" and\n    step: \"revision_step r s s'\"\n  shows \"reachable s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable s'", "obtain init e where exec: \"execution e init s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e init.\n        execution e init s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using reach reachable_def"], ["proof (prove)\nusing this:\n  reachable s\n  reachable ?s \\<equiv> \\<exists>e s'. execution e s' ?s\n\ngoal (1 subgoal):\n 1. (\\<And>e init.\n        execution e init s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution e init s\n\ngoal (1 subgoal):\n 1. reachable s'", "hence init_s:\"init \\<leadsto>\\<^sup>* s\""], ["proof (prove)\nusing this:\n  execution e init s\n\ngoal (1 subgoal):\n 1. init \\<leadsto>\\<^sup>* s", "by (simp add: execution_def)"], ["proof (state)\nthis:\n  init \\<leadsto>\\<^sup>* s\n\ngoal (1 subgoal):\n 1. reachable s'", "have s_s': \"s \\<leadsto> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<leadsto> s'", "using step"], ["proof (prove)\nusing this:\n  revision_step r s s'\n\ngoal (1 subgoal):\n 1. s \\<leadsto> s'", "by blast"], ["proof (state)\nthis:\n  s \\<leadsto> s'\n\ngoal (1 subgoal):\n 1. reachable s'", "have \"init \\<leadsto>\\<^sup>* s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<leadsto>\\<^sup>* s'", "using init_s s_s'"], ["proof (prove)\nusing this:\n  init \\<leadsto>\\<^sup>* s\n  s \\<leadsto> s'\n\ngoal (1 subgoal):\n 1. init \\<leadsto>\\<^sup>* s'", "by auto"], ["proof (state)\nthis:\n  init \\<leadsto>\\<^sup>* s'\n\ngoal (1 subgoal):\n 1. reachable s'", "hence \"execution e init s'\""], ["proof (prove)\nusing this:\n  init \\<leadsto>\\<^sup>* s'\n\ngoal (1 subgoal):\n 1. execution e init s'", "using exec"], ["proof (prove)\nusing this:\n  init \\<leadsto>\\<^sup>* s'\n  execution e init s\n\ngoal (1 subgoal):\n 1. execution e init s'", "by (simp add: execution_def)"], ["proof (state)\nthis:\n  execution e init s'\n\ngoal (1 subgoal):\n 1. reachable s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  execution e init s'\n\ngoal (1 subgoal):\n 1. reachable s'", "using reachable_def"], ["proof (prove)\nusing this:\n  execution e init s'\n  reachable ?s \\<equiv> \\<exists>e s'. execution e s' ?s\n\ngoal (1 subgoal):\n 1. reachable s'", "by auto"], ["proof (state)\nthis:\n  reachable s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachability_closed_under_execution: \"reachable s \\<Longrightarrow> s \\<leadsto>\\<^sup>* s' \\<Longrightarrow> reachable s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s; s \\<leadsto>\\<^sup>* s'\\<rbrakk>\n    \\<Longrightarrow> reachable s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s; s \\<leadsto>\\<^sup>* s'\\<rbrakk>\n    \\<Longrightarrow> reachable s'", "assume reach: \"reachable s\" and \"s \\<leadsto>\\<^sup>* s'\""], ["proof (state)\nthis:\n  reachable s\n  s \\<leadsto>\\<^sup>* s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s; s \\<leadsto>\\<^sup>* s'\\<rbrakk>\n    \\<Longrightarrow> reachable s'", "then"], ["proof (chain)\npicking this:\n  reachable s\n  s \\<leadsto>\\<^sup>* s'", "obtain n where \"(s, s') \\<in> [\\<leadsto>]^^n\""], ["proof (prove)\nusing this:\n  reachable s\n  s \\<leadsto>\\<^sup>* s'\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rtrancl_imp_relpow"], ["proof (prove)\nusing this:\n  reachable s\n  s \\<leadsto>\\<^sup>* s'\n  ?p \\<in> ?R\\<^sup>* \\<Longrightarrow> \\<exists>n. ?p \\<in> ?R ^^ n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (s, s') \\<in> [\\<leadsto>] ^^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s; s \\<leadsto>\\<^sup>* s'\\<rbrakk>\n    \\<Longrightarrow> reachable s'", "thus \"reachable s'\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> [\\<leadsto>] ^^ n\n\ngoal (1 subgoal):\n 1. reachable s'", "proof (induct n arbitrary: s')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s'. (s, s') \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow> reachable s'\n 2. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   reachable s';\n        (s, s') \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> reachable s'", "case 0"], ["proof (state)\nthis:\n  (s, s') \\<in> [\\<leadsto>] ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>s'. (s, s') \\<in> [\\<leadsto>] ^^ 0 \\<Longrightarrow> reachable s'\n 2. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   reachable s';\n        (s, s') \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> reachable s'", "thus ?case"], ["proof (prove)\nusing this:\n  (s, s') \\<in> [\\<leadsto>] ^^ 0\n\ngoal (1 subgoal):\n 1. reachable s'", "using reach"], ["proof (prove)\nusing this:\n  (s, s') \\<in> [\\<leadsto>] ^^ 0\n  reachable s\n\ngoal (1 subgoal):\n 1. reachable s'", "by auto"], ["proof (state)\nthis:\n  reachable s'\n\ngoal (1 subgoal):\n 1. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   reachable s';\n        (s, s') \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> reachable s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   reachable s';\n        (s, s') \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> reachable s'", "case (Suc n)"], ["proof (state)\nthis:\n  (s, ?s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow> reachable ?s'\n  (s, s') \\<in> [\\<leadsto>] ^^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   reachable s';\n        (s, s') \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> reachable s'", "obtain s'' where \"(s,s'') \\<in> [\\<leadsto>]^^n\" \"s'' \\<leadsto> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>(s, s'') \\<in> [\\<leadsto>] ^^ n;\n         s'' \\<leadsto> s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.prems"], ["proof (prove)\nusing this:\n  (s, s') \\<in> [\\<leadsto>] ^^ Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>(s, s'') \\<in> [\\<leadsto>] ^^ n;\n         s'' \\<leadsto> s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (s, s'') \\<in> [\\<leadsto>] ^^ n\n  s'' \\<leadsto> s'\n\ngoal (1 subgoal):\n 1. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   reachable s';\n        (s, s') \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> reachable s'", "have \"reachable s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable s''", "by (simp add: Suc.hyps \\<open>(s, s'') \\<in> [\\<leadsto>]^^n\\<close>)"], ["proof (state)\nthis:\n  reachable s''\n\ngoal (1 subgoal):\n 1. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (s, s') \\<in> [\\<leadsto>] ^^ n \\<Longrightarrow>\n                   reachable s';\n        (s, s') \\<in> [\\<leadsto>] ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> reachable s'", "then"], ["proof (chain)\npicking this:\n  reachable s''", "show ?case"], ["proof (prove)\nusing this:\n  reachable s''\n\ngoal (1 subgoal):\n 1. reachable s'", "using \\<open>s'' \\<leadsto> s'\\<close> reachability_closed_under_execution_step"], ["proof (prove)\nusing this:\n  reachable s''\n  s'' \\<leadsto> s'\n  \\<lbrakk>reachable ?s; revision_step ?r ?s ?s'\\<rbrakk>\n  \\<Longrightarrow> reachable ?s'\n\ngoal (1 subgoal):\n 1. reachable s'", "by blast"], ["proof (state)\nthis:\n  reachable s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable s'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* substitution locale *)"], ["", "end"], ["", "(* theory *)"]]}