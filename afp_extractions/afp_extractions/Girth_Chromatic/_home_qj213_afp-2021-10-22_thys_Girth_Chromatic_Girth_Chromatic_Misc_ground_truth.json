{"file_name": "/home/qj213/afp-2021-10-22/thys/Girth_Chromatic/Girth_Chromatic_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Girth_Chromatic", "problem_names": ["lemma enat_in_Inf:\n  fixes S :: \"enat set\"\n  assumes \"Inf S \\<noteq> top\"\n  shows \"Inf S \\<in> S\"", "lemma enat_in_INF:\n  fixes f :: \"'a \\<Rightarrow> enat\"\n  assumes \"(INF x\\<in> S. f x) \\<noteq> top\"\n  obtains x where \"x \\<in> S\" and \"(INF x\\<in> S. f x) = f x\"", "lemma enat_less_INF_I:\n  fixes f :: \"'a \\<Rightarrow> enat\"\n  assumes not_inf: \"x \\<noteq> \\<infinity>\" and less: \"\\<And>y. y \\<in> S \\<Longrightarrow> x < f y\"\n  shows \"x < (INF y\\<in>S. f y)\"", "lemma enat_le_Sup_iff:\n  \"enat k \\<le> Sup M \\<longleftrightarrow> k = 0 \\<or> (\\<exists>m \\<in> M. enat k \\<le> m)\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma enat_neq_zero_cancel_iff[simp]:\n  \"0 \\<noteq> enat n \\<longleftrightarrow> 0 \\<noteq> n\"\n  \"enat n \\<noteq> 0 \\<longleftrightarrow> n \\<noteq> 0\"", "lemma natceiling_lessD: \"nat(ceiling x) < n \\<Longrightarrow> x < real n\"", "lemma le_natceiling_iff:\n  fixes n :: nat and r :: real\n  shows \"n \\<le> r \\<Longrightarrow> n \\<le> nat(ceiling r)\"", "lemma natceiling_le_iff:\n  fixes n :: nat and r :: real\n  shows \"r \\<le> n \\<Longrightarrow> nat(ceiling r) \\<le> n\"", "lemma dist_real_noabs_less:\n  fixes a b c :: real assumes \"dist a b < c\" shows \"a - b < c\"", "lemma n_choose_2_nat:\n  fixes n :: nat shows \"(n choose 2) = (n * (n - 1)) div 2\"", "lemma powr_less_one:\n  fixes x::real\n  assumes \"1 < x\" \"y < 0\"\n  shows \"x powr y < 1\"", "lemma powr_le_one_le: \"\\<And>x y::real. 0 < x \\<Longrightarrow> x \\<le> 1 \\<Longrightarrow> 1 \\<le> y \\<Longrightarrow> x powr y \\<le> x\"", "lemma list_set_tl: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\"", "lemma list_exhaust3:\n  obtains \"xs = []\" | x where \"xs = [x]\" | x y ys where \"xs = x # y # ys\"", "lemma card_Ex_subset:\n  \"k \\<le> card M \\<Longrightarrow> \\<exists>N. N \\<subseteq> M \\<and> card N = k\"", "lemma eventually_le_le:\n  fixes P :: \"'a => ('b :: preorder)\"\n  assumes \"eventually (\\<lambda>x. P x \\<le> Q x) net\"\n  assumes \"eventually (\\<lambda>x. Q x \\<le> R  x) net\"\n  shows \"eventually (\\<lambda>x. P x \\<le> R x) net\"", "lemma LIMSEQ_neg_powr:\n  assumes s: \"s < 0\"\n  shows \"(%x. (real x) powr s) \\<longlonglongrightarrow> 0\"", "lemma LIMSEQ_inv_powr:\n  assumes \"0 < c\" \"0 < d\"\n  shows \"(\\<lambda>n :: nat. (c / n) powr d) \\<longlonglongrightarrow> 0\""], "translations": [["", "lemma enat_in_Inf:\n  fixes S :: \"enat set\"\n  assumes \"Inf S \\<noteq> top\"\n  shows \"Inf S \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf S \\<in> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "assume A: \"~?thesis\""], ["proof (state)\nthis:\n  Inf S \\<notin> S\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "obtain n where Inf_conv: \"Inf S = enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. Inf S = enat n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  Inf S \\<noteq> top\n\ngoal (1 subgoal):\n 1. (\\<And>n. Inf S = enat n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: top_enat_def)"], ["proof (state)\nthis:\n  Inf S = enat n\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  Inf S = enat n\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s \\<in> S", "have \"Inf S \\<le> s\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. Inf S \\<le> s", "by (rule complete_lattice_class.Inf_lower)"], ["proof (state)\nthis:\n  Inf S \\<le> s\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Inf S \\<le> s\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "have \"Inf S \\<noteq> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf S \\<noteq> s", "using A \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  Inf S \\<notin> S\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. Inf S \\<noteq> s", "by auto"], ["proof (state)\nthis:\n  Inf S \\<noteq> s\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Inf S \\<le> s\n  Inf S \\<noteq> s", "have \"Inf S < s\""], ["proof (prove)\nusing this:\n  Inf S \\<le> s\n  Inf S \\<noteq> s\n\ngoal (1 subgoal):\n 1. Inf S < s", "by simp"], ["proof (state)\nthis:\n  Inf S < s\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "with Inf_conv"], ["proof (chain)\npicking this:\n  Inf S = enat n\n  Inf S < s", "have \"enat (Suc n) \\<le> s\""], ["proof (prove)\nusing this:\n  Inf S = enat n\n  Inf S < s\n\ngoal (1 subgoal):\n 1. enat (Suc n) \\<le> s", "by (cases s) auto"], ["proof (state)\nthis:\n  enat (Suc n) \\<le> s\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?s2 \\<in> S \\<Longrightarrow> enat (Suc n) \\<le> ?s2\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?s2 \\<in> S \\<Longrightarrow> enat (Suc n) \\<le> ?s2", "have \"enat (Suc n) \\<le> Inf S\""], ["proof (prove)\nusing this:\n  ?s2 \\<in> S \\<Longrightarrow> enat (Suc n) \\<le> ?s2\n\ngoal (1 subgoal):\n 1. enat (Suc n) \\<le> Inf S", "by (simp add: le_Inf_iff)"], ["proof (state)\nthis:\n  enat (Suc n) \\<le> Inf S\n\ngoal (1 subgoal):\n 1. Inf S \\<notin> S \\<Longrightarrow> False", "with Inf_conv"], ["proof (chain)\npicking this:\n  Inf S = enat n\n  enat (Suc n) \\<le> Inf S", "show False"], ["proof (prove)\nusing this:\n  Inf S = enat n\n  enat (Suc n) \\<le> Inf S\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enat_in_INF:\n  fixes f :: \"'a \\<Rightarrow> enat\"\n  assumes \"(INF x\\<in> S. f x) \\<noteq> top\"\n  obtains x where \"x \\<in> S\" and \"(INF x\\<in> S. f x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; Inf (f ` S) = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; Inf (f ` S) = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  Inf (f ` S) \\<noteq> top", "have \"(INF x\\<in> S. f x) \\<in> f ` S\""], ["proof (prove)\nusing this:\n  Inf (f ` S) \\<noteq> top\n\ngoal (1 subgoal):\n 1. Inf (f ` S) \\<in> f ` S", "using enat_in_Inf [of \"f ` S\"]"], ["proof (prove)\nusing this:\n  Inf (f ` S) \\<noteq> top\n  Inf (f ` S) \\<noteq> top \\<Longrightarrow> Inf (f ` S) \\<in> f ` S\n\ngoal (1 subgoal):\n 1. Inf (f ` S) \\<in> f ` S", "by auto"], ["proof (state)\nthis:\n  Inf (f ` S) \\<in> f ` S\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; Inf (f ` S) = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Inf (f ` S) \\<in> f ` S", "obtain x where \"x \\<in> S\" \"(INF x\\<in> S. f x) = f x\""], ["proof (prove)\nusing this:\n  Inf (f ` S) \\<in> f ` S\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; Inf (f ` S) = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n  Inf (f ` S) = f x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; Inf (f ` S) = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  x \\<in> S\n  Inf (f ` S) = f x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> S\n  Inf (f ` S) = f x\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enat_less_INF_I:\n  fixes f :: \"'a \\<Rightarrow> enat\"\n  assumes not_inf: \"x \\<noteq> \\<infinity>\" and less: \"\\<And>y. y \\<in> S \\<Longrightarrow> x < f y\"\n  shows \"x < (INF y\\<in>S. f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < Inf (f ` S)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<infinity>\n  ?y \\<in> S \\<Longrightarrow> x < f ?y\n\ngoal (1 subgoal):\n 1. x < Inf (f ` S)", "by (auto simp: Suc_ile_eq[symmetric] INF_greatest)"], ["", "lemma enat_le_Sup_iff:\n  \"enat k \\<le> Sup M \\<longleftrightarrow> k = 0 \\<or> (\\<exists>m \\<in> M. enat k \\<le> m)\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))\n 2. \\<not> ?P \\<Longrightarrow>\n    (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))", "assume \"k = 0\""], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))\n 2. \\<not> ?P \\<Longrightarrow>\n    (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))", "then"], ["proof (chain)\npicking this:\n  k = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))", "by (auto simp: enat_0)"], ["proof (state)\nthis:\n  (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))", "assume \"k \\<noteq> 0\""], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. enat k \\<le> Sup M \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)\n 2. k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m) \\<Longrightarrow>\n    enat k \\<le> Sup M", "assume ?L"], ["proof (state)\nthis:\n  enat k \\<le> Sup M\n\ngoal (2 subgoals):\n 1. enat k \\<le> Sup M \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)\n 2. k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m) \\<Longrightarrow>\n    enat k \\<le> Sup M", "then"], ["proof (chain)\npicking this:\n  enat k \\<le> Sup M", "have \"\\<lbrakk>enat k \\<le> (if finite M then Max M else \\<infinity>); M \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>m\\<in>M. enat k \\<le> m\""], ["proof (prove)\nusing this:\n  enat k \\<le> Sup M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enat k \\<le> (if finite M then Max M else \\<infinity>);\n     M \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>M. enat k \\<le> m", "by (metis Max_in Sup_enat_def finite_enat_bounded linorder_linear)"], ["proof (state)\nthis:\n  \\<lbrakk>enat k \\<le> (if finite M then Max M else \\<infinity>);\n   M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>M. enat k \\<le> m\n\ngoal (2 subgoals):\n 1. enat k \\<le> Sup M \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)\n 2. k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m) \\<Longrightarrow>\n    enat k \\<le> Sup M", "with \\<open>k \\<noteq> 0\\<close> and \\<open>?L\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  enat k \\<le> Sup M\n  \\<lbrakk>enat k \\<le> (if finite M then Max M else \\<infinity>);\n   M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>M. enat k \\<le> m", "show ?R"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  enat k \\<le> Sup M\n  \\<lbrakk>enat k \\<le> (if finite M then Max M else \\<infinity>);\n   M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>M. enat k \\<le> m\n\ngoal (1 subgoal):\n 1. k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)", "unfolding Sup_enat_def"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  enat k\n  \\<le> (if M = {} then 0 else if finite M then Max M else \\<infinity>)\n  \\<lbrakk>enat k \\<le> (if finite M then Max M else \\<infinity>);\n   M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>M. enat k \\<le> m\n\ngoal (1 subgoal):\n 1. k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)", "by (cases \"M={}\") (auto simp add: enat_0[symmetric])"], ["proof (state)\nthis:\n  k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)\n\ngoal (1 subgoal):\n 1. k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m) \\<Longrightarrow>\n    enat k \\<le> Sup M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m) \\<Longrightarrow>\n    enat k \\<le> Sup M", "assume ?R"], ["proof (state)\nthis:\n  k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)\n\ngoal (1 subgoal):\n 1. k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m) \\<Longrightarrow>\n    enat k \\<le> Sup M", "then"], ["proof (chain)\npicking this:\n  k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)", "show ?L"], ["proof (prove)\nusing this:\n  k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m)\n\ngoal (1 subgoal):\n 1. enat k \\<le> Sup M", "by (auto simp: enat_0 intro: complete_lattice_class.Sup_upper2)"], ["proof (state)\nthis:\n  enat k \\<le> Sup M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (enat k \\<le> Sup M) = (k = 0 \\<or> (\\<exists>m\\<in>M. enat k \\<le> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enat_neq_zero_cancel_iff[simp]:\n  \"0 \\<noteq> enat n \\<longleftrightarrow> 0 \\<noteq> n\"\n  \"enat n \\<noteq> 0 \\<longleftrightarrow> n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<noteq> enat n) = (0 \\<noteq> n) &&&\n    (enat n \\<noteq> 0) = (n \\<noteq> 0)", "by (auto simp: enat_0[symmetric])"], ["", "lemma natceiling_lessD: \"nat(ceiling x) < n \\<Longrightarrow> x < real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>x\\<rceil> < n \\<Longrightarrow> x < real n", "by linarith"], ["", "lemma le_natceiling_iff:\n  fixes n :: nat and r :: real\n  shows \"n \\<le> r \\<Longrightarrow> n \\<le> nat(ceiling r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n \\<le> r \\<Longrightarrow> n \\<le> nat \\<lceil>r\\<rceil>", "by linarith"], ["", "lemma natceiling_le_iff:\n  fixes n :: nat and r :: real\n  shows \"r \\<le> n \\<Longrightarrow> nat(ceiling r) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> real n \\<Longrightarrow> nat \\<lceil>r\\<rceil> \\<le> n", "by linarith"], ["", "lemma dist_real_noabs_less:\n  fixes a b c :: real assumes \"dist a b < c\" shows \"a - b < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b < c", "using assms"], ["proof (prove)\nusing this:\n  dist a b < c\n\ngoal (1 subgoal):\n 1. a - b < c", "by (simp add: dist_real_def)"], ["", "lemma n_choose_2_nat:\n  fixes n :: nat shows \"(n choose 2) = (n * (n - 1)) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n choose 2 = n * (n - 1) div 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n choose 2 = n * (n - 1) div 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n choose 2 = n * (n - 1) div 2", "proof (cases \"2 \\<le> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2\n 2. \\<not> 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2", "case True"], ["proof (state)\nthis:\n  2 \\<le> n\n\ngoal (2 subgoals):\n 1. 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2\n 2. \\<not> 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2", "then"], ["proof (chain)\npicking this:\n  2 \\<le> n", "obtain m where \"n = Suc (Suc m)\""], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc (Suc m) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add_Suc le_Suc_ex numeral_2_eq_2)"], ["proof (state)\nthis:\n  n = Suc (Suc m)\n\ngoal (2 subgoals):\n 1. 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2\n 2. \\<not> 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2", "moreover"], ["proof (state)\nthis:\n  n = Suc (Suc m)\n\ngoal (2 subgoals):\n 1. 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2\n 2. \\<not> 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2", "have \"(n choose 2) = (fact n div fact (n - 2)) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n choose 2 = fact n div fact (n - 2) div 2", "using \\<open>2 \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. n choose 2 = fact n div fact (n - 2) div 2", "by (simp add: binomial_altdef_nat\n        div_mult2_eq[symmetric] mult.commute numeral_2_eq_2)"], ["proof (state)\nthis:\n  n choose 2 = fact n div fact (n - 2) div 2\n\ngoal (2 subgoals):\n 1. 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2\n 2. \\<not> 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2", "ultimately"], ["proof (chain)\npicking this:\n  n = Suc (Suc m)\n  n choose 2 = fact n div fact (n - 2) div 2", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Suc (Suc m)\n  n choose 2 = fact n div fact (n - 2) div 2\n\ngoal (1 subgoal):\n 1. n choose 2 = n * (n - 1) div 2", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  n choose 2 = n * (n - 1) div 2\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> n \\<Longrightarrow> n choose 2 = n * (n - 1) div 2", "qed (auto simp: binomial_eq_0)"], ["proof (state)\nthis:\n  n choose 2 = n * (n - 1) div 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_less_one:\n  fixes x::real\n  assumes \"1 < x\" \"y < 0\"\n  shows \"x powr y < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x powr y < 1", "using assms less_log_iff"], ["proof (prove)\nusing this:\n  1 < x\n  y < 0\n  \\<lbrakk>1 < ?b; 0 < ?x\\<rbrakk>\n  \\<Longrightarrow> (?y < log ?b ?x) = (?b powr ?y < ?x)\n\ngoal (1 subgoal):\n 1. x powr y < 1", "by force"], ["", "lemma powr_le_one_le: \"\\<And>x y::real. 0 < x \\<Longrightarrow> x \\<le> 1 \\<Longrightarrow> 1 \\<le> y \\<Longrightarrow> x powr y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "fix x y :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "assume \"0 < x\" \"x \\<le> 1\" \"1 \\<le> y\""], ["proof (state)\nthis:\n  0 < x\n  x \\<le> 1\n  1 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "have \"x powr y = (1 / (1 / x)) powr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x powr y = (1 / (1 / x)) powr y", "using \\<open>0 < x\\<close>"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. x powr y = (1 / (1 / x)) powr y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x powr y = (1 / (1 / x)) powr y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "also"], ["proof (state)\nthis:\n  x powr y = (1 / (1 / x)) powr y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "have \"\\<dots> = 1 / (1 / x) powr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / (1 / x)) powr y = 1 / (1 / x) powr y", "using \\<open>0 < x\\<close>"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. (1 / (1 / x)) powr y = 1 / (1 / x) powr y", "by (simp add: powr_divide)"], ["proof (state)\nthis:\n  (1 / (1 / x)) powr y = 1 / (1 / x) powr y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "also"], ["proof (state)\nthis:\n  (1 / (1 / x)) powr y = 1 / (1 / x) powr y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "have \"\\<dots> \\<le> 1 / (1 / x) powr 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (1 / x) powr y \\<le> 1 / (1 / x) powr 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 / (1 / x) powr y \\<le> 1 / (1 / x) powr 1", "have \"1 \\<le> 1 / x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> 1 / x", "using \\<open>0 < x\\<close> \\<open>x \\<le> 1\\<close>"], ["proof (prove)\nusing this:\n  0 < x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> 1 / x", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  1 \\<le> 1 / x\n\ngoal (1 subgoal):\n 1. 1 / (1 / x) powr y \\<le> 1 / (1 / x) powr 1", "then"], ["proof (chain)\npicking this:\n  1 \\<le> 1 / x", "have \"(1 / x) powr 1  \\<le> (1 / x) powr y\""], ["proof (prove)\nusing this:\n  1 \\<le> 1 / x\n\ngoal (1 subgoal):\n 1. (1 / x) powr 1 \\<le> (1 / x) powr y", "using \\<open>0 < x\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> 1 / x\n  0 < x\n\ngoal (1 subgoal):\n 1. (1 / x) powr 1 \\<le> (1 / x) powr y", "using \\<open>1 \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> 1 / x\n  0 < x\n  1 \\<le> y\n\ngoal (1 subgoal):\n 1. (1 / x) powr 1 \\<le> (1 / x) powr y", "by ( simp only: powr_mono)"], ["proof (state)\nthis:\n  (1 / x) powr 1 \\<le> (1 / x) powr y\n\ngoal (1 subgoal):\n 1. 1 / (1 / x) powr y \\<le> 1 / (1 / x) powr 1", "then"], ["proof (chain)\npicking this:\n  (1 / x) powr 1 \\<le> (1 / x) powr y", "show ?thesis"], ["proof (prove)\nusing this:\n  (1 / x) powr 1 \\<le> (1 / x) powr y\n\ngoal (1 subgoal):\n 1. 1 / (1 / x) powr y \\<le> 1 / (1 / x) powr 1", "by (metis \\<open>1 \\<le> 1 / x\\<close> \\<open>1 \\<le> y\\<close> neg_le_iff_le powr_minus_divide powr_mono)"], ["proof (state)\nthis:\n  1 / (1 / x) powr y \\<le> 1 / (1 / x) powr 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 / (1 / x) powr y \\<le> 1 / (1 / x) powr 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "also"], ["proof (state)\nthis:\n  1 / (1 / x) powr y \\<le> 1 / (1 / x) powr 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (1 / x) powr 1 \\<le> x", "using \\<open>0 < x\\<close>"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. 1 / (1 / x) powr 1 \\<le> x", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  1 / (1 / x) powr 1 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> 1; 1 \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x powr y \\<le> x", "finally"], ["proof (chain)\npicking this:\n  x powr y \\<le> x", "show \"?thesis x y\""], ["proof (prove)\nusing this:\n  x powr y \\<le> x\n\ngoal (1 subgoal):\n 1. x powr y \\<le> x", "."], ["proof (state)\nthis:\n  x powr y \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lists and Sets\\<close>"], ["", "lemma list_set_tl: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs", "by (cases xs) auto"], ["", "lemma list_exhaust3:\n  obtains \"xs = []\" | x where \"xs = [x]\" | x y ys where \"xs = x # y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = [] \\<Longrightarrow> thesis;\n     \\<And>x. xs = [x] \\<Longrightarrow> thesis;\n     \\<And>x y ys. xs = x # y # ys \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis list.exhaust)"], ["", "lemma card_Ex_subset:\n  \"k \\<le> card M \\<Longrightarrow> \\<exists>N. N \\<subseteq> M \\<and> card N = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> card M \\<Longrightarrow> \\<exists>N\\<subseteq>M. card N = k", "by (induct rule: inc_induct) (auto simp: card_Suc_eq)"], ["", "subsection \\<open>Limits and eventually\\<close>"], ["", "text \\<open>\n  We employ filters and the @{term eventually} predicate to deal with the\n  @{term \"\\<exists>N. \\<forall>n\\<ge>N. P n\"} cases. To make this more convenient, introduce\n  a shorter syntax.\n\\<close>"], ["", "abbreviation evseq :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> bool\" (binder \"\\<forall>\\<^sup>\\<infinity>\" 10) where\n  \"evseq P \\<equiv> eventually P sequentially\""], ["", "lemma eventually_le_le:\n  fixes P :: \"'a => ('b :: preorder)\"\n  assumes \"eventually (\\<lambda>x. P x \\<le> Q x) net\"\n  assumes \"eventually (\\<lambda>x. Q x \\<le> R  x) net\"\n  shows \"eventually (\\<lambda>x. P x \\<le> R x) net\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in net. P x \\<le> R x", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in net. P x \\<le> Q x\n  \\<forall>\\<^sub>F x in net. Q x \\<le> R x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in net. P x \\<le> R x", "by eventually_elim (rule order_trans)"], ["", "lemma LIMSEQ_neg_powr:\n  assumes s: \"s < 0\"\n  shows \"(%x. (real x) powr s) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x powr s) \\<longlonglongrightarrow> 0", "by (rule tendsto_neg_powr[OF assms filterlim_real_sequentially])"], ["", "lemma LIMSEQ_inv_powr:\n  assumes \"0 < c\" \"0 < d\"\n  shows \"(\\<lambda>n :: nat. (c / n) powr d) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (c / real n) powr d) \\<longlonglongrightarrow> 0", "proof (rule tendsto_zero_powrI)"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<lambda>x. c / real x) \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. d) \\<longlonglongrightarrow> ?b\n 3. \\<forall>\\<^sup>\\<infinity>n. 0 \\<le> c / real n\n 4. 0 < ?b", "from \\<open>0 < c\\<close>"], ["proof (chain)\npicking this:\n  0 < c", "have \"\\<And>x. 0 < x \\<Longrightarrow> 0 < c / x\""], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> 0 < c / x", "by simp"], ["proof (state)\nthis:\n  0 < ?x \\<Longrightarrow> 0 < c / ?x\n\ngoal (4 subgoals):\n 1. (\\<lambda>x. c / real x) \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. d) \\<longlonglongrightarrow> ?b\n 3. \\<forall>\\<^sup>\\<infinity>n. 0 \\<le> c / real n\n 4. 0 < ?b", "then"], ["proof (chain)\npicking this:\n  0 < ?x \\<Longrightarrow> 0 < c / ?x", "show \"\\<forall>\\<^sup>\\<infinity>n. 0 \\<le> c / real n\""], ["proof (prove)\nusing this:\n  0 < ?x \\<Longrightarrow> 0 < c / ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. 0 \\<le> c / real n", "using assms(1)"], ["proof (prove)\nusing this:\n  0 < ?x \\<Longrightarrow> 0 < c / ?x\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. 0 \\<le> c / real n", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n. 0 \\<le> c / real n\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. c / real x) \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. d) \\<longlonglongrightarrow> ?b\n 3. 0 < ?b", "show \"(\\<lambda>x. c / real x) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. c / real x) \\<longlonglongrightarrow> 0", "by (intro tendsto_divide_0[OF tendsto_const] filterlim_at_top_imp_at_infinity\n              filterlim_real_sequentially tendsto_divide_0)"], ["proof (state)\nthis:\n  (\\<lambda>x. c / real x) \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. d) \\<longlonglongrightarrow> ?b\n 2. 0 < ?b", "show \"0 < d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d", "by (rule assms)"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. d) \\<longlonglongrightarrow> d", "show \"(\\<lambda>x. d) \\<longlonglongrightarrow> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. d) \\<longlonglongrightarrow> d", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. d) \\<longlonglongrightarrow> d\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}