{"file_name": "/home/qj213/afp-2021-10-22/thys/Girth_Chromatic/Ugraphs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Girth_Chromatic", "problem_names": ["lemma uwalk_length_conv: \"uwalk_length p = length p - 1\"", "lemma all_edges_mono:\n  \"vs \\<subseteq> ws \\<Longrightarrow> all_edges vs \\<subseteq> all_edges ws\"", "lemma all_edges_subset_Pow: \"all_edges A \\<subseteq> Pow A\"", "lemma in_mk_uedge_img: \"(a,b) \\<in> A \\<or> (b,a) \\<in> A \\<Longrightarrow> {a,b} \\<in> mk_uedge ` A\"", "lemma distinct_edgesI:\n  assumes \"distinct p\" shows \"distinct (uwalk_edges p)\"", "lemma finite_ucycles:\n  assumes \"finite (uverts G)\"\n  shows \"finite (ucycles G)\"", "lemma ucycles_distinct_edges:\n  assumes \"c \\<in> ucycles G\" shows \"distinct (uwalk_edges c)\"", "lemma card_left_less_pair:\n  fixes A :: \"('a :: linorder) set\"\n  assumes \"finite A\"\n  shows \"card {(a,b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n    = (card A * (card A - 1)) div 2\"", "lemma card_all_edges:\n  assumes \"finite A\"\n  shows \"card (all_edges A) = card A choose 2\"", "lemma verts_Gu: \"uverts (G -- u) = uverts G - {u}\"", "lemma edges_Gu: \"uedges (G -- u) \\<subseteq> uedges G\"", "lemma independent_sets_mono:\n  \"vs \\<in> independent_sets G \\<Longrightarrow> us \\<subseteq> vs \\<Longrightarrow> us \\<in> independent_sets G\"", "lemma le_\\<alpha>_iff:\n  assumes \"0 < k\"\n  shows \"k \\<le> \\<alpha> Gr \\<longleftrightarrow> k \\<in> card ` independent_sets Gr\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma zero_less_\\<alpha>:\n  assumes \"uverts G \\<noteq> {}\"\n  shows \"0 < \\<alpha> G\"", "lemma \\<alpha>_le_card:\n  assumes \"finite (uverts G)\"\n  shows \"\\<alpha> G \\<le> card(uverts G)\"", "lemma \\<alpha>_fin: \"finite (uverts G) \\<Longrightarrow> \\<alpha> G \\<noteq> \\<infinity>\"", "lemma \\<alpha>_remove_le:\n  shows \"\\<alpha> (G -- u) \\<le> \\<alpha> G\"", "lemma chromatic_lb:\n  assumes wf_G: \"uwellformed G\"\n    and fin_G: \"finite (uverts G)\"\n    and neG: \"uverts G \\<noteq> {}\"\n  shows \"card (uverts G) / \\<alpha> G \\<le> chromatic_number G\""], "translations": [["", "lemma uwalk_length_conv: \"uwalk_length p = length p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uwalk_length p = length p - 1", "by (induct p rule: uwalk_edges.induct) (auto simp: uwalk_length_def)"], ["", "lemma all_edges_mono:\n  \"vs \\<subseteq> ws \\<Longrightarrow> all_edges vs \\<subseteq> all_edges ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<subseteq> ws \\<Longrightarrow>\n    all_edges vs \\<subseteq> all_edges ws", "unfolding all_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<subseteq> ws \\<Longrightarrow>\n    mk_uedge ` {uv \\<in> vs \\<times> vs. fst uv \\<noteq> snd uv}\n    \\<subseteq> mk_uedge ` {uv \\<in> ws \\<times> ws. fst uv \\<noteq> snd uv}", "by auto"], ["", "lemma all_edges_subset_Pow: \"all_edges A \\<subseteq> Pow A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_edges A \\<subseteq> Pow A", "by (auto simp: all_edges_def)"], ["", "lemma in_mk_uedge_img: \"(a,b) \\<in> A \\<or> (b,a) \\<in> A \\<Longrightarrow> {a,b} \\<in> mk_uedge ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> A \\<or> (b, a) \\<in> A \\<Longrightarrow>\n    {a, b} \\<in> mk_uedge ` A", "by (auto intro: rev_image_eqI)"], ["", "lemma distinct_edgesI:\n  assumes \"distinct p\" shows \"distinct (uwalk_edges p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (uwalk_edges p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (uwalk_edges p)", "from assms"], ["proof (chain)\npicking this:\n  distinct p", "have \"?thesis\" \"\\<And>u. u \\<notin> set p \\<Longrightarrow> (\\<And>v. u \\<noteq> v \\<Longrightarrow> {u,v} \\<notin> set (uwalk_edges p))\""], ["proof (prove)\nusing this:\n  distinct p\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges p) &&&\n    (\\<And>u.\n        u \\<notin> set p \\<Longrightarrow>\n        (\\<And>v.\n            u \\<noteq> v \\<Longrightarrow>\n            {u, v} \\<notin> set (uwalk_edges p)))", "by (induct p rule: uwalk_edges.induct) auto"], ["proof (state)\nthis:\n  distinct (uwalk_edges p)\n  \\<lbrakk>?u \\<notin> set p; ?u \\<noteq> ?v\\<rbrakk>\n  \\<Longrightarrow> {?u, ?v} \\<notin> set (uwalk_edges p)\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges p)", "then"], ["proof (chain)\npicking this:\n  distinct (uwalk_edges p)\n  \\<lbrakk>?u \\<notin> set p; ?u \\<noteq> ?v\\<rbrakk>\n  \\<Longrightarrow> {?u, ?v} \\<notin> set (uwalk_edges p)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (uwalk_edges p)\n  \\<lbrakk>?u \\<notin> set p; ?u \\<noteq> ?v\\<rbrakk>\n  \\<Longrightarrow> {?u, ?v} \\<notin> set (uwalk_edges p)\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges p)", "by simp"], ["proof (state)\nthis:\n  distinct (uwalk_edges p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ucycles:\n  assumes \"finite (uverts G)\"\n  shows \"finite (ucycles G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (ucycles G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (ucycles G)", "have \"ucycles G \\<subseteq> {xs. set xs \\<subseteq> uverts G \\<and> length xs \\<le> Suc (card (uverts G))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ucycles G\n    \\<subseteq> {xs.\n                 set xs \\<subseteq> uverts G \\<and>\n                 length xs \\<le> Suc (card (uverts G))}", "proof (rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ucycles G \\<Longrightarrow>\n       set x \\<subseteq> uverts G \\<and>\n       length x \\<le> Suc (card (uverts G))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ucycles G \\<Longrightarrow>\n       set x \\<subseteq> uverts G \\<and>\n       length x \\<le> Suc (card (uverts G))", "assume \"p \\<in> ucycles G\""], ["proof (state)\nthis:\n  p \\<in> ucycles G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ucycles G \\<Longrightarrow>\n       set x \\<subseteq> uverts G \\<and>\n       length x \\<le> Suc (card (uverts G))", "then"], ["proof (chain)\npicking this:\n  p \\<in> ucycles G", "have \"distinct (tl p)\" and \"set p \\<subseteq> uverts G\""], ["proof (prove)\nusing this:\n  p \\<in> ucycles G\n\ngoal (1 subgoal):\n 1. distinct (tl p) &&& set p \\<subseteq> uverts G", "unfolding ucycles_def uwalks_def"], ["proof (prove)\nusing this:\n  p \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n              p \\<in> {p. set p \\<subseteq> uverts G \\<and>\n                          set (uwalk_edges p) \\<subseteq> uedges G \\<and>\n                          p \\<noteq> []} \\<and>\n              distinct (tl p) \\<and> hd p = last p}\n\ngoal (1 subgoal):\n 1. distinct (tl p) &&& set p \\<subseteq> uverts G", "by auto"], ["proof (state)\nthis:\n  distinct (tl p)\n  set p \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ucycles G \\<Longrightarrow>\n       set x \\<subseteq> uverts G \\<and>\n       length x \\<le> Suc (card (uverts G))", "moreover"], ["proof (state)\nthis:\n  distinct (tl p)\n  set p \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ucycles G \\<Longrightarrow>\n       set x \\<subseteq> uverts G \\<and>\n       length x \\<le> Suc (card (uverts G))", "then"], ["proof (chain)\npicking this:\n  distinct (tl p)\n  set p \\<subseteq> uverts G", "have \"set (tl p) \\<subseteq> uverts G\""], ["proof (prove)\nusing this:\n  distinct (tl p)\n  set p \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> uverts G", "by (auto simp: list_set_tl)"], ["proof (state)\nthis:\n  set (tl p) \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ucycles G \\<Longrightarrow>\n       set x \\<subseteq> uverts G \\<and>\n       length x \\<le> Suc (card (uverts G))", "with assms"], ["proof (chain)\npicking this:\n  finite (uverts G)\n  set (tl p) \\<subseteq> uverts G", "have \"card (set (tl p)) \\<le> card (uverts G)\""], ["proof (prove)\nusing this:\n  finite (uverts G)\n  set (tl p) \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. card (set (tl p)) \\<le> card (uverts G)", "by (rule card_mono)"], ["proof (state)\nthis:\n  card (set (tl p)) \\<le> card (uverts G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ucycles G \\<Longrightarrow>\n       set x \\<subseteq> uverts G \\<and>\n       length x \\<le> Suc (card (uverts G))", "then"], ["proof (chain)\npicking this:\n  card (set (tl p)) \\<le> card (uverts G)", "have \"length (p) \\<le> 1 + card (uverts G)\""], ["proof (prove)\nusing this:\n  card (set (tl p)) \\<le> card (uverts G)\n\ngoal (1 subgoal):\n 1. length p \\<le> 1 + card (uverts G)", "using distinct_card[OF \\<open>distinct (tl p)\\<close>]"], ["proof (prove)\nusing this:\n  card (set (tl p)) \\<le> card (uverts G)\n  card (set (tl p)) = length (tl p)\n\ngoal (1 subgoal):\n 1. length p \\<le> 1 + card (uverts G)", "by auto"], ["proof (state)\nthis:\n  length p \\<le> 1 + card (uverts G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ucycles G \\<Longrightarrow>\n       set x \\<subseteq> uverts G \\<and>\n       length x \\<le> Suc (card (uverts G))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (tl p)\n  set p \\<subseteq> uverts G\n  length p \\<le> 1 + card (uverts G)", "show \"set p \\<subseteq> uverts G \\<and> length p \\<le> Suc (card (uverts G))\""], ["proof (prove)\nusing this:\n  distinct (tl p)\n  set p \\<subseteq> uverts G\n  length p \\<le> 1 + card (uverts G)\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> uverts G \\<and> length p \\<le> Suc (card (uverts G))", "by auto"], ["proof (state)\nthis:\n  set p \\<subseteq> uverts G \\<and> length p \\<le> Suc (card (uverts G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ucycles G\n  \\<subseteq> {xs.\n               set xs \\<subseteq> uverts G \\<and>\n               length xs \\<le> Suc (card (uverts G))}\n\ngoal (1 subgoal):\n 1. finite (ucycles G)", "moreover"], ["proof (state)\nthis:\n  ucycles G\n  \\<subseteq> {xs.\n               set xs \\<subseteq> uverts G \\<and>\n               length xs \\<le> Suc (card (uverts G))}\n\ngoal (1 subgoal):\n 1. finite (ucycles G)", "have \"finite {xs. set xs \\<subseteq> uverts G \\<and> length xs \\<le> Suc (card (uverts G))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {xs.\n      set xs \\<subseteq> uverts G \\<and>\n      length xs \\<le> Suc (card (uverts G))}", "using assms"], ["proof (prove)\nusing this:\n  finite (uverts G)\n\ngoal (1 subgoal):\n 1. finite\n     {xs.\n      set xs \\<subseteq> uverts G \\<and>\n      length xs \\<le> Suc (card (uverts G))}", "by (rule finite_lists_length_le)"], ["proof (state)\nthis:\n  finite\n   {xs.\n    set xs \\<subseteq> uverts G \\<and>\n    length xs \\<le> Suc (card (uverts G))}\n\ngoal (1 subgoal):\n 1. finite (ucycles G)", "ultimately"], ["proof (chain)\npicking this:\n  ucycles G\n  \\<subseteq> {xs.\n               set xs \\<subseteq> uverts G \\<and>\n               length xs \\<le> Suc (card (uverts G))}\n  finite\n   {xs.\n    set xs \\<subseteq> uverts G \\<and>\n    length xs \\<le> Suc (card (uverts G))}", "show ?thesis"], ["proof (prove)\nusing this:\n  ucycles G\n  \\<subseteq> {xs.\n               set xs \\<subseteq> uverts G \\<and>\n               length xs \\<le> Suc (card (uverts G))}\n  finite\n   {xs.\n    set xs \\<subseteq> uverts G \\<and>\n    length xs \\<le> Suc (card (uverts G))}\n\ngoal (1 subgoal):\n 1. finite (ucycles G)", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite (ucycles G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ucycles_distinct_edges:\n  assumes \"c \\<in> ucycles G\" shows \"distinct (uwalk_edges c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (uwalk_edges c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (uwalk_edges c)", "from assms"], ["proof (chain)\npicking this:\n  c \\<in> ucycles G", "have c_props: \"distinct (tl c)\" \"4 \\<le> length c\" \"hd c = last c\""], ["proof (prove)\nusing this:\n  c \\<in> ucycles G\n\ngoal (1 subgoal):\n 1. distinct (tl c) &&& 4 \\<le> length c &&& hd c = last c", "by (auto simp add: ucycles_def uwalk_length_conv)"], ["proof (state)\nthis:\n  distinct (tl c)\n  4 \\<le> length c\n  hd c = last c\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges c)", "then"], ["proof (chain)\npicking this:\n  distinct (tl c)\n  4 \\<le> length c\n  hd c = last c", "have \"{hd c, hd (tl c)} \\<notin> set (uwalk_edges (tl c))\""], ["proof (prove)\nusing this:\n  distinct (tl c)\n  4 \\<le> length c\n  hd c = last c\n\ngoal (1 subgoal):\n 1. {hd c, hd (tl c)} \\<notin> set (uwalk_edges (tl c))", "proof (induct c rule: uwalk_edges.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "case (3 x y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n   hd (y # ys) = last (y # ys)\\<rbrakk>\n  \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                    \\<notin> set (uwalk_edges (tl (y # ys)))\n  distinct (tl (x # y # ys))\n  4 \\<le> length (x # y # ys)\n  hd (x # y # ys) = last (x # y # ys)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n   hd (y # ys) = last (y # ys)\\<rbrakk>\n  \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                    \\<notin> set (uwalk_edges (tl (y # ys)))\n  distinct (tl (x # y # ys))\n  4 \\<le> length (x # y # ys)\n  hd (x # y # ys) = last (x # y # ys)", "have \"hd ys \\<noteq> last ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n   hd (y # ys) = last (y # ys)\\<rbrakk>\n  \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                    \\<notin> set (uwalk_edges (tl (y # ys)))\n  distinct (tl (x # y # ys))\n  4 \\<le> length (x # y # ys)\n  hd (x # y # ys) = last (x # y # ys)\n\ngoal (1 subgoal):\n 1. hd ys \\<noteq> last ys", "by (cases ys) auto"], ["proof (state)\nthis:\n  hd ys \\<noteq> last ys\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "moreover"], ["proof (state)\nthis:\n  hd ys \\<noteq> last ys\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n   hd (y # ys) = last (y # ys)\\<rbrakk>\n  \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                    \\<notin> set (uwalk_edges (tl (y # ys)))\n  distinct (tl (x # y # ys))\n  4 \\<le> length (x # y # ys)\n  hd (x # y # ys) = last (x # y # ys)", "have \"uwalk_edges (y # ys) = {y, hd ys} # uwalk_edges ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n   hd (y # ys) = last (y # ys)\\<rbrakk>\n  \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                    \\<notin> set (uwalk_edges (tl (y # ys)))\n  distinct (tl (x # y # ys))\n  4 \\<le> length (x # y # ys)\n  hd (x # y # ys) = last (x # y # ys)\n\ngoal (1 subgoal):\n 1. uwalk_edges (y # ys) = {y, hd ys} # uwalk_edges ys", "by (cases ys) auto"], ["proof (state)\nthis:\n  uwalk_edges (y # ys) = {y, hd ys} # uwalk_edges ys\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "moreover"], ["proof (state)\nthis:\n  uwalk_edges (y # ys) = {y, hd ys} # uwalk_edges ys\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "{"], ["proof (state)\nthis:\n  uwalk_edges (y # ys) = {y, hd ys} # uwalk_edges ys\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "fix xs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "have \"set (uwalk_edges xs) \\<subseteq> Pow (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (uwalk_edges xs) \\<subseteq> Pow (set xs)", "by (induct xs rule: uwalk_edges.induct) auto"], ["proof (state)\nthis:\n  set (uwalk_edges xs) \\<subseteq> Pow (set xs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "}"], ["proof (state)\nthis:\n  set (uwalk_edges ?xs2) \\<subseteq> Pow (set ?xs2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n                 hd (y # ys) = last (y # ys)\\<rbrakk>\n                \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                                  \\<notin> set (uwalk_edges (tl (y # ys)));\n        distinct (tl (x # y # ys)); 4 \\<le> length (x # y # ys);\n        hd (x # y # ys) = last (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> {hd (x # y # ys), hd (tl (x # y # ys))}\n                         \\<notin> set (uwalk_edges (tl (x # y # ys)))", "ultimately"], ["proof (chain)\npicking this:\n  hd ys \\<noteq> last ys\n  uwalk_edges (y # ys) = {y, hd ys} # uwalk_edges ys\n  set (uwalk_edges ?xs2) \\<subseteq> Pow (set ?xs2)", "show ?case"], ["proof (prove)\nusing this:\n  hd ys \\<noteq> last ys\n  uwalk_edges (y # ys) = {y, hd ys} # uwalk_edges ys\n  set (uwalk_edges ?xs2) \\<subseteq> Pow (set ?xs2)\n\ngoal (1 subgoal):\n 1. {hd (x # y # ys), hd (tl (x # y # ys))}\n    \\<notin> set (uwalk_edges (tl (x # y # ys)))", "using 3"], ["proof (prove)\nusing this:\n  hd ys \\<noteq> last ys\n  uwalk_edges (y # ys) = {y, hd ys} # uwalk_edges ys\n  set (uwalk_edges ?xs2) \\<subseteq> Pow (set ?xs2)\n  \\<lbrakk>distinct (tl (y # ys)); 4 \\<le> length (y # ys);\n   hd (y # ys) = last (y # ys)\\<rbrakk>\n  \\<Longrightarrow> {hd (y # ys), hd (tl (y # ys))}\n                    \\<notin> set (uwalk_edges (tl (y # ys)))\n  distinct (tl (x # y # ys))\n  4 \\<le> length (x # y # ys)\n  hd (x # y # ys) = last (x # y # ys)\n\ngoal (1 subgoal):\n 1. {hd (x # y # ys), hd (tl (x # y # ys))}\n    \\<notin> set (uwalk_edges (tl (x # y # ys)))", "by auto"], ["proof (state)\nthis:\n  {hd (x # y # ys), hd (tl (x # y # ys))}\n  \\<notin> set (uwalk_edges (tl (x # y # ys)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (tl []); 4 \\<le> length []; hd [] = last []\\<rbrakk>\n    \\<Longrightarrow> {hd [], hd (tl [])} \\<notin> set (uwalk_edges (tl []))\n 2. \\<And>x.\n       \\<lbrakk>distinct (tl [x]); 4 \\<le> length [x];\n        hd [x] = last [x]\\<rbrakk>\n       \\<Longrightarrow> {hd [x], hd (tl [x])}\n                         \\<notin> set (uwalk_edges (tl [x]))", "qed simp_all"], ["proof (state)\nthis:\n  {hd c, hd (tl c)} \\<notin> set (uwalk_edges (tl c))\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges c)", "moreover"], ["proof (state)\nthis:\n  {hd c, hd (tl c)} \\<notin> set (uwalk_edges (tl c))\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges c)", "from assms"], ["proof (chain)\npicking this:\n  c \\<in> ucycles G", "have \"distinct (uwalk_edges (tl c))\""], ["proof (prove)\nusing this:\n  c \\<in> ucycles G\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges (tl c))", "by (intro distinct_edgesI) (simp add: ucycles_def)"], ["proof (state)\nthis:\n  distinct (uwalk_edges (tl c))\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges c)", "ultimately"], ["proof (chain)\npicking this:\n  {hd c, hd (tl c)} \\<notin> set (uwalk_edges (tl c))\n  distinct (uwalk_edges (tl c))", "show ?thesis"], ["proof (prove)\nusing this:\n  {hd c, hd (tl c)} \\<notin> set (uwalk_edges (tl c))\n  distinct (uwalk_edges (tl c))\n\ngoal (1 subgoal):\n 1. distinct (uwalk_edges c)", "by (cases c rule: list_exhaust3) auto"], ["proof (state)\nthis:\n  distinct (uwalk_edges c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_left_less_pair:\n  fixes A :: \"('a :: linorder) set\"\n  assumes \"finite A\"\n  shows \"card {(a,b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n    = (card A * (card A - 1)) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n    card A * (card A - 1) div 2", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n    card A * (card A - 1) div 2", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. card\n     {a. case a of\n         (a, b) \\<Rightarrow> a \\<in> {} \\<and> b \\<in> {} \\<and> a < b} =\n    card {} * (card {} - 1) div 2\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card\n         {a. case a of\n             (a, b) \\<Rightarrow> a \\<in> F \\<and> b \\<in> F \\<and> a < b} =\n        card F * (card F - 1) div 2\\<rbrakk>\n       \\<Longrightarrow> card\n                          {a. case a of\n                              (a, b) \\<Rightarrow>\n                                a \\<in> insert x F \\<and>\n                                b \\<in> insert x F \\<and> a < b} =\n                         card (insert x F) * (card (insert x F) - 1) div 2", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  card\n   {a. case a of\n       (a, b) \\<Rightarrow> a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n  card A * (card A - 1) div 2\n\ngoal (2 subgoals):\n 1. card\n     {a. case a of\n         (a, b) \\<Rightarrow> a \\<in> {} \\<and> b \\<in> {} \\<and> a < b} =\n    card {} * (card {} - 1) div 2\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card\n         {a. case a of\n             (a, b) \\<Rightarrow> a \\<in> F \\<and> b \\<in> F \\<and> a < b} =\n        card F * (card F - 1) div 2\\<rbrakk>\n       \\<Longrightarrow> card\n                          {a. case a of\n                              (a, b) \\<Rightarrow>\n                                a \\<in> insert x F \\<and>\n                                b \\<in> insert x F \\<and> a < b} =\n                         card (insert x F) * (card (insert x F) - 1) div 2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2", "proof (cases \"card A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "case (Suc n)"], ["proof (state)\nthis:\n  card A = Suc n\n\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "have \"{(a,b). a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b}\n        = {(a,b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<union> (\\<lambda>a. if a < x then (a,x) else (x,a)) ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<union>\n    (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A", "using \\<open>x \\<notin> A\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. {(a, b). a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<union>\n    (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A", "by (auto simp: order_less_le)"], ["proof (state)\nthis:\n  {(a, b). a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<union>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A\n\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "moreover"], ["proof (state)\nthis:\n  {(a, b). a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<union>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A\n\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "have \"finite {(a,b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}", "using insert"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  card\n   {a. case a of\n       (a, b) \\<Rightarrow> a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n  card A * (card A - 1) div 2\n\ngoal (1 subgoal):\n 1. finite {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}", "by (auto intro: finite_subset[of _ \"A \\<times> A\"])"], ["proof (state)\nthis:\n  finite {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "moreover"], ["proof (state)\nthis:\n  finite {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "have \"{(a,b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<inter> (\\<lambda>a. if a < x then (a,x) else (x,a)) ` A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<inter>\n    (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A =\n    {}", "using \\<open>x \\<notin> A\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<inter>\n    (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A =\n    {}", "by auto"], ["proof (state)\nthis:\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<inter>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A =\n  {}\n\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "moreover"], ["proof (state)\nthis:\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<inter>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A =\n  {}\n\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "have \"inj_on (\\<lambda>a. if a < x then (a, x) else (x, a)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>a. if a < x then (a, x) else (x, a)) A", "by (auto intro: inj_onI split: if_split_asm)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>a. if a < x then (a, x) else (x, a)) A\n\ngoal (2 subgoals):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2\n 2. \\<And>nat.\n       card A = Suc nat \\<Longrightarrow>\n       card\n        {a. case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n       card (insert x A) * (card (insert x A) - 1) div 2", "ultimately"], ["proof (chain)\npicking this:\n  {(a, b). a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<union>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A\n  finite {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<inter>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A =\n  {}\n  inj_on (\\<lambda>a. if a < x then (a, x) else (x, a)) A", "show ?thesis"], ["proof (prove)\nusing this:\n  {(a, b). a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<union>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A\n  finite {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<inter>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A =\n  {}\n  inj_on (\\<lambda>a. if a < x then (a, x) else (x, a)) A\n\ngoal (1 subgoal):\n 1. card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2", "using insert Suc"], ["proof (prove)\nusing this:\n  {(a, b). a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<union>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A\n  finite {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n  {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} \\<inter>\n  (\\<lambda>a. if a < x then (a, x) else (x, a)) ` A =\n  {}\n  inj_on (\\<lambda>a. if a < x then (a, x) else (x, a)) A\n  finite A\n  x \\<notin> A\n  card\n   {a. case a of\n       (a, b) \\<Rightarrow> a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n  card A * (card A - 1) div 2\n  card A = Suc n\n\ngoal (1 subgoal):\n 1. card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2", "by (simp add: card_Un_disjoint card_image del: if_image_distrib)"], ["proof (state)\nthis:\n  card\n   {a. case a of\n       (a, b) \\<Rightarrow>\n         a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n  card (insert x A) * (card (insert x A) - 1) div 2\n\ngoal (1 subgoal):\n 1. card A = 0 \\<Longrightarrow>\n    card\n     {a. case a of\n         (a, b) \\<Rightarrow>\n           a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n    card (insert x A) * (card (insert x A) - 1) div 2", "qed (simp add: card_eq_0_iff insert)"], ["proof (state)\nthis:\n  card\n   {a. case a of\n       (a, b) \\<Rightarrow>\n         a \\<in> insert x A \\<and> b \\<in> insert x A \\<and> a < b} =\n  card (insert x A) * (card (insert x A) - 1) div 2\n\ngoal (1 subgoal):\n 1. card\n     {a. case a of\n         (a, b) \\<Rightarrow> a \\<in> {} \\<and> b \\<in> {} \\<and> a < b} =\n    card {} * (card {} - 1) div 2", "qed simp"], ["", "lemma card_all_edges:\n  assumes \"finite A\"\n  shows \"card (all_edges A) = card A choose 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "have inj_on_mk_uedge: \"inj_on mk_uedge {(a,b). a < b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on mk_uedge {(a, b). a < b}", "by (rule inj_onI) (auto simp: doubleton_eq_iff)"], ["proof (state)\nthis:\n  inj_on mk_uedge {(a, b). a < b}\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "have \"all_edges A = mk_uedge ` {(a,b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_edges A =\n    mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}", "by (auto simp: all_edges_def intro!: in_mk_uedge_img)"], ["proof (state)\nthis:\n  all_edges A = mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "then"], ["proof (chain)\npicking this:\n  all_edges A = mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}", "have \"card ?L = card ?R\""], ["proof (prove)\nusing this:\n  all_edges A = mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n\ngoal (1 subgoal):\n 1. card (all_edges A) =\n    card (mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b})", "by simp"], ["proof (state)\nthis:\n  card (all_edges A) =\n  card (mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b})\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "also"], ["proof (state)\nthis:\n  card (all_edges A) =\n  card (mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b})\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "have \"\\<dots> = card {(a,b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}) =\n    card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}", "using inj_on_mk_uedge"], ["proof (prove)\nusing this:\n  inj_on mk_uedge {(a, b). a < b}\n\ngoal (1 subgoal):\n 1. card (mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}) =\n    card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}", "by (blast intro: card_image subset_inj_on)"], ["proof (state)\nthis:\n  card (mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}) =\n  card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "also"], ["proof (state)\nthis:\n  card (mk_uedge ` {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}) =\n  card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b}\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "have \"\\<dots> = (card A * (card A - 1)) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n    card A * (card A - 1) div 2", "using card_left_less_pair"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow>\n  card {(a, b). a \\<in> ?A \\<and> b \\<in> ?A \\<and> a < b} =\n  card ?A * (card ?A - 1) div 2\n\ngoal (1 subgoal):\n 1. card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n    card A * (card A - 1) div 2", "using assms"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow>\n  card {(a, b). a \\<in> ?A \\<and> b \\<in> ?A \\<and> a < b} =\n  card ?A * (card ?A - 1) div 2\n  finite A\n\ngoal (1 subgoal):\n 1. card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n    card A * (card A - 1) div 2", "by simp"], ["proof (state)\nthis:\n  card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n  card A * (card A - 1) div 2\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "also"], ["proof (state)\nthis:\n  card {(a, b). a \\<in> A \\<and> b \\<in> A \\<and> a < b} =\n  card A * (card A - 1) div 2\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "have \"\\<dots> = (card A choose 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A * (card A - 1) div 2 = card A choose 2", "by (simp add: n_choose_2_nat)"], ["proof (state)\nthis:\n  card A * (card A - 1) div 2 = card A choose 2\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "finally"], ["proof (chain)\npicking this:\n  card (all_edges A) = card A choose 2", "show ?thesis"], ["proof (prove)\nusing this:\n  card (all_edges A) = card A choose 2\n\ngoal (1 subgoal):\n 1. card (all_edges A) = card A choose 2", "."], ["proof (state)\nthis:\n  card (all_edges A) = card A choose 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma verts_Gu: \"uverts (G -- u) = uverts G - {u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uverts (G -- u) = uverts G - {u}", "unfolding remove_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. uverts (uverts G - {u}, uedges G - {A \\<in> uedges G. u \\<in> A}) =\n    uverts G - {u}", "by simp"], ["", "lemma edges_Gu: \"uedges (G -- u) \\<subseteq> uedges G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uedges (G -- u) \\<subseteq> uedges G", "unfolding remove_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. uedges (uverts G - {u}, uedges G - {A \\<in> uedges G. u \\<in> A})\n    \\<subseteq> uedges G", "by auto"], ["", "subsection \\<open>Girth, Independence and Vertex Colorings\\<close>"], ["", "definition girth :: \"ugraph \\<Rightarrow> enat\" where\n  \"girth G \\<equiv> INF p\\<in> ucycles G. enat (uwalk_length p)\""], ["", "definition independent_sets :: \"ugraph \\<Rightarrow> uvert set set\" where\n  \"independent_sets Gr \\<equiv> {vs. vs \\<subseteq> uverts Gr \\<and> all_edges vs \\<inter> uedges Gr = {}}\""], ["", "definition \\<alpha> :: \"ugraph \\<Rightarrow> enat\" where\n   \"\\<alpha> G \\<equiv> SUP vs \\<in> independent_sets G. enat (card vs)\""], ["", "definition vertex_colorings :: \"ugraph \\<Rightarrow> uvert set set set\" where\n  \"vertex_colorings G \\<equiv> {C. \\<Union>C = uverts G \\<and> (\\<forall>c1\\<in>C. \\<forall>c2\\<in>C. c1 \\<noteq> c2 \\<longrightarrow> c1 \\<inter> c2 = {}) \\<and>\n    (\\<forall>c\\<in>C. c \\<noteq> {} \\<and> (\\<forall>u \\<in> c. \\<forall>v \\<in> c. {u,v} \\<notin> uedges G))}\""], ["", "text \\<open>The chromatic number $\\chi$:\\<close>"], ["", "definition chromatic_number :: \"ugraph \\<Rightarrow> enat\" where\n  \"chromatic_number G \\<equiv> INF c\\<in> (vertex_colorings G). enat (card c)\""], ["", "lemma independent_sets_mono:\n  \"vs \\<in> independent_sets G \\<Longrightarrow> us \\<subseteq> vs \\<Longrightarrow> us \\<in> independent_sets G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs \\<in> independent_sets G; us \\<subseteq> vs\\<rbrakk>\n    \\<Longrightarrow> us \\<in> independent_sets G", "using Int_mono[OF all_edges_mono, of us vs \"uedges G\" \"uedges G\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>us \\<subseteq> vs; uedges G \\<subseteq> uedges G\\<rbrakk>\n  \\<Longrightarrow> all_edges us \\<inter> uedges G\n                    \\<subseteq> all_edges vs \\<inter> uedges G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs \\<in> independent_sets G; us \\<subseteq> vs\\<rbrakk>\n    \\<Longrightarrow> us \\<in> independent_sets G", "unfolding independent_sets_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>us \\<subseteq> vs; uedges G \\<subseteq> uedges G\\<rbrakk>\n  \\<Longrightarrow> all_edges us \\<inter> uedges G\n                    \\<subseteq> all_edges vs \\<inter> uedges G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs \\<in> {vs.\n                       vs \\<subseteq> uverts G \\<and>\n                       all_edges vs \\<inter> uedges G = {}};\n     us \\<subseteq> vs\\<rbrakk>\n    \\<Longrightarrow> us \\<in> {vs.\n                                vs \\<subseteq> uverts G \\<and>\n                                all_edges vs \\<inter> uedges G = {}}", "by auto"], ["", "lemma le_\\<alpha>_iff:\n  assumes \"0 < k\"\n  shows \"k \\<le> \\<alpha> Gr \\<longleftrightarrow> k \\<in> card ` independent_sets Gr\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat k \\<le> \\<alpha> Gr) = (k \\<in> card ` independent_sets Gr)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. enat k \\<le> \\<alpha> Gr \\<Longrightarrow>\n    k \\<in> card ` independent_sets Gr\n 2. k \\<in> card ` independent_sets Gr \\<Longrightarrow>\n    enat k \\<le> \\<alpha> Gr", "assume ?L"], ["proof (state)\nthis:\n  enat k \\<le> \\<alpha> Gr\n\ngoal (2 subgoals):\n 1. enat k \\<le> \\<alpha> Gr \\<Longrightarrow>\n    k \\<in> card ` independent_sets Gr\n 2. k \\<in> card ` independent_sets Gr \\<Longrightarrow>\n    enat k \\<le> \\<alpha> Gr", "then"], ["proof (chain)\npicking this:\n  enat k \\<le> \\<alpha> Gr", "obtain vs where \"vs \\<in> independent_sets Gr\" and \"k \\<le> card vs\""], ["proof (prove)\nusing this:\n  enat k \\<le> \\<alpha> Gr\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>vs \\<in> independent_sets Gr; k \\<le> card vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  enat k \\<le> \\<alpha> Gr\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>vs \\<in> independent_sets Gr; k \\<le> card vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<alpha>_def enat_le_Sup_iff"], ["proof (prove)\nusing this:\n  k = 0 \\<or>\n  Bex ((\\<lambda>vs. enat (card vs)) ` independent_sets Gr)\n   ((\\<le>) (enat k))\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>vs \\<in> independent_sets Gr; k \\<le> card vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  vs \\<in> independent_sets Gr\n  k \\<le> card vs\n\ngoal (2 subgoals):\n 1. enat k \\<le> \\<alpha> Gr \\<Longrightarrow>\n    k \\<in> card ` independent_sets Gr\n 2. k \\<in> card ` independent_sets Gr \\<Longrightarrow>\n    enat k \\<le> \\<alpha> Gr", "moreover"], ["proof (state)\nthis:\n  vs \\<in> independent_sets Gr\n  k \\<le> card vs\n\ngoal (2 subgoals):\n 1. enat k \\<le> \\<alpha> Gr \\<Longrightarrow>\n    k \\<in> card ` independent_sets Gr\n 2. k \\<in> card ` independent_sets Gr \\<Longrightarrow>\n    enat k \\<le> \\<alpha> Gr", "then"], ["proof (chain)\npicking this:\n  vs \\<in> independent_sets Gr\n  k \\<le> card vs", "obtain us where \"us \\<subseteq> vs\" and \"k = card us\""], ["proof (prove)\nusing this:\n  vs \\<in> independent_sets Gr\n  k \\<le> card vs\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<subseteq> vs; k = card us\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using card_Ex_subset"], ["proof (prove)\nusing this:\n  vs \\<in> independent_sets Gr\n  k \\<le> card vs\n  ?k \\<le> card ?M \\<Longrightarrow> \\<exists>N\\<subseteq>?M. card N = ?k\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<subseteq> vs; k = card us\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  us \\<subseteq> vs\n  k = card us\n\ngoal (2 subgoals):\n 1. enat k \\<le> \\<alpha> Gr \\<Longrightarrow>\n    k \\<in> card ` independent_sets Gr\n 2. k \\<in> card ` independent_sets Gr \\<Longrightarrow>\n    enat k \\<le> \\<alpha> Gr", "ultimately"], ["proof (chain)\npicking this:\n  vs \\<in> independent_sets Gr\n  k \\<le> card vs\n  us \\<subseteq> vs\n  k = card us", "have \"us \\<in> independent_sets Gr\""], ["proof (prove)\nusing this:\n  vs \\<in> independent_sets Gr\n  k \\<le> card vs\n  us \\<subseteq> vs\n  k = card us\n\ngoal (1 subgoal):\n 1. us \\<in> independent_sets Gr", "by (auto intro: independent_sets_mono)"], ["proof (state)\nthis:\n  us \\<in> independent_sets Gr\n\ngoal (2 subgoals):\n 1. enat k \\<le> \\<alpha> Gr \\<Longrightarrow>\n    k \\<in> card ` independent_sets Gr\n 2. k \\<in> card ` independent_sets Gr \\<Longrightarrow>\n    enat k \\<le> \\<alpha> Gr", "then"], ["proof (chain)\npicking this:\n  us \\<in> independent_sets Gr", "show ?R"], ["proof (prove)\nusing this:\n  us \\<in> independent_sets Gr\n\ngoal (1 subgoal):\n 1. k \\<in> card ` independent_sets Gr", "using \\<open>k = card us\\<close>"], ["proof (prove)\nusing this:\n  us \\<in> independent_sets Gr\n  k = card us\n\ngoal (1 subgoal):\n 1. k \\<in> card ` independent_sets Gr", "by auto"], ["proof (state)\nthis:\n  k \\<in> card ` independent_sets Gr\n\ngoal (1 subgoal):\n 1. k \\<in> card ` independent_sets Gr \\<Longrightarrow>\n    enat k \\<le> \\<alpha> Gr", "qed (auto intro: SUP_upper simp: \\<alpha>_def)"], ["", "lemma zero_less_\\<alpha>:\n  assumes \"uverts G \\<noteq> {}\"\n  shows \"0 < \\<alpha> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<alpha> G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < \\<alpha> G", "from assms"], ["proof (chain)\npicking this:\n  uverts G \\<noteq> {}", "obtain a where \"a \\<in> uverts G\""], ["proof (prove)\nusing this:\n  uverts G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> uverts G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> uverts G\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha> G", "then"], ["proof (chain)\npicking this:\n  a \\<in> uverts G", "have \"0 < enat (card {a})\" \"{a} \\<in> independent_sets G\""], ["proof (prove)\nusing this:\n  a \\<in> uverts G\n\ngoal (1 subgoal):\n 1. 0 < enat (card {a}) &&& {a} \\<in> independent_sets G", "by (auto simp: independent_sets_def all_edges_def)"], ["proof (state)\nthis:\n  0 < enat (card {a})\n  {a} \\<in> independent_sets G\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha> G", "then"], ["proof (chain)\npicking this:\n  0 < enat (card {a})\n  {a} \\<in> independent_sets G", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < enat (card {a})\n  {a} \\<in> independent_sets G\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha> G", "unfolding \\<alpha>_def less_SUP_iff"], ["proof (prove)\nusing this:\n  0 < enat (card {a})\n  {a} \\<in> independent_sets G\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>independent_sets G. 0 < enat (card x)", ".."], ["proof (state)\nthis:\n  0 < \\<alpha> G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<alpha>_le_card:\n  assumes \"finite (uverts G)\"\n  shows \"\\<alpha> G \\<le> card(uverts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> G \\<le> enat (card (uverts G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> G \\<le> enat (card (uverts G))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> G \\<le> enat (card (uverts G))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> G \\<le> enat (card (uverts G))", "assume \"x \\<in> independent_sets G\""], ["proof (state)\nthis:\n  x \\<in> independent_sets G\n\ngoal (1 subgoal):\n 1. \\<alpha> G \\<le> enat (card (uverts G))", "then"], ["proof (chain)\npicking this:\n  x \\<in> independent_sets G", "have \"x \\<subseteq> uverts G\""], ["proof (prove)\nusing this:\n  x \\<in> independent_sets G\n\ngoal (1 subgoal):\n 1. x \\<subseteq> uverts G", "by (auto simp: independent_sets_def)"], ["proof (state)\nthis:\n  x \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. \\<alpha> G \\<le> enat (card (uverts G))", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> independent_sets G \\<Longrightarrow> ?x2 \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. \\<alpha> G \\<le> enat (card (uverts G))", "with assms"], ["proof (chain)\npicking this:\n  finite (uverts G)\n  ?x2 \\<in> independent_sets G \\<Longrightarrow> ?x2 \\<subseteq> uverts G", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (uverts G)\n  ?x2 \\<in> independent_sets G \\<Longrightarrow> ?x2 \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. \\<alpha> G \\<le> enat (card (uverts G))", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  finite (uverts G)\n  ?x2 \\<in> independent_sets G \\<Longrightarrow> ?x2 \\<subseteq> uverts G\n\ngoal (1 subgoal):\n 1. (SUP vs\\<in>independent_sets G. enat (card vs))\n    \\<le> enat (card (uverts G))", "by (intro SUP_least) (auto intro: card_mono)"], ["proof (state)\nthis:\n  \\<alpha> G \\<le> enat (card (uverts G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<alpha>_fin: \"finite (uverts G) \\<Longrightarrow> \\<alpha> G \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (uverts G) \\<Longrightarrow> \\<alpha> G \\<noteq> \\<infinity>", "using \\<alpha>_le_card[of G]"], ["proof (prove)\nusing this:\n  finite (uverts G) \\<Longrightarrow>\n  \\<alpha> G \\<le> enat (card (uverts G))\n\ngoal (1 subgoal):\n 1. finite (uverts G) \\<Longrightarrow> \\<alpha> G \\<noteq> \\<infinity>", "by (cases \"\\<alpha> G\") auto"], ["", "lemma \\<alpha>_remove_le:\n  shows \"\\<alpha> (G -- u) \\<le> \\<alpha> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (G -- u) \\<le> \\<alpha> G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> (G -- u) \\<le> \\<alpha> G", "have \"independent_sets (G -- u) \\<subseteq> independent_sets G\" (is \"?L \\<subseteq> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. independent_sets (G -- u) \\<subseteq> independent_sets G", "using all_edges_subset_Pow"], ["proof (prove)\nusing this:\n  all_edges ?A \\<subseteq> Pow ?A\n\ngoal (1 subgoal):\n 1. independent_sets (G -- u) \\<subseteq> independent_sets G", "by (simp add: independent_sets_def remove_vertex_def) blast"], ["proof (state)\nthis:\n  independent_sets (G -- u) \\<subseteq> independent_sets G\n\ngoal (1 subgoal):\n 1. \\<alpha> (G -- u) \\<le> \\<alpha> G", "then"], ["proof (chain)\npicking this:\n  independent_sets (G -- u) \\<subseteq> independent_sets G", "show ?thesis"], ["proof (prove)\nusing this:\n  independent_sets (G -- u) \\<subseteq> independent_sets G\n\ngoal (1 subgoal):\n 1. \\<alpha> (G -- u) \\<le> \\<alpha> G", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  independent_sets (G -- u) \\<subseteq> independent_sets G\n\ngoal (1 subgoal):\n 1. (SUP vs\\<in>independent_sets (G -- u). enat (card vs))\n    \\<le> (SUP vs\\<in>independent_sets G. enat (card vs))", "by (rule SUP_subset_mono) simp"], ["proof (state)\nthis:\n  \\<alpha> (G -- u) \\<le> \\<alpha> G\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A lower bound for the chromatic number of a graph can be given in terms of\n  the independence number\n\\<close>"], ["", "lemma chromatic_lb:\n  assumes wf_G: \"uwellformed G\"\n    and fin_G: \"finite (uverts G)\"\n    and neG: \"uverts G \\<noteq> {}\"\n  shows \"card (uverts G) / \\<alpha> G \\<le> chromatic_number G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "from wf_G"], ["proof (chain)\npicking this:\n  uwellformed G", "have \"(\\<lambda>v. {v}) ` uverts G \\<in> vertex_colorings G\""], ["proof (prove)\nusing this:\n  uwellformed G\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. {v}) ` uverts G \\<in> vertex_colorings G", "by (auto simp: vertex_colorings_def uwellformed_def)"], ["proof (state)\nthis:\n  (\\<lambda>v. {v}) ` uverts G \\<in> vertex_colorings G\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>v. {v}) ` uverts G \\<in> vertex_colorings G", "have \"chromatic_number G \\<noteq> top\""], ["proof (prove)\nusing this:\n  (\\<lambda>v. {v}) ` uverts G \\<in> vertex_colorings G\n\ngoal (1 subgoal):\n 1. chromatic_number G \\<noteq> top", "by (simp add: chromatic_number_def) (auto simp: top_enat_def)"], ["proof (state)\nthis:\n  chromatic_number G \\<noteq> top\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "then"], ["proof (chain)\npicking this:\n  chromatic_number G \\<noteq> top", "obtain vc where vc_vc: \"vc \\<in> vertex_colorings G\"\n    and vc_size:\"chromatic_number G = card vc\""], ["proof (prove)\nusing this:\n  chromatic_number G \\<noteq> top\n\ngoal (1 subgoal):\n 1. (\\<And>vc.\n        \\<lbrakk>vc \\<in> vertex_colorings G;\n         chromatic_number G = enat (card vc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding chromatic_number_def"], ["proof (prove)\nusing this:\n  (INF c\\<in>vertex_colorings G. enat (card c)) \\<noteq> top\n\ngoal (1 subgoal):\n 1. (\\<And>vc.\n        \\<lbrakk>vc \\<in> vertex_colorings G;\n         (INF c\\<in>vertex_colorings G. enat (card c)) =\n         enat (card vc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule enat_in_INF)"], ["proof (state)\nthis:\n  vc \\<in> vertex_colorings G\n  chromatic_number G = enat (card vc)\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "have fin_vc_elems: \"\\<And>c. c \\<in> vc \\<Longrightarrow> finite c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> vc \\<Longrightarrow> finite c", "using vc_vc"], ["proof (prove)\nusing this:\n  vc \\<in> vertex_colorings G\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> vc \\<Longrightarrow> finite c", "by (intro finite_subset[OF _ fin_G]) (auto simp: vertex_colorings_def)"], ["proof (state)\nthis:\n  ?c \\<in> vc \\<Longrightarrow> finite ?c\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "have sum_vc_card: \"(\\<Sum>c \\<in> vc. card c) = card (uverts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum card vc = card (uverts G)", "using fin_vc_elems vc_vc"], ["proof (prove)\nusing this:\n  ?c \\<in> vc \\<Longrightarrow> finite ?c\n  vc \\<in> vertex_colorings G\n\ngoal (1 subgoal):\n 1. sum card vc = card (uverts G)", "unfolding vertex_colorings_def"], ["proof (prove)\nusing this:\n  ?c \\<in> vc \\<Longrightarrow> finite ?c\n  vc \\<in> {C. \\<Union> C = uverts G \\<and>\n               (\\<forall>c1\\<in>C.\n                   \\<forall>c2\\<in>C.\n                      c1 \\<noteq> c2 \\<longrightarrow>\n                      c1 \\<inter> c2 = {}) \\<and>\n               (\\<forall>c\\<in>C.\n                   c \\<noteq> {} \\<and>\n                   (\\<forall>u\\<in>c.\n                       \\<forall>v\\<in>c. {u, v} \\<notin> uedges G))}\n\ngoal (1 subgoal):\n 1. sum card vc = card (uverts G)", "by (simp add: card_Union_disjoint[symmetric] pairwise_def disjnt_def)"], ["proof (state)\nthis:\n  sum card vc = card (uverts G)\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "have \"\\<And>c. c \\<in> vc \\<Longrightarrow> c \\<in> independent_sets G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> vc \\<Longrightarrow> c \\<in> independent_sets G", "using vc_vc"], ["proof (prove)\nusing this:\n  vc \\<in> vertex_colorings G\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> vc \\<Longrightarrow> c \\<in> independent_sets G", "by (auto simp: vertex_colorings_def independent_sets_def all_edges_def)"], ["proof (state)\nthis:\n  ?c \\<in> vc \\<Longrightarrow> ?c \\<in> independent_sets G\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "then"], ["proof (chain)\npicking this:\n  ?c \\<in> vc \\<Longrightarrow> ?c \\<in> independent_sets G", "have \"\\<And>c. c \\<in> vc \\<Longrightarrow> card c \\<le> \\<alpha> G\""], ["proof (prove)\nusing this:\n  ?c \\<in> vc \\<Longrightarrow> ?c \\<in> independent_sets G\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> vc \\<Longrightarrow> enat (card c) \\<le> \\<alpha> G", "using vc_vc fin_vc_elems"], ["proof (prove)\nusing this:\n  ?c \\<in> vc \\<Longrightarrow> ?c \\<in> independent_sets G\n  vc \\<in> vertex_colorings G\n  ?c \\<in> vc \\<Longrightarrow> finite ?c\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> vc \\<Longrightarrow> enat (card c) \\<le> \\<alpha> G", "by (subst le_\\<alpha>_iff) (auto simp add: vertex_colorings_def)"], ["proof (state)\nthis:\n  ?c \\<in> vc \\<Longrightarrow> enat (card ?c) \\<le> \\<alpha> G\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "then"], ["proof (chain)\npicking this:\n  ?c \\<in> vc \\<Longrightarrow> enat (card ?c) \\<le> \\<alpha> G", "have \"(\\<Sum>c\\<in>vc. card c) \\<le> card vc * \\<alpha> G\""], ["proof (prove)\nusing this:\n  ?c \\<in> vc \\<Longrightarrow> enat (card ?c) \\<le> \\<alpha> G\n\ngoal (1 subgoal):\n 1. enat (sum card vc) \\<le> enat (card vc) * \\<alpha> G", "using sum_bounded_above[of vc card \"\\<alpha> G\"]"], ["proof (prove)\nusing this:\n  ?c \\<in> vc \\<Longrightarrow> enat (card ?c) \\<le> \\<alpha> G\n  (\\<And>i.\n      i \\<in> vc \\<Longrightarrow>\n      enat (card i) \\<le> \\<alpha> G) \\<Longrightarrow>\n  (\\<Sum>x\\<in>vc. enat (card x)) \\<le> of_nat (card vc) * \\<alpha> G\n\ngoal (1 subgoal):\n 1. enat (sum card vc) \\<le> enat (card vc) * \\<alpha> G", "by (simp add: of_nat_eq_enat[symmetric] of_nat_sum)"], ["proof (state)\nthis:\n  enat (sum card vc) \\<le> enat (card vc) * \\<alpha> G\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "then"], ["proof (chain)\npicking this:\n  enat (sum card vc) \\<le> enat (card vc) * \\<alpha> G", "have \"ereal_of_enat (card (uverts G)) \\<le> ereal_of_enat (\\<alpha> G) * ereal_of_enat (card vc)\""], ["proof (prove)\nusing this:\n  enat (sum card vc) \\<le> enat (card vc) * \\<alpha> G\n\ngoal (1 subgoal):\n 1. ereal_of_enat (enat (card (uverts G)))\n    \\<le> ereal_of_enat (\\<alpha> G) * ereal_of_enat (enat (card vc))", "by (simp add: sum_vc_card ereal_of_enat_pushout ac_simps del: ereal_of_enat_simps)"], ["proof (state)\nthis:\n  ereal_of_enat (enat (card (uverts G)))\n  \\<le> ereal_of_enat (\\<alpha> G) * ereal_of_enat (enat (card vc))\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "with zero_less_\\<alpha>[OF neG] \\<alpha>_fin[OF fin_G] vc_size"], ["proof (chain)\npicking this:\n  0 < \\<alpha> G\n  \\<alpha> G \\<noteq> \\<infinity>\n  chromatic_number G = enat (card vc)\n  ereal_of_enat (enat (card (uverts G)))\n  \\<le> ereal_of_enat (\\<alpha> G) * ereal_of_enat (enat (card vc))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < \\<alpha> G\n  \\<alpha> G \\<noteq> \\<infinity>\n  chromatic_number G = enat (card vc)\n  ereal_of_enat (enat (card (uverts G)))\n  \\<le> ereal_of_enat (\\<alpha> G) * ereal_of_enat (enat (card vc))\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal_of_enat (chromatic_number G)", "by (simp add: ereal_divide_le_pos)"], ["proof (state)\nthis:\n  ereal (real (card (uverts G))) / ereal_of_enat (\\<alpha> G)\n  \\<le> ereal_of_enat (chromatic_number G)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}