{"file_name": "/home/qj213/afp-2021-10-22/thys/Girth_Chromatic/Girth_Chromatic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Girth_Chromatic", "problem_names": ["lemma full_sum:\n  fixes p :: real\n  assumes \"finite S\"\n  shows \"(\\<Sum>A\\<in>Pow S. p^card A * (1 - p)^card (S - A)) = 1\"", "lemma finite_verts[intro!]: \"finite S_verts\"", "lemma finite_edges[intro!]: \"finite S_edges\"", "lemma finite_graph[intro!]: \"finite (uverts (edge_ugraph es))\"", "lemma uverts_edge_ugraph[simp]: \"uverts (edge_ugraph es) = S_verts\"", "lemma uedges_edge_ugraph[simp]: \"uedges (edge_ugraph es) = es \\<inter> S_edges\"", "lemma space_eq: \"space P = Pow S_edges\"", "lemma sets_eq: \"sets P = Pow (Pow S_edges)\"", "lemma emeasure_eq:\n  \"emeasure P A = (if A \\<subseteq> Pow S_edges then (\\<Sum>edges\\<in>A. p^card edges * (1 - p)^card (S_edges - edges)) else 0)\"", "lemma integrable_P[intro, simp]: \"integrable P (f::_ \\<Rightarrow> real)\"", "lemma borel_measurable_P[measurable]: \"f \\<in> borel_measurable P\"", "lemma prob_space_P: \"prob_space P\"", "lemma prob_eq:\n  \"prob A = (if A \\<subseteq> Pow S_edges then (\\<Sum>edges\\<in>A. p^card edges * (1 - p)^card (S_edges - edges)) else 0)\"", "lemma integral_finite_singleton: \"integral\\<^sup>L P f = (\\<Sum>x\\<in>Pow S_edges. f x * measure P {x})\"", "lemma cylinder_prob:\n  assumes \"A \\<subseteq> S_edges\" \"B \\<subseteq> S_edges\" \"A \\<inter> B = {}\"\n  shows \"prob (cylinder S_edges A B) = p ^ (card A) * (1 - p) ^ (card B)\" (is \"_ = ?pp A B\")", "lemma Markov_inequality:\n  fixes a :: real and X :: \"uedge set \\<Rightarrow> real\"\n  assumes \"0 < c\" \"\\<And>x. 0 \\<le> f x\"\n  shows \"prob {x \\<in> space P. c \\<le> f x} \\<le> (\\<integral>x. f x \\<partial> P) / c\"", "lemma probGn_le:\n  assumes p_prob: \"0 < p n\" \"p n < 1\"\n  assumes sub: \"\\<And>n es. es \\<in> space (MGn p n) \\<Longrightarrow> P n es \\<Longrightarrow> Q n es\"\n  shows \"probGn p n (P n) \\<le> probGn p n (Q n)\"", "lemma ksc_simps[simp]:\n  \"short_cycles G k = {} \\<Longrightarrow> kill_short G k = G\"\n  \"short_cycles G k \\<noteq> {}  \\<Longrightarrow> kill_short G k = kill_short (G -- (choose_v G k)) k\"", "lemma\n  assumes \"short_cycles G k \\<noteq> {}\"\n  shows choose_v__in_uverts: \"choose_v G k \\<in> uverts G\" (is ?t1)\n    and choose_v__in_short: \"\\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p\" (is ?t2)", "lemma kill_step_smaller:\n  assumes \"short_cycles G k \\<noteq> {}\"\n  shows \"short_cycles (G -- (choose_v G k)) k \\<subset> short_cycles G k\"", "lemma kill_short_induct[consumes 1, case_names empty kill_vert]:\n  assumes fin: \"finite (uverts G)\"\n  assumes a_empty: \"\\<And>G. short_cycles G k = {} \\<Longrightarrow> P G k\"\n  assumes a_kill: \"\\<And>G. finite (short_cycles G k) \\<Longrightarrow> short_cycles G k \\<noteq> {}\n    \\<Longrightarrow> P (G -- (choose_v G k)) k \\<Longrightarrow> P G k\"\n  shows \"P G k\"", "lemma kill_short_large_girth:\n  assumes \"finite (uverts G)\"\n  shows \"k < girth (kill_short G k)\"", "lemma kill_short_order_of_graph:\n  assumes \"finite (uverts G)\"\n  shows \"card (uverts G) - card (short_cycles G k) \\<le> card (uverts (kill_short G k))\"", "lemma kill_short_\\<alpha>:\n  assumes \"finite (uverts G)\"\n  shows \"\\<alpha> (kill_short G k) \\<le> \\<alpha> G\"", "lemma kill_short_uwellformed:\n  assumes \"finite (uverts G)\" \"uwellformed G\"\n  shows \"uwellformed (kill_short G k)\"", "lemma (in edge_space) random_prob_independent:\n  assumes \"n \\<ge> k\" \"k \\<ge> 2\"\n  shows \"prob {es \\<in> space P. k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> (n choose k)*(1-p)^(k choose 2)\"", "lemma almost_never_le_\\<alpha>:\n  fixes k :: nat\n    and p :: \"nat \\<Rightarrow> real\"\n  assumes p_prob: \"\\<forall>\\<^sup>\\<infinity> n. 0 < p n \\<and> p n < 1\"\n  assumes [arith]: \"k > 0\"\n  assumes N_prop: \"\\<forall>\\<^sup>\\<infinity> n. (6 * k * ln n)/n \\<le> p n\"\n  shows \"(\\<lambda>n. probGn p n (\\<lambda>es. 1/2*n/k \\<le> \\<alpha> (edge_space.edge_ugraph n es))) \\<longlonglongrightarrow> 0\"\n    (is \"(\\<lambda>n. ?prob_fun n) \\<longlonglongrightarrow> 0\")", "lemma (in edge_space) mean_k_cycles:\n  assumes \"3 \\<le> k\" \"k < n\"\n  shows \"(\\<integral>es. card {c \\<in> ucycles (edge_ugraph es). uwalk_length c = k} \\<partial> P)\n    = of_nat (fact n div fact (n - k)) * p ^ k\"", "theorem girth_chromatic:\n  fixes l :: nat\n  shows \"\\<exists>G. uwellformed G \\<and> l < girth G \\<and> l < chromatic_number G\""], "translations": [["", "lemma full_sum:\n  fixes p :: real\n  assumes \"finite S\"\n  shows \"(\\<Sum>A\\<in>Pow S. p^card A * (1 - p)^card (S - A)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>A\\<in>Pow S. p ^ card A * (1 - p) ^ card (S - A)) = 1", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<Sum>A\\<in>Pow S. p ^ card A * (1 - p) ^ card (S - A)) = 1", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>A\\<in>Pow {}. p ^ card A * (1 - p) ^ card ({} - A)) = 1\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Sum>A\\<in>Pow F. p ^ card A * (1 - p) ^ card (F - A)) =\n        1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>A\\<in>Pow (insert x F).\n                            p ^ card A * (1 - p) ^ card (insert x F - A)) =\n                         1", "case (insert s S)"], ["proof (state)\nthis:\n  finite S\n  s \\<notin> S\n  (\\<Sum>A\\<in>Pow S. p ^ card A * (1 - p) ^ card (S - A)) = 1\n\ngoal (2 subgoals):\n 1. (\\<Sum>A\\<in>Pow {}. p ^ card A * (1 - p) ^ card ({} - A)) = 1\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Sum>A\\<in>Pow F. p ^ card A * (1 - p) ^ card (F - A)) =\n        1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>A\\<in>Pow (insert x F).\n                            p ^ card A * (1 - p) ^ card (insert x F - A)) =\n                         1", "have \"inj_on (insert s) (Pow S)\"\n      and \"\\<And>x. S - insert s x = S - x\"\n      and \"Pow S \\<inter> insert s ` Pow S = {}\"\n      and \"\\<And>x. x \\<in> Pow S \\<Longrightarrow> card (insert s S - x) = Suc (card (S - x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inj_on (insert s) (Pow S) &&& (\\<And>x. S - insert s x = S - x)) &&&\n    Pow S \\<inter> insert s ` Pow S = {} &&&\n    (\\<And>x.\n        x \\<in> Pow S \\<Longrightarrow>\n        card (insert s S - x) = Suc (card (S - x)))", "using insert(1-2)"], ["proof (prove)\nusing this:\n  finite S\n  s \\<notin> S\n\ngoal (1 subgoal):\n 1. (inj_on (insert s) (Pow S) &&& (\\<And>x. S - insert s x = S - x)) &&&\n    Pow S \\<inter> insert s ` Pow S = {} &&&\n    (\\<And>x.\n        x \\<in> Pow S \\<Longrightarrow>\n        card (insert s S - x) = Suc (card (S - x)))", "by (auto simp: insert_Diff_if intro!: inj_onI)"], ["proof (state)\nthis:\n  inj_on (insert s) (Pow S)\n  S - insert s ?x = S - ?x\n  Pow S \\<inter> insert s ` Pow S = {}\n  ?x \\<in> Pow S \\<Longrightarrow>\n  card (insert s S - ?x) = Suc (card (S - ?x))\n\ngoal (2 subgoals):\n 1. (\\<Sum>A\\<in>Pow {}. p ^ card A * (1 - p) ^ card ({} - A)) = 1\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Sum>A\\<in>Pow F. p ^ card A * (1 - p) ^ card (F - A)) =\n        1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>A\\<in>Pow (insert x F).\n                            p ^ card A * (1 - p) ^ card (insert x F - A)) =\n                         1", "moreover"], ["proof (state)\nthis:\n  inj_on (insert s) (Pow S)\n  S - insert s ?x = S - ?x\n  Pow S \\<inter> insert s ` Pow S = {}\n  ?x \\<in> Pow S \\<Longrightarrow>\n  card (insert s S - ?x) = Suc (card (S - ?x))\n\ngoal (2 subgoals):\n 1. (\\<Sum>A\\<in>Pow {}. p ^ card A * (1 - p) ^ card ({} - A)) = 1\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Sum>A\\<in>Pow F. p ^ card A * (1 - p) ^ card (F - A)) =\n        1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>A\\<in>Pow (insert x F).\n                            p ^ card A * (1 - p) ^ card (insert x F - A)) =\n                         1", "have \"\\<And>x. x \\<subseteq> S \\<Longrightarrow> card (insert s x) = Suc (card x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<subseteq> S \\<Longrightarrow> card (insert s x) = Suc (card x)", "using insert(1-2)"], ["proof (prove)\nusing this:\n  finite S\n  s \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<subseteq> S \\<Longrightarrow> card (insert s x) = Suc (card x)", "by (subst card.insert) (auto dest: finite_subset)"], ["proof (state)\nthis:\n  ?x \\<subseteq> S \\<Longrightarrow> card (insert s ?x) = Suc (card ?x)\n\ngoal (2 subgoals):\n 1. (\\<Sum>A\\<in>Pow {}. p ^ card A * (1 - p) ^ card ({} - A)) = 1\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Sum>A\\<in>Pow F. p ^ card A * (1 - p) ^ card (F - A)) =\n        1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>A\\<in>Pow (insert x F).\n                            p ^ card A * (1 - p) ^ card (insert x F - A)) =\n                         1", "ultimately"], ["proof (chain)\npicking this:\n  inj_on (insert s) (Pow S)\n  S - insert s ?x = S - ?x\n  Pow S \\<inter> insert s ` Pow S = {}\n  ?x \\<in> Pow S \\<Longrightarrow>\n  card (insert s S - ?x) = Suc (card (S - ?x))\n  ?x \\<subseteq> S \\<Longrightarrow> card (insert s ?x) = Suc (card ?x)", "show ?case"], ["proof (prove)\nusing this:\n  inj_on (insert s) (Pow S)\n  S - insert s ?x = S - ?x\n  Pow S \\<inter> insert s ` Pow S = {}\n  ?x \\<in> Pow S \\<Longrightarrow>\n  card (insert s S - ?x) = Suc (card (S - ?x))\n  ?x \\<subseteq> S \\<Longrightarrow> card (insert s ?x) = Suc (card ?x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>A\\<in>Pow (insert s S).\n       p ^ card A * (1 - p) ^ card (insert s S - A)) =\n    1", "by (simp add: sum.reindex sum_distrib_left[symmetric] ac_simps\n                  insert.hyps sum.union_disjoint Pow_insert)"], ["proof (state)\nthis:\n  (\\<Sum>A\\<in>Pow (insert s S).\n     p ^ card A * (1 - p) ^ card (insert s S - A)) =\n  1\n\ngoal (1 subgoal):\n 1. (\\<Sum>A\\<in>Pow {}. p ^ card A * (1 - p) ^ card ({} - A)) = 1", "qed simp"], ["", "text \\<open>Definition of the probability space on edges:\\<close>"], ["", "locale edge_space =\n  fixes n :: nat and p :: real\n  assumes p_prob: \"0 \\<le> p\" \"p \\<le> 1\"\nbegin"], ["", "definition S_verts :: \"nat set\" where\n  \"S_verts \\<equiv> {1..n}\""], ["", "definition S_edges :: \"uedge set\" where\n  \"S_edges = all_edges S_verts\""], ["", "definition edge_ugraph :: \"uedge set \\<Rightarrow> ugraph\" where\n  \"edge_ugraph es \\<equiv> (S_verts, es \\<inter> S_edges)\""], ["", "definition \"P = point_measure (Pow S_edges) (\\<lambda>s. p^card s * (1 - p)^card (S_edges - s))\""], ["", "lemma finite_verts[intro!]: \"finite S_verts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S_verts", "by (auto simp: S_verts_def)"], ["", "lemma finite_edges[intro!]: \"finite S_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S_edges", "by (auto simp: S_edges_def all_edges_def finite_verts)"], ["", "lemma finite_graph[intro!]: \"finite (uverts (edge_ugraph es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (uverts (edge_ugraph es))", "unfolding edge_ugraph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (uverts (S_verts, es \\<inter> S_edges))", "by auto"], ["", "lemma uverts_edge_ugraph[simp]: \"uverts (edge_ugraph es) = S_verts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uverts (edge_ugraph es) = S_verts", "by (simp add: edge_ugraph_def)"], ["", "lemma uedges_edge_ugraph[simp]: \"uedges (edge_ugraph es) = es \\<inter> S_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uedges (edge_ugraph es) = es \\<inter> S_edges", "unfolding edge_ugraph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. uedges (S_verts, es \\<inter> S_edges) = es \\<inter> S_edges", "by simp"], ["", "lemma space_eq: \"space P = Pow S_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space P = Pow S_edges", "by (simp add: P_def space_point_measure)"], ["", "lemma sets_eq: \"sets P = Pow (Pow S_edges)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets P = Pow (Pow S_edges)", "by (simp add: P_def sets_point_measure)"], ["", "lemma emeasure_eq:\n  \"emeasure P A = (if A \\<subseteq> Pow S_edges then (\\<Sum>edges\\<in>A. p^card edges * (1 - p)^card (S_edges - edges)) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure P A =\n    ennreal\n     (if A \\<subseteq> Pow S_edges\n      then \\<Sum>edges\\<in>A.\n             p ^ card edges * (1 - p) ^ card (S_edges - edges)\n      else 0)", "using finite_edges p_prob"], ["proof (prove)\nusing this:\n  finite S_edges\n  0 \\<le> p\n  p \\<le> 1\n\ngoal (1 subgoal):\n 1. emeasure P A =\n    ennreal\n     (if A \\<subseteq> Pow S_edges\n      then \\<Sum>edges\\<in>A.\n             p ^ card edges * (1 - p) ^ card (S_edges - edges)\n      else 0)", "by (simp add: P_def space_point_measure emeasure_point_measure_finite\n    sets_point_measure emeasure_notin_sets)"], ["", "lemma integrable_P[intro, simp]: \"integrable P (f::_ \\<Rightarrow> real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable P f", "using finite_edges"], ["proof (prove)\nusing this:\n  finite S_edges\n\ngoal (1 subgoal):\n 1. integrable P f", "by (simp add: integrable_point_measure_finite P_def)"], ["", "lemma borel_measurable_P[measurable]: \"f \\<in> borel_measurable P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable P", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable\n             (point_measure (Pow S_edges)\n               (\\<lambda>x.\n                   ennreal (p ^ card x * (1 - p) ^ card (S_edges - x))))", "by simp"], ["", "lemma prob_space_P: \"prob_space P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure P (space P) = 1", "show \"emeasure P (space P) = 1\" \\<comment> \\<open>Sum of probabilities equals 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure P (space P) = 1", "using finite_edges"], ["proof (prove)\nusing this:\n  finite S_edges\n\ngoal (1 subgoal):\n 1. emeasure P (space P) = 1", "by (simp add: emeasure_eq full_sum one_ereal_def space_eq)"], ["proof (state)\nthis:\n  emeasure P (space P) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale edge_space \\<subseteq> prob_space P"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space P", "by (rule prob_space_P)"], ["", "context edge_space\nbegin"], ["", "lemma prob_eq:\n  \"prob A = (if A \\<subseteq> Pow S_edges then (\\<Sum>edges\\<in>A. p^card edges * (1 - p)^card (S_edges - edges)) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob A =\n    (if A \\<subseteq> Pow S_edges\n     then \\<Sum>edges\\<in>A.\n            p ^ card edges * (1 - p) ^ card (S_edges - edges)\n     else 0)", "using emeasure_eq[of A] p_prob"], ["proof (prove)\nusing this:\n  emeasure P A =\n  ennreal\n   (if A \\<subseteq> Pow S_edges\n    then \\<Sum>edges\\<in>A.\n           p ^ card edges * (1 - p) ^ card (S_edges - edges)\n    else 0)\n  0 \\<le> p\n  p \\<le> 1\n\ngoal (1 subgoal):\n 1. prob A =\n    (if A \\<subseteq> Pow S_edges\n     then \\<Sum>edges\\<in>A.\n            p ^ card edges * (1 - p) ^ card (S_edges - edges)\n     else 0)", "unfolding emeasure_eq_measure"], ["proof (prove)\nusing this:\n  ennreal (prob A) =\n  ennreal\n   (if A \\<subseteq> Pow S_edges\n    then \\<Sum>edges\\<in>A.\n           p ^ card edges * (1 - p) ^ card (S_edges - edges)\n    else 0)\n  0 \\<le> p\n  p \\<le> 1\n\ngoal (1 subgoal):\n 1. prob A =\n    (if A \\<subseteq> Pow S_edges\n     then \\<Sum>edges\\<in>A.\n            p ^ card edges * (1 - p) ^ card (S_edges - edges)\n     else 0)", "by (simp add: sum_nonneg)"], ["", "lemma integral_finite_singleton: \"integral\\<^sup>L P f = (\\<Sum>x\\<in>Pow S_edges. f x * measure P {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation f = (\\<Sum>x\\<in>Pow S_edges. f x * prob {x})", "using p_prob prob_eq"], ["proof (prove)\nusing this:\n  0 \\<le> p\n  p \\<le> 1\n  prob ?A =\n  (if ?A \\<subseteq> Pow S_edges\n   then \\<Sum>edges\\<in>?A.\n          p ^ card edges * (1 - p) ^ card (S_edges - edges)\n   else 0)\n\ngoal (1 subgoal):\n 1. expectation f = (\\<Sum>x\\<in>Pow S_edges. f x * prob {x})", "unfolding P_def"], ["proof (prove)\nusing this:\n  0 \\<le> p\n  p \\<le> 1\n  Sigma_Algebra.measure\n   (point_measure (Pow S_edges)\n     (\\<lambda>x. ennreal (p ^ card x * (1 - p) ^ card (S_edges - x))))\n   ?A =\n  (if ?A \\<subseteq> Pow S_edges\n   then \\<Sum>edges\\<in>?A.\n          p ^ card edges * (1 - p) ^ card (S_edges - edges)\n   else 0)\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L\n     (point_measure (Pow S_edges)\n       (\\<lambda>x. ennreal (p ^ card x * (1 - p) ^ card (S_edges - x))))\n     f =\n    (\\<Sum>x\\<in>Pow S_edges.\n       f x *\n       Sigma_Algebra.measure\n        (point_measure (Pow S_edges)\n          (\\<lambda>x. ennreal (p ^ card x * (1 - p) ^ card (S_edges - x))))\n        {x})", "by (subst lebesgue_integral_point_measure_finite) (auto intro!: sum.cong)"], ["", "text \\<open>Probability of cylinder sets:\\<close>"], ["", "lemma cylinder_prob:\n  assumes \"A \\<subseteq> S_edges\" \"B \\<subseteq> S_edges\" \"A \\<inter> B = {}\"\n  shows \"prob (cylinder S_edges A B) = p ^ (card A) * (1 - p) ^ (card B)\" (is \"_ = ?pp A B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "have \"Pow S_edges \\<inter> cylinder S_edges A B = cylinder S_edges A B\"\n       \"\\<And>x. x \\<in> cylinder S_edges A B \\<Longrightarrow> A \\<union> x = x\"\n       \"\\<And>x. x \\<in> cylinder S_edges A B \\<Longrightarrow> finite x\"\n       \"\\<And>x. x \\<in> cylinder S_edges A B \\<Longrightarrow> B \\<inter> (S_edges - B - x) = {}\"\n       \"\\<And>x. x \\<in> cylinder S_edges A B \\<Longrightarrow> B \\<union> (S_edges - B - x) = S_edges - x\"\n       \"finite A\" \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pow S_edges \\<inter> cylinder S_edges A B = cylinder S_edges A B &&&\n     (\\<And>x.\n         x \\<in> cylinder S_edges A B \\<Longrightarrow>\n         A \\<union> x = x) &&&\n     (\\<And>x. x \\<in> cylinder S_edges A B \\<Longrightarrow> finite x)) &&&\n    ((\\<And>x.\n         x \\<in> cylinder S_edges A B \\<Longrightarrow>\n         B \\<inter> (S_edges - B - x) = {}) &&&\n     (\\<And>x.\n         x \\<in> cylinder S_edges A B \\<Longrightarrow>\n         B \\<union> (S_edges - B - x) = S_edges - x)) &&&\n    finite A &&& finite B", "using assms"], ["proof (prove)\nusing this:\n  A \\<subseteq> S_edges\n  B \\<subseteq> S_edges\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. (Pow S_edges \\<inter> cylinder S_edges A B = cylinder S_edges A B &&&\n     (\\<And>x.\n         x \\<in> cylinder S_edges A B \\<Longrightarrow>\n         A \\<union> x = x) &&&\n     (\\<And>x. x \\<in> cylinder S_edges A B \\<Longrightarrow> finite x)) &&&\n    ((\\<And>x.\n         x \\<in> cylinder S_edges A B \\<Longrightarrow>\n         B \\<inter> (S_edges - B - x) = {}) &&&\n     (\\<And>x.\n         x \\<in> cylinder S_edges A B \\<Longrightarrow>\n         B \\<union> (S_edges - B - x) = S_edges - x)) &&&\n    finite A &&& finite B", "by (auto simp add: cylinder_def intro: finite_subset)"], ["proof (state)\nthis:\n  Pow S_edges \\<inter> cylinder S_edges A B = cylinder S_edges A B\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow> A \\<union> ?x1 = ?x1\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow> finite ?x1\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  B \\<inter> (S_edges - B - ?x1) = {}\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  B \\<union> (S_edges - B - ?x1) = S_edges - ?x1\n  finite A\n  finite B\n\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "then"], ["proof (chain)\npicking this:\n  Pow S_edges \\<inter> cylinder S_edges A B = cylinder S_edges A B\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow> A \\<union> ?x1 = ?x1\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow> finite ?x1\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  B \\<inter> (S_edges - B - ?x1) = {}\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  B \\<union> (S_edges - B - ?x1) = S_edges - ?x1\n  finite A\n  finite B", "have \"(\\<Sum>T\\<in>cylinder S_edges A B. ?pp T (S_edges - T))\n      = (\\<Sum>T \\<in> cylinder S_edges A B. p^(card A + card (T - A)) * (1 - p)^(card B + card ((S_edges - B) - T)))\""], ["proof (prove)\nusing this:\n  Pow S_edges \\<inter> cylinder S_edges A B = cylinder S_edges A B\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow> A \\<union> ?x1 = ?x1\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow> finite ?x1\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  B \\<inter> (S_edges - B - ?x1) = {}\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  B \\<union> (S_edges - B - ?x1) = S_edges - ?x1\n  finite A\n  finite B\n\ngoal (1 subgoal):\n 1. (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ card T * (1 - p) ^ card (S_edges - T)) =\n    (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ (card A + card (T - A)) *\n       (1 - p) ^ (card B + card (S_edges - B - T)))", "using finite_edges"], ["proof (prove)\nusing this:\n  Pow S_edges \\<inter> cylinder S_edges A B = cylinder S_edges A B\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow> A \\<union> ?x1 = ?x1\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow> finite ?x1\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  B \\<inter> (S_edges - B - ?x1) = {}\n  ?x1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  B \\<union> (S_edges - B - ?x1) = S_edges - ?x1\n  finite A\n  finite B\n  finite S_edges\n\ngoal (1 subgoal):\n 1. (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ card T * (1 - p) ^ card (S_edges - T)) =\n    (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ (card A + card (T - A)) *\n       (1 - p) ^ (card B + card (S_edges - B - T)))", "by (simp add: card_Un_Int)"], ["proof (state)\nthis:\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ card T * (1 - p) ^ card (S_edges - T)) =\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ (card A + card (T - A)) *\n     (1 - p) ^ (card B + card (S_edges - B - T)))\n\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "also"], ["proof (state)\nthis:\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ card T * (1 - p) ^ card (S_edges - T)) =\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ (card A + card (T - A)) *\n     (1 - p) ^ (card B + card (S_edges - B - T)))\n\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "have \"\\<dots> = ?pp A B * (\\<Sum>T\\<in>cylinder S_edges A B. ?pp (T - A) (S_edges - B - T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ (card A + card (T - A)) *\n       (1 - p) ^ (card B + card (S_edges - B - T))) =\n    p ^ card A * (1 - p) ^ card B *\n    (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T))", "by (simp add: power_add sum_distrib_left ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ (card A + card (T - A)) *\n     (1 - p) ^ (card B + card (S_edges - B - T))) =\n  p ^ card A * (1 - p) ^ card B *\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T))\n\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "also"], ["proof (state)\nthis:\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ (card A + card (T - A)) *\n     (1 - p) ^ (card B + card (S_edges - B - T))) =\n  p ^ card A * (1 - p) ^ card B *\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T))\n\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "have \"\\<dots> = ?pp A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ card A * (1 - p) ^ card B *\n    (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T)) =\n    p ^ card A * (1 - p) ^ card B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p ^ card A * (1 - p) ^ card B *\n    (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T)) =\n    p ^ card A * (1 - p) ^ card B", "have \"\\<And>T. T \\<in> cylinder S_edges A B \\<Longrightarrow> S_edges - B - T = (S_edges - A) - B - (T - A)\"\n         \"Pow (S_edges - A - B) = (\\<lambda>x. x - A) ` cylinder S_edges A B\"\n         \"inj_on (\\<lambda>x. x - A) (cylinder S_edges A B)\"\n         \"finite (S_edges - A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>T.\n         T \\<in> cylinder S_edges A B \\<Longrightarrow>\n         S_edges - B - T = S_edges - A - B - (T - A)) &&&\n     Pow (S_edges - A - B) = (\\<lambda>x. x - A) ` cylinder S_edges A B) &&&\n    inj_on (\\<lambda>x. x - A) (cylinder S_edges A B) &&&\n    finite (S_edges - A - B)", "using assms"], ["proof (prove)\nusing this:\n  A \\<subseteq> S_edges\n  B \\<subseteq> S_edges\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. ((\\<And>T.\n         T \\<in> cylinder S_edges A B \\<Longrightarrow>\n         S_edges - B - T = S_edges - A - B - (T - A)) &&&\n     Pow (S_edges - A - B) = (\\<lambda>x. x - A) ` cylinder S_edges A B) &&&\n    inj_on (\\<lambda>x. x - A) (cylinder S_edges A B) &&&\n    finite (S_edges - A - B)", "by (auto simp: cylinder_def intro!: inj_onI)"], ["proof (state)\nthis:\n  ?T1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  S_edges - B - ?T1 = S_edges - A - B - (?T1 - A)\n  Pow (S_edges - A - B) = (\\<lambda>x. x - A) ` cylinder S_edges A B\n  inj_on (\\<lambda>x. x - A) (cylinder S_edges A B)\n  finite (S_edges - A - B)\n\ngoal (1 subgoal):\n 1. p ^ card A * (1 - p) ^ card B *\n    (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T)) =\n    p ^ card A * (1 - p) ^ card B", "with full_sum[of \"S_edges - A - B\"]"], ["proof (chain)\npicking this:\n  finite (S_edges - A - B) \\<Longrightarrow>\n  (\\<Sum>Aa\\<in>Pow (S_edges - A - B).\n     ?p ^ card Aa * (1 - ?p) ^ card (S_edges - A - B - Aa)) =\n  1\n  ?T1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  S_edges - B - ?T1 = S_edges - A - B - (?T1 - A)\n  Pow (S_edges - A - B) = (\\<lambda>x. x - A) ` cylinder S_edges A B\n  inj_on (\\<lambda>x. x - A) (cylinder S_edges A B)\n  finite (S_edges - A - B)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (S_edges - A - B) \\<Longrightarrow>\n  (\\<Sum>Aa\\<in>Pow (S_edges - A - B).\n     ?p ^ card Aa * (1 - ?p) ^ card (S_edges - A - B - Aa)) =\n  1\n  ?T1 \\<in> cylinder S_edges A B \\<Longrightarrow>\n  S_edges - B - ?T1 = S_edges - A - B - (?T1 - A)\n  Pow (S_edges - A - B) = (\\<lambda>x. x - A) ` cylinder S_edges A B\n  inj_on (\\<lambda>x. x - A) (cylinder S_edges A B)\n  finite (S_edges - A - B)\n\ngoal (1 subgoal):\n 1. p ^ card A * (1 - p) ^ card B *\n    (\\<Sum>T\\<in>cylinder S_edges A B.\n       p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T)) =\n    p ^ card A * (1 - p) ^ card B", "by (simp add: sum.reindex)"], ["proof (state)\nthis:\n  p ^ card A * (1 - p) ^ card B *\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T)) =\n  p ^ card A * (1 - p) ^ card B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p ^ card A * (1 - p) ^ card B *\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ card (T - A) * (1 - p) ^ card (S_edges - B - T)) =\n  p ^ card A * (1 - p) ^ card B\n\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ card T * (1 - p) ^ card (S_edges - T)) =\n  p ^ card A * (1 - p) ^ card B", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>T\\<in>cylinder S_edges A B.\n     p ^ card T * (1 - p) ^ card (S_edges - T)) =\n  p ^ card A * (1 - p) ^ card B\n\ngoal (1 subgoal):\n 1. prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B", "by (auto simp add: prob_eq cylinder_def)"], ["proof (state)\nthis:\n  prob (cylinder S_edges A B) = p ^ card A * (1 - p) ^ card B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Markov_inequality:\n  fixes a :: real and X :: \"uedge set \\<Rightarrow> real\"\n  assumes \"0 < c\" \"\\<And>x. 0 \\<le> f x\"\n  shows \"prob {x \\<in> space P. c \\<le> f x} \\<le> (\\<integral>x. f x \\<partial> P) / c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob {x \\<in> space P. c \\<le> f x} \\<le> expectation f / c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prob {x \\<in> space P. c \\<le> f x} \\<le> expectation f / c", "from assms"], ["proof (chain)\npicking this:\n  0 < c\n  0 \\<le> f ?x1", "have \"(\\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>P) = (\\<integral>x. f x \\<partial>P)\""], ["proof (prove)\nusing this:\n  0 < c\n  0 \\<le> f ?x1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>P =\n    ennreal (expectation f)", "by (intro nn_integral_eq_integral) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>P = ennreal (expectation f)\n\ngoal (1 subgoal):\n 1. prob {x \\<in> space P. c \\<le> f x} \\<le> expectation f / c", "with assms"], ["proof (chain)\npicking this:\n  0 < c\n  0 \\<le> f ?x1\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>P = ennreal (expectation f)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < c\n  0 \\<le> f ?x1\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>P = ennreal (expectation f)\n\ngoal (1 subgoal):\n 1. prob {x \\<in> space P. c \\<le> f x} \\<le> expectation f / c", "using nn_integral_Markov_inequality[of f P \"space P\" \"1 / c\"]"], ["proof (prove)\nusing this:\n  0 < c\n  0 \\<le> f ?x1\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>P = ennreal (expectation f)\n  \\<lbrakk>random_variable borel (\\<lambda>x. ennreal (f x));\n   space P \\<in> events\\<rbrakk>\n  \\<Longrightarrow> emeasure P\n                     ({x \\<in> space P.\n                       1 \\<le> ennreal (1 / c) * ennreal (f x)} \\<inter>\n                      space P)\n                    \\<le> ennreal (1 / c) *\n                          (\\<integral>\\<^sup>+x\\<in>space P. ennreal (f x)\n                           \\<partial>P)\n\ngoal (1 subgoal):\n 1. prob {x \\<in> space P. c \\<le> f x} \\<le> expectation f / c", "by (simp cong: nn_integral_cong add: emeasure_eq_measure ennreal_mult[symmetric])"], ["proof (state)\nthis:\n  prob {x \\<in> space P. c \\<le> f x} \\<le> expectation f / c\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Graph Probabilities outside of @{term Edge_Space} locale\\<close>"], ["", "text \\<open>\n These abbreviations allow a compact expression of probabilities about random\n graphs outside of the @{term Edge_Space} locale. We also transfer a few of the lemmas\n we need from the locale into the toplevel theory.\n\\<close>"], ["", "abbreviation MGn :: \"(nat \\<Rightarrow> real) \\<Rightarrow> nat \\<Rightarrow> (uedge set) measure\" where\n  \"MGn p n \\<equiv> (edge_space.P n (p n))\""], ["", "abbreviation probGn :: \"(nat \\<Rightarrow> real) \\<Rightarrow> nat \\<Rightarrow> (uedge set \\<Rightarrow> bool) \\<Rightarrow> real\" where\n  \"probGn p n P \\<equiv> measure (MGn p n) {es \\<in> space (MGn p n). P es}\""], ["", "lemma probGn_le:\n  assumes p_prob: \"0 < p n\" \"p n < 1\"\n  assumes sub: \"\\<And>n es. es \\<in> space (MGn p n) \\<Longrightarrow> P n es \\<Longrightarrow> Q n es\"\n  shows \"probGn p n (P n) \\<le> probGn p n (Q n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. probGn p n (P n) \\<le> probGn p n (Q n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. probGn p n (P n) \\<le> probGn p n (Q n)", "from p_prob"], ["proof (chain)\npicking this:\n  0 < p n\n  p n < 1", "interpret E: edge_space n \"p n\""], ["proof (prove)\nusing this:\n  0 < p n\n  p n < 1\n\ngoal (1 subgoal):\n 1. edge_space (p n)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. E.prob {es \\<in> space E.P. P n es}\n    \\<le> E.prob {es \\<in> space E.P. Q n es}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. E.prob {es \\<in> space E.P. P n es}\n    \\<le> E.prob {es \\<in> space E.P. Q n es}", "by (auto intro!: E.finite_measure_mono sub simp: E.space_eq E.sets_eq)"], ["proof (state)\nthis:\n  E.prob {es \\<in> space E.P. P n es}\n  \\<le> E.prob {es \\<in> space E.P. Q n es}\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Short cycles\\<close>"], ["", "definition short_cycles :: \"ugraph \\<Rightarrow> nat \\<Rightarrow> uwalk set\" where\n  \"short_cycles G k \\<equiv> {p \\<in> ucycles G. uwalk_length p \\<le> k}\""], ["", "text \\<open>obtains a vertex in a short cycle:\\<close>"], ["", "definition choose_v :: \"ugraph \\<Rightarrow> nat \\<Rightarrow> uvert\" where\n  \"choose_v G k \\<equiv> SOME u. \\<exists>p. p \\<in> short_cycles G k \\<and> u \\<in> set p\""], ["", "partial_function (tailrec) kill_short :: \"ugraph \\<Rightarrow> nat \\<Rightarrow> ugraph\" where\n  \"kill_short G k = (if short_cycles G k = {} then G else (kill_short (G -- (choose_v G k)) k))\""], ["", "lemma ksc_simps[simp]:\n  \"short_cycles G k = {} \\<Longrightarrow> kill_short G k = G\"\n  \"short_cycles G k \\<noteq> {}  \\<Longrightarrow> kill_short G k = kill_short (G -- (choose_v G k)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (short_cycles G k = {} \\<Longrightarrow> kill_short G k = G) &&&\n    (short_cycles G k \\<noteq> {} \\<Longrightarrow>\n     kill_short G k = kill_short (G -- choose_v G k) k)", "by (auto simp: kill_short.simps)"], ["", "lemma\n  assumes \"short_cycles G k \\<noteq> {}\"\n  shows choose_v__in_uverts: \"choose_v G k \\<in> uverts G\" (is ?t1)\n    and choose_v__in_short: \"\\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p\" (is ?t2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_v G k \\<in> uverts G &&&\n    \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. choose_v G k \\<in> uverts G\n 2. \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p", "from assms"], ["proof (chain)\npicking this:\n  short_cycles G k \\<noteq> {}", "obtain p where \"p \\<in> ucycles G\" \"uwalk_length p \\<le> k\""], ["proof (prove)\nusing this:\n  short_cycles G k \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> ucycles G; uwalk_length p \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding short_cycles_def"], ["proof (prove)\nusing this:\n  {p \\<in> ucycles G. uwalk_length p \\<le> k} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> ucycles G; uwalk_length p \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p \\<in> ucycles G\n  uwalk_length p \\<le> k\n\ngoal (2 subgoals):\n 1. choose_v G k \\<in> uverts G\n 2. \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p", "moreover"], ["proof (state)\nthis:\n  p \\<in> ucycles G\n  uwalk_length p \\<le> k\n\ngoal (2 subgoals):\n 1. choose_v G k \\<in> uverts G\n 2. \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p", "then"], ["proof (chain)\npicking this:\n  p \\<in> ucycles G\n  uwalk_length p \\<le> k", "obtain u where \"u \\<in> set p\""], ["proof (prove)\nusing this:\n  p \\<in> ucycles G\n  uwalk_length p \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> set p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ucycles_def"], ["proof (prove)\nusing this:\n  p \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n              p \\<in> uwalks G \\<and> distinct (tl p) \\<and> hd p = last p}\n  uwalk_length p \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> set p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) (auto simp: uwalk_length_conv)"], ["proof (state)\nthis:\n  u \\<in> set p\n\ngoal (2 subgoals):\n 1. choose_v G k \\<in> uverts G\n 2. \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p", "ultimately"], ["proof (chain)\npicking this:\n  p \\<in> ucycles G\n  uwalk_length p \\<le> k\n  u \\<in> set p", "have \"\\<exists>u p. p \\<in> short_cycles G k \\<and> u \\<in> set p\""], ["proof (prove)\nusing this:\n  p \\<in> ucycles G\n  uwalk_length p \\<le> k\n  u \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<exists>u p. p \\<in> short_cycles G k \\<and> u \\<in> set p", "by (auto simp: short_cycles_def)"], ["proof (state)\nthis:\n  \\<exists>u p. p \\<in> short_cycles G k \\<and> u \\<in> set p\n\ngoal (2 subgoals):\n 1. choose_v G k \\<in> uverts G\n 2. \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p", "then"], ["proof (chain)\npicking this:\n  \\<exists>u p. p \\<in> short_cycles G k \\<and> u \\<in> set p", "show ?t2"], ["proof (prove)\nusing this:\n  \\<exists>u p. p \\<in> short_cycles G k \\<and> u \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p", "by (auto simp: choose_v_def intro!: someI_ex)"], ["proof (state)\nthis:\n  \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p\n\ngoal (1 subgoal):\n 1. choose_v G k \\<in> uverts G", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p", "show ?t1"], ["proof (prove)\nusing this:\n  \\<exists>p. p \\<in> short_cycles G k \\<and> choose_v G k \\<in> set p\n\ngoal (1 subgoal):\n 1. choose_v G k \\<in> uverts G", "by (auto simp: short_cycles_def ucycles_def uwalks_def)"], ["proof (state)\nthis:\n  choose_v G k \\<in> uverts G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kill_step_smaller:\n  assumes \"short_cycles G k \\<noteq> {}\"\n  shows \"short_cycles (G -- (choose_v G k)) k \\<subset> short_cycles G k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "let ?cv = \"choose_v G k\""], ["proof (state)\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "from assms"], ["proof (chain)\npicking this:\n  short_cycles G k \\<noteq> {}", "obtain p where \"p \\<in> short_cycles G k\" \"?cv \\<in> set p\""], ["proof (prove)\nusing this:\n  short_cycles G k \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> short_cycles G k; choose_v G k \\<in> set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule choose_v__in_short)"], ["proof (state)\nthis:\n  p \\<in> short_cycles G k\n  choose_v G k \\<in> set p\n\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "have \"short_cycles (G -- ?cv) k \\<subseteq> short_cycles G k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subseteq> short_cycles G k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> short_cycles (G -- choose_v G k) k \\<Longrightarrow>\n       x \\<in> short_cycles G k", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> short_cycles (G -- choose_v G k) k \\<Longrightarrow>\n       x \\<in> short_cycles G k", "assume \"p \\<in> short_cycles (G -- ?cv) k\""], ["proof (state)\nthis:\n  p \\<in> short_cycles (G -- choose_v G k) k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> short_cycles (G -- choose_v G k) k \\<Longrightarrow>\n       x \\<in> short_cycles G k", "then"], ["proof (chain)\npicking this:\n  p \\<in> short_cycles (G -- choose_v G k) k", "show \"p \\<in> short_cycles G k\""], ["proof (prove)\nusing this:\n  p \\<in> short_cycles (G -- choose_v G k) k\n\ngoal (1 subgoal):\n 1. p \\<in> short_cycles G k", "unfolding short_cycles_def ucycles_def uwalks_def"], ["proof (prove)\nusing this:\n  p \\<in> {p \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n                       p \\<in> {p. set p\n                                   \\<subseteq> uverts\n          (G -- choose_v G k) \\<and>\n                                   set (uwalk_edges p)\n                                   \\<subseteq> uedges\n          (G -- choose_v G k) \\<and>\n                                   p \\<noteq> []} \\<and>\n                       distinct (tl p) \\<and> hd p = last p}.\n           uwalk_length p \\<le> k}\n\ngoal (1 subgoal):\n 1. p \\<in> {p \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n                         p \\<in> {p. set p \\<subseteq> uverts G \\<and>\n                                     set (uwalk_edges p)\n                                     \\<subseteq> uedges G \\<and>\n                                     p \\<noteq> []} \\<and>\n                         distinct (tl p) \\<and> hd p = last p}.\n             uwalk_length p \\<le> k}", "using edges_Gu[of G ?cv]"], ["proof (prove)\nusing this:\n  p \\<in> {p \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n                       p \\<in> {p. set p\n                                   \\<subseteq> uverts\n          (G -- choose_v G k) \\<and>\n                                   set (uwalk_edges p)\n                                   \\<subseteq> uedges\n          (G -- choose_v G k) \\<and>\n                                   p \\<noteq> []} \\<and>\n                       distinct (tl p) \\<and> hd p = last p}.\n           uwalk_length p \\<le> k}\n  uedges (G -- choose_v G k) \\<subseteq> uedges G\n\ngoal (1 subgoal):\n 1. p \\<in> {p \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n                         p \\<in> {p. set p \\<subseteq> uverts G \\<and>\n                                     set (uwalk_edges p)\n                                     \\<subseteq> uedges G \\<and>\n                                     p \\<noteq> []} \\<and>\n                         distinct (tl p) \\<and> hd p = last p}.\n             uwalk_length p \\<le> k}", "by (auto simp: verts_Gu)"], ["proof (state)\nthis:\n  p \\<in> short_cycles G k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  short_cycles (G -- choose_v G k) k \\<subseteq> short_cycles G k\n\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "moreover"], ["proof (state)\nthis:\n  short_cycles (G -- choose_v G k) k \\<subseteq> short_cycles G k\n\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "have \"p \\<notin> short_cycles (G -- ?cv) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> short_cycles (G -- choose_v G k) k", "using \\<open>?cv \\<in> set p\\<close>"], ["proof (prove)\nusing this:\n  choose_v G k \\<in> set p\n\ngoal (1 subgoal):\n 1. p \\<notin> short_cycles (G -- choose_v G k) k", "by (auto simp: short_cycles_def ucycles_def uwalks_def verts_Gu)"], ["proof (state)\nthis:\n  p \\<notin> short_cycles (G -- choose_v G k) k\n\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "ultimately"], ["proof (chain)\npicking this:\n  short_cycles (G -- choose_v G k) k \\<subseteq> short_cycles G k\n  p \\<notin> short_cycles (G -- choose_v G k) k", "show ?thesis"], ["proof (prove)\nusing this:\n  short_cycles (G -- choose_v G k) k \\<subseteq> short_cycles G k\n  p \\<notin> short_cycles (G -- choose_v G k) k\n\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "using \\<open>p \\<in> short_cycles G k\\<close>"], ["proof (prove)\nusing this:\n  short_cycles (G -- choose_v G k) k \\<subseteq> short_cycles G k\n  p \\<notin> short_cycles (G -- choose_v G k) k\n  p \\<in> short_cycles G k\n\ngoal (1 subgoal):\n 1. short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k", "by auto"], ["proof (state)\nthis:\n  short_cycles (G -- choose_v G k) k \\<subset> short_cycles G k\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Induction rule for @{term kill_short}:\\<close>"], ["", "lemma kill_short_induct[consumes 1, case_names empty kill_vert]:\n  assumes fin: \"finite (uverts G)\"\n  assumes a_empty: \"\\<And>G. short_cycles G k = {} \\<Longrightarrow> P G k\"\n  assumes a_kill: \"\\<And>G. finite (short_cycles G k) \\<Longrightarrow> short_cycles G k \\<noteq> {}\n    \\<Longrightarrow> P (G -- (choose_v G k)) k \\<Longrightarrow> P G k\"\n  shows \"P G k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P G k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P G k", "have \"finite (short_cycles G k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (short_cycles G k)", "using finite_ucycles[OF fin]"], ["proof (prove)\nusing this:\n  finite (ucycles G)\n\ngoal (1 subgoal):\n 1. finite (short_cycles G k)", "by (auto simp: short_cycles_def)"], ["proof (state)\nthis:\n  finite (short_cycles G k)\n\ngoal (1 subgoal):\n 1. P G k", "then"], ["proof (chain)\npicking this:\n  finite (short_cycles G k)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (short_cycles G k)\n\ngoal (1 subgoal):\n 1. P G k", "by (induct \"short_cycles G k\" arbitrary: G rule: finite_psubset_induct)\n      (metis kill_step_smaller a_kill a_empty)"], ["proof (state)\nthis:\n  P G k\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Large Girth (after @{term kill_short}):\\<close>"], ["", "lemma kill_short_large_girth:\n  assumes \"finite (uverts G)\"\n  shows \"k < girth (kill_short G k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat k < girth (kill_short G k)", "using assms"], ["proof (prove)\nusing this:\n  finite (uverts G)\n\ngoal (1 subgoal):\n 1. enat k < girth (kill_short G k)", "proof (induct G k rule: kill_short_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       enat k < girth (kill_short G k)\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        enat k < girth (kill_short (G -- choose_v G k) k)\\<rbrakk>\n       \\<Longrightarrow> enat k < girth (kill_short G k)", "case (empty G)"], ["proof (state)\nthis:\n  short_cycles G k = {}\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       enat k < girth (kill_short G k)\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        enat k < girth (kill_short (G -- choose_v G k) k)\\<rbrakk>\n       \\<Longrightarrow> enat k < girth (kill_short G k)", "then"], ["proof (chain)\npicking this:\n  short_cycles G k = {}", "have \"\\<And>p. p \\<in> ucycles G \\<Longrightarrow> k < enat (uwalk_length p)\""], ["proof (prove)\nusing this:\n  short_cycles G k = {}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> ucycles G \\<Longrightarrow> enat k < enat (uwalk_length p)", "by (auto simp: short_cycles_def)"], ["proof (state)\nthis:\n  ?p \\<in> ucycles G \\<Longrightarrow> enat k < enat (uwalk_length ?p)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       enat k < girth (kill_short G k)\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        enat k < girth (kill_short (G -- choose_v G k) k)\\<rbrakk>\n       \\<Longrightarrow> enat k < girth (kill_short G k)", "with empty"], ["proof (chain)\npicking this:\n  short_cycles G k = {}\n  ?p \\<in> ucycles G \\<Longrightarrow> enat k < enat (uwalk_length ?p)", "show ?case"], ["proof (prove)\nusing this:\n  short_cycles G k = {}\n  ?p \\<in> ucycles G \\<Longrightarrow> enat k < enat (uwalk_length ?p)\n\ngoal (1 subgoal):\n 1. enat k < girth (kill_short G k)", "by (auto simp: girth_def intro: enat_less_INF_I)"], ["proof (state)\nthis:\n  enat k < girth (kill_short G k)\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        enat k < girth (kill_short (G -- choose_v G k) k)\\<rbrakk>\n       \\<Longrightarrow> enat k < girth (kill_short G k)", "qed simp"], ["", "text \\<open>Order of graph (after @{term kill_short}):\\<close>"], ["", "lemma kill_short_order_of_graph:\n  assumes \"finite (uverts G)\"\n  shows \"card (uverts G) - card (short_cycles G k) \\<le> card (uverts (kill_short G k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (uverts G) - card (short_cycles G k)\n    \\<le> card (uverts (kill_short G k))", "using assms assms"], ["proof (prove)\nusing this:\n  finite (uverts G)\n  finite (uverts G)\n\ngoal (1 subgoal):\n 1. card (uverts G) - card (short_cycles G k)\n    \\<le> card (uverts (kill_short G k))", "proof (induct G k rule: kill_short_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "case (kill_vert G)"], ["proof (state)\nthis:\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n  card (uverts (G -- choose_v G k)) -\n  card (short_cycles (G -- choose_v G k) k)\n  \\<le> card (uverts (kill_short (G -- choose_v G k) k))\n  finite (uverts G)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "let ?oG = \"G -- (choose_v G k)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "have \"finite (uverts ?oG)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (uverts (G -- choose_v G k))", "using kill_vert"], ["proof (prove)\nusing this:\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n  card (uverts (G -- choose_v G k)) -\n  card (short_cycles (G -- choose_v G k) k)\n  \\<le> card (uverts (kill_short (G -- choose_v G k) k))\n  finite (uverts G)\n\ngoal (1 subgoal):\n 1. finite (uverts (G -- choose_v G k))", "by (auto simp: remove_vertex_def)"], ["proof (state)\nthis:\n  finite (uverts (G -- choose_v G k))\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "moreover"], ["proof (state)\nthis:\n  finite (uverts (G -- choose_v G k))\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "have \"uverts (kill_short G k) = uverts (kill_short ?oG k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uverts (kill_short G k) = uverts (kill_short (G -- choose_v G k) k)", "using kill_vert"], ["proof (prove)\nusing this:\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n  card (uverts (G -- choose_v G k)) -\n  card (short_cycles (G -- choose_v G k) k)\n  \\<le> card (uverts (kill_short (G -- choose_v G k) k))\n  finite (uverts G)\n\ngoal (1 subgoal):\n 1. uverts (kill_short G k) = uverts (kill_short (G -- choose_v G k) k)", "by simp"], ["proof (state)\nthis:\n  uverts (kill_short G k) = uverts (kill_short (G -- choose_v G k) k)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "moreover"], ["proof (state)\nthis:\n  uverts (kill_short G k) = uverts (kill_short (G -- choose_v G k) k)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "have \"card (uverts G) = Suc (card (uverts ?oG))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (uverts G) = Suc (card (uverts (G -- choose_v G k)))", "using choose_v__in_uverts kill_vert"], ["proof (prove)\nusing this:\n  short_cycles ?G ?k \\<noteq> {} \\<Longrightarrow>\n  choose_v ?G ?k \\<in> uverts ?G\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n  card (uverts (G -- choose_v G k)) -\n  card (short_cycles (G -- choose_v G k) k)\n  \\<le> card (uverts (kill_short (G -- choose_v G k) k))\n  finite (uverts G)\n\ngoal (1 subgoal):\n 1. card (uverts G) = Suc (card (uverts (G -- choose_v G k)))", "by (simp add: remove_vertex_def card_Suc_Diff1 del: card_Diff_insert)"], ["proof (state)\nthis:\n  card (uverts G) = Suc (card (uverts (G -- choose_v G k)))\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "moreover"], ["proof (state)\nthis:\n  card (uverts G) = Suc (card (uverts (G -- choose_v G k)))\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "have \"card (short_cycles ?oG k) < card (short_cycles G k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (short_cycles (G -- choose_v G k) k) < card (short_cycles G k)", "by (intro psubset_card_mono kill_vert.hyps kill_step_smaller)"], ["proof (state)\nthis:\n  card (short_cycles (G -- choose_v G k) k) < card (short_cycles G k)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n        card (uverts (G -- choose_v G k)) -\n        card (short_cycles (G -- choose_v G k) k)\n        \\<le> card (uverts (kill_short (G -- choose_v G k) k));\n        finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "ultimately"], ["proof (chain)\npicking this:\n  finite (uverts (G -- choose_v G k))\n  uverts (kill_short G k) = uverts (kill_short (G -- choose_v G k) k)\n  card (uverts G) = Suc (card (uverts (G -- choose_v G k)))\n  card (short_cycles (G -- choose_v G k) k) < card (short_cycles G k)", "show ?case"], ["proof (prove)\nusing this:\n  finite (uverts (G -- choose_v G k))\n  uverts (kill_short G k) = uverts (kill_short (G -- choose_v G k) k)\n  card (uverts G) = Suc (card (uverts (G -- choose_v G k)))\n  card (short_cycles (G -- choose_v G k) k) < card (short_cycles G k)\n\ngoal (1 subgoal):\n 1. card (uverts G) - card (short_cycles G k)\n    \\<le> card (uverts (kill_short G k))", "using kill_vert.hyps"], ["proof (prove)\nusing this:\n  finite (uverts (G -- choose_v G k))\n  uverts (kill_short G k) = uverts (kill_short (G -- choose_v G k) k)\n  card (uverts G) = Suc (card (uverts (G -- choose_v G k)))\n  card (short_cycles (G -- choose_v G k) k) < card (short_cycles G k)\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  finite (uverts (G -- choose_v G k)) \\<Longrightarrow>\n  card (uverts (G -- choose_v G k)) -\n  card (short_cycles (G -- choose_v G k) k)\n  \\<le> card (uverts (kill_short (G -- choose_v G k) k))\n\ngoal (1 subgoal):\n 1. card (uverts G) - card (short_cycles G k)\n    \\<le> card (uverts (kill_short G k))", "by presburger"], ["proof (state)\nthis:\n  card (uverts G) - card (short_cycles G k)\n  \\<le> card (uverts (kill_short G k))\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; finite (uverts G)\\<rbrakk>\n       \\<Longrightarrow> card (uverts G) - card (short_cycles G k)\n                         \\<le> card (uverts (kill_short G k))", "qed simp"], ["", "text \\<open>Independence number (after @{term kill_short}):\\<close>"], ["", "lemma kill_short_\\<alpha>:\n  assumes \"finite (uverts G)\"\n  shows \"\\<alpha> (kill_short G k) \\<le> \\<alpha> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "using assms"], ["proof (prove)\nusing this:\n  finite (uverts G)\n\ngoal (1 subgoal):\n 1. \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "proof (induct G k rule: kill_short_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       \\<alpha> (kill_short G k) \\<le> \\<alpha> G\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        \\<alpha> (kill_short (G -- choose_v G k) k)\n        \\<le> \\<alpha> (G -- choose_v G k)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "case (kill_vert G)"], ["proof (state)\nthis:\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  \\<alpha> (kill_short (G -- choose_v G k) k)\n  \\<le> \\<alpha> (G -- choose_v G k)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       \\<alpha> (kill_short G k) \\<le> \\<alpha> G\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        \\<alpha> (kill_short (G -- choose_v G k) k)\n        \\<le> \\<alpha> (G -- choose_v G k)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "note kill_vert(3)"], ["proof (state)\nthis:\n  \\<alpha> (kill_short (G -- choose_v G k) k)\n  \\<le> \\<alpha> (G -- choose_v G k)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       \\<alpha> (kill_short G k) \\<le> \\<alpha> G\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        \\<alpha> (kill_short (G -- choose_v G k) k)\n        \\<le> \\<alpha> (G -- choose_v G k)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "also"], ["proof (state)\nthis:\n  \\<alpha> (kill_short (G -- choose_v G k) k)\n  \\<le> \\<alpha> (G -- choose_v G k)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       \\<alpha> (kill_short G k) \\<le> \\<alpha> G\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        \\<alpha> (kill_short (G -- choose_v G k) k)\n        \\<le> \\<alpha> (G -- choose_v G k)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "have \"\\<alpha> (G -- (choose_v G k)) \\<le> \\<alpha> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (G -- choose_v G k) \\<le> \\<alpha> G", "by (rule \\<alpha>_remove_le)"], ["proof (state)\nthis:\n  \\<alpha> (G -- choose_v G k) \\<le> \\<alpha> G\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       \\<alpha> (kill_short G k) \\<le> \\<alpha> G\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        \\<alpha> (kill_short (G -- choose_v G k) k)\n        \\<le> \\<alpha> (G -- choose_v G k)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> (kill_short (G -- choose_v G k) k) \\<le> \\<alpha> G", "show ?case"], ["proof (prove)\nusing this:\n  \\<alpha> (kill_short (G -- choose_v G k) k) \\<le> \\<alpha> G\n\ngoal (1 subgoal):\n 1. \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "using kill_vert"], ["proof (prove)\nusing this:\n  \\<alpha> (kill_short (G -- choose_v G k) k) \\<le> \\<alpha> G\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  \\<alpha> (kill_short (G -- choose_v G k) k)\n  \\<le> \\<alpha> (G -- choose_v G k)\n\ngoal (1 subgoal):\n 1. \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "by simp"], ["proof (state)\nthis:\n  \\<alpha> (kill_short G k) \\<le> \\<alpha> G\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       short_cycles G k = {} \\<Longrightarrow>\n       \\<alpha> (kill_short G k) \\<le> \\<alpha> G", "qed simp"], ["", "text \\<open>Wellformedness (after @{term kill_short}):\\<close>"], ["", "lemma kill_short_uwellformed:\n  assumes \"finite (uverts G)\" \"uwellformed G\"\n  shows \"uwellformed (kill_short G k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uwellformed (kill_short G k)", "using assms"], ["proof (prove)\nusing this:\n  finite (uverts G)\n  uwellformed G\n\ngoal (1 subgoal):\n 1. uwellformed (kill_short G k)", "proof (induct G k rule: kill_short_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; uwellformed G\\<rbrakk>\n       \\<Longrightarrow> uwellformed (kill_short G k)\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        uwellformed (G -- choose_v G k) \\<Longrightarrow>\n        uwellformed (kill_short (G -- choose_v G k) k);\n        uwellformed G\\<rbrakk>\n       \\<Longrightarrow> uwellformed (kill_short G k)", "case (kill_vert G)"], ["proof (state)\nthis:\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  uwellformed (G -- choose_v G k) \\<Longrightarrow>\n  uwellformed (kill_short (G -- choose_v G k) k)\n  uwellformed G\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; uwellformed G\\<rbrakk>\n       \\<Longrightarrow> uwellformed (kill_short G k)\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        uwellformed (G -- choose_v G k) \\<Longrightarrow>\n        uwellformed (kill_short (G -- choose_v G k) k);\n        uwellformed G\\<rbrakk>\n       \\<Longrightarrow> uwellformed (kill_short G k)", "from kill_vert.prems"], ["proof (chain)\npicking this:\n  uwellformed G", "have \"uwellformed (G -- (choose_v G k))\""], ["proof (prove)\nusing this:\n  uwellformed G\n\ngoal (1 subgoal):\n 1. uwellformed (G -- choose_v G k)", "by (auto simp: uwellformed_def remove_vertex_def)"], ["proof (state)\nthis:\n  uwellformed (G -- choose_v G k)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; uwellformed G\\<rbrakk>\n       \\<Longrightarrow> uwellformed (kill_short G k)\n 2. \\<And>G.\n       \\<lbrakk>finite (short_cycles G k); short_cycles G k \\<noteq> {};\n        uwellformed (G -- choose_v G k) \\<Longrightarrow>\n        uwellformed (kill_short (G -- choose_v G k) k);\n        uwellformed G\\<rbrakk>\n       \\<Longrightarrow> uwellformed (kill_short G k)", "with kill_vert.hyps"], ["proof (chain)\npicking this:\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  uwellformed (G -- choose_v G k) \\<Longrightarrow>\n  uwellformed (kill_short (G -- choose_v G k) k)\n  uwellformed (G -- choose_v G k)", "show ?case"], ["proof (prove)\nusing this:\n  finite (short_cycles G k)\n  short_cycles G k \\<noteq> {}\n  uwellformed (G -- choose_v G k) \\<Longrightarrow>\n  uwellformed (kill_short (G -- choose_v G k) k)\n  uwellformed (G -- choose_v G k)\n\ngoal (1 subgoal):\n 1. uwellformed (kill_short G k)", "by simp"], ["proof (state)\nthis:\n  uwellformed (kill_short G k)\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>short_cycles G k = {}; uwellformed G\\<rbrakk>\n       \\<Longrightarrow> uwellformed (kill_short G k)", "qed simp"], ["", "section \\<open>The Chromatic-Girth Theorem\\<close>"], ["", "text \\<open>Probability of Independent Edges:\\<close>"], ["", "lemma (in edge_space) random_prob_independent:\n  assumes \"n \\<ge> k\" \"k \\<ge> 2\"\n  shows \"prob {es \\<in> space P. k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> (n choose k)*(1-p)^(k choose 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "let \"?k_sets\" = \"{vs. vs \\<subseteq> S_verts \\<and> card vs = k}\""], ["proof (state)\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "fix vs"], ["proof (state)\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "assume A: \"vs \\<in> ?k_sets\""], ["proof (state)\nthis:\n  vs \\<in> {vs. vs \\<subseteq> S_verts \\<and> card vs = k}\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "then"], ["proof (chain)\npicking this:\n  vs \\<in> {vs. vs \\<subseteq> S_verts \\<and> card vs = k}", "have B: \"all_edges vs \\<subseteq> S_edges\""], ["proof (prove)\nusing this:\n  vs \\<in> {vs. vs \\<subseteq> S_verts \\<and> card vs = k}\n\ngoal (1 subgoal):\n 1. all_edges vs \\<subseteq> S_edges", "unfolding all_edges_def S_edges_def"], ["proof (prove)\nusing this:\n  vs \\<in> {vs. vs \\<subseteq> S_verts \\<and> card vs = k}\n\ngoal (1 subgoal):\n 1. mk_uedge ` {uv \\<in> vs \\<times> vs. fst uv \\<noteq> snd uv}\n    \\<subseteq> mk_uedge `\n                {uv \\<in> S_verts \\<times> S_verts. fst uv \\<noteq> snd uv}", "by blast"], ["proof (state)\nthis:\n  all_edges vs \\<subseteq> S_edges\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "have \"{es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)}\n        = cylinder S_edges {} (all_edges vs)\" (is \"?L = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n    cylinder S_edges {} (all_edges vs)", "using A"], ["proof (prove)\nusing this:\n  vs \\<in> {vs. vs \\<subseteq> S_verts \\<and> card vs = k}\n\ngoal (1 subgoal):\n 1. {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n    cylinder S_edges {} (all_edges vs)", "by (auto simp: independent_sets_def edge_ugraph_def space_eq cylinder_def)"], ["proof (state)\nthis:\n  {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n  cylinder S_edges {} (all_edges vs)\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "then"], ["proof (chain)\npicking this:\n  {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n  cylinder S_edges {} (all_edges vs)", "have \"prob ?L = (1-p)^(k choose 2)\""], ["proof (prove)\nusing this:\n  {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n  cylinder S_edges {} (all_edges vs)\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n    (1 - p) ^ (k choose 2)", "using A B finite"], ["proof (prove)\nusing this:\n  {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n  cylinder S_edges {} (all_edges vs)\n  vs \\<in> {vs. vs \\<subseteq> S_verts \\<and> card vs = k}\n  all_edges vs \\<subseteq> S_edges\n  finite ?A\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n    (1 - p) ^ (k choose 2)", "by (auto simp: cylinder_prob card_all_edges dest: finite_subset)"], ["proof (state)\nthis:\n  prob {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)} =\n  (1 - p) ^ (k choose 2)\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "}"], ["proof (state)\nthis:\n  ?vs3\n  \\<in> {vs. vs \\<subseteq> S_verts \\<and> card vs = k} \\<Longrightarrow>\n  prob {es \\<in> space P. ?vs3 \\<in> independent_sets (edge_ugraph es)} =\n  (1 - p) ^ (k choose 2)\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "note prob_k_indep = this\n    \\<comment> \\<open>probability that a fixed set of k vertices is independent in a random graph\\<close>"], ["proof (state)\nthis:\n  ?vs3\n  \\<in> {vs. vs \\<subseteq> S_verts \\<and> card vs = k} \\<Longrightarrow>\n  prob {es \\<in> space P. ?vs3 \\<in> independent_sets (edge_ugraph es)} =\n  (1 - p) ^ (k choose 2)\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "have \"{es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)}\n    = (\\<Union>vs \\<in> ?k_sets. {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)})\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)} =\n    (\\<Union>vs\\<in>{vs. vs \\<subseteq> S_verts \\<and> card vs = k}.\n        {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)})", "unfolding image_def space_eq independent_sets_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {es \\<in> Pow S_edges.\n     k \\<in> {y. \\<exists>x\\<in>{vs.\n                                 vs \\<subseteq> uverts\n           (edge_ugraph es) \\<and>\n                                 all_edges vs \\<inter>\n                                 uedges (edge_ugraph es) =\n                                 {}}.\n                    y = card x}} =\n    \\<Union>\n     {y. \\<exists>x\\<in>{vs. vs \\<subseteq> S_verts \\<and> card vs = k}.\n            y =\n            {es \\<in> Pow S_edges.\n             x \\<in> {vs.\n                      vs \\<subseteq> uverts (edge_ugraph es) \\<and>\n                      all_edges vs \\<inter> uedges (edge_ugraph es) = {}}}}", "by auto"], ["proof (state)\nthis:\n  {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)} =\n  (\\<Union>vs\\<in>{vs. vs \\<subseteq> S_verts \\<and> card vs = k}.\n      {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)})\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "then"], ["proof (chain)\npicking this:\n  {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)} =\n  (\\<Union>vs\\<in>{vs. vs \\<subseteq> S_verts \\<and> card vs = k}.\n      {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)})", "have \"prob ?L \\<le> (\\<Sum>vs \\<in> ?k_sets. prob {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)})\""], ["proof (prove)\nusing this:\n  {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)} =\n  (\\<Union>vs\\<in>{vs. vs \\<subseteq> S_verts \\<and> card vs = k}.\n      {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)})\n\ngoal (1 subgoal):\n 1. prob\n     {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)}\n    \\<le> (\\<Sum>vs | vs \\<subseteq> S_verts \\<and> card vs = k.\n             prob\n              {es \\<in> space P.\n               vs \\<in> independent_sets (edge_ugraph es)})", "by (auto intro!: finite_measure_subadditive_finite simp: space_eq sets_eq)"], ["proof (state)\nthis:\n  prob {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)}\n  \\<le> (\\<Sum>vs | vs \\<subseteq> S_verts \\<and> card vs = k.\n           prob\n            {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)})\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "also"], ["proof (state)\nthis:\n  prob {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)}\n  \\<le> (\\<Sum>vs | vs \\<subseteq> S_verts \\<and> card vs = k.\n           prob\n            {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)})\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "have \"\\<dots> = (n choose k)*((1 - p) ^ (k choose 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>vs | vs \\<subseteq> S_verts \\<and> card vs = k.\n       prob\n        {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)}) =\n    real (n choose k) * (1 - p) ^ (k choose 2)", "by (simp add: prob_k_indep S_verts_def n_subsets)"], ["proof (state)\nthis:\n  (\\<Sum>vs | vs \\<subseteq> S_verts \\<and> card vs = k.\n     prob {es \\<in> space P. vs \\<in> independent_sets (edge_ugraph es)}) =\n  real (n choose k) * (1 - p) ^ (k choose 2)\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "finally"], ["proof (chain)\npicking this:\n  prob {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)}\n  \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  prob {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)}\n  \\<le> real (n choose k) * (1 - p) ^ (k choose 2)\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "using \\<open>k \\<ge> 2\\<close>"], ["proof (prove)\nusing this:\n  prob {es \\<in> space P. k \\<in> card ` independent_sets (edge_ugraph es)}\n  \\<le> real (n choose k) * (1 - p) ^ (k choose 2)\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n    \\<le> real (n choose k) * (1 - p) ^ (k choose 2)", "by (simp add: le_\\<alpha>_iff)"], ["proof (state)\nthis:\n  prob {es \\<in> space P. enat k \\<le> \\<alpha> (edge_ugraph es)}\n  \\<le> real (n choose k) * (1 - p) ^ (k choose 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Almost never many independent edges:\\<close>"], ["", "lemma almost_never_le_\\<alpha>:\n  fixes k :: nat\n    and p :: \"nat \\<Rightarrow> real\"\n  assumes p_prob: \"\\<forall>\\<^sup>\\<infinity> n. 0 < p n \\<and> p n < 1\"\n  assumes [arith]: \"k > 0\"\n  assumes N_prop: \"\\<forall>\\<^sup>\\<infinity> n. (6 * k * ln n)/n \\<le> p n\"\n  shows \"(\\<lambda>n. probGn p n (\\<lambda>es. 1/2*n/k \\<le> \\<alpha> (edge_space.edge_ugraph n es))) \\<longlonglongrightarrow> 0\"\n    (is \"(\\<lambda>n. ?prob_fun n) \\<longlonglongrightarrow> 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "let \"?prob_fun_raw n\" = \"probGn p n (\\<lambda>es. nat(ceiling (1/2*n/k)) \\<le> \\<alpha> (edge_space.edge_ugraph n es))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "define r where \"r n = 1 / 2 * n / k\" for n :: nat"], ["proof (state)\nthis:\n  r ?n = 1 / 2 * real ?n / real k\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "let ?nr = \"\\<lambda>n. nat(ceiling (r n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "have r_pos: \"\\<And>n. 0 < n \\<Longrightarrow> 0 < r n \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. 0 < n \\<Longrightarrow> 0 < r n", "by (auto simp: r_def field_simps)"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow> 0 < r ?n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "have nr_bounds: \"\\<forall>\\<^sup>\\<infinity> n. 2 \\<le> ?nr n \\<and> ?nr n \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n       nat \\<lceil>r n\\<rceil> \\<le> n", "by (intro eventually_sequentiallyI[of \"4 * k\"])\n       (simp add: r_def nat_ceiling_le_eq le_natceiling_iff field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "from nr_bounds p_prob"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1", "have ev_prob_fun_raw_le:\n    \"\\<forall>\\<^sup>\\<infinity> n. probGn p n (\\<lambda>es. ?nr n\\<le> \\<alpha> (edge_space.edge_ugraph n es))\n      \\<le> (n * exp (- p n * (real (?nr n) - 1) / 2)) powr ?nr n\"\n    (is \"\\<forall>\\<^sup>\\<infinity> n. ?prob_fun_raw_le n\")"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       probGn p n\n        (\\<lambda>es.\n            enat (nat \\<lceil>r n\\<rceil>)\n            \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n       \\<le> (real n *\n              exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n             real (nat \\<lceil>r n\\<rceil>)", "proof (rule eventually_elim2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "assume A: \"2 \\<le> ?nr n \\<and> ?nr n \\<le> n\" \"0 < p n \\<and>p n < 1\""], ["proof (state)\nthis:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "then"], ["proof (chain)\npicking this:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1", "interpret pG: edge_space n \"p n\""], ["proof (prove)\nusing this:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. edge_space (p n)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "have r: \"real (?nr n - Suc 0) = real (?nr n) - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (nat \\<lceil>r n\\<rceil> - Suc 0) =\n    real (nat \\<lceil>r n\\<rceil>) - real (Suc 0)", "using A"], ["proof (prove)\nusing this:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. real (nat \\<lceil>r n\\<rceil> - Suc 0) =\n    real (nat \\<lceil>r n\\<rceil>) - real (Suc 0)", "by auto"], ["proof (state)\nthis:\n  real (nat \\<lceil>r n\\<rceil> - Suc 0) =\n  real (nat \\<lceil>r n\\<rceil>) - real (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "have [simp]: \"n>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using A"], ["proof (prove)\nusing this:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. 0 < n", "by linarith"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "have \"probGn p n (\\<lambda>es. ?nr n \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n        \\<le> (n choose ?nr n) * (1 - p n)^(?nr n choose 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pG.prob\n     {es \\<in> space pG.P.\n      enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n    \\<le> real (n choose nat \\<lceil>r n\\<rceil>) *\n          (1 - p n) ^ (nat \\<lceil>r n\\<rceil> choose 2)", "using A"], ["proof (prove)\nusing this:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. pG.prob\n     {es \\<in> space pG.P.\n      enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n    \\<le> real (n choose nat \\<lceil>r n\\<rceil>) *\n          (1 - p n) ^ (nat \\<lceil>r n\\<rceil> choose 2)", "by (auto intro: pG.random_prob_independent)"], ["proof (state)\nthis:\n  pG.prob\n   {es \\<in> space pG.P.\n    enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n  \\<le> real (n choose nat \\<lceil>r n\\<rceil>) *\n        (1 - p n) ^ (nat \\<lceil>r n\\<rceil> choose 2)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "also"], ["proof (state)\nthis:\n  pG.prob\n   {es \\<in> space pG.P.\n    enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n  \\<le> real (n choose nat \\<lceil>r n\\<rceil>) *\n        (1 - p n) ^ (nat \\<lceil>r n\\<rceil> choose 2)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "have \"\\<dots> \\<le> n powr ?nr n * (1 - p n) powr (?nr n choose 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n choose nat \\<lceil>r n\\<rceil>) *\n    (1 - p n) ^ (nat \\<lceil>r n\\<rceil> choose 2)\n    \\<le> real n powr real (nat \\<lceil>r n\\<rceil>) *\n          (1 - p n) powr real (nat \\<lceil>r n\\<rceil> choose 2)", "using A"], ["proof (prove)\nusing this:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. real (n choose nat \\<lceil>r n\\<rceil>) *\n    (1 - p n) ^ (nat \\<lceil>r n\\<rceil> choose 2)\n    \\<le> real n powr real (nat \\<lceil>r n\\<rceil>) *\n          (1 - p n) powr real (nat \\<lceil>r n\\<rceil> choose 2)", "by (simp add: powr_realpow of_nat_power [symmetric] binomial_le_pow  del: of_nat_power)"], ["proof (state)\nthis:\n  real (n choose nat \\<lceil>r n\\<rceil>) *\n  (1 - p n) ^ (nat \\<lceil>r n\\<rceil> choose 2)\n  \\<le> real n powr real (nat \\<lceil>r n\\<rceil>) *\n        (1 - p n) powr real (nat \\<lceil>r n\\<rceil> choose 2)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "also"], ["proof (state)\nthis:\n  real (n choose nat \\<lceil>r n\\<rceil>) *\n  (1 - p n) ^ (nat \\<lceil>r n\\<rceil> choose 2)\n  \\<le> real n powr real (nat \\<lceil>r n\\<rceil>) *\n        (1 - p n) powr real (nat \\<lceil>r n\\<rceil> choose 2)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "have \"\\<dots> = n powr ?nr n * (1 - p n) powr (?nr n * (?nr n - 1) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    (1 - p n) powr real (nat \\<lceil>r n\\<rceil> choose 2) =\n    real n powr real (nat \\<lceil>r n\\<rceil>) *\n    (1 - p n) powr\n    (real (nat \\<lceil>r n\\<rceil> * (nat \\<lceil>r n\\<rceil> - 1)) / 2)", "by (cases \"even (?nr n - 1)\")\n        (auto simp add: n_choose_2_nat real_of_nat_div)"], ["proof (state)\nthis:\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  (1 - p n) powr real (nat \\<lceil>r n\\<rceil> choose 2) =\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  (1 - p n) powr\n  (real (nat \\<lceil>r n\\<rceil> * (nat \\<lceil>r n\\<rceil> - 1)) / 2)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "also"], ["proof (state)\nthis:\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  (1 - p n) powr real (nat \\<lceil>r n\\<rceil> choose 2) =\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  (1 - p n) powr\n  (real (nat \\<lceil>r n\\<rceil> * (nat \\<lceil>r n\\<rceil> - 1)) / 2)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "have \"\\<dots> = n powr ?nr n * ((1 - p n) powr ((?nr n - 1) / 2)) powr ?nr n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    (1 - p n) powr\n    (real (nat \\<lceil>r n\\<rceil> * (nat \\<lceil>r n\\<rceil> - 1)) / 2) =\n    real n powr real (nat \\<lceil>r n\\<rceil>) *\n    ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)", "by (auto simp add: powr_powr r ac_simps)"], ["proof (state)\nthis:\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  (1 - p n) powr\n  (real (nat \\<lceil>r n\\<rceil> * (nat \\<lceil>r n\\<rceil> - 1)) / 2) =\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n  real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "also"], ["proof (state)\nthis:\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  (1 - p n) powr\n  (real (nat \\<lceil>r n\\<rceil> * (nat \\<lceil>r n\\<rceil> - 1)) / 2) =\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n  real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "have \"\\<dots> \\<le> (n * exp (- p n * (?nr n - 1) / 2)) powr ?nr n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (real n *\n           exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (real n *\n           exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "have \"(1 - p n) powr ((?nr n - 1) / 2) \\<le> exp (- p n) powr ((?nr n - 1) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n    \\<le> exp (- p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)", "using A"], ["proof (prove)\nusing this:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. (1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n    \\<le> exp (- p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)", "by (auto simp: powr_mono2 diff_conv_add_uminus simp del: add_uminus_conv_diff)"], ["proof (state)\nthis:\n  (1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n  \\<le> exp (- p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (real n *\n           exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "also"], ["proof (state)\nthis:\n  (1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n  \\<le> exp (- p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (real n *\n           exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "have \"\\<dots> = exp (- p n * (?nr n - 1) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2) =\n    exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)", "by (auto simp: powr_def)"], ["proof (state)\nthis:\n  exp (- p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2) =\n  exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (real n *\n           exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "finally"], ["proof (chain)\npicking this:\n  (1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n  \\<le> exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n  \\<le> exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (real n *\n           exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "using A"], ["proof (prove)\nusing this:\n  (1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n  \\<le> exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. real n powr real (nat \\<lceil>r n\\<rceil>) *\n    ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (real n *\n           exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "by (auto simp: powr_mono2 powr_mult)"], ["proof (state)\nthis:\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n  real (nat \\<lceil>r n\\<rceil>)\n  \\<le> (real n * exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real n powr real (nat \\<lceil>r n\\<rceil>) *\n  ((1 - p n) powr (real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n  real (nat \\<lceil>r n\\<rceil>)\n  \\<le> (real n * exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                nat \\<lceil>r n\\<rceil> \\<le> n;\n        0 < p n \\<and> p n < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p n\n                          (\\<lambda>es.\n                              enat (nat \\<lceil>r n\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n                         \\<le> (real n *\n                                exp (- p n *\n                                     (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                                     2)) powr\n                               real (nat \\<lceil>r n\\<rceil>)", "finally"], ["proof (chain)\npicking this:\n  pG.prob\n   {es \\<in> space pG.P.\n    enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n  \\<le> (real n * exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)", "show \"probGn p n (\\<lambda>es. ?nr n \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n      \\<le> (n * exp (- p n * (real (?nr n) - 1) / 2)) powr ?nr n\""], ["proof (prove)\nusing this:\n  pG.prob\n   {es \\<in> space pG.P.\n    enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n  \\<le> (real n * exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. pG.prob\n     {es \\<in> space pG.P.\n      enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n    \\<le> (real n *\n           exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "using A r"], ["proof (prove)\nusing this:\n  pG.prob\n   {es \\<in> space pG.P.\n    enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n  \\<le> (real n * exp (- p n * real (nat \\<lceil>r n\\<rceil> - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  0 < p n \\<and> p n < 1\n  real (nat \\<lceil>r n\\<rceil> - Suc 0) =\n  real (nat \\<lceil>r n\\<rceil>) - real (Suc 0)\n\ngoal (1 subgoal):\n 1. pG.prob\n     {es \\<in> space pG.P.\n      enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n    \\<le> (real n *\n           exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "by simp"], ["proof (state)\nthis:\n  pG.prob\n   {es \\<in> space pG.P.\n    enat (nat \\<lceil>r n\\<rceil>) \\<le> \\<alpha> (pG.edge_ugraph es)}\n  \\<le> (real n *\n         exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     probGn p n\n      (\\<lambda>es.\n          enat (nat \\<lceil>r n\\<rceil>)\n          \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n     \\<le> (real n *\n            exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n           real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "from p_prob N_prop"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) / real n \\<le> p n", "have ev_expr_bound: \"\\<forall>\\<^sup>\\<infinity> n. n * exp (-p n * (real (?nr n) - 1) / 2) \\<le> (exp 1 / n) powr (1 / 2)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) / real n \\<le> p n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n       \\<le> (exp 1 / real n) powr (1 / 2)", "proof (elim eventually_rev_mp, intro eventually_sequentiallyI conjI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "assume n_bound[arith]: \"2 \\<le> n\"\n      and p_bound: \"0 < p n \\<and> p n < 1\" \"(6 * k * ln n) / n \\<le> p n\""], ["proof (state)\nthis:\n  2 \\<le> n\n  0 < p n \\<and> p n < 1\n  real (6 * k) * ln (real n) / real n \\<le> p n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have r_bound: \"r n \\<le> ?nr n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r n \\<le> real (nat \\<lceil>r n\\<rceil>)", "by (rule real_nat_ceiling_ge)"], ["proof (state)\nthis:\n  r n \\<le> real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have \"n * exp (-p n * (real (?nr n)- 1) / 2) \\<le> n * exp (- 3 / 2 * ln n + p n / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)", "have \"0 < ln n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ln (real n)", "using \"n_bound\""], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 < ln (real n)", "by auto"], ["proof (state)\nthis:\n  0 < ln (real n)\n\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)", "then"], ["proof (chain)\npicking this:\n  0 < ln (real n)", "have \"(3 / 2) * ln n \\<le> ((6 * k * ln n) / n) * (?nr n / 2)\""], ["proof (prove)\nusing this:\n  0 < ln (real n)\n\ngoal (1 subgoal):\n 1. 3 / 2 * ln (real n)\n    \\<le> real (6 * k) * ln (real n) / real n *\n          (real (nat \\<lceil>r n\\<rceil>) / 2)", "using r_bound le_of_int_ceiling[of \"n/2*k\"]"], ["proof (prove)\nusing this:\n  0 < ln (real n)\n  r n \\<le> real (nat \\<lceil>r n\\<rceil>)\n  real n / 2 * real k \\<le> real_of_int \\<lceil>real n / 2 * real k\\<rceil>\n\ngoal (1 subgoal):\n 1. 3 / 2 * ln (real n)\n    \\<le> real (6 * k) * ln (real n) / real n *\n          (real (nat \\<lceil>r n\\<rceil>) / 2)", "by (simp add: r_def field_simps del: le_of_int_ceiling)"], ["proof (state)\nthis:\n  3 / 2 * ln (real n)\n  \\<le> real (6 * k) * ln (real n) / real n *\n        (real (nat \\<lceil>r n\\<rceil>) / 2)\n\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)", "also"], ["proof (state)\nthis:\n  3 / 2 * ln (real n)\n  \\<le> real (6 * k) * ln (real n) / real n *\n        (real (nat \\<lceil>r n\\<rceil>) / 2)\n\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)", "have \"\\<dots> \\<le> p n * (?nr n / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (6 * k) * ln (real n) / real n *\n    (real (nat \\<lceil>r n\\<rceil>) / 2)\n    \\<le> p n * (real (nat \\<lceil>r n\\<rceil>) / 2)", "using n_bound p_bound r_bound r_pos[of n]"], ["proof (prove)\nusing this:\n  2 \\<le> n\n  0 < p n \\<and> p n < 1\n  real (6 * k) * ln (real n) / real n \\<le> p n\n  r n \\<le> real (nat \\<lceil>r n\\<rceil>)\n  0 < n \\<Longrightarrow> 0 < r n\n\ngoal (1 subgoal):\n 1. real (6 * k) * ln (real n) / real n *\n    (real (nat \\<lceil>r n\\<rceil>) / 2)\n    \\<le> p n * (real (nat \\<lceil>r n\\<rceil>) / 2)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  real (6 * k) * ln (real n) / real n * (real (nat \\<lceil>r n\\<rceil>) / 2)\n  \\<le> p n * (real (nat \\<lceil>r n\\<rceil>) / 2)\n\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)", "finally"], ["proof (chain)\npicking this:\n  3 / 2 * ln (real n) \\<le> p n * (real (nat \\<lceil>r n\\<rceil>) / 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  3 / 2 * ln (real n) \\<le> p n * (real (nat \\<lceil>r n\\<rceil>) / 2)\n\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)", "using r_bound"], ["proof (prove)\nusing this:\n  3 / 2 * ln (real n) \\<le> p n * (real (nat \\<lceil>r n\\<rceil>) / 2)\n  r n \\<le> real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n  \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n  \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "also"], ["proof (state)\nthis:\n  real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n  \\<le> real n * exp (- 3 / 2 * ln (real n) + p n / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have \"\\<dots> \\<le> n * n powr (- 3 / 2) * exp 1 powr (1 / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n * exp (- 3 / 2 * ln (real n) + p n / 2)\n    \\<le> real n * real n powr (- 3 / 2) * exp 1 powr (1 / 2)", "using p_bound"], ["proof (prove)\nusing this:\n  0 < p n \\<and> p n < 1\n  real (6 * k) * ln (real n) / real n \\<le> p n\n\ngoal (1 subgoal):\n 1. real n * exp (- 3 / 2 * ln (real n) + p n / 2)\n    \\<le> real n * real n powr (- 3 / 2) * exp 1 powr (1 / 2)", "by (simp add: powr_def exp_add [symmetric])"], ["proof (state)\nthis:\n  real n * exp (- 3 / 2 * ln (real n) + p n / 2)\n  \\<le> real n * real n powr (- 3 / 2) * exp 1 powr (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "also"], ["proof (state)\nthis:\n  real n * exp (- 3 / 2 * ln (real n) + p n / 2)\n  \\<le> real n * real n powr (- 3 / 2) * exp 1 powr (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have \"\\<dots> \\<le> n powr (-1 / 2) * exp 1 powr (1 / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n * real n powr (- 3 / 2) * exp 1 powr (1 / 2)\n    \\<le> real n powr (- 1 / 2) * exp 1 powr (1 / 2)", "by (simp add: powr_mult_base)"], ["proof (state)\nthis:\n  real n * real n powr (- 3 / 2) * exp 1 powr (1 / 2)\n  \\<le> real n powr (- 1 / 2) * exp 1 powr (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "also"], ["proof (state)\nthis:\n  real n * real n powr (- 3 / 2) * exp 1 powr (1 / 2)\n  \\<le> real n powr (- 1 / 2) * exp 1 powr (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have \"\\<dots> = (exp 1 / n) powr (1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n powr (- 1 / 2) * exp 1 powr (1 / 2) =\n    (exp 1 / real n) powr (1 / 2)", "by (simp add: powr_divide powr_minus_divide)"], ["proof (state)\nthis:\n  real n powr (- 1 / 2) * exp 1 powr (1 / 2) = (exp 1 / real n) powr (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real (6 * k) * ln (real n) / real n \\<le> p n;\n        ?c6 \\<le> x; real (6 * k) * ln (real x) / real x \\<le> p x;\n        0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> real x *\n                         exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) /\n                              2)\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "finally"], ["proof (chain)\npicking this:\n  real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n  \\<le> (exp 1 / real n) powr (1 / 2)", "show \"n * exp (- p n * (real (?nr n) - 1) / 2) \\<le> (exp 1 / n) powr (1 / 2)\""], ["proof (prove)\nusing this:\n  real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n  \\<le> (exp 1 / real n) powr (1 / 2)\n\ngoal (1 subgoal):\n 1. real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n    \\<le> (exp 1 / real n) powr (1 / 2)", "."], ["proof (state)\nthis:\n  real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n  \\<le> (exp 1 / real n) powr (1 / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n     \\<le> (exp 1 / real n) powr (1 / 2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "have ceil_bound: \"\\<And>G n. 1/2*n/k \\<le> \\<alpha> G \\<longleftrightarrow> nat(ceiling (1/2*n/k)) \\<le> \\<alpha> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G n.\n       (ereal (1 / 2 * n / real k) \\<le> ereal_of_enat (\\<alpha> G)) =\n       (enat (nat \\<lceil>1 / 2 * n / real k\\<rceil>) \\<le> \\<alpha> G)", "by (case_tac \"\\<alpha> G\") (auto simp: nat_ceiling_le_eq)"], ["proof (state)\nthis:\n  (ereal (1 / 2 * ?n / real k) \\<le> ereal_of_enat (\\<alpha> ?G)) =\n  (enat (nat \\<lceil>1 / 2 * ?n / real k\\<rceil>) \\<le> \\<alpha> ?G)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "proof (unfold ceil_bound, rule real_tendsto_sandwich)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       ?f n\n       \\<le> probGn p n\n              (\\<lambda>es.\n                  enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n                  \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n 2. \\<forall>\\<^sup>\\<infinity>n.\n       probGn p n\n        (\\<lambda>es.\n            enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n            \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n       \\<le> ?h n\n 3. ?f \\<longlonglongrightarrow> 0\n 4. ?h \\<longlonglongrightarrow> 0", "show \"(\\<lambda>n. 0) \\<longlonglongrightarrow> 0\"\n        \"(\\<lambda>n. (exp 1 / n) powr (1 / 2)) \\<longlonglongrightarrow> 0\"\n        \"\\<forall>\\<^sup>\\<infinity> n. 0 \\<le> ?prob_fun_raw n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 0::'a) \\<longlonglongrightarrow> (0::'a) &&&\n    (\\<lambda>n. (exp 1 / real n) powr (1 / 2))\n    \\<longlonglongrightarrow> 0 &&&\n    \\<forall>\\<^sup>\\<infinity>n.\n       0 \\<le> probGn p n\n                (\\<lambda>es.\n                    enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n                    \\<le> \\<alpha> (edge_space.edge_ugraph n es))", "using p_prob"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 0::'a) \\<longlonglongrightarrow> (0::'a) &&&\n    (\\<lambda>n. (exp 1 / real n) powr (1 / 2))\n    \\<longlonglongrightarrow> 0 &&&\n    \\<forall>\\<^sup>\\<infinity>n.\n       0 \\<le> probGn p n\n                (\\<lambda>es.\n                    enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n                    \\<le> \\<alpha> (edge_space.edge_ugraph n es))", "by (auto intro: measure_nonneg LIMSEQ_inv_powr elim: eventually_mono)"], ["proof (state)\nthis:\n  (\\<lambda>n. 0::?'a) \\<longlonglongrightarrow> (0::?'a)\n  (\\<lambda>n. (exp 1 / real n) powr (1 / 2)) \\<longlonglongrightarrow> 0\n  \\<forall>\\<^sup>\\<infinity>n.\n     0 \\<le> probGn p n\n              (\\<lambda>es.\n                  enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n                  \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       probGn p n\n        (\\<lambda>es.\n            enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n            \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n       \\<le> (exp 1 / real n) powr (1 / 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       probGn p n\n        (\\<lambda>es.\n            enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n            \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n       \\<le> (exp 1 / real n) powr (1 / 2)", "from nr_bounds ev_expr_bound ev_prob_fun_raw_le"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  \\<forall>\\<^sup>\\<infinity>n.\n     real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n     \\<le> (exp 1 / real n) powr (1 / 2)\n  \\<forall>\\<^sup>\\<infinity>n.\n     probGn p n\n      (\\<lambda>es.\n          enat (nat \\<lceil>r n\\<rceil>)\n          \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n     \\<le> (real n *\n            exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n           real (nat \\<lceil>r n\\<rceil>)", "show \"\\<forall>\\<^sup>\\<infinity> n. ?prob_fun_raw n \\<le> (exp 1 / n) powr (1 / 2)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  \\<forall>\\<^sup>\\<infinity>n.\n     real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n     \\<le> (exp 1 / real n) powr (1 / 2)\n  \\<forall>\\<^sup>\\<infinity>n.\n     probGn p n\n      (\\<lambda>es.\n          enat (nat \\<lceil>r n\\<rceil>)\n          \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n     \\<le> (real n *\n            exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n           real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       probGn p n\n        (\\<lambda>es.\n            enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n            \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n       \\<le> (exp 1 / real n) powr (1 / 2)", "proof (elim eventually_rev_mp, intro eventually_sequentiallyI impI conjI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "assume A: \"3 \\<le> n\"\n        and nr_bounds: \"2 \\<le> ?nr n \\<and> ?nr n \\<le> n\"\n        and prob_fun_raw_le: \"?prob_fun_raw_le n\"\n        and expr_bound: \"n * exp (- p n * (real (nat(ceiling (r n))) - 1) / 2) \\<le> (exp 1 / n) powr (1 / 2)\""], ["proof (state)\nthis:\n  3 \\<le> n\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  probGn p n\n   (\\<lambda>es.\n       enat (nat \\<lceil>r n\\<rceil>)\n       \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n  \\<le> (real n *\n         exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n  real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n  \\<le> (exp 1 / real n) powr (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have \"exp 1 < (3 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 < 3", "by (approximation 6)"], ["proof (state)\nthis:\n  exp 1 < 3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "then"], ["proof (chain)\npicking this:\n  exp 1 < 3", "have \"(exp 1 / n) powr (1 / 2) \\<le> 1 powr (1 / 2)\""], ["proof (prove)\nusing this:\n  exp 1 < 3\n\ngoal (1 subgoal):\n 1. (exp 1 / real n) powr (1 / 2) \\<le> 1 powr (1 / 2)", "using A"], ["proof (prove)\nusing this:\n  exp 1 < 3\n  3 \\<le> n\n\ngoal (1 subgoal):\n 1. (exp 1 / real n) powr (1 / 2) \\<le> 1 powr (1 / 2)", "by (intro powr_mono2) (auto simp: field_simps)"], ["proof (state)\nthis:\n  (exp 1 / real n) powr (1 / 2) \\<le> 1 powr (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "then"], ["proof (chain)\npicking this:\n  (exp 1 / real n) powr (1 / 2) \\<le> 1 powr (1 / 2)", "have ep_bound: \"(exp 1 / n) powr (1 / 2) \\<le> 1\""], ["proof (prove)\nusing this:\n  (exp 1 / real n) powr (1 / 2) \\<le> 1 powr (1 / 2)\n\ngoal (1 subgoal):\n 1. (exp 1 / real n) powr (1 / 2) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  (exp 1 / real n) powr (1 / 2) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have \"?prob_fun_raw n \\<le> (n * exp (- p n * (real (?nr n) - 1) / 2)) powr (?nr n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. probGn p n\n     (\\<lambda>es.\n         enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n         \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n    \\<le> (real n *\n           exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "using prob_fun_raw_le"], ["proof (prove)\nusing this:\n  probGn p n\n   (\\<lambda>es.\n       enat (nat \\<lceil>r n\\<rceil>)\n       \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n  \\<le> (real n *\n         exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. probGn p n\n     (\\<lambda>es.\n         enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n         \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n    \\<le> (real n *\n           exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "by (simp add: r_def)"], ["proof (state)\nthis:\n  probGn p n\n   (\\<lambda>es.\n       enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n       \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n  \\<le> (real n *\n         exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "also"], ["proof (state)\nthis:\n  probGn p n\n   (\\<lambda>es.\n       enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n       \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n  \\<le> (real n *\n         exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n        real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have \"\\<dots> \\<le> ((exp 1 / n) powr (1 / 2)) powr ?nr n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> ((exp 1 / real n) powr (1 / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "using expr_bound A"], ["proof (prove)\nusing this:\n  real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n  \\<le> (exp 1 / real n) powr (1 / 2)\n  3 \\<le> n\n\ngoal (1 subgoal):\n 1. (real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n    real (nat \\<lceil>r n\\<rceil>)\n    \\<le> ((exp 1 / real n) powr (1 / 2)) powr\n          real (nat \\<lceil>r n\\<rceil>)", "by (auto simp: powr_mono2)"], ["proof (state)\nthis:\n  (real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n  real (nat \\<lceil>r n\\<rceil>)\n  \\<le> ((exp 1 / real n) powr (1 / 2)) powr real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "also"], ["proof (state)\nthis:\n  (real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)) powr\n  real (nat \\<lceil>r n\\<rceil>)\n  \\<le> ((exp 1 / real n) powr (1 / 2)) powr real (nat \\<lceil>r n\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "have \"\\<dots> \\<le> ((exp 1 / n) powr (1 / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((exp 1 / real n) powr (1 / 2)) powr real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (exp 1 / real n) powr (1 / 2)", "using nr_bounds ep_bound A"], ["proof (prove)\nusing this:\n  2 \\<le> nat \\<lceil>r n\\<rceil> \\<and> nat \\<lceil>r n\\<rceil> \\<le> n\n  (exp 1 / real n) powr (1 / 2) \\<le> 1\n  3 \\<le> n\n\ngoal (1 subgoal):\n 1. ((exp 1 / real n) powr (1 / 2)) powr real (nat \\<lceil>r n\\<rceil>)\n    \\<le> (exp 1 / real n) powr (1 / 2)", "by (auto simp: powr_le_one_le)"], ["proof (state)\nthis:\n  ((exp 1 / real n) powr (1 / 2)) powr real (nat \\<lceil>r n\\<rceil>)\n  \\<le> (exp 1 / real n) powr (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n.\n                   2 \\<le> nat \\<lceil>r n\\<rceil> \\<and>\n                   nat \\<lceil>r n\\<rceil> \\<le> n;\n        \\<forall>\\<^sup>\\<infinity>n.\n           real n * exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) / 2)\n           \\<le> (exp 1 / real n) powr (1 / 2);\n        \\<forall>\\<^sup>\\<infinity>n.\n           probGn p n\n            (\\<lambda>es.\n                enat (nat \\<lceil>r n\\<rceil>)\n                \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n           \\<le> (real n *\n                  exp (- p n * (real (nat \\<lceil>r n\\<rceil>) - 1) /\n                       2)) powr\n                 real (nat \\<lceil>r n\\<rceil>);\n        ?c9 \\<le> x;\n        probGn p x\n         (\\<lambda>es.\n             enat (nat \\<lceil>r x\\<rceil>)\n             \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n        \\<le> (real x *\n               exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)) powr\n              real (nat \\<lceil>r x\\<rceil>);\n        real x * exp (- p x * (real (nat \\<lceil>r x\\<rceil>) - 1) / 2)\n        \\<le> (exp 1 / real x) powr (1 / 2);\n        2 \\<le> nat \\<lceil>r x\\<rceil> \\<and>\n        nat \\<lceil>r x\\<rceil> \\<le> x\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              enat\n                               (nat \\<lceil>1 / 2 * real x / real k\\<rceil>)\n                              \\<le> \\<alpha> (edge_space.edge_ugraph x es))\n                         \\<le> (exp 1 / real x) powr (1 / 2)", "finally"], ["proof (chain)\npicking this:\n  probGn p n\n   (\\<lambda>es.\n       enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n       \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n  \\<le> (exp 1 / real n) powr (1 / 2)", "show \"?prob_fun_raw n \\<le> (exp 1 / n) powr (1 / 2)\""], ["proof (prove)\nusing this:\n  probGn p n\n   (\\<lambda>es.\n       enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n       \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n  \\<le> (exp 1 / real n) powr (1 / 2)\n\ngoal (1 subgoal):\n 1. probGn p n\n     (\\<lambda>es.\n         enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n         \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n    \\<le> (exp 1 / real n) powr (1 / 2)", "."], ["proof (state)\nthis:\n  probGn p n\n   (\\<lambda>es.\n       enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n       \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n  \\<le> (exp 1 / real n) powr (1 / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     probGn p n\n      (\\<lambda>es.\n          enat (nat \\<lceil>1 / 2 * real n / real k\\<rceil>)\n          \\<le> \\<alpha> (edge_space.edge_ugraph n es))\n     \\<le> (exp 1 / real n) powr (1 / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      probGn p n\n       (\\<lambda>es.\n           ereal (1 / 2 * real n / real k)\n           \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n  \\<longlonglongrightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Mean number of k-cycles in a graph. (Or rather of paths describing a circle of length @{term k}):\\<close>"], ["", "lemma (in edge_space) mean_k_cycles:\n  assumes \"3 \\<le> k\" \"k < n\"\n  shows \"(\\<integral>es. card {c \\<in> ucycles (edge_ugraph es). uwalk_length c = k} \\<partial> P)\n    = of_nat (fact n div fact (n - k)) * p ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "let ?k_cycle = \"\\<lambda>es c k. c \\<in> ucycles (edge_ugraph es) \\<and> uwalk_length c = k\""], ["proof (state)\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "define C where \"C k = {c. ?k_cycle S_edges c k}\" for k\n    \\<comment> \\<open>@{term \"C k\"} is the set of all possible cycles of size @{term k} in @{term \"edge_ugraph S_edges\"}\\<close>"], ["proof (state)\nthis:\n  C ?k = {c \\<in> ucycles (edge_ugraph S_edges). uwalk_length c = ?k}\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "define XG  where \"XG es = {c. ?k_cycle es c k}\" for es\n    \\<comment> \\<open>@{term \"XG es\"} is the set of cycles contained in a @{term \"edge_ugraph es\"}\\<close>"], ["proof (state)\nthis:\n  XG ?es = {c \\<in> ucycles (edge_ugraph ?es). uwalk_length c = k}\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "define XC where \"XC c = {es \\<in> space P. ?k_cycle es c k}\" for c\n    \\<comment> \\<open>\"@{term \"XC c\"} is the set of graphs (edge sets) containing a cycle c\"\\<close>"], ["proof (state)\nthis:\n  XC ?c =\n  {es \\<in> space P.\n   ?c \\<in> ucycles (edge_ugraph es) \\<and> uwalk_length ?c = k}\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "then"], ["proof (chain)\npicking this:\n  XC ?c =\n  {es \\<in> space P.\n   ?c \\<in> ucycles (edge_ugraph es) \\<and> uwalk_length ?c = k}", "have XC_in_sets: \"\\<And>c. XC c \\<in> sets P\"\n      and XC_cyl: \"\\<And>c. c \\<in> C k \\<Longrightarrow> XC c = cylinder S_edges (set (uwalk_edges c)) {}\""], ["proof (prove)\nusing this:\n  XC ?c =\n  {es \\<in> space P.\n   ?c \\<in> ucycles (edge_ugraph es) \\<and> uwalk_length ?c = k}\n\ngoal (1 subgoal):\n 1. (\\<And>c. XC c \\<in> events) &&&\n    (\\<And>c.\n        c \\<in> C k \\<Longrightarrow>\n        XC c = cylinder S_edges (set (uwalk_edges c)) {})", "by (auto simp: ucycles_def space_eq uwalks_def C_def cylinder_def sets_eq)"], ["proof (state)\nthis:\n  XC ?c1 \\<in> events\n  ?c1 \\<in> C k \\<Longrightarrow>\n  XC ?c1 = cylinder S_edges (set (uwalk_edges ?c1)) {}\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "have \"(\\<integral>es. card {c \\<in> ucycles (edge_ugraph es). uwalk_length c = k} \\<partial> P)\n      =  (\\<Sum>x\\<in>space P. card (XG x) * prob {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x})", "by (simp add: XG_def integral_finite_singleton space_eq)"], ["proof (state)\nthis:\n  expectation\n   (\\<lambda>x.\n       real (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x})\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "also"], ["proof (state)\nthis:\n  expectation\n   (\\<lambda>x.\n       real (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x})\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "have \"\\<dots> = (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "have XG_Int_C: \"\\<And>s. s \\<in> space P \\<Longrightarrow> C k \\<inter> XG s = XG s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> space P \\<Longrightarrow> C k \\<inter> XG s = XG s", "unfolding XG_def C_def ucycles_def uwalks_def edge_ugraph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> space P \\<Longrightarrow>\n       {c \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n                    p \\<in> {p. set p\n                                \\<subseteq> uverts\n       (S_verts, S_edges \\<inter> S_edges) \\<and>\n                                set (uwalk_edges p)\n                                \\<subseteq> uedges\n       (S_verts, S_edges \\<inter> S_edges) \\<and>\n                                p \\<noteq> []} \\<and>\n                    distinct (tl p) \\<and> hd p = last p}.\n        uwalk_length c = k} \\<inter>\n       {c \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n                    p \\<in> {p. set p\n                                \\<subseteq> uverts\n       (S_verts, s \\<inter> S_edges) \\<and>\n                                set (uwalk_edges p)\n                                \\<subseteq> uedges\n       (S_verts, s \\<inter> S_edges) \\<and>\n                                p \\<noteq> []} \\<and>\n                    distinct (tl p) \\<and> hd p = last p}.\n        uwalk_length c = k} =\n       {c \\<in> {p. 3 \\<le> uwalk_length p \\<and>\n                    p \\<in> {p. set p\n                                \\<subseteq> uverts\n       (S_verts, s \\<inter> S_edges) \\<and>\n                                set (uwalk_edges p)\n                                \\<subseteq> uedges\n       (S_verts, s \\<inter> S_edges) \\<and>\n                                p \\<noteq> []} \\<and>\n                    distinct (tl p) \\<and> hd p = last p}.\n        uwalk_length c = k}", "by auto"], ["proof (state)\nthis:\n  ?s1 \\<in> space P \\<Longrightarrow> C k \\<inter> XG ?s1 = XG ?s1\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "have fin_XC: \"\\<And>k. finite (XC k)\" and fin_C: \"finite (C k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. finite (XC k)) &&& finite (C k)", "unfolding C_def XC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ka.\n        finite\n         {es \\<in> space P.\n          ka \\<in> ucycles (edge_ugraph es) \\<and> uwalk_length ka = k}) &&&\n    finite {c \\<in> ucycles (edge_ugraph S_edges). uwalk_length c = k}", "by (auto simp: finite_edges space_eq intro!: finite_ucycles)"], ["proof (state)\nthis:\n  finite (XC ?k1)\n  finite (C k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "have \"(\\<Sum>x\\<in>space P. card (XG x) * prob {x}) = (\\<Sum>x\\<in>space P. (\\<Sum>c \\<in> XG x. prob {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>x\\<in>space P. \\<Sum>c\\<in>XG x. prob {x})", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n  (\\<Sum>x\\<in>space P. \\<Sum>c\\<in>XG x. prob {x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n  (\\<Sum>x\\<in>space P. \\<Sum>c\\<in>XG x. prob {x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "have \"\\<dots> = (\\<Sum>x\\<in>space P. (\\<Sum>c \\<in> C k. if c \\<in> XG x then prob {x} else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. \\<Sum>c\\<in>XG x. prob {x}) =\n    (\\<Sum>x\\<in>space P.\n       \\<Sum>c\\<in>C k. if c \\<in> XG x then prob {x} else 0)", "using fin_C"], ["proof (prove)\nusing this:\n  finite (C k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. \\<Sum>c\\<in>XG x. prob {x}) =\n    (\\<Sum>x\\<in>space P.\n       \\<Sum>c\\<in>C k. if c \\<in> XG x then prob {x} else 0)", "by (simp add: sum.If_cases) (simp add: XG_Int_C)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P. \\<Sum>c\\<in>XG x. prob {x}) =\n  (\\<Sum>x\\<in>space P.\n     \\<Sum>c\\<in>C k. if c \\<in> XG x then prob {x} else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P. \\<Sum>c\\<in>XG x. prob {x}) =\n  (\\<Sum>x\\<in>space P.\n     \\<Sum>c\\<in>C k. if c \\<in> XG x then prob {x} else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "have \"\\<dots> = (\\<Sum>c \\<in> C k. (\\<Sum> x \\<in> space P \\<inter> XC c. prob {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P.\n       \\<Sum>c\\<in>C k. if c \\<in> XG x then prob {x} else 0) =\n    (\\<Sum>c\\<in>C k. \\<Sum>x\\<in>space P \\<inter> XC c. prob {x})", "using finite_edges"], ["proof (prove)\nusing this:\n  finite S_edges\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P.\n       \\<Sum>c\\<in>C k. if c \\<in> XG x then prob {x} else 0) =\n    (\\<Sum>c\\<in>C k. \\<Sum>x\\<in>space P \\<inter> XC c. prob {x})", "by (subst sum.swap) (simp add: sum.inter_restrict XG_def XC_def space_eq)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P.\n     \\<Sum>c\\<in>C k. if c \\<in> XG x then prob {x} else 0) =\n  (\\<Sum>c\\<in>C k. \\<Sum>x\\<in>space P \\<inter> XC c. prob {x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P.\n     \\<Sum>c\\<in>C k. if c \\<in> XG x then prob {x} else 0) =\n  (\\<Sum>c\\<in>C k. \\<Sum>x\\<in>space P \\<inter> XC c. prob {x})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "have \"\\<dots> = (\\<Sum>c \\<in> C k. prob (XC c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. \\<Sum>x\\<in>space P \\<inter> XC c. prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (XC c))", "using fin_XC XC_in_sets"], ["proof (prove)\nusing this:\n  finite (XC ?k1)\n  XC ?c1 \\<in> events\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. \\<Sum>x\\<in>space P \\<inter> XC c. prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (XC c))", "by (auto simp add: prob_eq sets_eq space_eq intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>C k. \\<Sum>x\\<in>space P \\<inter> XC c. prob {x}) =\n  (\\<Sum>c\\<in>C k. prob (XC c))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n  (\\<Sum>c\\<in>C k. prob (XC c))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n  (\\<Sum>c\\<in>C k. prob (XC c))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n    (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))", "by (simp add: XC_cyl)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n  (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n  (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>space P. real (card (XG x)) * prob {x}) =\n  (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {}))\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "have \"\\<dots> = (\\<Sum>c\\<in>C k. p ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {})) =\n    (\\<Sum>c\\<in>C k. p ^ k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {})) =\n    (\\<Sum>c\\<in>C k. p ^ k)", "have \"\\<And>x. x \\<in> C k \\<Longrightarrow> card (set (uwalk_edges x)) = uwalk_length x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C k \\<Longrightarrow>\n       card (set (uwalk_edges x)) = uwalk_length x", "by (auto simp: uwalk_length_def C_def ucycles_distinct_edges intro: distinct_card)"], ["proof (state)\nthis:\n  ?x1 \\<in> C k \\<Longrightarrow>\n  card (set (uwalk_edges ?x1)) = uwalk_length ?x1\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {})) =\n    (\\<Sum>c\\<in>C k. p ^ k)", "then"], ["proof (chain)\npicking this:\n  ?x1 \\<in> C k \\<Longrightarrow>\n  card (set (uwalk_edges ?x1)) = uwalk_length ?x1", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x1 \\<in> C k \\<Longrightarrow>\n  card (set (uwalk_edges ?x1)) = uwalk_length ?x1\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {})) =\n    (\\<Sum>c\\<in>C k. p ^ k)", "by (auto simp: C_def ucycles_def uwalks_def cylinder_prob)"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {})) =\n  (\\<Sum>c\\<in>C k. p ^ k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {})) =\n  (\\<Sum>c\\<in>C k. p ^ k)\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "also"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>C k. prob (cylinder S_edges (set (uwalk_edges c)) {})) =\n  (\\<Sum>c\\<in>C k. p ^ k)\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "have \"\\<dots> = of_nat (fact n div fact (n - k)) * p ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "have inj_last_Cons: \"\\<And>A. inj_on (\\<lambda>es. last es # es) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. inj_on (\\<lambda>es. last es # es) A", "by (rule inj_onI) simp"], ["proof (state)\nthis:\n  inj_on (\\<lambda>es. last es # es) ?A1\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "{"], ["proof (state)\nthis:\n  inj_on (\\<lambda>es. last es # es) ?A1\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "fix xs A"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "assume \"3 \\<le> length xs - Suc 0\" \"hd xs = last xs\""], ["proof (state)\nthis:\n  3 \\<le> length xs - Suc 0\n  hd xs = last xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "then"], ["proof (chain)\npicking this:\n  3 \\<le> length xs - Suc 0\n  hd xs = last xs", "have \"xs \\<in> (\\<lambda>xs. last xs # xs) ` A \\<longleftrightarrow> tl xs \\<in> A\""], ["proof (prove)\nusing this:\n  3 \\<le> length xs - Suc 0\n  hd xs = last xs\n\ngoal (1 subgoal):\n 1. (xs \\<in> (\\<lambda>xs. last xs # xs) ` A) = (tl xs \\<in> A)", "by (cases xs) (auto simp: inj_image_mem_iff[OF inj_last_Cons] split: if_split_asm)"], ["proof (state)\nthis:\n  (xs \\<in> (\\<lambda>xs. last xs # xs) ` A) = (tl xs \\<in> A)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "}"], ["proof (state)\nthis:\n  \\<lbrakk>3 \\<le> length ?xs4 - Suc 0; hd ?xs4 = last ?xs4\\<rbrakk>\n  \\<Longrightarrow> (?xs4 \\<in> (\\<lambda>xs. last xs # xs) ` ?A4) =\n                    (tl ?xs4 \\<in> ?A4)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "note image_mem_iff_inst = this"], ["proof (state)\nthis:\n  \\<lbrakk>3 \\<le> length ?xs4 - Suc 0; hd ?xs4 = last ?xs4\\<rbrakk>\n  \\<Longrightarrow> (?xs4 \\<in> (\\<lambda>xs. last xs # xs) ` ?A4) =\n                    (tl ?xs4 \\<in> ?A4)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "{"], ["proof (state)\nthis:\n  \\<lbrakk>3 \\<le> length ?xs4 - Suc 0; hd ?xs4 = last ?xs4\\<rbrakk>\n  \\<Longrightarrow> (?xs4 \\<in> (\\<lambda>xs. last xs # xs) ` ?A4) =\n                    (tl ?xs4 \\<in> ?A4)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "have \"xs \\<in> uwalks (edge_ugraph S_edges) \\<Longrightarrow> set (tl xs) \\<subseteq> S_verts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> uwalks (edge_ugraph S_edges) \\<Longrightarrow>\n    set (tl xs) \\<subseteq> S_verts", "unfolding uwalks_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> {p. set p \\<subseteq> uverts (edge_ugraph S_edges) \\<and>\n                 set (uwalk_edges p)\n                 \\<subseteq> uedges (edge_ugraph S_edges) \\<and>\n                 p \\<noteq> []} \\<Longrightarrow>\n    set (tl xs) \\<subseteq> S_verts", "by (induct xs) auto"], ["proof (state)\nthis:\n  xs \\<in> uwalks (edge_ugraph S_edges) \\<Longrightarrow>\n  set (tl xs) \\<subseteq> S_verts\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "}"], ["proof (state)\nthis:\n  ?xs4 \\<in> uwalks (edge_ugraph S_edges) \\<Longrightarrow>\n  set (tl ?xs4) \\<subseteq> S_verts\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "moreover"], ["proof (state)\nthis:\n  ?xs4 \\<in> uwalks (edge_ugraph S_edges) \\<Longrightarrow>\n  set (tl ?xs4) \\<subseteq> S_verts\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "{"], ["proof (state)\nthis:\n  ?xs4 \\<in> uwalks (edge_ugraph S_edges) \\<Longrightarrow>\n  set (tl ?xs4) \\<subseteq> S_verts\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "assume \"set xs \\<subseteq> S_verts\" \"2 \\<le> length xs\" \"distinct xs\""], ["proof (state)\nthis:\n  set xs \\<subseteq> S_verts\n  2 \\<le> length xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "then"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> S_verts\n  2 \\<le> length xs\n  distinct xs", "have \"(last xs # xs) \\<in> uwalks (edge_ugraph S_edges)\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> S_verts\n  2 \\<le> length xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. last xs # xs \\<in> uwalks (edge_ugraph S_edges)", "proof (induct xs rule: uwalk_edges.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> S_verts; 2 \\<le> length [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> [last []] \\<in> uwalks (edge_ugraph S_edges)\n 2. \\<And>x.\n       \\<lbrakk>set [x] \\<subseteq> S_verts; 2 \\<le> length [x];\n        distinct [x]\\<rbrakk>\n       \\<Longrightarrow> [last [x], x] \\<in> uwalks (edge_ugraph S_edges)\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>set (y # ys) \\<subseteq> S_verts;\n                 2 \\<le> length (y # ys); distinct (y # ys)\\<rbrakk>\n                \\<Longrightarrow> last (y # ys) # y # ys\n                                  \\<in> uwalks (edge_ugraph S_edges);\n        set (x # y # ys) \\<subseteq> S_verts; 2 \\<le> length (x # y # ys);\n        distinct (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> last (x # y # ys) # x # y # ys\n                         \\<in> uwalks (edge_ugraph S_edges)", "case (3 x y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>set (y # ys) \\<subseteq> S_verts; 2 \\<le> length (y # ys);\n   distinct (y # ys)\\<rbrakk>\n  \\<Longrightarrow> last (y # ys) # y # ys\n                    \\<in> uwalks (edge_ugraph S_edges)\n  set (x # y # ys) \\<subseteq> S_verts\n  2 \\<le> length (x # y # ys)\n  distinct (x # y # ys)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> S_verts; 2 \\<le> length [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> [last []] \\<in> uwalks (edge_ugraph S_edges)\n 2. \\<And>x.\n       \\<lbrakk>set [x] \\<subseteq> S_verts; 2 \\<le> length [x];\n        distinct [x]\\<rbrakk>\n       \\<Longrightarrow> [last [x], x] \\<in> uwalks (edge_ugraph S_edges)\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>set (y # ys) \\<subseteq> S_verts;\n                 2 \\<le> length (y # ys); distinct (y # ys)\\<rbrakk>\n                \\<Longrightarrow> last (y # ys) # y # ys\n                                  \\<in> uwalks (edge_ugraph S_edges);\n        set (x # y # ys) \\<subseteq> S_verts; 2 \\<le> length (x # y # ys);\n        distinct (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> last (x # y # ys) # x # y # ys\n                         \\<in> uwalks (edge_ugraph S_edges)", "have S_edges_memI: \"\\<And>x y. x \\<in> S_verts \\<Longrightarrow> y \\<in> S_verts \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> {x, y} \\<in> S_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S_verts; y \\<in> S_verts; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> {x, y} \\<in> S_edges", "unfolding S_edges_def all_edges_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S_verts; y \\<in> S_verts; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> {x, y}\n                         \\<in> {y. \\<exists>x\n      \\<in>{uv \\<in> S_verts \\<times> S_verts. fst uv \\<noteq> snd uv}.\ny = mk_uedge x}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> S_verts; ?y2 \\<in> S_verts; ?x2 \\<noteq> ?y2\\<rbrakk>\n  \\<Longrightarrow> {?x2, ?y2} \\<in> S_edges\n\ngoal (3 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> S_verts; 2 \\<le> length [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> [last []] \\<in> uwalks (edge_ugraph S_edges)\n 2. \\<And>x.\n       \\<lbrakk>set [x] \\<subseteq> S_verts; 2 \\<le> length [x];\n        distinct [x]\\<rbrakk>\n       \\<Longrightarrow> [last [x], x] \\<in> uwalks (edge_ugraph S_edges)\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>set (y # ys) \\<subseteq> S_verts;\n                 2 \\<le> length (y # ys); distinct (y # ys)\\<rbrakk>\n                \\<Longrightarrow> last (y # ys) # y # ys\n                                  \\<in> uwalks (edge_ugraph S_edges);\n        set (x # y # ys) \\<subseteq> S_verts; 2 \\<le> length (x # y # ys);\n        distinct (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> last (x # y # ys) # x # y # ys\n                         \\<in> uwalks (edge_ugraph S_edges)", "have \"ys \\<noteq> [] \\<Longrightarrow> set ys \\<subseteq> S_verts \\<Longrightarrow> last ys \\<in> S_verts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> []; set ys \\<subseteq> S_verts\\<rbrakk>\n    \\<Longrightarrow> last ys \\<in> S_verts", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>ys \\<noteq> []; set ys \\<subseteq> S_verts\\<rbrakk>\n  \\<Longrightarrow> last ys \\<in> S_verts\n\ngoal (3 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> S_verts; 2 \\<le> length [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> [last []] \\<in> uwalks (edge_ugraph S_edges)\n 2. \\<And>x.\n       \\<lbrakk>set [x] \\<subseteq> S_verts; 2 \\<le> length [x];\n        distinct [x]\\<rbrakk>\n       \\<Longrightarrow> [last [x], x] \\<in> uwalks (edge_ugraph S_edges)\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>set (y # ys) \\<subseteq> S_verts;\n                 2 \\<le> length (y # ys); distinct (y # ys)\\<rbrakk>\n                \\<Longrightarrow> last (y # ys) # y # ys\n                                  \\<in> uwalks (edge_ugraph S_edges);\n        set (x # y # ys) \\<subseteq> S_verts; 2 \\<le> length (x # y # ys);\n        distinct (x # y # ys)\\<rbrakk>\n       \\<Longrightarrow> last (x # y # ys) # x # y # ys\n                         \\<in> uwalks (edge_ugraph S_edges)", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>set (y # ys) \\<subseteq> S_verts; 2 \\<le> length (y # ys);\n   distinct (y # ys)\\<rbrakk>\n  \\<Longrightarrow> last (y # ys) # y # ys\n                    \\<in> uwalks (edge_ugraph S_edges)\n  set (x # y # ys) \\<subseteq> S_verts\n  2 \\<le> length (x # y # ys)\n  distinct (x # y # ys)\n  \\<lbrakk>ys \\<noteq> []; set ys \\<subseteq> S_verts\\<rbrakk>\n  \\<Longrightarrow> last ys \\<in> S_verts", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (y # ys) \\<subseteq> S_verts; 2 \\<le> length (y # ys);\n   distinct (y # ys)\\<rbrakk>\n  \\<Longrightarrow> last (y # ys) # y # ys\n                    \\<in> uwalks (edge_ugraph S_edges)\n  set (x # y # ys) \\<subseteq> S_verts\n  2 \\<le> length (x # y # ys)\n  distinct (x # y # ys)\n  \\<lbrakk>ys \\<noteq> []; set ys \\<subseteq> S_verts\\<rbrakk>\n  \\<Longrightarrow> last ys \\<in> S_verts\n\ngoal (1 subgoal):\n 1. last (x # y # ys) # x # y # ys \\<in> uwalks (edge_ugraph S_edges)", "by (auto simp add: uwalks_def Suc_le_eq intro: S_edges_memI)"], ["proof (state)\nthis:\n  last (x # y # ys) # x # y # ys \\<in> uwalks (edge_ugraph S_edges)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> S_verts; 2 \\<le> length [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> [last []] \\<in> uwalks (edge_ugraph S_edges)\n 2. \\<And>x.\n       \\<lbrakk>set [x] \\<subseteq> S_verts; 2 \\<le> length [x];\n        distinct [x]\\<rbrakk>\n       \\<Longrightarrow> [last [x], x] \\<in> uwalks (edge_ugraph S_edges)", "qed simp_all"], ["proof (state)\nthis:\n  last xs # xs \\<in> uwalks (edge_ugraph S_edges)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set ?xs4 \\<subseteq> S_verts; 2 \\<le> length ?xs4;\n   distinct ?xs4\\<rbrakk>\n  \\<Longrightarrow> last ?xs4 # ?xs4 \\<in> uwalks (edge_ugraph S_edges)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>set ?xs4 \\<subseteq> S_verts; 2 \\<le> length ?xs4;\n   distinct ?xs4\\<rbrakk>\n  \\<Longrightarrow> last ?xs4 # ?xs4 \\<in> uwalks (edge_ugraph S_edges)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "note \\<open>3 \\<le> k\\<close>"], ["proof (state)\nthis:\n  3 \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "ultimately"], ["proof (chain)\npicking this:\n  ?xs4 \\<in> uwalks (edge_ugraph S_edges) \\<Longrightarrow>\n  set (tl ?xs4) \\<subseteq> S_verts\n  \\<lbrakk>set ?xs4 \\<subseteq> S_verts; 2 \\<le> length ?xs4;\n   distinct ?xs4\\<rbrakk>\n  \\<Longrightarrow> last ?xs4 # ?xs4 \\<in> uwalks (edge_ugraph S_edges)\n  3 \\<le> k", "have \"C k = (\\<lambda>xs. last xs # xs) ` {xs. length xs = k \\<and> distinct xs \\<and> set xs \\<subseteq> S_verts}\""], ["proof (prove)\nusing this:\n  ?xs4 \\<in> uwalks (edge_ugraph S_edges) \\<Longrightarrow>\n  set (tl ?xs4) \\<subseteq> S_verts\n  \\<lbrakk>set ?xs4 \\<subseteq> S_verts; 2 \\<le> length ?xs4;\n   distinct ?xs4\\<rbrakk>\n  \\<Longrightarrow> last ?xs4 # ?xs4 \\<in> uwalks (edge_ugraph S_edges)\n  3 \\<le> k\n\ngoal (1 subgoal):\n 1. C k =\n    (\\<lambda>xs. last xs # xs) `\n    {xs. length xs = k \\<and> distinct xs \\<and> set xs \\<subseteq> S_verts}", "by (auto simp: C_def ucycles_def uwalk_length_conv image_mem_iff_inst)"], ["proof (state)\nthis:\n  C k =\n  (\\<lambda>xs. last xs # xs) `\n  {xs. length xs = k \\<and> distinct xs \\<and> set xs \\<subseteq> S_verts}\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "moreover"], ["proof (state)\nthis:\n  C k =\n  (\\<lambda>xs. last xs # xs) `\n  {xs. length xs = k \\<and> distinct xs \\<and> set xs \\<subseteq> S_verts}\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "have \"card S_verts = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card S_verts = n", "by (simp add: S_verts_def)"], ["proof (state)\nthis:\n  card S_verts = n\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "ultimately"], ["proof (chain)\npicking this:\n  C k =\n  (\\<lambda>xs. last xs # xs) `\n  {xs. length xs = k \\<and> distinct xs \\<and> set xs \\<subseteq> S_verts}\n  card S_verts = n", "have \"card (C k) = fact n div fact (n - k)\""], ["proof (prove)\nusing this:\n  C k =\n  (\\<lambda>xs. last xs # xs) `\n  {xs. length xs = k \\<and> distinct xs \\<and> set xs \\<subseteq> S_verts}\n  card S_verts = n\n\ngoal (1 subgoal):\n 1. card (C k) = fact n div fact (n - k)", "using \\<open>k < n\\<close>"], ["proof (prove)\nusing this:\n  C k =\n  (\\<lambda>xs. last xs # xs) `\n  {xs. length xs = k \\<and> distinct xs \\<and> set xs \\<subseteq> S_verts}\n  card S_verts = n\n  k < n\n\ngoal (1 subgoal):\n 1. card (C k) = fact n div fact (n - k)", "by (simp add: card_image[OF inj_last_Cons] card_lists_distinct_length_eq' fact_div_fact)"], ["proof (state)\nthis:\n  card (C k) = fact n div fact (n - k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "then"], ["proof (chain)\npicking this:\n  card (C k) = fact n div fact (n - k)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (C k) = fact n div fact (n - k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>C k. p ^ k) = real (fact n div fact (n - k)) * p ^ k\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "finally"], ["proof (chain)\npicking this:\n  expectation\n   (\\<lambda>x.\n       real (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n  real (fact n div fact (n - k)) * p ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  expectation\n   (\\<lambda>x.\n       real (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n  real (fact n div fact (n - k)) * p ^ k\n\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>x.\n         real\n          (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n    real (fact n div fact (n - k)) * p ^ k", "by simp"], ["proof (state)\nthis:\n  expectation\n   (\\<lambda>x.\n       real (card {c \\<in> ucycles (edge_ugraph x). uwalk_length c = k})) =\n  real (fact n div fact (n - k)) * p ^ k\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Girth-Chromatic number theorem:\\<close>"], ["", "theorem girth_chromatic:\n  fixes l :: nat\n  shows \"\\<exists>G. uwellformed G \\<and> l < girth G \\<and> l < chromatic_number G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "define k where \"k = max 3 l\""], ["proof (state)\nthis:\n  k = max 3 l\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "define \\<epsilon> where \"\\<epsilon> = 1 / (2 * k)\""], ["proof (state)\nthis:\n  \\<epsilon> = 1 / real (2 * k)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "define p where \"p n = real n powr (\\<epsilon> - 1)\" for n :: nat"], ["proof (state)\nthis:\n  p ?n = real ?n powr (\\<epsilon> - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "let ?ug = edge_space.edge_ugraph"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "define short_count where \"short_count g = card (short_cycles g k)\" for g\n    \\<comment> \\<open>This random variable differs from the one used in the proof of theorem 11.2.2,\n          as we count the number of paths describing a circle, not the circles themselves\\<close>"], ["proof (state)\nthis:\n  short_count ?g = card (short_cycles ?g k)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "from k_def"], ["proof (chain)\npicking this:\n  k = max 3 l", "have \"3 \\<le> k\" \"l \\<le> k\""], ["proof (prove)\nusing this:\n  k = max 3 l\n\ngoal (1 subgoal):\n 1. 3 \\<le> k &&& l \\<le> k", "by auto"], ["proof (state)\nthis:\n  3 \\<le> k\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "from \\<open>3 \\<le> k\\<close>"], ["proof (chain)\npicking this:\n  3 \\<le> k", "have \\<epsilon>_props: \"0 < \\<epsilon>\" \"\\<epsilon> < 1 / k\" \"\\<epsilon> < 1\""], ["proof (prove)\nusing this:\n  3 \\<le> k\n\ngoal (1 subgoal):\n 1. 0 < \\<epsilon> &&& \\<epsilon> < 1 / real k &&& \\<epsilon> < 1", "by (auto simp: \\<epsilon>_def field_simps)"], ["proof (state)\nthis:\n  0 < \\<epsilon>\n  \\<epsilon> < 1 / real k\n  \\<epsilon> < 1\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have ev_p: \"\\<forall>\\<^sup>\\<infinity> n. 0 < p n \\<and> p n < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1", "proof (rule eventually_sequentiallyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ?c \\<le> x \\<Longrightarrow> 0 < p x \\<and> p x < 1", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ?c \\<le> x \\<Longrightarrow> 0 < p x \\<and> p x < 1", "assume \"2 \\<le> n\""], ["proof (state)\nthis:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x. ?c \\<le> x \\<Longrightarrow> 0 < p x \\<and> p x < 1", "with \\<open>\\<epsilon> < 1\\<close>"], ["proof (chain)\npicking this:\n  \\<epsilon> < 1\n  2 \\<le> n", "have \"n powr (\\<epsilon> - 1) < 1\""], ["proof (prove)\nusing this:\n  \\<epsilon> < 1\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. real n powr (\\<epsilon> - 1) < 1", "by (auto intro!: powr_less_one)"], ["proof (state)\nthis:\n  real n powr (\\<epsilon> - 1) < 1\n\ngoal (1 subgoal):\n 1. \\<And>x. ?c \\<le> x \\<Longrightarrow> 0 < p x \\<and> p x < 1", "then"], ["proof (chain)\npicking this:\n  real n powr (\\<epsilon> - 1) < 1", "show \"0 < p n \\<and> p n < 1\""], ["proof (prove)\nusing this:\n  real n powr (\\<epsilon> - 1) < 1\n\ngoal (1 subgoal):\n 1. 0 < p n \\<and> p n < 1", "using \\<open>2 \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  real n powr (\\<epsilon> - 1) < 1\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 < p n \\<and> p n < 1", "by (auto simp: p_def)"], ["proof (state)\nthis:\n  0 < p n \\<and> p n < 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1", "have prob_short_count_le: \"\\<forall>\\<^sup>\\<infinity> n. probGn p n (\\<lambda>es. (real n/2) \\<le> short_count (?ug n es))\n      \\<le> 2 * (k - 2) * n powr (\\<epsilon> * k - 1)\"  (is \"\\<forall>\\<^sup>\\<infinity> n. ?P n\")"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       probGn p n\n        (\\<lambda>es.\n            real n / 2\n            \\<le> real (short_count (edge_space.edge_ugraph n es)))\n       \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)", "proof (elim eventually_rev_mp, intro eventually_sequentiallyI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "assume A: \"Suc k \\<le> n\" \"0 < p n \\<and> p n < 1\""], ["proof (state)\nthis:\n  Suc k \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "then"], ["proof (chain)\npicking this:\n  Suc k \\<le> n\n  0 < p n \\<and> p n < 1", "interpret pG: edge_space n \"p n\""], ["proof (prove)\nusing this:\n  Suc k \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. edge_space (p n)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "have \"1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> n", "using A"], ["proof (prove)\nusing this:\n  Suc k \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> n", "by auto"], ["proof (state)\nthis:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "define mean_short_count where \"mean_short_count = (\\<integral>es. short_count (?ug n es) \\<partial> pG.P)\""], ["proof (state)\nthis:\n  mean_short_count =\n  pG.expectation (\\<lambda>x. real (short_count (pG.edge_ugraph x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "have mean_short_count_le: \"mean_short_count \\<le> (k - 2) * n powr (\\<epsilon> * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "have small_empty: \"\\<And>es k. k \\<le> 2 \\<Longrightarrow> short_cycles (edge_space.edge_ugraph n es) k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>es k.\n       k \\<le> 2 \\<Longrightarrow> short_cycles (pG.edge_ugraph es) k = {}", "by (auto simp add: short_cycles_def ucycles_def)"], ["proof (state)\nthis:\n  ?k1 \\<le> 2 \\<Longrightarrow> short_cycles (pG.edge_ugraph ?es1) ?k1 = {}\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "have short_count_conv: \"\\<And>es. short_count (?ug n es) = (\\<Sum>i=3..k. real (card {c \\<in> ucycles (?ug n es). uwalk_length c = i}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>es.\n       real (short_count (pG.edge_ugraph es)) =\n       (\\<Sum>i = 3..k.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "proof (unfold short_count_def, induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>es.\n       real (card (short_cycles (pG.edge_ugraph es) 0)) =\n       (\\<Sum>i = 3..0.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))\n 2. \\<And>k es.\n       (\\<And>es.\n           real (card (short_cycles (pG.edge_ugraph es) k)) =\n           (\\<Sum>i = 3..k.\n               real\n                (card\n                  {c \\<in> ucycles (pG.edge_ugraph es).\n                   uwalk_length c = i}))) \\<Longrightarrow>\n       real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n       (\\<Sum>i = 3..Suc k.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>es.\n       real (card (short_cycles (pG.edge_ugraph es) 0)) =\n       (\\<Sum>i = 3..0.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))\n 2. \\<And>k es.\n       (\\<And>es.\n           real (card (short_cycles (pG.edge_ugraph es) k)) =\n           (\\<Sum>i = 3..k.\n               real\n                (card\n                  {c \\<in> ucycles (pG.edge_ugraph es).\n                   uwalk_length c = i}))) \\<Longrightarrow>\n       real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n       (\\<Sum>i = 3..Suc k.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "with small_empty"], ["proof (chain)\npicking this:\n  ?k1 \\<le> 2 \\<Longrightarrow> short_cycles (pG.edge_ugraph ?es1) ?k1 = {}", "show ?case"], ["proof (prove)\nusing this:\n  ?k1 \\<le> 2 \\<Longrightarrow> short_cycles (pG.edge_ugraph ?es1) ?k1 = {}\n\ngoal (1 subgoal):\n 1. real (card (short_cycles (pG.edge_ugraph es) 0)) =\n    (\\<Sum>i = 3..0.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "by auto"], ["proof (state)\nthis:\n  real (card (short_cycles (pG.edge_ugraph es) 0)) =\n  (\\<Sum>i = 3..0.\n      real (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))\n\ngoal (1 subgoal):\n 1. \\<And>k es.\n       (\\<And>es.\n           real (card (short_cycles (pG.edge_ugraph es) k)) =\n           (\\<Sum>i = 3..k.\n               real\n                (card\n                  {c \\<in> ucycles (pG.edge_ugraph es).\n                   uwalk_length c = i}))) \\<Longrightarrow>\n       real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n       (\\<Sum>i = 3..Suc k.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k es.\n       (\\<And>es.\n           real (card (short_cycles (pG.edge_ugraph es) k)) =\n           (\\<Sum>i = 3..k.\n               real\n                (card\n                  {c \\<in> ucycles (pG.edge_ugraph es).\n                   uwalk_length c = i}))) \\<Longrightarrow>\n       real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n       (\\<Sum>i = 3..Suc k.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "case (Suc k)"], ["proof (state)\nthis:\n  real (card (short_cycles (pG.edge_ugraph ?es1) k)) =\n  (\\<Sum>i = 3..k.\n      real\n       (card {c \\<in> ucycles (pG.edge_ugraph ?es1). uwalk_length c = i}))\n\ngoal (1 subgoal):\n 1. \\<And>k es.\n       (\\<And>es.\n           real (card (short_cycles (pG.edge_ugraph es) k)) =\n           (\\<Sum>i = 3..k.\n               real\n                (card\n                  {c \\<in> ucycles (pG.edge_ugraph es).\n                   uwalk_length c = i}))) \\<Longrightarrow>\n       real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n       (\\<Sum>i = 3..Suc k.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "proof (cases \"Suc k \\<le> 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))\n 2. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "case True"], ["proof (state)\nthis:\n  Suc k \\<le> 2\n\ngoal (2 subgoals):\n 1. Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))\n 2. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "with small_empty"], ["proof (chain)\npicking this:\n  ?k1 \\<le> 2 \\<Longrightarrow> short_cycles (pG.edge_ugraph ?es1) ?k1 = {}\n  Suc k \\<le> 2", "show ?thesis"], ["proof (prove)\nusing this:\n  ?k1 \\<le> 2 \\<Longrightarrow> short_cycles (pG.edge_ugraph ?es1) ?k1 = {}\n  Suc k \\<le> 2\n\ngoal (1 subgoal):\n 1. real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "by auto"], ["proof (state)\nthis:\n  real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n  (\\<Sum>i = 3..Suc k.\n      real (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))\n\ngoal (1 subgoal):\n 1. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "case False"], ["proof (state)\nthis:\n  \\<not> Suc k \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "have \"{c \\<in> ucycles (?ug n es). uwalk_length c \\<le> Suc k}\n              = {c \\<in> ucycles (?ug n es). uwalk_length c \\<le> k} \\<union> {c \\<in> ucycles (?ug n es). uwalk_length c = Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n    {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} \\<union>\n    {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}", "by auto"], ["proof (state)\nthis:\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} \\<union>\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n\ngoal (1 subgoal):\n 1. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "moreover"], ["proof (state)\nthis:\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} \\<union>\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n\ngoal (1 subgoal):\n 1. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "have \"finite (uverts (edge_space.edge_ugraph n es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (uverts (pG.edge_ugraph es))", "by auto"], ["proof (state)\nthis:\n  finite (uverts (pG.edge_ugraph es))\n\ngoal (1 subgoal):\n 1. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "ultimately"], ["proof (chain)\npicking this:\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} \\<union>\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n  finite (uverts (pG.edge_ugraph es))", "have \"card {c \\<in> ucycles (?ug n es). uwalk_length c \\<le> Suc k}\n            = card {c \\<in> ucycles (?ug n es). uwalk_length c \\<le> k} + card {c \\<in> ucycles (?ug n es). uwalk_length c = Suc k}\""], ["proof (prove)\nusing this:\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} \\<union>\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n  finite (uverts (pG.edge_ugraph es))\n\ngoal (1 subgoal):\n 1. card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n    card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} +\n    card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}", "using finite_ucycles"], ["proof (prove)\nusing this:\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} \\<union>\n  {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n  finite (uverts (pG.edge_ugraph es))\n  finite (uverts ?G) \\<Longrightarrow> finite (ucycles ?G)\n\ngoal (1 subgoal):\n 1. card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n    card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} +\n    card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}", "by (subst card_Un_disjoint[symmetric]) auto"], ["proof (state)\nthis:\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} +\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n\ngoal (1 subgoal):\n 1. \\<not> Suc k \\<le> 2 \\<Longrightarrow>\n    real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "then"], ["proof (chain)\npicking this:\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} +\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}", "show ?thesis"], ["proof (prove)\nusing this:\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} +\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n\ngoal (1 subgoal):\n 1. real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "using Suc False"], ["proof (prove)\nusing this:\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} +\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n  real (card (short_cycles (pG.edge_ugraph ?es1) k)) =\n  (\\<Sum>i = 3..k.\n      real\n       (card {c \\<in> ucycles (pG.edge_ugraph ?es1). uwalk_length c = i}))\n  \\<not> Suc k \\<le> 2\n\ngoal (1 subgoal):\n 1. real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "unfolding short_cycles_def"], ["proof (prove)\nusing this:\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> Suc k} =\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c \\<le> k} +\n  card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = Suc k}\n  real\n   (card {p \\<in> ucycles (pG.edge_ugraph ?es1). uwalk_length p \\<le> k}) =\n  (\\<Sum>i = 3..k.\n      real\n       (card {c \\<in> ucycles (pG.edge_ugraph ?es1). uwalk_length c = i}))\n  \\<not> Suc k \\<le> 2\n\ngoal (1 subgoal):\n 1. real\n     (card\n       {p \\<in> ucycles (pG.edge_ugraph es). uwalk_length p \\<le> Suc k}) =\n    (\\<Sum>i = 3..Suc k.\n        real\n         (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))", "by (auto simp: not_le)"], ["proof (state)\nthis:\n  real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n  (\\<Sum>i = 3..Suc k.\n      real (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (card (short_cycles (pG.edge_ugraph es) (Suc k))) =\n  (\\<Sum>i = 3..Suc k.\n      real (card {c \\<in> ucycles (pG.edge_ugraph es). uwalk_length c = i}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (short_count (pG.edge_ugraph ?es1)) =\n  (\\<Sum>i = 3..k.\n      real\n       (card {c \\<in> ucycles (pG.edge_ugraph ?es1). uwalk_length c = i}))\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "have \"mean_short_count = (\\<Sum>i=3..k. \\<integral>es. card {c \\<in> ucycles (?ug n es). uwalk_length c = i} \\<partial> pG.P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mean_short_count =\n    (\\<Sum>i = 3..k.\n        pG.expectation\n         (\\<lambda>x.\n             real\n              (card\n                {c \\<in> ucycles (pG.edge_ugraph x). uwalk_length c = i})))", "unfolding mean_short_count_def short_count_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. pG.expectation\n     (\\<lambda>x.\n         \\<Sum>i = 3..k.\n            real\n             (card\n               {c \\<in> ucycles (pG.edge_ugraph x). uwalk_length c = i})) =\n    (\\<Sum>i = 3..k.\n        pG.expectation\n         (\\<lambda>x.\n             real\n              (card\n                {c \\<in> ucycles (pG.edge_ugraph x). uwalk_length c = i})))", "by (subst Bochner_Integration.integral_sum) (auto intro: pG.integral_finite_singleton)"], ["proof (state)\nthis:\n  mean_short_count =\n  (\\<Sum>i = 3..k.\n      pG.expectation\n       (\\<lambda>x.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph x). uwalk_length c = i})))\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "also"], ["proof (state)\nthis:\n  mean_short_count =\n  (\\<Sum>i = 3..k.\n      pG.expectation\n       (\\<lambda>x.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph x). uwalk_length c = i})))\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "have \"\\<dots> = (\\<Sum>i\\<in>{3..k}. of_nat (fact n div fact (n - i)) * p n ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 3..k.\n        pG.expectation\n         (\\<lambda>x.\n             real\n              (card\n                {c \\<in> ucycles (pG.edge_ugraph x).\n                 uwalk_length c = i}))) =\n    (\\<Sum>i = 3..k. real (fact n div fact (n - i)) * p n ^ i)", "using A"], ["proof (prove)\nusing this:\n  Suc k \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 3..k.\n        pG.expectation\n         (\\<lambda>x.\n             real\n              (card\n                {c \\<in> ucycles (pG.edge_ugraph x).\n                 uwalk_length c = i}))) =\n    (\\<Sum>i = 3..k. real (fact n div fact (n - i)) * p n ^ i)", "by (simp add: pG.mean_k_cycles)"], ["proof (state)\nthis:\n  (\\<Sum>i = 3..k.\n      pG.expectation\n       (\\<lambda>x.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph x). uwalk_length c = i}))) =\n  (\\<Sum>i = 3..k. real (fact n div fact (n - i)) * p n ^ i)\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 3..k.\n      pG.expectation\n       (\\<lambda>x.\n           real\n            (card\n              {c \\<in> ucycles (pG.edge_ugraph x). uwalk_length c = i}))) =\n  (\\<Sum>i = 3..k. real (fact n div fact (n - i)) * p n ^ i)\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "have \"\\<dots> \\<le> (\\<Sum> i\\<in>{3..k}. n ^ i * p n ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 3..k. real (fact n div fact (n - i)) * p n ^ i)\n    \\<le> (\\<Sum>i = 3..k. real (n ^ i) * p n ^ i)", "apply (rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {3..k} \\<Longrightarrow>\n       real (fact n div fact (n - i)) * p n ^ i \\<le> real (n ^ i) * p n ^ i", "by (meson A fact_div_fact_le_pow  Suc_leD atLeastAtMost_iff of_nat_le_iff order_trans mult_le_cancel_iff1 zero_less_power)"], ["proof (state)\nthis:\n  (\\<Sum>i = 3..k. real (fact n div fact (n - i)) * p n ^ i)\n  \\<le> (\\<Sum>i = 3..k. real (n ^ i) * p n ^ i)\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 3..k. real (fact n div fact (n - i)) * p n ^ i)\n  \\<le> (\\<Sum>i = 3..k. real (n ^ i) * p n ^ i)\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "have \"... \\<le> (\\<Sum> i\\<in>{3..k}. n powr (\\<epsilon> * k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 3..k. real (n ^ i) * p n ^ i)\n    \\<le> (\\<Sum>i = 3..k. real n powr (\\<epsilon> * real k))", "using \\<open>1 \\<le> n\\<close> \\<open>0 < \\<epsilon>\\<close> A"], ["proof (prove)\nusing this:\n  1 \\<le> n\n  0 < \\<epsilon>\n  Suc k \\<le> n\n  0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 3..k. real (n ^ i) * p n ^ i)\n    \\<le> (\\<Sum>i = 3..k. real n powr (\\<epsilon> * real k))", "by (intro sum_mono) (auto simp: p_def field_simps powr_mult_base powr_powr\n          powr_realpow[symmetric] powr_mult[symmetric] powr_add[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i = 3..k. real (n ^ i) * p n ^ i)\n  \\<le> (\\<Sum>i = 3..k. real n powr (\\<epsilon> * real k))\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "finally"], ["proof (chain)\npicking this:\n  mean_short_count \\<le> (\\<Sum>i = 3..k. real n powr (\\<epsilon> * real k))", "show ?thesis"], ["proof (prove)\nusing this:\n  mean_short_count \\<le> (\\<Sum>i = 3..k. real n powr (\\<epsilon> * real k))\n\ngoal (1 subgoal):\n 1. mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)", "by simp"], ["proof (state)\nthis:\n  mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "have \"pG.prob {es \\<in> space pG.P. n/2 \\<le> short_count (?ug n es)} \\<le> mean_short_count / (n/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pG.prob\n     {es \\<in> space pG.P.\n      real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n    \\<le> mean_short_count / (real n / 2)", "unfolding mean_short_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pG.prob\n     {es \\<in> space pG.P.\n      real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n    \\<le> pG.expectation\n           (\\<lambda>x. real (short_count (pG.edge_ugraph x))) /\n          (real n / 2)", "using \\<open>1 \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. pG.prob\n     {es \\<in> space pG.P.\n      real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n    \\<le> pG.expectation\n           (\\<lambda>x. real (short_count (pG.edge_ugraph x))) /\n          (real n / 2)", "by (intro pG.Markov_inequality) (auto simp: short_count_def)"], ["proof (state)\nthis:\n  pG.prob\n   {es \\<in> space pG.P.\n    real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n  \\<le> mean_short_count / (real n / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "also"], ["proof (state)\nthis:\n  pG.prob\n   {es \\<in> space pG.P.\n    real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n  \\<le> mean_short_count / (real n / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "have \"\\<dots> \\<le> 2 * (k - 2) * n powr (\\<epsilon> * k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mean_short_count / (real n / 2)\n    \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mean_short_count / (real n / 2)\n    \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)", "have \"mean_short_count / (n / 2) \\<le> 2 * (k - 2) * (1 / n powr 1) * n powr (\\<epsilon> * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mean_short_count / (real n / 2)\n    \\<le> real (2 * (k - 2)) * (1 / real n powr 1) *\n          real n powr (\\<epsilon> * real k)", "using mean_short_count_le \\<open>1 \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  mean_short_count \\<le> real (k - 2) * real n powr (\\<epsilon> * real k)\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. mean_short_count / (real n / 2)\n    \\<le> real (2 * (k - 2)) * (1 / real n powr 1) *\n          real n powr (\\<epsilon> * real k)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  mean_short_count / (real n / 2)\n  \\<le> real (2 * (k - 2)) * (1 / real n powr 1) *\n        real n powr (\\<epsilon> * real k)\n\ngoal (1 subgoal):\n 1. mean_short_count / (real n / 2)\n    \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)", "then"], ["proof (chain)\npicking this:\n  mean_short_count / (real n / 2)\n  \\<le> real (2 * (k - 2)) * (1 / real n powr 1) *\n        real n powr (\\<epsilon> * real k)", "show ?thesis"], ["proof (prove)\nusing this:\n  mean_short_count / (real n / 2)\n  \\<le> real (2 * (k - 2)) * (1 / real n powr 1) *\n        real n powr (\\<epsilon> * real k)\n\ngoal (1 subgoal):\n 1. mean_short_count / (real n / 2)\n    \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)", "by (simp add: powr_diff algebra_simps)"], ["proof (state)\nthis:\n  mean_short_count / (real n / 2)\n  \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mean_short_count / (real n / 2)\n  \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1;\n        ?c3 \\<le> x; 0 < p x \\<and> p x < 1\\<rbrakk>\n       \\<Longrightarrow> probGn p x\n                          (\\<lambda>es.\n                              real x / 2\n                              \\<le> real\n                                     (short_count\n (edge_space.edge_ugraph x es)))\n                         \\<le> real (2 * (k - 2)) *\n                               real x powr (\\<epsilon> * real k - 1)", "finally"], ["proof (chain)\npicking this:\n  pG.prob\n   {es \\<in> space pG.P.\n    real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n  \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)", "show \"?P n\""], ["proof (prove)\nusing this:\n  pG.prob\n   {es \\<in> space pG.P.\n    real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n  \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)\n\ngoal (1 subgoal):\n 1. pG.prob\n     {es \\<in> space pG.P.\n      real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n    \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)", "."], ["proof (state)\nthis:\n  pG.prob\n   {es \\<in> space pG.P.\n    real n / 2 \\<le> real (short_count (pG.edge_ugraph es))}\n  \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     probGn p n\n      (\\<lambda>es.\n          real n / 2 \\<le> real (short_count (edge_space.edge_ugraph n es)))\n     \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "define pf_short_count pf_\\<alpha>\n    where \"pf_short_count n = probGn p n (\\<lambda>es. n/2 \\<le> short_count (?ug n es))\"\n      and \"pf_\\<alpha> n = probGn p n (\\<lambda>es. 1/2 * n/k \\<le> \\<alpha> (edge_space.edge_ugraph n es))\"\n    for n"], ["proof (state)\nthis:\n  pf_short_count ?n =\n  probGn p ?n\n   (\\<lambda>es.\n       real ?n / 2 \\<le> real (short_count (edge_space.edge_ugraph ?n es)))\n  pf_\\<alpha> ?n =\n  probGn p ?n\n   (\\<lambda>es.\n       ereal (1 / 2 * real ?n / real k)\n       \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph ?n es)))\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have ev_short_count_le: \"\\<forall>\\<^sup>\\<infinity> n. pf_short_count n < 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2", "have \"\\<epsilon> * k - 1 < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> * real k - 1 < 0", "using \\<epsilon>_props \\<open>3 \\<le> k\\<close>"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n  \\<epsilon> < 1 / real k\n  \\<epsilon> < 1\n  3 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<epsilon> * real k - 1 < 0", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  \\<epsilon> * real k - 1 < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2", "then"], ["proof (chain)\npicking this:\n  \\<epsilon> * real k - 1 < 0", "have \"(\\<lambda>n. 2 * (k - 2) * n powr (\\<epsilon> * k - 1)) \\<longlonglongrightarrow> 0\" (is \"?bound \\<longlonglongrightarrow> 0\")"], ["proof (prove)\nusing this:\n  \\<epsilon> * real k - 1 < 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1))\n    \\<longlonglongrightarrow> 0", "by (intro tendsto_mult_right_zero LIMSEQ_neg_powr)"], ["proof (state)\nthis:\n  (\\<lambda>n. real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1))\n  \\<longlonglongrightarrow> 0", "have \"\\<forall>\\<^sup>\\<infinity> n. dist (?bound n) 0  < 1 / 2\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       dist (real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)) 0\n       < 1 / 2", "by (rule tendstoD) simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     dist (real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)) 0\n     < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2", "with prob_short_count_le"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     probGn p n\n      (\\<lambda>es.\n          real n / 2 \\<le> real (short_count (edge_space.edge_ugraph n es)))\n     \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)\n  \\<forall>\\<^sup>\\<infinity>n.\n     dist (real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)) 0\n     < 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     probGn p n\n      (\\<lambda>es.\n          real n / 2 \\<le> real (short_count (edge_space.edge_ugraph n es)))\n     \\<le> real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)\n  \\<forall>\\<^sup>\\<infinity>n.\n     dist (real (2 * (k - 2)) * real n powr (\\<epsilon> * real k - 1)) 0\n     < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2", "by (rule eventually_elim2) (auto simp: dist_real_def pf_short_count_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have lim_\\<alpha>: \"pf_\\<alpha> \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "have \"0 < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k", "using \\<open>3 \\<le> k\\<close>"], ["proof (prove)\nusing this:\n  3 \\<le> k\n\ngoal (1 subgoal):\n 1. 0 < k", "by simp"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "have \"\\<forall>\\<^sup>\\<infinity> n. (6*k) * ln n / n \\<le> p n \\<longleftrightarrow> (6*k) * ln n * n powr - \\<epsilon> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       (real (6 * k) * ln (real n) / real n \\<le> p n) =\n       (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)", "proof (rule eventually_sequentiallyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ?c \\<le> x \\<Longrightarrow>\n       (real (6 * k) * ln (real x) / real x \\<le> p x) =\n       (real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1)", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ?c \\<le> x \\<Longrightarrow>\n       (real (6 * k) * ln (real x) / real x \\<le> p x) =\n       (real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1)", "assume \"1 \\<le> n\""], ["proof (state)\nthis:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ?c \\<le> x \\<Longrightarrow>\n       (real (6 * k) * ln (real x) / real x \\<le> p x) =\n       (real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1)", "then"], ["proof (chain)\npicking this:\n  1 \\<le> n", "have \"(6 * k) * ln n / n \\<le> p n \\<longleftrightarrow> (6*k) * ln n * (n powr - 1) \\<le> n powr (\\<epsilon> - 1)\""], ["proof (prove)\nusing this:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. (real (6 * k) * ln (real n) / real n \\<le> p n) =\n    (real (6 * k) * ln (real n) * real n powr - 1\n     \\<le> real n powr (\\<epsilon> - 1))", "by  (subst powr_minus) (simp add: divide_inverse p_def)"], ["proof (state)\nthis:\n  (real (6 * k) * ln (real n) / real n \\<le> p n) =\n  (real (6 * k) * ln (real n) * real n powr - 1\n   \\<le> real n powr (\\<epsilon> - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ?c \\<le> x \\<Longrightarrow>\n       (real (6 * k) * ln (real x) / real x \\<le> p x) =\n       (real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1)", "also"], ["proof (state)\nthis:\n  (real (6 * k) * ln (real n) / real n \\<le> p n) =\n  (real (6 * k) * ln (real n) * real n powr - 1\n   \\<le> real n powr (\\<epsilon> - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ?c \\<le> x \\<Longrightarrow>\n       (real (6 * k) * ln (real x) / real x \\<le> p x) =\n       (real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1)", "have \"\\<dots> \\<longleftrightarrow> (6*k) * ln n * ((n powr - 1) / (n powr (\\<epsilon> - 1))) \\<le> n powr (\\<epsilon> - 1) / (n powr (\\<epsilon> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real (6 * k) * ln (real n) * real n powr - 1\n     \\<le> real n powr (\\<epsilon> - 1)) =\n    (real (6 * k) * ln (real n) *\n     (real n powr - 1 / real n powr (\\<epsilon> - 1))\n     \\<le> real n powr (\\<epsilon> - 1) / real n powr (\\<epsilon> - 1))", "using \\<open>1 \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. (real (6 * k) * ln (real n) * real n powr - 1\n     \\<le> real n powr (\\<epsilon> - 1)) =\n    (real (6 * k) * ln (real n) *\n     (real n powr - 1 / real n powr (\\<epsilon> - 1))\n     \\<le> real n powr (\\<epsilon> - 1) / real n powr (\\<epsilon> - 1))", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (real (6 * k) * ln (real n) * real n powr - 1\n   \\<le> real n powr (\\<epsilon> - 1)) =\n  (real (6 * k) * ln (real n) *\n   (real n powr - 1 / real n powr (\\<epsilon> - 1))\n   \\<le> real n powr (\\<epsilon> - 1) / real n powr (\\<epsilon> - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ?c \\<le> x \\<Longrightarrow>\n       (real (6 * k) * ln (real x) / real x \\<le> p x) =\n       (real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1)", "also"], ["proof (state)\nthis:\n  (real (6 * k) * ln (real n) * real n powr - 1\n   \\<le> real n powr (\\<epsilon> - 1)) =\n  (real (6 * k) * ln (real n) *\n   (real n powr - 1 / real n powr (\\<epsilon> - 1))\n   \\<le> real n powr (\\<epsilon> - 1) / real n powr (\\<epsilon> - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ?c \\<le> x \\<Longrightarrow>\n       (real (6 * k) * ln (real x) / real x \\<le> p x) =\n       (real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1)", "have \"\\<dots> \\<longleftrightarrow> (6*k) * ln n * n powr - \\<epsilon> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real (6 * k) * ln (real n) *\n     (real n powr - 1 / real n powr (\\<epsilon> - 1))\n     \\<le> real n powr (\\<epsilon> - 1) / real n powr (\\<epsilon> - 1)) =\n    (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)", "by (simp add: powr_diff [symmetric] )"], ["proof (state)\nthis:\n  (real (6 * k) * ln (real n) *\n   (real n powr - 1 / real n powr (\\<epsilon> - 1))\n   \\<le> real n powr (\\<epsilon> - 1) / real n powr (\\<epsilon> - 1)) =\n  (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ?c \\<le> x \\<Longrightarrow>\n       (real (6 * k) * ln (real x) / real x \\<le> p x) =\n       (real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1)", "finally"], ["proof (chain)\npicking this:\n  (real (6 * k) * ln (real n) / real n \\<le> p n) =\n  (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)", "show \"(6*k) * ln n / n \\<le> p n \\<longleftrightarrow> (6*k) * ln n * n powr - \\<epsilon> \\<le> 1\""], ["proof (prove)\nusing this:\n  (real (6 * k) * ln (real n) / real n \\<le> p n) =\n  (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)\n\ngoal (1 subgoal):\n 1. (real (6 * k) * ln (real n) / real n \\<le> p n) =\n    (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)", "."], ["proof (state)\nthis:\n  (real (6 * k) * ln (real n) / real n \\<le> p n) =\n  (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     (real (6 * k) * ln (real n) / real n \\<le> p n) =\n     (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)\n\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     (real (6 * k) * ln (real n) / real n \\<le> p n) =\n     (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)", "have \"(\\<forall>\\<^sup>\\<infinity> n. (6 * k) * ln n / real n \\<le> p n)\n        \\<longleftrightarrow> (\\<forall>\\<^sup>\\<infinity> n. (6*k) * ln n * n powr - \\<epsilon> \\<le> 1)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     (real (6 * k) * ln (real n) / real n \\<le> p n) =\n     (real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sup>\\<infinity>n.\n        real (6 * k) * ln (real n) / real n \\<le> p n) =\n    (\\<forall>\\<^sup>\\<infinity>n.\n        real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)", "by (rule eventually_subst)"], ["proof (state)\nthis:\n  (\\<forall>\\<^sup>\\<infinity>n.\n      real (6 * k) * ln (real n) / real n \\<le> p n) =\n  (\\<forall>\\<^sup>\\<infinity>n.\n      real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)\n\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  (\\<forall>\\<^sup>\\<infinity>n.\n      real (6 * k) * ln (real n) / real n \\<le> p n) =\n  (\\<forall>\\<^sup>\\<infinity>n.\n      real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1)\n\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "have \"\\<forall>\\<^sup>\\<infinity> n. (6*k) * ln n * n powr - \\<epsilon> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "assume \"0 < n\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "have \"ln (real n) \\<le> n powr (\\<epsilon>/2) / (\\<epsilon>/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (real n) \\<le> real n powr (\\<epsilon> / 2) / (\\<epsilon> / 2)", "using \\<open>0 < n\\<close> \\<open>0 < \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. ln (real n) \\<le> real n powr (\\<epsilon> / 2) / (\\<epsilon> / 2)", "by (intro ln_powr_bound) auto"], ["proof (state)\nthis:\n  ln (real n) \\<le> real n powr (\\<epsilon> / 2) / (\\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "also"], ["proof (state)\nthis:\n  ln (real n) \\<le> real n powr (\\<epsilon> / 2) / (\\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "have \"\\<dots> \\<le> 2/\\<epsilon> * n powr (\\<epsilon>/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n powr (\\<epsilon> / 2) / (\\<epsilon> / 2)\n    \\<le> 2 / \\<epsilon> * real n powr (\\<epsilon> / 2)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  real n powr (\\<epsilon> / 2) / (\\<epsilon> / 2)\n  \\<le> 2 / \\<epsilon> * real n powr (\\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  ln (real n) \\<le> 2 / \\<epsilon> * real n powr (\\<epsilon> / 2)", "have \"(6*k) * ln n * (n powr - \\<epsilon>)  \\<le> (6*k) * (2/\\<epsilon> * n powr (\\<epsilon>/2)) * (n powr - \\<epsilon>)\""], ["proof (prove)\nusing this:\n  ln (real n) \\<le> 2 / \\<epsilon> * real n powr (\\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n    \\<le> real (6 * k) * (2 / \\<epsilon> * real n powr (\\<epsilon> / 2)) *\n          real n powr - \\<epsilon>", "using \\<open>0 < n\\<close> \\<open>0 < k\\<close>"], ["proof (prove)\nusing this:\n  ln (real n) \\<le> 2 / \\<epsilon> * real n powr (\\<epsilon> / 2)\n  0 < n\n  0 < k\n\ngoal (1 subgoal):\n 1. real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n    \\<le> real (6 * k) * (2 / \\<epsilon> * real n powr (\\<epsilon> / 2)) *\n          real n powr - \\<epsilon>", "by (intro mult_right_mono mult_left_mono) auto"], ["proof (state)\nthis:\n  real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n  \\<le> real (6 * k) * (2 / \\<epsilon> * real n powr (\\<epsilon> / 2)) *\n        real n powr - \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "also"], ["proof (state)\nthis:\n  real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n  \\<le> real (6 * k) * (2 / \\<epsilon> * real n powr (\\<epsilon> / 2)) *\n        real n powr - \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "have \"\\<dots> = 12*k/\\<epsilon> * n powr (-\\<epsilon>/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (6 * k) * (2 / \\<epsilon> * real n powr (\\<epsilon> / 2)) *\n    real n powr - \\<epsilon> =\n    real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)", "unfolding divide_inverse"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (6 * k) *\n    (2 * inverse \\<epsilon> * real n powr (\\<epsilon> * inverse 2)) *\n    real n powr - \\<epsilon> =\n    real (12 * k) * inverse \\<epsilon> *\n    real n powr (- \\<epsilon> * inverse 2)", "by (auto simp: field_simps powr_minus[symmetric] powr_add[symmetric])"], ["proof (state)\nthis:\n  real (6 * k) * (2 / \\<epsilon> * real n powr (\\<epsilon> / 2)) *\n  real n powr - \\<epsilon> =\n  real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n  \\<le> real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)", "have \"(6*k) * ln n * (n powr - \\<epsilon>) \\<le> 12*k/\\<epsilon> * n powr (-\\<epsilon>/2)\""], ["proof (prove)\nusing this:\n  real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n  \\<le> real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n    \\<le> real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)", "."], ["proof (state)\nthis:\n  real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n  \\<le> real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "}"], ["proof (state)\nthis:\n  0 < ?n2 \\<Longrightarrow>\n  real (6 * k) * ln (real ?n2) * real ?n2 powr - \\<epsilon>\n  \\<le> real (12 * k) / \\<epsilon> * real ?n2 powr (- \\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "then"], ["proof (chain)\npicking this:\n  0 < ?n2 \\<Longrightarrow>\n  real (6 * k) * ln (real ?n2) * real ?n2 powr - \\<epsilon>\n  \\<le> real (12 * k) / \\<epsilon> * real ?n2 powr (- \\<epsilon> / 2)", "have \"\\<forall>\\<^sup>\\<infinity> n. (6*k) * ln n * (n powr - \\<epsilon>) \\<le> 12*k/\\<epsilon> * n powr (-\\<epsilon>/2)\""], ["proof (prove)\nusing this:\n  0 < ?n2 \\<Longrightarrow>\n  real (6 * k) * ln (real ?n2) * real ?n2 powr - \\<epsilon>\n  \\<le> real (12 * k) / \\<epsilon> * real ?n2 powr (- \\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n       \\<le> real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)", "by (intro eventually_sequentiallyI[of 1]) auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n     \\<le> real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "also"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) * real n powr - \\<epsilon>\n     \\<le> real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "have \"\\<forall>\\<^sup>\\<infinity> n. 12*k/\\<epsilon> * n powr (-\\<epsilon>/2) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2) \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2) \\<le> 1", "have \"(\\<lambda>n. 12*k/\\<epsilon> * n powr (-\\<epsilon>/2)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2))\n    \\<longlonglongrightarrow> 0", "using \\<open>0 < \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2))\n    \\<longlonglongrightarrow> 0", "by (intro tendsto_mult_right_zero LIMSEQ_neg_powr) auto"], ["proof (state)\nthis:\n  (\\<lambda>n. real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2))\n  \\<longlonglongrightarrow> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2) \\<le> 1", "using \\<open>0 < \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2))\n  \\<longlonglongrightarrow> 0\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2) \\<le> 1", "by - (drule tendstoD[where e=1], auto elim: eventually_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (12 * k) / \\<epsilon> * real n powr (- \\<epsilon> / 2) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "finally (eventually_le_le)"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>x.\n     real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>x.\n     real (6 * k) * ln (real x) * real x powr - \\<epsilon> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1", "."], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) * real n powr - \\<epsilon> \\<le> 1\n\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "finally"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) / real n \\<le> p n", "have \"\\<forall>\\<^sup>\\<infinity> n. real (6 * k) * ln (real n) / real n \\<le> p n\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) / real n \\<le> p n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       real (6 * k) * ln (real n) / real n \\<le> p n", "."], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) / real n \\<le> p n\n\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "with ev_p \\<open>0 < k\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n  0 < k\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) / real n \\<le> p n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n  0 < k\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) / real n \\<le> p n\n\ngoal (1 subgoal):\n 1. pf_\\<alpha> \\<longlonglongrightarrow> 0", "unfolding pf_\\<alpha>_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n  0 < k\n  \\<forall>\\<^sup>\\<infinity>n.\n     real (6 * k) * ln (real n) / real n \\<le> p n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        probGn p n\n         (\\<lambda>es.\n             ereal (1 / 2 * real n / real k)\n             \\<le> ereal_of_enat (\\<alpha> (edge_space.edge_ugraph n es))))\n    \\<longlonglongrightarrow> 0", "by (rule almost_never_le_\\<alpha>)"], ["proof (state)\nthis:\n  pf_\\<alpha> \\<longlonglongrightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pf_\\<alpha> \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "from ev_short_count_le lim_\\<alpha>[THEN tendstoD, of \"1/2\"] ev_p"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2\n  0 < 1 / 2 \\<Longrightarrow>\n  \\<forall>\\<^sup>\\<infinity>x. dist (pf_\\<alpha> x) 0 < 1 / 2\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1", "have \"\\<forall>\\<^sup>\\<infinity> n. 0 < p n \\<and> p n < 1 \\<and> pf_short_count n < 1/2 \\<and> pf_\\<alpha> n < 1/2\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n. pf_short_count n < 1 / 2\n  0 < 1 / 2 \\<Longrightarrow>\n  \\<forall>\\<^sup>\\<infinity>x. dist (pf_\\<alpha> x) 0 < 1 / 2\n  \\<forall>\\<^sup>\\<infinity>n. 0 < p n \\<and> p n < 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sup>\\<infinity>n.\n       0 < p n \\<and>\n       p n < 1 \\<and> pf_short_count n < 1 / 2 \\<and> pf_\\<alpha> n < 1 / 2", "by simp (elim eventually_rev_mp, auto simp: eventually_sequentially dist_real_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sup>\\<infinity>n.\n     0 < p n \\<and>\n     p n < 1 \\<and> pf_short_count n < 1 / 2 \\<and> pf_\\<alpha> n < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     0 < p n \\<and>\n     p n < 1 \\<and> pf_short_count n < 1 / 2 \\<and> pf_\\<alpha> n < 1 / 2", "obtain n where \"0 < p n\" \"p n < 1\" and [arith]: \"0 < n\"\n      and probs: \"pf_short_count n < 1/2\" \"pf_\\<alpha> n < 1/2\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sup>\\<infinity>n.\n     0 < p n \\<and>\n     p n < 1 \\<and> pf_short_count n < 1 / 2 \\<and> pf_\\<alpha> n < 1 / 2\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>0 < p n; p n < 1; 0 < n; pf_short_count n < 1 / 2;\n         pf_\\<alpha> n < 1 / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_sequentially)"], ["proof (state)\nthis:\n  0 < p n\n  p n < 1\n  0 < n\n  pf_short_count n < 1 / 2\n  pf_\\<alpha> n < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "then"], ["proof (chain)\npicking this:\n  0 < p n\n  p n < 1\n  0 < n\n  pf_short_count n < 1 / 2\n  pf_\\<alpha> n < 1 / 2", "interpret ES: edge_space n \"(p n)\""], ["proof (prove)\nusing this:\n  0 < p n\n  p n < 1\n  0 < n\n  pf_short_count n < 1 / 2\n  pf_\\<alpha> n < 1 / 2\n\ngoal (1 subgoal):\n 1. edge_space (p n)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have rest_compl: \"\\<And>A P. A - {x\\<in>A. P x} = {x\\<in>A. \\<not>P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A P. A - {x \\<in> A. P x} = {x \\<in> A. \\<not> P x}", "by blast"], ["proof (state)\nthis:\n  ?A1 - {x \\<in> ?A1. ?P1 x} = {x \\<in> ?A1. \\<not> ?P1 x}\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "from probs"], ["proof (chain)\npicking this:\n  pf_short_count n < 1 / 2\n  pf_\\<alpha> n < 1 / 2", "have \"ES.prob ({es \\<in> space ES.P. n/2 \\<le> short_count (?ug n es)}\n      \\<union> {es \\<in> space ES.P. 1/2 * n/k \\<le> \\<alpha> (?ug n es)}) \\<le> pf_short_count n + pf_\\<alpha> n\""], ["proof (prove)\nusing this:\n  pf_short_count n < 1 / 2\n  pf_\\<alpha> n < 1 / 2\n\ngoal (1 subgoal):\n 1. ES.prob\n     ({es \\<in> space ES.P.\n       real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n      {es \\<in> space ES.P.\n       ereal (1 / 2 * real n / real k)\n       \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))})\n    \\<le> pf_short_count n + pf_\\<alpha> n", "unfolding pf_short_count_def pf_\\<alpha>_def"], ["proof (prove)\nusing this:\n  ES.prob\n   {es \\<in> space ES.P.\n    real n / 2 \\<le> real (short_count (ES.edge_ugraph es))}\n  < 1 / 2\n  ES.prob\n   {es \\<in> space ES.P.\n    ereal (1 / 2 * real n / real k)\n    \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))}\n  < 1 / 2\n\ngoal (1 subgoal):\n 1. ES.prob\n     ({es \\<in> space ES.P.\n       real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n      {es \\<in> space ES.P.\n       ereal (1 / 2 * real n / real k)\n       \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))})\n    \\<le> ES.prob\n           {es \\<in> space ES.P.\n            real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} +\n          ES.prob\n           {es \\<in> space ES.P.\n            ereal (1 / 2 * real n / real k)\n            \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))}", "by (subst ES.finite_measure_subadditive) auto"], ["proof (state)\nthis:\n  ES.prob\n   ({es \\<in> space ES.P.\n     real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n    {es \\<in> space ES.P.\n     ereal (1 / 2 * real n / real k)\n     \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))})\n  \\<le> pf_short_count n + pf_\\<alpha> n\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "also"], ["proof (state)\nthis:\n  ES.prob\n   ({es \\<in> space ES.P.\n     real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n    {es \\<in> space ES.P.\n     ereal (1 / 2 * real n / real k)\n     \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))})\n  \\<le> pf_short_count n + pf_\\<alpha> n\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"\\<dots> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pf_short_count n + pf_\\<alpha> n < 1", "using probs"], ["proof (prove)\nusing this:\n  pf_short_count n < 1 / 2\n  pf_\\<alpha> n < 1 / 2\n\ngoal (1 subgoal):\n 1. pf_short_count n + pf_\\<alpha> n < 1", "by auto"], ["proof (state)\nthis:\n  pf_short_count n + pf_\\<alpha> n < 1\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "finally"], ["proof (chain)\npicking this:\n  ES.prob\n   ({es \\<in> space ES.P.\n     real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n    {es \\<in> space ES.P.\n     ereal (1 / 2 * real n / real k)\n     \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))})\n  < 1", "have \"0 < ES.prob (space ES.P - ({es \\<in> space ES.P. n/2 \\<le> short_count (?ug n es)}\n      \\<union> {es \\<in> space ES.P. 1/2 * n/k \\<le> \\<alpha> (?ug n es)}))\" (is \"0 < ES.prob ?S\")"], ["proof (prove)\nusing this:\n  ES.prob\n   ({es \\<in> space ES.P.\n     real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n    {es \\<in> space ES.P.\n     ereal (1 / 2 * real n / real k)\n     \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))})\n  < 1\n\ngoal (1 subgoal):\n 1. 0 < ES.prob\n         (space ES.P -\n          ({es \\<in> space ES.P.\n            real n / 2\n            \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n           {es \\<in> space ES.P.\n            ereal (1 / 2 * real n / real k)\n            \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))}))", "by (subst ES.prob_compl) auto"], ["proof (state)\nthis:\n  0 < ES.prob\n       (space ES.P -\n        ({es \\<in> space ES.P.\n          real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n         {es \\<in> space ES.P.\n          ereal (1 / 2 * real n / real k)\n          \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))}))\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "also"], ["proof (state)\nthis:\n  0 < ES.prob\n       (space ES.P -\n        ({es \\<in> space ES.P.\n          real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n         {es \\<in> space ES.P.\n          ereal (1 / 2 * real n / real k)\n          \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))}))\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"?S = {es \\<in> space ES.P. short_count (?ug n es) < n/2 \\<and> \\<alpha> (?ug n es) < 1/2* n/k}\" (is \"\\<dots> = ?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. space ES.P -\n    ({es \\<in> space ES.P.\n      real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n     {es \\<in> space ES.P.\n      ereal (1 / 2 * real n / real k)\n      \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))}) =\n    {es \\<in> space ES.P.\n     real (short_count (ES.edge_ugraph es)) < real n / 2 \\<and>\n     ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n     < ereal (1 / 2 * real n / real k)}", "by (auto simp: not_less rest_compl)"], ["proof (state)\nthis:\n  space ES.P -\n  ({es \\<in> space ES.P.\n    real n / 2 \\<le> real (short_count (ES.edge_ugraph es))} \\<union>\n   {es \\<in> space ES.P.\n    ereal (1 / 2 * real n / real k)\n    \\<le> ereal_of_enat (\\<alpha> (ES.edge_ugraph es))}) =\n  {es \\<in> space ES.P.\n   real (short_count (ES.edge_ugraph es)) < real n / 2 \\<and>\n   ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n   < ereal (1 / 2 * real n / real k)}\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "finally"], ["proof (chain)\npicking this:\n  0 < ES.prob\n       {es \\<in> space ES.P.\n        real (short_count (ES.edge_ugraph es)) < real n / 2 \\<and>\n        ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n        < ereal (1 / 2 * real n / real k)}", "have \"?C \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < ES.prob\n       {es \\<in> space ES.P.\n        real (short_count (ES.edge_ugraph es)) < real n / 2 \\<and>\n        ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n        < ereal (1 / 2 * real n / real k)}\n\ngoal (1 subgoal):\n 1. {es \\<in> space ES.P.\n     real (short_count (ES.edge_ugraph es)) < real n / 2 \\<and>\n     ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n     < ereal (1 / 2 * real n / real k)} \\<noteq>\n    {}", "by (intro notI) (simp only:, auto)"], ["proof (state)\nthis:\n  {es \\<in> space ES.P.\n   real (short_count (ES.edge_ugraph es)) < real n / 2 \\<and>\n   ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n   < ereal (1 / 2 * real n / real k)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "then"], ["proof (chain)\npicking this:\n  {es \\<in> space ES.P.\n   real (short_count (ES.edge_ugraph es)) < real n / 2 \\<and>\n   ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n   < ereal (1 / 2 * real n / real k)} \\<noteq>\n  {}", "obtain es where es_props: \"es \\<in> space ES.P\"\n      \"short_count (?ug n es) < n/2\" \"\\<alpha> (?ug n es) < 1/2 * n/k\""], ["proof (prove)\nusing this:\n  {es \\<in> space ES.P.\n   real (short_count (ES.edge_ugraph es)) < real n / 2 \\<and>\n   ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n   < ereal (1 / 2 * real n / real k)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        \\<lbrakk>es \\<in> space ES.P;\n         real (short_count (ES.edge_ugraph es)) < real n / 2;\n         ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n         < ereal (1 / 2 * real n / real k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto\n    \\<comment> \\<open>now we obtained a high colored graph (few independent nodes) with almost no short cycles\\<close>"], ["proof (state)\nthis:\n  es \\<in> space ES.P\n  real (short_count (ES.edge_ugraph es)) < real n / 2\n  ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n  < ereal (1 / 2 * real n / real k)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "define G where \"G = ?ug n es\""], ["proof (state)\nthis:\n  G = ES.edge_ugraph es\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "define H where \"H = kill_short G k\""], ["proof (state)\nthis:\n  H = kill_short G k\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have G_props: \"uverts G = {1..n}\" \"finite (uverts G)\" \"short_count G < n/2\" \"\\<alpha> G < 1/2 * n/k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uverts G = {1..n} &&& finite (uverts G)) &&&\n    real (short_count G) < real n / 2 &&&\n    ereal_of_enat (\\<alpha> G) < ereal (1 / 2 * real n / real k)", "unfolding G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uverts (ES.edge_ugraph es) = {1..n} &&&\n     finite (uverts (ES.edge_ugraph es))) &&&\n    real (short_count (ES.edge_ugraph es)) < real n / 2 &&&\n    ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n    < ereal (1 / 2 * real n / real k)", "using es_props"], ["proof (prove)\nusing this:\n  es \\<in> space ES.P\n  real (short_count (ES.edge_ugraph es)) < real n / 2\n  ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n  < ereal (1 / 2 * real n / real k)\n\ngoal (1 subgoal):\n 1. (uverts (ES.edge_ugraph es) = {1..n} &&&\n     finite (uverts (ES.edge_ugraph es))) &&&\n    real (short_count (ES.edge_ugraph es)) < real n / 2 &&&\n    ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n    < ereal (1 / 2 * real n / real k)", "by (auto simp: ES.S_verts_def)"], ["proof (state)\nthis:\n  uverts G = {1..n}\n  finite (uverts G)\n  real (short_count G) < real n / 2\n  ereal_of_enat (\\<alpha> G) < ereal (1 / 2 * real n / real k)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"uwellformed G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uwellformed G", "by (auto simp: G_def uwellformed_def all_edges_def ES.S_edges_def)"], ["proof (state)\nthis:\n  uwellformed G\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "with G_props"], ["proof (chain)\npicking this:\n  uverts G = {1..n}\n  finite (uverts G)\n  real (short_count G) < real n / 2\n  ereal_of_enat (\\<alpha> G) < ereal (1 / 2 * real n / real k)\n  uwellformed G", "have T1: \"uwellformed H\""], ["proof (prove)\nusing this:\n  uverts G = {1..n}\n  finite (uverts G)\n  real (short_count G) < real n / 2\n  ereal_of_enat (\\<alpha> G) < ereal (1 / 2 * real n / real k)\n  uwellformed G\n\ngoal (1 subgoal):\n 1. uwellformed H", "unfolding H_def"], ["proof (prove)\nusing this:\n  uverts G = {1..n}\n  finite (uverts G)\n  real (short_count G) < real n / 2\n  ereal_of_enat (\\<alpha> G) < ereal (1 / 2 * real n / real k)\n  uwellformed G\n\ngoal (1 subgoal):\n 1. uwellformed (kill_short G k)", "by (intro kill_short_uwellformed)"], ["proof (state)\nthis:\n  uwellformed H\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"enat l \\<le> enat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat l \\<le> enat k", "using \\<open>l \\<le> k\\<close>"], ["proof (prove)\nusing this:\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. enat l \\<le> enat k", "by simp"], ["proof (state)\nthis:\n  enat l \\<le> enat k\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "also"], ["proof (state)\nthis:\n  enat l \\<le> enat k\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"\\<dots> < girth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat k < girth H", "using G_props"], ["proof (prove)\nusing this:\n  uverts G = {1..n}\n  finite (uverts G)\n  real (short_count G) < real n / 2\n  ereal_of_enat (\\<alpha> G) < ereal (1 / 2 * real n / real k)\n\ngoal (1 subgoal):\n 1. enat k < girth H", "by (auto simp: kill_short_large_girth H_def)"], ["proof (state)\nthis:\n  enat k < girth H\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "finally"], ["proof (chain)\npicking this:\n  enat l < girth H", "have T2: \"l < girth H\""], ["proof (prove)\nusing this:\n  enat l < girth H\n\ngoal (1 subgoal):\n 1. enat l < girth H", "."], ["proof (state)\nthis:\n  enat l < girth H\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have card_H: \"n/2 \\<le> card (uverts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n / 2 \\<le> real (card (uverts H))", "using G_props es_props kill_short_order_of_graph[of G k]"], ["proof (prove)\nusing this:\n  uverts G = {1..n}\n  finite (uverts G)\n  real (short_count G) < real n / 2\n  ereal_of_enat (\\<alpha> G) < ereal (1 / 2 * real n / real k)\n  es \\<in> space ES.P\n  real (short_count (ES.edge_ugraph es)) < real n / 2\n  ereal_of_enat (\\<alpha> (ES.edge_ugraph es))\n  < ereal (1 / 2 * real n / real k)\n  finite (uverts G) \\<Longrightarrow>\n  card (uverts G) - card (short_cycles G k)\n  \\<le> card (uverts (kill_short G k))\n\ngoal (1 subgoal):\n 1. real n / 2 \\<le> real (card (uverts H))", "by (simp add: short_count_def H_def)"], ["proof (state)\nthis:\n  real n / 2 \\<le> real (card (uverts H))\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "then"], ["proof (chain)\npicking this:\n  real n / 2 \\<le> real (card (uverts H))", "have uverts_H: \"uverts H \\<noteq> {}\" \"0 < card (uverts H)\""], ["proof (prove)\nusing this:\n  real n / 2 \\<le> real (card (uverts H))\n\ngoal (1 subgoal):\n 1. uverts H \\<noteq> {} &&& 0 < card (uverts H)", "by auto"], ["proof (state)\nthis:\n  uverts H \\<noteq> {}\n  0 < card (uverts H)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "then"], ["proof (chain)\npicking this:\n  uverts H \\<noteq> {}\n  0 < card (uverts H)", "have \"0 < \\<alpha> H\""], ["proof (prove)\nusing this:\n  uverts H \\<noteq> {}\n  0 < card (uverts H)\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha> H", "using zero_less_\\<alpha> uverts_H"], ["proof (prove)\nusing this:\n  uverts H \\<noteq> {}\n  0 < card (uverts H)\n  uverts ?G \\<noteq> {} \\<Longrightarrow> 0 < \\<alpha> ?G\n  uverts H \\<noteq> {}\n  0 < card (uverts H)\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha> H", "by auto"], ["proof (state)\nthis:\n  0 < \\<alpha> H\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \\<alpha>_HG: \"\\<alpha> H \\<le> \\<alpha> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> H \\<le> \\<alpha> G", "unfolding H_def G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (kill_short (ES.edge_ugraph es) k)\n    \\<le> \\<alpha> (ES.edge_ugraph es)", "by (auto intro: kill_short_\\<alpha>)"], ["proof (state)\nthis:\n  \\<alpha> H \\<le> \\<alpha> G\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"enat l \\<le> ereal k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal_of_enat (enat l) \\<le> ereal (real k)", "using \\<open>l \\<le> k\\<close>"], ["proof (prove)\nusing this:\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. ereal_of_enat (enat l) \\<le> ereal (real k)", "by auto"], ["proof (state)\nthis:\n  ereal_of_enat (enat l) \\<le> ereal (real k)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "also"], ["proof (state)\nthis:\n  ereal_of_enat (enat l) \\<le> ereal (real k)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"\\<dots> < (n/2) / \\<alpha> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (real k) < ereal (real n / 2) / ereal_of_enat (\\<alpha> G)", "using G_props \\<open>3 \\<le> k\\<close>"], ["proof (prove)\nusing this:\n  uverts G = {1..n}\n  finite (uverts G)\n  real (short_count G) < real n / 2\n  ereal_of_enat (\\<alpha> G) < ereal (1 / 2 * real n / real k)\n  3 \\<le> k\n\ngoal (1 subgoal):\n 1. ereal (real k) < ereal (real n / 2) / ereal_of_enat (\\<alpha> G)", "by (cases \"\\<alpha> G\") (auto simp: field_simps)"], ["proof (state)\nthis:\n  ereal (real k) < ereal (real n / 2) / ereal_of_enat (\\<alpha> G)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "also"], ["proof (state)\nthis:\n  ereal (real k) < ereal (real n / 2) / ereal_of_enat (\\<alpha> G)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"\\<dots> \\<le> (n/2) / \\<alpha> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (real n / 2) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal (real n / 2) / ereal_of_enat (\\<alpha> H)", "using \\<alpha>_HG \\<open>0 < \\<alpha> H\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha> H \\<le> \\<alpha> G\n  0 < \\<alpha> H\n\ngoal (1 subgoal):\n 1. ereal (real n / 2) / ereal_of_enat (\\<alpha> G)\n    \\<le> ereal (real n / 2) / ereal_of_enat (\\<alpha> H)", "by (auto simp: ereal_of_enat_pushout intro!: ereal_divide_left_mono)"], ["proof (state)\nthis:\n  ereal (real n / 2) / ereal_of_enat (\\<alpha> G)\n  \\<le> ereal (real n / 2) / ereal_of_enat (\\<alpha> H)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "also"], ["proof (state)\nthis:\n  ereal (real n / 2) / ereal_of_enat (\\<alpha> G)\n  \\<le> ereal (real n / 2) / ereal_of_enat (\\<alpha> H)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"\\<dots> \\<le> card (uverts H) / \\<alpha> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (real n / 2) / ereal_of_enat (\\<alpha> H)\n    \\<le> ereal (real (card (uverts H))) / ereal_of_enat (\\<alpha> H)", "using card_H \\<open>0 < \\<alpha> H\\<close>"], ["proof (prove)\nusing this:\n  real n / 2 \\<le> real (card (uverts H))\n  0 < \\<alpha> H\n\ngoal (1 subgoal):\n 1. ereal (real n / 2) / ereal_of_enat (\\<alpha> H)\n    \\<le> ereal (real (card (uverts H))) / ereal_of_enat (\\<alpha> H)", "by (auto intro!: ereal_divide_right_mono)"], ["proof (state)\nthis:\n  ereal (real n / 2) / ereal_of_enat (\\<alpha> H)\n  \\<le> ereal (real (card (uverts H))) / ereal_of_enat (\\<alpha> H)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "also"], ["proof (state)\nthis:\n  ereal (real n / 2) / ereal_of_enat (\\<alpha> H)\n  \\<le> ereal (real (card (uverts H))) / ereal_of_enat (\\<alpha> H)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "have \"\\<dots> \\<le> chromatic_number H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (real (card (uverts H))) / ereal_of_enat (\\<alpha> H)\n    \\<le> ereal_of_enat (chromatic_number H)", "using uverts_H T1"], ["proof (prove)\nusing this:\n  uverts H \\<noteq> {}\n  0 < card (uverts H)\n  uwellformed H\n\ngoal (1 subgoal):\n 1. ereal (real (card (uverts H))) / ereal_of_enat (\\<alpha> H)\n    \\<le> ereal_of_enat (chromatic_number H)", "by (intro chromatic_lb) auto"], ["proof (state)\nthis:\n  ereal (real (card (uverts H))) / ereal_of_enat (\\<alpha> H)\n  \\<le> ereal_of_enat (chromatic_number H)\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "finally"], ["proof (chain)\npicking this:\n  ereal_of_enat (enat l) < ereal_of_enat (chromatic_number H)", "have T3: \"l < chromatic_number H\""], ["proof (prove)\nusing this:\n  ereal_of_enat (enat l) < ereal_of_enat (chromatic_number H)\n\ngoal (1 subgoal):\n 1. enat l < chromatic_number H", "by (simp del: ereal_of_enat_simps)"], ["proof (state)\nthis:\n  enat l < chromatic_number H\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "from T1 T2 T3"], ["proof (chain)\npicking this:\n  uwellformed H\n  enat l < girth H\n  enat l < chromatic_number H", "show ?thesis"], ["proof (prove)\nusing this:\n  uwellformed H\n  enat l < girth H\n  enat l < chromatic_number H\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       uwellformed G \\<and>\n       enat l < girth G \\<and> enat l < chromatic_number G", "by fast"], ["proof (state)\nthis:\n  \\<exists>G.\n     uwellformed G \\<and>\n     enat l < girth G \\<and> enat l < chromatic_number G\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}