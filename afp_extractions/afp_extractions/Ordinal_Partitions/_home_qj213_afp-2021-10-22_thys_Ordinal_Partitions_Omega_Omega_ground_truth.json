{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordinal_Partitions/Omega_Omega.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordinal_Partitions", "problem_names": ["lemma omega_sum_0_iff [simp]: \"normal ns \\<Longrightarrow> omega_sum ns = 0 \\<longleftrightarrow> ns = []\"", "lemma Ord_omega_sum_aux [simp]: \"Ord (omega_sum_aux k ms)\"", "lemma Ord_omega_sum: \"Ord (omega_sum ms)\"", "lemma omega_sum_less_\\<omega>\\<omega> [intro]: \"omega_sum ms < \\<omega>\\<up>\\<omega>\"", "lemma omega_sum_aux_less: \"omega_sum_aux k ms < \\<omega> \\<up> k\"", "lemma omega_sum_less: \"omega_sum ms < \\<omega> \\<up> (length ms)\"", "lemma omega_sum_ge: \"m \\<noteq> 0 \\<Longrightarrow> \\<omega> \\<up> (length ms) \\<le> omega_sum (m#ms)\"", "lemma omega_sum_length_less:\n  assumes \"length ms < length ns\" \"normal ns\"\n  shows \"omega_sum ms < omega_sum ns\"", "lemma omega_sum_length_leD:\n  assumes \"omega_sum ms \\<le> omega_sum ns\" \"normal ms\"\n  shows \"length ms \\<le> length ns\"", "lemma omega_sum_less_eqlen_iff_cases [simp]:\n  assumes \"length ms = length ns\"\n   shows \"omega_sum (m#ms) < omega_sum (n#ns)\n          \\<longleftrightarrow> m<n \\<or> m=n \\<and> omega_sum ms < omega_sum ns\"\n  (is \"?lhs = ?rhs\")", "lemma omega_sum_lex_less_iff_cases:\n   \"((length ms, omega_sum (m#ms)), (length ns, omega_sum (n#ns))) \\<in> less_than <*lex*> VWF\n   \\<longleftrightarrow> length ms < length ns\n            \\<or> length ms = length ns \\<and> m<n\n            \\<or> m=n \\<and> ((length ms, omega_sum ms), (length ns, omega_sum ns)) \\<in> less_than <*lex*> VWF\"", "lemma omega_sum_less_iff_cases:\n  assumes \"m > 0\" \"n > 0\"\n  shows \"omega_sum (m#ms) < omega_sum (n#ns)\n          \\<longleftrightarrow> length ms < length ns\n            \\<or> length ms = length ns \\<and> m<n\n            \\<or> length ms = length ns \\<and> m=n \\<and> omega_sum ms < omega_sum ns\"\n    (is \"?lhs = ?rhs\")", "lemma omega_sum_less_iff:\n  \"((length ms, omega_sum ms), (length ns, omega_sum ns)) \\<in> less_than <*lex*> VWF\n   \\<longleftrightarrow> (ms,ns) \\<in> lenlex less_than\"", "lemma eq_omega_sum_less_iff:\n  assumes \"length ms = length ns\"\n  shows \"(omega_sum ms, omega_sum ns) \\<in> VWF \\<longleftrightarrow> (ms,ns) \\<in> lenlex less_than\"", "lemma eq_omega_sum_eq_iff:\n  assumes \"length ms = length ns\"\n  shows \"omega_sum ms = omega_sum ns \\<longleftrightarrow> ms=ns\"", "lemma inj_omega_sum: \"inj_on omega_sum {l. length l = n}\"", "lemma Ex_omega_sum: \"\\<gamma> \\<in> elts (\\<omega>\\<up>n) \\<Longrightarrow> \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = n\"", "lemma omega_sum_drop [simp]: \"omega_sum (dropWhile (\\<lambda>n. n=0) ns) = omega_sum ns\"", "lemma normal_drop [simp]: \"normal (dropWhile (\\<lambda>n. n=0) ns)\"", "lemma omega_sum_\\<omega>\\<omega>:\n  assumes \"\\<gamma> \\<in> elts (\\<omega>\\<up>\\<omega>)\"\n  obtains ns where \"\\<gamma> = omega_sum ns\" \"normal ns\"", "lemma\n  assumes \"\\<gamma> \\<in> elts (\\<omega>\\<up>\\<omega>)\"\n  shows Cantor_\\<omega>\\<omega>: \"omega_sum (Cantor_\\<omega>\\<omega> \\<gamma>) = \\<gamma>\"\n    and normal_Cantor_\\<omega>\\<omega>: \"normal (Cantor_\\<omega>\\<omega> \\<gamma>)\"", "lemma from_into_WW [simp]: \"from_WW k (into_WW k ns) = ns\"", "lemma inj_into_WW: \"inj (into_WW k)\"", "lemma into_from_WW_aux:\n  \"\\<lbrakk>strict_sorted ns; \\<forall>n\\<in>list.set ns. k \\<le> n\\<rbrakk> \\<Longrightarrow> into_WW k (from_WW k ns) = ns\"", "lemma into_from_WW [simp]: \"strict_sorted ns \\<Longrightarrow> into_WW 0 (from_WW 0 ns) = ns\"", "lemma into_WW_imp_ge: \"y \\<in> List.set (into_WW x ns) \\<Longrightarrow> x \\<le> y\"", "lemma strict_sorted_into_WW: \"strict_sorted (into_WW x ns)\"", "lemma length_into_WW: \"length (into_WW x ns) = length ns\"", "lemma WW_eq_range_into: \"WW = range (into_WW 0)\"", "lemma into_WW_lenlex_iff: \"(into_WW k ms, into_WW k ns) \\<in> lenlex less_than \\<longleftrightarrow> (ms, ns) \\<in> lenlex less_than\"", "lemma wf_llt [simp]: \"wf (lenlex less_than)\"", "lemma trans_llt [simp]: \"trans (lenlex less_than)\"", "lemma total_llt [simp]: \"total_on A (lenlex less_than)\"", "lemma omega_sum_1_less:\n  assumes \"(ms,ns) \\<in> lenlex less_than\" shows \"omega_sum (1#ms) < omega_sum (1#ns)\"", "lemma ordertype_WW_1: \"ordertype WW (lenlex less_than) \\<le> ordertype UNIV (lenlex less_than)\"", "lemma ordertype_WW_2: \"ordertype UNIV (lenlex less_than) \\<le> \\<omega>\\<up>\\<omega>\"", "lemma ordertype_WW_3: \"\\<omega>\\<up>\\<omega> \\<le> ordertype WW (lenlex less_than)\"", "lemma ordertype_WW: \"ordertype WW (lenlex less_than) = \\<omega>\\<up>\\<omega>\"\n  and ordertype_UNIV_\\<omega>\\<omega>: \"ordertype UNIV (lenlex less_than) = \\<omega>\\<up>\\<omega>\"", "lemma ordertype_\\<omega>\\<omega>:\n  fixes F :: \"nat \\<Rightarrow> nat list set\"\n  assumes \"\\<And>j::nat. ordertype (F j) (lenlex less_than) = \\<omega>\\<up>j\"\n  shows \"ordertype (\\<Union>j. F j) (lenlex less_than) = \\<omega>\\<up>\\<omega>\"", "lemma WW_seg_subset_WW: \"WW_seg n \\<subseteq> WW\"", "lemma WW_eq_UN_WW_seg: \"WW = (\\<Union> n. WW_seg n)\"", "lemma ordertype_list_seg: \"ordertype {l. length l = n} (lenlex less_than) = \\<omega>\\<up>n\"", "lemma ordertype_WW_seg: \"ordertype (WW_seg n) (lenlex less_than) = \\<omega>\\<up>n\"\n  (is \"ordertype ?W ?R = \\<omega>\\<up>n\")", "lemma less_Nil [simp]: \"xs < []\" \"[] < xs\"", "lemma less_sets_imp_list_less:\n  assumes \"list.set xs \\<lless> list.set ys\"\n  shows \"xs < ys\"", "lemma less_sets_imp_sorted_list_of_set:\n  assumes \"A \\<lless> B\" \"finite A\" \"finite B\"\n  shows \"list_of A < list_of B\"", "lemma sorted_list_of_set_imp_less_sets:\n  assumes \"xs < ys\" \"sorted xs\" \"sorted ys\"\n  shows \"list.set xs \\<lless> list.set ys\"", "lemma less_list_iff_less_sets:\n  assumes \"sorted xs\" \"sorted ys\"\n  shows \"xs < ys \\<longleftrightarrow> list.set xs \\<lless> list.set ys\"", "lemma sorted_trans:\n  assumes \"xs < ys\" \"ys < zs\" \"sorted ys\" \"ys \\<noteq> []\" shows \"xs < zs\"", "lemma strict_sorted_imp_append_less:\n  assumes \"strict_sorted (xs @ ys)\"\n  shows \"xs < ys\"", "lemma strict_sorted_append_iff:\n  \"strict_sorted (xs @ ys) \\<longleftrightarrow> xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\" (is \"?lhs = ?rhs\")", "lemma singleton_less_list_iff: \"sorted xs \\<Longrightarrow> [n] < xs \\<longleftrightarrow> {..n} \\<inter> list.set xs = {}\"", "lemma less_last_iff: \"xs@[x] < ys \\<longleftrightarrow> [x] < ys\"", "lemma less_Cons_iff: \"NO_MATCH [] ys \\<Longrightarrow> xs < y#ys \\<longleftrightarrow> xs < [y]\"", "lemma less_hd_imp_less: \"xs < [hd ys] \\<Longrightarrow> xs < ys\"", "lemma last_less_imp_less: \"[last xs] < ys \\<Longrightarrow> xs < ys\"", "lemma strict_sorted_concat_I:\n  assumes\n    \"\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x\"\n    \"\\<And>n. Suc n < length xs \\<Longrightarrow> xs!n < xs!Suc n\"\n  assumes \"xs \\<in> lists (- {[]})\"\n  shows \"strict_sorted (concat xs)\"", "lemma initial_segment_ne:\n  assumes \"initial_segment xs ys\" \"xs \\<noteq> []\"\n  shows \"ys \\<noteq> [] \\<and> hd ys = hd xs\"", "lemma take_initial_segment:\n  assumes \"initial_segment xs ys\" \"k \\<le> length xs\"\n  shows \"take k xs = take k ys\"", "lemma initial_segment_length_eq:\n  assumes \"initial_segment xs ys\" \"length xs = length ys\"\n  shows \"xs = ys\"", "lemma initial_segment_Nil [simp]: \"initial_segment [] ys\"", "lemma initial_segment_Cons [simp]: \"initial_segment (x#xs) (y#ys) \\<longleftrightarrow> x=y \\<and> initial_segment xs ys\"", "lemma init_segment_iff_initial_segment:\n  assumes \"strict_sorted xs\" \"strict_sorted ys\"\n  shows \"init_segment (list.set xs) (list.set ys) \\<longleftrightarrow> initial_segment xs ys\" (is \"?lhs = ?rhs\")", "theorem Nash_Williams_WW:\n  fixes h :: \"nat list \\<Rightarrow> nat\"\n  assumes \"infinite M\" and h: \"h ` {l \\<in> A. List.set l \\<subseteq> M} \\<subseteq> {..<2}\" and \"thin A\" \"A \\<subseteq> WW\"\n  obtains i N where \"i < 2\" \"infinite N\" \"N \\<subseteq> M\" \"h ` {l \\<in> A. List.set l \\<subseteq> N} \\<subseteq> {i}\"", "lemma mem_lists_non_Nil: \"xss \\<in> lists (- {[]}) \\<longleftrightarrow> (\\<forall>x \\<in> list.set xss. x \\<noteq> [])\"", "lemma length_acc_lengths [simp]: \"length (acc_lengths acc ls) = length ls\"", "lemma acc_lengths_eq_Nil_iff [simp]: \"acc_lengths acc ls = [] \\<longleftrightarrow> ls = []\"", "lemma set_acc_lengths:\n  assumes \"ls \\<in> lists (- {[]})\" shows \"list.set (acc_lengths acc ls) \\<subseteq> {acc<..}\"", "lemma hd_acc_lengths [simp]: \"hd (acc_lengths acc (l#ls)) = acc + length l\"", "lemma last_acc_lengths [simp]:\n  \"ls \\<noteq> [] \\<Longrightarrow> last (acc_lengths acc ls) = acc + sum_list (map length ls)\"", "lemma nth_acc_lengths [simp]:\n  \"\\<lbrakk>ls \\<noteq> []; k < length ls\\<rbrakk> \\<Longrightarrow> acc_lengths acc ls ! k = acc + sum_list (map length (take (Suc k) ls))\"", "lemma acc_lengths_plus: \"acc_lengths (m+n) as = map ((+)m) (acc_lengths n as)\"", "lemma acc_lengths_shift: \"NO_MATCH 0 acc \\<Longrightarrow> acc_lengths acc as = map ((+)acc) (acc_lengths 0 as)\"", "lemma length_concat_acc_lengths:\n  \"ls \\<noteq> [] \\<Longrightarrow> k + length (concat ls) \\<in> list.set (acc_lengths k ls)\"", "lemma strict_sorted_acc_lengths:\n  assumes \"ls \\<in> lists (- {[]})\" shows \"strict_sorted (acc_lengths acc ls)\"", "lemma acc_lengths_append:\n  \"acc_lengths acc (xs @ ys)\n   = acc_lengths acc xs @ acc_lengths (acc + sum_list (map length xs)) ys\"", "lemma length_concat_ge:\n  assumes \"as \\<in> lists (- {[]})\"\n  shows \"length (concat as) \\<ge> length as\"", "lemma (in monoid_add) length_interact:\n  \"length (interact xs ys) = sum_list (map length xs) + sum_list (map length ys)\"", "lemma length_interact_ge:\n  assumes \"xs \\<in> lists (- {[]})\" \"ys \\<in> lists (- {[]})\"\n  shows \"length (interact xs ys) \\<ge> length xs + length ys\"", "lemma set_interact [simp]:\n  shows \"list.set (interact xs ys) = list.set (concat xs) \\<union> list.set (concat ys)\"", "lemma interact_eq_Nil_iff [simp]:\n  assumes \"xs \\<in> lists (- {[]})\" \"ys \\<in> lists (- {[]})\"\n  shows \"interact xs ys = [] \\<longleftrightarrow> xs=[] \\<and> ys=[]\"", "lemma interact_sing [simp]: \"interact [x] ys = x @ concat ys\"", "lemma hd_interact: \"\\<lbrakk>xs \\<noteq> []; hd xs \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd (interact xs ys) = hd (hd xs)\"", "lemma acc_lengths_concat_injective:\n  assumes \"concat as' = concat as\" \"acc_lengths n as' = acc_lengths n as\"\n  shows \"as' = as\"", "lemma acc_lengths_interact_injective:\n  assumes \"interact as' bs' = interact as bs\" \"acc_lengths a as' = acc_lengths a as\" \"acc_lengths b bs' = acc_lengths b bs\"\n  shows \"as' = as \\<and> bs' = bs\"", "lemma strict_sorted_interact_I:\n  assumes \"length ys \\<le> length xs\" \"length xs \\<le> Suc (length ys)\"\n    \"\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x\"\n    \"\\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y\"\n    \"\\<And>n. n < length ys \\<Longrightarrow> xs!n < ys!n\"\n    \"\\<And>n. Suc n < length xs \\<Longrightarrow> ys!n < xs!Suc n\"\n  assumes \"xs \\<in> lists (- {[]})\" \"ys \\<in> lists (- {[]})\"\n  shows \"strict_sorted (interact xs ys)\"", "lemma Form_elim_upair:\n  assumes \"Form l U\"\n  obtains xs ys where \"xs \\<noteq> ys\" \"U = {xs,ys}\" \"length xs \\<le> length ys\"", "lemma Form_Body_WW:\n  assumes \"Form_Body ka kb xs ys zs\"\n  shows \"zs \\<in> WW\"", "lemma Form_Body_nonempty:\n  assumes \"Form_Body ka kb xs ys zs\"\n  shows \"length zs > 0\"", "lemma Form_Body_length:\n  assumes \"Form_Body ka kb xs ys zs\"\n  shows \"length xs < length ys\"", "lemma form_cases:\n  fixes l::nat\n  obtains (zero) \"l = 0\" | (nz) ka kb where \"l = ka+kb - 1\" \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\"", "lemma interact:\n  assumes \"Form l U\" \"l>0\"\n  obtains ka kb xs ys zs where \"l = ka+kb - 1\" \"U = {xs,ys}\" \"Form_Body ka kb xs ys zs\" \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\"", "lemma inter_scheme:\n  assumes \"Form l U\" \"l>0\"\n  obtains ka kb xs ys where \"l = ka+kb - 1\" \"U = {xs,ys}\" \"Form_Body ka kb xs ys (inter_scheme l U)\" \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\"", "lemma inter_scheme_simple:\n  assumes \"Form l U\" \"l>0\"\n  shows \"inter_scheme l U \\<in> WW \\<and> length (inter_scheme l U) > 0\"", "lemma inter_scheme_strict_sorted:\n  assumes \"Form l U\" \"l>0\"\n  shows \"strict_sorted (inter_scheme l U)\"", "lemma strict_sorted_interact_imp_concat:\n    \"strict_sorted (interact as bs) \\<Longrightarrow> strict_sorted (concat as) \\<and> strict_sorted (concat bs)\"", "lemma strict_sorted_interact_hd:\n  \"\\<lbrakk>strict_sorted (interact cs ds); cs \\<noteq> []; ds \\<noteq> []; hd cs \\<noteq> []; hd ds \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (hd cs) < hd (hd ds)\"", "lemma Form_Body_imp_inter_scheme:\n  assumes \"Form_Body ka kb xs ys zs\" and \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\"\n  shows \"zs = inter_scheme ((ka+kb) - Suc 0) {xs,ys}\"", "lemma grab_0 [simp]: \"grab N 0 = ({}, N)\"", "lemma less_sets_grab:\n  \"infinite N \\<Longrightarrow> fst (grab N n) \\<lless> snd (grab N n)\"", "lemma finite_grab [iff]: \"finite (fst (grab N n))\"", "lemma card_grab [simp]:\n  assumes \"infinite N\" shows \"card (fst (grab N n)) = n\"", "lemma fst_grab_subset: \"fst (grab N n) \\<subseteq> N\"", "lemma snd_grab_subset: \"snd (grab N n) \\<subseteq> N\"", "lemma grab_Un_eq:\n  assumes \"infinite N\" shows \"fst (grab N n) \\<union> snd (grab N n) = N\"", "lemma finite_grab_iff [simp]: \"finite (snd (grab N n)) \\<longleftrightarrow> finite N\"", "lemma grab_eqD:\n    \"\\<lbrakk>grab N n = (A,M); infinite N\\<rbrakk>\n    \\<Longrightarrow> A \\<lless> M \\<and> finite A \\<and> card A = n \\<and> infinite M \\<and> A \\<subseteq> N \\<and> M \\<subseteq> N\"", "lemma less_sets_fst_grab: \"A \\<lless> N \\<Longrightarrow> A \\<lless> fst (grab N n)\"", "lemma infinite_nxtN: \"infinite N \\<Longrightarrow> infinite (nxt N n)\"", "lemma nxt_subset: \"nxt N n \\<subseteq> N\"", "lemma nxt_subset_greaterThan: \"m \\<le> n \\<Longrightarrow> nxt N n \\<subseteq> {m<..}\"", "lemma nxt_subset_atLeast: \"m \\<le> n \\<Longrightarrow> nxt N n \\<subseteq> {m..}\"", "lemma enum_nxt_ge: \"infinite N \\<Longrightarrow> a \\<le> enum (nxt N a) n\"", "lemma inj_enum_nxt: \"infinite N \\<Longrightarrow> inj_on (enum (nxt N a)) A\"", "lemma lemma_3_11:\n  assumes \"l > 0\"\n  shows \"thin (inter_scheme l ` {U. Form l U})\"", "lemma total_order_nsets_2_eq:\n  assumes tot: \"total_on A r\" and irr: \"irrefl r\"\n  shows \"nsets A 2 = {{x,y} | x y. x \\<in> A \\<and> y \\<in> A \\<and> (x,y) \\<in> r}\"\n     (is \"_ = ?rhs\")", "lemma lenlex_nsets_2_eq: \"nsets A 2 = {{x,y} | x y. x \\<in> A \\<and> y \\<in> A \\<and> (x,y) \\<in> lenlex less_than}\"", "lemma sum_sorted_list_of_set_map: \"finite I \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I\"", "lemma sorted_list_of_set_UN_eq_concat:\n  assumes I: \"strict_mono_sets I f\" \"finite I\" and fin: \"\\<And>i. finite (f i)\"\n  shows \"list_of (\\<Union>i \\<in> I. f i) = concat (map (list_of \\<circ> f) (list_of I))\"", "lemma IJ_iff: \"u \\<in> IJ k \\<longleftrightarrow> (\\<exists>j i. u = (j,i) \\<and> i<j \\<and> j\\<le>k)\"", "lemma finite_IJ: \"finite (IJ k)\"", "lemma prev_eq_None_iff: \"prev j i = None \\<longleftrightarrow> j \\<le> Suc 0 \\<and> i = 0\"", "lemma prev_pair_less:\n  \"prev j i = Some ji' \\<Longrightarrow> (ji', (j,i)) \\<in> pair_less\"", "lemma prev_Some_less: \"\\<lbrakk>prev j i = Some (j',i'); i \\<le> j\\<rbrakk> \\<Longrightarrow> i' < j'\"", "lemma prev_maximal:\n  \"\\<lbrakk>prev j i = Some (j',i'); (ji'', (j,i)) \\<in> pair_less; ji'' \\<in> IJ k\\<rbrakk>\n   \\<Longrightarrow> (ji'', (j',i')) \\<in> pair_less \\<or> ji'' = (j',i')\"", "lemma pair_less_prev:\n  assumes \"(u, (j,i)) \\<in> pair_less\" \"u \\<in> IJ k\"\n  shows \"prev j i = Some u \\<or> (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)\"", "lemma USigma_empty [simp]: \"USigma {} B = {}\"", "lemma USigma_iff:\n  assumes \"\\<And>I j. I \\<in> \\<I> \\<Longrightarrow> I \\<lless> J I \\<and> finite I\"\n  shows \"x \\<in> USigma \\<I> J \\<longleftrightarrow> usplit (\\<lambda>I j. I\\<in>\\<I> \\<and> j\\<in>J I \\<and> x = insert j I) x\"", "lemma ordertype_append_image_IJ:\n  assumes lenB [simp]: \"\\<And>i j. i \\<in> \\<I> \\<Longrightarrow> j \\<in> J i \\<Longrightarrow> length (B j) = c\"\n    and AB: \"\\<And>i j. i \\<in> \\<I> \\<Longrightarrow> j \\<in> J i \\<Longrightarrow> A i < B j\"\n    and IJ: \"\\<And>i. i \\<in> \\<I> \\<Longrightarrow> i \\<lless> J i \\<and> finite i\"\n    and \\<beta>: \"\\<And>i. i \\<in> \\<I> \\<Longrightarrow> ordertype (B ` J i) (lenlex less_than) = \\<beta>\"\n    and A: \"inj_on A \\<I>\"\n  shows \"ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J) (lenlex less_than)\n       = \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)\"\n    (is \"ordertype ?AB ?R = _ * ?\\<alpha>\")", "lemma merge_single:\n  \"\\<lbrakk>concat as < concat bs; concat as \\<noteq> []; concat bs \\<noteq> []\\<rbrakk> \\<Longrightarrow> merge as bs [concat as] [concat bs]\"", "lemma merge_length1_nonempty:\n  assumes \"merge as bs us vs\" \"as \\<in> lists (- {[]})\"\n  shows \"us \\<in> lists (- {[]})\"", "lemma merge_length2_nonempty:\n  assumes \"merge as bs us vs\" \"bs \\<in> lists (- {[]})\"\n  shows \"vs \\<in> lists (- {[]})\"", "lemma merge_length1_gt_0:\n  assumes \"merge as bs us vs\" \"as \\<noteq> []\"\n  shows \"length us > 0\"", "lemma merge_length_le:\n  assumes \"merge as bs us vs\"\n  shows \"length vs \\<le> length us\"", "lemma merge_length_le_Suc:\n  assumes \"merge as bs us vs\"\n  shows \"length us \\<le> Suc (length vs)\"", "lemma merge_length_less2:\n  assumes \"merge as bs us vs\"\n  shows \"length vs \\<le> length as\"", "lemma merge_preserves:\n  assumes \"merge as bs us vs\"\n  shows \"concat as = concat us \\<and> concat bs = concat vs\"", "lemma merge_interact:\n  assumes \"merge as bs us vs\" \"strict_sorted (concat as)\" \"strict_sorted (concat bs)\"\n           \"bs \\<in> lists (- {[]})\"\n  shows \"strict_sorted (interact us vs)\"", "lemma acc_lengths_merge1:\n  assumes \"merge as bs us vs\"\n  shows \"list.set (acc_lengths k us) \\<subseteq> list.set (acc_lengths k as)\"", "lemma acc_lengths_merge2:\n  assumes \"merge as bs us vs\"\n  shows \"list.set (acc_lengths k vs) \\<subseteq> list.set (acc_lengths k bs)\"", "lemma length_hd_le_concat:\n  assumes \"as \\<noteq> []\" shows \"length (hd as) \\<le> length (concat as)\"", "lemma length_hd_merge2:\n  assumes \"merge as bs us vs\"\n  shows \"length (hd bs) \\<le> length (hd vs)\"", "lemma merge_less_sets_hd:\n  assumes \"merge as bs us vs\" \"strict_sorted (concat as)\" \"strict_sorted (concat bs)\" \"bs \\<in> lists (- {[]})\"\n  shows \"list.set (hd us) \\<lless> list.set (concat vs)\"", "lemma set_takeWhile:\n  assumes \"strict_sorted (concat as)\" \"as \\<in> lists (- {[]})\"\n  shows \"list.set (takeWhile (\\<lambda>x. x < y) as) = {x \\<in> list.set as. x < y}\"", "theorem partition_\\<omega>\\<omega>_aux:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\"\n  shows \"partn_lst (lenlex less_than) WW [\\<omega>\\<up>\\<omega>,\\<alpha>] 2\" (is \"partn_lst ?R WW [\\<omega>\\<up>\\<omega>,\\<alpha>] 2\")", "theorem partition_\\<omega>\\<omega>: \"\\<alpha> \\<in> elts \\<omega> \\<Longrightarrow> partn_lst_VWF (\\<omega>\\<up>\\<omega>) [\\<omega>\\<up>\\<omega>,\\<alpha>] 2\""], "translations": [["", "lemma omega_sum_0_iff [simp]: \"normal ns \\<Longrightarrow> omega_sum ns = 0 \\<longleftrightarrow> ns = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal ns \\<Longrightarrow> (omega_sum ns = 0) = (ns = [])", "by (induction ns) auto"], ["", "lemma Ord_omega_sum_aux [simp]: \"Ord (omega_sum_aux k ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (omega_sum_aux k ms)", "by (induction rule: omega_sum_aux.induct) auto"], ["", "lemma Ord_omega_sum: \"Ord (omega_sum ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (omega_sum ms)", "by simp"], ["", "lemma omega_sum_less_\\<omega>\\<omega> [intro]: \"omega_sum ms < \\<omega>\\<up>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum ms < \\<omega> \\<up> \\<omega>", "proof (induction ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. omega_sum [] < \\<omega> \\<up> \\<omega>\n 2. \\<And>a ms.\n       omega_sum ms < \\<omega> \\<up> \\<omega> \\<Longrightarrow>\n       omega_sum (a # ms) < \\<omega> \\<up> \\<omega>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. omega_sum [] < \\<omega> \\<up> \\<omega>\n 2. \\<And>a ms.\n       omega_sum ms < \\<omega> \\<up> \\<omega> \\<Longrightarrow>\n       omega_sum (a # ms) < \\<omega> \\<up> \\<omega>", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum [] < \\<omega> \\<up> \\<omega>", "by (auto simp: zero_less_Limit)"], ["proof (state)\nthis:\n  omega_sum [] < \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       omega_sum ms < \\<omega> \\<up> \\<omega> \\<Longrightarrow>\n       omega_sum (a # ms) < \\<omega> \\<up> \\<omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       omega_sum ms < \\<omega> \\<up> \\<omega> \\<Longrightarrow>\n       omega_sum (a # ms) < \\<omega> \\<up> \\<omega>", "case (Cons m ms)"], ["proof (state)\nthis:\n  omega_sum ms < \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       omega_sum ms < \\<omega> \\<up> \\<omega> \\<Longrightarrow>\n       omega_sum (a # ms) < \\<omega> \\<up> \\<omega>", "have \"\\<omega> \\<up> (length ms) * ord_of_nat m \\<in> elts (\\<omega> \\<up> Suc (length ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n    \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc (length ms)))", "using Ord_mem_iff_lt"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n    \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc (length ms)))", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n  \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc (length ms)))\n\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       omega_sum ms < \\<omega> \\<up> \\<omega> \\<Longrightarrow>\n       omega_sum (a # ms) < \\<omega> \\<up> \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n  \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc (length ms)))", "have \"\\<omega>\\<up>(length ms) * ord_of_nat m \\<in> elts (\\<omega>\\<up>\\<omega>)\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n  \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc (length ms)))\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n    \\<in> elts (\\<omega> \\<up> \\<omega>)", "using Ord_ord_of_nat oexp_mono_le omega_nonzero ord_of_nat_le_omega"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n  \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc (length ms)))\n  Ord (ord_of_nat ?k)\n  \\<lbrakk>?\\<gamma> \\<le> ?\\<beta>; ?\\<alpha> \\<noteq> 0; Ord ?\\<alpha>;\n   Ord ?\\<beta>; Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<up> ?\\<gamma> \\<le> ?\\<alpha> \\<up> ?\\<beta>\n  \\<omega> \\<noteq> 0\n  ord_of_nat ?n \\<le> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n    \\<in> elts (\\<omega> \\<up> \\<omega>)", "by blast"], ["proof (state)\nthis:\n  \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n  \\<in> elts (\\<omega> \\<up> \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       omega_sum ms < \\<omega> \\<up> \\<omega> \\<Longrightarrow>\n       omega_sum (a # ms) < \\<omega> \\<up> \\<omega>", "with Cons"], ["proof (chain)\npicking this:\n  omega_sum ms < \\<omega> \\<up> \\<omega>\n  \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n  \\<in> elts (\\<omega> \\<up> \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  omega_sum ms < \\<omega> \\<up> \\<omega>\n  \\<omega> \\<up> ord_of_nat (length ms) * ord_of_nat m\n  \\<in> elts (\\<omega> \\<up> \\<omega>)\n\ngoal (1 subgoal):\n 1. omega_sum (m # ms) < \\<omega> \\<up> \\<omega>", "by (auto simp: mult_succ OrdmemD oexp_less indecomposableD indecomposable_\\<omega>_power)"], ["proof (state)\nthis:\n  omega_sum (m # ms) < \\<omega> \\<up> \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma omega_sum_aux_less: \"omega_sum_aux k ms < \\<omega> \\<up> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum_aux k ms < \\<omega> \\<up> ord_of_nat k", "proof (induction rule: omega_sum_aux.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_. omega_sum_aux 0 uu_ < \\<omega> \\<up> ord_of_nat 0\n 2. \\<And>n. omega_sum_aux (Suc n) [] < \\<omega> \\<up> ord_of_nat (Suc n)\n 3. \\<And>n m ms.\n       omega_sum_aux n ms < \\<omega> \\<up> ord_of_nat n \\<Longrightarrow>\n       omega_sum_aux (Suc n) (m # ms) < \\<omega> \\<up> ord_of_nat (Suc n)", "case (3 n m ms)"], ["proof (state)\nthis:\n  omega_sum_aux n ms < \\<omega> \\<up> ord_of_nat n\n\ngoal (3 subgoals):\n 1. \\<And>uu_. omega_sum_aux 0 uu_ < \\<omega> \\<up> ord_of_nat 0\n 2. \\<And>n. omega_sum_aux (Suc n) [] < \\<omega> \\<up> ord_of_nat (Suc n)\n 3. \\<And>n m ms.\n       omega_sum_aux n ms < \\<omega> \\<up> ord_of_nat n \\<Longrightarrow>\n       omega_sum_aux (Suc n) (m # ms) < \\<omega> \\<up> ord_of_nat (Suc n)", "have \" \\<omega>\\<up>n * ord_of_nat m + \\<omega>\\<up>n < \\<omega>\\<up>n * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ord_of_nat n * ord_of_nat m + \\<omega> \\<up> ord_of_nat n\n    < \\<omega> \\<up> ord_of_nat n * \\<omega>", "by (metis Ord_ord_of_nat \\<omega>_power_succ_gtr mult_succ oexp_succ ord_of_nat.simps(2))"], ["proof (state)\nthis:\n  \\<omega> \\<up> ord_of_nat n * ord_of_nat m + \\<omega> \\<up> ord_of_nat n\n  < \\<omega> \\<up> ord_of_nat n * \\<omega>\n\ngoal (3 subgoals):\n 1. \\<And>uu_. omega_sum_aux 0 uu_ < \\<omega> \\<up> ord_of_nat 0\n 2. \\<And>n. omega_sum_aux (Suc n) [] < \\<omega> \\<up> ord_of_nat (Suc n)\n 3. \\<And>n m ms.\n       omega_sum_aux n ms < \\<omega> \\<up> ord_of_nat n \\<Longrightarrow>\n       omega_sum_aux (Suc n) (m # ms) < \\<omega> \\<up> ord_of_nat (Suc n)", "with 3"], ["proof (chain)\npicking this:\n  omega_sum_aux n ms < \\<omega> \\<up> ord_of_nat n\n  \\<omega> \\<up> ord_of_nat n * ord_of_nat m + \\<omega> \\<up> ord_of_nat n\n  < \\<omega> \\<up> ord_of_nat n * \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  omega_sum_aux n ms < \\<omega> \\<up> ord_of_nat n\n  \\<omega> \\<up> ord_of_nat n * ord_of_nat m + \\<omega> \\<up> ord_of_nat n\n  < \\<omega> \\<up> ord_of_nat n * \\<omega>\n\ngoal (1 subgoal):\n 1. omega_sum_aux (Suc n) (m # ms) < \\<omega> \\<up> ord_of_nat (Suc n)", "using dual_order.strict_trans"], ["proof (prove)\nusing this:\n  omega_sum_aux n ms < \\<omega> \\<up> ord_of_nat n\n  \\<omega> \\<up> ord_of_nat n * ord_of_nat m + \\<omega> \\<up> ord_of_nat n\n  < \\<omega> \\<up> ord_of_nat n * \\<omega>\n  \\<lbrakk>?b < ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n\ngoal (1 subgoal):\n 1. omega_sum_aux (Suc n) (m # ms) < \\<omega> \\<up> ord_of_nat (Suc n)", "by force"], ["proof (state)\nthis:\n  omega_sum_aux (Suc n) (m # ms) < \\<omega> \\<up> ord_of_nat (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>uu_. omega_sum_aux 0 uu_ < \\<omega> \\<up> ord_of_nat 0\n 2. \\<And>n. omega_sum_aux (Suc n) [] < \\<omega> \\<up> ord_of_nat (Suc n)", "qed auto"], ["", "lemma omega_sum_less: \"omega_sum ms < \\<omega> \\<up> (length ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum ms < \\<omega> \\<up> ord_of_nat (length ms)", "by (rule omega_sum_aux_less)"], ["", "lemma omega_sum_ge: \"m \\<noteq> 0 \\<Longrightarrow> \\<omega> \\<up> (length ms) \\<le> omega_sum (m#ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<omega> \\<up> ord_of_nat (length ms) \\<le> omega_sum (m # ms)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m;\n        x \\<in> elts (\\<omega> \\<up> ord_of_nat (length ms))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> elts\n                                  (\\<omega> \\<up> ord_of_nat (length ms) *\n                                   ord_of_nat m +\n                                   omega_sum ms)", "by (metis Ord_ord_of_nat add_le_cancel_left0 le_mult Nat.neq0_conv ord_of_eq_0_iff vsubsetD)"], ["", "lemma omega_sum_length_less:\n  assumes \"length ms < length ns\" \"normal ns\"\n  shows \"omega_sum ms < omega_sum ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum ms < omega_sum ns", "proof (cases ns)"], ["proof (state)\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow> omega_sum ms < omega_sum ns\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow> omega_sum ms < omega_sum ns", "case Nil"], ["proof (state)\nthis:\n  ns = []\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow> omega_sum ms < omega_sum ns\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow> omega_sum ms < omega_sum ns", "then"], ["proof (chain)\npicking this:\n  ns = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ns = []\n\ngoal (1 subgoal):\n 1. omega_sum ms < omega_sum ns", "using assms"], ["proof (prove)\nusing this:\n  ns = []\n  length ms < length ns\n  normal ns\n\ngoal (1 subgoal):\n 1. omega_sum ms < omega_sum ns", "by auto"], ["proof (state)\nthis:\n  omega_sum ms < omega_sum ns\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow> omega_sum ms < omega_sum ns", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow> omega_sum ms < omega_sum ns", "case (Cons n ns')"], ["proof (state)\nthis:\n  ns = n # ns'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow> omega_sum ms < omega_sum ns", "have \"\\<omega> \\<up> length ms \\<le> \\<omega> \\<up> length ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ord_of_nat (length ms)\n    \\<le> \\<omega> \\<up> ord_of_nat (length ns')", "using assms local.Cons"], ["proof (prove)\nusing this:\n  length ms < length ns\n  normal ns\n  ns = n # ns'\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ord_of_nat (length ms)\n    \\<le> \\<omega> \\<up> ord_of_nat (length ns')", "by (simp add: oexp_mono_le)"], ["proof (state)\nthis:\n  \\<omega> \\<up> ord_of_nat (length ms)\n  \\<le> \\<omega> \\<up> ord_of_nat (length ns')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow> omega_sum ms < omega_sum ns", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> ord_of_nat (length ms)\n  \\<le> \\<omega> \\<up> ord_of_nat (length ns')", "have \"\\<not> omega_sum (n#ns') \\<le> omega_sum ms\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> ord_of_nat (length ms)\n  \\<le> \\<omega> \\<up> ord_of_nat (length ns')\n\ngoal (1 subgoal):\n 1. \\<not> omega_sum (n # ns') \\<le> omega_sum ms", "using omega_sum_ge [of n ns'] omega_sum_less [of ms] \\<open>normal ns\\<close> local.Cons"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> ord_of_nat (length ms)\n  \\<le> \\<omega> \\<up> ord_of_nat (length ns')\n  n \\<noteq> 0 \\<Longrightarrow>\n  \\<omega> \\<up> ord_of_nat (length ns') \\<le> omega_sum (n # ns')\n  omega_sum ms < \\<omega> \\<up> ord_of_nat (length ms)\n  normal ns\n  ns = n # ns'\n\ngoal (1 subgoal):\n 1. \\<not> omega_sum (n # ns') \\<le> omega_sum ms", "by auto"], ["proof (state)\nthis:\n  \\<not> omega_sum (n # ns') \\<le> omega_sum ms\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow> omega_sum ms < omega_sum ns", "then"], ["proof (chain)\npicking this:\n  \\<not> omega_sum (n # ns') \\<le> omega_sum ms", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> omega_sum (n # ns') \\<le> omega_sum ms\n\ngoal (1 subgoal):\n 1. omega_sum ms < omega_sum ns", "by (metis Ord_linear2 Ord_omega_sum local.Cons)"], ["proof (state)\nthis:\n  omega_sum ms < omega_sum ns\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma omega_sum_length_leD:\n  assumes \"omega_sum ms \\<le> omega_sum ns\" \"normal ms\"\n  shows \"length ms \\<le> length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ms \\<le> length ns", "by (meson assms leD leI omega_sum_length_less)"], ["", "lemma omega_sum_less_eqlen_iff_cases [simp]:\n  assumes \"length ms = length ns\"\n   shows \"omega_sum (m#ms) < omega_sum (n#ns)\n          \\<longleftrightarrow> m<n \\<or> m=n \\<and> omega_sum ms < omega_sum ns\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (omega_sum (m # ms) < omega_sum (n # ns)) =\n    (m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns\n 2. m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "assume L: ?lhs"], ["proof (state)\nthis:\n  omega_sum (m # ms) < omega_sum (n # ns)\n\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns\n 2. m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "have \"\\<not> Suc n < Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Suc n < Suc m", "using omega_sum_less [of ms] omega_sum_less [of ns] L assms mult_nat_less_add_less"], ["proof (prove)\nusing this:\n  omega_sum ms < \\<omega> \\<up> ord_of_nat (length ms)\n  omega_sum ns < \\<omega> \\<up> ord_of_nat (length ns)\n  omega_sum (m # ms) < omega_sum (n # ns)\n  length ms = length ns\n  \\<lbrakk>?m < ?n; ?\\<alpha> < ?\\<gamma>; ?\\<beta> < ?\\<gamma>;\n   Ord ?\\<alpha>; Ord ?\\<beta>; Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<gamma> * ord_of_nat ?m + ?\\<alpha>\n                    < ?\\<gamma> * ord_of_nat ?n + ?\\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> Suc n < Suc m", "by fastforce"], ["proof (state)\nthis:\n  \\<not> Suc n < Suc m\n\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns\n 2. m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "then"], ["proof (chain)\npicking this:\n  \\<not> Suc n < Suc m", "have \"m\\<le>n\""], ["proof (prove)\nusing this:\n  \\<not> Suc n < Suc m\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by auto"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns\n 2. m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "with L assms"], ["proof (chain)\npicking this:\n  omega_sum (m # ms) < omega_sum (n # ns)\n  length ms = length ns\n  m \\<le> n", "show ?rhs"], ["proof (prove)\nusing this:\n  omega_sum (m # ms) < omega_sum (n # ns)\n  length ms = length ns\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns", "by auto"], ["proof (state)\nthis:\n  m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns\n\ngoal (1 subgoal):\n 1. m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "assume ?rhs"], ["proof (state)\nthis:\n  m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns\n\ngoal (1 subgoal):\n 1. m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "then"], ["proof (chain)\npicking this:\n  m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns", "show ?lhs"], ["proof (prove)\nusing this:\n  m < n \\<or> m = n \\<and> omega_sum ms < omega_sum ns\n\ngoal (1 subgoal):\n 1. omega_sum (m # ms) < omega_sum (n # ns)", "by (auto simp: mult_nat_less_add_less omega_sum_aux_less assms)"], ["proof (state)\nthis:\n  omega_sum (m # ms) < omega_sum (n # ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma omega_sum_lex_less_iff_cases:\n   \"((length ms, omega_sum (m#ms)), (length ns, omega_sum (n#ns))) \\<in> less_than <*lex*> VWF\n   \\<longleftrightarrow> length ms < length ns\n            \\<or> length ms = length ns \\<and> m<n\n            \\<or> m=n \\<and> ((length ms, omega_sum ms), (length ns, omega_sum ns)) \\<in> less_than <*lex*> VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((length ms, omega_sum (m # ms)), length ns, omega_sum (n # ns))\n     \\<in> less_than <*lex*> VWF) =\n    (length ms < length ns \\<or>\n     length ms = length ns \\<and> m < n \\<or>\n     m = n \\<and>\n     ((length ms, omega_sum ms), length ns, omega_sum ns)\n     \\<in> less_than <*lex*> VWF)", "using omega_sum_less_eqlen_iff_cases"], ["proof (prove)\nusing this:\n  length ?ms = length ?ns \\<Longrightarrow>\n  (omega_sum (?m # ?ms) < omega_sum (?n # ?ns)) =\n  (?m < ?n \\<or> ?m = ?n \\<and> omega_sum ?ms < omega_sum ?ns)\n\ngoal (1 subgoal):\n 1. (((length ms, omega_sum (m # ms)), length ns, omega_sum (n # ns))\n     \\<in> less_than <*lex*> VWF) =\n    (length ms < length ns \\<or>\n     length ms = length ns \\<and> m < n \\<or>\n     m = n \\<and>\n     ((length ms, omega_sum ms), length ns, omega_sum ns)\n     \\<in> less_than <*lex*> VWF)", "by force"], ["", "lemma omega_sum_less_iff_cases:\n  assumes \"m > 0\" \"n > 0\"\n  shows \"omega_sum (m#ms) < omega_sum (n#ns)\n          \\<longleftrightarrow> length ms < length ns\n            \\<or> length ms = length ns \\<and> m<n\n            \\<or> length ms = length ns \\<and> m=n \\<and> omega_sum ms < omega_sum ns\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (omega_sum (m # ms) < omega_sum (n # ns)) =\n    (length ms < length ns \\<or>\n     length ms = length ns \\<and> m < n \\<or>\n     length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n 2. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "assume L: ?lhs"], ["proof (state)\nthis:\n  omega_sum (m # ms) < omega_sum (n # ns)\n\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n 2. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "then"], ["proof (chain)\npicking this:\n  omega_sum (m # ms) < omega_sum (n # ns)", "have \"length ms \\<le> length ns\""], ["proof (prove)\nusing this:\n  omega_sum (m # ms) < omega_sum (n # ns)\n\ngoal (1 subgoal):\n 1. length ms \\<le> length ns", "using omega_sum_length_leD [OF less_imp_le [OF L]]"], ["proof (prove)\nusing this:\n  omega_sum (m # ms) < omega_sum (n # ns)\n  normal (m # ms) \\<Longrightarrow> length (m # ms) \\<le> length (n # ns)\n\ngoal (1 subgoal):\n 1. length ms \\<le> length ns", "by (simp add: \\<open>m > 0\\<close>)"], ["proof (state)\nthis:\n  length ms \\<le> length ns\n\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n 2. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "moreover"], ["proof (state)\nthis:\n  length ms \\<le> length ns\n\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n 2. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "have \"m\\<le>n\" if \"length ms = length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "using L omega_sum_less_eqlen_iff_cases that"], ["proof (prove)\nusing this:\n  omega_sum (m # ms) < omega_sum (n # ns)\n  length ?ms = length ?ns \\<Longrightarrow>\n  (omega_sum (?m # ?ms) < omega_sum (?n # ?ns)) =\n  (?m < ?n \\<or> ?m = ?n \\<and> omega_sum ?ms < omega_sum ?ns)\n  length ms = length ns\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by auto"], ["proof (state)\nthis:\n  length ms = length ns \\<Longrightarrow> m \\<le> n\n\ngoal (2 subgoals):\n 1. omega_sum (m # ms) < omega_sum (n # ns) \\<Longrightarrow>\n    length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n 2. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "ultimately"], ["proof (chain)\npicking this:\n  length ms \\<le> length ns\n  length ms = length ns \\<Longrightarrow> m \\<le> n", "show ?rhs"], ["proof (prove)\nusing this:\n  length ms \\<le> length ns\n  length ms = length ns \\<Longrightarrow> m \\<le> n\n\ngoal (1 subgoal):\n 1. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns", "using L"], ["proof (prove)\nusing this:\n  length ms \\<le> length ns\n  length ms = length ns \\<Longrightarrow> m \\<le> n\n  omega_sum (m # ms) < omega_sum (n # ns)\n\ngoal (1 subgoal):\n 1. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns", "by auto"], ["proof (state)\nthis:\n  length ms < length ns \\<or>\n  length ms = length ns \\<and> m < n \\<or>\n  length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n\ngoal (1 subgoal):\n 1. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "assume ?rhs"], ["proof (state)\nthis:\n  length ms < length ns \\<or>\n  length ms = length ns \\<and> m < n \\<or>\n  length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n\ngoal (1 subgoal):\n 1. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "moreover"], ["proof (state)\nthis:\n  length ms < length ns \\<or>\n  length ms = length ns \\<and> m < n \\<or>\n  length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n\ngoal (1 subgoal):\n 1. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "have \"omega_sum (m # ms) < omega_sum (n # ns)\"\n    if \"length ms < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum (m # ms) < omega_sum (n # ns)", "using that"], ["proof (prove)\nusing this:\n  length ms < length ns\n\ngoal (1 subgoal):\n 1. omega_sum (m # ms) < omega_sum (n # ns)", "by (metis Suc_mono \\<open>n > 0\\<close> length_Cons normal_Suc omega_sum_length_less)"], ["proof (state)\nthis:\n  length ms < length ns \\<Longrightarrow>\n  omega_sum (m # ms) < omega_sum (n # ns)\n\ngoal (1 subgoal):\n 1. length ms < length ns \\<or>\n    length ms = length ns \\<and> m < n \\<or>\n    length ms = length ns \\<and>\n    m = n \\<and> omega_sum ms < omega_sum ns \\<Longrightarrow>\n    omega_sum (m # ms) < omega_sum (n # ns)", "ultimately"], ["proof (chain)\npicking this:\n  length ms < length ns \\<or>\n  length ms = length ns \\<and> m < n \\<or>\n  length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n  length ms < length ns \\<Longrightarrow>\n  omega_sum (m # ms) < omega_sum (n # ns)", "show ?lhs"], ["proof (prove)\nusing this:\n  length ms < length ns \\<or>\n  length ms = length ns \\<and> m < n \\<or>\n  length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n  length ms < length ns \\<Longrightarrow>\n  omega_sum (m # ms) < omega_sum (n # ns)\n\ngoal (1 subgoal):\n 1. omega_sum (m # ms) < omega_sum (n # ns)", "using omega_sum_less_eqlen_iff_cases"], ["proof (prove)\nusing this:\n  length ms < length ns \\<or>\n  length ms = length ns \\<and> m < n \\<or>\n  length ms = length ns \\<and> m = n \\<and> omega_sum ms < omega_sum ns\n  length ms < length ns \\<Longrightarrow>\n  omega_sum (m # ms) < omega_sum (n # ns)\n  length ?ms = length ?ns \\<Longrightarrow>\n  (omega_sum (?m # ?ms) < omega_sum (?n # ?ns)) =\n  (?m < ?n \\<or> ?m = ?n \\<and> omega_sum ?ms < omega_sum ?ns)\n\ngoal (1 subgoal):\n 1. omega_sum (m # ms) < omega_sum (n # ns)", "by force"], ["proof (state)\nthis:\n  omega_sum (m # ms) < omega_sum (n # ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma omega_sum_less_iff:\n  \"((length ms, omega_sum ms), (length ns, omega_sum ns)) \\<in> less_than <*lex*> VWF\n   \\<longleftrightarrow> (ms,ns) \\<in> lenlex less_than\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((length ms, omega_sum ms), length ns, omega_sum ns)\n     \\<in> less_than <*lex*> VWF) =\n    ((ms, ns) \\<in> lenlex less_than)", "proof (induction ms arbitrary: ns)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ns.\n       (((length [], omega_sum []), length ns, omega_sum ns)\n        \\<in> less_than <*lex*> VWF) =\n       (([], ns) \\<in> lenlex less_than)\n 2. \\<And>a ms ns.\n       (\\<And>ns.\n           (((length ms, omega_sum ms), length ns, omega_sum ns)\n            \\<in> less_than <*lex*> VWF) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       (((length (a # ms), omega_sum (a # ms)), length ns, omega_sum ns)\n        \\<in> less_than <*lex*> VWF) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ns.\n       (((length [], omega_sum []), length ns, omega_sum ns)\n        \\<in> less_than <*lex*> VWF) =\n       (([], ns) \\<in> lenlex less_than)\n 2. \\<And>a ms ns.\n       (\\<And>ns.\n           (((length ms, omega_sum ms), length ns, omega_sum ns)\n            \\<in> less_than <*lex*> VWF) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       (((length (a # ms), omega_sum (a # ms)), length ns, omega_sum ns)\n        \\<in> less_than <*lex*> VWF) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((length [], omega_sum []), length ns, omega_sum ns)\n     \\<in> less_than <*lex*> VWF) =\n    (([], ns) \\<in> lenlex less_than)", "by auto"], ["proof (state)\nthis:\n  (((length [], omega_sum []), length ns, omega_sum ns)\n   \\<in> less_than <*lex*> VWF) =\n  (([], ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<And>a ms ns.\n       (\\<And>ns.\n           (((length ms, omega_sum ms), length ns, omega_sum ns)\n            \\<in> less_than <*lex*> VWF) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       (((length (a # ms), omega_sum (a # ms)), length ns, omega_sum ns)\n        \\<in> less_than <*lex*> VWF) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ms ns.\n       (\\<And>ns.\n           (((length ms, omega_sum ms), length ns, omega_sum ns)\n            \\<in> less_than <*lex*> VWF) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       (((length (a # ms), omega_sum (a # ms)), length ns, omega_sum ns)\n        \\<in> less_than <*lex*> VWF) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "case (Cons m ms)"], ["proof (state)\nthis:\n  (((length ms, omega_sum ms), length ?ns, omega_sum ?ns)\n   \\<in> less_than <*lex*> VWF) =\n  ((ms, ?ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<And>a ms ns.\n       (\\<And>ns.\n           (((length ms, omega_sum ms), length ns, omega_sum ns)\n            \\<in> less_than <*lex*> VWF) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       (((length (a # ms), omega_sum (a # ms)), length ns, omega_sum ns)\n        \\<in> less_than <*lex*> VWF) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "then"], ["proof (chain)\npicking this:\n  (((length ms, omega_sum ms), length ?ns, omega_sum ?ns)\n   \\<in> less_than <*lex*> VWF) =\n  ((ms, ?ns) \\<in> lenlex less_than)", "show ?case"], ["proof (prove)\nusing this:\n  (((length ms, omega_sum ms), length ?ns, omega_sum ?ns)\n   \\<in> less_than <*lex*> VWF) =\n  ((ms, ?ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. (((length (m # ms), omega_sum (m # ms)), length ns, omega_sum ns)\n     \\<in> less_than <*lex*> VWF) =\n    ((m # ms, ns) \\<in> lenlex less_than)", "proof (induction ns)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>ns.\n        (((length ms, omega_sum ms), length ns, omega_sum ns)\n         \\<in> less_than <*lex*> VWF) =\n        ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n    (((length (m # ms), omega_sum (m # ms)), length [], omega_sum [])\n     \\<in> less_than <*lex*> VWF) =\n    ((m # ms, []) \\<in> lenlex less_than)\n 2. \\<And>a ns.\n       \\<lbrakk>(\\<And>ns.\n                    (((length ms, omega_sum ms), length ns, omega_sum ns)\n                     \\<in> less_than <*lex*> VWF) =\n                    ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n                (((length (m # ms), omega_sum (m # ms)), length ns,\n                  omega_sum ns)\n                 \\<in> less_than <*lex*> VWF) =\n                ((m # ms, ns) \\<in> lenlex less_than);\n        \\<And>ns.\n           (((length ms, omega_sum ms), length ns, omega_sum ns)\n            \\<in> less_than <*lex*> VWF) =\n           ((ms, ns) \\<in> lenlex less_than)\\<rbrakk>\n       \\<Longrightarrow> (((length (m # ms), omega_sum (m # ms)),\n                           length (a # ns), omega_sum (a # ns))\n                          \\<in> less_than <*lex*> VWF) =\n                         ((m # ms, a # ns) \\<in> lenlex less_than)", "case (Cons n ns')"], ["proof (state)\nthis:\n  (\\<And>ns.\n      (((length ms, omega_sum ms), length ns, omega_sum ns)\n       \\<in> less_than <*lex*> VWF) =\n      ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n  (((length (m # ms), omega_sum (m # ms)), length ns', omega_sum ns')\n   \\<in> less_than <*lex*> VWF) =\n  ((m # ms, ns') \\<in> lenlex less_than)\n  (((length ms, omega_sum ms), length ?ns, omega_sum ?ns)\n   \\<in> less_than <*lex*> VWF) =\n  ((ms, ?ns) \\<in> lenlex less_than)\n\ngoal (2 subgoals):\n 1. (\\<And>ns.\n        (((length ms, omega_sum ms), length ns, omega_sum ns)\n         \\<in> less_than <*lex*> VWF) =\n        ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n    (((length (m # ms), omega_sum (m # ms)), length [], omega_sum [])\n     \\<in> less_than <*lex*> VWF) =\n    ((m # ms, []) \\<in> lenlex less_than)\n 2. \\<And>a ns.\n       \\<lbrakk>(\\<And>ns.\n                    (((length ms, omega_sum ms), length ns, omega_sum ns)\n                     \\<in> less_than <*lex*> VWF) =\n                    ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n                (((length (m # ms), omega_sum (m # ms)), length ns,\n                  omega_sum ns)\n                 \\<in> less_than <*lex*> VWF) =\n                ((m # ms, ns) \\<in> lenlex less_than);\n        \\<And>ns.\n           (((length ms, omega_sum ms), length ns, omega_sum ns)\n            \\<in> less_than <*lex*> VWF) =\n           ((ms, ns) \\<in> lenlex less_than)\\<rbrakk>\n       \\<Longrightarrow> (((length (m # ms), omega_sum (m # ms)),\n                           length (a # ns), omega_sum (a # ns))\n                          \\<in> less_than <*lex*> VWF) =\n                         ((m # ms, a # ns) \\<in> lenlex less_than)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((length (m # ms), omega_sum (m # ms)), length (n # ns'),\n      omega_sum (n # ns'))\n     \\<in> less_than <*lex*> VWF) =\n    ((m # ms, n # ns') \\<in> lenlex less_than)", "using omega_sum_lex_less_iff_cases [of ms m ns' n] Cons.prems"], ["proof (prove)\nusing this:\n  (((length ms, omega_sum (m # ms)), length ns', omega_sum (n # ns'))\n   \\<in> less_than <*lex*> VWF) =\n  (length ms < length ns' \\<or>\n   length ms = length ns' \\<and> m < n \\<or>\n   m = n \\<and>\n   ((length ms, omega_sum ms), length ns', omega_sum ns')\n   \\<in> less_than <*lex*> VWF)\n  (((length ms, omega_sum ms), length ?ns, omega_sum ?ns)\n   \\<in> less_than <*lex*> VWF) =\n  ((ms, ?ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. (((length (m # ms), omega_sum (m # ms)), length (n # ns'),\n      omega_sum (n # ns'))\n     \\<in> less_than <*lex*> VWF) =\n    ((m # ms, n # ns') \\<in> lenlex less_than)", "by (simp add: Cons_lenlex_iff lenlex_length order.not_eq_order_implies_strict nat_less_le)"], ["proof (state)\nthis:\n  (((length (m # ms), omega_sum (m # ms)), length (n # ns'),\n    omega_sum (n # ns'))\n   \\<in> less_than <*lex*> VWF) =\n  ((m # ms, n # ns') \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        (((length ms, omega_sum ms), length ns, omega_sum ns)\n         \\<in> less_than <*lex*> VWF) =\n        ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n    (((length (m # ms), omega_sum (m # ms)), length [], omega_sum [])\n     \\<in> less_than <*lex*> VWF) =\n    ((m # ms, []) \\<in> lenlex less_than)", "qed auto"], ["proof (state)\nthis:\n  (((length (m # ms), omega_sum (m # ms)), length ns, omega_sum ns)\n   \\<in> less_than <*lex*> VWF) =\n  ((m # ms, ns) \\<in> lenlex less_than)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_omega_sum_less_iff:\n  assumes \"length ms = length ns\"\n  shows \"(omega_sum ms, omega_sum ns) \\<in> VWF \\<longleftrightarrow> (ms,ns) \\<in> lenlex less_than\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((omega_sum ms, omega_sum ns) \\<in> VWF) =\n    ((ms, ns) \\<in> lenlex less_than)", "by (metis assms in_lex_prod less_not_refl less_than_iff omega_sum_less_iff)"], ["", "lemma eq_omega_sum_eq_iff:\n  assumes \"length ms = length ns\"\n  shows \"omega_sum ms = omega_sum ns \\<longleftrightarrow> ms=ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (omega_sum ms = omega_sum ns) = (ms = ns)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. omega_sum ms = omega_sum ns \\<Longrightarrow> ms = ns\n 2. ms = ns \\<Longrightarrow> omega_sum ms = omega_sum ns", "assume \"omega_sum ms = omega_sum ns\""], ["proof (state)\nthis:\n  omega_sum ms = omega_sum ns\n\ngoal (2 subgoals):\n 1. omega_sum ms = omega_sum ns \\<Longrightarrow> ms = ns\n 2. ms = ns \\<Longrightarrow> omega_sum ms = omega_sum ns", "then"], ["proof (chain)\npicking this:\n  omega_sum ms = omega_sum ns", "have \"(omega_sum ms, omega_sum ns) \\<notin> VWF\" \"(omega_sum ns, omega_sum ms) \\<notin> VWF\""], ["proof (prove)\nusing this:\n  omega_sum ms = omega_sum ns\n\ngoal (1 subgoal):\n 1. (omega_sum ms, omega_sum ns) \\<notin> VWF &&&\n    (omega_sum ns, omega_sum ms) \\<notin> VWF", "by auto"], ["proof (state)\nthis:\n  (omega_sum ms, omega_sum ns) \\<notin> VWF\n  (omega_sum ns, omega_sum ms) \\<notin> VWF\n\ngoal (2 subgoals):\n 1. omega_sum ms = omega_sum ns \\<Longrightarrow> ms = ns\n 2. ms = ns \\<Longrightarrow> omega_sum ms = omega_sum ns", "then"], ["proof (chain)\npicking this:\n  (omega_sum ms, omega_sum ns) \\<notin> VWF\n  (omega_sum ns, omega_sum ms) \\<notin> VWF", "obtain \"(ms,ns) \\<notin> lenlex less_than\" \"(ns,ms) \\<notin> lenlex less_than\""], ["proof (prove)\nusing this:\n  (omega_sum ms, omega_sum ns) \\<notin> VWF\n  (omega_sum ns, omega_sum ms) \\<notin> VWF\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>(ms, ns) \\<notin> lenlex less_than;\n      (ns, ms) \\<notin> lenlex less_than\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms eq_omega_sum_less_iff"], ["proof (prove)\nusing this:\n  (omega_sum ms, omega_sum ns) \\<notin> VWF\n  (omega_sum ns, omega_sum ms) \\<notin> VWF\n  length ms = length ns\n  length ?ms = length ?ns \\<Longrightarrow>\n  ((omega_sum ?ms, omega_sum ?ns) \\<in> VWF) =\n  ((?ms, ?ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>(ms, ns) \\<notin> lenlex less_than;\n      (ns, ms) \\<notin> lenlex less_than\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (ms, ns) \\<notin> lenlex less_than\n  (ns, ms) \\<notin> lenlex less_than\n\ngoal (2 subgoals):\n 1. omega_sum ms = omega_sum ns \\<Longrightarrow> ms = ns\n 2. ms = ns \\<Longrightarrow> omega_sum ms = omega_sum ns", "moreover"], ["proof (state)\nthis:\n  (ms, ns) \\<notin> lenlex less_than\n  (ns, ms) \\<notin> lenlex less_than\n\ngoal (2 subgoals):\n 1. omega_sum ms = omega_sum ns \\<Longrightarrow> ms = ns\n 2. ms = ns \\<Longrightarrow> omega_sum ms = omega_sum ns", "have \"total (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total (lenlex less_than)", "by (simp add: total_lenlex total_less_than)"], ["proof (state)\nthis:\n  total (lenlex less_than)\n\ngoal (2 subgoals):\n 1. omega_sum ms = omega_sum ns \\<Longrightarrow> ms = ns\n 2. ms = ns \\<Longrightarrow> omega_sum ms = omega_sum ns", "ultimately"], ["proof (chain)\npicking this:\n  (ms, ns) \\<notin> lenlex less_than\n  (ns, ms) \\<notin> lenlex less_than\n  total (lenlex less_than)", "show \"ms=ns\""], ["proof (prove)\nusing this:\n  (ms, ns) \\<notin> lenlex less_than\n  (ns, ms) \\<notin> lenlex less_than\n  total (lenlex less_than)\n\ngoal (1 subgoal):\n 1. ms = ns", "by (meson UNIV_I total_on_def)"], ["proof (state)\nthis:\n  ms = ns\n\ngoal (1 subgoal):\n 1. ms = ns \\<Longrightarrow> omega_sum ms = omega_sum ns", "qed auto"], ["", "lemma inj_omega_sum: \"inj_on omega_sum {l. length l = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on omega_sum {l. length l = n}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{l. length l = n}.\n       \\<forall>y\\<in>{l. length l = n}.\n          omega_sum x = omega_sum y \\<longrightarrow> x = y", "using eq_omega_sum_eq_iff"], ["proof (prove)\nusing this:\n  length ?ms = length ?ns \\<Longrightarrow>\n  (omega_sum ?ms = omega_sum ?ns) = (?ms = ?ns)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{l. length l = n}.\n       \\<forall>y\\<in>{l. length l = n}.\n          omega_sum x = omega_sum y \\<longrightarrow> x = y", "by fastforce"], ["", "lemma Ex_omega_sum: \"\\<gamma> \\<in> elts (\\<omega>\\<up>n) \\<Longrightarrow> \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = n", "proof (induction n arbitrary: \\<gamma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<gamma>.\n       \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat 0) \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = 0\n 2. \\<And>n \\<gamma>.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<gamma>\n                   \\<in> elts\n                          (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n                   \\<exists>ns.\n                      \\<gamma> = omega_sum ns \\<and> length ns = n;\n        \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "case 0"], ["proof (state)\nthis:\n  \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat 0)\n\ngoal (2 subgoals):\n 1. \\<And>\\<gamma>.\n       \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat 0) \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = 0\n 2. \\<And>n \\<gamma>.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<gamma>\n                   \\<in> elts\n                          (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n                   \\<exists>ns.\n                      \\<gamma> = omega_sum ns \\<and> length ns = n;\n        \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "then"], ["proof (chain)\npicking this:\n  \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat 0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat 0)\n\ngoal (1 subgoal):\n 1. \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = 0", "by (rule_tac x=\"[]\" in exI) auto"], ["proof (state)\nthis:\n  \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = 0\n\ngoal (1 subgoal):\n 1. \\<And>n \\<gamma>.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<gamma>\n                   \\<in> elts\n                          (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n                   \\<exists>ns.\n                      \\<gamma> = omega_sum ns \\<and> length ns = n;\n        \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n \\<gamma>.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<gamma>\n                   \\<in> elts\n                          (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n                   \\<exists>ns.\n                      \\<gamma> = omega_sum ns \\<and> length ns = n;\n        \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  ?\\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n  \\<exists>ns. ?\\<gamma> = omega_sum ns \\<and> length ns = n\n  \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n \\<gamma>.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<gamma>\n                   \\<in> elts\n                          (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n                   \\<exists>ns.\n                      \\<gamma> = omega_sum ns \\<and> length ns = n;\n        \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "then"], ["proof (chain)\npicking this:\n  ?\\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n  \\<exists>ns. ?\\<gamma> = omega_sum ns \\<and> length ns = n\n  \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))", "obtain k::nat where k: \"\\<gamma> \\<in> elts (\\<omega> \\<up> n * k)\"\n       and kmin: \"\\<And>k'. k'<k \\<Longrightarrow> \\<gamma> \\<notin> elts (\\<omega> \\<up> n * k')\""], ["proof (prove)\nusing this:\n  ?\\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n  \\<exists>ns. ?\\<gamma> = omega_sum ns \\<and> length ns = n\n  \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>\\<gamma>\n                 \\<in> elts (\\<omega> \\<up> ord_of_nat n * ord_of_nat k);\n         \\<And>k'.\n            k' < k \\<Longrightarrow>\n            \\<gamma>\n            \\<notin> elts\n                      (\\<omega> \\<up> ord_of_nat n * ord_of_nat k')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Ord_ord_of_nat elts_mult_\\<omega>E oexp_succ ord_of_nat.simps(2))"], ["proof (state)\nthis:\n  \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat n * ord_of_nat k)\n  ?k' < k \\<Longrightarrow>\n  \\<gamma> \\<notin> elts (\\<omega> \\<up> ord_of_nat n * ord_of_nat ?k')\n\ngoal (1 subgoal):\n 1. \\<And>n \\<gamma>.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<gamma>\n                   \\<in> elts\n                          (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n                   \\<exists>ns.\n                      \\<gamma> = omega_sum ns \\<and> length ns = n;\n        \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat (Suc n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "then"], ["proof (chain)\npicking this:\n  k = Suc k'", "obtain \\<delta> where \\<delta>: \"\\<gamma> = (\\<omega> \\<up> n * k') + \\<delta>\""], ["proof (prove)\nusing this:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>.\n        \\<gamma> =\n        \\<omega> \\<up> ord_of_nat n * ord_of_nat k' +\n        \\<delta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis lessI mult_succ ord_of_nat.simps(2) k kmin mem_plus_V_E)"], ["proof (state)\nthis:\n  \\<gamma> = \\<omega> \\<up> ord_of_nat n * ord_of_nat k' + \\<delta>\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "then"], ["proof (chain)\npicking this:\n  \\<gamma> = \\<omega> \\<up> ord_of_nat n * ord_of_nat k' + \\<delta>", "have \\<delta>in: \"\\<delta> \\<in> elts (\\<omega> \\<up> n)\""], ["proof (prove)\nusing this:\n  \\<gamma> = \\<omega> \\<up> ord_of_nat n * ord_of_nat k' + \\<delta>\n\ngoal (1 subgoal):\n 1. \\<delta> \\<in> elts (\\<omega> \\<up> ord_of_nat n)", "using Suc k mult_succ"], ["proof (prove)\nusing this:\n  \\<gamma> = \\<omega> \\<up> ord_of_nat n * ord_of_nat k' + \\<delta>\n  k = Suc k'\n  \\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat n * ord_of_nat k)\n  ?x * ZFC_in_HOL.succ ?y = ?x * ?y + ?x\n\ngoal (1 subgoal):\n 1. \\<delta> \\<in> elts (\\<omega> \\<up> ord_of_nat n)", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<in> elts (\\<omega> \\<up> ord_of_nat n)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "then"], ["proof (chain)\npicking this:\n  \\<delta> \\<in> elts (\\<omega> \\<up> ord_of_nat n)", "obtain ns where ns: \"\\<delta> = omega_sum ns\" and len: \"length ns = n\""], ["proof (prove)\nusing this:\n  \\<delta> \\<in> elts (\\<omega> \\<up> ord_of_nat n)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>\\<delta> = omega_sum ns; length ns = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.IH"], ["proof (prove)\nusing this:\n  \\<delta> \\<in> elts (\\<omega> \\<up> ord_of_nat n)\n  ?\\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat n) \\<Longrightarrow>\n  \\<exists>ns. ?\\<gamma> = omega_sum ns \\<and> length ns = n\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>\\<delta> = omega_sum ns; length ns = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<delta> = omega_sum ns\n  length ns = n\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "moreover"], ["proof (state)\nthis:\n  \\<delta> = omega_sum ns\n  length ns = n\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "have \"omega_sum ns < \\<omega>\\<up>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum ns < \\<omega> \\<up> ord_of_nat n", "using OrdmemD ns \\<delta>in"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?j \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> ?j < ?k\n  \\<delta> = omega_sum ns\n  \\<delta> \\<in> elts (\\<omega> \\<up> ord_of_nat n)\n\ngoal (1 subgoal):\n 1. omega_sum ns < \\<omega> \\<up> ord_of_nat n", "by auto"], ["proof (state)\nthis:\n  omega_sum ns < \\<omega> \\<up> ord_of_nat n\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> = omega_sum ns\n  length ns = n\n  omega_sum ns < \\<omega> \\<up> ord_of_nat n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<delta> = omega_sum ns\n  length ns = n\n  omega_sum ns < \\<omega> \\<up> ord_of_nat n\n\ngoal (1 subgoal):\n 1. \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "by (rule_tac x=\"k'#ns\" in exI) (simp add: \\<delta>)"], ["proof (state)\nthis:\n  \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n", "qed (use k in auto)"], ["proof (state)\nthis:\n  \\<exists>ns. \\<gamma> = omega_sum ns \\<and> length ns = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma omega_sum_drop [simp]: \"omega_sum (dropWhile (\\<lambda>n. n=0) ns) = omega_sum ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum (dropWhile (\\<lambda>n. n = 0) ns) = omega_sum ns", "by (induction ns) auto"], ["", "lemma normal_drop [simp]: \"normal (dropWhile (\\<lambda>n. n=0) ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal (dropWhile (\\<lambda>n. n = 0) ns)", "by (induction ns) auto"], ["", "lemma omega_sum_\\<omega>\\<omega>:\n  assumes \"\\<gamma> \\<in> elts (\\<omega>\\<up>\\<omega>)\"\n  obtains ns where \"\\<gamma> = omega_sum ns\" \"normal ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>\\<gamma> = omega_sum ns; normal ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>\\<gamma> = omega_sum ns; normal ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ms where \"\\<gamma> = omega_sum ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ms.\n        \\<gamma> = omega_sum ms \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms Ex_omega_sum"], ["proof (prove)\nusing this:\n  \\<gamma> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  ?\\<gamma> \\<in> elts (\\<omega> \\<up> ord_of_nat ?n) \\<Longrightarrow>\n  \\<exists>ns. ?\\<gamma> = omega_sum ns \\<and> length ns = ?n\n\ngoal (1 subgoal):\n 1. (\\<And>ms.\n        \\<gamma> = omega_sum ms \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: oexp_Limit elts_\\<omega>)"], ["proof (state)\nthis:\n  \\<gamma> = omega_sum ms\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>\\<gamma> = omega_sum ns; normal ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<gamma> = omega_sum ?ns\n 2. normal ?ns", "show \"\\<gamma> = omega_sum (dropWhile (\\<lambda>n. n=0) ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> = omega_sum (dropWhile (\\<lambda>n. n = 0) ms)", "by (simp add: \\<open>\\<gamma> = omega_sum ms\\<close>)"], ["proof (state)\nthis:\n  \\<gamma> = omega_sum (dropWhile (\\<lambda>n. n = 0) ms)\n\ngoal (1 subgoal):\n 1. normal (dropWhile (\\<lambda>n. n = 0) ms)", "show \"normal (dropWhile (\\<lambda>n. n=0) ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal (dropWhile (\\<lambda>n. n = 0) ms)", "by auto"], ["proof (state)\nthis:\n  normal (dropWhile (\\<lambda>n. n = 0) ms)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Cantor_\\<omega>\\<omega> :: \"V \\<Rightarrow> nat list\"\n  where \"Cantor_\\<omega>\\<omega> \\<equiv> \\<lambda>x. SOME ns. x = omega_sum ns \\<and> normal ns\""], ["", "lemma\n  assumes \"\\<gamma> \\<in> elts (\\<omega>\\<up>\\<omega>)\"\n  shows Cantor_\\<omega>\\<omega>: \"omega_sum (Cantor_\\<omega>\\<omega> \\<gamma>) = \\<gamma>\"\n    and normal_Cantor_\\<omega>\\<omega>: \"normal (Cantor_\\<omega>\\<omega> \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum (Cantor_\\<omega>\\<omega> \\<gamma>) = \\<gamma> &&&\n    normal (Cantor_\\<omega>\\<omega> \\<gamma>)", "by (metis (mono_tags, lifting) Cantor_\\<omega>\\<omega>_def assms omega_sum_\\<omega>\\<omega> someI)+"], ["", "subsection \\<open>Larson's set $W(n)$\\<close>"], ["", "definition WW :: \"nat list set\"\n  where \"WW \\<equiv> {l. strict_sorted l}\""], ["", "fun into_WW :: \"nat \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"into_WW k [] = []\"\n| \"into_WW k (n#ns) = (k+n) # into_WW (Suc (k+n)) ns\""], ["", "fun from_WW :: \"nat \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"from_WW k [] = []\"\n| \"from_WW k (n#ns) = (n - k) # from_WW (Suc n) ns\""], ["", "lemma from_into_WW [simp]: \"from_WW k (into_WW k ns) = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_WW k (into_WW k ns) = ns", "by (induction ns arbitrary: k) auto"], ["", "lemma inj_into_WW: \"inj (into_WW k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (into_WW k)", "by (metis from_into_WW injI)"], ["", "lemma into_from_WW_aux:\n  \"\\<lbrakk>strict_sorted ns; \\<forall>n\\<in>list.set ns. k \\<le> n\\<rbrakk> \\<Longrightarrow> into_WW k (from_WW k ns) = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_sorted ns;\n     \\<forall>n\\<in>list.set ns. k \\<le> n\\<rbrakk>\n    \\<Longrightarrow> into_WW k (from_WW k ns) = ns", "by (induction ns arbitrary: k) (auto simp: Suc_leI)"], ["", "lemma into_from_WW [simp]: \"strict_sorted ns \\<Longrightarrow> into_WW 0 (from_WW 0 ns) = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted ns \\<Longrightarrow> into_WW 0 (from_WW 0 ns) = ns", "by (simp add: into_from_WW_aux)"], ["", "lemma into_WW_imp_ge: \"y \\<in> List.set (into_WW x ns) \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> list.set (into_WW x ns) \\<Longrightarrow> x \\<le> y", "by (induction ns arbitrary: x) fastforce+"], ["", "lemma strict_sorted_into_WW: \"strict_sorted (into_WW x ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (into_WW x ns)", "by (induction ns arbitrary: x) (auto simp: dest: into_WW_imp_ge)"], ["", "lemma length_into_WW: \"length (into_WW x ns) = length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (into_WW x ns) = length ns", "by (induction ns arbitrary: x) auto"], ["", "lemma WW_eq_range_into: \"WW = range (into_WW 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WW = range (into_WW 0)", "by (metis (mono_tags, hide_lams) WW_def equalityI image_subset_iff into_from_WW mem_Collect_eq rangeI strict_sorted_into_WW subset_iff)"], ["", "lemma into_WW_lenlex_iff: \"(into_WW k ms, into_WW k ns) \\<in> lenlex less_than \\<longleftrightarrow> (ms, ns) \\<in> lenlex less_than\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((into_WW k ms, into_WW k ns) \\<in> lenlex less_than) =\n    ((ms, ns) \\<in> lenlex less_than)", "proof (induction ms arbitrary: ns k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ns k.\n       ((into_WW k [], into_WW k ns) \\<in> lenlex less_than) =\n       (([], ns) \\<in> lenlex less_than)\n 2. \\<And>a ms ns k.\n       (\\<And>ns k.\n           ((into_WW k ms, into_WW k ns) \\<in> lenlex less_than) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       ((into_WW k (a # ms), into_WW k ns) \\<in> lenlex less_than) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ns k.\n       ((into_WW k [], into_WW k ns) \\<in> lenlex less_than) =\n       (([], ns) \\<in> lenlex less_than)\n 2. \\<And>a ms ns k.\n       (\\<And>ns k.\n           ((into_WW k ms, into_WW k ns) \\<in> lenlex less_than) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       ((into_WW k (a # ms), into_WW k ns) \\<in> lenlex less_than) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((into_WW k [], into_WW k ns) \\<in> lenlex less_than) =\n    (([], ns) \\<in> lenlex less_than)", "by simp (metis length_0_conv length_into_WW)"], ["proof (state)\nthis:\n  ((into_WW k [], into_WW k ns) \\<in> lenlex less_than) =\n  (([], ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<And>a ms ns k.\n       (\\<And>ns k.\n           ((into_WW k ms, into_WW k ns) \\<in> lenlex less_than) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       ((into_WW k (a # ms), into_WW k ns) \\<in> lenlex less_than) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ms ns k.\n       (\\<And>ns k.\n           ((into_WW k ms, into_WW k ns) \\<in> lenlex less_than) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       ((into_WW k (a # ms), into_WW k ns) \\<in> lenlex less_than) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "case (Cons m ms)"], ["proof (state)\nthis:\n  ((into_WW ?k ms, into_WW ?k ?ns) \\<in> lenlex less_than) =\n  ((ms, ?ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<And>a ms ns k.\n       (\\<And>ns k.\n           ((into_WW k ms, into_WW k ns) \\<in> lenlex less_than) =\n           ((ms, ns) \\<in> lenlex less_than)) \\<Longrightarrow>\n       ((into_WW k (a # ms), into_WW k ns) \\<in> lenlex less_than) =\n       ((a # ms, ns) \\<in> lenlex less_than)", "then"], ["proof (chain)\npicking this:\n  ((into_WW ?k ms, into_WW ?k ?ns) \\<in> lenlex less_than) =\n  ((ms, ?ns) \\<in> lenlex less_than)", "show ?case"], ["proof (prove)\nusing this:\n  ((into_WW ?k ms, into_WW ?k ?ns) \\<in> lenlex less_than) =\n  ((ms, ?ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. ((into_WW k (m # ms), into_WW k ns) \\<in> lenlex less_than) =\n    ((m # ms, ns) \\<in> lenlex less_than)", "by (induction ns) (auto simp: Cons_lenlex_iff length_into_WW)"], ["proof (state)\nthis:\n  ((into_WW k (m # ms), into_WW k ns) \\<in> lenlex less_than) =\n  ((m # ms, ns) \\<in> lenlex less_than)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_llt [simp]: \"wf (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (lenlex less_than)", "by blast"], ["", "lemma trans_llt [simp]: \"trans (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (lenlex less_than)", "by blast"], ["", "lemma total_llt [simp]: \"total_on A (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_on A (lenlex less_than)", "by (meson UNIV_I total_lenlex total_less_than total_on_def)"], ["", "lemma omega_sum_1_less:\n  assumes \"(ms,ns) \\<in> lenlex less_than\" shows \"omega_sum (1#ms) < omega_sum (1#ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum (1 # ms) < omega_sum (1 # ns)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. omega_sum (1 # ms) < omega_sum (1 # ns)", "have \"omega_sum (1#ms) < omega_sum (1#ns)\" if \"length ms < length ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. omega_sum (1 # ms) < omega_sum (1 # ns)", "using omega_sum_less_iff_cases that zero_less_one"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> (omega_sum (?m # ?ms) < omega_sum (?n # ?ns)) =\n                    (length ?ms < length ?ns \\<or>\n                     length ?ms = length ?ns \\<and> ?m < ?n \\<or>\n                     length ?ms = length ?ns \\<and>\n                     ?m = ?n \\<and> omega_sum ?ms < omega_sum ?ns)\n  length ms < length ns\n  (0::?'a) < (1::?'a)\n\ngoal (1 subgoal):\n 1. omega_sum (1 # ms) < omega_sum (1 # ns)", "by blast"], ["proof (state)\nthis:\n  length ms < length ns \\<Longrightarrow>\n  omega_sum (1 # ms) < omega_sum (1 # ns)\n\ngoal (1 subgoal):\n 1. omega_sum (1 # ms) < omega_sum (1 # ns)", "then"], ["proof (chain)\npicking this:\n  length ms < length ns \\<Longrightarrow>\n  omega_sum (1 # ms) < omega_sum (1 # ns)", "show ?thesis"], ["proof (prove)\nusing this:\n  length ms < length ns \\<Longrightarrow>\n  omega_sum (1 # ms) < omega_sum (1 # ns)\n\ngoal (1 subgoal):\n 1. omega_sum (1 # ms) < omega_sum (1 # ns)", "using assms"], ["proof (prove)\nusing this:\n  length ms < length ns \\<Longrightarrow>\n  omega_sum (1 # ms) < omega_sum (1 # ns)\n  (ms, ns) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. omega_sum (1 # ms) < omega_sum (1 # ns)", "by (auto simp: mult_succ simp flip: omega_sum_less_iff)"], ["proof (state)\nthis:\n  omega_sum (1 # ms) < omega_sum (1 # ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_WW_1: \"ordertype WW (lenlex less_than) \\<le> ordertype UNIV (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype WW (lenlex less_than) \\<le> ordertype UNIV (lenlex less_than)", "by (rule ordertype_mono) auto"], ["", "lemma ordertype_WW_2: \"ordertype UNIV (lenlex less_than) \\<le> \\<omega>\\<up>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype UNIV (lenlex less_than) \\<le> \\<omega> \\<up> \\<omega>", "proof (rule ordertype_inc_le_Ord)"], ["proof (state)\ngoal (6 subgoals):\n 1. small UNIV\n 2. Ord (\\<omega> \\<up> \\<omega>)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        (x, y) \\<in> lenlex less_than\\<rbrakk>\n       \\<Longrightarrow> ?\\<pi> x < ?\\<pi> y\n 4. wf (lenlex less_than)\n 5. total (lenlex less_than)\n 6. range ?\\<pi> \\<subseteq> elts (\\<omega> \\<up> \\<omega>)", "show \"range (\\<lambda>ms. omega_sum (1#ms)) \\<subseteq> elts (\\<omega>\\<up>\\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>ms. omega_sum (1 # ms))\n    \\<subseteq> elts (\\<omega> \\<up> \\<omega>)", "by (meson Ord_\\<omega> Ord_mem_iff_lt Ord_oexp Ord_omega_sum image_subset_iff omega_sum_less_\\<omega>\\<omega>)"], ["proof (state)\nthis:\n  range (\\<lambda>ms. omega_sum (1 # ms))\n  \\<subseteq> elts (\\<omega> \\<up> \\<omega>)\n\ngoal (5 subgoals):\n 1. small UNIV\n 2. Ord (\\<omega> \\<up> \\<omega>)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        (x, y) \\<in> lenlex less_than\\<rbrakk>\n       \\<Longrightarrow> omega_sum (1 # x) < omega_sum (1 # y)\n 4. wf (lenlex less_than)\n 5. total (lenlex less_than)", "qed (use omega_sum_1_less in auto)"], ["", "lemma ordertype_WW_3: \"\\<omega>\\<up>\\<omega> \\<le> ordertype WW (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)", "define \\<pi> where \"\\<pi> \\<equiv> into_WW 0 \\<circ> Cantor_\\<omega>\\<omega>\""], ["proof (state)\nthis:\n  \\<pi> \\<equiv> into_WW 0 \\<circ> Cantor_\\<omega>\\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)", "have \\<omega>\\<omega>: \"\\<omega>\\<up>\\<omega> = tp (elts (\\<omega>\\<up>\\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> = tp (elts (\\<omega> \\<up> \\<omega>))", "by simp"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<omega> = tp (elts (\\<omega> \\<up> \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<omega> = tp (elts (\\<omega> \\<up> \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)", "have \"\\<dots> \\<le> ordertype WW (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tp (elts (\\<omega> \\<up> \\<omega>))\n    \\<le> ordertype WW (lenlex less_than)", "proof (rule ordertype_inc_le)"], ["proof (state)\ngoal (8 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> elts (\\<omega> \\<up> \\<omega>);\n        y \\<in> elts (\\<omega> \\<up> \\<omega>); (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> (?\\<pi> x, ?\\<pi> y) \\<in> lenlex less_than\n 4. wf VWF\n 5. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 6. wf (lenlex less_than)\n 7. trans (lenlex less_than)\n 8. ?\\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "fix \\<alpha> \\<beta>"], ["proof (state)\ngoal (8 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> elts (\\<omega> \\<up> \\<omega>);\n        y \\<in> elts (\\<omega> \\<up> \\<omega>); (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> (?\\<pi> x, ?\\<pi> y) \\<in> lenlex less_than\n 4. wf VWF\n 5. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 6. wf (lenlex less_than)\n 7. trans (lenlex less_than)\n 8. ?\\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "assume \\<alpha>: \"\\<alpha> \\<in> elts (\\<omega>\\<up>\\<omega>)\" and \\<beta>: \"\\<beta> \\<in> elts (\\<omega>\\<up>\\<omega>)\" and \"(\\<alpha>, \\<beta>) \\<in> VWF\""], ["proof (state)\nthis:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  (\\<alpha>, \\<beta>) \\<in> VWF\n\ngoal (8 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> elts (\\<omega> \\<up> \\<omega>);\n        y \\<in> elts (\\<omega> \\<up> \\<omega>); (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> (?\\<pi> x, ?\\<pi> y) \\<in> lenlex less_than\n 4. wf VWF\n 5. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 6. wf (lenlex less_than)\n 7. trans (lenlex less_than)\n 8. ?\\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  (\\<alpha>, \\<beta>) \\<in> VWF", "obtain *: \"Ord \\<alpha>\" \"Ord \\<beta>\" \"\\<alpha><\\<beta>\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  (\\<alpha>, \\<beta>) \\<in> VWF\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord \\<alpha>; Ord \\<beta>; \\<alpha> < \\<beta>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Ord_in_Ord Ord_ordertype VWF_iff_Ord_less \\<omega>\\<omega>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  Ord \\<beta>\n  \\<alpha> < \\<beta>\n\ngoal (8 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> elts (\\<omega> \\<up> \\<omega>);\n        y \\<in> elts (\\<omega> \\<up> \\<omega>); (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> (?\\<pi> x, ?\\<pi> y) \\<in> lenlex less_than\n 4. wf VWF\n 5. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 6. wf (lenlex less_than)\n 7. trans (lenlex less_than)\n 8. ?\\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>\n  Ord \\<beta>\n  \\<alpha> < \\<beta>", "have \"length (Cantor_\\<omega>\\<omega> \\<alpha>) \\<le> length (Cantor_\\<omega>\\<omega> \\<beta>)\""], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  Ord \\<beta>\n  \\<alpha> < \\<beta>\n\ngoal (1 subgoal):\n 1. length (Cantor_\\<omega>\\<omega> \\<alpha>)\n    \\<le> length (Cantor_\\<omega>\\<omega> \\<beta>)", "using \\<alpha> \\<beta>"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  Ord \\<beta>\n  \\<alpha> < \\<beta>\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<omega>)\n\ngoal (1 subgoal):\n 1. length (Cantor_\\<omega>\\<omega> \\<alpha>)\n    \\<le> length (Cantor_\\<omega>\\<omega> \\<beta>)", "by (simp add: Cantor_\\<omega>\\<omega> normal_Cantor_\\<omega>\\<omega> omega_sum_length_leD)"], ["proof (state)\nthis:\n  length (Cantor_\\<omega>\\<omega> \\<alpha>)\n  \\<le> length (Cantor_\\<omega>\\<omega> \\<beta>)\n\ngoal (8 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> elts (\\<omega> \\<up> \\<omega>);\n        y \\<in> elts (\\<omega> \\<up> \\<omega>); (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> (?\\<pi> x, ?\\<pi> y) \\<in> lenlex less_than\n 4. wf VWF\n 5. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 6. wf (lenlex less_than)\n 7. trans (lenlex less_than)\n 8. ?\\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "with \\<alpha> \\<beta> *"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  Ord \\<alpha>\n  Ord \\<beta>\n  \\<alpha> < \\<beta>\n  length (Cantor_\\<omega>\\<omega> \\<alpha>)\n  \\<le> length (Cantor_\\<omega>\\<omega> \\<beta>)", "have \"(Cantor_\\<omega>\\<omega> \\<alpha>, Cantor_\\<omega>\\<omega> \\<beta>) \\<in> lenlex less_than\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<omega>)\n  Ord \\<alpha>\n  Ord \\<beta>\n  \\<alpha> < \\<beta>\n  length (Cantor_\\<omega>\\<omega> \\<alpha>)\n  \\<le> length (Cantor_\\<omega>\\<omega> \\<beta>)\n\ngoal (1 subgoal):\n 1. (Cantor_\\<omega>\\<omega> \\<alpha>, Cantor_\\<omega>\\<omega> \\<beta>)\n    \\<in> lenlex less_than", "by (auto simp: Cantor_\\<omega>\\<omega> simp flip: omega_sum_less_iff)"], ["proof (state)\nthis:\n  (Cantor_\\<omega>\\<omega> \\<alpha>, Cantor_\\<omega>\\<omega> \\<beta>)\n  \\<in> lenlex less_than\n\ngoal (8 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> elts (\\<omega> \\<up> \\<omega>);\n        y \\<in> elts (\\<omega> \\<up> \\<omega>); (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> (?\\<pi> x, ?\\<pi> y) \\<in> lenlex less_than\n 4. wf VWF\n 5. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 6. wf (lenlex less_than)\n 7. trans (lenlex less_than)\n 8. ?\\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "then"], ["proof (chain)\npicking this:\n  (Cantor_\\<omega>\\<omega> \\<alpha>, Cantor_\\<omega>\\<omega> \\<beta>)\n  \\<in> lenlex less_than", "show \"(\\<pi> \\<alpha>, \\<pi> \\<beta>) \\<in> lenlex less_than\""], ["proof (prove)\nusing this:\n  (Cantor_\\<omega>\\<omega> \\<alpha>, Cantor_\\<omega>\\<omega> \\<beta>)\n  \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (\\<pi> \\<alpha>, \\<pi> \\<beta>) \\<in> lenlex less_than", "by (simp add: \\<pi>_def into_WW_lenlex_iff)"], ["proof (state)\nthis:\n  (\\<pi> \\<alpha>, \\<pi> \\<beta>) \\<in> lenlex less_than\n\ngoal (7 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. wf VWF\n 4. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 5. wf (lenlex less_than)\n 6. trans (lenlex less_than)\n 7. \\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. wf VWF\n 4. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 5. wf (lenlex less_than)\n 6. trans (lenlex less_than)\n 7. \\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "show \"\\<pi> ` elts (\\<omega>\\<up>\\<omega>) \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW", "by (auto simp: \\<pi>_def WW_def strict_sorted_into_WW)"], ["proof (state)\nthis:\n  \\<pi> ` elts (\\<omega> \\<up> \\<omega>) \\<subseteq> WW\n\ngoal (6 subgoals):\n 1. small (elts (\\<omega> \\<up> \\<omega>))\n 2. small WW\n 3. wf VWF\n 4. total_on (elts (\\<omega> \\<up> \\<omega>)) VWF\n 5. wf (lenlex less_than)\n 6. trans (lenlex less_than)", "qed auto"], ["proof (state)\nthis:\n  tp (elts (\\<omega> \\<up> \\<omega>)) \\<le> ordertype WW (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)", "finally"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)", "show \"\\<omega>\\<up>\\<omega> \\<le> ordertype WW (lenlex less_than)\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)", "."], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_WW: \"ordertype WW (lenlex less_than) = \\<omega>\\<up>\\<omega>\"\n  and ordertype_UNIV_\\<omega>\\<omega>: \"ordertype UNIV (lenlex less_than) = \\<omega>\\<up>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype WW (lenlex less_than) = \\<omega> \\<up> \\<omega> &&&\n    ordertype UNIV (lenlex less_than) = \\<omega> \\<up> \\<omega>", "using ordertype_WW_1 ordertype_WW_2 ordertype_WW_3"], ["proof (prove)\nusing this:\n  ordertype WW (lenlex less_than) \\<le> ordertype UNIV (lenlex less_than)\n  ordertype UNIV (lenlex less_than) \\<le> \\<omega> \\<up> \\<omega>\n  \\<omega> \\<up> \\<omega> \\<le> ordertype WW (lenlex less_than)\n\ngoal (1 subgoal):\n 1. ordertype WW (lenlex less_than) = \\<omega> \\<up> \\<omega> &&&\n    ordertype UNIV (lenlex less_than) = \\<omega> \\<up> \\<omega>", "by auto"], ["", "lemma ordertype_\\<omega>\\<omega>:\n  fixes F :: \"nat \\<Rightarrow> nat list set\"\n  assumes \"\\<And>j::nat. ordertype (F j) (lenlex less_than) = \\<omega>\\<up>j\"\n  shows \"ordertype (\\<Union>j. F j) (lenlex less_than) = \\<omega>\\<up>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (\\<Union> (range F)) (lenlex less_than) =\n    \\<omega> \\<up> \\<omega>", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ordertype (\\<Union> (range F)) (lenlex less_than)\n    \\<le> \\<omega> \\<up> \\<omega>\n 2. \\<omega> \\<up> \\<omega>\n    \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)", "show \"ordertype (\\<Union> (range F)) (lenlex less_than) \\<le> \\<omega> \\<up> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (\\<Union> (range F)) (lenlex less_than)\n    \\<le> \\<omega> \\<up> \\<omega>", "by (metis ordertype_UNIV_\\<omega>\\<omega> ordertype_mono small top_greatest trans_llt wf_llt)"], ["proof (state)\nthis:\n  ordertype (\\<Union> (range F)) (lenlex less_than)\n  \\<le> \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega>\n    \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)", "have \"\\<And>n. \\<omega> \\<up> ord_of_nat n \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<omega> \\<up> ord_of_nat n\n       \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)", "by (metis TC_small Union_upper assms ordertype_mono rangeI trans_llt wf_llt)"], ["proof (state)\nthis:\n  \\<omega> \\<up> ord_of_nat ?n\n  \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega>\n    \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> ord_of_nat ?n\n  \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)", "show \"\\<omega> \\<up> \\<omega> \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> ord_of_nat ?n\n  \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega>\n    \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)", "by (auto simp: oexp_\\<omega>_Limit ZFC_in_HOL.SUP_le_iff elts_\\<omega>)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<omega>\n  \\<le> ordertype (\\<Union> (range F)) (lenlex less_than)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition WW_seg :: \"nat \\<Rightarrow> nat list set\"\n  where \"WW_seg n \\<equiv> {l \\<in> WW. length l = n}\""], ["", "lemma WW_seg_subset_WW: \"WW_seg n \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WW_seg n \\<subseteq> WW", "by (auto simp: WW_seg_def)"], ["", "lemma WW_eq_UN_WW_seg: \"WW = (\\<Union> n. WW_seg n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WW = \\<Union> (range WW_seg)", "by (auto simp: WW_seg_def)"], ["", "lemma ordertype_list_seg: \"ordertype {l. length l = n} (lenlex less_than) = \\<omega>\\<up>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype {l. length l = n} (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype {l. length l = n} (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat n", "have \"bij_betw omega_sum {l. length l = n} (elts (\\<omega>\\<up>n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw omega_sum {l. length l = n}\n     (elts (\\<omega> \\<up> ord_of_nat n))", "unfolding WW_seg_def bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on omega_sum {l. length l = n} \\<and>\n    omega_sum ` {l. length l = n} = elts (\\<omega> \\<up> ord_of_nat n)", "by (auto simp: inj_omega_sum Ord_mem_iff_lt omega_sum_less dest: Ex_omega_sum)"], ["proof (state)\nthis:\n  bij_betw omega_sum {l. length l = n} (elts (\\<omega> \\<up> ord_of_nat n))\n\ngoal (1 subgoal):\n 1. ordertype {l. length l = n} (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat n", "then"], ["proof (chain)\npicking this:\n  bij_betw omega_sum {l. length l = n} (elts (\\<omega> \\<up> ord_of_nat n))", "show ?thesis"], ["proof (prove)\nusing this:\n  bij_betw omega_sum {l. length l = n} (elts (\\<omega> \\<up> ord_of_nat n))\n\ngoal (1 subgoal):\n 1. ordertype {l. length l = n} (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat n", "by (force simp: ordertype_eq_iff simp flip: eq_omega_sum_less_iff)"], ["proof (state)\nthis:\n  ordertype {l. length l = n} (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_WW_seg: \"ordertype (WW_seg n) (lenlex less_than) = \\<omega>\\<up>n\"\n  (is \"ordertype ?W ?R = \\<omega>\\<up>n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (WW_seg n) (lenlex less_than) = \\<omega> \\<up> ord_of_nat n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype (WW_seg n) (lenlex less_than) = \\<omega> \\<up> ord_of_nat n", "have \"ordertype {l. length l = n} ?R = ordertype ?W ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype {l. length l = n} (lenlex less_than) =\n    ordertype (WW_seg n) (lenlex less_than)", "proof (subst ordertype_eq_ordertype)"], ["proof (state)\ngoal (7 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on {l. length l = n} (lenlex less_than)\n 3. trans (lenlex less_than)\n 4. small {l. length l = n}\n 5. total_on (WW_seg n) (lenlex less_than)\n 6. small (WW_seg n)\n 7. \\<exists>f.\n       bij_betw f {l. length l = n} (WW_seg n) \\<and>\n       (\\<forall>x\\<in>{l. length l = n}.\n           \\<forall>y\\<in>{l. length l = n}.\n              ((f x, f y) \\<in> lenlex less_than) =\n              ((x, y) \\<in> lenlex less_than))", "show \"\\<exists>f. bij_betw f {l. length l = n} ?W \\<and> (\\<forall>x\\<in>{l. length l = n}. \\<forall>y\\<in>{l. length l = n}. ((f x, f y) \\<in> lenlex less_than) = ((x, y) \\<in> lenlex less_than))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f {l. length l = n} (WW_seg n) \\<and>\n       (\\<forall>x\\<in>{l. length l = n}.\n           \\<forall>y\\<in>{l. length l = n}.\n              ((f x, f y) \\<in> lenlex less_than) =\n              ((x, y) \\<in> lenlex less_than))", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw ?f {l. length l = n} (WW_seg n)\n 2. \\<forall>x\\<in>{l. length l = n}.\n       \\<forall>y\\<in>{l. length l = n}.\n          ((?f x, ?f y) \\<in> lenlex less_than) =\n          ((x, y) \\<in> lenlex less_than)", "have \"inj_on (into_WW 0) {l. length l = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (into_WW 0) {l. length l = n}", "by (metis from_into_WW inj_onI)"], ["proof (state)\nthis:\n  inj_on (into_WW 0) {l. length l = n}\n\ngoal (2 subgoals):\n 1. bij_betw ?f {l. length l = n} (WW_seg n)\n 2. \\<forall>x\\<in>{l. length l = n}.\n       \\<forall>y\\<in>{l. length l = n}.\n          ((?f x, ?f y) \\<in> lenlex less_than) =\n          ((x, y) \\<in> lenlex less_than)", "then"], ["proof (chain)\npicking this:\n  inj_on (into_WW 0) {l. length l = n}", "show \"bij_betw (into_WW 0) {l. length l = n} ?W\""], ["proof (prove)\nusing this:\n  inj_on (into_WW 0) {l. length l = n}\n\ngoal (1 subgoal):\n 1. bij_betw (into_WW 0) {l. length l = n} (WW_seg n)", "by (auto simp: bij_betw_def WW_seg_def WW_eq_range_into length_into_WW)"], ["proof (state)\nthis:\n  bij_betw (into_WW 0) {l. length l = n} (WW_seg n)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{l. length l = n}.\n       \\<forall>y\\<in>{l. length l = n}.\n          ((into_WW 0 x, into_WW 0 y) \\<in> lenlex less_than) =\n          ((x, y) \\<in> lenlex less_than)", "qed (simp add: into_WW_lenlex_iff)"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f {l. length l = n} (WW_seg n) \\<and>\n     (\\<forall>x\\<in>{l. length l = n}.\n         \\<forall>y\\<in>{l. length l = n}.\n            ((f x, f y) \\<in> lenlex less_than) =\n            ((x, y) \\<in> lenlex less_than))\n\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on {l. length l = n} (lenlex less_than)\n 3. trans (lenlex less_than)\n 4. small {l. length l = n}\n 5. total_on (WW_seg n) (lenlex less_than)\n 6. small (WW_seg n)", "qed auto"], ["proof (state)\nthis:\n  ordertype {l. length l = n} (lenlex less_than) =\n  ordertype (WW_seg n) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. ordertype (WW_seg n) (lenlex less_than) = \\<omega> \\<up> ord_of_nat n", "then"], ["proof (chain)\npicking this:\n  ordertype {l. length l = n} (lenlex less_than) =\n  ordertype (WW_seg n) (lenlex less_than)", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype {l. length l = n} (lenlex less_than) =\n  ordertype (WW_seg n) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. ordertype (WW_seg n) (lenlex less_than) = \\<omega> \\<up> ord_of_nat n", "using ordertype_list_seg"], ["proof (prove)\nusing this:\n  ordertype {l. length l = n} (lenlex less_than) =\n  ordertype (WW_seg n) (lenlex less_than)\n  ordertype {l. length l = ?n} (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat ?n\n\ngoal (1 subgoal):\n 1. ordertype (WW_seg n) (lenlex less_than) = \\<omega> \\<up> ord_of_nat n", "by auto"], ["proof (state)\nthis:\n  ordertype (WW_seg n) (lenlex less_than) = \\<omega> \\<up> ord_of_nat n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definitions required for the lemmas\\<close>"], ["", "subsubsection \\<open>Larson's \"$<$\"-relation on ordered lists\\<close>"], ["", "instantiation list :: (ord)ord\nbegin"], ["", "definition \"xs < ys \\<equiv> xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow> last xs < hd ys\" for xs ys :: \"'a list\""], ["", "definition \"xs \\<le> ys \\<equiv> xs < ys \\<or> xs = ys\" for xs ys :: \"'a list\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, ord_class)", "by standard"], ["", "end"], ["", "lemma less_Nil [simp]: \"xs < []\" \"[] < xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs < [] &&& [] < xs", "by (auto simp: less_list_def)"], ["", "lemma less_sets_imp_list_less:\n  assumes \"list.set xs \\<lless> list.set ys\"\n  shows \"xs < ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs < ys", "by (metis assms last_in_set less_list_def less_sets_def list.set_sel(1))"], ["", "lemma less_sets_imp_sorted_list_of_set:\n  assumes \"A \\<lless> B\" \"finite A\" \"finite B\"\n  shows \"list_of A < list_of B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of A < list_of B", "by (simp add: assms less_sets_imp_list_less)"], ["", "lemma sorted_list_of_set_imp_less_sets:\n  assumes \"xs < ys\" \"sorted xs\" \"sorted ys\"\n  shows \"list.set xs \\<lless> list.set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set xs \\<lless> list.set ys", "using assms sorted_hd_le sorted_le_last"], ["proof (prove)\nusing this:\n  xs < ys\n  sorted xs\n  sorted ys\n  \\<lbrakk>sorted ?xs; ?x \\<in> list.set ?xs\\<rbrakk>\n  \\<Longrightarrow> hd ?xs \\<le> ?x\n  \\<lbrakk>sorted ?xs; ?x \\<in> list.set ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> last ?xs\n\ngoal (1 subgoal):\n 1. list.set xs \\<lless> list.set ys", "by (force simp: less_list_def less_sets_def intro: order.trans)"], ["", "lemma less_list_iff_less_sets:\n  assumes \"sorted xs\" \"sorted ys\"\n  shows \"xs < ys \\<longleftrightarrow> list.set xs \\<lless> list.set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs < ys) = (list.set xs \\<lless> list.set ys)", "using assms sorted_hd_le sorted_le_last"], ["proof (prove)\nusing this:\n  sorted xs\n  sorted ys\n  \\<lbrakk>sorted ?xs; ?x \\<in> list.set ?xs\\<rbrakk>\n  \\<Longrightarrow> hd ?xs \\<le> ?x\n  \\<lbrakk>sorted ?xs; ?x \\<in> list.set ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> last ?xs\n\ngoal (1 subgoal):\n 1. (xs < ys) = (list.set xs \\<lless> list.set ys)", "by (force simp: less_list_def less_sets_def intro: order.trans)"], ["", "lemma sorted_trans:\n  assumes \"xs < ys\" \"ys < zs\" \"sorted ys\" \"ys \\<noteq> []\" shows \"xs < zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs < zs", "using assms"], ["proof (prove)\nusing this:\n  xs < ys\n  ys < zs\n  sorted ys\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs < zs", "unfolding less_list_def"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow> last xs < hd ys\n  ys \\<noteq> [] \\<and> zs \\<noteq> [] \\<longrightarrow> last ys < hd zs\n  sorted ys\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and> zs \\<noteq> [] \\<longrightarrow> last xs < hd zs", "by (metis dual_order.strict_trans last_in_set leD neqE sorted_hd_le)"], ["", "lemma strict_sorted_imp_append_less:\n  assumes \"strict_sorted (xs @ ys)\"\n  shows \"xs < ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs < ys", "using assms"], ["proof (prove)\nusing this:\n  strict_sorted (xs @ ys)\n\ngoal (1 subgoal):\n 1. xs < ys", "by (simp add: less_list_def sorted_wrt_append strict_sorted_sorted_wrt)"], ["", "lemma strict_sorted_append_iff:\n  \"strict_sorted (xs @ ys) \\<longleftrightarrow> xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (xs @ ys) =\n    (xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. strict_sorted (xs @ ys) \\<Longrightarrow>\n    xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\n 2. xs < ys \\<and>\n    strict_sorted xs \\<and> strict_sorted ys \\<Longrightarrow>\n    strict_sorted (xs @ ys)", "assume ?lhs"], ["proof (state)\nthis:\n  strict_sorted (xs @ ys)\n\ngoal (2 subgoals):\n 1. strict_sorted (xs @ ys) \\<Longrightarrow>\n    xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\n 2. xs < ys \\<and>\n    strict_sorted xs \\<and> strict_sorted ys \\<Longrightarrow>\n    strict_sorted (xs @ ys)", "then"], ["proof (chain)\npicking this:\n  strict_sorted (xs @ ys)", "show ?rhs"], ["proof (prove)\nusing this:\n  strict_sorted (xs @ ys)\n\ngoal (1 subgoal):\n 1. xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys", "by (auto simp: sorted_wrt_append strict_sorted_sorted_wrt less_list_def)"], ["proof (state)\nthis:\n  xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\n\ngoal (1 subgoal):\n 1. xs < ys \\<and>\n    strict_sorted xs \\<and> strict_sorted ys \\<Longrightarrow>\n    strict_sorted (xs @ ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs < ys \\<and>\n    strict_sorted xs \\<and> strict_sorted ys \\<Longrightarrow>\n    strict_sorted (xs @ ys)", "assume R: ?rhs"], ["proof (state)\nthis:\n  xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\n\ngoal (1 subgoal):\n 1. xs < ys \\<and>\n    strict_sorted xs \\<and> strict_sorted ys \\<Longrightarrow>\n    strict_sorted (xs @ ys)", "then"], ["proof (chain)\npicking this:\n  xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys", "have \"\\<And>x y. \\<lbrakk>x \\<in> list.set xs; y \\<in> list.set ys\\<rbrakk> \\<Longrightarrow> x < y\""], ["proof (prove)\nusing this:\n  xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> list.set xs; y \\<in> list.set ys\\<rbrakk>\n       \\<Longrightarrow> x < y", "using less_setsD sorted_list_of_set_imp_less_sets strict_sorted_imp_sorted"], ["proof (prove)\nusing this:\n  xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\n  \\<lbrakk>?A \\<lless> ?B; ?a \\<in> ?A; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n  \\<lbrakk>?xs < ?ys; sorted ?xs; sorted ?ys\\<rbrakk>\n  \\<Longrightarrow> list.set ?xs \\<lless> list.set ?ys\n  strict_sorted ?xs \\<Longrightarrow> sorted ?xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> list.set xs; y \\<in> list.set ys\\<rbrakk>\n       \\<Longrightarrow> x < y", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> list.set xs; ?y \\<in> list.set ys\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. xs < ys \\<and>\n    strict_sorted xs \\<and> strict_sorted ys \\<Longrightarrow>\n    strict_sorted (xs @ ys)", "with R"], ["proof (chain)\npicking this:\n  xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\n  \\<lbrakk>?x \\<in> list.set xs; ?y \\<in> list.set ys\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y", "show ?lhs"], ["proof (prove)\nusing this:\n  xs < ys \\<and> strict_sorted xs \\<and> strict_sorted ys\n  \\<lbrakk>?x \\<in> list.set xs; ?y \\<in> list.set ys\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. strict_sorted (xs @ ys)", "by (auto simp: sorted_wrt_append strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  strict_sorted (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_less_list_iff: \"sorted xs \\<Longrightarrow> [n] < xs \\<longleftrightarrow> {..n} \\<inter> list.set xs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs \\<Longrightarrow>\n    ([n] < xs) = ({..n} \\<inter> list.set xs = {})", "apply (simp add: less_list_def set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs \\<Longrightarrow>\n    (xs \\<noteq> [] \\<longrightarrow> n < hd xs) =\n    (\\<forall>x\\<le>n. x \\<notin> list.set xs)", "by (metis empty_iff less_le_trans list.set(1) list.set_sel(1) not_le sorted_hd_le)"], ["", "lemma less_last_iff: \"xs@[x] < ys \\<longleftrightarrow> [x] < ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ [x] < ys) = ([x] < ys)", "by (simp add: less_list_def)"], ["", "lemma less_Cons_iff: \"NO_MATCH [] ys \\<Longrightarrow> xs < y#ys \\<longleftrightarrow> xs < [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH [] ys \\<Longrightarrow> (xs < y # ys) = (xs < [y])", "by (simp add: less_list_def)"], ["", "lemma less_hd_imp_less: \"xs < [hd ys] \\<Longrightarrow> xs < ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs < [hd ys] \\<Longrightarrow> xs < ys", "by (simp add: less_list_def)"], ["", "lemma last_less_imp_less: \"[last xs] < ys \\<Longrightarrow> xs < ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [last xs] < ys \\<Longrightarrow> xs < ys", "by (simp add: less_list_def)"], ["", "lemma strict_sorted_concat_I:\n  assumes\n    \"\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x\"\n    \"\\<And>n. Suc n < length xs \\<Longrightarrow> xs!n < xs!Suc n\"\n  assumes \"xs \\<in> lists (- {[]})\"\n  shows \"strict_sorted (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat xs)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> list.set xs \\<Longrightarrow> strict_sorted ?x\n  Suc ?n < length xs \\<Longrightarrow> xs ! ?n < xs ! Suc ?n\n  xs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (concat xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n     \\<And>n. Suc n < length [] \\<Longrightarrow> [] ! n < [] ! Suc n;\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (concat [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> list.set xs \\<Longrightarrow>\n                            strict_sorted x;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> xs ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (concat xs);\n        \\<And>x.\n           x \\<in> list.set (a # xs) \\<Longrightarrow> strict_sorted x;\n        \\<And>n.\n           Suc n < length (a # xs) \\<Longrightarrow>\n           (a # xs) ! n < (a # xs) ! Suc n;\n        a # xs \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (concat (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> xs ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (concat xs)\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (x # xs) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n     \\<And>n. Suc n < length [] \\<Longrightarrow> [] ! n < [] ! Suc n;\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (concat [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> list.set xs \\<Longrightarrow>\n                            strict_sorted x;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> xs ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (concat xs);\n        \\<And>x.\n           x \\<in> list.set (a # xs) \\<Longrightarrow> strict_sorted x;\n        \\<And>n.\n           Suc n < length (a # xs) \\<Longrightarrow>\n           (a # xs) ! n < (a # xs) ! Suc n;\n        a # xs \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (concat (a # xs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> xs ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (concat xs)\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (x # xs) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})", "have \"x < concat xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> xs ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (concat xs)\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (x # xs) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. x < concat xs", "apply (simp add: less_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<And>n.\n                 Suc n < length xs \\<Longrightarrow>\n                 xs ! n \\<noteq> [] \\<and>\n                 xs ! Suc n \\<noteq> [] \\<longrightarrow>\n                 last (xs ! n) < hd (xs ! Suc n)) \\<Longrightarrow>\n             strict_sorted (concat xs);\n     \\<And>xa.\n        xa = x \\<or> xa \\<in> list.set xs \\<Longrightarrow>\n        strict_sorted xa;\n     \\<And>n.\n        n < length xs \\<Longrightarrow>\n        (x # xs) ! n \\<noteq> [] \\<and> xs ! n \\<noteq> [] \\<longrightarrow>\n        last ((x # xs) ! n) < hd (xs ! n);\n     x \\<noteq> [] \\<and> xs \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs\\<in>list.set xs.\n                          xs \\<noteq> []) \\<longrightarrow>\n                      last x < hd (concat xs)", "by (metis Compl_iff hd_concat insertI1 length_greater_0_conv length_pos_if_in_set list.sel(1) lists.cases nth_Cons_0)"], ["proof (state)\nthis:\n  x < concat xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n     \\<And>n. Suc n < length [] \\<Longrightarrow> [] ! n < [] ! Suc n;\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (concat [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> list.set xs \\<Longrightarrow>\n                            strict_sorted x;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> xs ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (concat xs);\n        \\<And>x.\n           x \\<in> list.set (a # xs) \\<Longrightarrow> strict_sorted x;\n        \\<And>n.\n           Suc n < length (a # xs) \\<Longrightarrow>\n           (a # xs) ! n < (a # xs) ! Suc n;\n        a # xs \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (concat (a # xs))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> xs ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (concat xs)\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (x # xs) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n  x < concat xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> xs ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (concat xs)\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (x # xs) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n  x < concat xs\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs))", "by (force simp: strict_sorted_append_iff)"], ["proof (state)\nthis:\n  strict_sorted (concat (x # xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n     \\<And>n. Suc n < length [] \\<Longrightarrow> [] ! n < [] ! Suc n;\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (concat [])", "qed auto"], ["", "subsection \\<open>Nash Williams for lists\\<close>"], ["", "subsubsection \\<open>Thin sets of lists\\<close>"], ["", "inductive initial_segment :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  where \"initial_segment xs (xs@ys)\""], ["", "definition thin :: \"'a list set \\<Rightarrow> bool\"\n  where \"thin A \\<equiv> \\<not> (\\<exists>x y. x \\<in> A \\<and> y \\<in> A \\<and> x \\<noteq> y \\<and> initial_segment x y)\""], ["", "lemma initial_segment_ne:\n  assumes \"initial_segment xs ys\" \"xs \\<noteq> []\"\n  shows \"ys \\<noteq> [] \\<and> hd ys = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<and> hd ys = hd xs", "using assms"], ["proof (prove)\nusing this:\n  initial_segment xs ys\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<and> hd ys = hd xs", "by (auto elim!: initial_segment.cases)"], ["", "lemma take_initial_segment:\n  assumes \"initial_segment xs ys\" \"k \\<le> length xs\"\n  shows \"take k xs = take k ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k xs = take k ys", "by (metis append_eq_conv_conj assms initial_segment.cases min_def take_take)"], ["", "lemma initial_segment_length_eq:\n  assumes \"initial_segment xs ys\" \"length xs = length ys\"\n  shows \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "using assms initial_segment.cases"], ["proof (prove)\nusing this:\n  initial_segment xs ys\n  length xs = length ys\n  \\<lbrakk>initial_segment ?a1.0 ?a2.0;\n   \\<And>xs ys.\n      \\<lbrakk>?a1.0 = xs; ?a2.0 = xs @ ys\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. xs = ys", "by fastforce"], ["", "lemma initial_segment_Nil [simp]: \"initial_segment [] ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial_segment [] ys", "by (simp add: initial_segment.simps)"], ["", "lemma initial_segment_Cons [simp]: \"initial_segment (x#xs) (y#ys) \\<longleftrightarrow> x=y \\<and> initial_segment xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial_segment (x # xs) (y # ys) = (x = y \\<and> initial_segment xs ys)", "by (metis append_Cons initial_segment.simps list.inject)"], ["", "lemma init_segment_iff_initial_segment:\n  assumes \"strict_sorted xs\" \"strict_sorted ys\"\n  shows \"init_segment (list.set xs) (list.set ys) \\<longleftrightarrow> initial_segment xs ys\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. init_segment (list.set xs) (list.set ys) = initial_segment xs ys", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. init_segment (list.set xs) (list.set ys) \\<Longrightarrow>\n    initial_segment xs ys\n 2. initial_segment xs ys \\<Longrightarrow>\n    init_segment (list.set xs) (list.set ys)", "assume ?lhs"], ["proof (state)\nthis:\n  init_segment (list.set xs) (list.set ys)\n\ngoal (2 subgoals):\n 1. init_segment (list.set xs) (list.set ys) \\<Longrightarrow>\n    initial_segment xs ys\n 2. initial_segment xs ys \\<Longrightarrow>\n    init_segment (list.set xs) (list.set ys)", "then"], ["proof (chain)\npicking this:\n  init_segment (list.set xs) (list.set ys)", "obtain S' where S': \"list.set ys = list.set xs \\<union> S'\" \"list.set xs \\<lless> S'\""], ["proof (prove)\nusing this:\n  init_segment (list.set xs) (list.set ys)\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>list.set ys = list.set xs \\<union> S';\n         list.set xs \\<lless> S'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: init_segment_def)"], ["proof (state)\nthis:\n  list.set ys = list.set xs \\<union> S'\n  list.set xs \\<lless> S'\n\ngoal (2 subgoals):\n 1. init_segment (list.set xs) (list.set ys) \\<Longrightarrow>\n    initial_segment xs ys\n 2. initial_segment xs ys \\<Longrightarrow>\n    init_segment (list.set xs) (list.set ys)", "then"], ["proof (chain)\npicking this:\n  list.set ys = list.set xs \\<union> S'\n  list.set xs \\<lless> S'", "have \"finite S'\""], ["proof (prove)\nusing this:\n  list.set ys = list.set xs \\<union> S'\n  list.set xs \\<lless> S'\n\ngoal (1 subgoal):\n 1. finite S'", "by (metis List.finite_set finite_Un)"], ["proof (state)\nthis:\n  finite S'\n\ngoal (2 subgoals):\n 1. init_segment (list.set xs) (list.set ys) \\<Longrightarrow>\n    initial_segment xs ys\n 2. initial_segment xs ys \\<Longrightarrow>\n    init_segment (list.set xs) (list.set ys)", "have \"ys = xs @ list_of S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = xs @ list_of S'", "using S' \\<open>strict_sorted xs\\<close>"], ["proof (prove)\nusing this:\n  list.set ys = list.set xs \\<union> S'\n  list.set xs \\<lless> S'\n  strict_sorted xs\n\ngoal (1 subgoal):\n 1. ys = xs @ list_of S'", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>list.set ys = list.set [] \\<union> S'; list.set [] \\<lless> S';\n     strict_sorted []\\<rbrakk>\n    \\<Longrightarrow> ys = [] @ list_of S'\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list.set ys = list.set xs \\<union> S';\n                 list.set xs \\<lless> S'; strict_sorted xs\\<rbrakk>\n                \\<Longrightarrow> ys = xs @ list_of S';\n        list.set ys = list.set (a # xs) \\<union> S';\n        list.set (a # xs) \\<lless> S'; strict_sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ys = (a # xs) @ list_of S'", "case Nil"], ["proof (state)\nthis:\n  list.set ys = list.set [] \\<union> S'\n  list.set [] \\<lless> S'\n  strict_sorted []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list.set ys = list.set [] \\<union> S'; list.set [] \\<lless> S';\n     strict_sorted []\\<rbrakk>\n    \\<Longrightarrow> ys = [] @ list_of S'\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list.set ys = list.set xs \\<union> S';\n                 list.set xs \\<lless> S'; strict_sorted xs\\<rbrakk>\n                \\<Longrightarrow> ys = xs @ list_of S';\n        list.set ys = list.set (a # xs) \\<union> S';\n        list.set (a # xs) \\<lless> S'; strict_sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ys = (a # xs) @ list_of S'", "with \\<open>strict_sorted ys\\<close>"], ["proof (chain)\npicking this:\n  strict_sorted ys\n  list.set ys = list.set [] \\<union> S'\n  list.set [] \\<lless> S'\n  strict_sorted []", "show ?case"], ["proof (prove)\nusing this:\n  strict_sorted ys\n  list.set ys = list.set [] \\<union> S'\n  list.set [] \\<lless> S'\n  strict_sorted []\n\ngoal (1 subgoal):\n 1. ys = [] @ list_of S'", "by auto"], ["proof (state)\nthis:\n  ys = [] @ list_of S'\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list.set ys = list.set xs \\<union> S';\n                 list.set xs \\<lless> S'; strict_sorted xs\\<rbrakk>\n                \\<Longrightarrow> ys = xs @ list_of S';\n        list.set ys = list.set (a # xs) \\<union> S';\n        list.set (a # xs) \\<lless> S'; strict_sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ys = (a # xs) @ list_of S'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list.set ys = list.set xs \\<union> S';\n                 list.set xs \\<lless> S'; strict_sorted xs\\<rbrakk>\n                \\<Longrightarrow> ys = xs @ list_of S';\n        list.set ys = list.set (a # xs) \\<union> S';\n        list.set (a # xs) \\<lless> S'; strict_sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ys = (a # xs) @ list_of S'", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>list.set ys = list.set xs \\<union> S'; list.set xs \\<lless> S';\n   strict_sorted xs\\<rbrakk>\n  \\<Longrightarrow> ys = xs @ list_of S'\n  list.set ys = list.set (a # xs) \\<union> S'\n  list.set (a # xs) \\<lless> S'\n  strict_sorted (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list.set ys = list.set xs \\<union> S';\n                 list.set xs \\<lless> S'; strict_sorted xs\\<rbrakk>\n                \\<Longrightarrow> ys = xs @ list_of S';\n        list.set ys = list.set (a # xs) \\<union> S';\n        list.set (a # xs) \\<lless> S'; strict_sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ys = (a # xs) @ list_of S'", "with \\<open>finite S'\\<close>"], ["proof (chain)\npicking this:\n  finite S'\n  \\<lbrakk>list.set ys = list.set xs \\<union> S'; list.set xs \\<lless> S';\n   strict_sorted xs\\<rbrakk>\n  \\<Longrightarrow> ys = xs @ list_of S'\n  list.set ys = list.set (a # xs) \\<union> S'\n  list.set (a # xs) \\<lless> S'\n  strict_sorted (a # xs)", "have \"ys = a # xs @ list_of S'\""], ["proof (prove)\nusing this:\n  finite S'\n  \\<lbrakk>list.set ys = list.set xs \\<union> S'; list.set xs \\<lless> S';\n   strict_sorted xs\\<rbrakk>\n  \\<Longrightarrow> ys = xs @ list_of S'\n  list.set ys = list.set (a # xs) \\<union> S'\n  list.set (a # xs) \\<lless> S'\n  strict_sorted (a # xs)\n\ngoal (1 subgoal):\n 1. ys = a # xs @ list_of S'", "by (metis List.finite_set \\<open>finite S'\\<close> append_Cons assms(2) sorted_list_of_set_Un sorted_list_of_set_set_of)"], ["proof (state)\nthis:\n  ys = a # xs @ list_of S'\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>list.set ys = list.set xs \\<union> S';\n                 list.set xs \\<lless> S'; strict_sorted xs\\<rbrakk>\n                \\<Longrightarrow> ys = xs @ list_of S';\n        list.set ys = list.set (a # xs) \\<union> S';\n        list.set (a # xs) \\<lless> S'; strict_sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ys = (a # xs) @ list_of S'", "then"], ["proof (chain)\npicking this:\n  ys = a # xs @ list_of S'", "show ?case"], ["proof (prove)\nusing this:\n  ys = a # xs @ list_of S'\n\ngoal (1 subgoal):\n 1. ys = (a # xs) @ list_of S'", "by (auto simp: Cons)"], ["proof (state)\nthis:\n  ys = (a # xs) @ list_of S'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ys = xs @ list_of S'\n\ngoal (2 subgoals):\n 1. init_segment (list.set xs) (list.set ys) \\<Longrightarrow>\n    initial_segment xs ys\n 2. initial_segment xs ys \\<Longrightarrow>\n    init_segment (list.set xs) (list.set ys)", "then"], ["proof (chain)\npicking this:\n  ys = xs @ list_of S'", "show ?rhs"], ["proof (prove)\nusing this:\n  ys = xs @ list_of S'\n\ngoal (1 subgoal):\n 1. initial_segment xs ys", "using initial_segment.intros"], ["proof (prove)\nusing this:\n  ys = xs @ list_of S'\n  initial_segment ?xs (?xs @ ?ys)\n\ngoal (1 subgoal):\n 1. initial_segment xs ys", "by blast"], ["proof (state)\nthis:\n  initial_segment xs ys\n\ngoal (1 subgoal):\n 1. initial_segment xs ys \\<Longrightarrow>\n    init_segment (list.set xs) (list.set ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. initial_segment xs ys \\<Longrightarrow>\n    init_segment (list.set xs) (list.set ys)", "assume ?rhs"], ["proof (state)\nthis:\n  initial_segment xs ys\n\ngoal (1 subgoal):\n 1. initial_segment xs ys \\<Longrightarrow>\n    init_segment (list.set xs) (list.set ys)", "then"], ["proof (chain)\npicking this:\n  initial_segment xs ys", "show ?lhs"], ["proof (prove)\nusing this:\n  initial_segment xs ys\n\ngoal (1 subgoal):\n 1. init_segment (list.set xs) (list.set ys)", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ysa.\n       ys = xs @ ysa \\<Longrightarrow>\n       init_segment (list.set xs) (list.set ys)", "case (1 ys)"], ["proof (state)\nthis:\n  ys = xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>ysa.\n       ys = xs @ ysa \\<Longrightarrow>\n       init_segment (list.set xs) (list.set ys)", "with assms(2)"], ["proof (chain)\npicking this:\n  strict_sorted ys\n  ys = xs @ ys", "show ?thesis"], ["proof (prove)\nusing this:\n  strict_sorted ys\n  ys = xs @ ys\n\ngoal (1 subgoal):\n 1. init_segment (list.set xs) (list.set ys)", "using sorted_list_of_set_imp_less_sets strict_sorted_imp_sorted"], ["proof (prove)\nusing this:\n  strict_sorted ys\n  ys = xs @ ys\n  \\<lbrakk>?xs < ?ys; sorted ?xs; sorted ?ys\\<rbrakk>\n  \\<Longrightarrow> list.set ?xs \\<lless> list.set ?ys\n  strict_sorted ?xs \\<Longrightarrow> sorted ?xs\n\ngoal (1 subgoal):\n 1. init_segment (list.set xs) (list.set ys)", "by (auto simp: init_segment_def strict_sorted_append_iff)"], ["proof (state)\nthis:\n  init_segment (list.set xs) (list.set ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  init_segment (list.set xs) (list.set ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Nash_Williams_WW:\n  fixes h :: \"nat list \\<Rightarrow> nat\"\n  assumes \"infinite M\" and h: \"h ` {l \\<in> A. List.set l \\<subseteq> M} \\<subseteq> {..<2}\" and \"thin A\" \"A \\<subseteq> WW\"\n  obtains i N where \"i < 2\" \"infinite N\" \"N \\<subseteq> M\" \"h ` {l \\<in> A. List.set l \\<subseteq> N} \\<subseteq> {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define AM where \"AM \\<equiv> {l \\<in> A. List.set l \\<subseteq> M}\""], ["proof (state)\nthis:\n  AM \\<equiv> {l \\<in> A. list.set l \\<subseteq> M}\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"thin_set (list.set ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thin_set (list.set ` A)", "using \\<open>thin A\\<close> \\<open>A \\<subseteq> WW\\<close>"], ["proof (prove)\nusing this:\n  thin A\n  A \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. thin_set (list.set ` A)", "unfolding thin_def thin_set_def WW_def"], ["proof (prove)\nusing this:\n  \\<nexists>x y.\n     x \\<in> A \\<and>\n     y \\<in> A \\<and> x \\<noteq> y \\<and> initial_segment x y\n  A \\<subseteq> {l. strict_sorted l}\n\ngoal (1 subgoal):\n 1. list.set ` A \\<subseteq> Collect finite \\<and>\n    (\\<forall>S\\<in>list.set ` A.\n        \\<forall>T\\<in>list.set ` A.\n           init_segment S T \\<longrightarrow> S = T)", "by (auto simp: subset_iff init_segment_iff_initial_segment)"], ["proof (state)\nthis:\n  thin_set (list.set ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  thin_set (list.set ` A)", "have \"thin_set (list.set ` AM)\""], ["proof (prove)\nusing this:\n  thin_set (list.set ` A)\n\ngoal (1 subgoal):\n 1. thin_set (list.set ` AM)", "by (simp add: AM_def image_subset_iff thin_set_def)"], ["proof (state)\nthis:\n  thin_set (list.set ` AM)\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  thin_set (list.set ` AM)", "have \"Ramsey (list.set ` AM) 2\""], ["proof (prove)\nusing this:\n  thin_set (list.set ` AM)\n\ngoal (1 subgoal):\n 1. Ramsey (list.set ` AM) 2", "using Nash_Williams_2"], ["proof (prove)\nusing this:\n  thin_set (list.set ` AM)\n  thin_set ?\\<F> \\<Longrightarrow> Ramsey ?\\<F> 2\n\ngoal (1 subgoal):\n 1. Ramsey (list.set ` AM) 2", "by metis"], ["proof (state)\nthis:\n  Ramsey (list.set ` AM) 2\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  Ramsey (list.set ` AM) 2\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(h \\<circ> list_of) \\<in> list.set ` AM \\<rightarrow> {..<2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<circ> list_of \\<in> list.set ` AM \\<rightarrow> {..<2}", "unfolding AM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<circ> list_of\n    \\<in> list.set ` {l \\<in> A. list.set l \\<subseteq> M} \\<rightarrow>\n          {..<2}", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> A; list.set xa \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> h (list_of (list.set xa)) < 2", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> A; list.set xa \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> h (list_of (list.set xa)) < 2", "assume \"l \\<in> A\" \"list.set l \\<subseteq> M\""], ["proof (state)\nthis:\n  l \\<in> A\n  list.set l \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> A; list.set xa \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> h (list_of (list.set xa)) < 2", "then"], ["proof (chain)\npicking this:\n  l \\<in> A\n  list.set l \\<subseteq> M", "have \"strict_sorted l\""], ["proof (prove)\nusing this:\n  l \\<in> A\n  list.set l \\<subseteq> M\n\ngoal (1 subgoal):\n 1. strict_sorted l", "using WW_def \\<open>A \\<subseteq> WW\\<close>"], ["proof (prove)\nusing this:\n  l \\<in> A\n  list.set l \\<subseteq> M\n  WW \\<equiv> {l. strict_sorted l}\n  A \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. strict_sorted l", "by blast"], ["proof (state)\nthis:\n  strict_sorted l\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> A; list.set xa \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> h (list_of (list.set xa)) < 2", "then"], ["proof (chain)\npicking this:\n  strict_sorted l", "show \"h (list_of (list.set l)) < 2\""], ["proof (prove)\nusing this:\n  strict_sorted l\n\ngoal (1 subgoal):\n 1. h (list_of (list.set l)) < 2", "using h \\<open>l \\<in> A\\<close> \\<open>list.set l \\<subseteq> M\\<close>"], ["proof (prove)\nusing this:\n  strict_sorted l\n  h ` {l \\<in> A. list.set l \\<subseteq> M} \\<subseteq> {..<2}\n  l \\<in> A\n  list.set l \\<subseteq> M\n\ngoal (1 subgoal):\n 1. h (list_of (list.set l)) < 2", "by auto"], ["proof (state)\nthis:\n  h (list_of (list.set l)) < 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<circ> list_of \\<in> list.set ` AM \\<rightarrow> {..<2}\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  Ramsey (list.set ` AM) 2\n  h \\<circ> list_of \\<in> list.set ` AM \\<rightarrow> {..<2}", "obtain N i where N: \"N \\<subseteq> M\" \"infinite N\" \"i<2\"\n    and \"\\<And>j. \\<lbrakk>j<2; i\\<noteq>j\\<rbrakk> \\<Longrightarrow> (h \\<circ> list_of) -` {j} \\<inter> (list.set ` AM) \\<inter> Pow N = {}\""], ["proof (prove)\nusing this:\n  Ramsey (list.set ` AM) 2\n  h \\<circ> list_of \\<in> list.set ` AM \\<rightarrow> {..<2}\n\ngoal (1 subgoal):\n 1. (\\<And>N i.\n        \\<lbrakk>N \\<subseteq> M; infinite N; i < 2;\n         \\<And>j.\n            \\<lbrakk>j < 2; i \\<noteq> j\\<rbrakk>\n            \\<Longrightarrow> (h \\<circ> list_of) -` {j} \\<inter>\n                              list.set ` AM \\<inter>\n                              Pow N =\n                              {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Ramsey_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>list.set ` AM \\<rightarrow> {..<2}.\n     \\<forall>M.\n        infinite M \\<longrightarrow>\n        (\\<exists>N i.\n            N \\<subseteq> M \\<and>\n            infinite N \\<and>\n            i < 2 \\<and>\n            (\\<forall>j<2.\n                j \\<noteq> i \\<longrightarrow>\n                f -` {j} \\<inter> list.set ` AM \\<inter> Pow N = {}))\n  h \\<circ> list_of \\<in> list.set ` AM \\<rightarrow> {..<2}\n\ngoal (1 subgoal):\n 1. (\\<And>N i.\n        \\<lbrakk>N \\<subseteq> M; infinite N; i < 2;\n         \\<And>j.\n            \\<lbrakk>j < 2; i \\<noteq> j\\<rbrakk>\n            \\<Longrightarrow> (h \\<circ> list_of) -` {j} \\<inter>\n                              list.set ` AM \\<inter>\n                              Pow N =\n                              {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>infinite M\\<close>)"], ["proof (state)\nthis:\n  N \\<subseteq> M\n  infinite N\n  i < 2\n  \\<lbrakk>?j < 2; i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> (h \\<circ> list_of) -` {?j} \\<inter>\n                    list.set ` AM \\<inter>\n                    Pow N =\n                    {}\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  N \\<subseteq> M\n  infinite N\n  i < 2\n  \\<lbrakk>?j < 2; i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> (h \\<circ> list_of) -` {?j} \\<inter>\n                    list.set ` AM \\<inter>\n                    Pow N =\n                    {}", "have N_disjoint: \"(h \\<circ> list_of) -` {1-i} \\<inter> (list.set ` AM) \\<inter> Pow N = {}\""], ["proof (prove)\nusing this:\n  N \\<subseteq> M\n  infinite N\n  i < 2\n  \\<lbrakk>?j < 2; i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> (h \\<circ> list_of) -` {?j} \\<inter>\n                    list.set ` AM \\<inter>\n                    Pow N =\n                    {}\n\ngoal (1 subgoal):\n 1. (h \\<circ> list_of) -` {1 - i} \\<inter> list.set ` AM \\<inter> Pow N =\n    {}", "by (metis One_nat_def diff_less_Suc not_less_eq numeral_2_eq_2 zero_less_diff)"], ["proof (state)\nthis:\n  (h \\<circ> list_of) -` {1 - i} \\<inter> list.set ` AM \\<inter> Pow N = {}\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "assume \"l \\<in> A\" and \"list.set l \\<subseteq> N\""], ["proof (state)\nthis:\n  l \\<in> A\n  list.set l \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "then"], ["proof (chain)\npicking this:\n  l \\<in> A\n  list.set l \\<subseteq> N", "have \"h l < 2\""], ["proof (prove)\nusing this:\n  l \\<in> A\n  list.set l \\<subseteq> N\n\ngoal (1 subgoal):\n 1. h l < 2", "using h \\<open>N \\<subseteq> M\\<close>"], ["proof (prove)\nusing this:\n  l \\<in> A\n  list.set l \\<subseteq> N\n  h ` {l \\<in> A. list.set l \\<subseteq> M} \\<subseteq> {..<2}\n  N \\<subseteq> M\n\ngoal (1 subgoal):\n 1. h l < 2", "by force"], ["proof (state)\nthis:\n  h l < 2\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "with \\<open>i<2\\<close>"], ["proof (chain)\npicking this:\n  i < 2\n  h l < 2", "have \"h l \\<noteq> Suc 0 - i \\<Longrightarrow> h l = i\""], ["proof (prove)\nusing this:\n  i < 2\n  h l < 2\n\ngoal (1 subgoal):\n 1. h l \\<noteq> Suc 0 - i \\<Longrightarrow> h l = i", "by (auto simp: eval_nat_numeral less_Suc_eq)"], ["proof (state)\nthis:\n  h l \\<noteq> Suc 0 - i \\<Longrightarrow> h l = i\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "moreover"], ["proof (state)\nthis:\n  h l \\<noteq> Suc 0 - i \\<Longrightarrow> h l = i\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "have \"strict_sorted l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted l", "using \\<open>A \\<subseteq> WW\\<close> \\<open>l \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  A \\<subseteq> WW\n  l \\<in> A\n\ngoal (1 subgoal):\n 1. strict_sorted l", "unfolding WW_def"], ["proof (prove)\nusing this:\n  A \\<subseteq> {l. strict_sorted l}\n  l \\<in> A\n\ngoal (1 subgoal):\n 1. strict_sorted l", "by blast"], ["proof (state)\nthis:\n  strict_sorted l\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "moreover"], ["proof (state)\nthis:\n  strict_sorted l\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "have \"h (list_of (list.set l)) = 1 - i \\<longrightarrow> \\<not> (list.set l \\<subseteq> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (list_of (list.set l)) = 1 - i \\<longrightarrow>\n    \\<not> list.set l \\<subseteq> N", "using N_disjoint \\<open>N \\<subseteq> M\\<close> \\<open>l \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  (h \\<circ> list_of) -` {1 - i} \\<inter> list.set ` AM \\<inter> Pow N = {}\n  N \\<subseteq> M\n  l \\<in> A\n\ngoal (1 subgoal):\n 1. h (list_of (list.set l)) = 1 - i \\<longrightarrow>\n    \\<not> list.set l \\<subseteq> N", "by (auto simp: AM_def)"], ["proof (state)\nthis:\n  h (list_of (list.set l)) = 1 - i \\<longrightarrow>\n  \\<not> list.set l \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>h xa \\<notin> {}; xa \\<in> A;\n        list.set xa \\<subseteq> N\\<rbrakk>\n       \\<Longrightarrow> h xa = i", "ultimately"], ["proof (chain)\npicking this:\n  h l \\<noteq> Suc 0 - i \\<Longrightarrow> h l = i\n  strict_sorted l\n  h (list_of (list.set l)) = 1 - i \\<longrightarrow>\n  \\<not> list.set l \\<subseteq> N", "show \"h l = i\""], ["proof (prove)\nusing this:\n  h l \\<noteq> Suc 0 - i \\<Longrightarrow> h l = i\n  strict_sorted l\n  h (list_of (list.set l)) = 1 - i \\<longrightarrow>\n  \\<not> list.set l \\<subseteq> N\n\ngoal (1 subgoal):\n 1. h l = i", "using N \\<open>N \\<subseteq> M\\<close> \\<open>l \\<in> A\\<close> \\<open>list.set l \\<subseteq> N\\<close>"], ["proof (prove)\nusing this:\n  h l \\<noteq> Suc 0 - i \\<Longrightarrow> h l = i\n  strict_sorted l\n  h (list_of (list.set l)) = 1 - i \\<longrightarrow>\n  \\<not> list.set l \\<subseteq> N\n  N \\<subseteq> M\n  infinite N\n  i < 2\n  N \\<subseteq> M\n  l \\<in> A\n  list.set l \\<subseteq> N\n\ngoal (1 subgoal):\n 1. h l = i", "by (auto simp: vimage_def set_eq_iff AM_def WW_def subset_iff)"], ["proof (state)\nthis:\n  h l = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. (\\<And>i N.\n        \\<lbrakk>i < 2; infinite N; N \\<subseteq> M;\n         h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}", "show thesis"], ["proof (prove)\nusing this:\n  h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. thesis", "using that \\<open>i<2\\<close> N"], ["proof (prove)\nusing this:\n  h ` {l \\<in> A. list.set l \\<subseteq> N} \\<subseteq> {i}\n  \\<lbrakk>?i < 2; infinite ?N; ?N \\<subseteq> M;\n   h ` {l \\<in> A. list.set l \\<subseteq> ?N} \\<subseteq> {?i}\\<rbrakk>\n  \\<Longrightarrow> thesis\n  i < 2\n  N \\<subseteq> M\n  infinite N\n  i < 2\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Specialised functions on lists\\<close>"], ["", "lemma mem_lists_non_Nil: \"xss \\<in> lists (- {[]}) \\<longleftrightarrow> (\\<forall>x \\<in> list.set xss. x \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xss \\<in> lists (- {[]})) =\n    (\\<forall>x\\<in>list.set xss. x \\<noteq> [])", "by auto"], ["", "fun acc_lengths :: \"nat \\<Rightarrow> 'a list list \\<Rightarrow> nat list\"\n  where \"acc_lengths acc [] = []\"\n      | \"acc_lengths acc (l#ls) = (acc + length l) # acc_lengths (acc + length l) ls\""], ["", "lemma length_acc_lengths [simp]: \"length (acc_lengths acc ls) = length ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (acc_lengths acc ls) = length ls", "by (induction ls arbitrary: acc) auto"], ["", "lemma acc_lengths_eq_Nil_iff [simp]: \"acc_lengths acc ls = [] \\<longleftrightarrow> ls = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (acc_lengths acc ls = []) = (ls = [])", "by (metis length_0_conv length_acc_lengths)"], ["", "lemma set_acc_lengths:\n  assumes \"ls \\<in> lists (- {[]})\" shows \"list.set (acc_lengths acc ls) \\<subseteq> {acc<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (acc_lengths acc ls) \\<subseteq> {acc<..}", "using assms"], ["proof (prove)\nusing this:\n  ls \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths acc ls) \\<subseteq> {acc<..}", "by (induction ls rule: acc_lengths.induct) fastforce+"], ["", "text \\<open>Useful because @{text acc_lengths.simps} will later be deleted from the simpset.\\<close>"], ["", "lemma hd_acc_lengths [simp]: \"hd (acc_lengths acc (l#ls)) = acc + length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (acc_lengths acc (l # ls)) = acc + length l", "by simp"], ["", "lemma last_acc_lengths [simp]:\n  \"ls \\<noteq> [] \\<Longrightarrow> last (acc_lengths acc ls) = acc + sum_list (map length ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<noteq> [] \\<Longrightarrow>\n    last (acc_lengths acc ls) = acc + sum_list (map length ls)", "by (induction acc ls rule: acc_lengths.induct) auto"], ["", "lemma nth_acc_lengths [simp]:\n  \"\\<lbrakk>ls \\<noteq> []; k < length ls\\<rbrakk> \\<Longrightarrow> acc_lengths acc ls ! k = acc + sum_list (map length (take (Suc k) ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<noteq> []; k < length ls\\<rbrakk>\n    \\<Longrightarrow> acc_lengths acc ls ! k =\n                      acc + sum_list (map length (take (Suc k) ls))", "by (induction acc ls arbitrary: k rule: acc_lengths.induct) (fastforce simp: less_Suc_eq nth_Cons')+"], ["", "lemma acc_lengths_plus: \"acc_lengths (m+n) as = map ((+)m) (acc_lengths n as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc_lengths (m + n) as = map ((+) m) (acc_lengths n as)", "by (induction n as arbitrary: m rule: acc_lengths.induct) (auto simp: add.assoc)"], ["", "lemma acc_lengths_shift: \"NO_MATCH 0 acc \\<Longrightarrow> acc_lengths acc as = map ((+)acc) (acc_lengths 0 as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH (0::'a) acc \\<Longrightarrow>\n    acc_lengths acc as = map ((+) acc) (acc_lengths 0 as)", "by (metis acc_lengths_plus add.comm_neutral)"], ["", "lemma length_concat_acc_lengths:\n  \"ls \\<noteq> [] \\<Longrightarrow> k + length (concat ls) \\<in> list.set (acc_lengths k ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<noteq> [] \\<Longrightarrow>\n    k + length (concat ls) \\<in> list.set (acc_lengths k ls)", "by (metis acc_lengths_eq_Nil_iff last_acc_lengths last_in_set length_concat)"], ["", "lemma strict_sorted_acc_lengths:\n  assumes \"ls \\<in> lists (- {[]})\" shows \"strict_sorted (acc_lengths acc ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (acc_lengths acc ls)", "using assms"], ["proof (prove)\nusing this:\n  ls \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (acc_lengths acc ls)", "proof (induction ls rule: acc_lengths.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>acc.\n       [] \\<in> lists (- {[]}) \\<Longrightarrow>\n       strict_sorted (acc_lengths acc [])\n 2. \\<And>acc l ls.\n       \\<lbrakk>ls \\<in> lists (- {[]}) \\<Longrightarrow>\n                strict_sorted (acc_lengths (acc + length l) ls);\n        l # ls \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (acc_lengths acc (l # ls))", "case (2 acc l ls)"], ["proof (state)\nthis:\n  ls \\<in> lists (- {[]}) \\<Longrightarrow>\n  strict_sorted (acc_lengths (acc + length l) ls)\n  l # ls \\<in> lists (- {[]})\n\ngoal (2 subgoals):\n 1. \\<And>acc.\n       [] \\<in> lists (- {[]}) \\<Longrightarrow>\n       strict_sorted (acc_lengths acc [])\n 2. \\<And>acc l ls.\n       \\<lbrakk>ls \\<in> lists (- {[]}) \\<Longrightarrow>\n                strict_sorted (acc_lengths (acc + length l) ls);\n        l # ls \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (acc_lengths acc (l # ls))", "then"], ["proof (chain)\npicking this:\n  ls \\<in> lists (- {[]}) \\<Longrightarrow>\n  strict_sorted (acc_lengths (acc + length l) ls)\n  l # ls \\<in> lists (- {[]})", "have \"strict_sorted (acc_lengths (acc + length l) ls)\""], ["proof (prove)\nusing this:\n  ls \\<in> lists (- {[]}) \\<Longrightarrow>\n  strict_sorted (acc_lengths (acc + length l) ls)\n  l # ls \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (acc_lengths (acc + length l) ls)", "using \"2\""], ["proof (prove)\nusing this:\n  ls \\<in> lists (- {[]}) \\<Longrightarrow>\n  strict_sorted (acc_lengths (acc + length l) ls)\n  l # ls \\<in> lists (- {[]})\n  ls \\<in> lists (- {[]}) \\<Longrightarrow>\n  strict_sorted (acc_lengths (acc + length l) ls)\n  l # ls \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (acc_lengths (acc + length l) ls)", "by auto"], ["proof (state)\nthis:\n  strict_sorted (acc_lengths (acc + length l) ls)\n\ngoal (2 subgoals):\n 1. \\<And>acc.\n       [] \\<in> lists (- {[]}) \\<Longrightarrow>\n       strict_sorted (acc_lengths acc [])\n 2. \\<And>acc l ls.\n       \\<lbrakk>ls \\<in> lists (- {[]}) \\<Longrightarrow>\n                strict_sorted (acc_lengths (acc + length l) ls);\n        l # ls \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (acc_lengths acc (l # ls))", "then"], ["proof (chain)\npicking this:\n  strict_sorted (acc_lengths (acc + length l) ls)", "show ?case"], ["proof (prove)\nusing this:\n  strict_sorted (acc_lengths (acc + length l) ls)\n\ngoal (1 subgoal):\n 1. strict_sorted (acc_lengths acc (l # ls))", "using set_acc_lengths \"2.prems\""], ["proof (prove)\nusing this:\n  strict_sorted (acc_lengths (acc + length l) ls)\n  ?ls \\<in> lists (- {[]}) \\<Longrightarrow>\n  list.set (acc_lengths ?acc ?ls) \\<subseteq> {?acc<..}\n  l # ls \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (acc_lengths acc (l # ls))", "by auto"], ["proof (state)\nthis:\n  strict_sorted (acc_lengths acc (l # ls))\n\ngoal (1 subgoal):\n 1. \\<And>acc.\n       [] \\<in> lists (- {[]}) \\<Longrightarrow>\n       strict_sorted (acc_lengths acc [])", "qed auto"], ["", "lemma acc_lengths_append:\n  \"acc_lengths acc (xs @ ys)\n   = acc_lengths acc xs @ acc_lengths (acc + sum_list (map length xs)) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc_lengths acc (xs @ ys) =\n    acc_lengths acc xs @ acc_lengths (acc + sum_list (map length xs)) ys", "by (induction acc xs rule: acc_lengths.induct) (auto simp: add.assoc)"], ["", "declare acc_lengths.simps [simp del]"], ["", "lemma length_concat_ge:\n  assumes \"as \\<in> lists (- {[]})\"\n  shows \"length (concat as) \\<ge> length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as \\<le> length (concat as)", "using assms"], ["proof (prove)\nusing this:\n  as \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. length as \\<le> length (concat as)", "proof (induction as)"], ["proof (state)\ngoal (2 subgoals):\n 1. length [] \\<le> length (concat [])\n 2. \\<And>a l.\n       \\<lbrakk>a \\<in> - {[]}; l \\<in> lists (- {[]});\n        length l \\<le> length (concat l)\\<rbrakk>\n       \\<Longrightarrow> length (a # l) \\<le> length (concat (a # l))", "case (Cons a as)"], ["proof (state)\nthis:\n  a \\<in> - {[]}\n  as \\<in> lists (- {[]})\n  length as \\<le> length (concat as)\n\ngoal (2 subgoals):\n 1. length [] \\<le> length (concat [])\n 2. \\<And>a l.\n       \\<lbrakk>a \\<in> - {[]}; l \\<in> lists (- {[]});\n        length l \\<le> length (concat l)\\<rbrakk>\n       \\<Longrightarrow> length (a # l) \\<le> length (concat (a # l))", "then"], ["proof (chain)\npicking this:\n  a \\<in> - {[]}\n  as \\<in> lists (- {[]})\n  length as \\<le> length (concat as)", "have \"length a \\<ge> Suc 0\" \"\\<And>l. l \\<in> list.set as \\<Longrightarrow> length l \\<ge> Suc 0\""], ["proof (prove)\nusing this:\n  a \\<in> - {[]}\n  as \\<in> lists (- {[]})\n  length as \\<le> length (concat as)\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> length a &&&\n    (\\<And>l. l \\<in> list.set as \\<Longrightarrow> Suc 0 \\<le> length l)", "by (auto simp: Suc_leI)"], ["proof (state)\nthis:\n  Suc 0 \\<le> length a\n  ?l \\<in> list.set as \\<Longrightarrow> Suc 0 \\<le> length ?l\n\ngoal (2 subgoals):\n 1. length [] \\<le> length (concat [])\n 2. \\<And>a l.\n       \\<lbrakk>a \\<in> - {[]}; l \\<in> lists (- {[]});\n        length l \\<le> length (concat l)\\<rbrakk>\n       \\<Longrightarrow> length (a # l) \\<le> length (concat (a # l))", "then"], ["proof (chain)\npicking this:\n  Suc 0 \\<le> length a\n  ?l \\<in> list.set as \\<Longrightarrow> Suc 0 \\<le> length ?l", "show ?case"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> length a\n  ?l \\<in> list.set as \\<Longrightarrow> Suc 0 \\<le> length ?l\n\ngoal (1 subgoal):\n 1. length (a # as) \\<le> length (concat (a # as))", "using Cons.IH"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> length a\n  ?l \\<in> list.set as \\<Longrightarrow> Suc 0 \\<le> length ?l\n  length as \\<le> length (concat as)\n\ngoal (1 subgoal):\n 1. length (a # as) \\<le> length (concat (a # as))", "by force"], ["proof (state)\nthis:\n  length (a # as) \\<le> length (concat (a # as))\n\ngoal (1 subgoal):\n 1. length [] \\<le> length (concat [])", "qed auto"], ["", "fun interact :: \"'a list list \\<Rightarrow> 'a list list \\<Rightarrow> 'a list\"\n  where\n  \"interact [] ys = concat ys\"\n| \"interact xs [] = concat xs\"\n| \"interact (x#xs) (y#ys) = x @ y @ interact xs ys\""], ["", "lemma (in monoid_add) length_interact:\n  \"length (interact xs ys) = sum_list (map length xs) + sum_list (map length ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (interact xs ys) =\n    sum_list (map length xs) + sum_list (map length ys)", "by (induction rule: interact.induct) (auto simp: length_concat)"], ["", "lemma length_interact_ge:\n  assumes \"xs \\<in> lists (- {[]})\" \"ys \\<in> lists (- {[]})\"\n  shows \"length (interact xs ys) \\<ge> length xs + length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs + length ys \\<le> length (interact xs ys)", "by (metis mem_lists_non_Nil add_mono assms length_concat length_concat_ge length_interact)"], ["", "lemma set_interact [simp]:\n  shows \"list.set (interact xs ys) = list.set (concat xs) \\<union> list.set (concat ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (interact xs ys) =\n    list.set (concat xs) \\<union> list.set (concat ys)", "by (induction rule: interact.induct) auto"], ["", "lemma interact_eq_Nil_iff [simp]:\n  assumes \"xs \\<in> lists (- {[]})\" \"ys \\<in> lists (- {[]})\"\n  shows \"interact xs ys = [] \\<longleftrightarrow> xs=[] \\<and> ys=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (interact xs ys = []) = (xs = [] \\<and> ys = [])", "using length_interact_ge [OF assms]"], ["proof (prove)\nusing this:\n  length xs + length ys \\<le> length (interact xs ys)\n\ngoal (1 subgoal):\n 1. (interact xs ys = []) = (xs = [] \\<and> ys = [])", "by fastforce"], ["", "lemma interact_sing [simp]: \"interact [x] ys = x @ concat ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interact [x] ys = x @ concat ys", "by (metis (no_types) concat.simps(2) interact.simps neq_Nil_conv)"], ["", "lemma hd_interact: \"\\<lbrakk>xs \\<noteq> []; hd xs \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd (interact xs ys) = hd (hd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; hd xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd (interact xs ys) = hd (hd xs)", "by (metis concat.simps(2) hd_append2 interact.simps(2) interact.simps(3) list.exhaust list.sel(1))"], ["", "lemma acc_lengths_concat_injective:\n  assumes \"concat as' = concat as\" \"acc_lengths n as' = acc_lengths n as\"\n  shows \"as' = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as' = as", "using assms"], ["proof (prove)\nusing this:\n  concat as' = concat as\n  acc_lengths n as' = acc_lengths n as\n\ngoal (1 subgoal):\n 1. as' = as", "proof (induction as arbitrary: n as')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n as'.\n       \\<lbrakk>concat as' = concat [];\n        acc_lengths n as' = acc_lengths n []\\<rbrakk>\n       \\<Longrightarrow> as' = []\n 2. \\<And>a as n as'.\n       \\<lbrakk>\\<And>n as'.\n                   \\<lbrakk>concat as' = concat as;\n                    acc_lengths n as' = acc_lengths n as\\<rbrakk>\n                   \\<Longrightarrow> as' = as;\n        concat as' = concat (a # as);\n        acc_lengths n as' = acc_lengths n (a # as)\\<rbrakk>\n       \\<Longrightarrow> as' = a # as", "case Nil"], ["proof (state)\nthis:\n  concat as' = concat []\n  acc_lengths n as' = acc_lengths n []\n\ngoal (2 subgoals):\n 1. \\<And>n as'.\n       \\<lbrakk>concat as' = concat [];\n        acc_lengths n as' = acc_lengths n []\\<rbrakk>\n       \\<Longrightarrow> as' = []\n 2. \\<And>a as n as'.\n       \\<lbrakk>\\<And>n as'.\n                   \\<lbrakk>concat as' = concat as;\n                    acc_lengths n as' = acc_lengths n as\\<rbrakk>\n                   \\<Longrightarrow> as' = as;\n        concat as' = concat (a # as);\n        acc_lengths n as' = acc_lengths n (a # as)\\<rbrakk>\n       \\<Longrightarrow> as' = a # as", "then"], ["proof (chain)\npicking this:\n  concat as' = concat []\n  acc_lengths n as' = acc_lengths n []", "show ?case"], ["proof (prove)\nusing this:\n  concat as' = concat []\n  acc_lengths n as' = acc_lengths n []\n\ngoal (1 subgoal):\n 1. as' = []", "by (metis acc_lengths_eq_Nil_iff)"], ["proof (state)\nthis:\n  as' = []\n\ngoal (1 subgoal):\n 1. \\<And>a as n as'.\n       \\<lbrakk>\\<And>n as'.\n                   \\<lbrakk>concat as' = concat as;\n                    acc_lengths n as' = acc_lengths n as\\<rbrakk>\n                   \\<Longrightarrow> as' = as;\n        concat as' = concat (a # as);\n        acc_lengths n as' = acc_lengths n (a # as)\\<rbrakk>\n       \\<Longrightarrow> as' = a # as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as n as'.\n       \\<lbrakk>\\<And>n as'.\n                   \\<lbrakk>concat as' = concat as;\n                    acc_lengths n as' = acc_lengths n as\\<rbrakk>\n                   \\<Longrightarrow> as' = as;\n        concat as' = concat (a # as);\n        acc_lengths n as' = acc_lengths n (a # as)\\<rbrakk>\n       \\<Longrightarrow> as' = a # as", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>concat ?as' = concat as;\n   acc_lengths ?n ?as' = acc_lengths ?n as\\<rbrakk>\n  \\<Longrightarrow> ?as' = as\n  concat as' = concat (a # as)\n  acc_lengths n as' = acc_lengths n (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>a as n as'.\n       \\<lbrakk>\\<And>n as'.\n                   \\<lbrakk>concat as' = concat as;\n                    acc_lengths n as' = acc_lengths n as\\<rbrakk>\n                   \\<Longrightarrow> as' = as;\n        concat as' = concat (a # as);\n        acc_lengths n as' = acc_lengths n (a # as)\\<rbrakk>\n       \\<Longrightarrow> as' = a # as", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>concat ?as' = concat as;\n   acc_lengths ?n ?as' = acc_lengths ?n as\\<rbrakk>\n  \\<Longrightarrow> ?as' = as\n  concat as' = concat (a # as)\n  acc_lengths n as' = acc_lengths n (a # as)", "obtain a' bs where \"as' = a'#bs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>concat ?as' = concat as;\n   acc_lengths ?n ?as' = acc_lengths ?n as\\<rbrakk>\n  \\<Longrightarrow> ?as' = as\n  concat as' = concat (a # as)\n  acc_lengths n as' = acc_lengths n (a # as)\n\ngoal (1 subgoal):\n 1. (\\<And>a' bs. as' = a' # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv length_acc_lengths)"], ["proof (state)\nthis:\n  as' = a' # bs\n\ngoal (1 subgoal):\n 1. \\<And>a as n as'.\n       \\<lbrakk>\\<And>n as'.\n                   \\<lbrakk>concat as' = concat as;\n                    acc_lengths n as' = acc_lengths n as\\<rbrakk>\n                   \\<Longrightarrow> as' = as;\n        concat as' = concat (a # as);\n        acc_lengths n as' = acc_lengths n (a # as)\\<rbrakk>\n       \\<Longrightarrow> as' = a # as", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>concat ?as' = concat as;\n   acc_lengths ?n ?as' = acc_lengths ?n as\\<rbrakk>\n  \\<Longrightarrow> ?as' = as\n  concat as' = concat (a # as)\n  acc_lengths n as' = acc_lengths n (a # as)\n  as' = a' # bs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>concat ?as' = concat as;\n   acc_lengths ?n ?as' = acc_lengths ?n as\\<rbrakk>\n  \\<Longrightarrow> ?as' = as\n  concat as' = concat (a # as)\n  acc_lengths n as' = acc_lengths n (a # as)\n  as' = a' # bs\n\ngoal (1 subgoal):\n 1. as' = a # as", "by (simp add: acc_lengths.simps)"], ["proof (state)\nthis:\n  as' = a # as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acc_lengths_interact_injective:\n  assumes \"interact as' bs' = interact as bs\" \"acc_lengths a as' = acc_lengths a as\" \"acc_lengths b bs' = acc_lengths b bs\"\n  shows \"as' = as \\<and> bs' = bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as' = as \\<and> bs' = bs", "using assms"], ["proof (prove)\nusing this:\n  interact as' bs' = interact as bs\n  acc_lengths a as' = acc_lengths a as\n  acc_lengths b bs' = acc_lengths b bs\n\ngoal (1 subgoal):\n 1. as' = as \\<and> bs' = bs", "proof (induction as bs arbitrary: a b as' bs' rule: interact.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact [] ys;\n        acc_lengths a as' = acc_lengths a [];\n        acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n       \\<Longrightarrow> as' = [] \\<and> bs' = ys\n 2. \\<And>v va a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact (v # va) [];\n        acc_lengths a as' = acc_lengths a (v # va);\n        acc_lengths b bs' = acc_lengths b []\\<rbrakk>\n       \\<Longrightarrow> as' = v # va \\<and> bs' = []\n 3. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "case (1 cs)"], ["proof (state)\nthis:\n  interact as' bs' = interact [] cs\n  acc_lengths a as' = acc_lengths a []\n  acc_lengths b bs' = acc_lengths b cs\n\ngoal (3 subgoals):\n 1. \\<And>ys a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact [] ys;\n        acc_lengths a as' = acc_lengths a [];\n        acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n       \\<Longrightarrow> as' = [] \\<and> bs' = ys\n 2. \\<And>v va a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact (v # va) [];\n        acc_lengths a as' = acc_lengths a (v # va);\n        acc_lengths b bs' = acc_lengths b []\\<rbrakk>\n       \\<Longrightarrow> as' = v # va \\<and> bs' = []\n 3. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "then"], ["proof (chain)\npicking this:\n  interact as' bs' = interact [] cs\n  acc_lengths a as' = acc_lengths a []\n  acc_lengths b bs' = acc_lengths b cs", "have \"as' = []\""], ["proof (prove)\nusing this:\n  interact as' bs' = interact [] cs\n  acc_lengths a as' = acc_lengths a []\n  acc_lengths b bs' = acc_lengths b cs\n\ngoal (1 subgoal):\n 1. as' = []", "by (metis acc_lengths_eq_Nil_iff)"], ["proof (state)\nthis:\n  as' = []\n\ngoal (3 subgoals):\n 1. \\<And>ys a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact [] ys;\n        acc_lengths a as' = acc_lengths a [];\n        acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n       \\<Longrightarrow> as' = [] \\<and> bs' = ys\n 2. \\<And>v va a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact (v # va) [];\n        acc_lengths a as' = acc_lengths a (v # va);\n        acc_lengths b bs' = acc_lengths b []\\<rbrakk>\n       \\<Longrightarrow> as' = v # va \\<and> bs' = []\n 3. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "with 1"], ["proof (chain)\npicking this:\n  interact as' bs' = interact [] cs\n  acc_lengths a as' = acc_lengths a []\n  acc_lengths b bs' = acc_lengths b cs\n  as' = []", "show ?case"], ["proof (prove)\nusing this:\n  interact as' bs' = interact [] cs\n  acc_lengths a as' = acc_lengths a []\n  acc_lengths b bs' = acc_lengths b cs\n  as' = []\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> bs' = cs", "using acc_lengths_concat_injective"], ["proof (prove)\nusing this:\n  interact as' bs' = interact [] cs\n  acc_lengths a as' = acc_lengths a []\n  acc_lengths b bs' = acc_lengths b cs\n  as' = []\n  \\<lbrakk>concat ?as' = concat ?as;\n   acc_lengths ?n ?as' = acc_lengths ?n ?as\\<rbrakk>\n  \\<Longrightarrow> ?as' = ?as\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> bs' = cs", "by auto"], ["proof (state)\nthis:\n  as' = [] \\<and> bs' = cs\n\ngoal (2 subgoals):\n 1. \\<And>v va a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact (v # va) [];\n        acc_lengths a as' = acc_lengths a (v # va);\n        acc_lengths b bs' = acc_lengths b []\\<rbrakk>\n       \\<Longrightarrow> as' = v # va \\<and> bs' = []\n 2. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact (v # va) [];\n        acc_lengths a as' = acc_lengths a (v # va);\n        acc_lengths b bs' = acc_lengths b []\\<rbrakk>\n       \\<Longrightarrow> as' = v # va \\<and> bs' = []\n 2. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "case (2 c cs)"], ["proof (state)\nthis:\n  interact as' bs' = interact (c # cs) []\n  acc_lengths a as' = acc_lengths a (c # cs)\n  acc_lengths b bs' = acc_lengths b []\n\ngoal (2 subgoals):\n 1. \\<And>v va a b as' bs'.\n       \\<lbrakk>interact as' bs' = interact (v # va) [];\n        acc_lengths a as' = acc_lengths a (v # va);\n        acc_lengths b bs' = acc_lengths b []\\<rbrakk>\n       \\<Longrightarrow> as' = v # va \\<and> bs' = []\n 2. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "then"], ["proof (chain)\npicking this:\n  interact as' bs' = interact (c # cs) []\n  acc_lengths a as' = acc_lengths a (c # cs)\n  acc_lengths b bs' = acc_lengths b []", "show ?case"], ["proof (prove)\nusing this:\n  interact as' bs' = interact (c # cs) []\n  acc_lengths a as' = acc_lengths a (c # cs)\n  acc_lengths b bs' = acc_lengths b []\n\ngoal (1 subgoal):\n 1. as' = c # cs \\<and> bs' = []", "by (metis acc_lengths_concat_injective acc_lengths_eq_Nil_iff interact.simps(2) list.exhaust)"], ["proof (state)\nthis:\n  as' = c # cs \\<and> bs' = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "case (3 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>interact ?as' ?bs' = interact xs ys;\n   acc_lengths ?a ?as' = acc_lengths ?a xs;\n   acc_lengths ?b ?bs' = acc_lengths ?b ys\\<rbrakk>\n  \\<Longrightarrow> ?as' = xs \\<and> ?bs' = ys\n  interact as' bs' = interact (x # xs) (y # ys)\n  acc_lengths a as' = acc_lengths a (x # xs)\n  acc_lengths b bs' = acc_lengths b (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>interact ?as' ?bs' = interact xs ys;\n   acc_lengths ?a ?as' = acc_lengths ?a xs;\n   acc_lengths ?b ?bs' = acc_lengths ?b ys\\<rbrakk>\n  \\<Longrightarrow> ?as' = xs \\<and> ?bs' = ys\n  interact as' bs' = interact (x # xs) (y # ys)\n  acc_lengths a as' = acc_lengths a (x # xs)\n  acc_lengths b bs' = acc_lengths b (y # ys)", "obtain a' us b' vs where \"as' = a'#us\" \"bs' = b'#vs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>interact ?as' ?bs' = interact xs ys;\n   acc_lengths ?a ?as' = acc_lengths ?a xs;\n   acc_lengths ?b ?bs' = acc_lengths ?b ys\\<rbrakk>\n  \\<Longrightarrow> ?as' = xs \\<and> ?bs' = ys\n  interact as' bs' = interact (x # xs) (y # ys)\n  acc_lengths a as' = acc_lengths a (x # xs)\n  acc_lengths b bs' = acc_lengths b (y # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>a' us b' vs.\n        \\<lbrakk>as' = a' # us; bs' = b' # vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv length_acc_lengths)"], ["proof (state)\nthis:\n  as' = a' # us\n  bs' = b' # vs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys a b as' bs'.\n       \\<lbrakk>\\<And>a b as' bs'.\n                   \\<lbrakk>interact as' bs' = interact xs ys;\n                    acc_lengths a as' = acc_lengths a xs;\n                    acc_lengths b bs' = acc_lengths b ys\\<rbrakk>\n                   \\<Longrightarrow> as' = xs \\<and> bs' = ys;\n        interact as' bs' = interact (x # xs) (y # ys);\n        acc_lengths a as' = acc_lengths a (x # xs);\n        acc_lengths b bs' = acc_lengths b (y # ys)\\<rbrakk>\n       \\<Longrightarrow> as' = x # xs \\<and> bs' = y # ys", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>interact ?as' ?bs' = interact xs ys;\n   acc_lengths ?a ?as' = acc_lengths ?a xs;\n   acc_lengths ?b ?bs' = acc_lengths ?b ys\\<rbrakk>\n  \\<Longrightarrow> ?as' = xs \\<and> ?bs' = ys\n  interact as' bs' = interact (x # xs) (y # ys)\n  acc_lengths a as' = acc_lengths a (x # xs)\n  acc_lengths b bs' = acc_lengths b (y # ys)\n  as' = a' # us\n  bs' = b' # vs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>interact ?as' ?bs' = interact xs ys;\n   acc_lengths ?a ?as' = acc_lengths ?a xs;\n   acc_lengths ?b ?bs' = acc_lengths ?b ys\\<rbrakk>\n  \\<Longrightarrow> ?as' = xs \\<and> ?bs' = ys\n  interact as' bs' = interact (x # xs) (y # ys)\n  acc_lengths a as' = acc_lengths a (x # xs)\n  acc_lengths b bs' = acc_lengths b (y # ys)\n  as' = a' # us\n  bs' = b' # vs\n\ngoal (1 subgoal):\n 1. as' = x # xs \\<and> bs' = y # ys", "by (auto simp: acc_lengths.simps)"], ["proof (state)\nthis:\n  as' = x # xs \\<and> bs' = y # ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_sorted_interact_I:\n  assumes \"length ys \\<le> length xs\" \"length xs \\<le> Suc (length ys)\"\n    \"\\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x\"\n    \"\\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y\"\n    \"\\<And>n. n < length ys \\<Longrightarrow> xs!n < ys!n\"\n    \"\\<And>n. Suc n < length xs \\<Longrightarrow> ys!n < xs!Suc n\"\n  assumes \"xs \\<in> lists (- {[]})\" \"ys \\<in> lists (- {[]})\"\n  shows \"strict_sorted (interact xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact xs ys)", "using assms"], ["proof (prove)\nusing this:\n  length ys \\<le> length xs\n  length xs \\<le> Suc (length ys)\n  ?x \\<in> list.set xs \\<Longrightarrow> strict_sorted ?x\n  ?y \\<in> list.set ys \\<Longrightarrow> strict_sorted ?y\n  ?n < length ys \\<Longrightarrow> xs ! ?n < ys ! ?n\n  Suc ?n < length xs \\<Longrightarrow> ys ! ?n < xs ! Suc ?n\n  xs \\<in> lists (- {[]})\n  ys \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (interact xs ys)", "proof (induction rule: interact.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length ys \\<le> length []; length [] \\<le> Suc (length ys);\n        \\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length ys \\<Longrightarrow> [] ! n < ys ! n;\n        \\<And>n. Suc n < length [] \\<Longrightarrow> ys ! n < [] ! Suc n;\n        [] \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [] ys)\n 2. \\<And>v va.\n       \\<lbrakk>length [] \\<le> length (v # va);\n        length (v # va) \\<le> Suc (length []);\n        \\<And>x.\n           x \\<in> list.set (v # va) \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set [] \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length [] \\<Longrightarrow> (v # va) ! n < [] ! n;\n        \\<And>n.\n           Suc n < length (v # va) \\<Longrightarrow>\n           [] ! n < (v # va) ! Suc n;\n        v # va \\<in> lists (- {[]}); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (v # va) [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 length xs \\<le> Suc (length ys);\n                 \\<And>x.\n                    x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n                 \\<And>y.\n                    y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n                 \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (interact xs ys);\n        length (y # ys) \\<le> length (x # xs);\n        length (x # xs) \\<le> Suc (length (y # ys));\n        \\<And>xa.\n           xa \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted xa;\n        \\<And>ya.\n           ya \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ya;\n        \\<And>n.\n           n < length (y # ys) \\<Longrightarrow>\n           (x # xs) ! n < (y # ys) ! n;\n        \\<And>n.\n           Suc n < length (x # xs) \\<Longrightarrow>\n           (y # ys) ! n < (x # xs) ! Suc n;\n        x # xs \\<in> lists (- {[]}); y # ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (x # xs) (y # ys))", "case (3 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>length ys \\<le> length xs; length xs \\<le> Suc (length ys);\n   \\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n   \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact xs ys)\n  length (y # ys) \\<le> length (x # xs)\n  length (x # xs) \\<le> Suc (length (y # ys))\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  ?y \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ?y\n  ?n < length (y # ys) \\<Longrightarrow> (x # xs) ! ?n < (y # ys) ! ?n\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (y # ys) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n  y # ys \\<in> lists (- {[]})\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length ys \\<le> length []; length [] \\<le> Suc (length ys);\n        \\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length ys \\<Longrightarrow> [] ! n < ys ! n;\n        \\<And>n. Suc n < length [] \\<Longrightarrow> ys ! n < [] ! Suc n;\n        [] \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [] ys)\n 2. \\<And>v va.\n       \\<lbrakk>length [] \\<le> length (v # va);\n        length (v # va) \\<le> Suc (length []);\n        \\<And>x.\n           x \\<in> list.set (v # va) \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set [] \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length [] \\<Longrightarrow> (v # va) ! n < [] ! n;\n        \\<And>n.\n           Suc n < length (v # va) \\<Longrightarrow>\n           [] ! n < (v # va) ! Suc n;\n        v # va \\<in> lists (- {[]}); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (v # va) [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 length xs \\<le> Suc (length ys);\n                 \\<And>x.\n                    x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n                 \\<And>y.\n                    y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n                 \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (interact xs ys);\n        length (y # ys) \\<le> length (x # xs);\n        length (x # xs) \\<le> Suc (length (y # ys));\n        \\<And>xa.\n           xa \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted xa;\n        \\<And>ya.\n           ya \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ya;\n        \\<And>n.\n           n < length (y # ys) \\<Longrightarrow>\n           (x # xs) ! n < (y # ys) ! n;\n        \\<And>n.\n           Suc n < length (x # xs) \\<Longrightarrow>\n           (y # ys) ! n < (x # xs) ! Suc n;\n        x # xs \\<in> lists (- {[]}); y # ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (x # xs) (y # ys))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ys \\<le> length xs; length xs \\<le> Suc (length ys);\n   \\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n   \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact xs ys)\n  length (y # ys) \\<le> length (x # xs)\n  length (x # xs) \\<le> Suc (length (y # ys))\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  ?y \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ?y\n  ?n < length (y # ys) \\<Longrightarrow> (x # xs) ! ?n < (y # ys) ! ?n\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (y # ys) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n  y # ys \\<in> lists (- {[]})", "have \"x < y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ys \\<le> length xs; length xs \\<le> Suc (length ys);\n   \\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n   \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact xs ys)\n  length (y # ys) \\<le> length (x # xs)\n  length (x # xs) \\<le> Suc (length (y # ys))\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  ?y \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ?y\n  ?n < length (y # ys) \\<Longrightarrow> (x # xs) ! ?n < (y # ys) ! ?n\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (y # ys) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n  y # ys \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. x < y", "by force+"], ["proof (state)\nthis:\n  x < y\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length ys \\<le> length []; length [] \\<le> Suc (length ys);\n        \\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length ys \\<Longrightarrow> [] ! n < ys ! n;\n        \\<And>n. Suc n < length [] \\<Longrightarrow> ys ! n < [] ! Suc n;\n        [] \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [] ys)\n 2. \\<And>v va.\n       \\<lbrakk>length [] \\<le> length (v # va);\n        length (v # va) \\<le> Suc (length []);\n        \\<And>x.\n           x \\<in> list.set (v # va) \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set [] \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length [] \\<Longrightarrow> (v # va) ! n < [] ! n;\n        \\<And>n.\n           Suc n < length (v # va) \\<Longrightarrow>\n           [] ! n < (v # va) ! Suc n;\n        v # va \\<in> lists (- {[]}); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (v # va) [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 length xs \\<le> Suc (length ys);\n                 \\<And>x.\n                    x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n                 \\<And>y.\n                    y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n                 \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (interact xs ys);\n        length (y # ys) \\<le> length (x # xs);\n        length (x # xs) \\<le> Suc (length (y # ys));\n        \\<And>xa.\n           xa \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted xa;\n        \\<And>ya.\n           ya \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ya;\n        \\<And>n.\n           n < length (y # ys) \\<Longrightarrow>\n           (x # xs) ! n < (y # ys) ! n;\n        \\<And>n.\n           Suc n < length (x # xs) \\<Longrightarrow>\n           (y # ys) ! n < (x # xs) ! Suc n;\n        x # xs \\<in> lists (- {[]}); y # ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (x # xs) (y # ys))", "moreover"], ["proof (state)\nthis:\n  x < y\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length ys \\<le> length []; length [] \\<le> Suc (length ys);\n        \\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length ys \\<Longrightarrow> [] ! n < ys ! n;\n        \\<And>n. Suc n < length [] \\<Longrightarrow> ys ! n < [] ! Suc n;\n        [] \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [] ys)\n 2. \\<And>v va.\n       \\<lbrakk>length [] \\<le> length (v # va);\n        length (v # va) \\<le> Suc (length []);\n        \\<And>x.\n           x \\<in> list.set (v # va) \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set [] \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length [] \\<Longrightarrow> (v # va) ! n < [] ! n;\n        \\<And>n.\n           Suc n < length (v # va) \\<Longrightarrow>\n           [] ! n < (v # va) ! Suc n;\n        v # va \\<in> lists (- {[]}); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (v # va) [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 length xs \\<le> Suc (length ys);\n                 \\<And>x.\n                    x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n                 \\<And>y.\n                    y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n                 \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (interact xs ys);\n        length (y # ys) \\<le> length (x # xs);\n        length (x # xs) \\<le> Suc (length (y # ys));\n        \\<And>xa.\n           xa \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted xa;\n        \\<And>ya.\n           ya \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ya;\n        \\<And>n.\n           n < length (y # ys) \\<Longrightarrow>\n           (x # xs) ! n < (y # ys) ! n;\n        \\<And>n.\n           Suc n < length (x # xs) \\<Longrightarrow>\n           (y # ys) ! n < (x # xs) ! Suc n;\n        x # xs \\<in> lists (- {[]}); y # ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (x # xs) (y # ys))", "have \"strict_sorted (interact xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact xs ys)", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ys \\<le> length xs; length xs \\<le> Suc (length ys);\n   \\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n   \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact xs ys)\n  length (y # ys) \\<le> length (x # xs)\n  length (x # xs) \\<le> Suc (length (y # ys))\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  ?y \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ?y\n  ?n < length (y # ys) \\<Longrightarrow> (x # xs) ! ?n < (y # ys) ! ?n\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (y # ys) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n  y # ys \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (interact xs ys)", "by simp (metis Suc_less_eq nth_Cons_Suc)"], ["proof (state)\nthis:\n  strict_sorted (interact xs ys)\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length ys \\<le> length []; length [] \\<le> Suc (length ys);\n        \\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length ys \\<Longrightarrow> [] ! n < ys ! n;\n        \\<And>n. Suc n < length [] \\<Longrightarrow> ys ! n < [] ! Suc n;\n        [] \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [] ys)\n 2. \\<And>v va.\n       \\<lbrakk>length [] \\<le> length (v # va);\n        length (v # va) \\<le> Suc (length []);\n        \\<And>x.\n           x \\<in> list.set (v # va) \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set [] \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length [] \\<Longrightarrow> (v # va) ! n < [] ! n;\n        \\<And>n.\n           Suc n < length (v # va) \\<Longrightarrow>\n           [] ! n < (v # va) ! Suc n;\n        v # va \\<in> lists (- {[]}); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (v # va) [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 length xs \\<le> Suc (length ys);\n                 \\<And>x.\n                    x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n                 \\<And>y.\n                    y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n                 \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (interact xs ys);\n        length (y # ys) \\<le> length (x # xs);\n        length (x # xs) \\<le> Suc (length (y # ys));\n        \\<And>xa.\n           xa \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted xa;\n        \\<And>ya.\n           ya \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ya;\n        \\<And>n.\n           n < length (y # ys) \\<Longrightarrow>\n           (x # xs) ! n < (y # ys) ! n;\n        \\<And>n.\n           Suc n < length (x # xs) \\<Longrightarrow>\n           (y # ys) ! n < (x # xs) ! Suc n;\n        x # xs \\<in> lists (- {[]}); y # ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (x # xs) (y # ys))", "moreover"], ["proof (state)\nthis:\n  strict_sorted (interact xs ys)\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length ys \\<le> length []; length [] \\<le> Suc (length ys);\n        \\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length ys \\<Longrightarrow> [] ! n < ys ! n;\n        \\<And>n. Suc n < length [] \\<Longrightarrow> ys ! n < [] ! Suc n;\n        [] \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [] ys)\n 2. \\<And>v va.\n       \\<lbrakk>length [] \\<le> length (v # va);\n        length (v # va) \\<le> Suc (length []);\n        \\<And>x.\n           x \\<in> list.set (v # va) \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set [] \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length [] \\<Longrightarrow> (v # va) ! n < [] ! n;\n        \\<And>n.\n           Suc n < length (v # va) \\<Longrightarrow>\n           [] ! n < (v # va) ! Suc n;\n        v # va \\<in> lists (- {[]}); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (v # va) [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 length xs \\<le> Suc (length ys);\n                 \\<And>x.\n                    x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n                 \\<And>y.\n                    y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n                 \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (interact xs ys);\n        length (y # ys) \\<le> length (x # xs);\n        length (x # xs) \\<le> Suc (length (y # ys));\n        \\<And>xa.\n           xa \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted xa;\n        \\<And>ya.\n           ya \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ya;\n        \\<And>n.\n           n < length (y # ys) \\<Longrightarrow>\n           (x # xs) ! n < (y # ys) ! n;\n        \\<And>n.\n           Suc n < length (x # xs) \\<Longrightarrow>\n           (y # ys) ! n < (x # xs) ! Suc n;\n        x # xs \\<in> lists (- {[]}); y # ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (x # xs) (y # ys))", "have \"y < interact xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < interact xs ys", "proof (clarsimp simp add: less_list_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> []; interact xs ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last y < hd (interact xs ys)", "assume \"y \\<noteq> []\" and ne: \"interact xs ys \\<noteq> []\""], ["proof (state)\nthis:\n  y \\<noteq> []\n  interact xs ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> []; interact xs ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last y < hd (interact xs ys)", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> []\n  interact xs ys \\<noteq> []", "show \"last y < hd (interact xs ys)\""], ["proof (prove)\nusing this:\n  y \\<noteq> []\n  interact xs ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. last y < hd (interact xs ys)", "using 3"], ["proof (prove)\nusing this:\n  y \\<noteq> []\n  interact xs ys \\<noteq> []\n  \\<lbrakk>length ys \\<le> length xs; length xs \\<le> Suc (length ys);\n   \\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n   \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact xs ys)\n  length (y # ys) \\<le> length (x # xs)\n  length (x # xs) \\<le> Suc (length (y # ys))\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  ?y \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ?y\n  ?n < length (y # ys) \\<Longrightarrow> (x # xs) ! ?n < (y # ys) ! ?n\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (y # ys) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n  y # ys \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. last y < hd (interact xs ys)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> []; xs = [] \\<longrightarrow> ys \\<noteq> [];\n     \\<lbrakk>\\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n      \\<And>n.\n         Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n\\<rbrakk>\n     \\<Longrightarrow> strict_sorted (interact xs ys);\n     length ys \\<le> length xs; length xs \\<le> Suc (length ys);\n     \\<And>xa.\n        xa = x \\<or> xa \\<in> list.set xs \\<Longrightarrow>\n        strict_sorted xa;\n     \\<And>ya.\n        ya = y \\<or> ya \\<in> list.set ys \\<Longrightarrow>\n        strict_sorted ya;\n     \\<And>n.\n        n < Suc (length ys) \\<Longrightarrow> (x # xs) ! n < (y # ys) ! n;\n     \\<And>n. n < length xs \\<Longrightarrow> (y # ys) ! n < xs ! n;\n     x \\<noteq> [] \\<and> xs \\<in> lists (- {[]});\n     ys \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> last y < hd (interact xs ys)", "by (metis dual_order.strict_trans1 hd_interact length_greater_0_conv less_list_def list.sel(1) lists.simps mem_lists_non_Nil nth_Cons' nth_mem)"], ["proof (state)\nthis:\n  last y < hd (interact xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y < interact xs ys\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length ys \\<le> length []; length [] \\<le> Suc (length ys);\n        \\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length ys \\<Longrightarrow> [] ! n < ys ! n;\n        \\<And>n. Suc n < length [] \\<Longrightarrow> ys ! n < [] ! Suc n;\n        [] \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [] ys)\n 2. \\<And>v va.\n       \\<lbrakk>length [] \\<le> length (v # va);\n        length (v # va) \\<le> Suc (length []);\n        \\<And>x.\n           x \\<in> list.set (v # va) \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set [] \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length [] \\<Longrightarrow> (v # va) ! n < [] ! n;\n        \\<And>n.\n           Suc n < length (v # va) \\<Longrightarrow>\n           [] ! n < (v # va) ! Suc n;\n        v # va \\<in> lists (- {[]}); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (v # va) [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 length xs \\<le> Suc (length ys);\n                 \\<And>x.\n                    x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n                 \\<And>y.\n                    y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n                 \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n                 \\<And>n.\n                    Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n                 xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> strict_sorted (interact xs ys);\n        length (y # ys) \\<le> length (x # xs);\n        length (x # xs) \\<le> Suc (length (y # ys));\n        \\<And>xa.\n           xa \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted xa;\n        \\<And>ya.\n           ya \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ya;\n        \\<And>n.\n           n < length (y # ys) \\<Longrightarrow>\n           (x # xs) ! n < (y # ys) ! n;\n        \\<And>n.\n           Suc n < length (x # xs) \\<Longrightarrow>\n           (y # ys) ! n < (x # xs) ! Suc n;\n        x # xs \\<in> lists (- {[]}); y # ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (x # xs) (y # ys))", "ultimately"], ["proof (chain)\npicking this:\n  x < y\n  strict_sorted (interact xs ys)\n  y < interact xs ys", "show ?case"], ["proof (prove)\nusing this:\n  x < y\n  strict_sorted (interact xs ys)\n  y < interact xs ys\n\ngoal (1 subgoal):\n 1. strict_sorted (interact (x # xs) (y # ys))", "using 3"], ["proof (prove)\nusing this:\n  x < y\n  strict_sorted (interact xs ys)\n  y < interact xs ys\n  \\<lbrakk>length ys \\<le> length xs; length xs \\<le> Suc (length ys);\n   \\<And>x. x \\<in> list.set xs \\<Longrightarrow> strict_sorted x;\n   \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n   \\<And>n. n < length ys \\<Longrightarrow> xs ! n < ys ! n;\n   \\<And>n. Suc n < length xs \\<Longrightarrow> ys ! n < xs ! Suc n;\n   xs \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact xs ys)\n  length (y # ys) \\<le> length (x # xs)\n  length (x # xs) \\<le> Suc (length (y # ys))\n  ?x \\<in> list.set (x # xs) \\<Longrightarrow> strict_sorted ?x\n  ?y \\<in> list.set (y # ys) \\<Longrightarrow> strict_sorted ?y\n  ?n < length (y # ys) \\<Longrightarrow> (x # xs) ! ?n < (y # ys) ! ?n\n  Suc ?n < length (x # xs) \\<Longrightarrow>\n  (y # ys) ! ?n < (x # xs) ! Suc ?n\n  x # xs \\<in> lists (- {[]})\n  y # ys \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (interact (x # xs) (y # ys))", "by (simp add: strict_sorted_append_iff less_list_def)"], ["proof (state)\nthis:\n  strict_sorted (interact (x # xs) (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length ys \\<le> length []; length [] \\<le> Suc (length ys);\n        \\<And>x. x \\<in> list.set [] \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set ys \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length ys \\<Longrightarrow> [] ! n < ys ! n;\n        \\<And>n. Suc n < length [] \\<Longrightarrow> ys ! n < [] ! Suc n;\n        [] \\<in> lists (- {[]}); ys \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [] ys)\n 2. \\<And>v va.\n       \\<lbrakk>length [] \\<le> length (v # va);\n        length (v # va) \\<le> Suc (length []);\n        \\<And>x.\n           x \\<in> list.set (v # va) \\<Longrightarrow> strict_sorted x;\n        \\<And>y. y \\<in> list.set [] \\<Longrightarrow> strict_sorted y;\n        \\<And>n. n < length [] \\<Longrightarrow> (v # va) ! n < [] ! n;\n        \\<And>n.\n           Suc n < length (v # va) \\<Longrightarrow>\n           [] ! n < (v # va) ! Suc n;\n        v # va \\<in> lists (- {[]}); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact (v # va) [])", "qed auto"], ["", "subsection \\<open>Forms and interactions\\<close>"], ["", "subsubsection \\<open>Forms\\<close>"], ["", "inductive Form_Body :: \"[nat, nat, nat list, nat list, nat list] \\<Rightarrow> bool\"\n  where \"Form_Body ka kb xs ys zs\"\n  if \"length xs < length ys\" \"xs = concat (a#as)\" \"ys = concat (b#bs)\"\n          \"a#as \\<in> lists (- {[]})\" \"b#bs \\<in> lists (- {[]})\"\n          \"length (a#as) = ka\" \"length (b#bs) = kb\"\n          \"c = acc_lengths 0 (a#as)\"\n          \"d = acc_lengths 0 (b#bs)\"\n          \"zs = concat [c, a, d, b] @ interact as bs\"\n          \"strict_sorted zs\""], ["", "inductive Form :: \"[nat, nat list set] \\<Rightarrow> bool\"\n  where \"Form 0 {xs,ys}\" if \"length xs = length ys\" \"xs \\<noteq> ys\"\n      | \"Form (2*k-1) {xs,ys}\" if \"Form_Body k k xs ys zs\" \"k > 0\"\n      | \"Form (2*k)   {xs,ys}\" if \"Form_Body (Suc k) k xs ys zs\" \"k > 0\""], ["", "inductive_cases Form_0_cases_raw: \"Form 0 u\""], ["", "lemma Form_elim_upair:\n  assumes \"Form l U\"\n  obtains xs ys where \"xs \\<noteq> ys\" \"U = {xs,ys}\" \"length xs \\<le> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>xs \\<noteq> ys; U = {xs, ys};\n         length xs \\<le> length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  Form l U\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>xs \\<noteq> ys; U = {xs, ys};\n         length xs \\<le> length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim Form.cases Form_Body.cases; metis dual_order.order_iff_strict less_not_refl)"], ["", "lemma Form_Body_WW:\n  assumes \"Form_Body ka kb xs ys zs\"\n  shows \"zs \\<in> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs \\<in> WW", "by (rule Form_Body.cases [OF assms]) (auto simp: WW_def)"], ["", "lemma Form_Body_nonempty:\n  assumes \"Form_Body ka kb xs ys zs\"\n  shows \"length zs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length zs", "by (rule Form_Body.cases [OF assms]) auto"], ["", "lemma Form_Body_length:\n  assumes \"Form_Body ka kb xs ys zs\"\n  shows \"length xs < length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs < length ys", "using Form_Body.cases assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Form_Body ?a1.0 ?a2.0 ?a3.0 ?a4.0 ?a5.0;\n   \\<And>xs ys a as b bs ka kb c d zs.\n      \\<lbrakk>?a1.0 = ka; ?a2.0 = kb; ?a3.0 = xs; ?a4.0 = ys; ?a5.0 = zs;\n       length xs < length ys; xs = concat (a # as); ys = concat (b # bs);\n       a # as \\<in> lists (- {[]}); b # bs \\<in> lists (- {[]});\n       length (a # as) = ka; length (b # bs) = kb;\n       c = acc_lengths 0 (a # as); d = acc_lengths 0 (b # bs);\n       zs = concat [c, a, d, b] @ interact as bs; strict_sorted zs\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  Form_Body ka kb xs ys zs\n\ngoal (1 subgoal):\n 1. length xs < length ys", "by blast"], ["", "lemma form_cases:\n  fixes l::nat\n  obtains (zero) \"l = 0\" | (nz) ka kb where \"l = ka+kb - 1\" \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = 0 \\<Longrightarrow> thesis;\n     \\<And>ka kb.\n        \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = 0 \\<Longrightarrow> thesis;\n     \\<And>ka kb.\n        \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"l = 0 \\<or> (\\<exists>ka kb. l = ka+kb - 1 \\<and> 0 < kb \\<and> kb \\<le> ka \\<and> ka \\<le> Suc kb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = 0 \\<or>\n    (\\<exists>ka kb.\n        l = ka + kb - 1 \\<and>\n        0 < kb \\<and> kb \\<le> ka \\<and> ka \\<le> Suc kb)", "by presburger"], ["proof (state)\nthis:\n  l = 0 \\<or>\n  (\\<exists>ka kb.\n      l = ka + kb - 1 \\<and>\n      0 < kb \\<and> kb \\<le> ka \\<and> ka \\<le> Suc kb)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = 0 \\<Longrightarrow> thesis;\n     \\<And>ka kb.\n        \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  l = 0 \\<or>\n  (\\<exists>ka kb.\n      l = ka + kb - 1 \\<and>\n      0 < kb \\<and> kb \\<le> ka \\<and> ka \\<le> Suc kb)", "show thesis"], ["proof (prove)\nusing this:\n  l = 0 \\<or>\n  (\\<exists>ka kb.\n      l = ka + kb - 1 \\<and>\n      0 < kb \\<and> kb \\<le> ka \\<and> ka \\<le> Suc kb)\n\ngoal (1 subgoal):\n 1. thesis", "using nz zero"], ["proof (prove)\nusing this:\n  l = 0 \\<or>\n  (\\<exists>ka kb.\n      l = ka + kb - 1 \\<and>\n      0 < kb \\<and> kb \\<le> ka \\<and> ka \\<le> Suc kb)\n  \\<lbrakk>l = ?ka + ?kb - 1; 0 < ?kb; ?kb \\<le> ?ka;\n   ?ka \\<le> Suc ?kb\\<rbrakk>\n  \\<Longrightarrow> thesis\n  l = 0 \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Interactions\\<close>"], ["", "lemma interact:\n  assumes \"Form l U\" \"l>0\"\n  obtains ka kb xs ys zs where \"l = ka+kb - 1\" \"U = {xs,ys}\" \"Form_Body ka kb xs ys zs\" \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ka kb xs ys zs.\n        \\<lbrakk>l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs;\n         0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using form_cases [of l]"], ["proof (prove)\nusing this:\n  \\<lbrakk>l = 0 \\<Longrightarrow> ?thesis;\n   \\<And>ka kb.\n      \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ka kb xs ys zs.\n        \\<lbrakk>l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs;\n         0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ka kb xs ys zs.\n                \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                 Form_Body ka kb xs ys zs; 0 < kb; kb \\<le> ka;\n                 ka \\<le> Suc kb\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     l = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>ka kb.\n       \\<lbrakk>\\<And>ka kb xs ys zs.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys zs; 0 < kb; kb \\<le> ka;\n                    ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; 0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "case zero"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ka kb xs ys zs.\n                \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                 Form_Body ka kb xs ys zs; 0 < kb; kb \\<le> ka;\n                 ka \\<le> Suc kb\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     l = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>ka kb.\n       \\<lbrakk>\\<And>ka kb xs ys zs.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys zs; 0 < kb; kb \\<le> ka;\n                    ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; 0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  l = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  l = 0\n\ngoal (1 subgoal):\n 1. thesis", "using Form_0_cases_raw assms that(1)"], ["proof (prove)\nusing this:\n  l = 0\n  \\<lbrakk>Form 0 ?u;\n   \\<And>xs ys.\n      \\<lbrakk>?u = {xs, ys}; length xs = length ys; xs \\<noteq> ys\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  Form l U\n  0 < l\n  \\<lbrakk>l = ?ka + ?kb - 1; U = {?xs, ?ys}; Form_Body ?ka ?kb ?xs ?ys ?zs;\n   0 < ?kb; ?kb \\<le> ?ka; ?ka \\<le> Suc ?kb\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>ka kb.\n       \\<lbrakk>\\<And>ka kb xs ys zs.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys zs; 0 < kb; kb \\<le> ka;\n                    ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; 0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka kb.\n       \\<lbrakk>\\<And>ka kb xs ys zs.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys zs; 0 < kb; kb \\<le> ka;\n                    ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; 0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (nz ka kb)"], ["proof (state)\nthis:\n  l = ka + kb - 1\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. \\<And>ka kb.\n       \\<lbrakk>\\<And>ka kb xs ys zs.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys zs; 0 < kb; kb \\<le> ka;\n                    ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; 0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain xs ys where xys: \"xs \\<noteq> ys\" \"U = {xs,ys}\" \"length xs \\<le> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>xs \\<noteq> ys; U = {xs, ys};\n         length xs \\<le> length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Form_elim_upair assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Form ?l ?U;\n   \\<And>xs ys.\n      \\<lbrakk>xs \\<noteq> ys; ?U = {xs, ys};\n       length xs \\<le> length ys\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Form l U\n  0 < l\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>xs \\<noteq> ys; U = {xs, ys};\n         length xs \\<le> length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs \\<noteq> ys\n  U = {xs, ys}\n  length xs \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<And>ka kb.\n       \\<lbrakk>\\<And>ka kb xs ys zs.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys zs; 0 < kb; kb \\<le> ka;\n                    ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; 0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"ka = kb\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ka = kb \\<Longrightarrow> thesis\n 2. ka \\<noteq> kb \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  ka = kb\n\ngoal (2 subgoals):\n 1. ka = kb \\<Longrightarrow> thesis\n 2. ka \\<noteq> kb \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using Form.cases [OF \\<open>Form l U\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xs ys.\n              \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n               xs \\<noteq> ys\\<rbrakk>\n              \\<Longrightarrow> ?P;\n   \\<And>k xs ys zs.\n      \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n       0 < k\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>k xs ys zs.\n      \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n       0 < k\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. thesis", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (2 k xs' ys' zs')"], ["proof (state)\nthis:\n  l = 2 * k - 1\n  U = {xs', ys'}\n  Form_Body k k xs' ys' zs'\n  0 < k\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  l = 2 * k - 1\n  U = {xs', ys'}\n  Form_Body k k xs' ys' zs'\n  0 < k", "have \"xs' = xs \\<and> ys' = ys\""], ["proof (prove)\nusing this:\n  l = 2 * k - 1\n  U = {xs', ys'}\n  Form_Body k k xs' ys' zs'\n  0 < k\n\ngoal (1 subgoal):\n 1. xs' = xs \\<and> ys' = ys", "by (metis Form_Body_length Set.doubleton_eq_iff leD xys(2) xys(3))"], ["proof (state)\nthis:\n  xs' = xs \\<and> ys' = ys\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  xs' = xs \\<and> ys' = ys\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"k = ka\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = ka", "using 2 True nz"], ["proof (prove)\nusing this:\n  l = 2 * k - 1\n  U = {xs', ys'}\n  Form_Body k k xs' ys' zs'\n  0 < k\n  ka = kb\n  l = ka + kb - 1\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. k = ka", "by presburger"], ["proof (state)\nthis:\n  k = ka\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  xs' = xs \\<and> ys' = ys\n  k = ka", "show ?thesis"], ["proof (prove)\nusing this:\n  xs' = xs \\<and> ys' = ys\n  k = ka\n\ngoal (1 subgoal):\n 1. thesis", "using 2 True nz(1) nz(4) that xys(1)"], ["proof (prove)\nusing this:\n  xs' = xs \\<and> ys' = ys\n  k = ka\n  l = 2 * k - 1\n  U = {xs', ys'}\n  Form_Body k k xs' ys' zs'\n  0 < k\n  ka = kb\n  l = ka + kb - 1\n  ka \\<le> Suc kb\n  \\<lbrakk>l = ?ka + ?kb - 1; U = {?xs, ?ys}; Form_Body ?ka ?kb ?xs ?ys ?zs;\n   0 < ?kb; ?kb \\<le> ?ka; ?ka \\<le> Suc ?kb\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed (use True nz in \\<open>presburger+\\<close>)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  ka \\<noteq> kb\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using Form.cases [OF \\<open>Form l U\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xs ys.\n              \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n               xs \\<noteq> ys\\<rbrakk>\n              \\<Longrightarrow> ?P;\n   \\<And>k xs ys zs.\n      \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n       0 < k\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>k xs ys zs.\n      \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n       0 < k\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. thesis", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (3 k xs' ys' zs')"], ["proof (state)\nthis:\n  l = 2 * k\n  U = {xs', ys'}\n  Form_Body (Suc k) k xs' ys' zs'\n  0 < k\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  l = 2 * k\n  U = {xs', ys'}\n  Form_Body (Suc k) k xs' ys' zs'\n  0 < k", "have \"xs' = xs \\<and> ys' = ys\""], ["proof (prove)\nusing this:\n  l = 2 * k\n  U = {xs', ys'}\n  Form_Body (Suc k) k xs' ys' zs'\n  0 < k\n\ngoal (1 subgoal):\n 1. xs' = xs \\<and> ys' = ys", "by (metis Form_Body_length Set.doubleton_eq_iff leD xys(2) xys(3))"], ["proof (state)\nthis:\n  xs' = xs \\<and> ys' = ys\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  xs' = xs \\<and> ys' = ys\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"k = kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = kb", "using 3 False nz"], ["proof (prove)\nusing this:\n  l = 2 * k\n  U = {xs', ys'}\n  Form_Body (Suc k) k xs' ys' zs'\n  0 < k\n  ka \\<noteq> kb\n  l = ka + kb - 1\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. k = kb", "by linarith"], ["proof (state)\nthis:\n  k = kb\n\ngoal (3 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k; U = {xs, ys}; Form_Body (Suc k) k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  xs' = xs \\<and> ys' = ys\n  k = kb", "show ?thesis"], ["proof (prove)\nusing this:\n  xs' = xs \\<and> ys' = ys\n  k = kb\n\ngoal (1 subgoal):\n 1. thesis", "using 3 False nz \\<open>xs \\<noteq> ys\\<close>"], ["proof (prove)\nusing this:\n  xs' = xs \\<and> ys' = ys\n  k = kb\n  l = 2 * k\n  U = {xs', ys'}\n  Form_Body (Suc k) k xs' ys' zs'\n  0 < k\n  ka \\<noteq> kb\n  l = ka + kb - 1\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. thesis", "by (metis le_SucE le_antisym that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>l = 0; U = {xs, ys}; length xs = length ys;\n        xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>k xs ys zs.\n       \\<lbrakk>l = 2 * k - 1; U = {xs, ys}; Form_Body k k xs ys zs;\n        0 < k\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed (use False nz in \\<open>presburger+\\<close>)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition inter_scheme :: \"nat \\<Rightarrow> nat list set \\<Rightarrow> nat list\"\n  where \"inter_scheme l U \\<equiv> \n           SOME zs. \\<exists>k xs ys. l > 0 \\<and>\n                         (l = 2*k-1 \\<and> U = {xs,ys} \\<and> Form_Body k k xs ys zs\n                        \\<or> l = 2*k \\<and> U = {xs,ys} \\<and> Form_Body (Suc k) k xs ys zs)\""], ["", "lemma inter_scheme:\n  assumes \"Form l U\" \"l>0\"\n  obtains ka kb xs ys where \"l = ka+kb - 1\" \"U = {xs,ys}\" \"Form_Body ka kb xs ys (inter_scheme l U)\" \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ka kb xs ys.\n        \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n         Form_Body ka kb xs ys (inter_scheme l U); 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using interact [OF \\<open>Form l U\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < l;\n   \\<And>ka kb xs ys zs.\n      \\<lbrakk>l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs;\n       0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ka kb xs ys.\n        \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n         Form_Body ka kb xs ys (inter_scheme l U); 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>ka kb xs ys.\n        \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n         Form_Body ka kb xs ys (inter_scheme l U); 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    0 < l\n 2. \\<And>ka kb xs ys zs.\n       \\<lbrakk>\\<And>ka kb xs ys.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys (inter_scheme l U); 0 < kb;\n                    kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs; 0 < kb;\n        kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<And>ka kb xs ys.\n        \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n         Form_Body ka kb xs ys (inter_scheme l U); 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    0 < l\n 2. \\<And>ka kb xs ys zs.\n       \\<lbrakk>\\<And>ka kb xs ys.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys (inter_scheme l U); 0 < kb;\n                    kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs; 0 < kb;\n        kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>l > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < l", "show ?case"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. 0 < l", "by auto"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. \\<And>ka kb xs ys zs.\n       \\<lbrakk>\\<And>ka kb xs ys.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys (inter_scheme l U); 0 < kb;\n                    kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs; 0 < kb;\n        kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka kb xs ys zs.\n       \\<lbrakk>\\<And>ka kb xs ys.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys (inter_scheme l U); 0 < kb;\n                    kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs; 0 < kb;\n        kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (2 ka kb xs ys zs)"], ["proof (state)\nthis:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. \\<And>ka kb xs ys zs.\n       \\<lbrakk>\\<And>ka kb xs ys.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys (inter_scheme l U); 0 < kb;\n                    kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs; 0 < kb;\n        kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb", "have \\<section>: \"\\<And>ka kb zs. \\<not> Form_Body ka kb ys xs zs\""], ["proof (prove)\nusing this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. \\<And>ka kb zs. \\<not> Form_Body ka kb ys xs zs", "using Form_Body_length less_asym'"], ["proof (prove)\nusing this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  Form_Body ?ka ?kb ?xs ?ys ?zs \\<Longrightarrow> length ?xs < length ?ys\n  \\<lbrakk>?a < ?b; ?b < ?a\\<rbrakk> \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>ka kb zs. \\<not> Form_Body ka kb ys xs zs", "by blast"], ["proof (state)\nthis:\n  \\<not> Form_Body ?ka ?kb ys xs ?zs\n\ngoal (1 subgoal):\n 1. \\<And>ka kb xs ys zs.\n       \\<lbrakk>\\<And>ka kb xs ys.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys (inter_scheme l U); 0 < kb;\n                    kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs; 0 < kb;\n        kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"Form_Body ka kb xs ys (inter_scheme l U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form_Body ka kb xs ys (inter_scheme l U)", "proof (cases \"ka = kb\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ka = kb \\<Longrightarrow> Form_Body ka kb xs ys (inter_scheme l U)\n 2. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "case True"], ["proof (state)\nthis:\n  ka = kb\n\ngoal (2 subgoals):\n 1. ka = kb \\<Longrightarrow> Form_Body ka kb xs ys (inter_scheme l U)\n 2. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "with 2"], ["proof (chain)\npicking this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  ka = kb", "have l: \"\\<forall>k. l \\<noteq> k * 2\""], ["proof (prove)\nusing this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  ka = kb\n\ngoal (1 subgoal):\n 1. \\<forall>k. l \\<noteq> k * 2", "by presburger"], ["proof (state)\nthis:\n  \\<forall>k. l \\<noteq> k * 2\n\ngoal (2 subgoals):\n 1. ka = kb \\<Longrightarrow> Form_Body ka kb xs ys (inter_scheme l U)\n 2. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "have [simp]: \"\\<And>k. kb + kb - Suc 0 = k * 2 - Suc 0 \\<longleftrightarrow> k=kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. (kb + kb - Suc 0 = k * 2 - Suc 0) = (k = kb)", "by auto"], ["proof (state)\nthis:\n  (kb + kb - Suc 0 = ?k * 2 - Suc 0) = (?k = kb)\n\ngoal (2 subgoals):\n 1. ka = kb \\<Longrightarrow> Form_Body ka kb xs ys (inter_scheme l U)\n 2. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form_Body ka kb xs ys (inter_scheme l U)", "unfolding inter_scheme_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form_Body ka kb xs ys\n     (SOME zs.\n         \\<exists>k xs ys.\n            0 < l \\<and>\n            (l = 2 * k - 1 \\<and>\n             U = {xs, ys} \\<and> Form_Body k k xs ys zs \\<or>\n             l = 2 * k \\<and>\n             U = {xs, ys} \\<and> Form_Body (Suc k) k xs ys zs))", "using 2 l True"], ["proof (prove)\nusing this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  \\<forall>k. l \\<noteq> k * 2\n  ka = kb\n\ngoal (1 subgoal):\n 1. Form_Body ka kb xs ys\n     (SOME zs.\n         \\<exists>k xs ys.\n            0 < l \\<and>\n            (l = 2 * k - 1 \\<and>\n             U = {xs, ys} \\<and> Form_Body k k xs ys zs \\<or>\n             l = 2 * k \\<and>\n             U = {xs, ys} \\<and> Form_Body (Suc k) k xs ys zs))", "by (auto simp add: \\<section> \\<open>l > 0\\<close> Set.doubleton_eq_iff conj_disj_distribR ex_disj_distrib algebra_simps some_eq_ex)"], ["proof (state)\nthis:\n  Form_Body ka kb xs ys (inter_scheme l U)\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "case False"], ["proof (state)\nthis:\n  ka \\<noteq> kb\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "with 2"], ["proof (chain)\npicking this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  ka \\<noteq> kb", "have l: \"\\<forall>k. l \\<noteq> k * 2 - Suc 0\" and [simp]: \"ka = Suc kb\""], ["proof (prove)\nusing this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  ka \\<noteq> kb\n\ngoal (1 subgoal):\n 1. \\<forall>k. l \\<noteq> k * 2 - Suc 0 &&& ka = Suc kb", "by presburger+"], ["proof (state)\nthis:\n  \\<forall>k. l \\<noteq> k * 2 - Suc 0\n  ka = Suc kb\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "have [simp]: \"\\<And>k. kb + kb = k * 2 \\<longleftrightarrow> k=kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. (kb + kb = k * 2) = (k = kb)", "by auto"], ["proof (state)\nthis:\n  (kb + kb = ?k * 2) = (?k = kb)\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    Form_Body ka kb xs ys (inter_scheme l U)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form_Body ka kb xs ys (inter_scheme l U)", "unfolding inter_scheme_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form_Body ka kb xs ys\n     (SOME zs.\n         \\<exists>k xs ys.\n            0 < l \\<and>\n            (l = 2 * k - 1 \\<and>\n             U = {xs, ys} \\<and> Form_Body k k xs ys zs \\<or>\n             l = 2 * k \\<and>\n             U = {xs, ys} \\<and> Form_Body (Suc k) k xs ys zs))", "using 2 l False"], ["proof (prove)\nusing this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  \\<forall>k. l \\<noteq> k * 2 - Suc 0\n  ka \\<noteq> kb\n\ngoal (1 subgoal):\n 1. Form_Body ka kb xs ys\n     (SOME zs.\n         \\<exists>k xs ys.\n            0 < l \\<and>\n            (l = 2 * k - 1 \\<and>\n             U = {xs, ys} \\<and> Form_Body k k xs ys zs \\<or>\n             l = 2 * k \\<and>\n             U = {xs, ys} \\<and> Form_Body (Suc k) k xs ys zs))", "by (auto simp add: \\<section> \\<open>l > 0\\<close> Set.doubleton_eq_iff conj_disj_distribR ex_disj_distrib algebra_simps some_eq_ex)"], ["proof (state)\nthis:\n  Form_Body ka kb xs ys (inter_scheme l U)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Form_Body ka kb xs ys (inter_scheme l U)\n\ngoal (1 subgoal):\n 1. \\<And>ka kb xs ys zs.\n       \\<lbrakk>\\<And>ka kb xs ys.\n                   \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n                    Form_Body ka kb xs ys (inter_scheme l U); 0 < kb;\n                    kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        l = ka + kb - 1; U = {xs, ys}; Form_Body ka kb xs ys zs; 0 < kb;\n        kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  Form_Body ka kb xs ys (inter_scheme l U)", "show ?thesis"], ["proof (prove)\nusing this:\n  Form_Body ka kb xs ys (inter_scheme l U)\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add: 2 that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inter_scheme_simple:\n  assumes \"Form l U\" \"l>0\"\n  shows \"inter_scheme l U \\<in> WW \\<and> length (inter_scheme l U) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inter_scheme l U \\<in> WW \\<and> 0 < length (inter_scheme l U)", "using inter_scheme [OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>ka kb xs ys.\n      \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n       Form_Body ka kb xs ys (inter_scheme l U); 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. inter_scheme l U \\<in> WW \\<and> 0 < length (inter_scheme l U)", "by (meson Form_Body_WW Form_Body_nonempty)"], ["", "lemma inter_scheme_strict_sorted:\n  assumes \"Form l U\" \"l>0\"\n  shows \"strict_sorted (inter_scheme l U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (inter_scheme l U)", "using inter_scheme_simple [OF assms]"], ["proof (prove)\nusing this:\n  inter_scheme l U \\<in> WW \\<and> 0 < length (inter_scheme l U)\n\ngoal (1 subgoal):\n 1. strict_sorted (inter_scheme l U)", "by (auto simp: WW_def)"], ["", "subsubsection \\<open>Injectivity of interactions\\<close>"], ["", "proposition inter_scheme_injective:\n  assumes \"Form l U\" \"Form l U'\" \"l > 0\" and eq: \"inter_scheme l U' = inter_scheme l U\"\n  shows \"U' = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U' = U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. U' = U", "obtain ka kb xs ys \n    where l: \"l = ka+kb - 1\" and U: \"U = {xs,ys}\" \n      and FB: \"Form_Body ka kb xs ys (inter_scheme l U)\" and \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ka kb xs ys.\n        \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n         Form_Body ka kb xs ys (inter_scheme l U); 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms inter_scheme"], ["proof (prove)\nusing this:\n  Form l U\n  Form l U'\n  0 < l\n  inter_scheme l U' = inter_scheme l U\n  \\<lbrakk>Form ?l ?U; 0 < ?l;\n   \\<And>ka kb xs ys.\n      \\<lbrakk>?l = ka + kb - 1; ?U = {xs, ys};\n       Form_Body ka kb xs ys (inter_scheme ?l ?U); 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ka kb xs ys.\n        \\<lbrakk>l = ka + kb - 1; U = {xs, ys};\n         Form_Body ka kb xs ys (inter_scheme l U); 0 < kb; kb \\<le> ka;\n         ka \\<le> Suc kb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys (inter_scheme l U)\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. U' = U", "then"], ["proof (chain)\npicking this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys (inter_scheme l U)\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb", "obtain a as b bs c d\n    where xs: \"xs = concat (a#as)\" and ys: \"ys = concat (b#bs)\"\n      and len: \"length (a#as) = ka\" \"length (b#bs) = kb\"\n      and c: \"c = acc_lengths 0 (a#as)\"\n      and d: \"d = acc_lengths 0 (b#bs)\"\n      and Ueq: \"inter_scheme l U = concat [c, a, d, b] @ interact as bs\""], ["proof (prove)\nusing this:\n  l = ka + kb - 1\n  U = {xs, ys}\n  Form_Body ka kb xs ys (inter_scheme l U)\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. (\\<And>a as b bs c d.\n        \\<lbrakk>xs = concat (a # as); ys = concat (b # bs);\n         length (a # as) = ka; length (b # bs) = kb;\n         c = acc_lengths 0 (a # as); d = acc_lengths 0 (b # bs);\n         inter_scheme l U = concat [c, a, d, b] @ interact as bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Form_Body.simps)"], ["proof (state)\nthis:\n  xs = concat (a # as)\n  ys = concat (b # bs)\n  length (a # as) = ka\n  length (b # bs) = kb\n  c = acc_lengths 0 (a # as)\n  d = acc_lengths 0 (b # bs)\n  inter_scheme l U = concat [c, a, d, b] @ interact as bs\n\ngoal (1 subgoal):\n 1. U' = U", "obtain ka' kb' xs' ys' \n    where l': \"l = ka'+kb' - 1\" and U': \"U' = {xs',ys'}\" \n      and FB': \"Form_Body ka' kb' xs' ys' (inter_scheme l U')\" and \"0 < kb'\" \"kb' \\<le> ka'\" \"ka' \\<le> Suc kb'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ka' kb' xs' ys'.\n        \\<lbrakk>l = ka' + kb' - 1; U' = {xs', ys'};\n         Form_Body ka' kb' xs' ys' (inter_scheme l U'); 0 < kb';\n         kb' \\<le> ka'; ka' \\<le> Suc kb'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms inter_scheme"], ["proof (prove)\nusing this:\n  Form l U\n  Form l U'\n  0 < l\n  inter_scheme l U' = inter_scheme l U\n  \\<lbrakk>Form ?l ?U; 0 < ?l;\n   \\<And>ka kb xs ys.\n      \\<lbrakk>?l = ka + kb - 1; ?U = {xs, ys};\n       Form_Body ka kb xs ys (inter_scheme ?l ?U); 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ka' kb' xs' ys'.\n        \\<lbrakk>l = ka' + kb' - 1; U' = {xs', ys'};\n         Form_Body ka' kb' xs' ys' (inter_scheme l U'); 0 < kb';\n         kb' \\<le> ka'; ka' \\<le> Suc kb'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l = ka' + kb' - 1\n  U' = {xs', ys'}\n  Form_Body ka' kb' xs' ys' (inter_scheme l U')\n  0 < kb'\n  kb' \\<le> ka'\n  ka' \\<le> Suc kb'\n\ngoal (1 subgoal):\n 1. U' = U", "then"], ["proof (chain)\npicking this:\n  l = ka' + kb' - 1\n  U' = {xs', ys'}\n  Form_Body ka' kb' xs' ys' (inter_scheme l U')\n  0 < kb'\n  kb' \\<le> ka'\n  ka' \\<le> Suc kb'", "obtain a' as' b' bs' c' d'\n    where xs': \"xs' = concat (a'#as')\" and ys': \"ys' = concat (b'#bs')\"\n      and len': \"length (a'#as') = ka'\" \"length (b'#bs') = kb'\"\n      and c': \"c' = acc_lengths 0 (a'#as')\"\n      and d': \"d' = acc_lengths 0 (b'#bs')\"\n      and Ueq': \"inter_scheme l U' = concat [c', a', d', b'] @ interact as' bs'\""], ["proof (prove)\nusing this:\n  l = ka' + kb' - 1\n  U' = {xs', ys'}\n  Form_Body ka' kb' xs' ys' (inter_scheme l U')\n  0 < kb'\n  kb' \\<le> ka'\n  ka' \\<le> Suc kb'\n\ngoal (1 subgoal):\n 1. (\\<And>a' as' b' bs' c' d'.\n        \\<lbrakk>xs' = concat (a' # as'); ys' = concat (b' # bs');\n         length (a' # as') = ka'; length (b' # bs') = kb';\n         c' = acc_lengths 0 (a' # as'); d' = acc_lengths 0 (b' # bs');\n         inter_scheme l U' =\n         concat [c', a', d', b'] @ interact as' bs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Form_Body.simps"], ["proof (prove)\nusing this:\n  l = ka' + kb' - 1\n  U' = {xs', ys'}\n  Form_Body ka' kb' xs' ys' (inter_scheme l U')\n  0 < kb'\n  kb' \\<le> ka'\n  ka' \\<le> Suc kb'\n  Form_Body ?a1.0 ?a2.0 ?a3.0 ?a4.0 ?a5.0 =\n  (\\<exists>xs ys a as b bs ka kb c d zs.\n      ?a1.0 = ka \\<and>\n      ?a2.0 = kb \\<and>\n      ?a3.0 = xs \\<and>\n      ?a4.0 = ys \\<and>\n      ?a5.0 = zs \\<and>\n      length xs < length ys \\<and>\n      xs = concat (a # as) \\<and>\n      ys = concat (b # bs) \\<and>\n      a # as \\<in> lists (- {[]}) \\<and>\n      b # bs \\<in> lists (- {[]}) \\<and>\n      length (a # as) = ka \\<and>\n      length (b # bs) = kb \\<and>\n      c = acc_lengths 0 (a # as) \\<and>\n      d = acc_lengths 0 (b # bs) \\<and>\n      zs = concat [c, a, d, b] @ interact as bs \\<and> strict_sorted zs)\n\ngoal (1 subgoal):\n 1. (\\<And>a' as' b' bs' c' d'.\n        \\<lbrakk>xs' = concat (a' # as'); ys' = concat (b' # bs');\n         length (a' # as') = ka'; length (b' # bs') = kb';\n         c' = acc_lengths 0 (a' # as'); d' = acc_lengths 0 (b' # bs');\n         inter_scheme l U' =\n         concat [c', a', d', b'] @ interact as' bs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs' = concat (a' # as')\n  ys' = concat (b' # bs')\n  length (a' # as') = ka'\n  length (b' # bs') = kb'\n  c' = acc_lengths 0 (a' # as')\n  d' = acc_lengths 0 (b' # bs')\n  inter_scheme l U' = concat [c', a', d', b'] @ interact as' bs'\n\ngoal (1 subgoal):\n 1. U' = U", "have [simp]: \"ka' = ka \\<and> kb' = kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ka' = ka \\<and> kb' = kb", "using \\<open>l > 0\\<close> l l' \\<open>ka \\<le> Suc kb\\<close> \\<open>ka' \\<le> Suc kb'\\<close> \\<open>kb \\<le> ka\\<close> \\<open>kb' \\<le> ka'\\<close> le_SucE le_antisym mult_2"], ["proof (prove)\nusing this:\n  0 < l\n  l = ka + kb - 1\n  l = ka' + kb' - 1\n  ka \\<le> Suc kb\n  ka' \\<le> Suc kb'\n  kb \\<le> ka\n  kb' \\<le> ka'\n  \\<lbrakk>?m \\<le> Suc ?n; ?m \\<le> ?n \\<Longrightarrow> ?R;\n   ?m = Suc ?n \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n  (2::?'a) * ?z = ?z + ?z\n\ngoal (1 subgoal):\n 1. ka' = ka \\<and> kb' = kb", "by linarith"], ["proof (state)\nthis:\n  ka' = ka \\<and> kb' = kb\n\ngoal (1 subgoal):\n 1. U' = U", "have [simp]: \"length c = length c'\" \"length d = length d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length c = length c' &&& length d = length d'", "using c c' d d' len' len"], ["proof (prove)\nusing this:\n  c = acc_lengths 0 (a # as)\n  c' = acc_lengths 0 (a' # as')\n  d = acc_lengths 0 (b # bs)\n  d' = acc_lengths 0 (b' # bs')\n  length (a' # as') = ka'\n  length (b' # bs') = kb'\n  length (a # as) = ka\n  length (b # bs) = kb\n\ngoal (1 subgoal):\n 1. length c = length c' &&& length d = length d'", "by auto"], ["proof (state)\nthis:\n  length c = length c'\n  length d = length d'\n\ngoal (1 subgoal):\n 1. U' = U", "have c_off: \"c' = c\" \"a' @ d' @ b' @ interact as' bs' = a @ d @ b @ interact as bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c' = c &&& a' @ d' @ b' @ interact as' bs' = a @ d @ b @ interact as bs", "using eq"], ["proof (prove)\nusing this:\n  inter_scheme l U' = inter_scheme l U\n\ngoal (1 subgoal):\n 1. c' = c &&& a' @ d' @ b' @ interact as' bs' = a @ d @ b @ interact as bs", "by (auto simp: Ueq Ueq')"], ["proof (state)\nthis:\n  c' = c\n  a' @ d' @ b' @ interact as' bs' = a @ d @ b @ interact as bs\n\ngoal (1 subgoal):\n 1. U' = U", "then"], ["proof (chain)\npicking this:\n  c' = c\n  a' @ d' @ b' @ interact as' bs' = a @ d @ b @ interact as bs", "have len_a: \"length a' = length a\""], ["proof (prove)\nusing this:\n  c' = c\n  a' @ d' @ b' @ interact as' bs' = a @ d @ b @ interact as bs\n\ngoal (1 subgoal):\n 1. length a' = length a", "by (metis acc_lengths.simps(2) add.left_neutral c c' nth_Cons_0)"], ["proof (state)\nthis:\n  length a' = length a\n\ngoal (1 subgoal):\n 1. U' = U", "with c_off"], ["proof (chain)\npicking this:\n  c' = c\n  a' @ d' @ b' @ interact as' bs' = a @ d @ b @ interact as bs\n  length a' = length a", "have \\<section>: \"a' = a\" \"d' = d\" \"b' @ interact as' bs' = b @ interact as bs\""], ["proof (prove)\nusing this:\n  c' = c\n  a' @ d' @ b' @ interact as' bs' = a @ d @ b @ interact as bs\n  length a' = length a\n\ngoal (1 subgoal):\n 1. a' = a &&& d' = d &&& b' @ interact as' bs' = b @ interact as bs", "by auto"], ["proof (state)\nthis:\n  a' = a\n  d' = d\n  b' @ interact as' bs' = b @ interact as bs\n\ngoal (1 subgoal):\n 1. U' = U", "then"], ["proof (chain)\npicking this:\n  a' = a\n  d' = d\n  b' @ interact as' bs' = b @ interact as bs", "have \"length (interact as' bs') = length (interact as bs)\""], ["proof (prove)\nusing this:\n  a' = a\n  d' = d\n  b' @ interact as' bs' = b @ interact as bs\n\ngoal (1 subgoal):\n 1. length (interact as' bs') = length (interact as bs)", "by (metis acc_lengths.simps(2) add_left_cancel append_eq_append_conv d d' list.inject)"], ["proof (state)\nthis:\n  length (interact as' bs') = length (interact as bs)\n\ngoal (1 subgoal):\n 1. U' = U", "with \\<section>"], ["proof (chain)\npicking this:\n  a' = a\n  d' = d\n  b' @ interact as' bs' = b @ interact as bs\n  length (interact as' bs') = length (interact as bs)", "have \"b' = b\" \"interact as' bs' = interact as bs\""], ["proof (prove)\nusing this:\n  a' = a\n  d' = d\n  b' @ interact as' bs' = b @ interact as bs\n  length (interact as' bs') = length (interact as bs)\n\ngoal (1 subgoal):\n 1. b' = b &&& interact as' bs' = interact as bs", "by auto"], ["proof (state)\nthis:\n  b' = b\n  interact as' bs' = interact as bs\n\ngoal (1 subgoal):\n 1. U' = U", "moreover"], ["proof (state)\nthis:\n  b' = b\n  interact as' bs' = interact as bs\n\ngoal (1 subgoal):\n 1. U' = U", "have \"acc_lengths 0 as' = acc_lengths 0 as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc_lengths 0 as' = acc_lengths 0 as", "using \\<open>a' = a\\<close> \\<open>c' = c\\<close>"], ["proof (prove)\nusing this:\n  a' = a\n  c' = c\n\ngoal (1 subgoal):\n 1. acc_lengths 0 as' = acc_lengths 0 as", "by (simp add: c' c acc_lengths.simps acc_lengths_shift)"], ["proof (state)\nthis:\n  acc_lengths 0 as' = acc_lengths 0 as\n\ngoal (1 subgoal):\n 1. U' = U", "moreover"], ["proof (state)\nthis:\n  acc_lengths 0 as' = acc_lengths 0 as\n\ngoal (1 subgoal):\n 1. U' = U", "have \"acc_lengths 0 bs' = acc_lengths 0 bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc_lengths 0 bs' = acc_lengths 0 bs", "using \\<open>b' = b\\<close> \\<open>d' = d\\<close>"], ["proof (prove)\nusing this:\n  b' = b\n  d' = d\n\ngoal (1 subgoal):\n 1. acc_lengths 0 bs' = acc_lengths 0 bs", "by (simp add: d' d acc_lengths.simps acc_lengths_shift)"], ["proof (state)\nthis:\n  acc_lengths 0 bs' = acc_lengths 0 bs\n\ngoal (1 subgoal):\n 1. U' = U", "ultimately"], ["proof (chain)\npicking this:\n  b' = b\n  interact as' bs' = interact as bs\n  acc_lengths 0 as' = acc_lengths 0 as\n  acc_lengths 0 bs' = acc_lengths 0 bs", "have \"as' = as \\<and> bs' = bs\""], ["proof (prove)\nusing this:\n  b' = b\n  interact as' bs' = interact as bs\n  acc_lengths 0 as' = acc_lengths 0 as\n  acc_lengths 0 bs' = acc_lengths 0 bs\n\ngoal (1 subgoal):\n 1. as' = as \\<and> bs' = bs", "using acc_lengths_interact_injective"], ["proof (prove)\nusing this:\n  b' = b\n  interact as' bs' = interact as bs\n  acc_lengths 0 as' = acc_lengths 0 as\n  acc_lengths 0 bs' = acc_lengths 0 bs\n  \\<lbrakk>interact ?as' ?bs' = interact ?as ?bs;\n   acc_lengths ?a ?as' = acc_lengths ?a ?as;\n   acc_lengths ?b ?bs' = acc_lengths ?b ?bs\\<rbrakk>\n  \\<Longrightarrow> ?as' = ?as \\<and> ?bs' = ?bs\n\ngoal (1 subgoal):\n 1. as' = as \\<and> bs' = bs", "by blast"], ["proof (state)\nthis:\n  as' = as \\<and> bs' = bs\n\ngoal (1 subgoal):\n 1. U' = U", "then"], ["proof (chain)\npicking this:\n  as' = as \\<and> bs' = bs", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = as \\<and> bs' = bs\n\ngoal (1 subgoal):\n 1. U' = U", "by (simp add: \\<open>a' = a\\<close> U U' \\<open>b' = b\\<close> xs xs' ys ys')"], ["proof (state)\nthis:\n  U' = U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_sorted_interact_imp_concat:\n    \"strict_sorted (interact as bs) \\<Longrightarrow> strict_sorted (concat as) \\<and> strict_sorted (concat bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact as bs) \\<Longrightarrow>\n    strict_sorted (concat as) \\<and> strict_sorted (concat bs)", "proof (induction as bs rule: interact.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       strict_sorted (interact [] ys) \\<Longrightarrow>\n       strict_sorted (concat []) \\<and> strict_sorted (concat ys)\n 2. \\<And>v va.\n       strict_sorted (interact (v # va) []) \\<Longrightarrow>\n       strict_sorted (concat (v # va)) \\<and> strict_sorted (concat [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>strict_sorted (interact xs ys) \\<Longrightarrow>\n                strict_sorted (concat xs) \\<and> strict_sorted (concat ys);\n        strict_sorted (interact (x # xs) (y # ys))\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (concat (x # xs)) \\<and>\n                         strict_sorted (concat (y # ys))", "case (3 x xs y ys)"], ["proof (state)\nthis:\n  strict_sorted (interact xs ys) \\<Longrightarrow>\n  strict_sorted (concat xs) \\<and> strict_sorted (concat ys)\n  strict_sorted (interact (x # xs) (y # ys))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       strict_sorted (interact [] ys) \\<Longrightarrow>\n       strict_sorted (concat []) \\<and> strict_sorted (concat ys)\n 2. \\<And>v va.\n       strict_sorted (interact (v # va) []) \\<Longrightarrow>\n       strict_sorted (concat (v # va)) \\<and> strict_sorted (concat [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>strict_sorted (interact xs ys) \\<Longrightarrow>\n                strict_sorted (concat xs) \\<and> strict_sorted (concat ys);\n        strict_sorted (interact (x # xs) (y # ys))\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (concat (x # xs)) \\<and>\n                         strict_sorted (concat (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = [] \\<Longrightarrow>\n    strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n 2. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "case Nil"], ["proof (state)\nthis:\n  x = []\n\ngoal (2 subgoals):\n 1. x = [] \\<Longrightarrow>\n    strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n 2. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow>\n    strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n 2. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "case Nil"], ["proof (state)\nthis:\n  y = []\n\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow>\n    strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n 2. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "then"], ["proof (chain)\npicking this:\n  y = []", "show ?thesis"], ["proof (prove)\nusing this:\n  y = []\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "using \"3\" strict_sorted_append_iff"], ["proof (prove)\nusing this:\n  y = []\n  strict_sorted (interact xs ys) \\<Longrightarrow>\n  strict_sorted (concat xs) \\<and> strict_sorted (concat ys)\n  strict_sorted (interact (x # xs) (y # ys))\n  strict_sorted (?xs @ ?ys) =\n  (?xs < ?ys \\<and> strict_sorted ?xs \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "by (auto simp: \\<open>x = []\\<close>)"], ["proof (state)\nthis:\n  strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "case (Cons a list)"], ["proof (state)\nthis:\n  y = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "with Nil 3"], ["proof (chain)\npicking this:\n  x = []\n  strict_sorted (interact xs ys) \\<Longrightarrow>\n  strict_sorted (concat xs) \\<and> strict_sorted (concat ys)\n  strict_sorted (interact (x # xs) (y # ys))\n  y = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  x = []\n  strict_sorted (interact xs ys) \\<Longrightarrow>\n  strict_sorted (concat xs) \\<and> strict_sorted (concat ys)\n  strict_sorted (interact (x # xs) (y # ys))\n  y = a # list\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "apply (simp add: strict_sorted_append_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = [];\n     strict_sorted (concat xs) \\<and> strict_sorted (concat ys);\n     (\\<forall>x\\<in>list.set list \\<union>\n                     (\\<Union> (list.set ` list.set xs) \\<union>\n                      \\<Union> (list.set ` list.set ys)).\n         a < x) \\<and>\n     list < interact xs ys \\<and>\n     strict_sorted list \\<and> strict_sorted (interact xs ys);\n     y = a # list\\<rbrakk>\n    \\<Longrightarrow> Ball\n                       (list.set list \\<union>\n                        \\<Union> (list.set ` list.set ys))\n                       ((<) a) \\<and>\n                      list < concat ys", "by (metis (no_types, lifting) Un_iff set_interact sorted_wrt_append strict_sorted_append_iff strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "case (Cons a list)"], ["proof (state)\nthis:\n  x = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "have \\<section>: \"sorted_wrt (<) ((a # list) @ y @ interact xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) ((a # list) @ y @ interact xs ys)", "by (metis (no_types) \"3.prems\" interact.simps(3) local.Cons strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  sorted_wrt (<) ((a # list) @ y @ interact xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "then"], ["proof (chain)\npicking this:\n  sorted_wrt (<) ((a # list) @ y @ interact xs ys)", "have \"list = [] \\<or> concat xs = [] \\<or> last list < hd (concat xs)\""], ["proof (prove)\nusing this:\n  sorted_wrt (<) ((a # list) @ y @ interact xs ys)\n\ngoal (1 subgoal):\n 1. list = [] \\<or> concat xs = [] \\<or> last list < hd (concat xs)", "by (metis (full_types) Un_iff hd_in_set last_ConsR last_in_set list.simps(3) set_append set_interact sorted_wrt_append)"], ["proof (state)\nthis:\n  list = [] \\<or> concat xs = [] \\<or> last list < hd (concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "then"], ["proof (chain)\npicking this:\n  list = [] \\<or> concat xs = [] \\<or> last list < hd (concat xs)", "have \"list < concat xs\""], ["proof (prove)\nusing this:\n  list = [] \\<or> concat xs = [] \\<or> last list < hd (concat xs)\n\ngoal (1 subgoal):\n 1. list < concat xs", "using less_list_def"], ["proof (prove)\nusing this:\n  list = [] \\<or> concat xs = [] \\<or> last list < hd (concat xs)\n  ?xs < ?ys \\<equiv>\n  ?xs \\<noteq> [] \\<and> ?ys \\<noteq> [] \\<longrightarrow> last ?xs < hd ?ys\n\ngoal (1 subgoal):\n 1. list < concat xs", "by blast"], ["proof (state)\nthis:\n  list < concat xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "have \"list < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list < y", "by (metis \\<section> append.assoc last.simps less_list_def list.distinct(1) strict_sorted_append_iff strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  list < y\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "note Cons1 = Cons"], ["proof (state)\nthis:\n  x = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow>\n    strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n 2. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "case Nil"], ["proof (state)\nthis:\n  y = []\n\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow>\n    strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n 2. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "then"], ["proof (chain)\npicking this:\n  y = []", "show ?thesis"], ["proof (prove)\nusing this:\n  y = []\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "using 3"], ["proof (prove)\nusing this:\n  y = []\n  strict_sorted (interact xs ys) \\<Longrightarrow>\n  strict_sorted (concat xs) \\<and> strict_sorted (concat ys)\n  strict_sorted (interact (x # xs) (y # ys))\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "by (simp add: sorted_wrt_append strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "case (Cons a' list')"], ["proof (state)\nthis:\n  y = a' # list'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "have \"strict_sorted (list' @ concat ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (list' @ concat ys)", "apply (simp add: strict_sorted_sorted_wrt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (list' @ concat ys)", "by (metis \"3.IH\" \"\\<section>\" Un_iff append_Cons local.Cons set_interact sorted_wrt_append strict_sorted.simps(2) strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  strict_sorted (list' @ concat ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "moreover"], ["proof (state)\nthis:\n  strict_sorted (list' @ concat ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "have \"y < concat ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < concat ys", "by (metis \"\\<section>\" Un_iff hd_in_set last_in_set less_list_def set_interact sorted_wrt_append)"], ["proof (state)\nthis:\n  y < concat ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       y = a # list \\<Longrightarrow>\n       strict_sorted (concat (x # xs)) \\<and>\n       strict_sorted (concat (y # ys))", "ultimately"], ["proof (chain)\npicking this:\n  strict_sorted (list' @ concat ys)\n  y < concat ys", "show ?thesis"], ["proof (prove)\nusing this:\n  strict_sorted (list' @ concat ys)\n  y < concat ys\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "using 3 \\<open>list < concat xs\\<close>"], ["proof (prove)\nusing this:\n  strict_sorted (list' @ concat ys)\n  y < concat ys\n  strict_sorted (interact xs ys) \\<Longrightarrow>\n  strict_sorted (concat xs) \\<and> strict_sorted (concat ys)\n  strict_sorted (interact (x # xs) (y # ys))\n  list < concat xs\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))", "by (auto simp: Cons1 strict_sorted_append_iff)"], ["proof (state)\nthis:\n  strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strict_sorted (concat (x # xs)) \\<and> strict_sorted (concat (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       strict_sorted (interact [] ys) \\<Longrightarrow>\n       strict_sorted (concat []) \\<and> strict_sorted (concat ys)\n 2. \\<And>v va.\n       strict_sorted (interact (v # va) []) \\<Longrightarrow>\n       strict_sorted (concat (v # va)) \\<and> strict_sorted (concat [])", "qed auto"], ["", "lemma strict_sorted_interact_hd:\n  \"\\<lbrakk>strict_sorted (interact cs ds); cs \\<noteq> []; ds \\<noteq> []; hd cs \\<noteq> []; hd ds \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (hd cs) < hd (hd ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_sorted (interact cs ds); cs \\<noteq> []; ds \\<noteq> [];\n     hd cs \\<noteq> []; hd ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd (hd cs) < hd (hd ds)", "by (metis Nil_is_append_conv hd_append2 hd_in_set interact.simps(3) list.exhaust_sel sorted_wrt_append strict_sorted_sorted_wrt)"], ["", "text \\<open>the lengths of the two lists can differ by one\\<close>"], ["", "proposition interaction_scheme_unique_aux:\n  assumes eq: \"concat as = concat as'\" and ys': \"concat bs = concat bs'\"\n    and ne: \"as \\<in> lists (- {[]})\" \"bs \\<in> lists (- {[]})\"\n    and ss_zs: \"strict_sorted (interact as bs)\"\n    and \"length bs \\<le> length as\" \"length as \\<le> Suc (length bs)\"\n    and ne': \"as' \\<in> lists (- {[]})\" \"bs' \\<in> lists (- {[]})\"\n    and ss_zs': \"strict_sorted (interact as' bs')\"\n    and \"length bs' \\<le> length as'\" \"length as' \\<le> Suc (length bs')\"\n    and \"length as = length as'\" \"length bs = length bs'\"\n  shows \"as = as' \\<and> bs = bs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as = as' \\<and> bs = bs'", "using assms"], ["proof (prove)\nusing this:\n  concat as = concat as'\n  concat bs = concat bs'\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  strict_sorted (interact as bs)\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  strict_sorted (interact as' bs')\n  length bs' \\<le> length as'\n  length as' \\<le> Suc (length bs')\n  length as = length as'\n  length bs = length bs'\n\ngoal (1 subgoal):\n 1. as = as' \\<and> bs = bs'", "proof (induction \"length as\" arbitrary: as bs as' bs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as bs as' bs'.\n       \\<lbrakk>0 = length as; concat as = concat as';\n        concat bs = concat bs'; as \\<in> lists (- {[]});\n        bs \\<in> lists (- {[]}); strict_sorted (interact as bs);\n        length bs \\<le> length as; length as \\<le> Suc (length bs);\n        as' \\<in> lists (- {[]}); bs' \\<in> lists (- {[]});\n        strict_sorted (interact as' bs'); length bs' \\<le> length as';\n        length as' \\<le> Suc (length bs'); length as = length as';\n        length bs = length bs'\\<rbrakk>\n       \\<Longrightarrow> as = as' \\<and> bs = bs'\n 2. \\<And>x as bs as' bs'.\n       \\<lbrakk>\\<And>as bs as' bs'.\n                   \\<lbrakk>x = length as; concat as = concat as';\n                    concat bs = concat bs'; as \\<in> lists (- {[]});\n                    bs \\<in> lists (- {[]}); strict_sorted (interact as bs);\n                    length bs \\<le> length as;\n                    length as \\<le> Suc (length bs);\n                    as' \\<in> lists (- {[]}); bs' \\<in> lists (- {[]});\n                    strict_sorted (interact as' bs');\n                    length bs' \\<le> length as';\n                    length as' \\<le> Suc (length bs');\n                    length as = length as'; length bs = length bs'\\<rbrakk>\n                   \\<Longrightarrow> as = as' \\<and> bs = bs';\n        Suc x = length as; concat as = concat as'; concat bs = concat bs';\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]});\n        strict_sorted (interact as bs); length bs \\<le> length as;\n        length as \\<le> Suc (length bs); as' \\<in> lists (- {[]});\n        bs' \\<in> lists (- {[]}); strict_sorted (interact as' bs');\n        length bs' \\<le> length as'; length as' \\<le> Suc (length bs');\n        length as = length as'; length bs = length bs'\\<rbrakk>\n       \\<Longrightarrow> as = as' \\<and> bs = bs'", "case 0"], ["proof (state)\nthis:\n  0 = length as\n  concat as = concat as'\n  concat bs = concat bs'\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  strict_sorted (interact as bs)\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  strict_sorted (interact as' bs')\n  length bs' \\<le> length as'\n  length as' \\<le> Suc (length bs')\n  length as = length as'\n  length bs = length bs'\n\ngoal (2 subgoals):\n 1. \\<And>as bs as' bs'.\n       \\<lbrakk>0 = length as; concat as = concat as';\n        concat bs = concat bs'; as \\<in> lists (- {[]});\n        bs \\<in> lists (- {[]}); strict_sorted (interact as bs);\n        length bs \\<le> length as; length as \\<le> Suc (length bs);\n        as' \\<in> lists (- {[]}); bs' \\<in> lists (- {[]});\n        strict_sorted (interact as' bs'); length bs' \\<le> length as';\n        length as' \\<le> Suc (length bs'); length as = length as';\n        length bs = length bs'\\<rbrakk>\n       \\<Longrightarrow> as = as' \\<and> bs = bs'\n 2. \\<And>x as bs as' bs'.\n       \\<lbrakk>\\<And>as bs as' bs'.\n                   \\<lbrakk>x = length as; concat as = concat as';\n                    concat bs = concat bs'; as \\<in> lists (- {[]});\n                    bs \\<in> lists (- {[]}); strict_sorted (interact as bs);\n                    length bs \\<le> length as;\n                    length as \\<le> Suc (length bs);\n                    as' \\<in> lists (- {[]}); bs' \\<in> lists (- {[]});\n                    strict_sorted (interact as' bs');\n                    length bs' \\<le> length as';\n                    length as' \\<le> Suc (length bs');\n                    length as = length as'; length bs = length bs'\\<rbrakk>\n                   \\<Longrightarrow> as = as' \\<and> bs = bs';\n        Suc x = length as; concat as = concat as'; concat bs = concat bs';\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]});\n        strict_sorted (interact as bs); length bs \\<le> length as;\n        length as \\<le> Suc (length bs); as' \\<in> lists (- {[]});\n        bs' \\<in> lists (- {[]}); strict_sorted (interact as' bs');\n        length bs' \\<le> length as'; length as' \\<le> Suc (length bs');\n        length as = length as'; length bs = length bs'\\<rbrakk>\n       \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  0 = length as\n  concat as = concat as'\n  concat bs = concat bs'\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  strict_sorted (interact as bs)\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  strict_sorted (interact as' bs')\n  length bs' \\<le> length as'\n  length as' \\<le> Suc (length bs')\n  length as = length as'\n  length bs = length bs'", "show ?case"], ["proof (prove)\nusing this:\n  0 = length as\n  concat as = concat as'\n  concat bs = concat bs'\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  strict_sorted (interact as bs)\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  strict_sorted (interact as' bs')\n  length bs' \\<le> length as'\n  length as' \\<le> Suc (length bs')\n  length as = length as'\n  length bs = length bs'\n\ngoal (1 subgoal):\n 1. as = as' \\<and> bs = bs'", "by auto"], ["proof (state)\nthis:\n  as = as' \\<and> bs = bs'\n\ngoal (1 subgoal):\n 1. \\<And>x as bs as' bs'.\n       \\<lbrakk>\\<And>as bs as' bs'.\n                   \\<lbrakk>x = length as; concat as = concat as';\n                    concat bs = concat bs'; as \\<in> lists (- {[]});\n                    bs \\<in> lists (- {[]}); strict_sorted (interact as bs);\n                    length bs \\<le> length as;\n                    length as \\<le> Suc (length bs);\n                    as' \\<in> lists (- {[]}); bs' \\<in> lists (- {[]});\n                    strict_sorted (interact as' bs');\n                    length bs' \\<le> length as';\n                    length as' \\<le> Suc (length bs');\n                    length as = length as'; length bs = length bs'\\<rbrakk>\n                   \\<Longrightarrow> as = as' \\<and> bs = bs';\n        Suc x = length as; concat as = concat as'; concat bs = concat bs';\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]});\n        strict_sorted (interact as bs); length bs \\<le> length as;\n        length as \\<le> Suc (length bs); as' \\<in> lists (- {[]});\n        bs' \\<in> lists (- {[]}); strict_sorted (interact as' bs');\n        length bs' \\<le> length as'; length as' \\<le> Suc (length bs');\n        length as = length as'; length bs = length bs'\\<rbrakk>\n       \\<Longrightarrow> as = as' \\<and> bs = bs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x as bs as' bs'.\n       \\<lbrakk>\\<And>as bs as' bs'.\n                   \\<lbrakk>x = length as; concat as = concat as';\n                    concat bs = concat bs'; as \\<in> lists (- {[]});\n                    bs \\<in> lists (- {[]}); strict_sorted (interact as bs);\n                    length bs \\<le> length as;\n                    length as \\<le> Suc (length bs);\n                    as' \\<in> lists (- {[]}); bs' \\<in> lists (- {[]});\n                    strict_sorted (interact as' bs');\n                    length bs' \\<le> length as';\n                    length as' \\<le> Suc (length bs');\n                    length as = length as'; length bs = length bs'\\<rbrakk>\n                   \\<Longrightarrow> as = as' \\<and> bs = bs';\n        Suc x = length as; concat as = concat as'; concat bs = concat bs';\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]});\n        strict_sorted (interact as bs); length bs \\<le> length as;\n        length as \\<le> Suc (length bs); as' \\<in> lists (- {[]});\n        bs' \\<in> lists (- {[]}); strict_sorted (interact as' bs');\n        length bs' \\<le> length as'; length as' \\<le> Suc (length bs');\n        length as = length as'; length bs = length bs'\\<rbrakk>\n       \\<Longrightarrow> as = as' \\<and> bs = bs'", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>k = length ?as; concat ?as = concat ?as';\n   concat ?bs = concat ?bs'; ?as \\<in> lists (- {[]});\n   ?bs \\<in> lists (- {[]}); strict_sorted (interact ?as ?bs);\n   length ?bs \\<le> length ?as; length ?as \\<le> Suc (length ?bs);\n   ?as' \\<in> lists (- {[]}); ?bs' \\<in> lists (- {[]});\n   strict_sorted (interact ?as' ?bs'); length ?bs' \\<le> length ?as';\n   length ?as' \\<le> Suc (length ?bs'); length ?as = length ?as';\n   length ?bs = length ?bs'\\<rbrakk>\n  \\<Longrightarrow> ?as = ?as' \\<and> ?bs = ?bs'\n  Suc k = length as\n  concat as = concat as'\n  concat bs = concat bs'\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  strict_sorted (interact as bs)\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  strict_sorted (interact as' bs')\n  length bs' \\<le> length as'\n  length as' \\<le> Suc (length bs')\n  length as = length as'\n  length bs = length bs'\n\ngoal (1 subgoal):\n 1. \\<And>x as bs as' bs'.\n       \\<lbrakk>\\<And>as bs as' bs'.\n                   \\<lbrakk>x = length as; concat as = concat as';\n                    concat bs = concat bs'; as \\<in> lists (- {[]});\n                    bs \\<in> lists (- {[]}); strict_sorted (interact as bs);\n                    length bs \\<le> length as;\n                    length as \\<le> Suc (length bs);\n                    as' \\<in> lists (- {[]}); bs' \\<in> lists (- {[]});\n                    strict_sorted (interact as' bs');\n                    length bs' \\<le> length as';\n                    length as' \\<le> Suc (length bs');\n                    length as = length as'; length bs = length bs'\\<rbrakk>\n                   \\<Longrightarrow> as = as' \\<and> bs = bs';\n        Suc x = length as; concat as = concat as'; concat bs = concat bs';\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]});\n        strict_sorted (interact as bs); length bs \\<le> length as;\n        length as \\<le> Suc (length bs); as' \\<in> lists (- {[]});\n        bs' \\<in> lists (- {[]}); strict_sorted (interact as' bs');\n        length bs' \\<le> length as'; length as' \\<le> Suc (length bs');\n        length as = length as'; length bs = length bs'\\<rbrakk>\n       \\<Longrightarrow> as = as' \\<and> bs = bs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. as = as' \\<and> bs = bs'", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> as = as' \\<and> bs = bs'\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> as = as' \\<and> bs = bs'\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  k = 0", "have \"length as = Suc 0\""], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. length as = Suc 0", "using Suc.hyps(2)"], ["proof (prove)\nusing this:\n  k = 0\n  Suc k = length as\n\ngoal (1 subgoal):\n 1. length as = Suc 0", "by auto"], ["proof (state)\nthis:\n  length as = Suc 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> as = as' \\<and> bs = bs'\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  length as = Suc 0", "obtain a a' where \"as = [a]\" \"as' = [a']\""], ["proof (prove)\nusing this:\n  length as = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>a a'.\n        \\<lbrakk>as = [a]; as' = [a']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>length as = length as'\\<close> length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  as = [a]\n  as' = [a']\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> as = as' \\<and> bs = bs'\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "with 0"], ["proof (chain)\npicking this:\n  k = 0\n  as = [a]\n  as' = [a']", "show ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n  as = [a]\n  as' = [a']\n\ngoal (1 subgoal):\n 1. as = as' \\<and> bs = bs'", "using Suc.prems"], ["proof (prove)\nusing this:\n  k = 0\n  as = [a]\n  as' = [a']\n  concat as = concat as'\n  concat bs = concat bs'\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  strict_sorted (interact as bs)\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  strict_sorted (interact as' bs')\n  length bs' \\<le> length as'\n  length as' \\<le> Suc (length bs')\n  length as = length as'\n  length bs = length bs'\n\ngoal (1 subgoal):\n 1. as = as' \\<and> bs = bs'", "apply (simp add: le_Suc_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k = 0; as = [a']; as' = [a']; a = a'; concat bs = concat bs';\n     a' \\<noteq> []; bs \\<in> lists (- {[]});\n     strict_sorted (a' @ concat bs'); bs' = [] \\<or> length bs' = Suc 0;\n     Suc 0 \\<le> length bs' \\<or> bs' = []; bs' \\<in> lists (- {[]});\n     length bs = length bs'\\<rbrakk>\n    \\<Longrightarrow> bs = bs'", "by (metis concat.simps length_0_conv length_Suc_conv self_append_conv)"], ["proof (state)\nthis:\n  as = as' \\<and> bs = bs'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  k = Suc k'", "obtain a cs b ds where eq: \"as = a#cs\" \"bs = b#ds\""], ["proof (prove)\nusing this:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. (\\<And>a cs b ds.\n        \\<lbrakk>as = a # cs; bs = b # ds\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.prems"], ["proof (prove)\nusing this:\n  k = Suc k'\n  concat as = concat as'\n  concat bs = concat bs'\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  strict_sorted (interact as bs)\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  strict_sorted (interact as' bs')\n  length bs' \\<le> length as'\n  length as' \\<le> Suc (length bs')\n  length as = length as'\n  length bs = length bs'\n\ngoal (1 subgoal):\n 1. (\\<And>a cs b ds.\n        \\<lbrakk>as = a # cs; bs = b # ds\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc.hyps(2) le0 list.exhaust list.size(3) not_less_eq_eq)"], ["proof (state)\nthis:\n  as = a # cs\n  bs = b # ds\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"length as' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as' \\<noteq> 0", "using Suc.hyps(2) Suc.prems(1) Suc.prems(3) interact_eq_Nil_iff"], ["proof (prove)\nusing this:\n  Suc k = length as\n  concat as = concat as'\n  as \\<in> lists (- {[]})\n  \\<lbrakk>?xs \\<in> lists (- {[]}); ?ys \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> (interact ?xs ?ys = []) = (?xs = [] \\<and> ?ys = [])\n\ngoal (1 subgoal):\n 1. length as' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length as' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  length as' \\<noteq> 0", "obtain a' cs' b' ds' where eq': \"as' = a'#cs'\" \"bs' = b'#ds'\""], ["proof (prove)\nusing this:\n  length as' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a' cs' b' ds'.\n        \\<lbrakk>as' = a' # cs'; bs' = b' # ds'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc.prems(14) eq(2) length_0_conv list.exhaust)"], ["proof (state)\nthis:\n  as' = a' # cs'\n  bs' = b' # ds'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "obtain k: \"k = length cs\" \"k \\<le> Suc (length ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>k = length cs; k \\<le> Suc (length ds)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eq \\<open>Suc k = length as\\<close> \\<open>length bs \\<le> length as\\<close> \\<open>length as \\<le> Suc (length bs)\\<close>"], ["proof (prove)\nusing this:\n  as = a # cs\n  bs = b # ds\n  Suc k = length as\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>k = length cs; k \\<le> Suc (length ds)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k = length cs\n  k \\<le> Suc (length ds)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "obtain [simp]: \"b \\<noteq> []\" \"b' \\<noteq> []\" \"a \\<noteq> []\" \"a' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>b \\<noteq> []; b' \\<noteq> []; a \\<noteq> [];\n      a' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.prems"], ["proof (prove)\nusing this:\n  concat as = concat as'\n  concat bs = concat bs'\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  strict_sorted (interact as bs)\n  length bs \\<le> length as\n  length as \\<le> Suc (length bs)\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  strict_sorted (interact as' bs')\n  length bs' \\<le> length as'\n  length as' \\<le> Suc (length bs')\n  length as = length as'\n  length bs = length bs'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>b \\<noteq> []; b' \\<noteq> []; a \\<noteq> [];\n      a' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: eq eq')"], ["proof (state)\nthis:\n  b \\<noteq> []\n  b' \\<noteq> []\n  a \\<noteq> []\n  a' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> []\n  b' \\<noteq> []\n  a \\<noteq> []\n  a' \\<noteq> []", "have \"hd b' = hd b\""], ["proof (prove)\nusing this:\n  b \\<noteq> []\n  b' \\<noteq> []\n  a \\<noteq> []\n  a' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd b' = hd b", "using Suc.prems(2)"], ["proof (prove)\nusing this:\n  b \\<noteq> []\n  b' \\<noteq> []\n  a \\<noteq> []\n  a' \\<noteq> []\n  concat bs = concat bs'\n\ngoal (1 subgoal):\n 1. hd b' = hd b", "by (metis concat.simps(2) eq'(2) eq(2) hd_append2)"], ["proof (state)\nthis:\n  hd b' = hd b\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have ss_ab: \"strict_sorted (concat as)\" \"strict_sorted (concat bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat as) &&& strict_sorted (concat bs)", "using strict_sorted_interact_imp_concat Suc.prems(5)"], ["proof (prove)\nusing this:\n  strict_sorted (interact ?as ?bs) \\<Longrightarrow>\n  strict_sorted (concat ?as) \\<and> strict_sorted (concat ?bs)\n  strict_sorted (interact as bs)\n\ngoal (1 subgoal):\n 1. strict_sorted (concat as) &&& strict_sorted (concat bs)", "by blast+"], ["proof (state)\nthis:\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b", "by (metis eq Suc.prems(5) append.assoc interact.simps(3) strict_sorted_append_iff)"], ["proof (state)\nthis:\n  a < b\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have sw_ab: \"sorted_wrt (<) (a @ b @ interact cs ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (a @ b @ interact cs ds)", "by (metis Suc.prems(5) eq interact.simps(3) strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  sorted_wrt (<) (a @ b @ interact cs ds)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  sorted_wrt (<) (a @ b @ interact cs ds)", "have \"hd b \\<notin> list.set (concat cs)\""], ["proof (prove)\nusing this:\n  sorted_wrt (<) (a @ b @ interact cs ds)\n\ngoal (1 subgoal):\n 1. hd b \\<notin> list.set (concat cs)", "by (metis Un_iff \\<open>b \\<noteq> []\\<close> list.set_sel(1) not_less_iff_gr_or_eq set_interact sorted_wrt_append)"], ["proof (state)\nthis:\n  hd b \\<notin> list.set (concat cs)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"b < concat cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < concat cs", "using eq \\<open>strict_sorted (interact as bs)\\<close>"], ["proof (prove)\nusing this:\n  as = a # cs\n  bs = b # ds\n  strict_sorted (interact as bs)\n\ngoal (1 subgoal):\n 1. b < concat cs", "apply (simp add: strict_sorted_append_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as = a # cs; bs = b # ds;\n     a < b @ interact cs ds \\<and>\n     strict_sorted a \\<and>\n     b < interact cs ds \\<and>\n     strict_sorted b \\<and> strict_sorted (interact cs ds)\\<rbrakk>\n    \\<Longrightarrow> b < concat cs", "by (metis Un_iff sw_ab last_in_set less_list_def list.set_sel(1) set_interact sorted_wrt_append)"], ["proof (state)\nthis:\n  b < concat cs\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"strict_sorted (a @ concat cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (a @ concat cs)", "using eq(1) ss_ab(1)"], ["proof (prove)\nusing this:\n  as = a # cs\n  strict_sorted (concat as)\n\ngoal (1 subgoal):\n 1. strict_sorted (a @ concat cs)", "by force"], ["proof (state)\nthis:\n  strict_sorted (a @ concat cs)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  strict_sorted (a @ concat cs)", "have b_cs: \"strict_sorted (b @ concat cs)\""], ["proof (prove)\nusing this:\n  strict_sorted (a @ concat cs)\n\ngoal (1 subgoal):\n 1. strict_sorted (b @ concat cs)", "by (metis \\<open>b < concat cs\\<close> strict_sorted_append_iff strict_sorted_sorted_wrt sw_ab)"], ["proof (state)\nthis:\n  strict_sorted (b @ concat cs)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"list.set a = list.set (concat as) \\<inter> {..< hd b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set a = list.set (concat as) \\<inter> {..<hd b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list.set a = list.set (concat as) \\<inter> {..<hd b}", "have \"x \\<in> list.set a\"\n        if \"x < hd b\" and \"l \\<in> list.set cs\" and \"x \\<in> list.set l\" for x l"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> list.set a", "using b_cs sorted_hd_le strict_sorted_imp_sorted that"], ["proof (prove)\nusing this:\n  strict_sorted (b @ concat cs)\n  \\<lbrakk>sorted ?xs; ?x \\<in> list.set ?xs\\<rbrakk>\n  \\<Longrightarrow> hd ?xs \\<le> ?x\n  strict_sorted ?xs \\<Longrightarrow> sorted ?xs\n  x < hd b\n  l \\<in> list.set cs\n  x \\<in> list.set l\n\ngoal (1 subgoal):\n 1. x \\<in> list.set a", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?x < hd b; ?l \\<in> list.set cs; ?x \\<in> list.set ?l\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> list.set a\n\ngoal (1 subgoal):\n 1. list.set a = list.set (concat as) \\<inter> {..<hd b}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x < hd b; ?l \\<in> list.set cs; ?x \\<in> list.set ?l\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> list.set a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < hd b; ?l \\<in> list.set cs; ?x \\<in> list.set ?l\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> list.set a\n\ngoal (1 subgoal):\n 1. list.set a = list.set (concat as) \\<inter> {..<hd b}", "using \\<open>b \\<noteq> []\\<close> sw_ab"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < hd b; ?l \\<in> list.set cs; ?x \\<in> list.set ?l\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> list.set a\n  b \\<noteq> []\n  sorted_wrt (<) (a @ b @ interact cs ds)\n\ngoal (1 subgoal):\n 1. list.set a = list.set (concat as) \\<inter> {..<hd b}", "by (force simp: strict_sorted_append_iff sorted_wrt_append eq)"], ["proof (state)\nthis:\n  list.set a = list.set (concat as) \\<inter> {..<hd b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list.set a = list.set (concat as) \\<inter> {..<hd b}\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "moreover"], ["proof (state)\nthis:\n  list.set a = list.set (concat as) \\<inter> {..<hd b}\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have ss_ab': \"strict_sorted (concat as')\" \"strict_sorted (concat bs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat as') &&& strict_sorted (concat bs')", "using strict_sorted_interact_imp_concat Suc.prems(10)"], ["proof (prove)\nusing this:\n  strict_sorted (interact ?as ?bs) \\<Longrightarrow>\n  strict_sorted (concat ?as) \\<and> strict_sorted (concat ?bs)\n  strict_sorted (interact as' bs')\n\ngoal (1 subgoal):\n 1. strict_sorted (concat as') &&& strict_sorted (concat bs')", "by blast+"], ["proof (state)\nthis:\n  strict_sorted (concat as')\n  strict_sorted (concat bs')\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"a' < b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' < b'", "by (metis eq' Suc.prems(10) append.assoc interact.simps(3) strict_sorted_append_iff)"], ["proof (state)\nthis:\n  a' < b'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have sw_ab': \"sorted_wrt (<) (a' @ b' @ interact cs' ds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (a' @ b' @ interact cs' ds')", "by (metis Suc.prems(10) eq' interact.simps(3) strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  sorted_wrt (<) (a' @ b' @ interact cs' ds')\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  sorted_wrt (<) (a' @ b' @ interact cs' ds')", "have \"hd b' \\<notin> list.set (concat cs')\""], ["proof (prove)\nusing this:\n  sorted_wrt (<) (a' @ b' @ interact cs' ds')\n\ngoal (1 subgoal):\n 1. hd b' \\<notin> list.set (concat cs')", "by (metis Un_iff \\<open>b' \\<noteq> []\\<close> list.set_sel(1) not_less_iff_gr_or_eq set_interact sorted_wrt_append)"], ["proof (state)\nthis:\n  hd b' \\<notin> list.set (concat cs')\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"b' < concat cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' < concat cs'", "using eq' \\<open>strict_sorted (interact as' bs')\\<close>"], ["proof (prove)\nusing this:\n  as' = a' # cs'\n  bs' = b' # ds'\n  strict_sorted (interact as' bs')\n\ngoal (1 subgoal):\n 1. b' < concat cs'", "apply (simp add: strict_sorted_append_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as' = a' # cs'; bs' = b' # ds';\n     a' < b' @ interact cs' ds' \\<and>\n     strict_sorted a' \\<and>\n     b' < interact cs' ds' \\<and>\n     strict_sorted b' \\<and> strict_sorted (interact cs' ds')\\<rbrakk>\n    \\<Longrightarrow> b' < concat cs'", "by (metis Un_iff last_in_set less_list_def list.set_sel(1) set_interact sorted_wrt_append sw_ab')"], ["proof (state)\nthis:\n  b' < concat cs'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"strict_sorted (a' @ concat cs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (a' @ concat cs')", "using eq'(1) ss_ab'(1)"], ["proof (prove)\nusing this:\n  as' = a' # cs'\n  strict_sorted (concat as')\n\ngoal (1 subgoal):\n 1. strict_sorted (a' @ concat cs')", "by force"], ["proof (state)\nthis:\n  strict_sorted (a' @ concat cs')\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "then"], ["proof (chain)\npicking this:\n  strict_sorted (a' @ concat cs')", "have b_cs': \"strict_sorted (b' @ concat cs')\""], ["proof (prove)\nusing this:\n  strict_sorted (a' @ concat cs')\n\ngoal (1 subgoal):\n 1. strict_sorted (b' @ concat cs')", "using \\<open>b' < concat cs'\\<close> eq'(2) ss_ab'(2) strict_sorted_append_iff"], ["proof (prove)\nusing this:\n  strict_sorted (a' @ concat cs')\n  b' < concat cs'\n  bs' = b' # ds'\n  strict_sorted (concat bs')\n  strict_sorted (?xs @ ?ys) =\n  (?xs < ?ys \\<and> strict_sorted ?xs \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. strict_sorted (b' @ concat cs')", "by auto"], ["proof (state)\nthis:\n  strict_sorted (b' @ concat cs')\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"list.set a' = list.set (concat as') \\<inter> {..< hd b'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set a' = list.set (concat as') \\<inter> {..<hd b'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list.set a' = list.set (concat as') \\<inter> {..<hd b'}", "have \"x \\<in> list.set a'\"\n        if \"x < hd b'\" and \"l \\<in> list.set cs'\" and \"x \\<in> list.set l\" for x l"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> list.set a'", "using b_cs' sorted_hd_le strict_sorted_imp_sorted that"], ["proof (prove)\nusing this:\n  strict_sorted (b' @ concat cs')\n  \\<lbrakk>sorted ?xs; ?x \\<in> list.set ?xs\\<rbrakk>\n  \\<Longrightarrow> hd ?xs \\<le> ?x\n  strict_sorted ?xs \\<Longrightarrow> sorted ?xs\n  x < hd b'\n  l \\<in> list.set cs'\n  x \\<in> list.set l\n\ngoal (1 subgoal):\n 1. x \\<in> list.set a'", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?x < hd b'; ?l \\<in> list.set cs'; ?x \\<in> list.set ?l\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> list.set a'\n\ngoal (1 subgoal):\n 1. list.set a' = list.set (concat as') \\<inter> {..<hd b'}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x < hd b'; ?l \\<in> list.set cs'; ?x \\<in> list.set ?l\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> list.set a'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < hd b'; ?l \\<in> list.set cs'; ?x \\<in> list.set ?l\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> list.set a'\n\ngoal (1 subgoal):\n 1. list.set a' = list.set (concat as') \\<inter> {..<hd b'}", "using \\<open>b' \\<noteq> []\\<close> sw_ab'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < hd b'; ?l \\<in> list.set cs'; ?x \\<in> list.set ?l\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> list.set a'\n  b' \\<noteq> []\n  sorted_wrt (<) (a' @ b' @ interact cs' ds')\n\ngoal (1 subgoal):\n 1. list.set a' = list.set (concat as') \\<inter> {..<hd b'}", "by (force simp: strict_sorted_append_iff sorted_wrt_append eq')"], ["proof (state)\nthis:\n  list.set a' = list.set (concat as') \\<inter> {..<hd b'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list.set a' = list.set (concat as') \\<inter> {..<hd b'}\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "ultimately"], ["proof (chain)\npicking this:\n  list.set a = list.set (concat as) \\<inter> {..<hd b}\n  list.set a' = list.set (concat as') \\<inter> {..<hd b'}", "have \"a=a'\""], ["proof (prove)\nusing this:\n  list.set a = list.set (concat as) \\<inter> {..<hd b}\n  list.set a' = list.set (concat as') \\<inter> {..<hd b'}\n\ngoal (1 subgoal):\n 1. a = a'", "by (metis Suc.prems(1) \\<open>hd b' = hd b\\<close> sorted_wrt_append strict_sorted_equal strict_sorted_sorted_wrt sw_ab sw_ab')"], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "moreover"], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have ccat_cs_cs': \"concat cs = concat cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat cs = concat cs'", "using Suc.prems(1) \\<open>a = a'\\<close> eq'(1) eq(1)"], ["proof (prove)\nusing this:\n  concat as = concat as'\n  a = a'\n  as' = a' # cs'\n  as = a # cs\n\ngoal (1 subgoal):\n 1. concat cs = concat cs'", "by fastforce"], ["proof (state)\nthis:\n  concat cs = concat cs'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"b=b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = b'", "proof (cases \"ds = [] \\<or> ds' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ds = [] \\<or> ds' = [] \\<Longrightarrow> b = b'\n 2. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "case True"], ["proof (state)\nthis:\n  ds = [] \\<or> ds' = []\n\ngoal (2 subgoals):\n 1. ds = [] \\<or> ds' = [] \\<Longrightarrow> b = b'\n 2. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  ds = [] \\<or> ds' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ds = [] \\<or> ds' = []\n\ngoal (1 subgoal):\n 1. b = b'", "using Suc.prems(14) Suc.prems(2) eq'(2) eq(2)"], ["proof (prove)\nusing this:\n  ds = [] \\<or> ds' = []\n  length bs = length bs'\n  concat bs = concat bs'\n  bs' = b' # ds'\n  bs = b # ds\n\ngoal (1 subgoal):\n 1. b = b'", "by auto"], ["proof (state)\nthis:\n  b = b'\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "case False"], ["proof (state)\nthis:\n  \\<not> (ds = [] \\<or> ds' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  \\<not> (ds = [] \\<or> ds' = [])", "have \"ds \\<noteq> []\" \"ds' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> (ds = [] \\<or> ds' = [])\n\ngoal (1 subgoal):\n 1. ds \\<noteq> [] &&& ds' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ds \\<noteq> []\n  ds' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "have \"strict_sorted b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted b", "by (metis Suc.prems(2) concat.simps(2) eq(2) ss_ab'(2) strict_sorted_append_iff)"], ["proof (state)\nthis:\n  strict_sorted b\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "moreover"], ["proof (state)\nthis:\n  strict_sorted b\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "have \"cs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs \\<noteq> []", "using k local.Suc"], ["proof (prove)\nusing this:\n  k = length cs\n  k \\<le> Suc (length ds)\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. cs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  cs \\<noteq> []", "obtain \"hd cs \\<noteq> []\" \"hd ds \\<noteq> []\""], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>hd cs \\<noteq> []; hd ds \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.prems(3) Suc.prems(4) eq list.set_sel(1)"], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  as = a # cs\n  bs = b # ds\n  ?a \\<noteq> [] \\<Longrightarrow> hd ?a \\<in> list.set ?a\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>hd cs \\<noteq> []; hd ds \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: \\<open>ds \\<noteq> []\\<close> mem_lists_non_Nil)"], ["proof (state)\nthis:\n  hd cs \\<noteq> []\n  hd ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  hd cs \\<noteq> []\n  hd ds \\<noteq> []", "have \"concat cs \\<noteq> []\""], ["proof (prove)\nusing this:\n  hd cs \\<noteq> []\n  hd ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. concat cs \\<noteq> []", "using \\<open>cs \\<noteq> []\\<close> hd_in_set"], ["proof (prove)\nusing this:\n  hd cs \\<noteq> []\n  hd ds \\<noteq> []\n  cs \\<noteq> []\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> list.set ?xs\n\ngoal (1 subgoal):\n 1. concat cs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  concat cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "have \"hd (concat cs) < hd (concat ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (concat cs) < hd (concat ds)", "using strict_sorted_interact_hd"], ["proof (prove)\nusing this:\n  \\<lbrakk>strict_sorted (interact ?cs ?ds); ?cs \\<noteq> [];\n   ?ds \\<noteq> []; hd ?cs \\<noteq> []; hd ?ds \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> hd (hd ?cs) < hd (hd ?ds)\n\ngoal (1 subgoal):\n 1. hd (concat cs) < hd (concat ds)", "by (metis \\<open>cs \\<noteq> []\\<close> \\<open>ds \\<noteq> []\\<close> \\<open>hd cs \\<noteq> []\\<close> \\<open>hd ds \\<noteq> []\\<close> hd_concat strict_sorted_append_iff strict_sorted_sorted_wrt sw_ab)"], ["proof (state)\nthis:\n  hd (concat cs) < hd (concat ds)\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  hd (concat cs) < hd (concat ds)", "have \"list.set b = list.set (concat bs) \\<inter> {..< hd (concat cs)}\""], ["proof (prove)\nusing this:\n  hd (concat cs) < hd (concat ds)\n\ngoal (1 subgoal):\n 1. list.set b = list.set (concat bs) \\<inter> {..<hd (concat cs)}", "using ss_ab"], ["proof (prove)\nusing this:\n  hd (concat cs) < hd (concat ds)\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n\ngoal (1 subgoal):\n 1. list.set b = list.set (concat bs) \\<inter> {..<hd (concat cs)}", "apply (auto simp: strict_sorted_append_iff eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>hd (concat cs) < hd (concat ds); a < concat cs;\n        b < concat ds; strict_sorted a; strict_sorted (concat cs);\n        strict_sorted b; strict_sorted (concat ds);\n        x \\<in> list.set b\\<rbrakk>\n       \\<Longrightarrow> x < hd (concat cs)\n 2. \\<And>x xa.\n       \\<lbrakk>hd (concat cs) < hd (concat ds); a < concat cs;\n        b < concat ds; strict_sorted a; strict_sorted (concat cs);\n        strict_sorted b; strict_sorted (concat ds); x < hd (concat cs);\n        xa \\<in> list.set ds; x \\<in> list.set xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> list.set b", "apply (metis \\<open>b < concat cs\\<close> \\<open>concat cs \\<noteq> []\\<close> hd_in_set sorted_wrt_append strict_sorted_append_iff strict_sorted_sorted_wrt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>hd (concat cs) < hd (concat ds); a < concat cs;\n        b < concat ds; strict_sorted a; strict_sorted (concat cs);\n        strict_sorted b; strict_sorted (concat ds); x < hd (concat cs);\n        xa \\<in> list.set ds; x \\<in> list.set xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> list.set b", "by (metis strict_sorted_iff UN_I dual_order.strict_trans2 order.asym set_concat sorted_hd_le)"], ["proof (state)\nthis:\n  list.set b = list.set (concat bs) \\<inter> {..<hd (concat cs)}\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "moreover"], ["proof (state)\nthis:\n  list.set b = list.set (concat bs) \\<inter> {..<hd (concat cs)}\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "have \"cs' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs' \\<noteq> []", "using k local.Suc \\<open>concat cs \\<noteq> []\\<close> ccat_cs_cs'"], ["proof (prove)\nusing this:\n  k = length cs\n  k \\<le> Suc (length ds)\n  k = Suc k'\n  concat cs \\<noteq> []\n  concat cs = concat cs'\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  cs' \\<noteq> []", "obtain \"hd cs' \\<noteq> []\" \"hd ds' \\<noteq> []\""], ["proof (prove)\nusing this:\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>hd cs' \\<noteq> []; hd ds' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.prems(8,9) \\<open>ds' \\<noteq> []\\<close> eq'(1) eq'(2) list.set_sel(1)"], ["proof (prove)\nusing this:\n  cs' \\<noteq> []\n  as' \\<in> lists (- {[]})\n  bs' \\<in> lists (- {[]})\n  ds' \\<noteq> []\n  as' = a' # cs'\n  bs' = b' # ds'\n  ?a \\<noteq> [] \\<Longrightarrow> hd ?a \\<in> list.set ?a\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>hd cs' \\<noteq> []; hd ds' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hd cs' \\<noteq> []\n  hd ds' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  hd cs' \\<noteq> []\n  hd ds' \\<noteq> []", "have \"concat cs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  hd cs' \\<noteq> []\n  hd ds' \\<noteq> []\n\ngoal (1 subgoal):\n 1. concat cs' \\<noteq> []", "using \\<open>cs' \\<noteq> []\\<close> hd_in_set"], ["proof (prove)\nusing this:\n  hd cs' \\<noteq> []\n  hd ds' \\<noteq> []\n  cs' \\<noteq> []\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> list.set ?xs\n\ngoal (1 subgoal):\n 1. concat cs' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  concat cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "have \"hd (concat cs') < hd (concat ds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (concat cs') < hd (concat ds')", "using strict_sorted_interact_hd"], ["proof (prove)\nusing this:\n  \\<lbrakk>strict_sorted (interact ?cs ?ds); ?cs \\<noteq> [];\n   ?ds \\<noteq> []; hd ?cs \\<noteq> []; hd ?ds \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> hd (hd ?cs) < hd (hd ?ds)\n\ngoal (1 subgoal):\n 1. hd (concat cs') < hd (concat ds')", "by (metis \\<open>cs' \\<noteq> []\\<close> \\<open>ds' \\<noteq> []\\<close> \\<open>hd cs' \\<noteq> []\\<close> \\<open>hd ds' \\<noteq> []\\<close> hd_concat strict_sorted_append_iff strict_sorted_sorted_wrt sw_ab')"], ["proof (state)\nthis:\n  hd (concat cs') < hd (concat ds')\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  hd (concat cs') < hd (concat ds')", "have \"list.set b' = list.set (concat bs') \\<inter> {..< hd (concat cs')}\""], ["proof (prove)\nusing this:\n  hd (concat cs') < hd (concat ds')\n\ngoal (1 subgoal):\n 1. list.set b' = list.set (concat bs') \\<inter> {..<hd (concat cs')}", "using ss_ab'"], ["proof (prove)\nusing this:\n  hd (concat cs') < hd (concat ds')\n  strict_sorted (concat as')\n  strict_sorted (concat bs')\n\ngoal (1 subgoal):\n 1. list.set b' = list.set (concat bs') \\<inter> {..<hd (concat cs')}", "apply (auto simp: strict_sorted_append_iff eq')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>hd (concat cs') < hd (concat ds'); a' < concat cs';\n        b' < concat ds'; strict_sorted a'; strict_sorted (concat cs');\n        strict_sorted b'; strict_sorted (concat ds');\n        x \\<in> list.set b'\\<rbrakk>\n       \\<Longrightarrow> x < hd (concat cs')\n 2. \\<And>x xa.\n       \\<lbrakk>hd (concat cs') < hd (concat ds'); a' < concat cs';\n        b' < concat ds'; strict_sorted a'; strict_sorted (concat cs');\n        strict_sorted b'; strict_sorted (concat ds'); x < hd (concat cs');\n        xa \\<in> list.set ds'; x \\<in> list.set xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> list.set b'", "apply (meson strict_sorted_iff \\<open>b' < concat cs'\\<close> \\<open>b' \\<noteq> []\\<close> \\<open>concat cs' \\<noteq> []\\<close> dual_order.strict_trans2 less_list_def sorted_le_last)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>hd (concat cs') < hd (concat ds'); a' < concat cs';\n        b' < concat ds'; strict_sorted a'; strict_sorted (concat cs');\n        strict_sorted b'; strict_sorted (concat ds'); x < hd (concat cs');\n        xa \\<in> list.set ds'; x \\<in> list.set xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> list.set b'", "by (metis strict_sorted_iff UN_I dual_order.strict_trans2 order.asym set_concat sorted_hd_le)"], ["proof (state)\nthis:\n  list.set b' = list.set (concat bs') \\<inter> {..<hd (concat cs')}\n\ngoal (1 subgoal):\n 1. \\<not> (ds = [] \\<or> ds' = []) \\<Longrightarrow> b = b'", "ultimately"], ["proof (chain)\npicking this:\n  strict_sorted b\n  list.set b = list.set (concat bs) \\<inter> {..<hd (concat cs)}\n  list.set b' = list.set (concat bs') \\<inter> {..<hd (concat cs')}", "show \"b = b'\""], ["proof (prove)\nusing this:\n  strict_sorted b\n  list.set b = list.set (concat bs) \\<inter> {..<hd (concat cs)}\n  list.set b' = list.set (concat bs') \\<inter> {..<hd (concat cs')}\n\ngoal (1 subgoal):\n 1. b = b'", "by (metis Suc.prems(2) ccat_cs_cs' strict_sorted_append_iff strict_sorted_equal strict_sorted_sorted_wrt sw_ab')"], ["proof (state)\nthis:\n  b = b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = b'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "moreover"], ["proof (state)\nthis:\n  b = b'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "have \"cs = cs' \\<and> ds = ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs = cs' \\<and> ds = ds'", "proof (rule Suc.hyps)"], ["proof (state)\ngoal (15 subgoals):\n 1. k = length cs\n 2. concat cs = concat cs'\n 3. concat ds = concat ds'\n 4. cs \\<in> lists (- {[]})\n 5. ds \\<in> lists (- {[]})\n 6. strict_sorted (interact cs ds)\n 7. length ds \\<le> length cs\n 8. length cs \\<le> Suc (length ds)\n 9. cs' \\<in> lists (- {[]})\n 10. ds' \\<in> lists (- {[]})\nA total of 15 subgoals...", "show \"k = length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = length cs", "using eq Suc.hyps(2)"], ["proof (prove)\nusing this:\n  as = a # cs\n  bs = b # ds\n  Suc k = length as\n\ngoal (1 subgoal):\n 1. k = length cs", "by auto[1]"], ["proof (state)\nthis:\n  k = length cs\n\ngoal (14 subgoals):\n 1. concat cs = concat cs'\n 2. concat ds = concat ds'\n 3. cs \\<in> lists (- {[]})\n 4. ds \\<in> lists (- {[]})\n 5. strict_sorted (interact cs ds)\n 6. length ds \\<le> length cs\n 7. length cs \\<le> Suc (length ds)\n 8. cs' \\<in> lists (- {[]})\n 9. ds' \\<in> lists (- {[]})\n 10. strict_sorted (interact cs' ds')\nA total of 14 subgoals...", "show \"concat ds = concat ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ds = concat ds'", "using Suc.prems(2) \\<open>b = b'\\<close> eq'(2) eq(2)"], ["proof (prove)\nusing this:\n  concat bs = concat bs'\n  b = b'\n  bs' = b' # ds'\n  bs = b # ds\n\ngoal (1 subgoal):\n 1. concat ds = concat ds'", "by auto"], ["proof (state)\nthis:\n  concat ds = concat ds'\n\ngoal (13 subgoals):\n 1. concat cs = concat cs'\n 2. cs \\<in> lists (- {[]})\n 3. ds \\<in> lists (- {[]})\n 4. strict_sorted (interact cs ds)\n 5. length ds \\<le> length cs\n 6. length cs \\<le> Suc (length ds)\n 7. cs' \\<in> lists (- {[]})\n 8. ds' \\<in> lists (- {[]})\n 9. strict_sorted (interact cs' ds')\n 10. length ds' \\<le> length cs'\nA total of 13 subgoals...", "show \"strict_sorted (interact cs ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact cs ds)", "using eq Suc.prems(5) strict_sorted_append_iff"], ["proof (prove)\nusing this:\n  as = a # cs\n  bs = b # ds\n  strict_sorted (interact as bs)\n  strict_sorted (?xs @ ?ys) =\n  (?xs < ?ys \\<and> strict_sorted ?xs \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. strict_sorted (interact cs ds)", "by auto"], ["proof (state)\nthis:\n  strict_sorted (interact cs ds)\n\ngoal (12 subgoals):\n 1. concat cs = concat cs'\n 2. cs \\<in> lists (- {[]})\n 3. ds \\<in> lists (- {[]})\n 4. length ds \\<le> length cs\n 5. length cs \\<le> Suc (length ds)\n 6. cs' \\<in> lists (- {[]})\n 7. ds' \\<in> lists (- {[]})\n 8. strict_sorted (interact cs' ds')\n 9. length ds' \\<le> length cs'\n 10. length cs' \\<le> Suc (length ds')\nA total of 12 subgoals...", "show \"length ds \\<le> length cs\" \"length cs \\<le> Suc (length ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ds \\<le> length cs &&& length cs \\<le> Suc (length ds)", "using eq Suc.hyps(2) Suc.prems(6) k"], ["proof (prove)\nusing this:\n  as = a # cs\n  bs = b # ds\n  Suc k = length as\n  length bs \\<le> length as\n  k = length cs\n  k \\<le> Suc (length ds)\n\ngoal (1 subgoal):\n 1. length ds \\<le> length cs &&& length cs \\<le> Suc (length ds)", "by auto"], ["proof (state)\nthis:\n  length ds \\<le> length cs\n  length cs \\<le> Suc (length ds)\n\ngoal (10 subgoals):\n 1. concat cs = concat cs'\n 2. cs \\<in> lists (- {[]})\n 3. ds \\<in> lists (- {[]})\n 4. cs' \\<in> lists (- {[]})\n 5. ds' \\<in> lists (- {[]})\n 6. strict_sorted (interact cs' ds')\n 7. length ds' \\<le> length cs'\n 8. length cs' \\<le> Suc (length ds')\n 9. length cs = length cs'\n 10. length ds = length ds'", "show \"strict_sorted (interact cs' ds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact cs' ds')", "using eq' Suc.prems(10) strict_sorted_append_iff"], ["proof (prove)\nusing this:\n  as' = a' # cs'\n  bs' = b' # ds'\n  strict_sorted (interact as' bs')\n  strict_sorted (?xs @ ?ys) =\n  (?xs < ?ys \\<and> strict_sorted ?xs \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. strict_sorted (interact cs' ds')", "by auto"], ["proof (state)\nthis:\n  strict_sorted (interact cs' ds')\n\ngoal (9 subgoals):\n 1. concat cs = concat cs'\n 2. cs \\<in> lists (- {[]})\n 3. ds \\<in> lists (- {[]})\n 4. cs' \\<in> lists (- {[]})\n 5. ds' \\<in> lists (- {[]})\n 6. length ds' \\<le> length cs'\n 7. length cs' \\<le> Suc (length ds')\n 8. length cs = length cs'\n 9. length ds = length ds'", "show \"length cs = length cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cs = length cs'", "using Suc.hyps(2) Suc.prems(13) eq'(1) k(1)"], ["proof (prove)\nusing this:\n  Suc k = length as\n  length as = length as'\n  as' = a' # cs'\n  k = length cs\n\ngoal (1 subgoal):\n 1. length cs = length cs'", "by force"], ["proof (state)\nthis:\n  length cs = length cs'\n\ngoal (8 subgoals):\n 1. concat cs = concat cs'\n 2. cs \\<in> lists (- {[]})\n 3. ds \\<in> lists (- {[]})\n 4. cs' \\<in> lists (- {[]})\n 5. ds' \\<in> lists (- {[]})\n 6. length ds' \\<le> length cs'\n 7. length cs' \\<le> Suc (length ds')\n 8. length ds = length ds'", "qed (use ccat_cs_cs' eq eq' Suc.prems in auto)"], ["proof (state)\nthis:\n  cs = cs' \\<and> ds = ds'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> as = as' \\<and> bs = bs'", "ultimately"], ["proof (chain)\npicking this:\n  a = a'\n  b = b'\n  cs = cs' \\<and> ds = ds'", "show ?thesis"], ["proof (prove)\nusing this:\n  a = a'\n  b = b'\n  cs = cs' \\<and> ds = ds'\n\ngoal (1 subgoal):\n 1. as = as' \\<and> bs = bs'", "by (simp add: \\<open>a = a'\\<close> \\<open>b = b'\\<close> eq eq')"], ["proof (state)\nthis:\n  as = as' \\<and> bs = bs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  as = as' \\<and> bs = bs'\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition Form_Body_unique:\n  assumes \"Form_Body ka kb xs ys zs\" \"Form_Body ka kb xs ys zs'\" and \"kb \\<le> ka\" \"ka \\<le> Suc kb\"\n  shows \"zs' = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs' = zs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zs' = zs", "obtain a as b bs c d\n      where xs: \"xs = concat (a#as)\" and ys: \"ys = concat (b#bs)\"\n        and ne: \"a#as \\<in> lists (- {[]})\" \"b#bs \\<in> lists (- {[]})\"\n        and len: \"length (a#as) = ka\" \"length (b#bs) = kb\"\n        and c: \"c = acc_lengths 0 (a#as)\"\n        and d: \"d = acc_lengths 0 (b#bs)\"\n        and Ueq: \"zs = concat [c, a, d, b] @ interact as bs\"\n        and ss_zs: \"strict_sorted zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a as b bs c d.\n        \\<lbrakk>xs = concat (a # as); ys = concat (b # bs);\n         a # as \\<in> lists (- {[]}); b # bs \\<in> lists (- {[]});\n         length (a # as) = ka; length (b # bs) = kb;\n         c = acc_lengths 0 (a # as); d = acc_lengths 0 (b # bs);\n         zs = concat [c, a, d, b] @ interact as bs;\n         strict_sorted zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Form_Body.cases [OF assms(1)]"], ["proof (prove)\nusing this:\n  (\\<And>xsa ysa a as b bs kaa kba c d zsa.\n      \\<lbrakk>ka = kaa; kb = kba; xs = xsa; ys = ysa; zs = zsa;\n       length xsa < length ysa; xsa = concat (a # as);\n       ysa = concat (b # bs); a # as \\<in> lists (- {[]});\n       b # bs \\<in> lists (- {[]}); length (a # as) = kaa;\n       length (b # bs) = kba; c = acc_lengths 0 (a # as);\n       d = acc_lengths 0 (b # bs);\n       zsa = concat [c, a, d, b] @ interact as bs;\n       strict_sorted zsa\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>a as b bs c d.\n        \\<lbrakk>xs = concat (a # as); ys = concat (b # bs);\n         a # as \\<in> lists (- {[]}); b # bs \\<in> lists (- {[]});\n         length (a # as) = ka; length (b # bs) = kb;\n         c = acc_lengths 0 (a # as); d = acc_lengths 0 (b # bs);\n         zs = concat [c, a, d, b] @ interact as bs;\n         strict_sorted zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types))"], ["proof (state)\nthis:\n  xs = concat (a # as)\n  ys = concat (b # bs)\n  a # as \\<in> lists (- {[]})\n  b # bs \\<in> lists (- {[]})\n  length (a # as) = ka\n  length (b # bs) = kb\n  c = acc_lengths 0 (a # as)\n  d = acc_lengths 0 (b # bs)\n  zs = concat [c, a, d, b] @ interact as bs\n  strict_sorted zs\n\ngoal (1 subgoal):\n 1. zs' = zs", "obtain a' as' b' bs' c' d'\n      where xs': \"xs = concat (a'#as')\" and ys': \"ys = concat (b'#bs')\"\n        and ne': \"a'#as' \\<in> lists (- {[]})\" \"b'#bs' \\<in> lists (- {[]})\"\n        and len': \"length (a'#as') = ka\" \"length (b'#bs') = kb\"\n        and c': \"c' = acc_lengths 0 (a'#as')\"\n        and d': \"d' = acc_lengths 0 (b'#bs')\"\n        and Ueq': \"zs' = concat [c', a', d', b'] @ interact as' bs'\"\n        and ss_zs': \"strict_sorted zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' as' b' bs' c' d'.\n        \\<lbrakk>xs = concat (a' # as'); ys = concat (b' # bs');\n         a' # as' \\<in> lists (- {[]}); b' # bs' \\<in> lists (- {[]});\n         length (a' # as') = ka; length (b' # bs') = kb;\n         c' = acc_lengths 0 (a' # as'); d' = acc_lengths 0 (b' # bs');\n         zs' = concat [c', a', d', b'] @ interact as' bs';\n         strict_sorted zs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Form_Body.cases [OF assms(2)]"], ["proof (prove)\nusing this:\n  (\\<And>xsa ysa a as b bs kaa kba c d zs.\n      \\<lbrakk>ka = kaa; kb = kba; xs = xsa; ys = ysa; zs' = zs;\n       length xsa < length ysa; xsa = concat (a # as);\n       ysa = concat (b # bs); a # as \\<in> lists (- {[]});\n       b # bs \\<in> lists (- {[]}); length (a # as) = kaa;\n       length (b # bs) = kba; c = acc_lengths 0 (a # as);\n       d = acc_lengths 0 (b # bs);\n       zs = concat [c, a, d, b] @ interact as bs; strict_sorted zs\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>a' as' b' bs' c' d'.\n        \\<lbrakk>xs = concat (a' # as'); ys = concat (b' # bs');\n         a' # as' \\<in> lists (- {[]}); b' # bs' \\<in> lists (- {[]});\n         length (a' # as') = ka; length (b' # bs') = kb;\n         c' = acc_lengths 0 (a' # as'); d' = acc_lengths 0 (b' # bs');\n         zs' = concat [c', a', d', b'] @ interact as' bs';\n         strict_sorted zs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types))"], ["proof (state)\nthis:\n  xs = concat (a' # as')\n  ys = concat (b' # bs')\n  a' # as' \\<in> lists (- {[]})\n  b' # bs' \\<in> lists (- {[]})\n  length (a' # as') = ka\n  length (b' # bs') = kb\n  c' = acc_lengths 0 (a' # as')\n  d' = acc_lengths 0 (b' # bs')\n  zs' = concat [c', a', d', b'] @ interact as' bs'\n  strict_sorted zs'\n\ngoal (1 subgoal):\n 1. zs' = zs", "have [simp]: \"length c = length c'\" \"length d = length d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length c = length c' &&& length d = length d'", "using c c' d d' len' len"], ["proof (prove)\nusing this:\n  c = acc_lengths 0 (a # as)\n  c' = acc_lengths 0 (a' # as')\n  d = acc_lengths 0 (b # bs)\n  d' = acc_lengths 0 (b' # bs')\n  length (a' # as') = ka\n  length (b' # bs') = kb\n  length (a # as) = ka\n  length (b # bs) = kb\n\ngoal (1 subgoal):\n 1. length c = length c' &&& length d = length d'", "by auto"], ["proof (state)\nthis:\n  length c = length c'\n  length d = length d'\n\ngoal (1 subgoal):\n 1. zs' = zs", "have \"a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b", "using ss_zs"], ["proof (prove)\nusing this:\n  strict_sorted zs\n\ngoal (1 subgoal):\n 1. a < b", "apply (simp add: Ueq strict_sorted_append_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c < a @ d @ b @ interact as bs \\<and>\n    strict_sorted c \\<and>\n    a < d @ b @ interact as bs \\<and>\n    strict_sorted a \\<and>\n    d < b @ interact as bs \\<and>\n    strict_sorted d \\<and>\n    b < interact as bs \\<and>\n    strict_sorted b \\<and> strict_sorted (interact as bs) \\<Longrightarrow>\n    a < b", "by (metis strict_sorted_iff append.assoc d length_0_conv length_acc_lengths list.distinct(1) strict_sorted_append_iff sorted_trans)"], ["proof (state)\nthis:\n  a < b\n\ngoal (1 subgoal):\n 1. zs' = zs", "have \"a' < b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' < b'", "using ss_zs'"], ["proof (prove)\nusing this:\n  strict_sorted zs'\n\ngoal (1 subgoal):\n 1. a' < b'", "apply (simp add: Ueq' strict_sorted_append_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c' < a' @ d' @ b' @ interact as' bs' \\<and>\n    strict_sorted c' \\<and>\n    a' < d' @ b' @ interact as' bs' \\<and>\n    strict_sorted a' \\<and>\n    d' < b' @ interact as' bs' \\<and>\n    strict_sorted d' \\<and>\n    b' < interact as' bs' \\<and>\n    strict_sorted b' \\<and>\n    strict_sorted (interact as' bs') \\<Longrightarrow>\n    a' < b'", "by (metis strict_sorted_iff append.assoc d' length_0_conv length_acc_lengths list.distinct(1) strict_sorted_append_iff sorted_trans)"], ["proof (state)\nthis:\n  a' < b'\n\ngoal (1 subgoal):\n 1. zs' = zs", "have \"a#as = a'#as' \\<and> b#bs = b'#bs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # as = a' # as' \\<and> b # bs = b' # bs'", "proof (rule interaction_scheme_unique_aux)"], ["proof (state)\ngoal (14 subgoals):\n 1. concat (a # as) = concat (a' # as')\n 2. concat (b # bs) = concat (b' # bs')\n 3. a # as \\<in> lists (- {[]})\n 4. b # bs \\<in> lists (- {[]})\n 5. strict_sorted (interact (a # as) (b # bs))\n 6. length (b # bs) \\<le> length (a # as)\n 7. length (a # as) \\<le> Suc (length (b # bs))\n 8. a' # as' \\<in> lists (- {[]})\n 9. b' # bs' \\<in> lists (- {[]})\n 10. strict_sorted (interact (a' # as') (b' # bs'))\nA total of 14 subgoals...", "show \"concat (a # as) = concat (a' # as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (a # as) = concat (a' # as')", "using xs xs'"], ["proof (prove)\nusing this:\n  xs = concat (a # as)\n  xs = concat (a' # as')\n\ngoal (1 subgoal):\n 1. concat (a # as) = concat (a' # as')", "by blast"], ["proof (state)\nthis:\n  concat (a # as) = concat (a' # as')\n\ngoal (13 subgoals):\n 1. concat (b # bs) = concat (b' # bs')\n 2. a # as \\<in> lists (- {[]})\n 3. b # bs \\<in> lists (- {[]})\n 4. strict_sorted (interact (a # as) (b # bs))\n 5. length (b # bs) \\<le> length (a # as)\n 6. length (a # as) \\<le> Suc (length (b # bs))\n 7. a' # as' \\<in> lists (- {[]})\n 8. b' # bs' \\<in> lists (- {[]})\n 9. strict_sorted (interact (a' # as') (b' # bs'))\n 10. length (b' # bs') \\<le> length (a' # as')\nA total of 13 subgoals...", "show \"concat (b # bs) = concat (b' # bs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (b # bs) = concat (b' # bs')", "using ys ys'"], ["proof (prove)\nusing this:\n  ys = concat (b # bs)\n  ys = concat (b' # bs')\n\ngoal (1 subgoal):\n 1. concat (b # bs) = concat (b' # bs')", "by blast"], ["proof (state)\nthis:\n  concat (b # bs) = concat (b' # bs')\n\ngoal (12 subgoals):\n 1. a # as \\<in> lists (- {[]})\n 2. b # bs \\<in> lists (- {[]})\n 3. strict_sorted (interact (a # as) (b # bs))\n 4. length (b # bs) \\<le> length (a # as)\n 5. length (a # as) \\<le> Suc (length (b # bs))\n 6. a' # as' \\<in> lists (- {[]})\n 7. b' # bs' \\<in> lists (- {[]})\n 8. strict_sorted (interact (a' # as') (b' # bs'))\n 9. length (b' # bs') \\<le> length (a' # as')\n 10. length (a' # as') \\<le> Suc (length (b' # bs'))\nA total of 12 subgoals...", "show \"a # as \\<in> lists (- {[]})\" \"b # bs \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # as \\<in> lists (- {[]}) &&& b # bs \\<in> lists (- {[]})", "using ne"], ["proof (prove)\nusing this:\n  a # as \\<in> lists (- {[]})\n  b # bs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. a # as \\<in> lists (- {[]}) &&& b # bs \\<in> lists (- {[]})", "by auto"], ["proof (state)\nthis:\n  a # as \\<in> lists (- {[]})\n  b # bs \\<in> lists (- {[]})\n\ngoal (10 subgoals):\n 1. strict_sorted (interact (a # as) (b # bs))\n 2. length (b # bs) \\<le> length (a # as)\n 3. length (a # as) \\<le> Suc (length (b # bs))\n 4. a' # as' \\<in> lists (- {[]})\n 5. b' # bs' \\<in> lists (- {[]})\n 6. strict_sorted (interact (a' # as') (b' # bs'))\n 7. length (b' # bs') \\<le> length (a' # as')\n 8. length (a' # as') \\<le> Suc (length (b' # bs'))\n 9. length (a # as) = length (a' # as')\n 10. length (b # bs) = length (b' # bs')", "show \"strict_sorted (interact (a # as) (b # bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact (a # as) (b # bs))", "using ss_zs \\<open>a < b\\<close>"], ["proof (prove)\nusing this:\n  strict_sorted zs\n  a < b\n\ngoal (1 subgoal):\n 1. strict_sorted (interact (a # as) (b # bs))", "apply (simp add: Ueq strict_sorted_append_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c < a @ d @ b @ interact as bs \\<and>\n             strict_sorted c \\<and>\n             a < d @ b @ interact as bs \\<and>\n             strict_sorted a \\<and>\n             d < b @ interact as bs \\<and>\n             strict_sorted d \\<and>\n             b < interact as bs \\<and>\n             strict_sorted b \\<and> strict_sorted (interact as bs);\n     a < b\\<rbrakk>\n    \\<Longrightarrow> a < b @ interact as bs", "by (metis strict_sorted_iff append.assoc append.left_neutral strict_sorted_append_iff sorted_trans)"], ["proof (state)\nthis:\n  strict_sorted (interact (a # as) (b # bs))\n\ngoal (9 subgoals):\n 1. length (b # bs) \\<le> length (a # as)\n 2. length (a # as) \\<le> Suc (length (b # bs))\n 3. a' # as' \\<in> lists (- {[]})\n 4. b' # bs' \\<in> lists (- {[]})\n 5. strict_sorted (interact (a' # as') (b' # bs'))\n 6. length (b' # bs') \\<le> length (a' # as')\n 7. length (a' # as') \\<le> Suc (length (b' # bs'))\n 8. length (a # as) = length (a' # as')\n 9. length (b # bs) = length (b' # bs')", "show \"length (b # bs) \\<le> length (a # as)\" \"length (b' # bs') \\<le> length (a' # as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (b # bs) \\<le> length (a # as) &&&\n    length (b' # bs') \\<le> length (a' # as')", "using \\<open>kb \\<le> ka\\<close> len len'"], ["proof (prove)\nusing this:\n  kb \\<le> ka\n  length (a # as) = ka\n  length (b # bs) = kb\n  length (a' # as') = ka\n  length (b' # bs') = kb\n\ngoal (1 subgoal):\n 1. length (b # bs) \\<le> length (a # as) &&&\n    length (b' # bs') \\<le> length (a' # as')", "by auto"], ["proof (state)\nthis:\n  length (b # bs) \\<le> length (a # as)\n  length (b' # bs') \\<le> length (a' # as')\n\ngoal (7 subgoals):\n 1. length (a # as) \\<le> Suc (length (b # bs))\n 2. a' # as' \\<in> lists (- {[]})\n 3. b' # bs' \\<in> lists (- {[]})\n 4. strict_sorted (interact (a' # as') (b' # bs'))\n 5. length (a' # as') \\<le> Suc (length (b' # bs'))\n 6. length (a # as) = length (a' # as')\n 7. length (b # bs) = length (b' # bs')", "show \"length (a # as) \\<le> Suc (length (b # bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (a # as) \\<le> Suc (length (b # bs))", "using \\<open>ka \\<le> Suc kb\\<close> len"], ["proof (prove)\nusing this:\n  ka \\<le> Suc kb\n  length (a # as) = ka\n  length (b # bs) = kb\n\ngoal (1 subgoal):\n 1. length (a # as) \\<le> Suc (length (b # bs))", "by linarith"], ["proof (state)\nthis:\n  length (a # as) \\<le> Suc (length (b # bs))\n\ngoal (6 subgoals):\n 1. a' # as' \\<in> lists (- {[]})\n 2. b' # bs' \\<in> lists (- {[]})\n 3. strict_sorted (interact (a' # as') (b' # bs'))\n 4. length (a' # as') \\<le> Suc (length (b' # bs'))\n 5. length (a # as) = length (a' # as')\n 6. length (b # bs) = length (b' # bs')", "then"], ["proof (chain)\npicking this:\n  length (a # as) \\<le> Suc (length (b # bs))", "show \"length (a' # as') \\<le> Suc (length (b' # bs'))\""], ["proof (prove)\nusing this:\n  length (a # as) \\<le> Suc (length (b # bs))\n\ngoal (1 subgoal):\n 1. length (a' # as') \\<le> Suc (length (b' # bs'))", "using len len'"], ["proof (prove)\nusing this:\n  length (a # as) \\<le> Suc (length (b # bs))\n  length (a # as) = ka\n  length (b # bs) = kb\n  length (a' # as') = ka\n  length (b' # bs') = kb\n\ngoal (1 subgoal):\n 1. length (a' # as') \\<le> Suc (length (b' # bs'))", "by fastforce"], ["proof (state)\nthis:\n  length (a' # as') \\<le> Suc (length (b' # bs'))\n\ngoal (5 subgoals):\n 1. a' # as' \\<in> lists (- {[]})\n 2. b' # bs' \\<in> lists (- {[]})\n 3. strict_sorted (interact (a' # as') (b' # bs'))\n 4. length (a # as) = length (a' # as')\n 5. length (b # bs) = length (b' # bs')", "show \"a' # as' \\<in> lists (- {[]})\" \"b' # bs' \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' # as' \\<in> lists (- {[]}) &&& b' # bs' \\<in> lists (- {[]})", "using ne'"], ["proof (prove)\nusing this:\n  a' # as' \\<in> lists (- {[]})\n  b' # bs' \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. a' # as' \\<in> lists (- {[]}) &&& b' # bs' \\<in> lists (- {[]})", "by auto"], ["proof (state)\nthis:\n  a' # as' \\<in> lists (- {[]})\n  b' # bs' \\<in> lists (- {[]})\n\ngoal (3 subgoals):\n 1. strict_sorted (interact (a' # as') (b' # bs'))\n 2. length (a # as) = length (a' # as')\n 3. length (b # bs) = length (b' # bs')", "show \"strict_sorted (interact (a' # as') (b' # bs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact (a' # as') (b' # bs'))", "using ss_zs' \\<open>a' < b'\\<close>"], ["proof (prove)\nusing this:\n  strict_sorted zs'\n  a' < b'\n\ngoal (1 subgoal):\n 1. strict_sorted (interact (a' # as') (b' # bs'))", "apply (simp add: Ueq' strict_sorted_append_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c' < a' @ d' @ b' @ interact as' bs' \\<and>\n             strict_sorted c' \\<and>\n             a' < d' @ b' @ interact as' bs' \\<and>\n             strict_sorted a' \\<and>\n             d' < b' @ interact as' bs' \\<and>\n             strict_sorted d' \\<and>\n             b' < interact as' bs' \\<and>\n             strict_sorted b' \\<and> strict_sorted (interact as' bs');\n     a' < b'\\<rbrakk>\n    \\<Longrightarrow> a' < b' @ interact as' bs'", "by (metis strict_sorted_iff append.assoc append.left_neutral strict_sorted_append_iff sorted_trans)"], ["proof (state)\nthis:\n  strict_sorted (interact (a' # as') (b' # bs'))\n\ngoal (2 subgoals):\n 1. length (a # as) = length (a' # as')\n 2. length (b # bs) = length (b' # bs')", "show \"length (a # as) = length (a' # as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (a # as) = length (a' # as')", "using len'(1) len(1)"], ["proof (prove)\nusing this:\n  length (a' # as') = ka\n  length (a # as) = ka\n\ngoal (1 subgoal):\n 1. length (a # as) = length (a' # as')", "by blast"], ["proof (state)\nthis:\n  length (a # as) = length (a' # as')\n\ngoal (1 subgoal):\n 1. length (b # bs) = length (b' # bs')", "show \"length (b # bs) = length (b' # bs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (b # bs) = length (b' # bs')", "using len'(2) len(2)"], ["proof (prove)\nusing this:\n  length (b' # bs') = kb\n  length (b # bs) = kb\n\ngoal (1 subgoal):\n 1. length (b # bs) = length (b' # bs')", "by blast"], ["proof (state)\nthis:\n  length (b # bs) = length (b' # bs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # as = a' # as' \\<and> b # bs = b' # bs'\n\ngoal (1 subgoal):\n 1. zs' = zs", "then"], ["proof (chain)\npicking this:\n  a # as = a' # as' \\<and> b # bs = b' # bs'", "show ?thesis"], ["proof (prove)\nusing this:\n  a # as = a' # as' \\<and> b # bs = b' # bs'\n\ngoal (1 subgoal):\n 1. zs' = zs", "using Ueq Ueq' c c' d d'"], ["proof (prove)\nusing this:\n  a # as = a' # as' \\<and> b # bs = b' # bs'\n  zs = concat [c, a, d, b] @ interact as bs\n  zs' = concat [c', a', d', b'] @ interact as' bs'\n  c = acc_lengths 0 (a # as)\n  c' = acc_lengths 0 (a' # as')\n  d = acc_lengths 0 (b # bs)\n  d' = acc_lengths 0 (b' # bs')\n\ngoal (1 subgoal):\n 1. zs' = zs", "by blast"], ["proof (state)\nthis:\n  zs' = zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Form_Body_imp_inter_scheme:\n  assumes \"Form_Body ka kb xs ys zs\" and \"0 < kb\" \"kb \\<le> ka\" \"ka \\<le> Suc kb\"\n  shows \"zs = inter_scheme ((ka+kb) - Suc 0) {xs,ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "have \"length xs < length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs < length ys", "by (meson Form_Body_length assms(1))"], ["proof (state)\nthis:\n  length xs < length ys\n\ngoal (1 subgoal):\n 1. zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "have [simp]: \"a + a = b + b \\<longleftrightarrow> a=b\"  \"a + a - Suc 0 = b + b - Suc 0 \\<longleftrightarrow> a=b\" for a b::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + a = b + b) = (a = b) &&& (a + a - Suc 0 = b + b - Suc 0) = (a = b)", "by auto"], ["proof (state)\nthis:\n  (?a + ?a = ?b + ?b) = (?a = ?b)\n  (?a + ?a - Suc 0 = ?b + ?b - Suc 0) = (?a = ?b)\n\ngoal (1 subgoal):\n 1. zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "proof (cases \"ka = kb\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ka = kb \\<Longrightarrow> zs = inter_scheme (ka + kb - Suc 0) {xs, ys}\n 2. ka \\<noteq> kb \\<Longrightarrow>\n    zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "case True"], ["proof (state)\nthis:\n  ka = kb\n\ngoal (2 subgoals):\n 1. ka = kb \\<Longrightarrow> zs = inter_scheme (ka + kb - Suc 0) {xs, ys}\n 2. ka \\<noteq> kb \\<Longrightarrow>\n    zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "unfolding inter_scheme_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs =\n    (SOME zs.\n        \\<exists>k xsa ysa.\n           0 < ka + kb - Suc 0 \\<and>\n           (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n            {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zs \\<or>\n            ka + kb - Suc 0 = 2 * k \\<and>\n            {xs, ys} = {xsa, ysa} \\<and> Form_Body (Suc k) k xsa ysa zs))", "apply (rule some_equality [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>k xsa ysa.\n       0 < ka + kb - Suc 0 \\<and>\n       (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n        {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zs \\<or>\n        ka + kb - Suc 0 = 2 * k \\<and>\n        {xs, ys} = {xsa, ysa} \\<and> Form_Body (Suc k) k xsa ysa zs)\n 2. \\<And>zsa.\n       \\<exists>k xsa ysa.\n          0 < ka + kb - Suc 0 \\<and>\n          (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n           {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zsa \\<or>\n           ka + kb - Suc 0 = 2 * k \\<and>\n           {xs, ys} = {xsa, ysa} \\<and>\n           Form_Body (Suc k) k xsa ysa zsa) \\<Longrightarrow>\n       zsa = zs", "using assms True mult_2 not_gr0 one_is_add"], ["proof (prove)\nusing this:\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  ka = kb\n  (2::?'a) * ?z = ?z + ?z\n  (\\<not> 0 < ?n) = (?n = 0)\n  (Suc 0 = ?m + ?n) =\n  (?m = Suc 0 \\<and> ?n = 0 \\<or> ?m = 0 \\<and> ?n = Suc 0)\n\ngoal (2 subgoals):\n 1. \\<exists>k xsa ysa.\n       0 < ka + kb - Suc 0 \\<and>\n       (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n        {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zs \\<or>\n        ka + kb - Suc 0 = 2 * k \\<and>\n        {xs, ys} = {xsa, ysa} \\<and> Form_Body (Suc k) k xsa ysa zs)\n 2. \\<And>zsa.\n       \\<exists>k xsa ysa.\n          0 < ka + kb - Suc 0 \\<and>\n          (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n           {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zsa \\<or>\n           ka + kb - Suc 0 = 2 * k \\<and>\n           {xs, ys} = {xsa, ysa} \\<and>\n           Form_Body (Suc k) k xsa ysa zsa) \\<Longrightarrow>\n       zsa = zs", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zsa.\n       \\<exists>k xsa ysa.\n          0 < ka + kb - Suc 0 \\<and>\n          (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n           {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zsa \\<or>\n           ka + kb - Suc 0 = 2 * k \\<and>\n           {xs, ys} = {xsa, ysa} \\<and>\n           Form_Body (Suc k) k xsa ysa zsa) \\<Longrightarrow>\n       zsa = zs", "using assms \\<open>length xs < length ys\\<close>"], ["proof (prove)\nusing this:\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  length xs < length ys\n\ngoal (1 subgoal):\n 1. \\<And>zsa.\n       \\<exists>k xsa ysa.\n          0 < ka + kb - Suc 0 \\<and>\n          (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n           {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zsa \\<or>\n           ka + kb - Suc 0 = 2 * k \\<and>\n           {xs, ys} = {xsa, ysa} \\<and>\n           Form_Body (Suc k) k xsa ysa zsa) \\<Longrightarrow>\n       zsa = zs", "apply (auto simp: True mult_2 Set.doubleton_eq_iff Form_Body_unique dest: Form_Body_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zsa k.\n       \\<lbrakk>Form_Body kb kb xs ys zs; 0 < kb; length xs < length ys;\n        kb + kb - Suc 0 = k + k; Form_Body (Suc k) k xs ys zsa\\<rbrakk>\n       \\<Longrightarrow> zsa = zs", "by presburger"], ["proof (state)\nthis:\n  zs = inter_scheme (ka + kb - Suc 0) {xs, ys}\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "case False"], ["proof (state)\nthis:\n  ka \\<noteq> kb\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "then"], ["proof (chain)\npicking this:\n  ka \\<noteq> kb", "have eq: \"ka = Suc kb\""], ["proof (prove)\nusing this:\n  ka \\<noteq> kb\n\ngoal (1 subgoal):\n 1. ka = Suc kb", "using assms"], ["proof (prove)\nusing this:\n  ka \\<noteq> kb\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. ka = Suc kb", "by linarith"], ["proof (state)\nthis:\n  ka = Suc kb\n\ngoal (1 subgoal):\n 1. ka \\<noteq> kb \\<Longrightarrow>\n    zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs = inter_scheme (ka + kb - Suc 0) {xs, ys}", "unfolding inter_scheme_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs =\n    (SOME zs.\n        \\<exists>k xsa ysa.\n           0 < ka + kb - Suc 0 \\<and>\n           (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n            {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zs \\<or>\n            ka + kb - Suc 0 = 2 * k \\<and>\n            {xs, ys} = {xsa, ysa} \\<and> Form_Body (Suc k) k xsa ysa zs))", "apply (rule some_equality [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>k xsa ysa.\n       0 < ka + kb - Suc 0 \\<and>\n       (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n        {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zs \\<or>\n        ka + kb - Suc 0 = 2 * k \\<and>\n        {xs, ys} = {xsa, ysa} \\<and> Form_Body (Suc k) k xsa ysa zs)\n 2. \\<And>zsa.\n       \\<exists>k xsa ysa.\n          0 < ka + kb - Suc 0 \\<and>\n          (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n           {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zsa \\<or>\n           ka + kb - Suc 0 = 2 * k \\<and>\n           {xs, ys} = {xsa, ysa} \\<and>\n           Form_Body (Suc k) k xsa ysa zsa) \\<Longrightarrow>\n       zsa = zs", "using assms False mult_2 one_is_add eq"], ["proof (prove)\nusing this:\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  ka \\<noteq> kb\n  (2::?'a) * ?z = ?z + ?z\n  (Suc 0 = ?m + ?n) =\n  (?m = Suc 0 \\<and> ?n = 0 \\<or> ?m = 0 \\<and> ?n = Suc 0)\n  ka = Suc kb\n\ngoal (2 subgoals):\n 1. \\<exists>k xsa ysa.\n       0 < ka + kb - Suc 0 \\<and>\n       (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n        {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zs \\<or>\n        ka + kb - Suc 0 = 2 * k \\<and>\n        {xs, ys} = {xsa, ysa} \\<and> Form_Body (Suc k) k xsa ysa zs)\n 2. \\<And>zsa.\n       \\<exists>k xsa ysa.\n          0 < ka + kb - Suc 0 \\<and>\n          (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n           {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zsa \\<or>\n           ka + kb - Suc 0 = 2 * k \\<and>\n           {xs, ys} = {xsa, ysa} \\<and>\n           Form_Body (Suc k) k xsa ysa zsa) \\<Longrightarrow>\n       zsa = zs", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zsa.\n       \\<exists>k xsa ysa.\n          0 < ka + kb - Suc 0 \\<and>\n          (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n           {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zsa \\<or>\n           ka + kb - Suc 0 = 2 * k \\<and>\n           {xs, ys} = {xsa, ysa} \\<and>\n           Form_Body (Suc k) k xsa ysa zsa) \\<Longrightarrow>\n       zsa = zs", "using assms \\<open>length xs < length ys\\<close>"], ["proof (prove)\nusing this:\n  Form_Body ka kb xs ys zs\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n  length xs < length ys\n\ngoal (1 subgoal):\n 1. \\<And>zsa.\n       \\<exists>k xsa ysa.\n          0 < ka + kb - Suc 0 \\<and>\n          (ka + kb - Suc 0 = 2 * k - 1 \\<and>\n           {xs, ys} = {xsa, ysa} \\<and> Form_Body k k xsa ysa zsa \\<or>\n           ka + kb - Suc 0 = 2 * k \\<and>\n           {xs, ys} = {xsa, ysa} \\<and>\n           Form_Body (Suc k) k xsa ysa zsa) \\<Longrightarrow>\n       zsa = zs", "apply (auto simp: eq mult_2 Set.doubleton_eq_iff Form_Body_unique dest: Form_Body_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zsa k.\n       \\<lbrakk>Form_Body (Suc kb) kb xs ys zs; 0 < kb;\n        length xs < length ys; kb + kb = k + k - Suc 0;\n        Form_Body k k xs ys zsa\\<rbrakk>\n       \\<Longrightarrow> zsa = zs", "by presburger"], ["proof (state)\nthis:\n  zs = inter_scheme (ka + kb - Suc 0) {xs, ys}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zs = inter_scheme (ka + kb - Suc 0) {xs, ys}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>For Lemma 3.8 AND PROBABLY 3.7\\<close>"], ["", "definition grab :: \"nat set \\<Rightarrow> nat \\<Rightarrow> nat set \\<times> nat set\"\n  where \"grab N n \\<equiv> (N \\<inter> enumerate N ` {..<n}, N \\<inter> {enumerate N n..})\""], ["", "lemma grab_0 [simp]: \"grab N 0 = ({}, N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grab N 0 = ({}, N)", "by (fastforce simp add: grab_def enumerate_0 Least_le)"], ["", "lemma less_sets_grab:\n  \"infinite N \\<Longrightarrow> fst (grab N n) \\<lless> snd (grab N n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite N \\<Longrightarrow> fst (grab N n) \\<lless> snd (grab N n)", "by (auto simp: grab_def less_sets_def intro: enumerate_mono less_le_trans)"], ["", "lemma finite_grab [iff]: \"finite (fst (grab N n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fst (grab N n))", "by (simp add: grab_def)"], ["", "lemma card_grab [simp]:\n  assumes \"infinite N\" shows \"card (fst (grab N n)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (fst (grab N n)) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (fst (grab N n)) = n", "have \"N \\<inter> enumerate N ` {..<n} = enumerate N ` {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<inter> enum N ` {..<n} = enum N ` {..<n}", "using assms"], ["proof (prove)\nusing this:\n  infinite N\n\ngoal (1 subgoal):\n 1. N \\<inter> enum N ` {..<n} = enum N ` {..<n}", "by (auto simp: enumerate_in_set)"], ["proof (state)\nthis:\n  N \\<inter> enum N ` {..<n} = enum N ` {..<n}\n\ngoal (1 subgoal):\n 1. card (fst (grab N n)) = n", "with assms"], ["proof (chain)\npicking this:\n  infinite N\n  N \\<inter> enum N ` {..<n} = enum N ` {..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite N\n  N \\<inter> enum N ` {..<n} = enum N ` {..<n}\n\ngoal (1 subgoal):\n 1. card (fst (grab N n)) = n", "by (simp add: card_image grab_def strict_mono_enum strict_mono_imp_inj_on)"], ["proof (state)\nthis:\n  card (fst (grab N n)) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fst_grab_subset: \"fst (grab N n) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (grab N n) \\<subseteq> N", "using grab_def range_enum"], ["proof (prove)\nusing this:\n  grab ?N ?n \\<equiv>\n  (?N \\<inter> enum ?N ` {..<?n}, ?N \\<inter> {enum ?N ?n..})\n  infinite ?N \\<Longrightarrow> range (enum ?N) = ?N\n\ngoal (1 subgoal):\n 1. fst (grab N n) \\<subseteq> N", "by fastforce"], ["", "lemma snd_grab_subset: \"snd (grab N n) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (grab N n) \\<subseteq> N", "by (auto simp: grab_def)"], ["", "lemma grab_Un_eq:\n  assumes \"infinite N\" shows \"fst (grab N n) \\<union> snd (grab N n) = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (grab N n) \\<union> snd (grab N n) = N", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (grab N n) \\<union> snd (grab N n) \\<subseteq> N\n 2. N \\<subseteq> fst (grab N n) \\<union> snd (grab N n)", "show \"N \\<subseteq> fst (grab N n) \\<union> snd (grab N n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<subseteq> fst (grab N n) \\<union> snd (grab N n)", "unfolding grab_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<subseteq> fst (N \\<inter> enum N ` {..<n},\n                       N \\<inter> {enum N n..}) \\<union>\n                  snd (N \\<inter> enum N ` {..<n}, N \\<inter> {enum N n..})", "using assms enumerate_Ex le_less_linear strict_mono_enum strict_mono_less"], ["proof (prove)\nusing this:\n  infinite N\n  \\<lbrakk>infinite ?S; ?s \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. enum ?S n = ?s\n  ?x \\<le> ?y \\<or> ?y < ?x\n  infinite ?N \\<Longrightarrow> strict_mono (enum ?N)\n  strict_mono ?f \\<Longrightarrow> (?f ?x < ?f ?y) = (?x < ?y)\n\ngoal (1 subgoal):\n 1. N \\<subseteq> fst (N \\<inter> enum N ` {..<n},\n                       N \\<inter> {enum N n..}) \\<union>\n                  snd (N \\<inter> enum N ` {..<n}, N \\<inter> {enum N n..})", "by fastforce"], ["proof (state)\nthis:\n  N \\<subseteq> fst (grab N n) \\<union> snd (grab N n)\n\ngoal (1 subgoal):\n 1. fst (grab N n) \\<union> snd (grab N n) \\<subseteq> N", "qed (simp add: grab_def)"], ["", "lemma finite_grab_iff [simp]: \"finite (snd (grab N n)) \\<longleftrightarrow> finite N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (snd (grab N n)) = finite N", "by (metis finite_grab grab_Un_eq infinite_Un infinite_super snd_grab_subset)"], ["", "lemma grab_eqD:\n    \"\\<lbrakk>grab N n = (A,M); infinite N\\<rbrakk>\n    \\<Longrightarrow> A \\<lless> M \\<and> finite A \\<and> card A = n \\<and> infinite M \\<and> A \\<subseteq> N \\<and> M \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>grab N n = (A, M); infinite N\\<rbrakk>\n    \\<Longrightarrow> A \\<lless> M \\<and>\n                      finite A \\<and>\n                      card A = n \\<and>\n                      infinite M \\<and>\n                      A \\<subseteq> N \\<and> M \\<subseteq> N", "using card_grab grab_def less_sets_grab finite_grab_iff"], ["proof (prove)\nusing this:\n  infinite ?N \\<Longrightarrow> card (fst (grab ?N ?n)) = ?n\n  grab ?N ?n \\<equiv>\n  (?N \\<inter> enum ?N ` {..<?n}, ?N \\<inter> {enum ?N ?n..})\n  infinite ?N \\<Longrightarrow> fst (grab ?N ?n) \\<lless> snd (grab ?N ?n)\n  finite (snd (grab ?N ?n)) = finite ?N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>grab N n = (A, M); infinite N\\<rbrakk>\n    \\<Longrightarrow> A \\<lless> M \\<and>\n                      finite A \\<and>\n                      card A = n \\<and>\n                      infinite M \\<and>\n                      A \\<subseteq> N \\<and> M \\<subseteq> N", "by auto"], ["", "lemma less_sets_fst_grab: \"A \\<lless> N \\<Longrightarrow> A \\<lless> fst (grab N n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<lless> N \\<Longrightarrow> A \\<lless> fst (grab N n)", "by (simp add: fst_grab_subset less_sets_weaken2)"], ["", "text\\<open>Possibly redundant, given @{term grab}\\<close>"], ["", "definition nxt where \"nxt \\<equiv> \\<lambda>N. \\<lambda>n::nat. N \\<inter> {n<..}\""], ["", "lemma infinite_nxtN: \"infinite N \\<Longrightarrow> infinite (nxt N n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite N \\<Longrightarrow> infinite (nxt N n)", "by (simp add: infinite_nat_greaterThan nxt_def)"], ["", "lemma nxt_subset: \"nxt N n \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nxt N n \\<subseteq> N", "unfolding nxt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<inter> {n<..} \\<subseteq> N", "by blast"], ["", "lemma nxt_subset_greaterThan: \"m \\<le> n \\<Longrightarrow> nxt N n \\<subseteq> {m<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> nxt N n \\<subseteq> {m<..}", "by (auto simp: nxt_def)"], ["", "lemma nxt_subset_atLeast: \"m \\<le> n \\<Longrightarrow> nxt N n \\<subseteq> {m..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> nxt N n \\<subseteq> {m..}", "by (auto simp: nxt_def)"], ["", "lemma enum_nxt_ge: \"infinite N \\<Longrightarrow> a \\<le> enum (nxt N a) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite N \\<Longrightarrow> a \\<le> enum (nxt N a) n", "by (simp add: atLeast_le_enum infinite_nxtN nxt_subset_atLeast)"], ["", "lemma inj_enum_nxt: \"infinite N \\<Longrightarrow> inj_on (enum (nxt N a)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite N \\<Longrightarrow> inj_on (enum (nxt N a)) A", "by (simp add: infinite_nxtN strict_mono_enum strict_mono_imp_inj_on)"], ["", "subsection \\<open>Larson's Lemma 3.11\\<close>"], ["", "text \\<open>Again from Jean A. Larson,\n     A short proof of a partition theorem for the ordinal $\\omega^\\omega$.\n     \\emph{Annals of Mathematical Logic}, 6:129?145, 1973.\\<close>"], ["", "lemma lemma_3_11:\n  assumes \"l > 0\"\n  shows \"thin (inter_scheme l ` {U. Form l U})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thin (inter_scheme l ` {U. Form l U})", "using form_cases [of l]"], ["proof (prove)\nusing this:\n  \\<lbrakk>l = 0 \\<Longrightarrow> ?thesis;\n   \\<And>ka kb.\n      \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. thin (inter_scheme l ` {U. Form l U})", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow> thin (inter_scheme l ` {U. Form l U})\n 2. \\<And>ka kb.\n       \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n        ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thin (inter_scheme l ` {U. Form l U})", "case zero"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow> thin (inter_scheme l ` {U. Form l U})\n 2. \\<And>ka kb.\n       \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n        ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thin (inter_scheme l ` {U. Form l U})", "then"], ["proof (chain)\npicking this:\n  l = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  l = 0\n\ngoal (1 subgoal):\n 1. thin (inter_scheme l ` {U. Form l U})", "using assms"], ["proof (prove)\nusing this:\n  l = 0\n  0 < l\n\ngoal (1 subgoal):\n 1. thin (inter_scheme l ` {U. Form l U})", "by auto"], ["proof (state)\nthis:\n  thin (inter_scheme l ` {U. Form l U})\n\ngoal (1 subgoal):\n 1. \\<And>ka kb.\n       \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n        ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thin (inter_scheme l ` {U. Form l U})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka kb.\n       \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n        ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thin (inter_scheme l ` {U. Form l U})", "case (nz ka kb)"], ["proof (state)\nthis:\n  l = ka + kb - 1\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. \\<And>ka kb.\n       \\<lbrakk>l = ka + kb - 1; 0 < kb; kb \\<le> ka;\n        ka \\<le> Suc kb\\<rbrakk>\n       \\<Longrightarrow> thin (inter_scheme l ` {U. Form l U})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thin (inter_scheme l ` {U. Form l U})", "unfolding thin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>x y.\n       x \\<in> inter_scheme l ` Collect (Form l) \\<and>\n       y \\<in> inter_scheme l ` Collect (Form l) \\<and>\n       x \\<noteq> y \\<and> initial_segment x y", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "fix U U'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "assume ne: \"inter_scheme l U \\<noteq> inter_scheme l U'\" and init: \"initial_segment (inter_scheme l U) (inter_scheme l U')\""], ["proof (state)\nthis:\n  inter_scheme l U \\<noteq> inter_scheme l U'\n  initial_segment (inter_scheme l U) (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"Form l U\""], ["proof (state)\nthis:\n  Form l U\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Form l U", "obtain kp kq xs ys \n      where \"l = kp+kq - 1\" \"U = {xs,ys}\" and U: \"Form_Body kp kq xs ys (inter_scheme l U)\" and \"0 < kq\" \"kq \\<le> kp\" \"kp \\<le> Suc kq\""], ["proof (prove)\nusing this:\n  Form l U\n\ngoal (1 subgoal):\n 1. (\\<And>kp kq xs ys.\n        \\<lbrakk>l = kp + kq - 1; U = {xs, ys};\n         Form_Body kp kq xs ys (inter_scheme l U); 0 < kq; kq \\<le> kp;\n         kp \\<le> Suc kq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms inter_scheme"], ["proof (prove)\nusing this:\n  Form l U\n  0 < l\n  \\<lbrakk>Form ?l ?U; 0 < ?l;\n   \\<And>ka kb xs ys.\n      \\<lbrakk>?l = ka + kb - 1; ?U = {xs, ys};\n       Form_Body ka kb xs ys (inter_scheme ?l ?U); 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>kp kq xs ys.\n        \\<lbrakk>l = kp + kq - 1; U = {xs, ys};\n         Form_Body kp kq xs ys (inter_scheme l U); 0 < kq; kq \\<le> kp;\n         kp \\<le> Suc kq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l = kp + kq - 1\n  U = {xs, ys}\n  Form_Body kp kq xs ys (inter_scheme l U)\n  0 < kq\n  kq \\<le> kp\n  kp \\<le> Suc kq\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  l = kp + kq - 1\n  U = {xs, ys}\n  Form_Body kp kq xs ys (inter_scheme l U)\n  0 < kq\n  kq \\<le> kp\n  kp \\<le> Suc kq", "have \"kp = ka \\<and> kq = kb\""], ["proof (prove)\nusing this:\n  l = kp + kq - 1\n  U = {xs, ys}\n  Form_Body kp kq xs ys (inter_scheme l U)\n  0 < kq\n  kq \\<le> kp\n  kp \\<le> Suc kq\n\ngoal (1 subgoal):\n 1. kp = ka \\<and> kq = kb", "using nz"], ["proof (prove)\nusing this:\n  l = kp + kq - 1\n  U = {xs, ys}\n  Form_Body kp kq xs ys (inter_scheme l U)\n  0 < kq\n  kq \\<le> kp\n  kp \\<le> Suc kq\n  l = ka + kb - 1\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. kp = ka \\<and> kq = kb", "by linarith"], ["proof (state)\nthis:\n  kp = ka \\<and> kq = kb\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  kp = ka \\<and> kq = kb", "obtain a as b bs c d\n      where xs: \"xs = concat (a#as)\" and ys: \"ys = concat (b#bs)\"\n        and len: \"length (a#as) = ka\" \"length (b#bs) = kb\"\n        and c: \"c = acc_lengths 0 (a#as)\"\n        and d: \"d = acc_lengths 0 (b#bs)\"\n        and Ueq: \"inter_scheme l U = concat [c, a, d, b] @ interact as bs\""], ["proof (prove)\nusing this:\n  kp = ka \\<and> kq = kb\n\ngoal (1 subgoal):\n 1. (\\<And>a as b bs c d.\n        \\<lbrakk>xs = concat (a # as); ys = concat (b # bs);\n         length (a # as) = ka; length (b # bs) = kb;\n         c = acc_lengths 0 (a # as); d = acc_lengths 0 (b # bs);\n         inter_scheme l U = concat [c, a, d, b] @ interact as bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using U"], ["proof (prove)\nusing this:\n  kp = ka \\<and> kq = kb\n  Form_Body kp kq xs ys (inter_scheme l U)\n\ngoal (1 subgoal):\n 1. (\\<And>a as b bs c d.\n        \\<lbrakk>xs = concat (a # as); ys = concat (b # bs);\n         length (a # as) = ka; length (b # bs) = kb;\n         c = acc_lengths 0 (a # as); d = acc_lengths 0 (b # bs);\n         inter_scheme l U = concat [c, a, d, b] @ interact as bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Form_Body.simps)"], ["proof (state)\nthis:\n  xs = concat (a # as)\n  ys = concat (b # bs)\n  length (a # as) = ka\n  length (b # bs) = kb\n  c = acc_lengths 0 (a # as)\n  d = acc_lengths 0 (b # bs)\n  inter_scheme l U = concat [c, a, d, b] @ interact as bs\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"Form l U'\""], ["proof (state)\nthis:\n  Form l U'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Form l U'", "obtain kp' kq' xs' ys' \n      where \"l = kp'+kq' - 1\" \"U' = {xs',ys'}\" and U': \"Form_Body kp' kq' xs' ys' (inter_scheme l U')\" and \"0 < kq'\" \"kq' \\<le> kp'\" \"kp' \\<le> Suc kq'\""], ["proof (prove)\nusing this:\n  Form l U'\n\ngoal (1 subgoal):\n 1. (\\<And>kp' kq' xs' ys'.\n        \\<lbrakk>l = kp' + kq' - 1; U' = {xs', ys'};\n         Form_Body kp' kq' xs' ys' (inter_scheme l U'); 0 < kq';\n         kq' \\<le> kp'; kp' \\<le> Suc kq'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms inter_scheme"], ["proof (prove)\nusing this:\n  Form l U'\n  0 < l\n  \\<lbrakk>Form ?l ?U; 0 < ?l;\n   \\<And>ka kb xs ys.\n      \\<lbrakk>?l = ka + kb - 1; ?U = {xs, ys};\n       Form_Body ka kb xs ys (inter_scheme ?l ?U); 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>kp' kq' xs' ys'.\n        \\<lbrakk>l = kp' + kq' - 1; U' = {xs', ys'};\n         Form_Body kp' kq' xs' ys' (inter_scheme l U'); 0 < kq';\n         kq' \\<le> kp'; kp' \\<le> Suc kq'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l = kp' + kq' - 1\n  U' = {xs', ys'}\n  Form_Body kp' kq' xs' ys' (inter_scheme l U')\n  0 < kq'\n  kq' \\<le> kp'\n  kp' \\<le> Suc kq'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  l = kp' + kq' - 1\n  U' = {xs', ys'}\n  Form_Body kp' kq' xs' ys' (inter_scheme l U')\n  0 < kq'\n  kq' \\<le> kp'\n  kp' \\<le> Suc kq'", "have \"kp' = ka \\<and> kq' = kb\""], ["proof (prove)\nusing this:\n  l = kp' + kq' - 1\n  U' = {xs', ys'}\n  Form_Body kp' kq' xs' ys' (inter_scheme l U')\n  0 < kq'\n  kq' \\<le> kp'\n  kp' \\<le> Suc kq'\n\ngoal (1 subgoal):\n 1. kp' = ka \\<and> kq' = kb", "using nz"], ["proof (prove)\nusing this:\n  l = kp' + kq' - 1\n  U' = {xs', ys'}\n  Form_Body kp' kq' xs' ys' (inter_scheme l U')\n  0 < kq'\n  kq' \\<le> kp'\n  kp' \\<le> Suc kq'\n  l = ka + kb - 1\n  0 < kb\n  kb \\<le> ka\n  ka \\<le> Suc kb\n\ngoal (1 subgoal):\n 1. kp' = ka \\<and> kq' = kb", "by linarith"], ["proof (state)\nthis:\n  kp' = ka \\<and> kq' = kb\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  kp' = ka \\<and> kq' = kb", "obtain a' as' b' bs' c' d'\n      where xs': \"xs' = concat (a'#as')\" and ys': \"ys' = concat (b'#bs')\"\n        and len': \"length (a'#as') = ka\" \"length (b'#bs') = kb\"\n        and c': \"c' = acc_lengths 0 (a'#as')\"\n        and d': \"d' = acc_lengths 0 (b'#bs')\"\n        and Ueq': \"inter_scheme l U' = concat [c', a', d', b'] @ interact as' bs'\""], ["proof (prove)\nusing this:\n  kp' = ka \\<and> kq' = kb\n\ngoal (1 subgoal):\n 1. (\\<And>a' as' b' bs' c' d'.\n        \\<lbrakk>xs' = concat (a' # as'); ys' = concat (b' # bs');\n         length (a' # as') = ka; length (b' # bs') = kb;\n         c' = acc_lengths 0 (a' # as'); d' = acc_lengths 0 (b' # bs');\n         inter_scheme l U' =\n         concat [c', a', d', b'] @ interact as' bs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using U'"], ["proof (prove)\nusing this:\n  kp' = ka \\<and> kq' = kb\n  Form_Body kp' kq' xs' ys' (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. (\\<And>a' as' b' bs' c' d'.\n        \\<lbrakk>xs' = concat (a' # as'); ys' = concat (b' # bs');\n         length (a' # as') = ka; length (b' # bs') = kb;\n         c' = acc_lengths 0 (a' # as'); d' = acc_lengths 0 (b' # bs');\n         inter_scheme l U' =\n         concat [c', a', d', b'] @ interact as' bs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Form_Body.simps)"], ["proof (state)\nthis:\n  xs' = concat (a' # as')\n  ys' = concat (b' # bs')\n  length (a' # as') = ka\n  length (b' # bs') = kb\n  c' = acc_lengths 0 (a' # as')\n  d' = acc_lengths 0 (b' # bs')\n  inter_scheme l U' = concat [c', a', d', b'] @ interact as' bs'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have [simp]: \"length bs' = length bs\" \"length as' = length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bs' = length bs &&& length as' = length as", "using len len'"], ["proof (prove)\nusing this:\n  length (a # as) = ka\n  length (b # bs) = kb\n  length (a' # as') = ka\n  length (b' # bs') = kb\n\ngoal (1 subgoal):\n 1. length bs' = length bs &&& length as' = length as", "by auto"], ["proof (state)\nthis:\n  length bs' = length bs\n  length as' = length as\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"inter_scheme l U \\<noteq> []\" \"inter_scheme l U' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inter_scheme l U \\<noteq> [] &&& inter_scheme l U' \\<noteq> []", "using Form_Body_nonempty U U'"], ["proof (prove)\nusing this:\n  Form_Body ?ka ?kb ?xs ?ys ?zs \\<Longrightarrow> 0 < length ?zs\n  Form_Body kp kq xs ys (inter_scheme l U)\n  Form_Body kp' kq' xs' ys' (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. inter_scheme l U \\<noteq> [] &&& inter_scheme l U' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  inter_scheme l U \\<noteq> []\n  inter_scheme l U' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "define u1 where \"u1 \\<equiv> hd (inter_scheme l U)\""], ["proof (state)\nthis:\n  u1 \\<equiv> hd (inter_scheme l U)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have u1_eq': \"u1 = hd (inter_scheme l U')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 = hd (inter_scheme l U')", "using \\<open>inter_scheme l U \\<noteq> []\\<close> init u1_def initial_segment_ne"], ["proof (prove)\nusing this:\n  inter_scheme l U \\<noteq> []\n  initial_segment (inter_scheme l U) (inter_scheme l U')\n  u1 \\<equiv> hd (inter_scheme l U)\n  \\<lbrakk>initial_segment ?xs ?ys; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<noteq> [] \\<and> hd ?ys = hd ?xs\n\ngoal (1 subgoal):\n 1. u1 = hd (inter_scheme l U')", "by fastforce"], ["proof (state)\nthis:\n  u1 = hd (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have au1: \"u1 = length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 = length a", "by (simp add: u1_def Ueq c acc_lengths.simps)"], ["proof (state)\nthis:\n  u1 = length a\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have au1': \"u1 = length a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 = length a'", "by (simp add: u1_eq' Ueq' c' acc_lengths.simps)"], ["proof (state)\nthis:\n  u1 = length a'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have len_eqk: \"length c' = ka\" \"length d' = kb\" \"length c' = ka\" \"length d' = kb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length c' = ka &&& length d' = kb) &&&\n    length c' = ka &&& length d' = kb", "using c d len c' d' len'"], ["proof (prove)\nusing this:\n  c = acc_lengths 0 (a # as)\n  d = acc_lengths 0 (b # bs)\n  length (a # as) = ka\n  length (b # bs) = kb\n  c' = acc_lengths 0 (a' # as')\n  d' = acc_lengths 0 (b' # bs')\n  length (a' # as') = ka\n  length (b' # bs') = kb\n\ngoal (1 subgoal):\n 1. (length c' = ka &&& length d' = kb) &&&\n    length c' = ka &&& length d' = kb", "by auto"], ["proof (state)\nthis:\n  length c' = ka\n  length d' = kb\n  length c' = ka\n  length d' = kb\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have take: \"take (ka + u1 + kb) (c @ a @ d @ l) = c @ a @ d\"\n               \"take (ka + u1 + kb) (c' @ a' @ d' @ l) = c' @ a' @ d'\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (ka + u1 + kb) (c @ a @ d @ l) = c @ a @ d &&&\n    take (ka + u1 + kb) (c' @ a' @ d' @ l) = c' @ a' @ d'", "using c d c' d' len"], ["proof (prove)\nusing this:\n  c = acc_lengths 0 (a # as)\n  d = acc_lengths 0 (b # bs)\n  c' = acc_lengths 0 (a' # as')\n  d' = acc_lengths 0 (b' # bs')\n  length (a # as) = ka\n  length (b # bs) = kb\n\ngoal (1 subgoal):\n 1. take (ka + u1 + kb) (c @ a @ d @ l) = c @ a @ d &&&\n    take (ka + u1 + kb) (c' @ a' @ d' @ l) = c' @ a' @ d'", "by (simp_all add: flip: au1 au1')"], ["proof (state)\nthis:\n  take (ka + u1 + kb) (c @ a @ d @ ?l) = c @ a @ d\n  take (ka + u1 + kb) (c' @ a' @ d' @ ?l) = c' @ a' @ d'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have leU: \"ka + u1 + kb \\<le> length (inter_scheme l U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ka + u1 + kb \\<le> length (inter_scheme l U)", "using c d len"], ["proof (prove)\nusing this:\n  c = acc_lengths 0 (a # as)\n  d = acc_lengths 0 (b # bs)\n  length (a # as) = ka\n  length (b # bs) = kb\n\ngoal (1 subgoal):\n 1. ka + u1 + kb \\<le> length (inter_scheme l U)", "by (simp add: au1 Ueq)"], ["proof (state)\nthis:\n  ka + u1 + kb \\<le> length (inter_scheme l U)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ka + u1 + kb \\<le> length (inter_scheme l U)", "have \"take (ka + u1 + kb) (inter_scheme l U) = take (ka + u1 + kb) (inter_scheme l U')\""], ["proof (prove)\nusing this:\n  ka + u1 + kb \\<le> length (inter_scheme l U)\n\ngoal (1 subgoal):\n 1. take (ka + u1 + kb) (inter_scheme l U) =\n    take (ka + u1 + kb) (inter_scheme l U')", "using take_initial_segment init"], ["proof (prove)\nusing this:\n  ka + u1 + kb \\<le> length (inter_scheme l U)\n  \\<lbrakk>initial_segment ?xs ?ys; ?k \\<le> length ?xs\\<rbrakk>\n  \\<Longrightarrow> take ?k ?xs = take ?k ?ys\n  initial_segment (inter_scheme l U) (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. take (ka + u1 + kb) (inter_scheme l U) =\n    take (ka + u1 + kb) (inter_scheme l U')", "by blast"], ["proof (state)\nthis:\n  take (ka + u1 + kb) (inter_scheme l U) =\n  take (ka + u1 + kb) (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  take (ka + u1 + kb) (inter_scheme l U) =\n  take (ka + u1 + kb) (inter_scheme l U')", "have \\<section>: \"c @ a @ d = c' @ a' @ d'\""], ["proof (prove)\nusing this:\n  take (ka + u1 + kb) (inter_scheme l U) =\n  take (ka + u1 + kb) (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. c @ a @ d = c' @ a' @ d'", "by (metis Ueq Ueq' append.assoc concat.simps(2) take)"], ["proof (state)\nthis:\n  c @ a @ d = c' @ a' @ d'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"length (inter_scheme l U) = ka + (c @ a @ d)!(ka-1) + kb + last d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (inter_scheme l U) = ka + (c @ a @ d) ! (ka - 1) + kb + last d", "by (simp add: Ueq c d length_interact nth_append flip: len)"], ["proof (state)\nthis:\n  length (inter_scheme l U) = ka + (c @ a @ d) ! (ka - 1) + kb + last d\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length (inter_scheme l U) = ka + (c @ a @ d) ! (ka - 1) + kb + last d\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"length (inter_scheme l U') = ka + (c' @ a' @ d')!(ka-1) + kb + last d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (inter_scheme l U') =\n    ka + (c' @ a' @ d') ! (ka - 1) + kb + last d'", "by (simp add: Ueq' c' d' length_interact nth_append flip: len')"], ["proof (state)\nthis:\n  length (inter_scheme l U') = ka + (c' @ a' @ d') ! (ka - 1) + kb + last d'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length (inter_scheme l U') = ka + (c' @ a' @ d') ! (ka - 1) + kb + last d'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"last d = last d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last d = last d'", "using \"\\<section>\" c d d' len'(1) len_eqk(1)"], ["proof (prove)\nusing this:\n  c @ a @ d = c' @ a' @ d'\n  c = acc_lengths 0 (a # as)\n  d = acc_lengths 0 (b # bs)\n  d' = acc_lengths 0 (b' # bs')\n  length (a' # as') = ka\n  length c' = ka\n\ngoal (1 subgoal):\n 1. last d = last d'", "by auto"], ["proof (state)\nthis:\n  last d = last d'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  length (inter_scheme l U) = ka + (c @ a @ d) ! (ka - 1) + kb + last d\n  length (inter_scheme l U') = ka + (c' @ a' @ d') ! (ka - 1) + kb + last d'\n  last d = last d'", "have \"length (inter_scheme l U) = length (inter_scheme l U')\""], ["proof (prove)\nusing this:\n  length (inter_scheme l U) = ka + (c @ a @ d) ! (ka - 1) + kb + last d\n  length (inter_scheme l U') = ka + (c' @ a' @ d') ! (ka - 1) + kb + last d'\n  last d = last d'\n\ngoal (1 subgoal):\n 1. length (inter_scheme l U) = length (inter_scheme l U')", "by (simp add: \\<section>)"], ["proof (state)\nthis:\n  length (inter_scheme l U) = length (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>Form l xa; Form l xb;\n        inter_scheme l xa \\<noteq> inter_scheme l xb;\n        initial_segment (inter_scheme l xa) (inter_scheme l xb)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  length (inter_scheme l U) = length (inter_scheme l U')", "show False"], ["proof (prove)\nusing this:\n  length (inter_scheme l U) = length (inter_scheme l U')\n\ngoal (1 subgoal):\n 1. False", "using init initial_segment_length_eq ne"], ["proof (prove)\nusing this:\n  length (inter_scheme l U) = length (inter_scheme l U')\n  initial_segment (inter_scheme l U) (inter_scheme l U')\n  \\<lbrakk>initial_segment ?xs ?ys; length ?xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n  inter_scheme l U \\<noteq> inter_scheme l U'\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thin (inter_scheme l ` {U. Form l U})\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Larson's Lemma 3.6\\<close>"], ["", "proposition lemma_3_6:\n  fixes g :: \"nat list set \\<Rightarrow> nat\"\n  assumes g: \"g \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {0,1}\"\n  obtains N j where \"infinite N\"\n    and \"\\<And>k u. \\<lbrakk>k > 0; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u; [enum N k] < inter_scheme k u; List.set (inter_scheme k u) \\<subseteq> N\\<rbrakk> \\<Longrightarrow> g u = j k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define \\<Phi> where \"\\<Phi> \\<equiv> \\<lambda>m::nat. \\<lambda>M. infinite M \\<and> m < Inf M\""], ["proof (state)\nthis:\n  \\<Phi> \\<equiv> \\<lambda>m M. infinite M \\<and> m < \\<Sqinter> M\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define \\<Psi> where \"\\<Psi> \\<equiv> \\<lambda>l m n::nat. \\<lambda>M N j. n > m \\<and> N \\<subseteq> M \\<and> n \\<in> M \\<and> (\\<forall>U. Form l U \\<and> U \\<subseteq> WW \\<and> [n] < inter_scheme l U \\<and> list.set (inter_scheme l U) \\<subseteq> N \\<longrightarrow> g U = j)\""], ["proof (state)\nthis:\n  \\<Psi> \\<equiv>\n  \\<lambda>l m n M N j.\n     m < n \\<and>\n     N \\<subseteq> M \\<and>\n     n \\<in> M \\<and>\n     (\\<forall>U.\n         Form l U \\<and>\n         U \\<subseteq> WW \\<and>\n         [n] < inter_scheme l U \\<and>\n         list.set (inter_scheme l U) \\<subseteq> N \\<longrightarrow>\n         g U = j)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  \\<Psi> \\<equiv>\n  \\<lambda>l m n M N j.\n     m < n \\<and>\n     N \\<subseteq> M \\<and>\n     n \\<in> M \\<and>\n     (\\<forall>U.\n         Form l U \\<and>\n         U \\<subseteq> WW \\<and>\n         [n] < inter_scheme l U \\<and>\n         list.set (inter_scheme l U) \\<subseteq> N \\<longrightarrow>\n         g U = j)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix l m::nat and M :: \"nat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"l > 0\" \"\\<Phi> m M\""], ["proof (state)\nthis:\n  0 < l\n  \\<Phi> m M\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?A = \"inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define h where \"h \\<equiv> \\<lambda>zs. g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l) zs)\""], ["proof (state)\nthis:\n  h \\<equiv>\n  \\<lambda>zs.\n     g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l)\n         zs)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"thin ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thin (inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U})", "using \\<open>l > 0\\<close> lemma_3_11"], ["proof (prove)\nusing this:\n  0 < l\n  0 < ?l \\<Longrightarrow> thin (inter_scheme ?l ` {U. Form ?l U})\n\ngoal (1 subgoal):\n 1. thin (inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U})", "by (simp add: thin_def)"], ["proof (state)\nthis:\n  thin (inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U})\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  thin (inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U})\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"?A \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n    \\<subseteq> WW", "using inter_scheme_simple \\<open>0 < l\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>Form ?l ?U; 0 < ?l\\<rbrakk>\n  \\<Longrightarrow> inter_scheme ?l ?U \\<in> WW \\<and>\n                    0 < length (inter_scheme ?l ?U)\n  0 < l\n\ngoal (1 subgoal):\n 1. inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n    \\<subseteq> WW", "by blast"], ["proof (state)\nthis:\n  inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"h ` {l \\<in> ?A. List.set l \\<subseteq> M} \\<subseteq> {..<2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h `\n    {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n     list.set la \\<subseteq> M}\n    \\<subseteq> {..<2}", "using g inv_into_into[of concl: \"{U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\" \"inter_scheme l\"]"], ["proof (prove)\nusing this:\n  g \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {0, 1}\n  ?x \\<in> inter_scheme l `\n           {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} \\<Longrightarrow>\n  inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l) ?x\n  \\<in> {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n\ngoal (1 subgoal):\n 1. h `\n    {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n     list.set la \\<subseteq> M}\n    \\<subseteq> {..<2}", "by (force simp: h_def Pi_iff)"], ["proof (state)\nthis:\n  h `\n  {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n   list.set la \\<subseteq> M}\n  \\<subseteq> {..<2}\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  thin (inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U})\n  inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} \\<subseteq> WW\n  h `\n  {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n   list.set la \\<subseteq> M}\n  \\<subseteq> {..<2}", "obtain j N where \"j < 2\" \"infinite N\" \"N \\<subseteq> M\" and hj: \"h ` {l \\<in> ?A. List.set l \\<subseteq> N} \\<subseteq> {j}\""], ["proof (prove)\nusing this:\n  thin (inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U})\n  inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} \\<subseteq> WW\n  h `\n  {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n   list.set la \\<subseteq> M}\n  \\<subseteq> {..<2}\n\ngoal (1 subgoal):\n 1. (\\<And>j N.\n        \\<lbrakk>j < 2; infinite N; N \\<subseteq> M;\n         h `\n         {la \\<in> inter_scheme l `\n                   {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n          list.set la \\<subseteq> N}\n         \\<subseteq> {j}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<Phi> m M\\<close>"], ["proof (prove)\nusing this:\n  thin (inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U})\n  inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} \\<subseteq> WW\n  h `\n  {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n   list.set la \\<subseteq> M}\n  \\<subseteq> {..<2}\n  \\<Phi> m M\n\ngoal (1 subgoal):\n 1. (\\<And>j N.\n        \\<lbrakk>j < 2; infinite N; N \\<subseteq> M;\n         h `\n         {la \\<in> inter_scheme l `\n                   {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n          list.set la \\<subseteq> N}\n         \\<subseteq> {j}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<Phi>_def"], ["proof (prove)\nusing this:\n  thin (inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U})\n  inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} \\<subseteq> WW\n  h `\n  {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n   list.set la \\<subseteq> M}\n  \\<subseteq> {..<2}\n  infinite M \\<and> m < \\<Sqinter> M\n\ngoal (1 subgoal):\n 1. (\\<And>j N.\n        \\<lbrakk>j < 2; infinite N; N \\<subseteq> M;\n         h `\n         {la \\<in> inter_scheme l `\n                   {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n          list.set la \\<subseteq> N}\n         \\<subseteq> {j}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast intro: Nash_Williams_WW [of M])"], ["proof (state)\nthis:\n  j < 2\n  infinite N\n  N \\<subseteq> M\n  h `\n  {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n   list.set la \\<subseteq> N}\n  \\<subseteq> {j}\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define n where \"n \\<equiv> Inf N\""], ["proof (state)\nthis:\n  n \\<equiv> \\<Sqinter> N\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"n > m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n", "using \\<open>\\<Phi> m M\\<close> \\<open>infinite N\\<close>"], ["proof (prove)\nusing this:\n  \\<Phi> m M\n  infinite N\n\ngoal (1 subgoal):\n 1. m < n", "unfolding n_def \\<Phi>_def Inf_nat_def infinite_nat_iff_unbounded"], ["proof (prove)\nusing this:\n  (\\<forall>m. \\<exists>n>m. n \\<in> M) \\<and> m < (LEAST n. n \\<in> M)\n  \\<forall>m. \\<exists>n>m. n \\<in> N\n\ngoal (1 subgoal):\n 1. m < (LEAST n. n \\<in> N)", "by (metis LeastI_ex \\<open>N \\<subseteq> M\\<close> le_less_trans not_less not_less_Least subsetD)"], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"g U = j\" if \"Form l U\" \"U \\<subseteq> WW\" \"[n] < inter_scheme l U\" \"list.set (inter_scheme l U) \\<subseteq> N - {n}\" for U"], ["proof (prove)\ngoal (1 subgoal):\n 1. g U = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g U = j", "obtain xs ys where xys: \"xs \\<noteq> ys\" \"U = {xs,ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>xs \\<noteq> ys; U = {xs, ys}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Form_elim_upair \\<open>Form l U\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>Form ?l ?U;\n   \\<And>xs ys.\n      \\<lbrakk>xs \\<noteq> ys; ?U = {xs, ys};\n       length xs \\<le> length ys\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Form l U\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>xs \\<noteq> ys; U = {xs, ys}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs \\<noteq> ys\n  U = {xs, ys}\n\ngoal (1 subgoal):\n 1. g U = j", "moreover"], ["proof (state)\nthis:\n  xs \\<noteq> ys\n  U = {xs, ys}\n\ngoal (1 subgoal):\n 1. g U = j", "have \"inj_on (inter_scheme l) {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (inter_scheme l) {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}", "by (metis (mono_tags, lifting) inter_scheme_injective \\<open>0 < l\\<close> inj_onI mem_Collect_eq)"], ["proof (state)\nthis:\n  inj_on (inter_scheme l) {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n\ngoal (1 subgoal):\n 1. g U = j", "moreover"], ["proof (state)\nthis:\n  inj_on (inter_scheme l) {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n\ngoal (1 subgoal):\n 1. g U = j", "have \"g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l) (inter_scheme l U)) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l)\n        (inter_scheme l U)) =\n    j", "using hj that xys"], ["proof (prove)\nusing this:\n  h `\n  {la \\<in> inter_scheme l ` {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}.\n   list.set la \\<subseteq> N}\n  \\<subseteq> {j}\n  Form l U\n  U \\<subseteq> WW\n  [n] < inter_scheme l U\n  list.set (inter_scheme l U) \\<subseteq> N - {n}\n  xs \\<noteq> ys\n  U = {xs, ys}\n\ngoal (1 subgoal):\n 1. g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l)\n        (inter_scheme l U)) =\n    j", "apply (simp add: h_def image_subset_iff image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (\\<exists>xa.\n                    xa \\<in> [WW]\\<^bsup>2\\<^esup> \\<and>\n                    Form l xa \\<and> x = inter_scheme l xa) \\<and>\n                list.set x \\<subseteq> N \\<longrightarrow>\n                g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n                    (inter_scheme l) x) =\n                j;\n     Form l {xs, ys}; xs \\<in> WW \\<and> ys \\<in> WW;\n     [n] < inter_scheme l {xs, ys};\n     list.set (inter_scheme l {xs, ys}) \\<subseteq> N - {n}; xs \\<noteq> ys;\n     U = {xs, ys}\\<rbrakk>\n    \\<Longrightarrow> g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n                          (inter_scheme l) (inter_scheme l {xs, ys})) =\n                      j", "by (metis (no_types, lifting) Diff_subset doubleton_in_nsets_2 dual_order.trans)"], ["proof (state)\nthis:\n  g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l)\n      (inter_scheme l U)) =\n  j\n\ngoal (1 subgoal):\n 1. g U = j", "ultimately"], ["proof (chain)\npicking this:\n  xs \\<noteq> ys\n  U = {xs, ys}\n  inj_on (inter_scheme l) {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n  g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l)\n      (inter_scheme l U)) =\n  j", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> ys\n  U = {xs, ys}\n  inj_on (inter_scheme l) {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n  g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l)\n      (inter_scheme l U)) =\n  j\n\ngoal (1 subgoal):\n 1. g U = j", "using that"], ["proof (prove)\nusing this:\n  xs \\<noteq> ys\n  U = {xs, ys}\n  inj_on (inter_scheme l) {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U}\n  g (inv_into {U \\<in> [WW]\\<^bsup>2\\<^esup>. Form l U} (inter_scheme l)\n      (inter_scheme l U)) =\n  j\n  Form l U\n  U \\<subseteq> WW\n  [n] < inter_scheme l U\n  list.set (inter_scheme l U) \\<subseteq> N - {n}\n\ngoal (1 subgoal):\n 1. g U = j", "by auto"], ["proof (state)\nthis:\n  g U = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Form l ?U; ?U \\<subseteq> WW; [n] < inter_scheme l ?U;\n   list.set (inter_scheme l ?U) \\<subseteq> N - {n}\\<rbrakk>\n  \\<Longrightarrow> g ?U = j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Form l ?U; ?U \\<subseteq> WW; [n] < inter_scheme l ?U;\n   list.set (inter_scheme l ?U) \\<subseteq> N - {n}\\<rbrakk>\n  \\<Longrightarrow> g ?U = j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"n < Inf (N - {n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (N - {n})", "unfolding n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> N < \\<Sqinter> (N - {\\<Sqinter> N})", "by (metis Diff_iff Inf_nat_def Inf_nat_def1 \\<open>infinite N\\<close> finite.emptyI infinite_remove linorder_neqE_nat not_less_Least singletonI)"], ["proof (state)\nthis:\n  n < \\<Sqinter> (N - {n})\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  n < \\<Sqinter> (N - {n})\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"n \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> M", "by (metis Inf_nat_def1 \\<open>N \\<subseteq> M\\<close> \\<open>infinite N\\<close> finite.emptyI n_def subsetD)"], ["proof (state)\nthis:\n  n \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>Form l ?U; ?U \\<subseteq> WW; [n] < inter_scheme l ?U;\n   list.set (inter_scheme l ?U) \\<subseteq> N - {n}\\<rbrakk>\n  \\<Longrightarrow> g ?U = j\n  n < \\<Sqinter> (N - {n})\n  n \\<in> M", "have \"\\<Phi> n (N - {n}) \\<and> \\<Psi> l m n M (N - {n}) j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Form l ?U; ?U \\<subseteq> WW; [n] < inter_scheme l ?U;\n   list.set (inter_scheme l ?U) \\<subseteq> N - {n}\\<rbrakk>\n  \\<Longrightarrow> g ?U = j\n  n < \\<Sqinter> (N - {n})\n  n \\<in> M\n\ngoal (1 subgoal):\n 1. \\<Phi> n (N - {n}) \\<and> \\<Psi> l m n M (N - {n}) j", "using \\<open>\\<Phi> m M\\<close> \\<open>infinite N\\<close> \\<open>N \\<subseteq> M\\<close> \\<open>n > m\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>Form l ?U; ?U \\<subseteq> WW; [n] < inter_scheme l ?U;\n   list.set (inter_scheme l ?U) \\<subseteq> N - {n}\\<rbrakk>\n  \\<Longrightarrow> g ?U = j\n  n < \\<Sqinter> (N - {n})\n  n \\<in> M\n  \\<Phi> m M\n  infinite N\n  N \\<subseteq> M\n  m < n\n\ngoal (1 subgoal):\n 1. \\<Phi> n (N - {n}) \\<and> \\<Psi> l m n M (N - {n}) j", "by (auto simp: \\<Phi>_def \\<Psi>_def)"], ["proof (state)\nthis:\n  \\<Phi> n (N - {n}) \\<and> \\<Psi> l m n M (N - {n}) j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<Phi> n (N - {n}) \\<and> \\<Psi> l m n M (N - {n}) j", "have \"\\<exists>n N j. \\<Phi> n N \\<and> \\<Psi> l m n M N j\""], ["proof (prove)\nusing this:\n  \\<Phi> n (N - {n}) \\<and> \\<Psi> l m n M (N - {n}) j\n\ngoal (1 subgoal):\n 1. \\<exists>n N j. \\<Phi> n N \\<and> \\<Psi> l m n M N j", "by blast"], ["proof (state)\nthis:\n  \\<exists>n N j. \\<Phi> n N \\<and> \\<Psi> l m n M N j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?l2; \\<Phi> ?m2 ?M2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n N j.\n                       \\<Phi> n N \\<and> \\<Psi> ?l2 ?m2 n ?M2 N j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?l2; \\<Phi> ?m2 ?M2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n N j.\n                       \\<Phi> n N \\<and> \\<Psi> ?l2 ?m2 n ?M2 N j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have base: \"\\<Phi> 0 {0<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> 0 {0<..}", "unfolding \\<Phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {0<..} \\<and> 0 < \\<Sqinter> {0<..}", "by (metis infinite_Ioi Inf_nat_def1 greaterThan_iff greaterThan_non_empty)"], ["proof (state)\nthis:\n  \\<Phi> 0 {0<..}\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have step: \"Ex (\\<lambda>(n,N,j). \\<Phi> n N \\<and> \\<Psi> l m n M N j)\" if \"\\<Phi> m M\" \"l > 0\" for m M l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex (\\<lambda>(n, N, j). \\<Phi> n N \\<and> \\<Psi> l m n M N j)", "using * [of l m M] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < l; \\<Phi> m M\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n N j. \\<Phi> n N \\<and> \\<Psi> l m n M N j\n  \\<Phi> m M\n  0 < l\n\ngoal (1 subgoal):\n 1. Ex (\\<lambda>(n, N, j). \\<Phi> n N \\<and> \\<Psi> l m n M N j)", "by (auto simp: \\<Phi>_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<Phi> ?m ?M; 0 < ?l\\<rbrakk>\n  \\<Longrightarrow> Ex (\\<lambda>(n, N, j).\n                           \\<Phi> n N \\<and> \\<Psi> ?l ?m n ?M N j)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define G where \"G \\<equiv> \\<lambda>l m M. @(n,N,j). \\<Phi> n N \\<and> \\<Psi> (Suc l) m n M N j\""], ["proof (state)\nthis:\n  G \\<equiv>\n  \\<lambda>l m M. SOME (n, N, j). \\<Phi> n N \\<and> \\<Psi> (Suc l) m n M N j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have G\\<Phi>: \"(\\<lambda>(n,N,j). \\<Phi> n N) (G l m M)\" and G\\<Psi>: \"(\\<lambda>(n,N,j). \\<Psi> (Suc l) m n M N j) (G l m M)\"\n    if \"\\<Phi> m M\" for l m M"], ["proof (prove)\ngoal (1 subgoal):\n 1. case G l m M of (n, N, j) \\<Rightarrow> \\<Phi> n N &&&\n    case G l m M of (n, N, j) \\<Rightarrow> \\<Psi> (Suc l) m n M N j", "using step [OF that, of \"Suc l\"]"], ["proof (prove)\nusing this:\n  0 < Suc l \\<Longrightarrow>\n  Ex (\\<lambda>(n, N, j). \\<Phi> n N \\<and> \\<Psi> (Suc l) m n M N j)\n\ngoal (1 subgoal):\n 1. case G l m M of (n, N, j) \\<Rightarrow> \\<Phi> n N &&&\n    case G l m M of (n, N, j) \\<Rightarrow> \\<Psi> (Suc l) m n M N j", "by (force simp: G_def dest: some_eq_imp)+"], ["proof (state)\nthis:\n  \\<Phi> ?m ?M \\<Longrightarrow>\n  case G ?l ?m ?M of (n, N, j) \\<Rightarrow> \\<Phi> n N\n  \\<Phi> ?m ?M \\<Longrightarrow>\n  case G ?l ?m ?M of (n, N, j) \\<Rightarrow> \\<Psi> (Suc ?l) ?m n ?M N j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have G_increasing: \"(\\<lambda>(n,N,j). n > m \\<and> N \\<subseteq> M \\<and> n \\<in> M) (G l m M)\"  if \"\\<Phi> m M\" for l m M"], ["proof (prove)\ngoal (1 subgoal):\n 1. case G l m M of\n    (n, N, j) \\<Rightarrow> m < n \\<and> N \\<subseteq> M \\<and> n \\<in> M", "using G\\<Psi> [OF that, of l] that"], ["proof (prove)\nusing this:\n  case G l m M of (n, N, j) \\<Rightarrow> \\<Psi> (Suc l) m n M N j\n  \\<Phi> m M\n\ngoal (1 subgoal):\n 1. case G l m M of\n    (n, N, j) \\<Rightarrow> m < n \\<and> N \\<subseteq> M \\<and> n \\<in> M", "by (simp add: \\<Psi>_def split: prod.split_asm)"], ["proof (state)\nthis:\n  \\<Phi> ?m ?M \\<Longrightarrow>\n  case G ?l ?m ?M of\n  (n, N, j) \\<Rightarrow> ?m < n \\<and> N \\<subseteq> ?M \\<and> n \\<in> ?M\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define H where \"H \\<equiv> rec_nat (0,{0<..},0) (\\<lambda>l (m,M,j). G l m M)\""], ["proof (state)\nthis:\n  H \\<equiv> rec_nat (0, {0<..}, 0) (\\<lambda>l (m, M, j). G l m M)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H_simps: \"H 0 = (0,{0<..},0)\" \"\\<And>l. H (Suc l) = (case H l of (m,M,j) \\<Rightarrow> G l m M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H 0 = (0, {0<..}, 0) &&&\n    (\\<And>l. H (Suc l) = (case H l of (m, M, j) \\<Rightarrow> G l m M))", "by (simp_all add: H_def)"], ["proof (state)\nthis:\n  H 0 = (0, {0<..}, 0)\n  H (Suc ?l) = (case H ?l of (m, M, j) \\<Rightarrow> G ?l m M)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H\\<Phi>: \"(\\<lambda>(n,N,j). \\<Phi> n N) (H l)\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. case H 0 of (n, N, j) \\<Rightarrow> \\<Phi> n N\n 2. \\<And>l.\n       case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N \\<Longrightarrow>\n       case H (Suc l) of (n, N, j) \\<Rightarrow> \\<Phi> n N", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. case H 0 of (n, N, j) \\<Rightarrow> \\<Phi> n N\n 2. \\<And>l.\n       case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N \\<Longrightarrow>\n       case H (Suc l) of (n, N, j) \\<Rightarrow> \\<Phi> n N", "with base"], ["proof (chain)\npicking this:\n  \\<Phi> 0 {0<..}", "show ?case"], ["proof (prove)\nusing this:\n  \\<Phi> 0 {0<..}\n\ngoal (1 subgoal):\n 1. case H 0 of (n, N, j) \\<Rightarrow> \\<Phi> n N", "by (auto simp: H_simps)"], ["proof (state)\nthis:\n  case H 0 of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N \\<Longrightarrow>\n       case H (Suc l) of (n, N, j) \\<Rightarrow> \\<Phi> n N", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N \\<Longrightarrow>\n       case H (Suc l) of (n, N, j) \\<Rightarrow> \\<Phi> n N", "case (Suc l)"], ["proof (state)\nthis:\n  case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N \\<Longrightarrow>\n       case H (Suc l) of (n, N, j) \\<Rightarrow> \\<Phi> n N", "with G\\<Phi>"], ["proof (chain)\npicking this:\n  \\<Phi> ?m ?M \\<Longrightarrow>\n  case G ?l ?m ?M of (n, N, j) \\<Rightarrow> \\<Phi> n N\n  case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N", "show ?case"], ["proof (prove)\nusing this:\n  \\<Phi> ?m ?M \\<Longrightarrow>\n  case G ?l ?m ?M of (n, N, j) \\<Rightarrow> \\<Phi> n N\n  case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal (1 subgoal):\n 1. case H (Suc l) of (n, N, j) \\<Rightarrow> \\<Phi> n N", "by (force simp: H_simps split: prod.split prod.split_asm)"], ["proof (state)\nthis:\n  case H (Suc l) of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case H ?l of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define \\<nu> where \"\\<nu> \\<equiv> (\\<lambda>l. case H l of (n,M,j) \\<Rightarrow> n)\""], ["proof (state)\nthis:\n  \\<nu> \\<equiv> \\<lambda>l. case H l of (n, M, j) \\<Rightarrow> n\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H_inc: \"\\<nu> l \\<ge> l\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> \\<nu> l", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> \\<nu> 0\n 2. \\<And>l. l \\<le> \\<nu> l \\<Longrightarrow> Suc l \\<le> \\<nu> (Suc l)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<le> \\<nu> 0\n 2. \\<And>l. l \\<le> \\<nu> l \\<Longrightarrow> Suc l \\<le> \\<nu> (Suc l)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<nu> 0", "by auto"], ["proof (state)\nthis:\n  0 \\<le> \\<nu> 0\n\ngoal (1 subgoal):\n 1. \\<And>l. l \\<le> \\<nu> l \\<Longrightarrow> Suc l \\<le> \\<nu> (Suc l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. l \\<le> \\<nu> l \\<Longrightarrow> Suc l \\<le> \\<nu> (Suc l)", "case (Suc l)"], ["proof (state)\nthis:\n  l \\<le> \\<nu> l\n\ngoal (1 subgoal):\n 1. \\<And>l. l \\<le> \\<nu> l \\<Longrightarrow> Suc l \\<le> \\<nu> (Suc l)", "then"], ["proof (chain)\npicking this:\n  l \\<le> \\<nu> l", "show ?case"], ["proof (prove)\nusing this:\n  l \\<le> \\<nu> l\n\ngoal (1 subgoal):\n 1. Suc l \\<le> \\<nu> (Suc l)", "using H\\<Phi> G_increasing [of \"\\<nu> l\"]"], ["proof (prove)\nusing this:\n  l \\<le> \\<nu> l\n  case H ?l of (n, N, j) \\<Rightarrow> \\<Phi> n N\n  \\<Phi> (\\<nu> l) ?M \\<Longrightarrow>\n  case G ?l (\\<nu> l) ?M of\n  (n, N, j) \\<Rightarrow>\n    \\<nu> l < n \\<and> N \\<subseteq> ?M \\<and> n \\<in> ?M\n\ngoal (1 subgoal):\n 1. Suc l \\<le> \\<nu> (Suc l)", "apply (auto simp: H_simps \\<nu>_def split: prod.split prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 aa ba x1a ab bb.\n       \\<lbrakk>\\<And>l. case H l of (n, N, j) \\<Rightarrow> \\<Phi> n N;\n        \\<And>M l.\n           \\<Phi> x1 M \\<Longrightarrow>\n           case G l x1 M of\n           (n, ab) \\<Rightarrow>\n             x1 < n \\<and>\n             (case ab of\n              (N, j) \\<Rightarrow> N \\<subseteq> M \\<and> n \\<in> M);\n        H l = (x1, aa, ba); l \\<le> x1; G l x1 aa = (x1a, ab, bb)\\<rbrakk>\n       \\<Longrightarrow> Suc l \\<le> x1a", "by (metis (mono_tags, lifting) Suc_leI Suc_le_mono case_prod_conv dual_order.trans)"], ["proof (state)\nthis:\n  Suc l \\<le> \\<nu> (Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?l \\<le> \\<nu> ?l\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?N = \"range \\<nu>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define j where \"j \\<equiv> \\<lambda>l. case H l of (n,M,j) \\<Rightarrow> j\""], ["proof (state)\nthis:\n  j \\<equiv> \\<lambda>l. case H l of (n, M, j) \\<Rightarrow> j\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H_increasing_Suc: \"(case H k of (n, N, j') \\<Rightarrow> N) \\<supseteq> (case H (Suc k) of (n, N, j') \\<Rightarrow> insert n N)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case H (Suc k) of (n, N, j') \\<Rightarrow> insert n N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "using H\\<Phi> [of k]"], ["proof (prove)\nusing this:\n  case H k of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal (1 subgoal):\n 1. (case H (Suc k) of (n, N, j') \\<Rightarrow> insert n N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "by (force simp: H_simps split: prod.split dest: G_increasing [where l=k])"], ["proof (state)\nthis:\n  (case H (Suc ?k) of (n, N, j') \\<Rightarrow> insert n N)\n  \\<subseteq> (case H ?k of (n, N, j') \\<Rightarrow> N)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H_increasing_superset: \"(case H k of (n, N, j') \\<Rightarrow> N) \\<supseteq> (case H (n+k) of (n, N, j') \\<Rightarrow> N)\" for k n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case H (n + k) of (n, N, j') \\<Rightarrow> N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "proof (induction n arbitrary:)"], ["proof (state)\ngoal (2 subgoals):\n 1. (case H (0 + k) of (n, N, j') \\<Rightarrow> N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)\n 2. \\<And>n.\n       (case H (n + k) of (n, N, j') \\<Rightarrow> N)\n       \\<subseteq> (case H k of\n                    (n, N, j') \\<Rightarrow> N) \\<Longrightarrow>\n       (case H (Suc n + k) of (n, N, j') \\<Rightarrow> N)\n       \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "case (Suc n)"], ["proof (state)\nthis:\n  (case H (n + k) of (n, N, j') \\<Rightarrow> N)\n  \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)\n\ngoal (2 subgoals):\n 1. (case H (0 + k) of (n, N, j') \\<Rightarrow> N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)\n 2. \\<And>n.\n       (case H (n + k) of (n, N, j') \\<Rightarrow> N)\n       \\<subseteq> (case H k of\n                    (n, N, j') \\<Rightarrow> N) \\<Longrightarrow>\n       (case H (Suc n + k) of (n, N, j') \\<Rightarrow> N)\n       \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "then"], ["proof (chain)\npicking this:\n  (case H (n + k) of (n, N, j') \\<Rightarrow> N)\n  \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "show ?case"], ["proof (prove)\nusing this:\n  (case H (n + k) of (n, N, j') \\<Rightarrow> N)\n  \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)\n\ngoal (1 subgoal):\n 1. (case H (Suc n + k) of (n, N, j') \\<Rightarrow> N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "using H_increasing_Suc [of \"n+k\"]"], ["proof (prove)\nusing this:\n  (case H (n + k) of (n, N, j') \\<Rightarrow> N)\n  \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)\n  (case H (Suc (n + k)) of (n, N, j') \\<Rightarrow> insert n N)\n  \\<subseteq> (case H (n + k) of (n, N, j') \\<Rightarrow> N)\n\ngoal (1 subgoal):\n 1. (case H (Suc n + k) of (n, N, j') \\<Rightarrow> N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "by (auto split: prod.split_asm)"], ["proof (state)\nthis:\n  (case H (Suc n + k) of (n, N, j') \\<Rightarrow> N)\n  \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)\n\ngoal (1 subgoal):\n 1. (case H (0 + k) of (n, N, j') \\<Rightarrow> N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "qed auto"], ["proof (state)\nthis:\n  (case H (?n + ?k) of (n, N, j') \\<Rightarrow> N)\n  \\<subseteq> (case H ?k of (n, N, j') \\<Rightarrow> N)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (case H (?n + ?k) of (n, N, j') \\<Rightarrow> N)\n  \\<subseteq> (case H ?k of (n, N, j') \\<Rightarrow> N)", "have H_increasing_less: \"(case H k of (n, N, j') \\<Rightarrow> N) \\<supseteq> (case H l of (n, N, j') \\<Rightarrow> insert n N)\"\n    if \"k<l\" for k l"], ["proof (prove)\nusing this:\n  (case H (?n + ?k) of (n, N, j') \\<Rightarrow> N)\n  \\<subseteq> (case H ?k of (n, N, j') \\<Rightarrow> N)\n\ngoal (1 subgoal):\n 1. (case H l of (n, N, j') \\<Rightarrow> insert n N)\n    \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)", "by (metis (no_types, lifting) H_increasing_Suc add.commute less_imp_Suc_add order_trans that)"], ["proof (state)\nthis:\n  ?k < ?l \\<Longrightarrow>\n  (case H ?l of (n, N, j') \\<Rightarrow> insert n N)\n  \\<subseteq> (case H ?k of (n, N, j') \\<Rightarrow> N)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<nu> k < \\<nu> (Suc k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> k < \\<nu> (Suc k)", "using H\\<Phi> [of k]"], ["proof (prove)\nusing this:\n  case H k of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal (1 subgoal):\n 1. \\<nu> k < \\<nu> (Suc k)", "unfolding \\<nu>_def"], ["proof (prove)\nusing this:\n  case H k of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal (1 subgoal):\n 1. (case H k of (n, M, j) \\<Rightarrow> n)\n    < (case H (Suc k) of (n, M, j) \\<Rightarrow> n)", "by (auto simp: H_simps split: prod.split dest: G_increasing [where l=k])"], ["proof (state)\nthis:\n  \\<nu> ?k < \\<nu> (Suc ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<nu> ?k < \\<nu> (Suc ?k)", "have strict_mono_\\<nu>: \"strict_mono \\<nu>\""], ["proof (prove)\nusing this:\n  \\<nu> ?k < \\<nu> (Suc ?k)\n\ngoal (1 subgoal):\n 1. strict_mono \\<nu>", "by (simp add: strict_mono_Suc_iff)"], ["proof (state)\nthis:\n  strict_mono \\<nu>\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  strict_mono \\<nu>", "have enum_N: \"enum ?N = \\<nu>\""], ["proof (prove)\nusing this:\n  strict_mono \\<nu>\n\ngoal (1 subgoal):\n 1. enum (range \\<nu>) = \\<nu>", "by (metis enum_works nat_infinite_iff range_strict_mono_ext)"], ["proof (state)\nthis:\n  enum (range \\<nu>) = \\<nu>\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have **: \"?N \\<inter> {n<..} \\<subseteq> N'\" if H: \"H k = (n, N', j)\" for n N' k j"], ["proof (prove)\ngoal (1 subgoal):\n 1. range \\<nu> \\<inter> {n<..} \\<subseteq> N'", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < \\<nu> xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<nu> xa \\<in> N'", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < \\<nu> xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<nu> xa \\<in> N'", "assume \"n < \\<nu> l\""], ["proof (state)\nthis:\n  n < \\<nu> l\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < \\<nu> xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<nu> xa \\<in> N'", "then"], ["proof (chain)\npicking this:\n  n < \\<nu> l", "have False if \"l \\<le> k\""], ["proof (prove)\nusing this:\n  n < \\<nu> l\n\ngoal (1 subgoal):\n 1. False", "using that strict_monoD [OF strict_mono_\\<nu>, of l k ] H"], ["proof (prove)\nusing this:\n  n < \\<nu> l\n  l \\<le> k\n  l < k \\<Longrightarrow> \\<nu> l < \\<nu> k\n  H k = (n, N', j)\n\ngoal (1 subgoal):\n 1. False", "by (force simp: \\<nu>_def)"], ["proof (state)\nthis:\n  l \\<le> k \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < \\<nu> xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<nu> xa \\<in> N'", "then"], ["proof (chain)\npicking this:\n  l \\<le> k \\<Longrightarrow> False", "have \"k < l\""], ["proof (prove)\nusing this:\n  l \\<le> k \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. k < l", "using not_less"], ["proof (prove)\nusing this:\n  l \\<le> k \\<Longrightarrow> False\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. k < l", "by blast"], ["proof (state)\nthis:\n  k < l\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < \\<nu> xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<nu> xa \\<in> N'", "then"], ["proof (chain)\npicking this:\n  k < l", "obtain M j where Mj: \"H l = (\\<nu> l,M,j)\""], ["proof (prove)\nusing this:\n  k < l\n\ngoal (1 subgoal):\n 1. (\\<And>M j.\n        H l = (\\<nu> l, M, j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<nu>_def"], ["proof (prove)\nusing this:\n  k < l\n\ngoal (1 subgoal):\n 1. (\\<And>M j.\n        H l =\n        (case H l of (n, M, j) \\<Rightarrow> n, M, j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, lifting) case_prod_conv old.prod.exhaust)"], ["proof (state)\nthis:\n  H l = (\\<nu> l, M, j)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < \\<nu> xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<nu> xa \\<in> N'", "then"], ["proof (chain)\npicking this:\n  H l = (\\<nu> l, M, j)", "show \"\\<nu> l \\<in> N'\""], ["proof (prove)\nusing this:\n  H l = (\\<nu> l, M, j)\n\ngoal (1 subgoal):\n 1. \\<nu> l \\<in> N'", "using that H_increasing_less [OF \\<open>k<l\\<close>] Mj"], ["proof (prove)\nusing this:\n  H l = (\\<nu> l, M, j)\n  H k = (n, N', ja__)\n  (case H l of (n, N, j') \\<Rightarrow> insert n N)\n  \\<subseteq> (case H k of (n, N, j') \\<Rightarrow> N)\n  H l = (\\<nu> l, M, j)\n\ngoal (1 subgoal):\n 1. \\<nu> l \\<in> N'", "by auto"], ["proof (state)\nthis:\n  \\<nu> l \\<in> N'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H ?k = (?n, ?N', ?j) \\<Longrightarrow>\n  range \\<nu> \\<inter> {?n<..} \\<subseteq> ?N'\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> g u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. infinite ?N\n 2. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum ?N k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> ?N\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "show \"infinite (?N::nat set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (range \\<nu>)", "using H_inc infinite_nat_iff_unbounded_le"], ["proof (prove)\nusing this:\n  ?l \\<le> \\<nu> ?l\n  infinite ?S = (\\<forall>m. \\<exists>n\\<ge>m. n \\<in> ?S)\n\ngoal (1 subgoal):\n 1. infinite (range \\<nu>)", "by auto"], ["proof (state)\nthis:\n  infinite (range \\<nu>)\n\ngoal (1 subgoal):\n 1. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum (range \\<nu>) k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum (range \\<nu>) k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "fix l U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum (range \\<nu>) k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "assume \"0 < l\" and U: \"U \\<in> [WW]\\<^bsup>2\\<^esup>\"\n      and interU: \"[enum ?N l] < inter_scheme l U\" \"Form l U\"\n      and sub: \"list.set (inter_scheme l U) \\<subseteq> ?N\""], ["proof (state)\nthis:\n  0 < l\n  U \\<in> [WW]\\<^bsup>2\\<^esup>\n  [enum (range \\<nu>) l] < inter_scheme l U\n  Form l U\n  list.set (inter_scheme l U) \\<subseteq> range \\<nu>\n\ngoal (1 subgoal):\n 1. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum (range \\<nu>) k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "obtain k where k: \"l = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. l = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>0 < l\\<close> gr0_conv_Suc"], ["proof (prove)\nusing this:\n  0 < l\n  (0 < ?n) = (\\<exists>m. ?n = Suc m)\n\ngoal (1 subgoal):\n 1. (\\<And>k. l = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  l = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum (range \\<nu>) k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "have \"U \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> WW", "using U"], ["proof (prove)\nusing this:\n  U \\<in> [WW]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. U \\<subseteq> WW", "by (auto simp: nsets_def)"], ["proof (state)\nthis:\n  U \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum (range \\<nu>) k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "moreover"], ["proof (state)\nthis:\n  U \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum (range \\<nu>) k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "have \"g U = v\" if \"H k = (m, M, j0)\" and \"G k m M = (n, N', v)\"\n      for m M j0 n N' v"], ["proof (prove)\ngoal (1 subgoal):\n 1. g U = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g U = v", "have n: \"\\<nu> (Suc k) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (Suc k) = n", "using that"], ["proof (prove)\nusing this:\n  H k = (m, M, j0)\n  G k m M = (n, N', v)\n\ngoal (1 subgoal):\n 1. \\<nu> (Suc k) = n", "by (simp add: \\<nu>_def H_simps)"], ["proof (state)\nthis:\n  \\<nu> (Suc k) = n\n\ngoal (1 subgoal):\n 1. g U = v", "have \"{..enum (range \\<nu>) l} \\<inter> list.set (inter_scheme l U) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..enum (range \\<nu>) l} \\<inter> list.set (inter_scheme l U) = {}", "using inter_scheme_strict_sorted \\<open>0 < l\\<close> interU singleton_less_list_iff strict_sorted_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>Form ?l ?U; 0 < ?l\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (inter_scheme ?l ?U)\n  0 < l\n  [enum (range \\<nu>) l] < inter_scheme l U\n  Form l U\n  sorted ?xs \\<Longrightarrow>\n  ([?n] < ?xs) = ({..?n} \\<inter> list.set ?xs = {})\n  strict_sorted ?l = (sorted ?l \\<and> distinct ?l)\n\ngoal (1 subgoal):\n 1. {..enum (range \\<nu>) l} \\<inter> list.set (inter_scheme l U) = {}", "by blast"], ["proof (state)\nthis:\n  {..enum (range \\<nu>) l} \\<inter> list.set (inter_scheme l U) = {}\n\ngoal (1 subgoal):\n 1. g U = v", "then"], ["proof (chain)\npicking this:\n  {..enum (range \\<nu>) l} \\<inter> list.set (inter_scheme l U) = {}", "have \"list.set (inter_scheme (Suc k) U) \\<subseteq> N'\""], ["proof (prove)\nusing this:\n  {..enum (range \\<nu>) l} \\<inter> list.set (inter_scheme l U) = {}\n\ngoal (1 subgoal):\n 1. list.set (inter_scheme (Suc k) U) \\<subseteq> N'", "using that sub ** [of \"Suc k\" n N' v] Suc_le_eq not_less_eq_eq"], ["proof (prove)\nusing this:\n  {..enum (range \\<nu>) l} \\<inter> list.set (inter_scheme l U) = {}\n  H k = (m, M, j0)\n  G k m M = (n, N', v)\n  list.set (inter_scheme l U) \\<subseteq> range \\<nu>\n  H (Suc k) = (n, N', v) \\<Longrightarrow>\n  range \\<nu> \\<inter> {n<..} \\<subseteq> N'\n  (Suc ?m \\<le> ?n) = (?m < ?n)\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. list.set (inter_scheme (Suc k) U) \\<subseteq> N'", "by (fastforce simp add:  k n enum_N H_simps)"], ["proof (state)\nthis:\n  list.set (inter_scheme (Suc k) U) \\<subseteq> N'\n\ngoal (1 subgoal):\n 1. g U = v", "then"], ["proof (chain)\npicking this:\n  list.set (inter_scheme (Suc k) U) \\<subseteq> N'", "show ?thesis"], ["proof (prove)\nusing this:\n  list.set (inter_scheme (Suc k) U) \\<subseteq> N'\n\ngoal (1 subgoal):\n 1. g U = v", "using that interU \\<open>U \\<subseteq> WW\\<close> G\\<Psi> [of m M k] H\\<Phi> [of k]"], ["proof (prove)\nusing this:\n  list.set (inter_scheme (Suc k) U) \\<subseteq> N'\n  H k = (m, M, j0)\n  G k m M = (n, N', v)\n  [enum (range \\<nu>) l] < inter_scheme l U\n  Form l U\n  U \\<subseteq> WW\n  \\<Phi> m M \\<Longrightarrow>\n  case G k m M of (n, N, j) \\<Rightarrow> \\<Psi> (Suc k) m n M N j\n  case H k of (n, N, j) \\<Rightarrow> \\<Phi> n N\n\ngoal (1 subgoal):\n 1. g U = v", "by (auto simp: \\<Psi>_def k enum_N H_simps n)"], ["proof (state)\nthis:\n  g U = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>H k = (?m, ?M, ?j0.0); G k ?m ?M = (?n, ?N', ?v)\\<rbrakk>\n  \\<Longrightarrow> g U = ?v\n\ngoal (1 subgoal):\n 1. \\<And>k u.\n       \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n        [enum (range \\<nu>) k] < inter_scheme k u;\n        list.set (inter_scheme k u) \\<subseteq> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> g u = ?j k", "ultimately"], ["proof (chain)\npicking this:\n  U \\<subseteq> WW\n  \\<lbrakk>H k = (?m, ?M, ?j0.0); G k ?m ?M = (?n, ?N', ?v)\\<rbrakk>\n  \\<Longrightarrow> g U = ?v", "show \"g U = j l\""], ["proof (prove)\nusing this:\n  U \\<subseteq> WW\n  \\<lbrakk>H k = (?m, ?M, ?j0.0); G k ?m ?M = (?n, ?N', ?v)\\<rbrakk>\n  \\<Longrightarrow> g U = ?v\n\ngoal (1 subgoal):\n 1. g U = j l", "by (auto simp: k j_def H_simps split: prod.split)"], ["proof (state)\nthis:\n  g U = j l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Larson's Lemma 3.7\\<close>"], ["", "subsubsection \\<open>Preliminaries\\<close>"], ["", "text \\<open>Analogous to @{thm [source] ordered_nsets_2_eq}, but without type classes\\<close>"], ["", "lemma total_order_nsets_2_eq:\n  assumes tot: \"total_on A r\" and irr: \"irrefl r\"\n  shows \"nsets A 2 = {{x,y} | x y. x \\<in> A \\<and> y \\<in> A \\<and> (x,y) \\<in> r}\"\n     (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. [A]\\<^bsup>2\\<^esup> =\n    {{x, y} |x y. x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. [A]\\<^bsup>2\\<^esup>\n    \\<subseteq> {{x, y} |x y.\n                 x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}\n 2. {{x, y} |x y. x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}\n    \\<subseteq> [A]\\<^bsup>2\\<^esup>", "show \"nsets A 2 \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [A]\\<^bsup>2\\<^esup>\n    \\<subseteq> {{x, y} |x y.\n                 x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}", "unfolding numeral_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. [A]\\<^bsup>Suc (Suc 0)\\<^esup>\n    \\<subseteq> {{x, y} |x y.\n                 x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}", "apply (clarsimp simp add: nsets_def card_Suc_eq Set.doubleton_eq_iff not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ba.\n       \\<lbrakk>\\<forall>x y.\n                   y \\<in> A \\<longrightarrow>\n                   x \\<in> A \\<longrightarrow>\n                   (b = x \\<longrightarrow> ba \\<noteq> y) \\<and>\n                   (b = y \\<longrightarrow> ba \\<noteq> x) \\<or>\n                   (x, y) \\<notin> r;\n        b \\<in> A; ba \\<in> A\\<rbrakk>\n       \\<Longrightarrow> b = ba", "by (metis tot total_on_def)"], ["proof (state)\nthis:\n  [A]\\<^bsup>2\\<^esup>\n  \\<subseteq> {{x, y} |x y.\n               x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}\n\ngoal (1 subgoal):\n 1. {{x, y} |x y. x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}\n    \\<subseteq> [A]\\<^bsup>2\\<^esup>", "show \"?rhs \\<subseteq> nsets A 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{x, y} |x y. x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}\n    \\<subseteq> [A]\\<^bsup>2\\<^esup>", "using irr"], ["proof (prove)\nusing this:\n  irrefl r\n\ngoal (1 subgoal):\n 1. {{x, y} |x y. x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}\n    \\<subseteq> [A]\\<^bsup>2\\<^esup>", "unfolding numeral_nat"], ["proof (prove)\nusing this:\n  irrefl r\n\ngoal (1 subgoal):\n 1. {{x, y} |x y. x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}\n    \\<subseteq> [A]\\<^bsup>Suc (Suc 0)\\<^esup>", "by (force simp: nsets_def card_Suc_eq irrefl_def)"], ["proof (state)\nthis:\n  {{x, y} |x y. x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> r}\n  \\<subseteq> [A]\\<^bsup>2\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lenlex_nsets_2_eq: \"nsets A 2 = {{x,y} | x y. x \\<in> A \\<and> y \\<in> A \\<and> (x,y) \\<in> lenlex less_than}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [A]\\<^bsup>2\\<^esup> =\n    {{x, y} |x y.\n     x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> lenlex less_than}", "using total_order_nsets_2_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>total_on ?A ?r; irrefl ?r\\<rbrakk>\n  \\<Longrightarrow> [?A]\\<^bsup>2\\<^esup> =\n                    {{x, y} |x y.\n                     x \\<in> ?A \\<and> y \\<in> ?A \\<and> (x, y) \\<in> ?r}\n\ngoal (1 subgoal):\n 1. [A]\\<^bsup>2\\<^esup> =\n    {{x, y} |x y.\n     x \\<in> A \\<and> y \\<in> A \\<and> (x, y) \\<in> lenlex less_than}", "by (simp add: total_order_nsets_2_eq irrefl_def)"], ["", "lemma sum_sorted_list_of_set_map: \"finite I \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "proof (induction \"card I\" arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I\n 2. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; finite I\\<rbrakk>\n                   \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I;\n        Suc x = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "case 0"], ["proof (state)\nthis:\n  0 = card I\n  finite I\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I\n 2. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; finite I\\<rbrakk>\n                   \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I;\n        Suc x = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "then"], ["proof (chain)\npicking this:\n  0 = card I\n  finite I", "show ?case"], ["proof (prove)\nusing this:\n  0 = card I\n  finite I\n\ngoal (1 subgoal):\n 1. sum_list (map f (list_of I)) = sum f I", "by auto"], ["proof (state)\nthis:\n  sum_list (map f (list_of I)) = sum f I\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; finite I\\<rbrakk>\n                   \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I;\n        Suc x = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; finite I\\<rbrakk>\n                   \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I;\n        Suc x = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "case (Suc n I)"], ["proof (state)\nthis:\n  \\<lbrakk>n = card ?I; finite ?I\\<rbrakk>\n  \\<Longrightarrow> sum_list (map f (list_of ?I)) = sum f ?I\n  Suc n = card I\n  finite I\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; finite I\\<rbrakk>\n                   \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I;\n        Suc x = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = card ?I; finite ?I\\<rbrakk>\n  \\<Longrightarrow> sum_list (map f (list_of ?I)) = sum f ?I\n  Suc n = card I\n  finite I", "have [simp]: \"I \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card ?I; finite ?I\\<rbrakk>\n  \\<Longrightarrow> sum_list (map f (list_of ?I)) = sum f ?I\n  Suc n = card I\n  finite I\n\ngoal (1 subgoal):\n 1. I \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; finite I\\<rbrakk>\n                   \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I;\n        Suc x = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "moreover"], ["proof (state)\nthis:\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; finite I\\<rbrakk>\n                   \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I;\n        Suc x = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "have \"sum_list (map f (list_of (I - {Min I}))) = sum f (I - {Min I})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (list_of (I - {Min I}))) = sum f (I - {Min I})", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card ?I; finite ?I\\<rbrakk>\n  \\<Longrightarrow> sum_list (map f (list_of ?I)) = sum f ?I\n  Suc n = card I\n  finite I\n\ngoal (1 subgoal):\n 1. sum_list (map f (list_of (I - {Min I}))) = sum f (I - {Min I})", "by auto"], ["proof (state)\nthis:\n  sum_list (map f (list_of (I - {Min I}))) = sum f (I - {Min I})\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; finite I\\<rbrakk>\n                   \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I;\n        Suc x = card I; finite I\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (list_of I)) = sum f I", "ultimately"], ["proof (chain)\npicking this:\n  I \\<noteq> {}\n  sum_list (map f (list_of (I - {Min I}))) = sum f (I - {Min I})", "show ?case"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n  sum_list (map f (list_of (I - {Min I}))) = sum f (I - {Min I})\n\ngoal (1 subgoal):\n 1. sum_list (map f (list_of I)) = sum f I", "using Suc.prems sum.remove [of I \"Min I\" f]"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n  sum_list (map f (list_of (I - {Min I}))) = sum f (I - {Min I})\n  finite I\n  \\<lbrakk>finite I; Min I \\<in> I\\<rbrakk>\n  \\<Longrightarrow> sum f I = f (Min I) + sum f (I - {Min I})\n\ngoal (1 subgoal):\n 1. sum_list (map f (list_of I)) = sum f I", "by (simp add: sorted_list_of_set_nonempty Suc)"], ["proof (state)\nthis:\n  sum_list (map f (list_of I)) = sum f I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_list_of_set_UN_eq_concat:\n  assumes I: \"strict_mono_sets I f\" \"finite I\" and fin: \"\\<And>i. finite (f i)\"\n  shows \"list_of (\\<Union>i \\<in> I. f i) = concat (map (list_of \\<circ> f) (list_of I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` I)) =\n    concat (map (list_of \\<circ> f) (list_of I))", "using I"], ["proof (prove)\nusing this:\n  strict_mono_sets I f\n  finite I\n\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` I)) =\n    concat (map (list_of \\<circ> f) (list_of I))", "proof (induction \"card I\" arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))\n 2. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "case 0"], ["proof (state)\nthis:\n  0 = card I\n  strict_mono_sets I f\n  finite I\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))\n 2. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "then"], ["proof (chain)\npicking this:\n  0 = card I\n  strict_mono_sets I f\n  finite I", "have \"I={}\""], ["proof (prove)\nusing this:\n  0 = card I\n  strict_mono_sets I f\n  finite I\n\ngoal (1 subgoal):\n 1. I = {}", "by auto"], ["proof (state)\nthis:\n  I = {}\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))\n 2. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "then"], ["proof (chain)\npicking this:\n  I = {}", "show ?case"], ["proof (prove)\nusing this:\n  I = {}\n\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` I)) =\n    concat (map (list_of \\<circ> f) (list_of I))", "by auto"], ["proof (state)\nthis:\n  list_of (\\<Union> (f ` I)) = concat (map (list_of \\<circ> f) (list_of I))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "case (Suc n I)"], ["proof (state)\nthis:\n  \\<lbrakk>n = card ?I; strict_mono_sets ?I f; finite ?I\\<rbrakk>\n  \\<Longrightarrow> list_of (\\<Union> (f ` ?I)) =\n                    concat (map (list_of \\<circ> f) (list_of ?I))\n  Suc n = card I\n  strict_mono_sets I f\n  finite I\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = card ?I; strict_mono_sets ?I f; finite ?I\\<rbrakk>\n  \\<Longrightarrow> list_of (\\<Union> (f ` ?I)) =\n                    concat (map (list_of \\<circ> f) (list_of ?I))\n  Suc n = card I\n  strict_mono_sets I f\n  finite I", "have \"I \\<noteq> {}\" and Iexp: \"I = insert (Min I) (I - {Min I})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card ?I; strict_mono_sets ?I f; finite ?I\\<rbrakk>\n  \\<Longrightarrow> list_of (\\<Union> (f ` ?I)) =\n                    concat (map (list_of \\<circ> f) (list_of ?I))\n  Suc n = card I\n  strict_mono_sets I f\n  finite I\n\ngoal (1 subgoal):\n 1. I \\<noteq> {} &&& I = insert (Min I) (I - {Min I})", "using Min_in Suc.hyps(2) Suc.prems(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card ?I; strict_mono_sets ?I f; finite ?I\\<rbrakk>\n  \\<Longrightarrow> list_of (\\<Union> (f ` ?I)) =\n                    concat (map (list_of \\<circ> f) (list_of ?I))\n  Suc n = card I\n  strict_mono_sets I f\n  finite I\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min ?A \\<in> ?A\n  Suc n = card I\n  finite I\n\ngoal (1 subgoal):\n 1. I \\<noteq> {} &&& I = insert (Min I) (I - {Min I})", "by fastforce+"], ["proof (state)\nthis:\n  I \\<noteq> {}\n  I = insert (Min I) (I - {Min I})\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "have IH: \"list_of (\\<Union> (f ` (I - {Min I}))) = concat (map (list_of \\<circ> f) (list_of (I - {Min I})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` (I - {Min I}))) =\n    concat (map (list_of \\<circ> f) (list_of (I - {Min I})))", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card ?I; strict_mono_sets ?I f; finite ?I\\<rbrakk>\n  \\<Longrightarrow> list_of (\\<Union> (f ` ?I)) =\n                    concat (map (list_of \\<circ> f) (list_of ?I))\n  Suc n = card I\n  strict_mono_sets I f\n  finite I\n\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` (I - {Min I}))) =\n    concat (map (list_of \\<circ> f) (list_of (I - {Min I})))", "by (metis DiffE Min_in \\<open>I \\<noteq> {}\\<close> card_Diff_singleton diff_Suc_1 finite_Diff strict_mono_sets_def)"], ["proof (state)\nthis:\n  list_of (\\<Union> (f ` (I - {Min I}))) =\n  concat (map (list_of \\<circ> f) (list_of (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "have \"list_of (\\<Union> (f ` I)) = list_of (\\<Union> (f ` (insert (Min I) (I - {Min I}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` I)) =\n    list_of (\\<Union> (f ` insert (Min I) (I - {Min I})))", "using Iexp"], ["proof (prove)\nusing this:\n  I = insert (Min I) (I - {Min I})\n\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` I)) =\n    list_of (\\<Union> (f ` insert (Min I) (I - {Min I})))", "by auto"], ["proof (state)\nthis:\n  list_of (\\<Union> (f ` I)) =\n  list_of (\\<Union> (f ` insert (Min I) (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "also"], ["proof (state)\nthis:\n  list_of (\\<Union> (f ` I)) =\n  list_of (\\<Union> (f ` insert (Min I) (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "have \"\\<dots> = list_of (f (Min I) \\<union> \\<Union> (f ` (I - {Min I})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` insert (Min I) (I - {Min I}))) =\n    list_of (f (Min I) \\<union> \\<Union> (f ` (I - {Min I})))", "by (metis Union_image_insert)"], ["proof (state)\nthis:\n  list_of (\\<Union> (f ` insert (Min I) (I - {Min I}))) =\n  list_of (f (Min I) \\<union> \\<Union> (f ` (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "also"], ["proof (state)\nthis:\n  list_of (\\<Union> (f ` insert (Min I) (I - {Min I}))) =\n  list_of (f (Min I) \\<union> \\<Union> (f ` (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "have \"\\<dots> = list_of (f (Min I)) @ list_of (\\<Union> (f ` (I - {Min I})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (f (Min I) \\<union> \\<Union> (f ` (I - {Min I}))) =\n    list_of (f (Min I)) @ list_of (\\<Union> (f ` (I - {Min I})))", "proof (rule sorted_list_of_set_Un)"], ["proof (state)\ngoal (3 subgoals):\n 1. f (Min I) \\<lless> \\<Union> (f ` (I - {Min I}))\n 2. finite (f (Min I))\n 3. finite (\\<Union> (f ` (I - {Min I})))", "show \"f (Min I) \\<lless> \\<Union> (f ` (I - {Min I}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Min I) \\<lless> \\<Union> (f ` (I - {Min I}))", "using Suc.prems \\<open>I \\<noteq> {}\\<close> strict_mono_less_sets_Min"], ["proof (prove)\nusing this:\n  strict_mono_sets I f\n  finite I\n  I \\<noteq> {}\n  \\<lbrakk>strict_mono_sets ?I ?f; finite ?I; ?I \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?f (Min ?I) \\<lless> \\<Union> (?f ` (?I - {Min ?I}))\n\ngoal (1 subgoal):\n 1. f (Min I) \\<lless> \\<Union> (f ` (I - {Min I}))", "by blast"], ["proof (state)\nthis:\n  f (Min I) \\<lless> \\<Union> (f ` (I - {Min I}))\n\ngoal (2 subgoals):\n 1. finite (f (Min I))\n 2. finite (\\<Union> (f ` (I - {Min I})))", "show \"finite (\\<Union> (f ` (I - {Min I})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (f ` (I - {Min I})))", "by (simp add: \\<open>finite I\\<close> fin)"], ["proof (state)\nthis:\n  finite (\\<Union> (f ` (I - {Min I})))\n\ngoal (1 subgoal):\n 1. finite (f (Min I))", "qed (use fin in auto)"], ["proof (state)\nthis:\n  list_of (f (Min I) \\<union> \\<Union> (f ` (I - {Min I}))) =\n  list_of (f (Min I)) @ list_of (\\<Union> (f ` (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "also"], ["proof (state)\nthis:\n  list_of (f (Min I) \\<union> \\<Union> (f ` (I - {Min I}))) =\n  list_of (f (Min I)) @ list_of (\\<Union> (f ` (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "have \"\\<dots> = list_of (f (Min I)) @ concat (map (list_of \\<circ> f) (list_of (I - {Min I})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (f (Min I)) @ list_of (\\<Union> (f ` (I - {Min I}))) =\n    list_of (f (Min I)) @\n    concat (map (list_of \\<circ> f) (list_of (I - {Min I})))", "using IH"], ["proof (prove)\nusing this:\n  list_of (\\<Union> (f ` (I - {Min I}))) =\n  concat (map (list_of \\<circ> f) (list_of (I - {Min I})))\n\ngoal (1 subgoal):\n 1. list_of (f (Min I)) @ list_of (\\<Union> (f ` (I - {Min I}))) =\n    list_of (f (Min I)) @\n    concat (map (list_of \\<circ> f) (list_of (I - {Min I})))", "by metis"], ["proof (state)\nthis:\n  list_of (f (Min I)) @ list_of (\\<Union> (f ` (I - {Min I}))) =\n  list_of (f (Min I)) @\n  concat (map (list_of \\<circ> f) (list_of (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "also"], ["proof (state)\nthis:\n  list_of (f (Min I)) @ list_of (\\<Union> (f ` (I - {Min I}))) =\n  list_of (f (Min I)) @\n  concat (map (list_of \\<circ> f) (list_of (I - {Min I})))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "have \"\\<dots> = concat (map (list_of \\<circ> f) (list_of I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (f (Min I)) @\n    concat (map (list_of \\<circ> f) (list_of (I - {Min I}))) =\n    concat (map (list_of \\<circ> f) (list_of I))", "by (simp add: Suc.prems(2) \\<open>I \\<noteq> {}\\<close> sorted_list_of_set_nonempty)"], ["proof (state)\nthis:\n  list_of (f (Min I)) @\n  concat (map (list_of \\<circ> f) (list_of (I - {Min I}))) =\n  concat (map (list_of \\<circ> f) (list_of I))\n\ngoal (1 subgoal):\n 1. \\<And>x I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>x = card I; strict_mono_sets I f;\n                    finite I\\<rbrakk>\n                   \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                                     concat\n(map (list_of \\<circ> f) (list_of I));\n        Suc x = card I; strict_mono_sets I f; finite I\\<rbrakk>\n       \\<Longrightarrow> list_of (\\<Union> (f ` I)) =\n                         concat (map (list_of \\<circ> f) (list_of I))", "finally"], ["proof (chain)\npicking this:\n  list_of (\\<Union> (f ` I)) = concat (map (list_of \\<circ> f) (list_of I))", "show ?case"], ["proof (prove)\nusing this:\n  list_of (\\<Union> (f ` I)) = concat (map (list_of \\<circ> f) (list_of I))\n\ngoal (1 subgoal):\n 1. list_of (\\<Union> (f ` I)) =\n    concat (map (list_of \\<circ> f) (list_of I))", "."], ["proof (state)\nthis:\n  list_of (\\<Union> (f ` I)) = concat (map (list_of \\<circ> f) (list_of I))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lemma 3.7 of Jean A. Larson, ibid.\\<close>"], ["", "text \\<open>Possibly should be redone using grab\\<close>"], ["", "proposition lemma_3_7:\n  assumes \"infinite N\" \"l > 0\"\n  obtains M where \"M \\<in> [WW]\\<^bsup>m\\<^esup>\"\n                  \"\\<And>U. U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow> Form l U \\<and> List.set (inter_scheme l U) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n         \\<And>U.\n            U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            Form l U \\<and>\n            list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"m < 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  m < 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain w where w: \"w \\<in> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> WW \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using WW_def strict_sorted_into_WW"], ["proof (prove)\nusing this:\n  WW \\<equiv> {l. strict_sorted l}\n  strict_sorted (into_WW ?x ?ns)\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> WW \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> WW\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "define M where \"M \\<equiv> if m=0 then {} else {w}\""], ["proof (state)\nthis:\n  M \\<equiv> if m = 0 then {} else {w}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have M: \"M \\<in> [WW]\\<^bsup>m\\<^esup>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> [WW]\\<^bsup>m\\<^esup>", "using True"], ["proof (prove)\nusing this:\n  m < 2\n\ngoal (1 subgoal):\n 1. M \\<in> [WW]\\<^bsup>m\\<^esup>", "by (auto simp: M_def nsets_def w)"], ["proof (state)\nthis:\n  M \\<in> [WW]\\<^bsup>m\\<^esup>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have [simp]: \"[M]\\<^bsup>2\\<^esup> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsup>2\\<^esup> = {}", "using True"], ["proof (prove)\nusing this:\n  m < 2\n\ngoal (1 subgoal):\n 1. [M]\\<^bsup>2\\<^esup> = {}", "by (auto simp: M_def nsets_def w dest: subset_singletonD)"], ["proof (state)\nthis:\n  [M]\\<^bsup>2\\<^esup> = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using M that"], ["proof (prove)\nusing this:\n  M \\<in> [WW]\\<^bsup>m\\<^esup>\n  \\<lbrakk>?M \\<in> [WW]\\<^bsup>m\\<^esup>;\n   \\<And>U.\n      U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n      Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> m < 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<not> m < 2", "have \"m \\<ge> 2\""], ["proof (prove)\nusing this:\n  \\<not> m < 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> m", "by auto"], ["proof (state)\nthis:\n  2 \\<le> m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have nonz: \"(enum N \\<circ> Suc) i > 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (enum N \\<circ> Suc) i", "using assms(1) le_enumerate less_le_trans"], ["proof (prove)\nusing this:\n  infinite N\n  infinite ?S \\<Longrightarrow> ?n \\<le> enum ?S ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. 0 < (enum N \\<circ> Suc) i", "by fastforce"], ["proof (state)\nthis:\n  0 < (enum N \\<circ> Suc) ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "note infinite_nxtN [OF \\<open>infinite N\\<close>, iff]"], ["proof (state)\nthis:\n  infinite (nxt N ?n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have [simp]: \"{n<..<Suc n} = {}\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n<..<Suc n} = {}", "by auto"], ["proof (state)\nthis:\n  {?n<..<Suc ?n} = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "define DF where \"DF \\<equiv> \\<lambda>k. rec_nat ((enum N \\<circ> Suc) ` {..<Suc k}) (\\<lambda>r D. enum (nxt N (enum (nxt N (Max D)) (Inf D - Suc 0))) ` {..<Suc k})\""], ["proof (state)\nthis:\n  DF \\<equiv>\n  \\<lambda>k.\n     rec_nat ((enum N \\<circ> Suc) ` {..<Suc k})\n      (\\<lambda>r D.\n          enum (nxt N (enum (nxt N (Max D)) (\\<Sqinter> D - Suc 0))) `\n          {..<Suc k})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have DF_simps: \"DF k 0 = (enum N \\<circ> Suc) ` {..<Suc k}\"\n    \"DF k (Suc i) = enum (nxt N (enum (nxt N (Max (DF k i))) (Inf (DF k i) - Suc 0))) ` {..<Suc k}\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF k 0 = (enum N \\<circ> Suc) ` {..<Suc k} &&&\n    DF k (Suc i) =\n    enum\n     (nxt N (enum (nxt N (Max (DF k i))) (\\<Sqinter> (DF k i) - Suc 0))) `\n    {..<Suc k}", "by (auto simp: DF_def)"], ["proof (state)\nthis:\n  DF ?k 0 = (enum N \\<circ> Suc) ` {..<Suc ?k}\n  DF ?k (Suc ?i) =\n  enum\n   (nxt N (enum (nxt N (Max (DF ?k ?i))) (\\<Sqinter> (DF ?k ?i) - Suc 0))) `\n  {..<Suc ?k}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have card_DF: \"card (DF k i) = Suc k\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DF k i) = Suc k", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. card (DF k 0) = Suc k\n 2. \\<And>i.\n       card (DF k i) = Suc k \\<Longrightarrow> card (DF k (Suc i)) = Suc k", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. card (DF k 0) = Suc k\n 2. \\<And>i.\n       card (DF k i) = Suc k \\<Longrightarrow> card (DF k (Suc i)) = Suc k", "have \"inj_on (enum N \\<circ> Suc) {..<Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (enum N \\<circ> Suc) {..<Suc k}", "by (simp add: assms(1) comp_inj_on strict_mono_enum strict_mono_imp_inj_on)"], ["proof (state)\nthis:\n  inj_on (enum N \\<circ> Suc) {..<Suc k}\n\ngoal (2 subgoals):\n 1. card (DF k 0) = Suc k\n 2. \\<And>i.\n       card (DF k i) = Suc k \\<Longrightarrow> card (DF k (Suc i)) = Suc k", "with 0"], ["proof (chain)\npicking this:\n  inj_on (enum N \\<circ> Suc) {..<Suc k}", "show ?case"], ["proof (prove)\nusing this:\n  inj_on (enum N \\<circ> Suc) {..<Suc k}\n\ngoal (1 subgoal):\n 1. card (DF k 0) = Suc k", "using card_image DF_simps"], ["proof (prove)\nusing this:\n  inj_on (enum N \\<circ> Suc) {..<Suc k}\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n  DF ?k 0 = (enum N \\<circ> Suc) ` {..<Suc ?k}\n  DF ?k (Suc ?i) =\n  enum\n   (nxt N (enum (nxt N (Max (DF ?k ?i))) (\\<Sqinter> (DF ?k ?i) - Suc 0))) `\n  {..<Suc ?k}\n\ngoal (1 subgoal):\n 1. card (DF k 0) = Suc k", "by fastforce"], ["proof (state)\nthis:\n  card (DF k 0) = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       card (DF k i) = Suc k \\<Longrightarrow> card (DF k (Suc i)) = Suc k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       card (DF k i) = Suc k \\<Longrightarrow> card (DF k (Suc i)) = Suc k", "case (Suc i)"], ["proof (state)\nthis:\n  card (DF k i) = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       card (DF k i) = Suc k \\<Longrightarrow> card (DF k (Suc i)) = Suc k", "then"], ["proof (chain)\npicking this:\n  card (DF k i) = Suc k", "show ?case"], ["proof (prove)\nusing this:\n  card (DF k i) = Suc k\n\ngoal (1 subgoal):\n 1. card (DF k (Suc i)) = Suc k", "by (simp add: \\<open>infinite N\\<close> DF_simps card_image infinite_nxtN strict_mono_enum strict_mono_imp_inj_on)"], ["proof (state)\nthis:\n  card (DF k (Suc i)) = Suc k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (DF ?k ?i) = Suc ?k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have DF_ne: \"DF k i \\<noteq> {}\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF k i \\<noteq> {}", "by (metis card_DF card_lessThan lessThan_empty_iff nat.simps(3))"], ["proof (state)\nthis:\n  DF ?k ?i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have DF_N: \"DF k i \\<subseteq> N \\<inter> {0<..}\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF k i \\<subseteq> N \\<inter> {0<..}", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. DF k 0 \\<subseteq> N \\<inter> {0<..}\n 2. \\<And>i.\n       DF k i \\<subseteq> N \\<inter> {0<..} \\<Longrightarrow>\n       DF k (Suc i) \\<subseteq> N \\<inter> {0<..}", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. DF k 0 \\<subseteq> N \\<inter> {0<..}\n 2. \\<And>i.\n       DF k i \\<subseteq> N \\<inter> {0<..} \\<Longrightarrow>\n       DF k (Suc i) \\<subseteq> N \\<inter> {0<..}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF k 0 \\<subseteq> N \\<inter> {0<..}", "using \\<open>infinite N\\<close> range_enum nonz"], ["proof (prove)\nusing this:\n  infinite N\n  infinite ?N \\<Longrightarrow> range (enum ?N) = ?N\n  0 < (enum N \\<circ> Suc) ?i\n\ngoal (1 subgoal):\n 1. DF k 0 \\<subseteq> N \\<inter> {0<..}", "by (auto simp: DF_simps)"], ["proof (state)\nthis:\n  DF k 0 \\<subseteq> N \\<inter> {0<..}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       DF k i \\<subseteq> N \\<inter> {0<..} \\<Longrightarrow>\n       DF k (Suc i) \\<subseteq> N \\<inter> {0<..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       DF k i \\<subseteq> N \\<inter> {0<..} \\<Longrightarrow>\n       DF k (Suc i) \\<subseteq> N \\<inter> {0<..}", "case (Suc i)"], ["proof (state)\nthis:\n  DF k i \\<subseteq> N \\<inter> {0<..}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       DF k i \\<subseteq> N \\<inter> {0<..} \\<Longrightarrow>\n       DF k (Suc i) \\<subseteq> N \\<inter> {0<..}", "then"], ["proof (chain)\npicking this:\n  DF k i \\<subseteq> N \\<inter> {0<..}", "show ?case"], ["proof (prove)\nusing this:\n  DF k i \\<subseteq> N \\<inter> {0<..}\n\ngoal (1 subgoal):\n 1. DF k (Suc i) \\<subseteq> N \\<inter> {0<..}", "unfolding DF_simps image_subset_iff"], ["proof (prove)\nusing this:\n  DF k i \\<subseteq> N \\<inter> {0<..}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<Suc k}.\n       enum\n        (nxt N (enum (nxt N (Max (DF k i))) (\\<Sqinter> (DF k i) - Suc 0)))\n        x\n       \\<in> N \\<inter> {0<..}", "using infinite_nxtN [OF \\<open>infinite N\\<close>]"], ["proof (prove)\nusing this:\n  DF k i \\<subseteq> N \\<inter> {0<..}\n  infinite (nxt N ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<Suc k}.\n       enum\n        (nxt N (enum (nxt N (Max (DF k i))) (\\<Sqinter> (DF k i) - Suc 0)))\n        x\n       \\<in> N \\<inter> {0<..}", "by (metis Int_iff enumerate_in_set greaterThan_iff not_gr0 not_less0 nxt_def)"], ["proof (state)\nthis:\n  DF k (Suc i) \\<subseteq> N \\<inter> {0<..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DF ?k ?i \\<subseteq> N \\<inter> {0<..}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  DF ?k ?i \\<subseteq> N \\<inter> {0<..}", "have DF_gt0: \"0 < Inf (DF k i)\" for i k"], ["proof (prove)\nusing this:\n  DF ?k ?i \\<subseteq> N \\<inter> {0<..}\n\ngoal (1 subgoal):\n 1. 0 < \\<Sqinter> (DF k i)", "using DF_ne Inf_nat_def1"], ["proof (prove)\nusing this:\n  DF ?k ?i \\<subseteq> N \\<inter> {0<..}\n  DF ?k ?i \\<noteq> {}\n  ?K \\<noteq> {} \\<Longrightarrow> \\<Sqinter> ?K \\<in> ?K\n\ngoal (1 subgoal):\n 1. 0 < \\<Sqinter> (DF k i)", "by blast"], ["proof (state)\nthis:\n  0 < \\<Sqinter> (DF ?k ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have finite_DF: \"finite (DF k i)\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DF k i)", "by (induction i) (auto simp: DF_simps)"], ["proof (state)\nthis:\n  finite (DF ?k ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have sm_enum_DF: \"strict_mono_on (enum (DF k i)) {..k}\" for k i"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono_on (enum (DF k i)) {..k}", "by (metis card_DF enum_works_finite finite_DF lessThan_Suc_atMost)"], ["proof (state)\nthis:\n  strict_mono_on (enum (DF ?k ?i)) {..?k}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have DF_Suc: \"DF k i \\<lless> DF k (Suc i)\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF k i \\<lless> DF k (Suc i)", "unfolding less_sets_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>DF k i. \\<forall>y\\<in>DF k (Suc i). x < y", "by (force simp: finite_DF DF_simps\n        intro!: greaterThan_less_enum nxt_subset_greaterThan atLeast_le_enum nxt_subset_atLeast infinite_nxtN [OF \\<open>infinite N\\<close>])"], ["proof (state)\nthis:\n  DF ?k ?i \\<lless> DF ?k (Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have DF_DF: \"DF k i \\<lless> DF k j\" if \"i<j\" for i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF k i \\<lless> DF k j", "by (meson DF_Suc DF_ne UNIV_I less_sets_imp_strict_mono_sets strict_mono_setsD that)"], ["proof (state)\nthis:\n  ?i < ?j \\<Longrightarrow> DF ?k ?i \\<lless> DF ?k ?j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ?i < ?j \\<Longrightarrow> DF ?k ?i \\<lless> DF ?k ?j", "have sm_DF: \"strict_mono_sets UNIV (DF k)\" for k"], ["proof (prove)\nusing this:\n  ?i < ?j \\<Longrightarrow> DF ?k ?i \\<lless> DF ?k ?j\n\ngoal (1 subgoal):\n 1. strict_mono_sets UNIV (DF k)", "by (simp add: strict_mono_sets_def)"], ["proof (state)\nthis:\n  strict_mono_sets UNIV (DF ?k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "define AF where \"AF \\<equiv> \\<lambda>k i. enum (nxt N (Max (DF k i))) ` {..<Inf (DF k i)}\""], ["proof (state)\nthis:\n  AF \\<equiv>\n  \\<lambda>k i. enum (nxt N (Max (DF k i))) ` {..<\\<Sqinter> (DF k i)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have AF_ne: \"AF k i \\<noteq> {}\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. AF k i \\<noteq> {}", "by (auto simp: AF_def lessThan_empty_iff DF_gt0)"], ["proof (state)\nthis:\n  AF ?k ?i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have finite_AF [simp]: \"finite (AF k i)\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (AF k i)", "by (simp add: AF_def)"], ["proof (state)\nthis:\n  finite (AF ?k ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have card_AF: \"card (AF k i) = \\<Sqinter> (DF k i)\" for k i"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF k i) = \\<Sqinter> (DF k i)", "by (simp add: AF_def \\<open>infinite N\\<close> card_image inj_enum_nxt)"], ["proof (state)\nthis:\n  card (AF ?k ?i) = \\<Sqinter> (DF ?k ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have DF_AF: \"DF k i \\<lless> AF k i\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF k i \\<lless> AF k i", "unfolding less_sets_def AF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>DF k i.\n       \\<forall>y\\<in>enum (nxt N (Max (DF k i))) `\n                      {..<\\<Sqinter> (DF k i)}.\n          x < y", "by (simp add: finite_DF \\<open>infinite N\\<close> greaterThan_less_enum nxt_subset_greaterThan)"], ["proof (state)\nthis:\n  DF ?k ?i \\<lless> AF ?k ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have AF_DF_Suc: \"AF k i \\<lless> DF k (Suc i)\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. AF k i \\<lless> DF k (Suc i)", "apply (clarsimp simp: DF_simps less_sets_def AF_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < \\<Sqinter> (DF k i); xa < Suc k\\<rbrakk>\n       \\<Longrightarrow> enum (nxt N (Max (DF k i))) x\n                         < enum\n                            (nxt N\n                              (enum (nxt N (Max (DF k i)))\n                                (\\<Sqinter> (DF k i) - Suc 0)))\n                            xa", "using strict_monoD [OF strict_mono_enum]"], ["proof (prove)\nusing this:\n  \\<lbrakk>infinite ?N1; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> enum ?N1 ?x < enum ?N1 ?y\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < \\<Sqinter> (DF k i); xa < Suc k\\<rbrakk>\n       \\<Longrightarrow> enum (nxt N (Max (DF k i))) x\n                         < enum\n                            (nxt N\n                              (enum (nxt N (Max (DF k i)))\n                                (\\<Sqinter> (DF k i) - Suc 0)))\n                            xa", "by (metis DF_gt0 Suc_pred assms(1) dual_order.order_iff_strict greaterThan_less_enum\n        infinite_nxtN linorder_neqE_nat not_less_eq nxt_subset_greaterThan)"], ["proof (state)\nthis:\n  AF ?k ?i \\<lless> DF ?k (Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have AF_DF: \"AF k p \\<lless> DF k q\" if \"p<q\" for k p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. AF k p \\<lless> DF k q", "using AF_DF_Suc"], ["proof (prove)\nusing this:\n  AF ?k ?i \\<lless> DF ?k (Suc ?i)\n\ngoal (1 subgoal):\n 1. AF k p \\<lless> DF k q", "by (metis DF_ne Suc_lessI UNIV_I less_sets_trans sm_DF strict_mono_sets_def that)"], ["proof (state)\nthis:\n  ?p < ?q \\<Longrightarrow> AF ?k ?p \\<lless> DF ?k ?q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have AF_Suc: \"AF k i \\<lless> AF k (Suc i)\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. AF k i \\<lless> AF k (Suc i)", "using AF_DF_Suc DF_AF DF_ne less_sets_trans"], ["proof (prove)\nusing this:\n  AF ?k ?i \\<lless> DF ?k (Suc ?i)\n  DF ?k ?i \\<lless> AF ?k ?i\n  DF ?k ?i \\<noteq> {}\n  \\<lbrakk>?A \\<lless> ?B; ?B \\<lless> ?C; ?B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?A \\<lless> ?C\n\ngoal (1 subgoal):\n 1. AF k i \\<lless> AF k (Suc i)", "by blast"], ["proof (state)\nthis:\n  AF ?k ?i \\<lless> AF ?k (Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  AF ?k ?i \\<lless> AF ?k (Suc ?i)", "have sm_AF: \"strict_mono_sets UNIV (AF k)\" for k"], ["proof (prove)\nusing this:\n  AF ?k ?i \\<lless> AF ?k (Suc ?i)\n\ngoal (1 subgoal):\n 1. strict_mono_sets UNIV (AF k)", "by (simp add: AF_ne less_sets_imp_strict_mono_sets)"], ["proof (state)\nthis:\n  strict_mono_sets UNIV (AF ?k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "define del where \"del \\<equiv> \\<lambda>k i j. enum (DF k i) j - enum (DF k i) (j - Suc 0)\""], ["proof (state)\nthis:\n  del \\<equiv> \\<lambda>k i j. enum (DF k i) j - enum (DF k i) (j - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "define QF where \"QF k \\<equiv> wfrec pair_less (\\<lambda>f (j,i).\n       if j=0 then AF k i\n       else let r = (if i=0 then f (j-1,m-1) else f (j,i-1)) in\n                enum (nxt N (Suc (Max r))) ` {..< del k (if j=k then m - Suc i else i) j})\"\n    for k"], ["proof (state)\nthis:\n  QF ?k \\<equiv>\n  wfrec pair_less\n   (\\<lambda>f (j, i).\n       if j = 0 then AF ?k i\n       else let r = if i = 0 then f (j - 1, m - 1) else f (j, i - 1)\n            in enum (nxt N (Suc (Max r))) `\n               {..<del ?k (if j = ?k then m - Suc i else i) j})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "note cut_apply [simp]"], ["proof (state)\nthis:\n  (?x, ?a) \\<in> ?R \\<Longrightarrow> cut ?f ?R ?a ?x = ?f ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have finite_QF [simp]: \"finite (QF k p)\" for p k"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (QF k p)", "using wf_pair_less"], ["proof (prove)\nusing this:\n  wf pair_less\n\ngoal (1 subgoal):\n 1. finite (QF k p)", "proof (induction p rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> pair_less \\<Longrightarrow>\n           finite (QF k y)) \\<Longrightarrow>\n       finite (QF k x)", "case (less p)"], ["proof (state)\nthis:\n  (?y, p) \\<in> pair_less \\<Longrightarrow> finite (QF k ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> pair_less \\<Longrightarrow>\n           finite (QF k y)) \\<Longrightarrow>\n       finite (QF k x)", "then"], ["proof (chain)\npicking this:\n  (?y, p) \\<in> pair_less \\<Longrightarrow> finite (QF k ?y)", "show ?case"], ["proof (prove)\nusing this:\n  (?y, p) \\<in> pair_less \\<Longrightarrow> finite (QF k ?y)\n\ngoal (1 subgoal):\n 1. finite (QF k p)", "by (simp add: def_wfrec [OF QF_def, of k p] split: prod.split)"], ["proof (state)\nthis:\n  finite (QF k p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (QF ?k ?p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have del_gt_0: \"\\<lbrakk>j < Suc k; 0 < j\\<rbrakk> \\<Longrightarrow> 0 < del k i j\" for i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc k; 0 < j\\<rbrakk> \\<Longrightarrow> 0 < del k i j", "by (simp add: card_DF del_def finite_DF)"], ["proof (state)\nthis:\n  \\<lbrakk>?j < Suc ?k; 0 < ?j\\<rbrakk> \\<Longrightarrow> 0 < del ?k ?i ?j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have QF_ne [simp]: \"QF k (j,i) \\<noteq> {}\" if j: \"j < Suc k\" for j i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j, i) \\<noteq> {}", "using wf_pair_less j"], ["proof (prove)\nusing this:\n  wf pair_less\n  j < Suc k\n\ngoal (1 subgoal):\n 1. QF k (j, i) \\<noteq> {}", "proof (induction \"(j,i)\" rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>((j, i), j, i) \\<in> pair_less; j < Suc k\\<rbrakk>\n             \\<Longrightarrow> QF k (j, i) \\<noteq> {};\n     j < Suc k\\<rbrakk>\n    \\<Longrightarrow> QF k (j, i) \\<noteq> {}", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>((j, i), j, i) \\<in> pair_less; j < Suc k\\<rbrakk>\n  \\<Longrightarrow> QF k (j, i) \\<noteq> {}\n  j < Suc k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>((j, i), j, i) \\<in> pair_less; j < Suc k\\<rbrakk>\n             \\<Longrightarrow> QF k (j, i) \\<noteq> {};\n     j < Suc k\\<rbrakk>\n    \\<Longrightarrow> QF k (j, i) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>((j, i), j, i) \\<in> pair_less; j < Suc k\\<rbrakk>\n  \\<Longrightarrow> QF k (j, i) \\<noteq> {}\n  j < Suc k", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>((j, i), j, i) \\<in> pair_less; j < Suc k\\<rbrakk>\n  \\<Longrightarrow> QF k (j, i) \\<noteq> {}\n  j < Suc k\n\ngoal (1 subgoal):\n 1. QF k (j, i) \\<noteq> {}", "by (auto simp: def_wfrec [OF QF_def, of k \"(j,i)\"] AF_ne lessThan_empty_iff del_gt_0)"], ["proof (state)\nthis:\n  QF k (j, i) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j < Suc ?k \\<Longrightarrow> QF ?k (?j, ?i) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have QF_0 [simp]: \"QF k (0,i) = AF k i\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (0, i) = AF k i", "by (simp add: def_wfrec [OF QF_def])"], ["proof (state)\nthis:\n  QF ?k (0, ?i) = AF ?k ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have QF_Suc: \"QF k (Suc j,0) = enum (nxt N (Suc (Max (QF k (j, m - Suc 0))))) `\n                       {..< del k (if Suc j = k then m - 1 else 0) (Suc j)}\" for j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (Suc j, 0) =\n    enum (nxt N (Suc (Max (QF k (j, m - Suc 0))))) `\n    {..<del k (if Suc j = k then m - 1 else 0) (Suc j)}", "apply (simp add: def_wfrec [OF QF_def, of k \"(Suc j,0)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc j = k \\<longrightarrow>\n     enum (nxt N (Suc (Max (cut (QF k) pair_less (k, 0) (j, m - Suc 0))))) `\n     {..<del k (m - Suc 0) k} =\n     enum (nxt N (Suc (Max (QF k (j, m - Suc 0))))) `\n     {..<del k (m - Suc 0) k}) \\<and>\n    (Suc j \\<noteq> k \\<longrightarrow>\n     enum\n      (nxt N (Suc (Max (cut (QF k) pair_less (Suc j, 0) (j, m - Suc 0))))) `\n     {..<del k 0 (Suc j)} =\n     enum (nxt N (Suc (Max (QF k (j, m - Suc 0))))) ` {..<del k 0 (Suc j)})", "apply (simp add: pair_less_def cut_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  QF ?k (Suc ?j, 0) =\n  enum (nxt N (Suc (Max (QF ?k (?j, m - Suc 0))))) `\n  {..<del ?k (if Suc ?j = ?k then m - 1 else 0) (Suc ?j)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have QF_Suc_Suc: \"QF k (Suc j, Suc i)\n                  = enum (nxt N (Suc (Max (QF k (Suc j, i))))) ` {..< del k (if Suc j = k then m - Suc(Suc i) else Suc i) (Suc j)}\"\n    for i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (Suc j, Suc i) =\n    enum (nxt N (Suc (Max (QF k (Suc j, i))))) `\n    {..<del k (if Suc j = k then m - Suc (Suc i) else Suc i) (Suc j)}", "by (simp add: def_wfrec [OF QF_def, of k \"(Suc j,Suc i)\"])"], ["proof (state)\nthis:\n  QF ?k (Suc ?j, Suc ?i) =\n  enum (nxt N (Suc (Max (QF ?k (Suc ?j, ?i))))) `\n  {..<del ?k (if Suc ?j = ?k then m - Suc (Suc ?i) else Suc ?i) (Suc ?j)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have less_QF1: \"QF k (j, m - Suc 0) \\<lless> QF k (Suc j,0)\" for j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j, m - Suc 0) \\<lless> QF k (Suc j, 0)", "by (auto simp: def_wfrec [OF QF_def, of k \"(Suc j,0)\"] pair_lessI1 \\<open>infinite N\\<close> enum_nxt_ge\n        intro!: less_sets_weaken2 [OF less_sets_Suc_Max])"], ["proof (state)\nthis:\n  QF ?k (?j, m - Suc 0) \\<lless> QF ?k (Suc ?j, 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have less_QF2: \"QF k (j,i) \\<lless> QF k (j, Suc i)\" for j i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j, i) \\<lless> QF k (j, Suc i)", "by (auto simp: def_wfrec [OF QF_def, of k \"(j, Suc i)\"] pair_lessI2 \\<open>infinite N\\<close> enum_nxt_ge\n        intro: less_sets_weaken2 [OF less_sets_Suc_Max] strict_mono_setsD [OF sm_AF])"], ["proof (state)\nthis:\n  QF ?k (?j, ?i) \\<lless> QF ?k (?j, Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have less_QF_same: \"QF k (j,i') \\<lless> QF k (j,i)\"\n    if \"i' < i\" \"j \\<le> k\" for i' i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j, i') \\<lless> QF k (j, i)", "proof (rule strict_mono_setsD [OF less_sets_imp_strict_mono_sets [of \"\\<lambda>i. QF k (j,i)\"]])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. QF k (j, i) \\<lless> QF k (j, Suc i)\n 2. \\<And>i. 0 < i \\<Longrightarrow> QF k (j, i) \\<noteq> {}\n 3. i' < i\n 4. i' \\<in> UNIV\n 5. i \\<in> UNIV", "show \"QF k (j, i) \\<lless> QF k (j, Suc i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j, i) \\<lless> QF k (j, Suc i)", "by (simp add: less_QF2)"], ["proof (state)\nthis:\n  QF k (j, ?i) \\<lless> QF k (j, Suc ?i)\n\ngoal (4 subgoals):\n 1. \\<And>i. 0 < i \\<Longrightarrow> QF k (j, i) \\<noteq> {}\n 2. i' < i\n 3. i' \\<in> UNIV\n 4. i \\<in> UNIV", "show \"QF k (j, i) \\<noteq> {}\" if \"0 < i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j, i) \\<noteq> {}", "using that"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. QF k (j, i) \\<noteq> {}", "by (simp add: \\<open>j \\<le> k\\<close> le_imp_less_Suc)"], ["proof (state)\nthis:\n  0 < ?i \\<Longrightarrow> QF k (j, ?i) \\<noteq> {}\n\ngoal (3 subgoals):\n 1. i' < i\n 2. i' \\<in> UNIV\n 3. i \\<in> UNIV", "qed (use that in auto)"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < ?i; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> QF ?k (?j, ?i') \\<lless> QF ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have less_QF_step: \"QF k (j - Suc 0, i') \\<lless> QF k (j,i)\"\n    if \"0 < j\" \"j \\<le> k\" \"i' < m\" for j i' i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, i)", "have less_QF1': \"QF k (j - Suc 0, m - Suc 0) \\<lless> QF k (j,0)\" if \"j > 0\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, m - Suc 0) \\<lless> QF k (j, 0)", "by (metis less_QF1 that Suc_pred)"], ["proof (state)\nthis:\n  0 < ?j \\<Longrightarrow>\n  QF k (?j - Suc 0, m - Suc 0) \\<lless> QF k (?j, 0)\n\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, i)", "have \\<section>: \"QF k (j - Suc 0, i') \\<lless> QF k (j,0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "proof (cases \"i' = m - Suc 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i' = m - Suc 0 \\<Longrightarrow>\n    QF k (j - Suc 0, i') \\<lless> QF k (j, 0)\n 2. i' \\<noteq> m - Suc 0 \\<Longrightarrow>\n    QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "case True"], ["proof (state)\nthis:\n  i' = m - Suc 0\n\ngoal (2 subgoals):\n 1. i' = m - Suc 0 \\<Longrightarrow>\n    QF k (j - Suc 0, i') \\<lless> QF k (j, 0)\n 2. i' \\<noteq> m - Suc 0 \\<Longrightarrow>\n    QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "then"], ["proof (chain)\npicking this:\n  i' = m - Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i' = m - Suc 0\n\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "using less_QF1' \\<open>0 < j\\<close>"], ["proof (prove)\nusing this:\n  i' = m - Suc 0\n  0 < ?j \\<Longrightarrow>\n  QF k (?j - Suc 0, m - Suc 0) \\<lless> QF k (?j, 0)\n  0 < j\n\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "by blast"], ["proof (state)\nthis:\n  QF k (j - Suc 0, i') \\<lless> QF k (j, 0)\n\ngoal (1 subgoal):\n 1. i' \\<noteq> m - Suc 0 \\<Longrightarrow>\n    QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i' \\<noteq> m - Suc 0 \\<Longrightarrow>\n    QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "case False"], ["proof (state)\nthis:\n  i' \\<noteq> m - Suc 0\n\ngoal (1 subgoal):\n 1. i' \\<noteq> m - Suc 0 \\<Longrightarrow>\n    QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "using False that less_sets_trans [OF less_QF_same less_QF1' QF_ne]"], ["proof (prove)\nusing this:\n  i' \\<noteq> m - Suc 0\n  0 < j\n  j \\<le> k\n  i' < m\n  \\<lbrakk>?i'3 < m - Suc 0; ?j2 - Suc 0 \\<le> k; 0 < ?j2;\n   ?j2 - Suc 0 < Suc k\\<rbrakk>\n  \\<Longrightarrow> QF k (?j2 - Suc 0, ?i'3) \\<lless> QF k (?j2, 0)\n\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "by auto"], ["proof (state)\nthis:\n  QF k (j - Suc 0, i') \\<lless> QF k (j, 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  QF k (j - Suc 0, i') \\<lless> QF k (j, 0)\n\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, i)", "then"], ["proof (chain)\npicking this:\n  QF k (j - Suc 0, i') \\<lless> QF k (j, 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  QF k (j - Suc 0, i') \\<lless> QF k (j, 0)\n\ngoal (1 subgoal):\n 1. QF k (j - Suc 0, i') \\<lless> QF k (j, i)", "by (metis QF_ne less_QF_same less_Suc_eq_le less_sets_trans \\<open>j \\<le> k\\<close> zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  QF k (j - Suc 0, i') \\<lless> QF k (j, i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?j; ?j \\<le> ?k; ?i' < m\\<rbrakk>\n  \\<Longrightarrow> QF ?k (?j - Suc 0, ?i') \\<lless> QF ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have less_QF: \"QF k (j',i') \\<lless> QF k (j,i)\"\n    if j: \"j' < j\" \"j \\<le> k\" and i: \"i' < m\" \"i < m\" for j' j i' i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j, i)", "using j"], ["proof (prove)\nusing this:\n  j' < j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j, i)", "proof (induction \"j-j'\" arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 = j - j'; j' < j; j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i);\n        Suc x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)", "case 0"], ["proof (state)\nthis:\n  0 = j - j'\n  j' < j\n  j \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 = j - j'; j' < j; j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i);\n        Suc x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)", "then"], ["proof (chain)\npicking this:\n  0 = j - j'\n  j' < j\n  j \\<le> k", "show ?case"], ["proof (prove)\nusing this:\n  0 = j - j'\n  j' < j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j, i)", "by auto"], ["proof (state)\nthis:\n  QF k (j', i') \\<lless> QF k (j, i)\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i);\n        Suc x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i);\n        Suc x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)", "case (Suc d)"], ["proof (state)\nthis:\n  \\<lbrakk>d = ?j - j'; j' < ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> QF k (j', i') \\<lless> QF k (?j, i)\n  Suc d = j - j'\n  j' < j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i);\n        Suc x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>d = ?j - j'; j' < ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> QF k (j', i') \\<lless> QF k (?j, i)\n  Suc d = j - j'\n  j' < j\n  j \\<le> k", "have eq: \"d = (j - Suc 0) - j'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>d = ?j - j'; j' < ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> QF k (j', i') \\<lless> QF k (?j, i)\n  Suc d = j - j'\n  j' < j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. d = j - Suc 0 - j'", "by linarith"], ["proof (state)\nthis:\n  d = j - Suc 0 - j'\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i);\n        Suc x = j - j'; j' < j; j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j, i)", "proof (cases \"j' < j - Suc 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j' < j - Suc 0 \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)\n 2. \\<not> j' < j - Suc 0 \\<Longrightarrow>\n    QF k (j', i') \\<lless> QF k (j, i)", "case True"], ["proof (state)\nthis:\n  j' < j - Suc 0\n\ngoal (2 subgoals):\n 1. j' < j - Suc 0 \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)\n 2. \\<not> j' < j - Suc 0 \\<Longrightarrow>\n    QF k (j', i') \\<lless> QF k (j, i)", "then"], ["proof (chain)\npicking this:\n  j' < j - Suc 0", "have \"QF k (j', i') \\<lless> QF k (j - Suc 0, i)\""], ["proof (prove)\nusing this:\n  j' < j - Suc 0\n\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j - Suc 0, i)", "using Suc eq"], ["proof (prove)\nusing this:\n  j' < j - Suc 0\n  \\<lbrakk>d = ?j - j'; j' < ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> QF k (j', i') \\<lless> QF k (?j, i)\n  Suc d = j - j'\n  j' < j\n  j \\<le> k\n  d = j - Suc 0 - j'\n\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j - Suc 0, i)", "by auto"], ["proof (state)\nthis:\n  QF k (j', i') \\<lless> QF k (j - Suc 0, i)\n\ngoal (2 subgoals):\n 1. j' < j - Suc 0 \\<Longrightarrow> QF k (j', i') \\<lless> QF k (j, i)\n 2. \\<not> j' < j - Suc 0 \\<Longrightarrow>\n    QF k (j', i') \\<lless> QF k (j, i)", "then"], ["proof (chain)\npicking this:\n  QF k (j', i') \\<lless> QF k (j - Suc 0, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  QF k (j', i') \\<lless> QF k (j - Suc 0, i)\n\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j, i)", "by (rule less_sets_trans [OF _ less_QF_step QF_ne]) (use Suc i in auto)"], ["proof (state)\nthis:\n  QF k (j', i') \\<lless> QF k (j, i)\n\ngoal (1 subgoal):\n 1. \\<not> j' < j - Suc 0 \\<Longrightarrow>\n    QF k (j', i') \\<lless> QF k (j, i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j' < j - Suc 0 \\<Longrightarrow>\n    QF k (j', i') \\<lless> QF k (j, i)", "case False"], ["proof (state)\nthis:\n  \\<not> j' < j - Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> j' < j - Suc 0 \\<Longrightarrow>\n    QF k (j', i') \\<lless> QF k (j, i)", "then"], ["proof (chain)\npicking this:\n  \\<not> j' < j - Suc 0", "have \"j' = j - Suc 0\""], ["proof (prove)\nusing this:\n  \\<not> j' < j - Suc 0\n\ngoal (1 subgoal):\n 1. j' = j - Suc 0", "using \\<open>j' < j\\<close>"], ["proof (prove)\nusing this:\n  \\<not> j' < j - Suc 0\n  j' < j\n\ngoal (1 subgoal):\n 1. j' = j - Suc 0", "by linarith"], ["proof (state)\nthis:\n  j' = j - Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> j' < j - Suc 0 \\<Longrightarrow>\n    QF k (j', i') \\<lless> QF k (j, i)", "then"], ["proof (chain)\npicking this:\n  j' = j - Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  j' = j - Suc 0\n\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j, i)", "using Suc.hyps \\<open>j \\<le> k\\<close> less_QF_step i"], ["proof (prove)\nusing this:\n  j' = j - Suc 0\n  \\<lbrakk>d = ?j - j'; j' < ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> QF k (j', i') \\<lless> QF k (?j, i)\n  Suc d = j - j'\n  j \\<le> k\n  \\<lbrakk>0 < ?j; ?j \\<le> ?k; ?i' < m\\<rbrakk>\n  \\<Longrightarrow> QF ?k (?j - Suc 0, ?i') \\<lless> QF ?k (?j, ?i)\n  i' < m\n  i < m\n\ngoal (1 subgoal):\n 1. QF k (j', i') \\<lless> QF k (j, i)", "by auto"], ["proof (state)\nthis:\n  QF k (j', i') \\<lless> QF k (j, i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  QF k (j', i') \\<lless> QF k (j, i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?j' < ?j; ?j \\<le> ?k; ?i' < m; ?i < m\\<rbrakk>\n  \\<Longrightarrow> QF ?k (?j', ?i') \\<lless> QF ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have sm_QF: \"strict_mono_sets ({..k} \\<times> {..<m}) (QF k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono_sets ({..k} \\<times> {..<m}) (QF k)", "unfolding strict_mono_sets_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..k} \\<times> {..<m}.\n       \\<forall>y\\<in>{..k} \\<times> {..<m}.\n          x < y \\<longrightarrow> QF k x \\<lless> QF k y", "proof (intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..k} \\<times> {..<m};\n        y \\<in> {..k} \\<times> {..<m}; x < y\\<rbrakk>\n       \\<Longrightarrow> QF k x \\<lless> QF k y", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..k} \\<times> {..<m};\n        y \\<in> {..k} \\<times> {..<m}; x < y\\<rbrakk>\n       \\<Longrightarrow> QF k x \\<lless> QF k y", "assume p: \"p \\<in> {..k} \\<times> {..<m}\" and q: \"q \\<in> {..k} \\<times> {..<m}\" and \"p < q\""], ["proof (state)\nthis:\n  p \\<in> {..k} \\<times> {..<m}\n  q \\<in> {..k} \\<times> {..<m}\n  p < q\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..k} \\<times> {..<m};\n        y \\<in> {..k} \\<times> {..<m}; x < y\\<rbrakk>\n       \\<Longrightarrow> QF k x \\<lless> QF k y", "then"], ["proof (chain)\npicking this:\n  p \\<in> {..k} \\<times> {..<m}\n  q \\<in> {..k} \\<times> {..<m}\n  p < q", "obtain j' i' j i where \\<section>: \"p = (j',i')\" \"q = (j,i)\" \"i' < m\" \"i < m\" \"j' \\<le> k\" \"j \\<le> k\""], ["proof (prove)\nusing this:\n  p \\<in> {..k} \\<times> {..<m}\n  q \\<in> {..k} \\<times> {..<m}\n  p < q\n\ngoal (1 subgoal):\n 1. (\\<And>j' i' j i.\n        \\<lbrakk>p = (j', i'); q = (j, i); i' < m; i < m; j' \\<le> k;\n         j \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using surj_pair [of p] surj_pair [of q]"], ["proof (prove)\nusing this:\n  p \\<in> {..k} \\<times> {..<m}\n  q \\<in> {..k} \\<times> {..<m}\n  p < q\n  \\<exists>x y. p = (x, y)\n  \\<exists>x y. q = (x, y)\n\ngoal (1 subgoal):\n 1. (\\<And>j' i' j i.\n        \\<lbrakk>p = (j', i'); q = (j, i); i' < m; i < m; j' \\<le> k;\n         j \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = (j', i')\n  q = (j, i)\n  i' < m\n  i < m\n  j' \\<le> k\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..k} \\<times> {..<m};\n        y \\<in> {..k} \\<times> {..<m}; x < y\\<rbrakk>\n       \\<Longrightarrow> QF k x \\<lless> QF k y", "with \\<open>p < q\\<close>"], ["proof (chain)\npicking this:\n  p < q\n  p = (j', i')\n  q = (j, i)\n  i' < m\n  i < m\n  j' \\<le> k\n  j \\<le> k", "have \"j' < j \\<or> j' = j \\<and> i' < i\""], ["proof (prove)\nusing this:\n  p < q\n  p = (j', i')\n  q = (j, i)\n  i' < m\n  i < m\n  j' \\<le> k\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. j' < j \\<or> j' = j \\<and> i' < i", "by auto"], ["proof (state)\nthis:\n  j' < j \\<or> j' = j \\<and> i' < i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..k} \\<times> {..<m};\n        y \\<in> {..k} \\<times> {..<m}; x < y\\<rbrakk>\n       \\<Longrightarrow> QF k x \\<lless> QF k y", "then"], ["proof (chain)\npicking this:\n  j' < j \\<or> j' = j \\<and> i' < i", "show \"QF k p \\<lless> QF k q\""], ["proof (prove)\nusing this:\n  j' < j \\<or> j' = j \\<and> i' < i\n\ngoal (1 subgoal):\n 1. QF k p \\<lless> QF k q", "proof (elim conjE disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. j' < j \\<Longrightarrow> QF k p \\<lless> QF k q\n 2. \\<lbrakk>j' = j; i' < i\\<rbrakk>\n    \\<Longrightarrow> QF k p \\<lless> QF k q", "assume \"j' < j\""], ["proof (state)\nthis:\n  j' < j\n\ngoal (2 subgoals):\n 1. j' < j \\<Longrightarrow> QF k p \\<lless> QF k q\n 2. \\<lbrakk>j' = j; i' < i\\<rbrakk>\n    \\<Longrightarrow> QF k p \\<lless> QF k q", "show \"QF k p \\<lless> QF k q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k p \\<lless> QF k q", "by (simp add: \\<section> \\<open>j' < j\\<close> less_QF that)"], ["proof (state)\nthis:\n  QF k p \\<lless> QF k q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j' = j; i' < i\\<rbrakk>\n    \\<Longrightarrow> QF k p \\<lless> QF k q", "qed (use \\<section> in \\<open>simp add: that less_QF_same\\<close>)"], ["proof (state)\nthis:\n  QF k p \\<lless> QF k q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strict_mono_sets ({..?k} \\<times> {..<m}) (QF ?k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  strict_mono_sets ({..?k} \\<times> {..<m}) (QF ?k)", "have sm_QF1: \"strict_mono_sets {..<ka} (\\<lambda>j. QF k (j,i))\"\n    if \"i<m\" \"Suc k \\<ge> ka\" \"ka \\<ge> k\" for ka k i"], ["proof (prove)\nusing this:\n  strict_mono_sets ({..?k} \\<times> {..<m}) (QF ?k)\n\ngoal (1 subgoal):\n 1. strict_mono_sets {..<ka} (\\<lambda>j. QF k (j, i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        strict_mono_sets ({..k} \\<times> {..<m}) (QF k)) \\<Longrightarrow>\n    strict_mono_sets {..<ka} (\\<lambda>j. QF k (j, i))", "have \"{..<ka} \\<subseteq> {..k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<ka} \\<subseteq> {..k}", "by (metis lessThan_Suc_atMost lessThan_subset_iff \\<open>Suc k \\<ge> ka\\<close>)"], ["proof (state)\nthis:\n  {..<ka} \\<subseteq> {..k}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        strict_mono_sets ({..k} \\<times> {..<m}) (QF k)) \\<Longrightarrow>\n    strict_mono_sets {..<ka} (\\<lambda>j. QF k (j, i))", "then"], ["proof (chain)\npicking this:\n  {..<ka} \\<subseteq> {..k}", "show ?thesis"], ["proof (prove)\nusing this:\n  {..<ka} \\<subseteq> {..k}\n\ngoal (1 subgoal):\n 1. strict_mono_sets {..<ka} (\\<lambda>j. QF k (j, i))", "by (simp add: less_QF strict_mono_sets_def subset_iff that)"], ["proof (state)\nthis:\n  strict_mono_sets {..<ka} (\\<lambda>j. QF k (j, i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < m; ?ka \\<le> Suc ?k; ?k \\<le> ?ka\\<rbrakk>\n  \\<Longrightarrow> strict_mono_sets {..<?ka} (\\<lambda>j. QF ?k (j, ?i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have disjoint_QF: \"i'=i \\<and> j'=j\" if \"\\<not> disjnt (QF k (j', i')) (QF k (j,i))\" \"j' \\<le> k\" \"j \\<le> k\" \"i' < m\" \"i < m\" for i' i j' j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. i' = i \\<and> j' = j", "using that strict_mono_sets_imp_disjoint [OF sm_QF]"], ["proof (prove)\nusing this:\n  \\<not> disjnt (QF k (j', i')) (QF k (j, i))\n  j' \\<le> k\n  j \\<le> k\n  i' < m\n  i < m\n  pairwise (\\<lambda>x y. disjnt (QF ?k1 x) (QF ?k1 y))\n   ({..?k1} \\<times> {..<m})\n\ngoal (1 subgoal):\n 1. i' = i \\<and> j' = j", "by (force simp: pairwise_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> disjnt (QF ?k (?j', ?i')) (QF ?k (?j, ?i)); ?j' \\<le> ?k;\n   ?j \\<le> ?k; ?i' < m; ?i < m\\<rbrakk>\n  \\<Longrightarrow> ?i' = ?i \\<and> ?j' = ?j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have card_QF: \"card (QF k (j,i)) = (if j=0 then \\<Sqinter> (DF k i) else del k (if j = k then m - Suc i else i) j)\"\n    for i k j"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (QF k (j, i)) =\n    (if j = 0 then \\<Sqinter> (DF k i)\n     else del k (if j = k then m - Suc i else i) j)", "proof (cases j)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    card (QF k (j, i)) =\n    (if j = 0 then \\<Sqinter> (DF k i)\n     else del k (if j = k then m - Suc i else i) j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       card (QF k (j, i)) =\n       (if j = 0 then \\<Sqinter> (DF k i)\n        else del k (if j = k then m - Suc i else i) j)", "case 0"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    card (QF k (j, i)) =\n    (if j = 0 then \\<Sqinter> (DF k i)\n     else del k (if j = k then m - Suc i else i) j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       card (QF k (j, i)) =\n       (if j = 0 then \\<Sqinter> (DF k i)\n        else del k (if j = k then m - Suc i else i) j)", "then"], ["proof (chain)\npicking this:\n  j = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  j = 0\n\ngoal (1 subgoal):\n 1. card (QF k (j, i)) =\n    (if j = 0 then \\<Sqinter> (DF k i)\n     else del k (if j = k then m - Suc i else i) j)", "by (simp add: AF_def card_image \\<open>infinite N\\<close> inj_enum_nxt)"], ["proof (state)\nthis:\n  card (QF k (j, i)) =\n  (if j = 0 then \\<Sqinter> (DF k i)\n   else del k (if j = k then m - Suc i else i) j)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       card (QF k (j, i)) =\n       (if j = 0 then \\<Sqinter> (DF k i)\n        else del k (if j = k then m - Suc i else i) j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       card (QF k (j, i)) =\n       (if j = 0 then \\<Sqinter> (DF k i)\n        else del k (if j = k then m - Suc i else i) j)", "case (Suc j')"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       card (QF k (j, i)) =\n       (if j = 0 then \\<Sqinter> (DF k i)\n        else del k (if j = k then m - Suc i else i) j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (QF k (j, i)) =\n    (if j = 0 then \\<Sqinter> (DF k i)\n     else del k (if j = k then m - Suc i else i) j)", "by (cases i; simp add: Suc QF_Suc QF_Suc_Suc card_image \\<open>infinite N\\<close> inj_enum_nxt)"], ["proof (state)\nthis:\n  card (QF k (j, i)) =\n  (if j = 0 then \\<Sqinter> (DF k i)\n   else del k (if j = k then m - Suc i else i) j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (QF ?k (?j, ?i)) =\n  (if ?j = 0 then \\<Sqinter> (DF ?k ?i)\n   else del ?k (if ?j = ?k then m - Suc ?i else ?i) ?j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have AF_non_Nil: \"list_of (AF k i) \\<noteq> []\" for k i"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (AF k i) \\<noteq> []", "by (simp add: AF_ne)"], ["proof (state)\nthis:\n  list_of (AF ?k ?i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have QF_non_Nil: \"list_of (QF k (j,i)) \\<noteq> []\" if \"j < Suc k\" for i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (QF k (j, i)) \\<noteq> []", "by (simp add: that)"], ["proof (state)\nthis:\n  ?j < Suc ?k \\<Longrightarrow> list_of (QF ?k (?j, ?i)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have AF_subset_N: \"AF k i \\<subseteq> N\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. AF k i \\<subseteq> N", "unfolding AF_def image_subset_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<\\<Sqinter> (DF k i)}.\n       enum (nxt N (Max (DF k i))) x \\<in> N", "using nxt_subset enumerate_in_set infinite_nxtN \\<open>infinite N\\<close>"], ["proof (prove)\nusing this:\n  nxt ?N ?n \\<subseteq> ?N\n  infinite ?S \\<Longrightarrow> enum ?S ?n \\<in> ?S\n  infinite ?N \\<Longrightarrow> infinite (nxt ?N ?n)\n  infinite N\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<\\<Sqinter> (DF k i)}.\n       enum (nxt N (Max (DF k i))) x \\<in> N", "by blast"], ["proof (state)\nthis:\n  AF ?k ?i \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have QF_subset_N: \"QF k (j,i) \\<subseteq> N\" for i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (j, i) \\<subseteq> N", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. QF k (0, i) \\<subseteq> N\n 2. \\<And>j.\n       QF k (j, i) \\<subseteq> N \\<Longrightarrow>\n       QF k (Suc j, i) \\<subseteq> N", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. QF k (0, i) \\<subseteq> N\n 2. \\<And>j.\n       QF k (j, i) \\<subseteq> N \\<Longrightarrow>\n       QF k (Suc j, i) \\<subseteq> N", "with AF_subset_N"], ["proof (chain)\npicking this:\n  AF ?k ?i \\<subseteq> N", "show ?case"], ["proof (prove)\nusing this:\n  AF ?k ?i \\<subseteq> N\n\ngoal (1 subgoal):\n 1. QF k (0, i) \\<subseteq> N", "by auto"], ["proof (state)\nthis:\n  QF k (0, i) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       QF k (j, i) \\<subseteq> N \\<Longrightarrow>\n       QF k (Suc j, i) \\<subseteq> N", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       QF k (j, i) \\<subseteq> N \\<Longrightarrow>\n       QF k (Suc j, i) \\<subseteq> N", "case (Suc j)"], ["proof (state)\nthis:\n  QF k (j, i) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       QF k (j, i) \\<subseteq> N \\<Longrightarrow>\n       QF k (Suc j, i) \\<subseteq> N", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. QF k (Suc j, i) \\<subseteq> N", "by (cases i) (use nxt_subset enumerate_in_set in \\<open>(force simp: QF_Suc QF_Suc_Suc)+\\<close>)"], ["proof (state)\nthis:\n  QF k (Suc j, i) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  QF ?k (?j, ?i) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain ka k where \"k>0\" and kka: \"k \\<le> ka\" \"ka \\<le> Suc k\" \"l = ((ka+k) - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k ka.\n        \\<lbrakk>0 < k; k \\<le> ka; ka \\<le> Suc k;\n         l = ka + k - Suc 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def assms(2) diff_add_inverse form_cases le0 le_refl)"], ["proof (state)\nthis:\n  0 < k\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  0 < k\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0", "have \"ka > 0\""], ["proof (prove)\nusing this:\n  0 < k\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. 0 < ka", "using dual_order.strict_trans1"], ["proof (prove)\nusing this:\n  0 < k\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  \\<lbrakk>?b \\<le> ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n\ngoal (1 subgoal):\n 1. 0 < ka", "by blast"], ["proof (state)\nthis:\n  0 < ka\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have ka_k_or_Suc: \"ka = k \\<or> ka = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ka = k \\<or> ka = Suc k", "using kka"], ["proof (prove)\nusing this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. ka = k \\<or> ka = Suc k", "by linarith"], ["proof (state)\nthis:\n  ka = k \\<or> ka = Suc k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have lessThan_k: \"{..<k} = insert 0 {0<..<k}\" if \"k>0\" for k::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<k} = insert 0 {0<..<k}", "using that"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. {..<k} = insert 0 {0<..<k}", "by auto"], ["proof (state)\nthis:\n  0 < ?k \\<Longrightarrow> {..<?k} = insert 0 {0<..<?k}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  0 < ?k \\<Longrightarrow> {..<?k} = insert 0 {0<..<?k}", "have sorted_list_of_set_k: \"list_of {..<k} = 0 # list_of {0<..<k}\" if \"k>0\" for k::nat"], ["proof (prove)\nusing this:\n  0 < ?k \\<Longrightarrow> {..<?k} = insert 0 {0<..<?k}\n\ngoal (1 subgoal):\n 1. list_of {..<k} = 0 # list_of {0<..<k}", "using sorted_list_of_set_insert_cons [of concl: 0 \"{0<..<k}\"] that"], ["proof (prove)\nusing this:\n  0 < ?k \\<Longrightarrow> {..<?k} = insert 0 {0<..<?k}\n  \\<lbrakk>finite {0<..<k}; {0} \\<lless> {0<..<k}\\<rbrakk>\n  \\<Longrightarrow> list_of (insert 0 {0<..<k}) = 0 # list_of {0<..<k}\n  0 < k\n\ngoal (1 subgoal):\n 1. list_of {..<k} = 0 # list_of {0<..<k}", "by simp"], ["proof (state)\nthis:\n  0 < ?k \\<Longrightarrow> list_of {..<?k} = 0 # list_of {0<..<?k}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "define RF where \"RF \\<equiv> \\<lambda>j i. if j = k then QF k (j, m - Suc i) else QF k (j,i)\""], ["proof (state)\nthis:\n  RF \\<equiv>\n  \\<lambda>j i. if j = k then QF k (j, m - Suc i) else QF k (j, i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have RF_subset_N: \"RF j i \\<subseteq> N\" if \"i<m\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF j i \\<subseteq> N", "using that QF_subset_N"], ["proof (prove)\nusing this:\n  i < m\n  QF ?k (?j, ?i) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. RF j i \\<subseteq> N", "by (simp add: RF_def)"], ["proof (state)\nthis:\n  ?i < m \\<Longrightarrow> RF ?j ?i \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have finite_RF [simp]: \"finite (RF k p)\" for p k"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (RF k p)", "by (simp add: RF_def)"], ["proof (state)\nthis:\n  finite (RF ?k ?p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have RF_0: \"RF 0 i = AF k i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF 0 i = AF k i", "using RF_def \\<open>0 < k\\<close>"], ["proof (prove)\nusing this:\n  RF \\<equiv>\n  \\<lambda>j i. if j = k then QF k (j, m - Suc i) else QF k (j, i)\n  0 < k\n\ngoal (1 subgoal):\n 1. RF 0 i = AF k i", "by auto"], ["proof (state)\nthis:\n  RF 0 ?i = AF k ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have disjoint_RF: \"i'=i \\<and> j'=j\" if \"\\<not> disjnt (RF j' i') (RF j i)\" \"j' \\<le> k\" \"j \\<le> k\" \"i' < m\" \"i < m\" for i' i j' j"], ["proof (prove)\ngoal (1 subgoal):\n 1. i' = i \\<and> j' = j", "using disjoint_QF that"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> disjnt (QF ?k (?j', ?i')) (QF ?k (?j, ?i)); ?j' \\<le> ?k;\n   ?j \\<le> ?k; ?i' < m; ?i < m\\<rbrakk>\n  \\<Longrightarrow> ?i' = ?i \\<and> ?j' = ?j\n  \\<not> disjnt (RF j' i') (RF j i)\n  j' \\<le> k\n  j \\<le> k\n  i' < m\n  i < m\n\ngoal (1 subgoal):\n 1. i' = i \\<and> j' = j", "by (auto simp: RF_def split: if_split_asm dest: disjoint_QF)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> disjnt (RF ?j' ?i') (RF ?j ?i); ?j' \\<le> k; ?j \\<le> k;\n   ?i' < m; ?i < m\\<rbrakk>\n  \\<Longrightarrow> ?i' = ?i \\<and> ?j' = ?j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have sum_card_RF [simp]: \"(\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n\" if \"n \\<le> k\" \"i < m\" for i n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n", "using that"], ["proof (prove)\nusing this:\n  n \\<le> k\n  i < m\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> k; i < m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>j\\<le>0. card (RF j i)) = enum (DF k i) 0\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) =\n                                  enum (DF k i) n;\n        Suc n \\<le> k; i < m\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<le>Suc n. card (RF j i)) =\n                         enum (DF k i) (Suc n)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> k\n  i < m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> k; i < m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>j\\<le>0. card (RF j i)) = enum (DF k i) 0\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) =\n                                  enum (DF k i) n;\n        Suc n \\<le> k; i < m\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<le>Suc n. card (RF j i)) =\n                         enum (DF k i) (Suc n)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> k\n  i < m", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  i < m\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>0. card (RF j i)) = enum (DF k i) 0", "using DF_ne [of k i] finite_DF [of k i] \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  i < m\n  DF k i \\<noteq> {}\n  finite (DF k i)\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>0. card (RF j i)) = enum (DF k i) 0", "by (simp add: RF_def AF_def card_image \\<open>infinite N\\<close> inj_enum_nxt enum_0_eq_Inf_finite)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>0. card (RF j i)) = enum (DF k i) 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) =\n                                  enum (DF k i) n;\n        Suc n \\<le> k; i < m\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<le>Suc n. card (RF j i)) =\n                         enum (DF k i) (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) =\n                                  enum (DF k i) n;\n        Suc n \\<le> k; i < m\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<le>Suc n. card (RF j i)) =\n                         enum (DF k i) (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n\n  Suc n \\<le> k\n  i < m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) =\n                                  enum (DF k i) n;\n        Suc n \\<le> k; i < m\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<le>Suc n. card (RF j i)) =\n                         enum (DF k i) (Suc n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n\n  Suc n \\<le> k\n  i < m", "have \"enum (DF k i) 0 \\<le> enum (DF k i) n \\<and> enum (DF k i) n \\<le> enum (DF k i) (Suc n)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n\n  Suc n \\<le> k\n  i < m\n\ngoal (1 subgoal):\n 1. enum (DF k i) 0 \\<le> enum (DF k i) n \\<and>\n    enum (DF k i) n \\<le> enum (DF k i) (Suc n)", "using sm_enum_DF [of k i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n\n  Suc n \\<le> k\n  i < m\n  strict_mono_on (enum (DF k i)) {..k}\n\ngoal (1 subgoal):\n 1. enum (DF k i) 0 \\<le> enum (DF k i) n \\<and>\n    enum (DF k i) n \\<le> enum (DF k i) (Suc n)", "apply (simp add: strict_mono_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n;\n     Suc n \\<le> k; i < m;\n     \\<forall>r s.\n        r \\<le> k \\<and> s \\<le> k \\<and> r < s \\<longrightarrow>\n        enum (DF k i) r < enum (DF k i) s\\<rbrakk>\n    \\<Longrightarrow> enum (DF k i) 0 \\<le> enum (DF k i) n \\<and>\n                      enum (DF k i) n \\<le> enum (DF k i) (Suc n)", "by (metis Suc_leD dual_order.order_iff_strict le0)"], ["proof (state)\nthis:\n  enum (DF k i) 0 \\<le> enum (DF k i) n \\<and>\n  enum (DF k i) n \\<le> enum (DF k i) (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) =\n                                  enum (DF k i) n;\n        Suc n \\<le> k; i < m\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<le>Suc n. card (RF j i)) =\n                         enum (DF k i) (Suc n)", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n\n  Suc n \\<le> k\n  i < m\n  enum (DF k i) 0 \\<le> enum (DF k i) n \\<and>\n  enum (DF k i) n \\<le> enum (DF k i) (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> k; i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>n. card (RF j i)) = enum (DF k i) n\n  Suc n \\<le> k\n  i < m\n  enum (DF k i) 0 \\<le> enum (DF k i) n \\<and>\n  enum (DF k i) n \\<le> enum (DF k i) (Suc n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>Suc n. card (RF j i)) = enum (DF k i) (Suc n)", "by (auto simp: RF_def card_QF del_def)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>Suc n. card (RF j i)) = enum (DF k i) (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?n \\<le> k; ?i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>?n. card (RF j ?i)) = enum (DF k ?i) ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have DF_in_N: \"enum (DF k i) j \\<in> N\" if \"j \\<le> k\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum (DF k i) j \\<in> N", "using DF_N [of k i] card_DF finite_enumerate_in_set finite_DF that"], ["proof (prove)\nusing this:\n  DF k i \\<subseteq> N \\<inter> {0<..}\n  card (DF ?k ?i) = Suc ?k\n  \\<lbrakk>finite ?S; ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> enum ?S ?n \\<in> ?S\n  finite (DF ?k ?i)\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. enum (DF k i) j \\<in> N", "by (metis inf.boundedE le_imp_less_Suc subsetD)"], ["proof (state)\nthis:\n  ?j \\<le> k \\<Longrightarrow> enum (DF k ?i) ?j \\<in> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have Inf_DF_N: \"\\<Sqinter>(DF k p) \\<in> N\" for k p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (DF k p) \\<in> N", "using DF_N DF_ne Inf_nat_def1"], ["proof (prove)\nusing this:\n  DF ?k ?i \\<subseteq> N \\<inter> {0<..}\n  DF ?k ?i \\<noteq> {}\n  ?K \\<noteq> {} \\<Longrightarrow> \\<Sqinter> ?K \\<in> ?K\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (DF k p) \\<in> N", "by blast"], ["proof (state)\nthis:\n  \\<Sqinter> (DF ?k ?p) \\<in> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have RF_in_N: \"(\\<Sum>j\\<le>n. card (RF j i)) \\<in> N\" if \"n \\<le> k\" \"i < m\" for i n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. card (RF j i)) \\<in> N", "by (auto simp: DF_in_N that)"], ["proof (state)\nthis:\n  \\<lbrakk>?n \\<le> k; ?i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>?n. card (RF j ?i)) \\<in> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"ka - Suc 0 \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ka - Suc 0 \\<le> k", "using kka(2)"], ["proof (prove)\nusing this:\n  ka \\<le> Suc k\n\ngoal (1 subgoal):\n 1. ka - Suc 0 \\<le> k", "by linarith"], ["proof (state)\nthis:\n  ka - Suc 0 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ka - Suc 0 \\<le> k", "have sum_card_RF' [simp]:\n    \"(\\<Sum>j<ka. card (RF j i)) = enum (DF k i) (ka - Suc 0)\" if \"i < m\" for i"], ["proof (prove)\nusing this:\n  ka - Suc 0 \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<ka. card (RF j i)) = enum (DF k i) (ka - Suc 0)", "using sum_card_RF [of \"ka - Suc 0\" i]"], ["proof (prove)\nusing this:\n  ka - Suc 0 \\<le> k\n  \\<lbrakk>ka - Suc 0 \\<le> k; i < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>j\\<le>ka - Suc 0. card (RF j i)) =\n                    enum (DF k i) (ka - Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<ka. card (RF j i)) = enum (DF k i) (ka - Suc 0)", "by (metis Suc_pred \\<open>0 < ka\\<close> lessThan_Suc_atMost that)"], ["proof (state)\nthis:\n  ?i < m \\<Longrightarrow>\n  (\\<Sum>j<ka. card (RF j ?i)) = enum (DF k ?i) (ka - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have enum_DF_le_iff [simp]:\n    \"enum (DF k i) j \\<le> enum (DF k i') j \\<longleftrightarrow> i \\<le> i'\" (is \"?lhs = _\")\n    if \"j \\<le> k\" for i' i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (enum (DF k i) j \\<le> enum (DF k i') j) = (i \\<le> i')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. enum (DF k i) j \\<le> enum (DF k i') j \\<Longrightarrow> i \\<le> i'\n 2. i \\<le> i' \\<Longrightarrow> enum (DF k i) j \\<le> enum (DF k i') j", "show \"i \\<le> i'\" if ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> i'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> i'", "have \"enum (DF k i) j \\<in> DF k i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum (DF k i) j \\<in> DF k i", "by (simp add: card_DF finite_enumerate_in_set finite_DF le_imp_less_Suc \\<open>j \\<le> k\\<close>)"], ["proof (state)\nthis:\n  enum (DF k i) j \\<in> DF k i\n\ngoal (1 subgoal):\n 1. i \\<le> i'", "moreover"], ["proof (state)\nthis:\n  enum (DF k i) j \\<in> DF k i\n\ngoal (1 subgoal):\n 1. i \\<le> i'", "have \"enum (DF k i') j \\<in> DF k i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum (DF k i') j \\<in> DF k i'", "by (simp add: \\<open>j \\<le> k\\<close> card_DF finite_enumerate_in_set finite_DF le_imp_less_Suc that)"], ["proof (state)\nthis:\n  enum (DF k i') j \\<in> DF k i'\n\ngoal (1 subgoal):\n 1. i \\<le> i'", "ultimately"], ["proof (chain)\npicking this:\n  enum (DF k i) j \\<in> DF k i\n  enum (DF k i') j \\<in> DF k i'", "have \"enum (DF k i') j < enum (DF k i) j\" if \"i' < i\""], ["proof (prove)\nusing this:\n  enum (DF k i) j \\<in> DF k i\n  enum (DF k i') j \\<in> DF k i'\n\ngoal (1 subgoal):\n 1. enum (DF k i') j < enum (DF k i) j", "using sm_DF [of k]"], ["proof (prove)\nusing this:\n  enum (DF k i) j \\<in> DF k i\n  enum (DF k i') j \\<in> DF k i'\n  strict_mono_sets UNIV (DF k)\n\ngoal (1 subgoal):\n 1. enum (DF k i') j < enum (DF k i) j", "by (meson UNIV_I less_sets_def strict_mono_setsD that)"], ["proof (state)\nthis:\n  i' < i \\<Longrightarrow> enum (DF k i') j < enum (DF k i) j\n\ngoal (1 subgoal):\n 1. i \\<le> i'", "then"], ["proof (chain)\npicking this:\n  i' < i \\<Longrightarrow> enum (DF k i') j < enum (DF k i) j", "show ?thesis"], ["proof (prove)\nusing this:\n  i' < i \\<Longrightarrow> enum (DF k i') j < enum (DF k i) j\n\ngoal (1 subgoal):\n 1. i \\<le> i'", "using not_less that"], ["proof (prove)\nusing this:\n  i' < i \\<Longrightarrow> enum (DF k i') j < enum (DF k i) j\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n  enum (DF k i) j \\<le> enum (DF k i') j\n\ngoal (1 subgoal):\n 1. i \\<le> i'", "by blast"], ["proof (state)\nthis:\n  i \\<le> i'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enum (DF k i) j \\<le> enum (DF k i') j \\<Longrightarrow> i \\<le> i'\n\ngoal (1 subgoal):\n 1. i \\<le> i' \\<Longrightarrow> enum (DF k i) j \\<le> enum (DF k i') j", "show ?lhs if \"i \\<le> i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum (DF k i) j \\<le> enum (DF k i') j", "using sm_DF [of k] that \\<open>j \\<le> k\\<close> card_DF finite_enumerate_in_set finite_DF le_eq_less_or_eq"], ["proof (prove)\nusing this:\n  strict_mono_sets UNIV (DF k)\n  i \\<le> i'\n  j \\<le> k\n  card (DF ?k ?i) = Suc ?k\n  \\<lbrakk>finite ?S; ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> enum ?S ?n \\<in> ?S\n  finite (DF ?k ?i)\n  (?m \\<le> ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. enum (DF k i) j \\<le> enum (DF k i') j", "by (force simp: strict_mono_sets_def less_sets_def finite_enumerate_in_set)"], ["proof (state)\nthis:\n  i \\<le> i' \\<Longrightarrow> enum (DF k i) j \\<le> enum (DF k i') j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j \\<le> ?k \\<Longrightarrow>\n  (enum (DF ?k ?i) ?j \\<le> enum (DF ?k ?i') ?j) = (?i \\<le> ?i')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ?j \\<le> ?k \\<Longrightarrow>\n  (enum (DF ?k ?i) ?j \\<le> enum (DF ?k ?i') ?j) = (?i \\<le> ?i')", "have enum_DF_eq_iff[simp]:\n    \"enum (DF k i) j = enum (DF k i') j \\<longleftrightarrow> i = i'\" if \"j \\<le> k\" for i' i j k"], ["proof (prove)\nusing this:\n  ?j \\<le> ?k \\<Longrightarrow>\n  (enum (DF ?k ?i) ?j \\<le> enum (DF ?k ?i') ?j) = (?i \\<le> ?i')\n\ngoal (1 subgoal):\n 1. (enum (DF k i) j = enum (DF k i') j) = (i = i')", "by (metis le_antisym order_refl that)"], ["proof (state)\nthis:\n  ?j \\<le> ?k \\<Longrightarrow>\n  (enum (DF ?k ?i) ?j = enum (DF ?k ?i') ?j) = (?i = ?i')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have enum_DF_less_iff [simp]:\n    \"enum (DF k i) j < enum (DF k i') j \\<longleftrightarrow> i < i'\" if \"j \\<le> k\" for i' i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (enum (DF k i) j < enum (DF k i') j) = (i < i')", "by (meson enum_DF_le_iff not_less that)"], ["proof (state)\nthis:\n  ?j \\<le> ?k \\<Longrightarrow>\n  (enum (DF ?k ?i) ?j < enum (DF ?k ?i') ?j) = (?i < ?i')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have card_AF_sum: \"card (AF k i) + (\\<Sum>j\\<in>{0<..<ka}. card (RF j i)) = enum (DF k i) (ka-1)\"\n    if \"i < m\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF k i) + (\\<Sum>j\\<in>{0<..<ka}. card (RF j i)) =\n    enum (DF k i) (ka - 1)", "using that \\<open>k > 0\\<close>  \\<open>k \\<le> ka\\<close> \\<open>ka \\<le> Suc k\\<close>"], ["proof (prove)\nusing this:\n  i < m\n  0 < k\n  k \\<le> ka\n  ka \\<le> Suc k\n\ngoal (1 subgoal):\n 1. card (AF k i) + (\\<Sum>j\\<in>{0<..<ka}. card (RF j i)) =\n    enum (DF k i) (ka - 1)", "by (simp add: lessThan_k RF_0 flip: sum_card_RF')"], ["proof (state)\nthis:\n  ?i < m \\<Longrightarrow>\n  card (AF k ?i) + (\\<Sum>j\\<in>{0<..<ka}. card (RF j ?i)) =\n  enum (DF k ?i) (ka - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have sorted_list_of_set_iff [simp]: \"list_of {0<..<k} = [] \\<longleftrightarrow> k = Suc 0\" if \"k>0\" for k::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_of {0<..<k} = []) = (k = Suc 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (list_of {0<..<k} = []) = (k = Suc 0)", "have \"list_of {0<..<k} = [] \\<longleftrightarrow> {0<..<k} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_of {0<..<k} = []) = ({0<..<k} = {})", "by simp"], ["proof (state)\nthis:\n  (list_of {0<..<k} = []) = ({0<..<k} = {})\n\ngoal (1 subgoal):\n 1. (list_of {0<..<k} = []) = (k = Suc 0)", "also"], ["proof (state)\nthis:\n  (list_of {0<..<k} = []) = ({0<..<k} = {})\n\ngoal (1 subgoal):\n 1. (list_of {0<..<k} = []) = (k = Suc 0)", "have \"\\<dots> \\<longleftrightarrow> k = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({0<..<k} = {}) = (k = Suc 0)", "using \\<open>k > 0\\<close> atLeastSucLessThan_greaterThanLessThan"], ["proof (prove)\nusing this:\n  0 < k\n  {Suc ?l..<?u} = {?l<..<?u}\n\ngoal (1 subgoal):\n 1. ({0<..<k} = {}) = (k = Suc 0)", "by fastforce"], ["proof (state)\nthis:\n  ({0<..<k} = {}) = (k = Suc 0)\n\ngoal (1 subgoal):\n 1. (list_of {0<..<k} = []) = (k = Suc 0)", "finally"], ["proof (chain)\npicking this:\n  (list_of {0<..<k} = []) = (k = Suc 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (list_of {0<..<k} = []) = (k = Suc 0)\n\ngoal (1 subgoal):\n 1. (list_of {0<..<k} = []) = (k = Suc 0)", "."], ["proof (state)\nthis:\n  (list_of {0<..<k} = []) = (k = Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?k \\<Longrightarrow> (list_of {0<..<?k} = []) = (?k = Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>M.\n                \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n                 \\<And>U.\n                    U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                    Form l U \\<and>\n                    list.set (inter_scheme l U) \\<subseteq> N\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> m < 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "show thesis \\<comment>\\<open>proof of main result\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ?M \\<in> [WW]\\<^bsup>m\\<^esup>\n 2. \\<And>U.\n       U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have inj: \"inj_on (\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) {..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) {..<m}", "proof (clarsimp simp: inj_on_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < m; y < m;\n        list_of (\\<Union>j<ka. RF j x) =\n        list_of (\\<Union>j<ka. RF j y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < m; y < m;\n        list_of (\\<Union>j<ka. RF j x) =\n        list_of (\\<Union>j<ka. RF j y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x < m\" \"y < m\" \"list_of (\\<Union>j<ka. RF j x) = list_of (\\<Union>j<ka. RF j y)\""], ["proof (state)\nthis:\n  x < m\n  y < m\n  list_of (\\<Union>j<ka. RF j x) = list_of (\\<Union>j<ka. RF j y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < m; y < m;\n        list_of (\\<Union>j<ka. RF j x) =\n        list_of (\\<Union>j<ka. RF j y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x < m\n  y < m\n  list_of (\\<Union>j<ka. RF j x) = list_of (\\<Union>j<ka. RF j y)", "have eq: \"(\\<Union>j<ka. RF j x) = (\\<Union>j<ka. RF j y)\""], ["proof (prove)\nusing this:\n  x < m\n  y < m\n  list_of (\\<Union>j<ka. RF j x) = list_of (\\<Union>j<ka. RF j y)\n\ngoal (1 subgoal):\n 1. (\\<Union>j<ka. RF j x) = (\\<Union>j<ka. RF j y)", "by (simp add: sorted_list_of_set_inject)"], ["proof (state)\nthis:\n  (\\<Union>j<ka. RF j x) = (\\<Union>j<ka. RF j y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < m; y < m;\n        list_of (\\<Union>j<ka. RF j x) =\n        list_of (\\<Union>j<ka. RF j y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "obtain n where n: \"n \\<in> RF 0 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n \\<in> RF 0 x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using AF_ne QF_0 \\<open>0 < k\\<close> Inf_nat_def1 \\<open>k \\<le> ka\\<close>"], ["proof (prove)\nusing this:\n  AF ?k ?i \\<noteq> {}\n  QF ?k (0, ?i) = AF ?k ?i\n  0 < k\n  ?K \\<noteq> {} \\<Longrightarrow> \\<Sqinter> ?K \\<in> ?K\n  k \\<le> ka\n\ngoal (1 subgoal):\n 1. (\\<And>n. n \\<in> RF 0 x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: RF_def)"], ["proof (state)\nthis:\n  n \\<in> RF 0 x\n\ngoal (1 subgoal):\n 1. x = y", "with eq \\<open>ka > 0\\<close>"], ["proof (chain)\npicking this:\n  (\\<Union>j<ka. RF j x) = (\\<Union>j<ka. RF j y)\n  0 < ka\n  n \\<in> RF 0 x", "obtain j' where \"j' < ka\" \"n \\<in> RF j' y\""], ["proof (prove)\nusing this:\n  (\\<Union>j<ka. RF j x) = (\\<Union>j<ka. RF j y)\n  0 < ka\n  n \\<in> RF 0 x\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>j' < ka; n \\<in> RF j' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j' < ka\n  n \\<in> RF j' y\n\ngoal (1 subgoal):\n 1. x = y", "then"], ["proof (chain)\npicking this:\n  j' < ka\n  n \\<in> RF j' y", "show ?thesis"], ["proof (prove)\nusing this:\n  j' < ka\n  n \\<in> RF j' y\n\ngoal (1 subgoal):\n 1. x = y", "using disjoint_QF [of k 0 x j'] n \\<open>x < m\\<close> \\<open>y < m\\<close> \\<open>ka \\<le> Suc k\\<close> \\<open>0 < k\\<close>"], ["proof (prove)\nusing this:\n  j' < ka\n  n \\<in> RF j' y\n  \\<lbrakk>\\<not> disjnt (QF k (0, x)) (QF k (j', ?i)); 0 \\<le> k;\n   j' \\<le> k; x < m; ?i < m\\<rbrakk>\n  \\<Longrightarrow> x = ?i \\<and> 0 = j'\n  n \\<in> RF 0 x\n  x < m\n  y < m\n  ka \\<le> Suc k\n  0 < k\n\ngoal (1 subgoal):\n 1. x = y", "by (force simp: RF_def disjnt_iff simp del: QF_0 split: if_split_asm)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) {..<m}\n\ngoal (2 subgoals):\n 1. ?M \\<in> [WW]\\<^bsup>m\\<^esup>\n 2. \\<And>U.\n       U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "define M where \"M \\<equiv> (\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) ` {..<m}\""], ["proof (state)\nthis:\n  M \\<equiv> (\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) ` {..<m}\n\ngoal (2 subgoals):\n 1. ?M \\<in> [WW]\\<^bsup>m\\<^esup>\n 2. \\<And>U.\n       U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have \"finite M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite M", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) ` {..<m})", "by blast"], ["proof (state)\nthis:\n  finite M\n\ngoal (2 subgoals):\n 1. ?M \\<in> [WW]\\<^bsup>m\\<^esup>\n 2. \\<And>U.\n       U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "moreover"], ["proof (state)\nthis:\n  finite M\n\ngoal (2 subgoals):\n 1. ?M \\<in> [WW]\\<^bsup>m\\<^esup>\n 2. \\<And>U.\n       U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have \"card M = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card M = m", "by (simp add: M_def \\<open>k \\<le> ka\\<close> card_image inj)"], ["proof (state)\nthis:\n  card M = m\n\ngoal (2 subgoals):\n 1. ?M \\<in> [WW]\\<^bsup>m\\<^esup>\n 2. \\<And>U.\n       U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "moreover"], ["proof (state)\nthis:\n  card M = m\n\ngoal (2 subgoals):\n 1. ?M \\<in> [WW]\\<^bsup>m\\<^esup>\n 2. \\<And>U.\n       U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have \"M \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<subseteq> WW", "by (force simp: M_def WW_def)"], ["proof (state)\nthis:\n  M \\<subseteq> WW\n\ngoal (2 subgoals):\n 1. ?M \\<in> [WW]\\<^bsup>m\\<^esup>\n 2. \\<And>U.\n       U \\<in> [?M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "ultimately"], ["proof (chain)\npicking this:\n  finite M\n  card M = m\n  M \\<subseteq> WW", "show \"M \\<in> [WW]\\<^bsup>m\\<^esup>\""], ["proof (prove)\nusing this:\n  finite M\n  card M = m\n  M \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. M \\<in> [WW]\\<^bsup>m\\<^esup>", "by (simp add: nsets_def)"], ["proof (state)\nthis:\n  M \\<in> [WW]\\<^bsup>m\\<^esup>\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       U \\<in> [(\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) `\n                {..<m}]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have sm_RF: \"strict_mono_sets {..<ka} (\\<lambda>j. RF j i)\" if \"i<m\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono_sets {..<ka} (\\<lambda>j. RF j i)", "using sm_QF1 that kka"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < m; ?ka \\<le> Suc ?k; ?k \\<le> ?ka\\<rbrakk>\n  \\<Longrightarrow> strict_mono_sets {..<?ka} (\\<lambda>j. QF ?k (j, ?i))\n  i < m\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. strict_mono_sets {..<ka} (\\<lambda>j. RF j i)", "by (simp add: less_QF RF_def strict_mono_sets_def)"], ["proof (state)\nthis:\n  ?i < m \\<Longrightarrow> strict_mono_sets {..<ka} (\\<lambda>j. RF j ?i)\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       U \\<in> [(\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) `\n                {..<m}]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have RF_non_Nil: \"list_of (RF j i) \\<noteq> []\" if \"j < Suc k\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (RF j i) \\<noteq> []", "using that"], ["proof (prove)\nusing this:\n  j < Suc k\n\ngoal (1 subgoal):\n 1. list_of (RF j i) \\<noteq> []", "by (simp add: RF_def)"], ["proof (state)\nthis:\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       U \\<in> [(\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) `\n                {..<m}]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have less_RF_same: \"RF j i' \\<lless> RF j i\"\n      if \"i' < i\" \"j < k\" for i' i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF j i' \\<lless> RF j i", "using that"], ["proof (prove)\nusing this:\n  i' < i\n  j < k\n\ngoal (1 subgoal):\n 1. RF j i' \\<lless> RF j i", "by (simp add: less_QF_same RF_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < ?i; ?j < k\\<rbrakk>\n  \\<Longrightarrow> RF ?j ?i' \\<lless> RF ?j ?i\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       U \\<in> [(\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) `\n                {..<m}]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have less_RF_same_k: \"RF k i' \\<lless> RF k i\" \\<comment>\\<open>reversed version for @{term k}\\<close>\n      if \"i < i'\" \"i' < m\" for i' i"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF k i' \\<lless> RF k i", "using that"], ["proof (prove)\nusing this:\n  i < i'\n  i' < m\n\ngoal (1 subgoal):\n 1. RF k i' \\<lless> RF k i", "by (simp add: less_QF_same RF_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?i'; ?i' < m\\<rbrakk>\n  \\<Longrightarrow> RF k ?i' \\<lless> RF k ?i\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       U \\<in> [(\\<lambda>i. list_of (\\<Union>j<ka. RF j i)) `\n                {..<m}]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "show \"Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\" if \"U \\<in> [M]\\<^bsup>2\\<^esup>\" for U"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "from that"], ["proof (chain)\npicking this:\n  U \\<in> [M]\\<^bsup>2\\<^esup>", "obtain x y where \"U = {x,y}\" \"x \\<in> M\" \"y \\<in> M\" and xy: \"(x,y) \\<in> lenlex less_than\""], ["proof (prove)\nusing this:\n  U \\<in> [M]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>U = {x, y}; x \\<in> M; y \\<in> M;\n         (x, y) \\<in> lenlex less_than\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: lenlex_nsets_2_eq)"], ["proof (state)\nthis:\n  U = {x, y}\n  x \\<in> M\n  y \\<in> M\n  (x, y) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "let ?R = \"\\<lambda>p. list_of \\<circ> (\\<lambda>j. RF j p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "obtain p q where x: \"x = list_of (\\<Union>j<ka. RF j p)\"\n        and y: \"y = list_of (\\<Union>j<ka. RF j q)\" and \"p < m\" \"q < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>x = list_of (\\<Union>j<ka. RF j p);\n         y = list_of (\\<Union>j<ka. RF j q); p < m; q < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x \\<in> M\\<close> \\<open>y \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> M\n  y \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>x = list_of (\\<Union>j<ka. RF j p);\n         y = list_of (\\<Union>j<ka. RF j q); p < m; q < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  x = list_of (\\<Union>j<ka. RF j p)\n  y = list_of (\\<Union>j<ka. RF j q)\n  p < m\n  q < m\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  x = list_of (\\<Union>j<ka. RF j p)\n  y = list_of (\\<Union>j<ka. RF j q)\n  p < m\n  q < m", "have pq: \"p<q\" \"length x < length y\""], ["proof (prove)\nusing this:\n  x = list_of (\\<Union>j<ka. RF j p)\n  y = list_of (\\<Union>j<ka. RF j q)\n  p < m\n  q < m\n\ngoal (1 subgoal):\n 1. p < q &&& length x < length y", "using xy \\<open>k \\<le> ka\\<close> \\<open>ka \\<le> Suc k\\<close> lexl_not_refl [OF irrefl_less_than]"], ["proof (prove)\nusing this:\n  x = list_of (\\<Union>j<ka. RF j p)\n  y = list_of (\\<Union>j<ka. RF j q)\n  p < m\n  q < m\n  (x, y) \\<in> lenlex less_than\n  k \\<le> ka\n  ka \\<le> Suc k\n  (?x, ?x) \\<notin> lex less_than\n\ngoal (1 subgoal):\n 1. p < q &&& length x < length y", "by (auto simp: lenlex_def sm_RF sorted_list_of_set_UN_lessThan length_concat sum_sorted_list_of_set_map)"], ["proof (state)\nthis:\n  p < q\n  length x < length y\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "moreover"], ["proof (state)\nthis:\n  p < q\n  length x < length y\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have xc: \"x = concat (map (?R p) (list_of {..<ka}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    concat (map (list_of \\<circ> (\\<lambda>j. RF j p)) (list_of {..<ka}))", "by (simp add: x sorted_list_of_set_UN_eq_concat \\<open>k \\<le> ka\\<close> \\<open>ka \\<le> Suc k\\<close> \\<open>p < m\\<close> sm_RF)"], ["proof (state)\nthis:\n  x = concat (map (list_of \\<circ> (\\<lambda>j. RF j p)) (list_of {..<ka}))\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have yc: \"y = concat (map (?R q) (list_of {..<ka}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y =\n    concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {..<ka}))", "by (simp add: y sorted_list_of_set_UN_eq_concat \\<open>k \\<le> ka\\<close> \\<open>ka \\<le> Suc k\\<close> \\<open>q < m\\<close> sm_RF)"], ["proof (state)\nthis:\n  y = concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {..<ka}))\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have enum_DF_AF: \"enum (DF k p) (ka - Suc 0) < hd (list_of (AF k p))\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum (DF k p) (ka - Suc 0) < hd (list_of (AF k p))", "proof (rule less_setsD [OF DF_AF])"], ["proof (state)\ngoal (2 subgoals):\n 1. enum (DF k p) (ka - Suc 0) \\<in> DF ?k1 ?i1\n 2. hd (list_of (AF k p)) \\<in> AF ?k1 ?i1", "show \"enum (DF k p) (ka - Suc 0) \\<in> DF k p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum (DF k p) (ka - Suc 0) \\<in> DF k p", "using \\<open>ka \\<le> Suc k\\<close> card_DF finite_DF"], ["proof (prove)\nusing this:\n  ka \\<le> Suc k\n  card (DF ?k ?i) = Suc ?k\n  finite (DF ?k ?i)\n\ngoal (1 subgoal):\n 1. enum (DF k p) (ka - Suc 0) \\<in> DF k p", "by (auto simp: finite_enumerate_in_set)"], ["proof (state)\nthis:\n  enum (DF k p) (ka - Suc 0) \\<in> DF k p\n\ngoal (1 subgoal):\n 1. hd (list_of (AF k p)) \\<in> AF k p", "show \"hd (list_of (AF k p)) \\<in> AF k p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (list_of (AF k p)) \\<in> AF k p", "using AF_non_Nil finite_AF hd_in_set set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  list_of (AF ?k ?i) \\<noteq> []\n  finite (AF ?k ?i)\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> list.set ?xs\n  finite ?A \\<Longrightarrow> list.set (list_of ?A) = ?A\n\ngoal (1 subgoal):\n 1. hd (list_of (AF k p)) \\<in> AF k p", "by blast"], ["proof (state)\nthis:\n  hd (list_of (AF k p)) \\<in> AF k p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enum (DF k ?p) (ka - Suc 0) < hd (list_of (AF k ?p))\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have less_RF_RF: \"RF n p \\<lless> RF n q\" if \"n < k\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF n p \\<lless> RF n q", "using that \\<open>p<q\\<close>"], ["proof (prove)\nusing this:\n  n < k\n  p < q\n\ngoal (1 subgoal):\n 1. RF n p \\<lless> RF n q", "by (simp add: less_RF_same)"], ["proof (state)\nthis:\n  ?n < k \\<Longrightarrow> RF ?n p \\<lless> RF ?n q\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have less_RF_Suc: \"RF n q \\<lless> RF (Suc n) q\" if \"n < k\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF n q \\<lless> RF (Suc n) q", "using \\<open>q < m\\<close> that"], ["proof (prove)\nusing this:\n  q < m\n  n < k\n\ngoal (1 subgoal):\n 1. RF n q \\<lless> RF (Suc n) q", "by (auto simp: RF_def less_QF)"], ["proof (state)\nthis:\n  ?n < k \\<Longrightarrow> RF ?n q \\<lless> RF (Suc ?n) q\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have less_RF_k: \"RF k q \\<lless> RF k p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF k q \\<lless> RF k p", "using \\<open>q < m\\<close> less_RF_same_k \\<open>p<q\\<close>"], ["proof (prove)\nusing this:\n  q < m\n  \\<lbrakk>?i < ?i'; ?i' < m\\<rbrakk>\n  \\<Longrightarrow> RF k ?i' \\<lless> RF k ?i\n  p < q\n\ngoal (1 subgoal):\n 1. RF k q \\<lless> RF k p", "by blast"], ["proof (state)\nthis:\n  RF k q \\<lless> RF k p\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have less_RF_k_ka: \"RF (k - Suc 0) p \\<lless> RF (ka - Suc 0) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (k - Suc 0) p \\<lless> RF (ka - Suc 0) q", "using ka_k_or_Suc less_RF_RF"], ["proof (prove)\nusing this:\n  ka = k \\<or> ka = Suc k\n  ?n < k \\<Longrightarrow> RF ?n p \\<lless> RF ?n q\n\ngoal (1 subgoal):\n 1. RF (k - Suc 0) p \\<lless> RF (ka - Suc 0) q", "by (metis One_nat_def RF_def \\<open>0 < k\\<close> \\<open>ka - Suc 0 \\<le> k\\<close> \\<open>p < m\\<close> diff_Suc_1 diff_Suc_less less_QF_step)"], ["proof (state)\nthis:\n  RF (k - Suc 0) p \\<lless> RF (ka - Suc 0) q\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have Inf_DF_eq_enum: \"\\<Sqinter> (DF k i) = enum (DF k i) 0\" for k i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (DF k i) = enum (DF k i) 0", "by (simp add: Inf_nat_def enumerate_0)"], ["proof (state)\nthis:\n  \\<Sqinter> (DF ?k ?i) = enum (DF ?k ?i) 0\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have Inf_DF_less: \"\\<Sqinter> (DF k i') < \\<Sqinter> (DF k i)\" if \"i'<i\" for i' i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (DF k i') < \\<Sqinter> (DF k i)", "by (metis DF_ne enum_0_eq_Inf enum_0_eq_Inf_finite enum_DF_less_iff le0 that)"], ["proof (state)\nthis:\n  ?i' < ?i \\<Longrightarrow> \\<Sqinter> (DF ?k ?i') < \\<Sqinter> (DF ?k ?i)\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have AF_Inf_DF_less: \"\\<And>x. x \\<in> AF k i \\<Longrightarrow> \\<Sqinter> (DF k i') < x\" if \"i'\\<le>i\" for i' i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> AF k i \\<Longrightarrow> \\<Sqinter> (DF k i') < x", "using less_setsD [OF DF_AF] DF_ne that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> DF ?k1 ?i1; ?b \\<in> AF ?k1 ?i1\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n  DF ?k ?i \\<noteq> {}\n  i' \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> AF k i \\<Longrightarrow> \\<Sqinter> (DF k i') < x", "by (metis Inf_DF_less Inf_nat_def1 dual_order.order_iff_strict dual_order.strict_trans)"], ["proof (state)\nthis:\n  \\<lbrakk>?i'1 \\<le> ?i1; ?x \\<in> AF k ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> (DF k ?i'1) < ?x\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "proof (cases \"k=1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "case True"], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "with kka"], ["proof (chain)\npicking this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  k = 1", "consider \"ka=1\" | \"ka=2\""], ["proof (prove)\nusing this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  k = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ka = 1 \\<Longrightarrow> thesis;\n     ka = 2 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>ka = 1 \\<Longrightarrow> ?thesis;\n   ka = 2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>ka = 1 \\<Longrightarrow> ?thesis;\n   ka = 2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ka = 1 \\<Longrightarrow> ?thesis;\n   ka = 2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ka = 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "case 1"], ["proof (state)\nthis:\n  ka = 1\n\ngoal (2 subgoals):\n 1. ka = 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "define zs where \"zs = card (AF 1 p) # list_of (AF 1 p)\n                              @ card (AF 1 q) # list_of (AF 1 q)\""], ["proof (state)\nthis:\n  zs = card (AF 1 p) # list_of (AF 1 p) @ card (AF 1 q) # list_of (AF 1 q)\n\ngoal (2 subgoals):\n 1. ka = 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have zs: \"Form_Body ka k x y zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form_Body ka k x y zs", "proof (intro that exI conjI Form_Body.intros [OF \\<open>length x < length y\\<close>])"], ["proof (state)\ngoal (10 subgoals):\n 1. x = concat (?a # ?as)\n 2. y = concat (?b # ?bs)\n 3. ?a # ?as \\<in> lists (- {[]})\n 4. ?b # ?bs \\<in> lists (- {[]})\n 5. length (?a # ?as) = ka\n 6. length (?b # ?bs) = k\n 7. ?c = acc_lengths 0 (?a # ?as)\n 8. ?d = acc_lengths 0 (?b # ?bs)\n 9. zs = concat [?c, ?a, ?d, ?b] @ interact ?as ?bs\n 10. strict_sorted zs", "show \"x = concat ([list_of (AF k p)])\" \"y = concat ([list_of (AF k q)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = concat [list_of (AF k p)] &&& y = concat [list_of (AF k q)]", "by (simp_all add: x y 1 lessThan_Suc RF_0)"], ["proof (state)\nthis:\n  x = concat [list_of (AF k p)]\n  y = concat [list_of (AF k q)]\n\ngoal (8 subgoals):\n 1. [list_of (AF k p)] \\<in> lists (- {[]})\n 2. [list_of (AF k q)] \\<in> lists (- {[]})\n 3. length [list_of (AF k p)] = ka\n 4. length [list_of (AF k q)] = k\n 5. ?c = acc_lengths 0 [list_of (AF k p)]\n 6. ?d = acc_lengths 0 [list_of (AF k q)]\n 7. zs =\n    concat [?c, list_of (AF k p), ?d, list_of (AF k q)] @ interact [] []\n 8. strict_sorted zs", "have \"AF k p \\<lless> insert (\\<Sqinter> (DF k q)) (AF k q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AF k p \\<lless> insert (\\<Sqinter> (DF k q)) (AF k q)", "by (metis AF_DF DF_ne Inf_nat_def1 RF_0 \\<open>0 < k\\<close> insert_iff less_RF_RF less_sets_def pq(1))"], ["proof (state)\nthis:\n  AF k p \\<lless> insert (\\<Sqinter> (DF k q)) (AF k q)\n\ngoal (8 subgoals):\n 1. [list_of (AF k p)] \\<in> lists (- {[]})\n 2. [list_of (AF k q)] \\<in> lists (- {[]})\n 3. length [list_of (AF k p)] = ka\n 4. length [list_of (AF k q)] = k\n 5. ?c = acc_lengths 0 [list_of (AF k p)]\n 6. ?d = acc_lengths 0 [list_of (AF k q)]\n 7. zs =\n    concat [?c, list_of (AF k p), ?d, list_of (AF k q)] @ interact [] []\n 8. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  AF k p \\<lless> insert (\\<Sqinter> (DF k q)) (AF k q)", "have \"strict_sorted (list_of (AF k p) @ \\<Sqinter> (DF k q) # list_of (AF k q))\""], ["proof (prove)\nusing this:\n  AF k p \\<lless> insert (\\<Sqinter> (DF k q)) (AF k q)\n\ngoal (1 subgoal):\n 1. strict_sorted\n     (list_of (AF k p) @ \\<Sqinter> (DF k q) # list_of (AF k q))", "by (auto simp: strict_sorted_append_iff intro: less_sets_imp_list_less AF_Inf_DF_less)"], ["proof (state)\nthis:\n  strict_sorted (list_of (AF k p) @ \\<Sqinter> (DF k q) # list_of (AF k q))\n\ngoal (8 subgoals):\n 1. [list_of (AF k p)] \\<in> lists (- {[]})\n 2. [list_of (AF k q)] \\<in> lists (- {[]})\n 3. length [list_of (AF k p)] = ka\n 4. length [list_of (AF k q)] = k\n 5. ?c = acc_lengths 0 [list_of (AF k p)]\n 6. ?d = acc_lengths 0 [list_of (AF k q)]\n 7. zs =\n    concat [?c, list_of (AF k p), ?d, list_of (AF k q)] @ interact [] []\n 8. strict_sorted zs", "moreover"], ["proof (state)\nthis:\n  strict_sorted (list_of (AF k p) @ \\<Sqinter> (DF k q) # list_of (AF k q))\n\ngoal (8 subgoals):\n 1. [list_of (AF k p)] \\<in> lists (- {[]})\n 2. [list_of (AF k q)] \\<in> lists (- {[]})\n 3. length [list_of (AF k p)] = ka\n 4. length [list_of (AF k q)] = k\n 5. ?c = acc_lengths 0 [list_of (AF k p)]\n 6. ?d = acc_lengths 0 [list_of (AF k q)]\n 7. zs =\n    concat [?c, list_of (AF k p), ?d, list_of (AF k q)] @ interact [] []\n 8. strict_sorted zs", "have \"\\<And>x. x \\<in> AF k q \\<Longrightarrow> \\<Sqinter> (DF k p) < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> AF k q \\<Longrightarrow> \\<Sqinter> (DF k p) < x", "by (meson AF_Inf_DF_less less_imp_le_nat \\<open>p < q\\<close>)"], ["proof (state)\nthis:\n  ?x \\<in> AF k q \\<Longrightarrow> \\<Sqinter> (DF k p) < ?x\n\ngoal (8 subgoals):\n 1. [list_of (AF k p)] \\<in> lists (- {[]})\n 2. [list_of (AF k q)] \\<in> lists (- {[]})\n 3. length [list_of (AF k p)] = ka\n 4. length [list_of (AF k q)] = k\n 5. ?c = acc_lengths 0 [list_of (AF k p)]\n 6. ?d = acc_lengths 0 [list_of (AF k q)]\n 7. zs =\n    concat [?c, list_of (AF k p), ?d, list_of (AF k q)] @ interact [] []\n 8. strict_sorted zs", "ultimately"], ["proof (chain)\npicking this:\n  strict_sorted (list_of (AF k p) @ \\<Sqinter> (DF k q) # list_of (AF k q))\n  ?x \\<in> AF k q \\<Longrightarrow> \\<Sqinter> (DF k p) < ?x", "show \"strict_sorted zs\""], ["proof (prove)\nusing this:\n  strict_sorted (list_of (AF k p) @ \\<Sqinter> (DF k q) # list_of (AF k q))\n  ?x \\<in> AF k q \\<Longrightarrow> \\<Sqinter> (DF k p) < ?x\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "using \\<open>p < q\\<close> True Inf_DF_less DF_AF DF_ne"], ["proof (prove)\nusing this:\n  strict_sorted (list_of (AF k p) @ \\<Sqinter> (DF k q) # list_of (AF k q))\n  ?x \\<in> AF k q \\<Longrightarrow> \\<Sqinter> (DF k p) < ?x\n  p < q\n  k = 1\n  ?i' < ?i \\<Longrightarrow> \\<Sqinter> (DF ?k ?i') < \\<Sqinter> (DF ?k ?i)\n  DF ?k ?i \\<lless> AF ?k ?i\n  DF ?k ?i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "apply (auto simp: zs_def less_sets_def card_AF AF_Inf_DF_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>strict_sorted\n                 (list_of (AF (Suc 0) p) @\n                  \\<Sqinter> (DF (Suc 0) q) # list_of (AF (Suc 0) q));\n        \\<And>x.\n           x \\<in> AF (Suc 0) q \\<Longrightarrow>\n           \\<Sqinter> (DF (Suc 0) p) < x;\n        p < q; k = Suc 0;\n        \\<And>i' i k.\n           i' < i \\<Longrightarrow>\n           \\<Sqinter> (DF k i') < \\<Sqinter> (DF k i);\n        \\<And>k i. \\<forall>x\\<in>DF k i. \\<forall>y\\<in>AF k i. x < y;\n        \\<And>k i. DF k i \\<noteq> {}; x \\<in> AF (Suc 0) p\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> (DF (Suc 0) p) < x", "by (meson Inf_nat_def1)"], ["proof (state)\nthis:\n  strict_sorted zs\n\ngoal (7 subgoals):\n 1. [list_of (AF k p)] \\<in> lists (- {[]})\n 2. [list_of (AF k q)] \\<in> lists (- {[]})\n 3. length [list_of (AF k p)] = ka\n 4. length [list_of (AF k q)] = k\n 5. ?c = acc_lengths 0 [list_of (AF k p)]\n 6. ?d = acc_lengths 0 [list_of (AF k q)]\n 7. zs =\n    concat [?c, list_of (AF k p), ?d, list_of (AF k q)] @ interact [] []", "qed (auto simp: \\<open>k=1\\<close> \\<open>ka=1\\<close> acc_lengths.simps zs_def AF_ne)"], ["proof (state)\nthis:\n  Form_Body ka k x y zs\n\ngoal (2 subgoals):\n 1. ka = 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have zs_N: \"list.set zs \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set zs \\<subseteq> N", "using AF_subset_N"], ["proof (prove)\nusing this:\n  AF ?k ?i \\<subseteq> N\n\ngoal (1 subgoal):\n 1. list.set zs \\<subseteq> N", "by (auto simp: zs_def card_AF Inf_DF_N \\<open>k=1\\<close>)"], ["proof (state)\nthis:\n  list.set zs \\<subseteq> N\n\ngoal (2 subgoals):\n 1. ka = 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Form l U\n 2. list.set (inter_scheme l U) \\<subseteq> N", "have \"l = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = 1", "using kka \\<open>k=1\\<close> \\<open>ka=1\\<close>"], ["proof (prove)\nusing this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  k = 1\n  ka = 1\n\ngoal (1 subgoal):\n 1. l = 1", "by auto"], ["proof (state)\nthis:\n  l = 1\n\ngoal (2 subgoals):\n 1. Form l U\n 2. list.set (inter_scheme l U) \\<subseteq> N", "have \"Form (2*1-1) {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form (2 * 1 - 1) {x, y}", "using \"1\" Form.intros(2) True zs"], ["proof (prove)\nusing this:\n  ka = 1\n  \\<lbrakk>Form_Body ?k ?k ?xs ?ys ?zs; 0 < ?k\\<rbrakk>\n  \\<Longrightarrow> Form (2 * ?k - 1) {?xs, ?ys}\n  k = 1\n  Form_Body ka k x y zs\n\ngoal (1 subgoal):\n 1. Form (2 * 1 - 1) {x, y}", "by fastforce"], ["proof (state)\nthis:\n  Form (2 * 1 - 1) {x, y}\n\ngoal (2 subgoals):\n 1. Form l U\n 2. list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  Form (2 * 1 - 1) {x, y}", "show \"Form l U\""], ["proof (prove)\nusing this:\n  Form (2 * 1 - 1) {x, y}\n\ngoal (1 subgoal):\n 1. Form l U", "by (simp add: \\<open>U = {x,y}\\<close> \\<open>l = 1\\<close>)"], ["proof (state)\nthis:\n  Form l U\n\ngoal (1 subgoal):\n 1. list.set (inter_scheme l U) \\<subseteq> N", "show \"list.set (inter_scheme l U) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (inter_scheme l U) \\<subseteq> N", "using kka zs zs_N \\<open>k=1\\<close> Form_Body_imp_inter_scheme"], ["proof (prove)\nusing this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  Form_Body ka k x y zs\n  list.set zs \\<subseteq> N\n  k = 1\n  \\<lbrakk>Form_Body ?ka ?kb ?xs ?ys ?zs; 0 < ?kb; ?kb \\<le> ?ka;\n   ?ka \\<le> Suc ?kb\\<rbrakk>\n  \\<Longrightarrow> ?zs = inter_scheme (?ka + ?kb - Suc 0) {?xs, ?ys}\n\ngoal (1 subgoal):\n 1. list.set (inter_scheme l U) \\<subseteq> N", "by (fastforce simp add: \\<open>U = {x,y}\\<close>)"], ["proof (state)\nthis:\n  list.set (inter_scheme l U) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "case 2"], ["proof (state)\nthis:\n  ka = 2\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "note True [simp]"], ["proof (state)\nthis:\n  k = 1\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "note 2 [simp]"], ["proof (state)\nthis:\n  ka = 2\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have [simp]: \"{0<..<2} = {Suc 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..<2} = {Suc 0}", "by auto"], ["proof (state)\nthis:\n  {0<..<2} = {Suc 0}\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have enum_DF1_eq: \"enum (DF (Suc 0) i) (Suc 0) = card (AF (Suc 0) i) + card (RF (Suc 0) i)\"\n            if \"i < m\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum (DF (Suc 0) i) (Suc 0) = card (AF (Suc 0) i) + card (RF (Suc 0) i)", "using card_AF_sum that"], ["proof (prove)\nusing this:\n  ?i < m \\<Longrightarrow>\n  card (AF k ?i) + (\\<Sum>j\\<in>{0<..<ka}. card (RF j ?i)) =\n  enum (DF k ?i) (ka - 1)\n  i < m\n\ngoal (1 subgoal):\n 1. enum (DF (Suc 0) i) (Suc 0) = card (AF (Suc 0) i) + card (RF (Suc 0) i)", "by simp"], ["proof (state)\nthis:\n  ?i < m \\<Longrightarrow>\n  enum (DF (Suc 0) ?i) (Suc 0) = card (AF (Suc 0) ?i) + card (RF (Suc 0) ?i)\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have card_RF: \"card (RF (Suc 0) i) = enum (DF (Suc 0) i) (Suc 0) - enum (DF (Suc 0) i) 0\" if \"i < m\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (RF (Suc 0) i) =\n    enum (DF (Suc 0) i) (Suc 0) - enum (DF (Suc 0) i) 0", "using that"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. card (RF (Suc 0) i) =\n    enum (DF (Suc 0) i) (Suc 0) - enum (DF (Suc 0) i) 0", "by (auto simp: RF_def card_QF del_def)"], ["proof (state)\nthis:\n  ?i < m \\<Longrightarrow>\n  card (RF (Suc 0) ?i) =\n  enum (DF (Suc 0) ?i) (Suc 0) - enum (DF (Suc 0) ?i) 0\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have list_of_AF_RF: \"list_of (AF (Suc 0) q \\<union> RF (Suc 0) q) = list_of (AF (Suc 0) q) @ list_of (RF (Suc 0) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (AF (Suc 0) q \\<union> RF (Suc 0) q) =\n    list_of (AF (Suc 0) q) @ list_of (RF (Suc 0) q)", "using RF_def \\<open>q < m\\<close> less_QF_step"], ["proof (prove)\nusing this:\n  RF \\<equiv>\n  \\<lambda>j i. if j = k then QF k (j, m - Suc i) else QF k (j, i)\n  q < m\n  \\<lbrakk>0 < ?j; ?j \\<le> ?k; ?i' < m\\<rbrakk>\n  \\<Longrightarrow> QF ?k (?j - Suc 0, ?i') \\<lless> QF ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. list_of (AF (Suc 0) q \\<union> RF (Suc 0) q) =\n    list_of (AF (Suc 0) q) @ list_of (RF (Suc 0) q)", "by (fastforce intro!: sorted_list_of_set_Un)"], ["proof (state)\nthis:\n  list_of (AF (Suc 0) q \\<union> RF (Suc 0) q) =\n  list_of (AF (Suc 0) q) @ list_of (RF (Suc 0) q)\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "define zs where \"zs = card (AF 1 p) # (card (AF 1 p) + card (RF 1 p))\n                         # list_of (AF 1 p)\n                  @ (card (AF 1 q) + card (RF 1 q)) # list_of (AF 1 q) @ list_of (RF 1 q) @ list_of (RF 1 p)\""], ["proof (state)\nthis:\n  zs =\n  card (AF 1 p) #\n  (card (AF 1 p) + card (RF 1 p)) #\n  list_of (AF 1 p) @\n  (card (AF 1 q) + card (RF 1 q)) #\n  list_of (AF 1 q) @ list_of (RF 1 q) @ list_of (RF 1 p)\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have zs: \"Form_Body ka k x y zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form_Body ka k x y zs", "proof (intro that exI conjI Form_Body.intros [OF \\<open>length x < length y\\<close>])"], ["proof (state)\ngoal (10 subgoals):\n 1. x = concat (?a # ?as)\n 2. y = concat (?b # ?bs)\n 3. ?a # ?as \\<in> lists (- {[]})\n 4. ?b # ?bs \\<in> lists (- {[]})\n 5. length (?a # ?as) = ka\n 6. length (?b # ?bs) = k\n 7. ?c = acc_lengths 0 (?a # ?as)\n 8. ?d = acc_lengths 0 (?b # ?bs)\n 9. zs = concat [?c, ?a, ?d, ?b] @ interact ?as ?bs\n 10. strict_sorted zs", "have \"x = list_of (RF 0 p \\<union> RF (Suc 0) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = list_of (RF 0 p \\<union> RF (Suc 0) p)", "by (simp add: x eval_nat_numeral lessThan_Suc RF_0 Un_commute)"], ["proof (state)\nthis:\n  x = list_of (RF 0 p \\<union> RF (Suc 0) p)\n\ngoal (10 subgoals):\n 1. x = concat (?a # ?as)\n 2. y = concat (?b # ?bs)\n 3. ?a # ?as \\<in> lists (- {[]})\n 4. ?b # ?bs \\<in> lists (- {[]})\n 5. length (?a # ?as) = ka\n 6. length (?b # ?bs) = k\n 7. ?c = acc_lengths 0 (?a # ?as)\n 8. ?d = acc_lengths 0 (?b # ?bs)\n 9. zs = concat [?c, ?a, ?d, ?b] @ interact ?as ?bs\n 10. strict_sorted zs", "also"], ["proof (state)\nthis:\n  x = list_of (RF 0 p \\<union> RF (Suc 0) p)\n\ngoal (10 subgoals):\n 1. x = concat (?a # ?as)\n 2. y = concat (?b # ?bs)\n 3. ?a # ?as \\<in> lists (- {[]})\n 4. ?b # ?bs \\<in> lists (- {[]})\n 5. length (?a # ?as) = ka\n 6. length (?b # ?bs) = k\n 7. ?c = acc_lengths 0 (?a # ?as)\n 8. ?d = acc_lengths 0 (?b # ?bs)\n 9. zs = concat [?c, ?a, ?d, ?b] @ interact ?as ?bs\n 10. strict_sorted zs", "have \"\\<dots> = list_of (RF 0 p) @ list_of (RF (Suc 0) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (RF 0 p \\<union> RF (Suc 0) p) =\n    list_of (RF 0 p) @ list_of (RF (Suc 0) p)", "using RF_def True \\<open>p < m\\<close> less_QF_step"], ["proof (prove)\nusing this:\n  RF \\<equiv>\n  \\<lambda>j i. if j = k then QF k (j, m - Suc i) else QF k (j, i)\n  k = 1\n  p < m\n  \\<lbrakk>0 < ?j; ?j \\<le> ?k; ?i' < m\\<rbrakk>\n  \\<Longrightarrow> QF ?k (?j - Suc 0, ?i') \\<lless> QF ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. list_of (RF 0 p \\<union> RF (Suc 0) p) =\n    list_of (RF 0 p) @ list_of (RF (Suc 0) p)", "by (subst sorted_list_of_set_Un) (fastforce+)"], ["proof (state)\nthis:\n  list_of (RF 0 p \\<union> RF (Suc 0) p) =\n  list_of (RF 0 p) @ list_of (RF (Suc 0) p)\n\ngoal (10 subgoals):\n 1. x = concat (?a # ?as)\n 2. y = concat (?b # ?bs)\n 3. ?a # ?as \\<in> lists (- {[]})\n 4. ?b # ?bs \\<in> lists (- {[]})\n 5. length (?a # ?as) = ka\n 6. length (?b # ?bs) = k\n 7. ?c = acc_lengths 0 (?a # ?as)\n 8. ?d = acc_lengths 0 (?b # ?bs)\n 9. zs = concat [?c, ?a, ?d, ?b] @ interact ?as ?bs\n 10. strict_sorted zs", "finally"], ["proof (chain)\npicking this:\n  x = list_of (RF 0 p) @ list_of (RF (Suc 0) p)", "show \"x = concat ([list_of (AF 1 p),list_of (RF 1 p)])\""], ["proof (prove)\nusing this:\n  x = list_of (RF 0 p) @ list_of (RF (Suc 0) p)\n\ngoal (1 subgoal):\n 1. x = concat [list_of (AF 1 p), list_of (RF 1 p)]", "by (simp add: RF_0)"], ["proof (state)\nthis:\n  x = concat [list_of (AF 1 p), list_of (RF 1 p)]\n\ngoal (9 subgoals):\n 1. y = concat (?b # ?bs)\n 2. [list_of (AF 1 p), list_of (RF 1 p)] \\<in> lists (- {[]})\n 3. ?b # ?bs \\<in> lists (- {[]})\n 4. length [list_of (AF 1 p), list_of (RF 1 p)] = ka\n 5. length (?b # ?bs) = k\n 6. ?c = acc_lengths 0 [list_of (AF 1 p), list_of (RF 1 p)]\n 7. ?d = acc_lengths 0 (?b # ?bs)\n 8. zs =\n    concat [?c, list_of (AF 1 p), ?d, ?b] @ interact [list_of (RF 1 p)] ?bs\n 9. strict_sorted zs", "show \"y = concat [list_of (RF 1 q \\<union> AF 1 q)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = concat [list_of (RF 1 q \\<union> AF 1 q)]", "by (simp add: y eval_nat_numeral lessThan_Suc RF_0)"], ["proof (state)\nthis:\n  y = concat [list_of (RF 1 q \\<union> AF 1 q)]\n\ngoal (8 subgoals):\n 1. [list_of (AF 1 p), list_of (RF 1 p)] \\<in> lists (- {[]})\n 2. [list_of (RF 1 q \\<union> AF 1 q)] \\<in> lists (- {[]})\n 3. length [list_of (AF 1 p), list_of (RF 1 p)] = ka\n 4. length [list_of (RF 1 q \\<union> AF 1 q)] = k\n 5. ?c = acc_lengths 0 [list_of (AF 1 p), list_of (RF 1 p)]\n 6. ?d = acc_lengths 0 [list_of (RF 1 q \\<union> AF 1 q)]\n 7. zs =\n    concat [?c, list_of (AF 1 p), ?d, list_of (RF 1 q \\<union> AF 1 q)] @\n    interact [list_of (RF 1 p)] []\n 8. strict_sorted zs", "show \"zs = concat [[card (AF 1 p), card (AF 1 p) + card (RF 1 p)], list_of (AF 1 p),\n                              [card (AF 1 q) + card (RF 1 q)], list_of (RF 1 q \\<union> AF 1 q)] @ interact [list_of (RF 1 p)] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs =\n    concat\n     [[card (AF 1 p), card (AF 1 p) + card (RF 1 p)], list_of (AF 1 p),\n      [card (AF 1 q) + card (RF 1 q)], list_of (RF 1 q \\<union> AF 1 q)] @\n    interact [list_of (RF 1 p)] []", "using list_of_AF_RF"], ["proof (prove)\nusing this:\n  list_of (AF (Suc 0) q \\<union> RF (Suc 0) q) =\n  list_of (AF (Suc 0) q) @ list_of (RF (Suc 0) q)\n\ngoal (1 subgoal):\n 1. zs =\n    concat\n     [[card (AF 1 p), card (AF 1 p) + card (RF 1 p)], list_of (AF 1 p),\n      [card (AF 1 q) + card (RF 1 q)], list_of (RF 1 q \\<union> AF 1 q)] @\n    interact [list_of (RF 1 p)] []", "by (simp add: zs_def Un_commute)"], ["proof (state)\nthis:\n  zs =\n  concat\n   [[card (AF 1 p), card (AF 1 p) + card (RF 1 p)], list_of (AF 1 p),\n    [card (AF 1 q) + card (RF 1 q)], list_of (RF 1 q \\<union> AF 1 q)] @\n  interact [list_of (RF 1 p)] []\n\ngoal (7 subgoals):\n 1. [list_of (AF 1 p), list_of (RF 1 p)] \\<in> lists (- {[]})\n 2. [list_of (RF 1 q \\<union> AF 1 q)] \\<in> lists (- {[]})\n 3. length [list_of (AF 1 p), list_of (RF 1 p)] = ka\n 4. length [list_of (RF 1 q \\<union> AF 1 q)] = k\n 5. [card (AF 1 p), card (AF 1 p) + card (RF 1 p)] =\n    acc_lengths 0 [list_of (AF 1 p), list_of (RF 1 p)]\n 6. [card (AF 1 q) + card (RF 1 q)] =\n    acc_lengths 0 [list_of (RF 1 q \\<union> AF 1 q)]\n 7. strict_sorted zs", "show \"strict_sorted zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted zs", "proof (simp add: \\<open>p<m\\<close> \\<open>q<m\\<close> \\<open>p<q\\<close> zs_def strict_sorted_append_iff, intro conjI strip)"], ["proof (state)\ngoal (9 subgoals):\n 1. 0 < card (RF (Suc 0) p)\n 2. card (AF (Suc 0) p) < card (AF (Suc 0) q) + card (RF (Suc 0) q)\n 3. \\<And>x.\n       x \\<in> AF (Suc 0) p \\<union>\n               (AF (Suc 0) q \\<union>\n                (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n       card (AF (Suc 0) p) < x\n 4. card (AF (Suc 0) p) + card (RF (Suc 0) p)\n    < card (AF (Suc 0) q) + card (RF (Suc 0) q)\n 5. \\<And>x.\n       x \\<in> AF (Suc 0) p \\<union>\n               (AF (Suc 0) q \\<union>\n                (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n       card (AF (Suc 0) p) + card (RF (Suc 0) p) < x\n 6. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 7. \\<And>x.\n       x \\<in> AF (Suc 0) q \\<union>\n               (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n       card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\n 8. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 9. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "show \"0 < card (RF (Suc 0) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card (RF (Suc 0) p)", "using \\<open>p<m\\<close>"], ["proof (prove)\nusing this:\n  p < m\n\ngoal (1 subgoal):\n 1. 0 < card (RF (Suc 0) p)", "by (simp add: card_RF card_DF finite_DF)"], ["proof (state)\nthis:\n  0 < card (RF (Suc 0) p)\n\ngoal (8 subgoals):\n 1. card (AF (Suc 0) p) < card (AF (Suc 0) q) + card (RF (Suc 0) q)\n 2. \\<And>x.\n       x \\<in> AF (Suc 0) p \\<union>\n               (AF (Suc 0) q \\<union>\n                (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n       card (AF (Suc 0) p) < x\n 3. card (AF (Suc 0) p) + card (RF (Suc 0) p)\n    < card (AF (Suc 0) q) + card (RF (Suc 0) q)\n 4. \\<And>x.\n       x \\<in> AF (Suc 0) p \\<union>\n               (AF (Suc 0) q \\<union>\n                (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n       card (AF (Suc 0) p) + card (RF (Suc 0) p) < x\n 5. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 6. \\<And>x.\n       x \\<in> AF (Suc 0) q \\<union>\n               (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n       card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\n 7. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 8. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "show \"card (AF (Suc 0) p) < card (AF (Suc 0) q) + card (RF (Suc 0) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF (Suc 0) p) < card (AF (Suc 0) q) + card (RF (Suc 0) q)", "using \\<open>p<q\\<close> \\<open>q<m\\<close>"], ["proof (prove)\nusing this:\n  p < q\n  q < m\n\ngoal (1 subgoal):\n 1. card (AF (Suc 0) p) < card (AF (Suc 0) q) + card (RF (Suc 0) q)", "by (simp add: Inf_DF_less card_AF trans_less_add1)"], ["proof (state)\nthis:\n  card (AF (Suc 0) p) < card (AF (Suc 0) q) + card (RF (Suc 0) q)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       x \\<in> AF (Suc 0) p \\<union>\n               (AF (Suc 0) q \\<union>\n                (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n       card (AF (Suc 0) p) < x\n 2. card (AF (Suc 0) p) + card (RF (Suc 0) p)\n    < card (AF (Suc 0) q) + card (RF (Suc 0) q)\n 3. \\<And>x.\n       x \\<in> AF (Suc 0) p \\<union>\n               (AF (Suc 0) q \\<union>\n                (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n       card (AF (Suc 0) p) + card (RF (Suc 0) p) < x\n 4. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 5. \\<And>x.\n       x \\<in> AF (Suc 0) q \\<union>\n               (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n       card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\n 6. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 7. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "show \"card (AF (Suc 0) p) < x\"\n                if \"x \\<in> AF (Suc 0) p \\<union> (AF (Suc 0) q \\<union> (RF (Suc 0) q \\<union> RF (Suc 0) p))\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF (Suc 0) p) < x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> AF (Suc 0) p \\<union>\n          (AF (Suc 0) q \\<union> (RF (Suc 0) q \\<union> RF (Suc 0) p))\n\ngoal (1 subgoal):\n 1. card (AF (Suc 0) p) < x", "apply (simp add: card_AF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> AF (Suc 0) p \\<or>\n    x \\<in> AF (Suc 0) q \\<or>\n    x \\<in> RF (Suc 0) q \\<or> x \\<in> RF (Suc 0) p \\<Longrightarrow>\n    \\<Sqinter> (DF (Suc 0) p) < x", "by (metis AF_ne DF_AF DF_ne less_RF_RF less_RF_Suc less_RF_k Inf_nat_def1 One_nat_def RF_0 RF_non_Nil True finite_RF lessI less_setsD less_sets_trans sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  ?x \\<in> AF (Suc 0) p \\<union>\n           (AF (Suc 0) q \\<union>\n            (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n  card (AF (Suc 0) p) < ?x\n\ngoal (6 subgoals):\n 1. card (AF (Suc 0) p) + card (RF (Suc 0) p)\n    < card (AF (Suc 0) q) + card (RF (Suc 0) q)\n 2. \\<And>x.\n       x \\<in> AF (Suc 0) p \\<union>\n               (AF (Suc 0) q \\<union>\n                (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n       card (AF (Suc 0) p) + card (RF (Suc 0) p) < x\n 3. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 4. \\<And>x.\n       x \\<in> AF (Suc 0) q \\<union>\n               (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n       card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\n 5. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 6. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "show \"card (AF (Suc 0) p) + card (RF (Suc 0) p) < card (AF (Suc 0) q) + card (RF (Suc 0) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF (Suc 0) p) + card (RF (Suc 0) p)\n    < card (AF (Suc 0) q) + card (RF (Suc 0) q)", "using \\<open>p < q\\<close> \\<open>p < m\\<close> \\<open>q < m\\<close>"], ["proof (prove)\nusing this:\n  p < q\n  p < m\n  q < m\n\ngoal (1 subgoal):\n 1. card (AF (Suc 0) p) + card (RF (Suc 0) p)\n    < card (AF (Suc 0) q) + card (RF (Suc 0) q)", "by (metis enum_DF1_eq enum_DF_less_iff le_refl)"], ["proof (state)\nthis:\n  card (AF (Suc 0) p) + card (RF (Suc 0) p)\n  < card (AF (Suc 0) q) + card (RF (Suc 0) q)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       x \\<in> AF (Suc 0) p \\<union>\n               (AF (Suc 0) q \\<union>\n                (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n       card (AF (Suc 0) p) + card (RF (Suc 0) p) < x\n 2. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 3. \\<And>x.\n       x \\<in> AF (Suc 0) q \\<union>\n               (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n       card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\n 4. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 5. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "show \"card (AF (Suc 0) p) + card (RF (Suc 0) p) < x\"\n                if \"x \\<in> AF (Suc 0) p \\<union> (AF (Suc 0) q \\<union> (RF (Suc 0) q \\<union> RF (Suc 0) p))\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF (Suc 0) p) + card (RF (Suc 0) p) < x", "using that \\<open>p < m\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> AF (Suc 0) p \\<union>\n          (AF (Suc 0) q \\<union> (RF (Suc 0) q \\<union> RF (Suc 0) p))\n  p < m\n\ngoal (1 subgoal):\n 1. card (AF (Suc 0) p) + card (RF (Suc 0) p) < x", "apply (simp add: flip: enum_DF1_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> AF (Suc 0) p \\<or>\n             x \\<in> AF (Suc 0) q \\<or>\n             x \\<in> RF (Suc 0) q \\<or> x \\<in> RF (Suc 0) p;\n     p < m\\<rbrakk>\n    \\<Longrightarrow> enum (DF (Suc 0) p) (Suc 0) < x", "by (metis AF_ne DF_AF less_RF_RF less_RF_Suc less_RF_k One_nat_def RF_0 RF_non_Nil Suc_mono True \\<open>0 < k\\<close> card_DF finite_enumerate_in_set finite_DF less_setsD less_sets_trans sorted_list_of_set_empty)"], ["proof (state)\nthis:\n  ?x \\<in> AF (Suc 0) p \\<union>\n           (AF (Suc 0) q \\<union>\n            (RF (Suc 0) q \\<union> RF (Suc 0) p)) \\<Longrightarrow>\n  card (AF (Suc 0) p) + card (RF (Suc 0) p) < ?x\n\ngoal (4 subgoals):\n 1. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 2. \\<And>x.\n       x \\<in> AF (Suc 0) q \\<union>\n               (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n       card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\n 3. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 4. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "have \"list_of (AF (Suc 0) p) < list_of {enum (DF (Suc 0) q) (Suc 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (AF (Suc 0) p) < list_of {enum (DF (Suc 0) q) (Suc 0)}", "proof (rule less_sets_imp_sorted_list_of_set)"], ["proof (state)\ngoal (3 subgoals):\n 1. AF (Suc 0) p \\<lless> {enum (DF (Suc 0) q) (Suc 0)}\n 2. finite (AF (Suc 0) p)\n 3. finite {enum (DF (Suc 0) q) (Suc 0)}", "show \"AF (Suc 0) p \\<lless> {enum (DF (Suc 0) q) (Suc 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AF (Suc 0) p \\<lless> {enum (DF (Suc 0) q) (Suc 0)}", "by (metis (no_types, lifting) AF_DF DF_ne Inf_nat_def1 \\<open>q < m\\<close> card_AF enum_DF1_eq less_setsD less_sets_singleton2 pq(1) trans_less_add1)"], ["proof (state)\nthis:\n  AF (Suc 0) p \\<lless> {enum (DF (Suc 0) q) (Suc 0)}\n\ngoal (2 subgoals):\n 1. finite (AF (Suc 0) p)\n 2. finite {enum (DF (Suc 0) q) (Suc 0)}", "qed auto"], ["proof (state)\nthis:\n  list_of (AF (Suc 0) p) < list_of {enum (DF (Suc 0) q) (Suc 0)}\n\ngoal (4 subgoals):\n 1. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 2. \\<And>x.\n       x \\<in> AF (Suc 0) q \\<union>\n               (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n       card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\n 3. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 4. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "then"], ["proof (chain)\npicking this:\n  list_of (AF (Suc 0) p) < list_of {enum (DF (Suc 0) q) (Suc 0)}", "show \"list_of (AF (Suc 0) p) < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) # list_of (AF (Suc 0) q) @ list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\""], ["proof (prove)\nusing this:\n  list_of (AF (Suc 0) p) < list_of {enum (DF (Suc 0) q) (Suc 0)}\n\ngoal (1 subgoal):\n 1. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)", "using \\<open>q < m\\<close>"], ["proof (prove)\nusing this:\n  list_of (AF (Suc 0) p) < list_of {enum (DF (Suc 0) q) (Suc 0)}\n  q < m\n\ngoal (1 subgoal):\n 1. list_of (AF (Suc 0) p)\n    < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n      list_of (AF (Suc 0) q) @\n      list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)", "by (simp add: less_list_def enum_DF1_eq)"], ["proof (state)\nthis:\n  list_of (AF (Suc 0) p)\n  < (card (AF (Suc 0) q) + card (RF (Suc 0) q)) #\n    list_of (AF (Suc 0) q) @ list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> AF (Suc 0) q \\<union>\n               (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n       card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\n 2. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 3. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "show \"card (AF (Suc 0) q) + card (RF (Suc 0) q) < x\"\n                if \"x \\<in> AF (Suc 0) q \\<union> (RF (Suc 0) q \\<union> RF (Suc 0) p)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF (Suc 0) q) + card (RF (Suc 0) q) < x", "using that \\<open>q < m\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> AF (Suc 0) q \\<union> (RF (Suc 0) q \\<union> RF (Suc 0) p)\n  q < m\n\ngoal (1 subgoal):\n 1. card (AF (Suc 0) q) + card (RF (Suc 0) q) < x", "apply (simp flip: enum_DF1_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> AF (Suc 0) q \\<or>\n             x \\<in> RF (Suc 0) q \\<or> x \\<in> RF (Suc 0) p;\n     q < m\\<rbrakk>\n    \\<Longrightarrow> enum (DF (Suc 0) q) (Suc 0) < x", "by (metis AF_ne DF_AF less_RF_Suc less_RF_k One_nat_def RF_0 RF_non_Nil True card_DF finite_enumerate_in_set finite_DF finite_RF lessI less_setsD less_sets_trans sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  ?x \\<in> AF (Suc 0) q \\<union>\n           (RF (Suc 0) q \\<union> RF (Suc 0) p) \\<Longrightarrow>\n  card (AF (Suc 0) q) + card (RF (Suc 0) q) < ?x\n\ngoal (2 subgoals):\n 1. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 2. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "have \"list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q)", "proof (rule less_sets_imp_sorted_list_of_set)"], ["proof (state)\ngoal (3 subgoals):\n 1. AF (Suc 0) q \\<lless> RF (Suc 0) q\n 2. finite (AF (Suc 0) q)\n 3. finite (RF (Suc 0) q)", "show \"AF (Suc 0) q \\<lless> RF (Suc 0) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AF (Suc 0) q \\<lless> RF (Suc 0) q", "by (metis less_RF_Suc One_nat_def RF_0 True \\<open>0 < k\\<close>)"], ["proof (state)\nthis:\n  AF (Suc 0) q \\<lless> RF (Suc 0) q\n\ngoal (2 subgoals):\n 1. finite (AF (Suc 0) q)\n 2. finite (RF (Suc 0) q)", "qed auto"], ["proof (state)\nthis:\n  list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q)\n\ngoal (2 subgoals):\n 1. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n 2. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "then"], ["proof (chain)\npicking this:\n  list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q)", "show \"list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\""], ["proof (prove)\nusing this:\n  list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q)\n\ngoal (1 subgoal):\n 1. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)", "using RF_non_Nil"], ["proof (prove)\nusing this:\n  list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q)\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)", "by (auto simp: less_list_def)"], ["proof (state)\nthis:\n  list_of (AF (Suc 0) q) < list_of (RF (Suc 0) q) @ list_of (RF (Suc 0) p)\n\ngoal (1 subgoal):\n 1. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "show \"list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)", "proof (rule less_sets_imp_sorted_list_of_set)"], ["proof (state)\ngoal (3 subgoals):\n 1. RF (Suc 0) q \\<lless> RF (Suc 0) p\n 2. finite (RF (Suc 0) q)\n 3. finite (RF (Suc 0) p)", "show \"RF (Suc 0) q \\<lless> RF (Suc 0) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (Suc 0) q \\<lless> RF (Suc 0) p", "by (metis less_RF_k One_nat_def True)"], ["proof (state)\nthis:\n  RF (Suc 0) q \\<lless> RF (Suc 0) p\n\ngoal (2 subgoals):\n 1. finite (RF (Suc 0) q)\n 2. finite (RF (Suc 0) p)", "qed auto"], ["proof (state)\nthis:\n  list_of (RF (Suc 0) q) < list_of (RF (Suc 0) p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strict_sorted zs\n\ngoal (6 subgoals):\n 1. [list_of (AF 1 p), list_of (RF 1 p)] \\<in> lists (- {[]})\n 2. [list_of (RF 1 q \\<union> AF 1 q)] \\<in> lists (- {[]})\n 3. length [list_of (AF 1 p), list_of (RF 1 p)] = ka\n 4. length [list_of (RF 1 q \\<union> AF 1 q)] = k\n 5. [card (AF 1 p), card (AF 1 p) + card (RF 1 p)] =\n    acc_lengths 0 [list_of (AF 1 p), list_of (RF 1 p)]\n 6. [card (AF 1 q) + card (RF 1 q)] =\n    acc_lengths 0 [list_of (RF 1 q \\<union> AF 1 q)]", "show \"[list_of (AF 1 p), list_of (RF 1 p)] \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [list_of (AF 1 p), list_of (RF 1 p)] \\<in> lists (- {[]})", "using RF_non_Nil \\<open>0 < k\\<close>"], ["proof (prove)\nusing this:\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n  0 < k\n\ngoal (1 subgoal):\n 1. [list_of (AF 1 p), list_of (RF 1 p)] \\<in> lists (- {[]})", "by (auto simp: acc_lengths.simps zs_def AF_ne)"], ["proof (state)\nthis:\n  [list_of (AF 1 p), list_of (RF 1 p)] \\<in> lists (- {[]})\n\ngoal (5 subgoals):\n 1. [list_of (RF 1 q \\<union> AF 1 q)] \\<in> lists (- {[]})\n 2. length [list_of (AF 1 p), list_of (RF 1 p)] = ka\n 3. length [list_of (RF 1 q \\<union> AF 1 q)] = k\n 4. [card (AF 1 p), card (AF 1 p) + card (RF 1 p)] =\n    acc_lengths 0 [list_of (AF 1 p), list_of (RF 1 p)]\n 5. [card (AF 1 q) + card (RF 1 q)] =\n    acc_lengths 0 [list_of (RF 1 q \\<union> AF 1 q)]", "show \"[card (AF 1 q) + card (RF 1 q)] = acc_lengths 0 [list_of (RF 1 q \\<union> AF 1 q)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [card (AF 1 q) + card (RF 1 q)] =\n    acc_lengths 0 [list_of (RF 1 q \\<union> AF 1 q)]", "using list_of_AF_RF"], ["proof (prove)\nusing this:\n  list_of (AF (Suc 0) q \\<union> RF (Suc 0) q) =\n  list_of (AF (Suc 0) q) @ list_of (RF (Suc 0) q)\n\ngoal (1 subgoal):\n 1. [card (AF 1 q) + card (RF 1 q)] =\n    acc_lengths 0 [list_of (RF 1 q \\<union> AF 1 q)]", "by (auto simp: acc_lengths.simps zs_def AF_ne sup_commute)"], ["proof (state)\nthis:\n  [card (AF 1 q) + card (RF 1 q)] =\n  acc_lengths 0 [list_of (RF 1 q \\<union> AF 1 q)]\n\ngoal (4 subgoals):\n 1. [list_of (RF 1 q \\<union> AF 1 q)] \\<in> lists (- {[]})\n 2. length [list_of (AF 1 p), list_of (RF 1 p)] = ka\n 3. length [list_of (RF 1 q \\<union> AF 1 q)] = k\n 4. [card (AF 1 p), card (AF 1 p) + card (RF 1 p)] =\n    acc_lengths 0 [list_of (AF 1 p), list_of (RF 1 p)]", "qed (auto simp: acc_lengths.simps zs_def AF_ne)"], ["proof (state)\nthis:\n  Form_Body ka k x y zs\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have zs_N: \"list.set zs \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set zs \\<subseteq> N", "using \\<open>p < m\\<close> \\<open>q < m\\<close> DF_in_N  enum_DF1_eq [symmetric]"], ["proof (prove)\nusing this:\n  p < m\n  q < m\n  ?j \\<le> k \\<Longrightarrow> enum (DF k ?i) ?j \\<in> N\n  ?i < m \\<Longrightarrow>\n  card (AF (Suc 0) ?i) + card (RF (Suc 0) ?i) = enum (DF (Suc 0) ?i) (Suc 0)\n\ngoal (1 subgoal):\n 1. list.set zs \\<subseteq> N", "by (auto simp: zs_def card_AF AF_subset_N RF_subset_N Inf_DF_N)"], ["proof (state)\nthis:\n  list.set zs \\<subseteq> N\n\ngoal (1 subgoal):\n 1. ka = 2 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Form l U\n 2. list.set (inter_scheme l U) \\<subseteq> N", "have \"Form (2*1) {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form (2 * 1) {x, y}", "by (metis \"2\" Form.simps Suc_1 True zero_less_one zs)"], ["proof (state)\nthis:\n  Form (2 * 1) {x, y}\n\ngoal (2 subgoals):\n 1. Form l U\n 2. list.set (inter_scheme l U) \\<subseteq> N", "with kka"], ["proof (chain)\npicking this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  Form (2 * 1) {x, y}", "show \"Form l U\""], ["proof (prove)\nusing this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  Form (2 * 1) {x, y}\n\ngoal (1 subgoal):\n 1. Form l U", "by (simp add: \\<open>U = {x,y}\\<close>)"], ["proof (state)\nthis:\n  Form l U\n\ngoal (1 subgoal):\n 1. list.set (inter_scheme l U) \\<subseteq> N", "show \"list.set (inter_scheme l U) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (inter_scheme l U) \\<subseteq> N", "using kka zs zs_N \\<open>k=1\\<close> Form_Body_imp_inter_scheme"], ["proof (prove)\nusing this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  Form_Body ka k x y zs\n  list.set zs \\<subseteq> N\n  k = 1\n  \\<lbrakk>Form_Body ?ka ?kb ?xs ?ys ?zs; 0 < ?kb; ?kb \\<le> ?ka;\n   ?ka \\<le> Suc ?kb\\<rbrakk>\n  \\<Longrightarrow> ?zs = inter_scheme (?ka + ?kb - Suc 0) {?xs, ?ys}\n\ngoal (1 subgoal):\n 1. list.set (inter_scheme l U) \\<subseteq> N", "by (fastforce simp add: \\<open>U = {x, y}\\<close>)"], ["proof (state)\nthis:\n  list.set (inter_scheme l U) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have \"k \\<ge> 2\" \"ka \\<ge> 2\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> k &&& 2 \\<le> ka", "using kka \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  0 < k\n\ngoal (1 subgoal):\n 1. 2 \\<le> k &&& 2 \\<le> ka", "by auto"], ["proof (state)\nthis:\n  2 \\<le> k\n  2 \\<le> ka\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  2 \\<le> k\n  2 \\<le> ka", "have k_minus_1 [simp]: \"Suc (k - Suc (Suc 0)) = k - Suc 0\""], ["proof (prove)\nusing this:\n  2 \\<le> k\n  2 \\<le> ka\n\ngoal (1 subgoal):\n 1. Suc (k - Suc (Suc 0)) = k - Suc 0", "by auto"], ["proof (state)\nthis:\n  Suc (k - Suc (Suc 0)) = k - Suc 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "define PP where \"PP \\<equiv> map (?R p) (list_of {0<..<ka})\""], ["proof (state)\nthis:\n  PP \\<equiv> map (list_of \\<circ> (\\<lambda>j. RF j p)) (list_of {0<..<ka})\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "define QQ where \"QQ \\<equiv> map (?R q) (list_of {0<..<k-1}) @ ([list_of (RF (k-1) q \\<union> RF (ka-1) q)])\""], ["proof (state)\nthis:\n  QQ \\<equiv>\n  map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<k - 1}) @\n  [list_of (RF (k - 1) q \\<union> RF (ka - 1) q)]\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "let ?INT = \"interact PP QQ\"\n        \\<comment>\\<open>No separate sets A and B as in the text, but instead we treat both cases as once\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have [simp]: \"length PP = ka - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length PP = ka - 1", "by (simp add: PP_def)"], ["proof (state)\nthis:\n  length PP = ka - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have [simp]: \"length QQ = k - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length QQ = k - 1", "using \\<open>k \\<ge> 2\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. length QQ = k - 1", "by (simp add: QQ_def)"], ["proof (state)\nthis:\n  length QQ = k - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have PP_n: \"PP ! n = list_of (RF (Suc n) p)\"\n          if \"n < ka-1\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. PP ! n = list_of (RF (Suc n) p)", "using that kka"], ["proof (prove)\nusing this:\n  n < ka - 1\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. PP ! n = list_of (RF (Suc n) p)", "by (auto simp: PP_def nth_sorted_list_of_set_greaterThanLessThan)"], ["proof (state)\nthis:\n  ?n < ka - 1 \\<Longrightarrow> PP ! ?n = list_of (RF (Suc ?n) p)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have QQ_n: \"QQ ! n = (if n < k - Suc (Suc 0) then list_of (RF (Suc n) q)\n                              else list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q))\"\n          if \"n < k-1\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. QQ ! n =\n    (if n < k - Suc (Suc 0) then list_of (RF (Suc n) q)\n     else list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q))", "using that kka"], ["proof (prove)\nusing this:\n  n < k - 1\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. QQ ! n =\n    (if n < k - Suc (Suc 0) then list_of (RF (Suc n) q)\n     else list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q))", "by (auto simp: QQ_def nth_append nth_sorted_list_of_set_greaterThanLessThan)"], ["proof (state)\nthis:\n  ?n < k - 1 \\<Longrightarrow>\n  QQ ! ?n =\n  (if ?n < k - Suc (Suc 0) then list_of (RF (Suc ?n) q)\n   else list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have QQ_n_same: \"QQ ! n = list_of (RF (Suc n) q)\"\n          if \"n < k - Suc 0\" \"k=ka\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. QQ ! n = list_of (RF (Suc n) q)", "using that kka Suc_diff_Suc"], ["proof (prove)\nusing this:\n  n < k - Suc 0\n  k = ka\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  ?n < ?m \\<Longrightarrow> Suc (?m - Suc ?n) = ?m - ?n\n\ngoal (1 subgoal):\n 1. QQ ! n = list_of (RF (Suc n) q)", "by (fastforce simp add: QQ_def nth_append nth_sorted_list_of_set_greaterThanLessThan)"], ["proof (state)\nthis:\n  \\<lbrakk>?n < k - Suc 0; k = ka\\<rbrakk>\n  \\<Longrightarrow> QQ ! ?n = list_of (RF (Suc ?n) q)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have split_nat_interval: \"{0<..<n} = insert (n - Suc 0) {0<..<n - Suc 0}\" if \"n \\<ge> 2\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..<n} = insert (n - Suc 0) {0<..<n - Suc 0}", "using that"], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. {0<..<n} = insert (n - Suc 0) {0<..<n - Suc 0}", "by auto"], ["proof (state)\nthis:\n  2 \\<le> ?n \\<Longrightarrow>\n  {0<..<?n} = insert (?n - Suc 0) {0<..<?n - Suc 0}\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have split_list_interval: \"list_of{0<..<n} = list_of{0<..<n - Suc 0} @ [n - Suc 0]\" if \"n \\<ge> 2\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of {0<..<n} = list_of {0<..<n - Suc 0} @ [n - Suc 0]", "proof (intro sorted_list_of_set_unique [THEN iffD1] conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite {0<..<n}\n 2. strict_sorted (list_of {0<..<n - Suc 0} @ [n - Suc 0])\n 3. list.set (list_of {0<..<n - Suc 0} @ [n - Suc 0]) = {0<..<n}\n 4. length (list_of {0<..<n - Suc 0} @ [n - Suc 0]) = card {0<..<n}", "have \"list_of {0<..<n - Suc 0} < [n - Suc 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of {0<..<n - Suc 0} < [n - Suc 0]", "by (auto intro: less_sets_imp_list_less)"], ["proof (state)\nthis:\n  list_of {0<..<n - Suc 0} < [n - Suc 0]\n\ngoal (4 subgoals):\n 1. finite {0<..<n}\n 2. strict_sorted (list_of {0<..<n - Suc 0} @ [n - Suc 0])\n 3. list.set (list_of {0<..<n - Suc 0} @ [n - Suc 0]) = {0<..<n}\n 4. length (list_of {0<..<n - Suc 0} @ [n - Suc 0]) = card {0<..<n}", "then"], ["proof (chain)\npicking this:\n  list_of {0<..<n - Suc 0} < [n - Suc 0]", "show \"strict_sorted (list_of {0<..<n - Suc 0} @ [n - Suc 0])\""], ["proof (prove)\nusing this:\n  list_of {0<..<n - Suc 0} < [n - Suc 0]\n\ngoal (1 subgoal):\n 1. strict_sorted (list_of {0<..<n - Suc 0} @ [n - Suc 0])", "by (auto simp: strict_sorted_append_iff)"], ["proof (state)\nthis:\n  strict_sorted (list_of {0<..<n - Suc 0} @ [n - Suc 0])\n\ngoal (3 subgoals):\n 1. finite {0<..<n}\n 2. list.set (list_of {0<..<n - Suc 0} @ [n - Suc 0]) = {0<..<n}\n 3. length (list_of {0<..<n - Suc 0} @ [n - Suc 0]) = card {0<..<n}", "qed (use \\<open>n \\<ge> 2\\<close> in auto)"], ["proof (state)\nthis:\n  2 \\<le> ?n \\<Longrightarrow>\n  list_of {0<..<?n} = list_of {0<..<?n - Suc 0} @ [?n - Suc 0]\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have list_of_RF_Un: \"list_of (RF (k - Suc 0) q \\<union> RF k q) = list_of (RF (k - Suc 0) q) @ list_of (RF k q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (RF (k - Suc 0) q \\<union> RF k q) =\n    list_of (RF (k - Suc 0) q) @ list_of (RF k q)", "by (metis less_RF_Suc Suc_pred \\<open>0 < k\\<close> diff_Suc_less finite_RF sorted_list_of_set_Un)"], ["proof (state)\nthis:\n  list_of (RF (k - Suc 0) q \\<union> RF k q) =\n  list_of (RF (k - Suc 0) q) @ list_of (RF k q)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have card_AF_sum_QQ: \"card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "proof (cases \"ka = Suc k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ka = Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\n 2. ka \\<noteq> Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "case True"], ["proof (state)\nthis:\n  ka = Suc k\n\ngoal (2 subgoals):\n 1. ka = Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\n 2. ka \\<noteq> Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "have \"RF (k - Suc 0) q \\<inter> RF k q = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (k - Suc 0) q \\<inter> RF k q = {}", "using less_RF_Suc [of \"k - Suc 0\"] \\<open>k > 0\\<close>"], ["proof (prove)\nusing this:\n  k - Suc 0 < k \\<Longrightarrow>\n  RF (k - Suc 0) q \\<lless> RF (Suc (k - Suc 0)) q\n  0 < k\n\ngoal (1 subgoal):\n 1. RF (k - Suc 0) q \\<inter> RF k q = {}", "by (auto simp: less_sets_def)"], ["proof (state)\nthis:\n  RF (k - Suc 0) q \\<inter> RF k q = {}\n\ngoal (2 subgoals):\n 1. ka = Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\n 2. ka \\<noteq> Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "then"], ["proof (chain)\npicking this:\n  RF (k - Suc 0) q \\<inter> RF k q = {}", "have \"card (RF (k - Suc 0) q \\<union> RF k q) = card (RF (k - Suc 0) q) + card (RF k q)\""], ["proof (prove)\nusing this:\n  RF (k - Suc 0) q \\<inter> RF k q = {}\n\ngoal (1 subgoal):\n 1. card (RF (k - Suc 0) q \\<union> RF k q) =\n    card (RF (k - Suc 0) q) + card (RF k q)", "by (simp add: card_Un_disjoint)"], ["proof (state)\nthis:\n  card (RF (k - Suc 0) q \\<union> RF k q) =\n  card (RF (k - Suc 0) q) + card (RF k q)\n\ngoal (2 subgoals):\n 1. ka = Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\n 2. ka \\<noteq> Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "then"], ["proof (chain)\npicking this:\n  card (RF (k - Suc 0) q \\<union> RF k q) =\n  card (RF (k - Suc 0) q) + card (RF k q)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (RF (k - Suc 0) q \\<union> RF k q) =\n  card (RF (k - Suc 0) q) + card (RF k q)\n\ngoal (1 subgoal):\n 1. card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "using \\<open>k\\<ge>2\\<close> \\<open>q < m\\<close>"], ["proof (prove)\nusing this:\n  card (RF (k - Suc 0) q \\<union> RF k q) =\n  card (RF (k - Suc 0) q) + card (RF k q)\n  2 \\<le> k\n  q < m\n\ngoal (1 subgoal):\n 1. card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "apply (simp add: QQ_def True flip: RF_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>card (RF (k - Suc 0) q \\<union> RF k q) =\n             card (RF (k - Suc 0) q) + card (RF k q);\n     2 \\<le> k; q < m\\<rbrakk>\n    \\<Longrightarrow> card (RF 0 q) +\n                      (sum_list\n                        (map (length \\<circ>\n                              (list_of \\<circ> (\\<lambda>j. RF j q)))\n                          (list_of {0<..<k - Suc 0})) +\n                       card (RF (k - Suc 0) q)) =\n                      (\\<Sum>j<k. card (RF j q))", "apply (simp add: lessThan_k split_nat_interval sum_sorted_list_of_set_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\n\ngoal (1 subgoal):\n 1. ka \\<noteq> Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ka \\<noteq> Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "case False"], ["proof (state)\nthis:\n  ka \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. ka \\<noteq> Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "with kka"], ["proof (chain)\npicking this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  ka \\<noteq> Suc k", "have \"ka=k\""], ["proof (prove)\nusing this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  ka \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. ka = k", "by linarith"], ["proof (state)\nthis:\n  ka = k\n\ngoal (1 subgoal):\n 1. ka \\<noteq> Suc k \\<Longrightarrow>\n    card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "with \\<open>k\\<ge>2\\<close>"], ["proof (chain)\npicking this:\n  2 \\<le> k\n  ka = k", "show ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> k\n  ka = k\n\ngoal (1 subgoal):\n 1. card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))", "by (simp add: QQ_def lessThan_k split_nat_interval sum_sorted_list_of_set_map flip: RF_0)"], ["proof (state)\nthis:\n  card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "define LENS where \"LENS \\<equiv> \\<lambda>i. acc_lengths 0 (list_of (AF k i) # map (?R i) (list_of {0<..<ka}))\""], ["proof (state)\nthis:\n  LENS \\<equiv>\n  \\<lambda>i.\n     acc_lengths 0\n      (list_of (AF k i) #\n       map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {0<..<ka}))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have LENS_subset_N: \"list.set (LENS i) \\<subseteq> N\" if \"i < m\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (LENS i) \\<subseteq> N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list.set (LENS i) \\<subseteq> N", "have eq: \"(list_of (AF k i) # map (?R i) (list_of {0<..<ka})) = map (?R i) (list_of {..<ka})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (AF k i) #\n    map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {0<..<ka}) =\n    map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {..<ka})", "using RF_0 \\<open>0 < ka\\<close> sorted_list_of_set_k"], ["proof (prove)\nusing this:\n  RF 0 ?i = AF k ?i\n  0 < ka\n  0 < ?k \\<Longrightarrow> list_of {..<?k} = 0 # list_of {0<..<?k}\n\ngoal (1 subgoal):\n 1. list_of (AF k i) #\n    map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {0<..<ka}) =\n    map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {..<ka})", "by auto"], ["proof (state)\nthis:\n  list_of (AF k i) #\n  map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {0<..<ka}) =\n  map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {..<ka})\n\ngoal (1 subgoal):\n 1. list.set (LENS i) \\<subseteq> N", "let ?f = \"rec_nat [card (AF k i)] (\\<lambda>n r. r @ [(\\<Sum>j\\<le>Suc n. card (RF j i))])\""], ["proof (state)\ngoal (1 subgoal):\n 1. list.set (LENS i) \\<subseteq> N", "have f: \"acc_lengths 0 (map (?R i) (list_of {..v})) = ?f v\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. acc_lengths 0\n     (map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {..v})) =\n    rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v", "by (induction v) (auto simp: RF_0 acc_lengths.simps acc_lengths_append sum_sorted_list_of_set_map)"], ["proof (state)\nthis:\n  acc_lengths 0\n   (map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {..?v})) =\n  rec_nat [card (AF k i)]\n   (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) ?v\n\ngoal (1 subgoal):\n 1. list.set (LENS i) \\<subseteq> N", "have 3: \"list.set (?f v) \\<subseteq> N\" if \"v \\<le> k\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set\n     (rec_nat [card (AF k i)]\n       (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n    \\<subseteq> N", "using that"], ["proof (prove)\nusing this:\n  v \\<le> k\n\ngoal (1 subgoal):\n 1. list.set\n     (rec_nat [card (AF k i)]\n       (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n    \\<subseteq> N", "proof (induction v)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> k \\<Longrightarrow>\n    list.set\n     (rec_nat [card (AF k i)]\n       (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) 0)\n    \\<subseteq> N\n 2. \\<And>v.\n       \\<lbrakk>v \\<le> k \\<Longrightarrow>\n                list.set\n                 (rec_nat [card (AF k i)]\n                   (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n                \\<subseteq> N;\n        Suc v \\<le> k\\<rbrakk>\n       \\<Longrightarrow> list.set\n                          (rec_nat [card (AF k i)]\n                            (\\<lambda>n r.\n                                r @ [\\<Sum>j\\<le>Suc n. card (RF j i)])\n                            (Suc v))\n                         \\<subseteq> N", "case 0"], ["proof (state)\nthis:\n  0 \\<le> k\n\ngoal (2 subgoals):\n 1. 0 \\<le> k \\<Longrightarrow>\n    list.set\n     (rec_nat [card (AF k i)]\n       (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) 0)\n    \\<subseteq> N\n 2. \\<And>v.\n       \\<lbrakk>v \\<le> k \\<Longrightarrow>\n                list.set\n                 (rec_nat [card (AF k i)]\n                   (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n                \\<subseteq> N;\n        Suc v \\<le> k\\<rbrakk>\n       \\<Longrightarrow> list.set\n                          (rec_nat [card (AF k i)]\n                            (\\<lambda>n r.\n                                r @ [\\<Sum>j\\<le>Suc n. card (RF j i)])\n                            (Suc v))\n                         \\<subseteq> N", "have \"card (AF k i) \\<in> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (AF k i) \\<in> N", "by (metis DF_N DF_ne Inf_nat_def1 Int_subset_iff card_AF subsetD)"], ["proof (state)\nthis:\n  card (AF k i) \\<in> N\n\ngoal (2 subgoals):\n 1. 0 \\<le> k \\<Longrightarrow>\n    list.set\n     (rec_nat [card (AF k i)]\n       (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) 0)\n    \\<subseteq> N\n 2. \\<And>v.\n       \\<lbrakk>v \\<le> k \\<Longrightarrow>\n                list.set\n                 (rec_nat [card (AF k i)]\n                   (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n                \\<subseteq> N;\n        Suc v \\<le> k\\<rbrakk>\n       \\<Longrightarrow> list.set\n                          (rec_nat [card (AF k i)]\n                            (\\<lambda>n r.\n                                r @ [\\<Sum>j\\<le>Suc n. card (RF j i)])\n                            (Suc v))\n                         \\<subseteq> N", "with 0"], ["proof (chain)\npicking this:\n  0 \\<le> k\n  card (AF k i) \\<in> N", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  card (AF k i) \\<in> N\n\ngoal (1 subgoal):\n 1. list.set\n     (rec_nat [card (AF k i)]\n       (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) 0)\n    \\<subseteq> N", "by simp"], ["proof (state)\nthis:\n  list.set\n   (rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) 0)\n  \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> k \\<Longrightarrow>\n                list.set\n                 (rec_nat [card (AF k i)]\n                   (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n                \\<subseteq> N;\n        Suc v \\<le> k\\<rbrakk>\n       \\<Longrightarrow> list.set\n                          (rec_nat [card (AF k i)]\n                            (\\<lambda>n r.\n                                r @ [\\<Sum>j\\<le>Suc n. card (RF j i)])\n                            (Suc v))\n                         \\<subseteq> N", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> k \\<Longrightarrow>\n                list.set\n                 (rec_nat [card (AF k i)]\n                   (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n                \\<subseteq> N;\n        Suc v \\<le> k\\<rbrakk>\n       \\<Longrightarrow> list.set\n                          (rec_nat [card (AF k i)]\n                            (\\<lambda>n r.\n                                r @ [\\<Sum>j\\<le>Suc n. card (RF j i)])\n                            (Suc v))\n                         \\<subseteq> N", "case (Suc v)"], ["proof (state)\nthis:\n  v \\<le> k \\<Longrightarrow>\n  list.set\n   (rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n  \\<subseteq> N\n  Suc v \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> k \\<Longrightarrow>\n                list.set\n                 (rec_nat [card (AF k i)]\n                   (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n                \\<subseteq> N;\n        Suc v \\<le> k\\<rbrakk>\n       \\<Longrightarrow> list.set\n                          (rec_nat [card (AF k i)]\n                            (\\<lambda>n r.\n                                r @ [\\<Sum>j\\<le>Suc n. card (RF j i)])\n                            (Suc v))\n                         \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  v \\<le> k \\<Longrightarrow>\n  list.set\n   (rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n  \\<subseteq> N\n  Suc v \\<le> k", "have \"enum (DF k i) (Suc v) \\<in> N\""], ["proof (prove)\nusing this:\n  v \\<le> k \\<Longrightarrow>\n  list.set\n   (rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n  \\<subseteq> N\n  Suc v \\<le> k\n\ngoal (1 subgoal):\n 1. enum (DF k i) (Suc v) \\<in> N", "by (metis DF_N Int_subset_iff card_DF finite_enumerate_in_set finite_DF in_mono le_imp_less_Suc)"], ["proof (state)\nthis:\n  enum (DF k i) (Suc v) \\<in> N\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> k \\<Longrightarrow>\n                list.set\n                 (rec_nat [card (AF k i)]\n                   (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n                \\<subseteq> N;\n        Suc v \\<le> k\\<rbrakk>\n       \\<Longrightarrow> list.set\n                          (rec_nat [card (AF k i)]\n                            (\\<lambda>n r.\n                                r @ [\\<Sum>j\\<le>Suc n. card (RF j i)])\n                            (Suc v))\n                         \\<subseteq> N", "with Suc \\<open>i < m\\<close>"], ["proof (chain)\npicking this:\n  v \\<le> k \\<Longrightarrow>\n  list.set\n   (rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n  \\<subseteq> N\n  Suc v \\<le> k\n  i < m\n  enum (DF k i) (Suc v) \\<in> N", "show ?case"], ["proof (prove)\nusing this:\n  v \\<le> k \\<Longrightarrow>\n  list.set\n   (rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) v)\n  \\<subseteq> N\n  Suc v \\<le> k\n  i < m\n  enum (DF k i) (Suc v) \\<in> N\n\ngoal (1 subgoal):\n 1. list.set\n     (rec_nat [card (AF k i)]\n       (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) (Suc v))\n    \\<subseteq> N", "by (simp del: sum.atMost_Suc)"], ["proof (state)\nthis:\n  list.set\n   (rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) (Suc v))\n  \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v \\<le> k \\<Longrightarrow>\n  list.set\n   (rec_nat [card (AF k i)]\n     (\\<lambda>n r. r @ [\\<Sum>j\\<le>Suc n. card (RF j i)]) ?v)\n  \\<subseteq> N\n\ngoal (1 subgoal):\n 1. list.set (LENS i) \\<subseteq> N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (LENS i) \\<subseteq> N", "unfolding LENS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set\n     (acc_lengths 0\n       (list_of (AF k i) #\n        map (list_of \\<circ> (\\<lambda>j. RF j i)) (list_of {0<..<ka})))\n    \\<subseteq> N", "by (metis \"3\" Suc_pred \\<open>0 < ka\\<close> \\<open>ka - Suc 0 \\<le> k\\<close> eq f lessThan_Suc_atMost)"], ["proof (state)\nthis:\n  list.set (LENS i) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < m \\<Longrightarrow> list.set (LENS ?i) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "define LENS_QQ where \"LENS_QQ \\<equiv> acc_lengths 0 (list_of (AF k q) # QQ)\""], ["proof (state)\nthis:\n  LENS_QQ \\<equiv> acc_lengths 0 (list_of (AF k q) # QQ)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have LENS_QQ_subset: \"list.set LENS_QQ \\<subseteq> list.set (LENS q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set LENS_QQ \\<subseteq> list.set (LENS q)", "proof (cases \"ka = Suc k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ka = Suc k \\<Longrightarrow>\n    list.set LENS_QQ \\<subseteq> list.set (LENS q)\n 2. ka \\<noteq> Suc k \\<Longrightarrow>\n    list.set LENS_QQ \\<subseteq> list.set (LENS q)", "case True"], ["proof (state)\nthis:\n  ka = Suc k\n\ngoal (2 subgoals):\n 1. ka = Suc k \\<Longrightarrow>\n    list.set LENS_QQ \\<subseteq> list.set (LENS q)\n 2. ka \\<noteq> Suc k \\<Longrightarrow>\n    list.set LENS_QQ \\<subseteq> list.set (LENS q)", "with \\<open>k \\<ge> 2\\<close>"], ["proof (chain)\npicking this:\n  2 \\<le> k\n  ka = Suc k", "show ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> k\n  ka = Suc k\n\ngoal (1 subgoal):\n 1. list.set LENS_QQ \\<subseteq> list.set (LENS q)", "unfolding QQ_def LENS_QQ_def LENS_def"], ["proof (prove)\nusing this:\n  2 \\<le> k\n  ka = Suc k\n\ngoal (1 subgoal):\n 1. list.set\n     (acc_lengths 0\n       (list_of (AF k q) #\n        map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<k - 1}) @\n        [list_of (RF (k - 1) q \\<union> RF (ka - 1) q)]))\n    \\<subseteq> list.set\n                 (acc_lengths 0\n                   (list_of (AF k q) #\n                    map (list_of \\<circ> (\\<lambda>j. RF j q))\n                     (list_of {0<..<ka})))", "by (auto simp: list_of_RF_Un split_list_interval acc_lengths.simps acc_lengths_append)"], ["proof (state)\nthis:\n  list.set LENS_QQ \\<subseteq> list.set (LENS q)\n\ngoal (1 subgoal):\n 1. ka \\<noteq> Suc k \\<Longrightarrow>\n    list.set LENS_QQ \\<subseteq> list.set (LENS q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ka \\<noteq> Suc k \\<Longrightarrow>\n    list.set LENS_QQ \\<subseteq> list.set (LENS q)", "case False"], ["proof (state)\nthis:\n  ka \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. ka \\<noteq> Suc k \\<Longrightarrow>\n    list.set LENS_QQ \\<subseteq> list.set (LENS q)", "then"], ["proof (chain)\npicking this:\n  ka \\<noteq> Suc k", "have \"ka=k\""], ["proof (prove)\nusing this:\n  ka \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. ka = k", "using kka"], ["proof (prove)\nusing this:\n  ka \\<noteq> Suc k\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. ka = k", "by linarith"], ["proof (state)\nthis:\n  ka = k\n\ngoal (1 subgoal):\n 1. ka \\<noteq> Suc k \\<Longrightarrow>\n    list.set LENS_QQ \\<subseteq> list.set (LENS q)", "with \\<open>k \\<ge> 2\\<close>"], ["proof (chain)\npicking this:\n  2 \\<le> k\n  ka = k", "show ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> k\n  ka = k\n\ngoal (1 subgoal):\n 1. list.set LENS_QQ \\<subseteq> list.set (LENS q)", "by (simp add: QQ_def LENS_QQ_def LENS_def split_list_interval)"], ["proof (state)\nthis:\n  list.set LENS_QQ \\<subseteq> list.set (LENS q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list.set LENS_QQ \\<subseteq> list.set (LENS q)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "have ss_INT: \"strict_sorted ?INT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact PP QQ)", "proof (rule strict_sorted_interact_I)"], ["proof (state)\ngoal (8 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. n < length QQ \\<Longrightarrow> PP ! n < QQ ! n\n 6. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 7. PP \\<in> lists (- {[]})\n 8. QQ \\<in> lists (- {[]})", "fix n"], ["proof (state)\ngoal (8 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. n < length QQ \\<Longrightarrow> PP ! n < QQ ! n\n 6. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 7. PP \\<in> lists (- {[]})\n 8. QQ \\<in> lists (- {[]})", "assume \"n < length QQ\""], ["proof (state)\nthis:\n  n < length QQ\n\ngoal (8 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. n < length QQ \\<Longrightarrow> PP ! n < QQ ! n\n 6. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 7. PP \\<in> lists (- {[]})\n 8. QQ \\<in> lists (- {[]})", "then"], ["proof (chain)\npicking this:\n  n < length QQ", "have n: \"n < k-1\""], ["proof (prove)\nusing this:\n  n < length QQ\n\ngoal (1 subgoal):\n 1. n < k - 1", "by simp"], ["proof (state)\nthis:\n  n < k - 1\n\ngoal (8 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. n < length QQ \\<Longrightarrow> PP ! n < QQ ! n\n 6. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 7. PP \\<in> lists (- {[]})\n 8. QQ \\<in> lists (- {[]})", "have \"n = k - Suc (Suc 0)\" if \"\\<not> n < k - Suc (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = k - Suc (Suc 0)", "using n that"], ["proof (prove)\nusing this:\n  n < k - 1\n  \\<not> n < k - Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. n = k - Suc (Suc 0)", "by linarith"], ["proof (state)\nthis:\n  \\<not> n < k - Suc (Suc 0) \\<Longrightarrow> n = k - Suc (Suc 0)\n\ngoal (8 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. n < length QQ \\<Longrightarrow> PP ! n < QQ ! n\n 6. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 7. PP \\<in> lists (- {[]})\n 8. QQ \\<in> lists (- {[]})", "with \\<open>p<q\\<close> n"], ["proof (chain)\npicking this:\n  p < q\n  n < k - 1\n  \\<not> n < k - Suc (Suc 0) \\<Longrightarrow> n = k - Suc (Suc 0)", "show \"PP ! n < QQ ! n\""], ["proof (prove)\nusing this:\n  p < q\n  n < k - 1\n  \\<not> n < k - Suc (Suc 0) \\<Longrightarrow> n = k - Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. PP ! n < QQ ! n", "using \\<open>0 < k\\<close> \\<open>k \\<le> ka\\<close> \\<open>ka \\<le> Suc k\\<close> \\<open>p<q\\<close> n"], ["proof (prove)\nusing this:\n  p < q\n  n < k - 1\n  \\<not> n < k - Suc (Suc 0) \\<Longrightarrow> n = k - Suc (Suc 0)\n  0 < k\n  k \\<le> ka\n  ka \\<le> Suc k\n  p < q\n  n < k - 1\n\ngoal (1 subgoal):\n 1. PP ! n < QQ ! n", "by (auto simp: PP_n QQ_n less_RF_same less_sets_imp_sorted_list_of_set less_sets_Un2 less_RF_RF less_RF_k_ka)"], ["proof (state)\nthis:\n  PP ! n < QQ ! n\n\ngoal (7 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 6. PP \\<in> lists (- {[]})\n 7. QQ \\<in> lists (- {[]})", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 6. PP \\<in> lists (- {[]})\n 7. QQ \\<in> lists (- {[]})", "fix n"], ["proof (state)\ngoal (7 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 6. PP \\<in> lists (- {[]})\n 7. QQ \\<in> lists (- {[]})", "have V: \"\\<lbrakk>Suc n < ka - Suc 0\\<rbrakk> \\<Longrightarrow> list_of (RF (Suc n) q) < list_of (RF (Suc (Suc n)) p)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n < ka - Suc 0 \\<Longrightarrow>\n    list_of (RF (Suc n) q) < list_of (RF (Suc (Suc n)) p)", "by (smt One_nat_def RF_def Suc_leI \\<open>ka - Suc 0 \\<le> k\\<close> \\<open>q < m\\<close> diff_Suc_1 finite_RF less_QF_step less_le_trans less_sets_imp_sorted_list_of_set nat_neq_iff zero_less_Suc)"], ["proof (state)\nthis:\n  Suc ?n < ka - Suc 0 \\<Longrightarrow>\n  list_of (RF (Suc ?n) q) < list_of (RF (Suc (Suc ?n)) p)\n\ngoal (7 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 6. PP \\<in> lists (- {[]})\n 7. QQ \\<in> lists (- {[]})", "have \"RF (k -  Suc 0) q \\<lless> RF k p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (k - Suc 0) q \\<lless> RF k p", "by (metis less_RF_Suc less_RF_k RF_non_Nil Suc_pred \\<open>0 < k\\<close> finite_RF lessI less_sets_trans sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  RF (k - Suc 0) q \\<lless> RF k p\n\ngoal (7 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 6. PP \\<in> lists (- {[]})\n 7. QQ \\<in> lists (- {[]})", "with kka"], ["proof (chain)\npicking this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  RF (k - Suc 0) q \\<lless> RF k p", "have \"RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q \\<lless> RF k p\""], ["proof (prove)\nusing this:\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n  RF (k - Suc 0) q \\<lless> RF k p\n\ngoal (1 subgoal):\n 1. RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q \\<lless> RF k p", "by (metis less_RF_k One_nat_def less_sets_Un1 antisym_conv2 diff_Suc_1 le_less_Suc_eq)"], ["proof (state)\nthis:\n  RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q \\<lless> RF k p\n\ngoal (7 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 6. PP \\<in> lists (- {[]})\n 7. QQ \\<in> lists (- {[]})", "then"], ["proof (chain)\npicking this:\n  RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q \\<lless> RF k p", "have VI: \"list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q) < list_of (RF k p)\""], ["proof (prove)\nusing this:\n  RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q \\<lless> RF k p\n\ngoal (1 subgoal):\n 1. list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q) < list_of (RF k p)", "by (rule less_sets_imp_sorted_list_of_set) auto"], ["proof (state)\nthis:\n  list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q) < list_of (RF k p)\n\ngoal (7 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 6. PP \\<in> lists (- {[]})\n 7. QQ \\<in> lists (- {[]})", "assume \"Suc n < length PP\""], ["proof (state)\nthis:\n  Suc n < length PP\n\ngoal (7 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. \\<And>n. Suc n < length PP \\<Longrightarrow> QQ ! n < PP ! Suc n\n 6. PP \\<in> lists (- {[]})\n 7. QQ \\<in> lists (- {[]})", "with \\<open>ka \\<le> Suc k\\<close> VI"], ["proof (chain)\npicking this:\n  ka \\<le> Suc k\n  list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q) < list_of (RF k p)\n  Suc n < length PP", "show \"QQ ! n < PP ! Suc n\""], ["proof (prove)\nusing this:\n  ka \\<le> Suc k\n  list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q) < list_of (RF k p)\n  Suc n < length PP\n\ngoal (1 subgoal):\n 1. QQ ! n < PP ! Suc n", "apply (auto simp: PP_n QQ_n less_RF_same less_sets_imp_sorted_list_of_set less_sets_Un1 less_sets_Un2 less_RF_RF less_RF_k_ka V)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ka \\<le> Suc k;\n     list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q)\n     < list_of (RF k p);\n     Suc n < ka - Suc 0; \\<not> n < k - Suc (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> list_of (RF (k - Suc 0) q \\<union> RF (ka - Suc 0) q)\n                      < list_of (RF (Suc (Suc n)) p)", "by (metis One_nat_def Suc_less_eq Suc_pred \\<open>0 < k\\<close> diff_Suc_1 k_minus_1 ka_k_or_Suc less_SucE)"], ["proof (state)\nthis:\n  QQ ! n < PP ! Suc n\n\ngoal (6 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. PP \\<in> lists (- {[]})\n 6. QQ \\<in> lists (- {[]})", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. PP \\<in> lists (- {[]})\n 6. QQ \\<in> lists (- {[]})", "show \"PP \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP \\<in> lists (- {[]})", "using RF_non_Nil kka"], ["proof (prove)\nusing this:\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. PP \\<in> lists (- {[]})", "by (clarsimp simp: PP_def) (metis RF_non_Nil less_le_trans)"], ["proof (state)\nthis:\n  PP \\<in> lists (- {[]})\n\ngoal (5 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y\n 5. QQ \\<in> lists (- {[]})", "show \"QQ \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QQ \\<in> lists (- {[]})", "using RF_non_Nil kka"], ["proof (prove)\nusing this:\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. QQ \\<in> lists (- {[]})", "by (clarsimp simp: QQ_def) (metis RF_non_Nil Suc_pred \\<open>0 < k\\<close> less_SucI)"], ["proof (state)\nthis:\n  QQ \\<in> lists (- {[]})\n\ngoal (4 subgoals):\n 1. length QQ \\<le> length PP\n 2. length PP \\<le> Suc (length QQ)\n 3. \\<And>x. x \\<in> list.set PP \\<Longrightarrow> strict_sorted x\n 4. \\<And>y. y \\<in> list.set QQ \\<Longrightarrow> strict_sorted y", "qed (use kka PP_def QQ_def in auto)"], ["proof (state)\nthis:\n  strict_sorted (interact PP QQ)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  strict_sorted (interact PP QQ)", "have ss_QQ: \"strict_sorted (concat QQ)\""], ["proof (prove)\nusing this:\n  strict_sorted (interact PP QQ)\n\ngoal (1 subgoal):\n 1. strict_sorted (concat QQ)", "using strict_sorted_interact_imp_concat"], ["proof (prove)\nusing this:\n  strict_sorted (interact PP QQ)\n  strict_sorted (interact ?as ?bs) \\<Longrightarrow>\n  strict_sorted (concat ?as) \\<and> strict_sorted (concat ?bs)\n\ngoal (1 subgoal):\n 1. strict_sorted (concat QQ)", "by blast"], ["proof (state)\nthis:\n  strict_sorted (concat QQ)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "obtain zs where zs: \"Form_Body ka k x y zs\" and zs_N: \"list.set zs \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (intro that exI conjI Form_Body.intros [OF \\<open>length x < length y\\<close>])"], ["proof (state)\ngoal (11 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x = concat (?a3 # ?as3)\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    y = concat (?b3 # ?bs3)\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?a3 # ?as3 \\<in> lists (- {[]})\n 4. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?b3 # ?bs3 \\<in> lists (- {[]})\n 5. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (?a3 # ?as3) = ka\n 6. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (?b3 # ?bs3) = k\n 7. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?c3 = acc_lengths 0 (?a3 # ?as3)\n 8. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (?b3 # ?bs3)\n 9. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?zs2 = concat [?c3, ?a3, ?d3, ?b3] @ interact ?as3 ?bs3\n 10. (\\<And>zs.\n         \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     strict_sorted ?zs2\nA total of 11 subgoals...", "show \"x = concat (list_of (AF k p) # PP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = concat (list_of (AF k p) # PP)", "using \\<open>ka > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < ka\n\ngoal (1 subgoal):\n 1. x = concat (list_of (AF k p) # PP)", "by (simp add: PP_def RF_0 xc sorted_list_of_set_k)"], ["proof (state)\nthis:\n  x = concat (list_of (AF k p) # PP)\n\ngoal (10 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    y = concat (?b3 # ?bs3)\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    list_of (AF k p) # PP \\<in> lists (- {[]})\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?b3 # ?bs3 \\<in> lists (- {[]})\n 4. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k p) # PP) = ka\n 5. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (?b3 # ?bs3) = k\n 6. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?c3 = acc_lengths 0 (list_of (AF k p) # PP)\n 7. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (?b3 # ?bs3)\n 8. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?zs2 = concat [?c3, list_of (AF k p), ?d3, ?b3] @ interact PP ?bs3\n 9. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_sorted ?zs2\n 10. (\\<And>zs.\n         \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     list.set ?zs2 \\<subseteq> N", "let ?YR = \"(map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))\""], ["proof (state)\ngoal (10 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    y = concat (?b3 # ?bs3)\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    list_of (AF k p) # PP \\<in> lists (- {[]})\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?b3 # ?bs3 \\<in> lists (- {[]})\n 4. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k p) # PP) = ka\n 5. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (?b3 # ?bs3) = k\n 6. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?c3 = acc_lengths 0 (list_of (AF k p) # PP)\n 7. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (?b3 # ?bs3)\n 8. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?zs2 = concat [?c3, list_of (AF k p), ?d3, ?b3] @ interact PP ?bs3\n 9. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_sorted ?zs2\n 10. (\\<And>zs.\n         \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     list.set ?zs2 \\<subseteq> N", "have \"concat ?YR = concat QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})) =\n    concat QQ", "proof (rule strict_sorted_equal [OF ss_QQ])"], ["proof (state)\ngoal (2 subgoals):\n 1. strict_sorted\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})))\n 2. list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "show \"strict_sorted (concat ?YR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})))", "proof (rule strict_sorted_concat_I, simp_all)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. list_of (RF x q)) ` {0<..<ka} \\<Longrightarrow>\n       strict_sorted x\n 2. \\<And>n.\n       Suc n < ka - Suc 0 \\<Longrightarrow>\n       list_of (RF (list_of {0<..<ka} ! n) q)\n       < list_of (RF (list_of {0<..<ka} ! Suc n) q)\n 3. map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})\n    \\<in> lists (- {[]})", "fix n"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. list_of (RF x q)) ` {0<..<ka} \\<Longrightarrow>\n       strict_sorted x\n 2. \\<And>n.\n       Suc n < ka - Suc 0 \\<Longrightarrow>\n       list_of (RF (list_of {0<..<ka} ! n) q)\n       < list_of (RF (list_of {0<..<ka} ! Suc n) q)\n 3. map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})\n    \\<in> lists (- {[]})", "assume \"Suc n < ka - Suc 0\""], ["proof (state)\nthis:\n  Suc n < ka - Suc 0\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. list_of (RF x q)) ` {0<..<ka} \\<Longrightarrow>\n       strict_sorted x\n 2. \\<And>n.\n       Suc n < ka - Suc 0 \\<Longrightarrow>\n       list_of (RF (list_of {0<..<ka} ! n) q)\n       < list_of (RF (list_of {0<..<ka} ! Suc n) q)\n 3. map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})\n    \\<in> lists (- {[]})", "then"], ["proof (chain)\npicking this:\n  Suc n < ka - Suc 0", "show \"list_of (RF (list_of {0<..<ka} ! n) q) < list_of (RF (list_of {0<..<ka} ! Suc n) q)\""], ["proof (prove)\nusing this:\n  Suc n < ka - Suc 0\n\ngoal (1 subgoal):\n 1. list_of (RF (list_of {0<..<ka} ! n) q)\n    < list_of (RF (list_of {0<..<ka} ! Suc n) q)", "by (metis less_RF_Suc Suc_lessD \\<open>ka - Suc 0 \\<le> k\\<close> add.left_neutral finite_RF less_le_trans less_sets_imp_sorted_list_of_set nth_sorted_list_of_set_greaterThanLessThan)"], ["proof (state)\nthis:\n  list_of (RF (list_of {0<..<ka} ! n) q)\n  < list_of (RF (list_of {0<..<ka} ! Suc n) q)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. list_of (RF x q)) ` {0<..<ka} \\<Longrightarrow>\n       strict_sorted x\n 2. map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})\n    \\<in> lists (- {[]})", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. list_of (RF x q)) ` {0<..<ka} \\<Longrightarrow>\n       strict_sorted x\n 2. map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})\n    \\<in> lists (- {[]})", "show \"?YR \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})\n    \\<in> lists (- {[]})", "using RF_non_Nil \\<open>ka \\<le> Suc k\\<close>"], ["proof (prove)\nusing this:\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n  ka \\<le> Suc k\n\ngoal (1 subgoal):\n 1. map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})\n    \\<in> lists (- {[]})", "by (auto simp: mem_lists_non_Nil)"], ["proof (state)\nthis:\n  map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})\n  \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. list_of (RF x q)) ` {0<..<ka} \\<Longrightarrow>\n       strict_sorted x", "qed auto"], ["proof (state)\nthis:\n  strict_sorted\n   (concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})))\n\ngoal (1 subgoal):\n 1. list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "show \"list.set (concat ?YR) = list.set (concat QQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "using ka_k_or_Suc"], ["proof (prove)\nusing this:\n  ka = k \\<or> ka = Suc k\n\ngoal (1 subgoal):\n 1. list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ka = k \\<Longrightarrow>\n    list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)\n 2. ka = Suc k \\<Longrightarrow>\n    list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "assume \"ka = k\""], ["proof (state)\nthis:\n  ka = k\n\ngoal (2 subgoals):\n 1. ka = k \\<Longrightarrow>\n    list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)\n 2. ka = Suc k \\<Longrightarrow>\n    list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "then"], ["proof (chain)\npicking this:\n  ka = k", "show \"list.set (concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) = list.set (concat QQ)\""], ["proof (prove)\nusing this:\n  ka = k\n\ngoal (1 subgoal):\n 1. list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "using \\<open>k\\<ge>2\\<close>"], ["proof (prove)\nusing this:\n  ka = k\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "by simp (simp add: split_nat_interval QQ_def)"], ["proof (state)\nthis:\n  list.set\n   (concat\n     (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n  list.set (concat QQ)\n\ngoal (1 subgoal):\n 1. ka = Suc k \\<Longrightarrow>\n    list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ka = Suc k \\<Longrightarrow>\n    list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "assume \"ka = Suc k\""], ["proof (state)\nthis:\n  ka = Suc k\n\ngoal (1 subgoal):\n 1. ka = Suc k \\<Longrightarrow>\n    list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "then"], ["proof (chain)\npicking this:\n  ka = Suc k", "show \"list.set (concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) = list.set (concat QQ)\""], ["proof (prove)\nusing this:\n  ka = Suc k\n\ngoal (1 subgoal):\n 1. list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "using \\<open>k\\<ge>2\\<close>"], ["proof (prove)\nusing this:\n  ka = Suc k\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. list.set\n     (concat\n       (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n    list.set (concat QQ)", "by simp (auto simp: QQ_def split_nat_interval)"], ["proof (state)\nthis:\n  list.set\n   (concat\n     (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n  list.set (concat QQ)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list.set\n   (concat\n     (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka}))) =\n  list.set (concat QQ)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})) =\n  concat QQ\n\ngoal (10 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    y = concat (?b3 # ?bs3)\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    list_of (AF k p) # PP \\<in> lists (- {[]})\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?b3 # ?bs3 \\<in> lists (- {[]})\n 4. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k p) # PP) = ka\n 5. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (?b3 # ?bs3) = k\n 6. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?c3 = acc_lengths 0 (list_of (AF k p) # PP)\n 7. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (?b3 # ?bs3)\n 8. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?zs2 = concat [?c3, list_of (AF k p), ?d3, ?b3] @ interact PP ?bs3\n 9. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_sorted ?zs2\n 10. (\\<And>zs.\n         \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     list.set ?zs2 \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})) =\n  concat QQ", "show \"y = concat (list_of (AF k q) # QQ)\""], ["proof (prove)\nusing this:\n  concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})) =\n  concat QQ\n\ngoal (1 subgoal):\n 1. y = concat (list_of (AF k q) # QQ)", "using \\<open>ka > 0\\<close>"], ["proof (prove)\nusing this:\n  concat (map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<ka})) =\n  concat QQ\n  0 < ka\n\ngoal (1 subgoal):\n 1. y = concat (list_of (AF k q) # QQ)", "by (simp add: RF_0 yc sorted_list_of_set_k)"], ["proof (state)\nthis:\n  y = concat (list_of (AF k q) # QQ)\n\ngoal (9 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    list_of (AF k p) # PP \\<in> lists (- {[]})\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    list_of (AF k q) # QQ \\<in> lists (- {[]})\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k p) # PP) = ka\n 4. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k q) # QQ) = k\n 5. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?c3 = acc_lengths 0 (list_of (AF k p) # PP)\n 6. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (list_of (AF k q) # QQ)\n 7. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?zs2 =\n    concat [?c3, list_of (AF k p), ?d3, list_of (AF k q)] @ interact PP QQ\n 8. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_sorted ?zs2\n 9. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    list.set ?zs2 \\<subseteq> N", "show \"list_of (AF k p) # PP \\<in> lists (- {[]})\" \"list_of (AF k q) # QQ \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (AF k p) # PP \\<in> lists (- {[]}) &&&\n    list_of (AF k q) # QQ \\<in> lists (- {[]})", "using  RF_non_Nil kka"], ["proof (prove)\nusing this:\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. list_of (AF k p) # PP \\<in> lists (- {[]}) &&&\n    list_of (AF k q) # QQ \\<in> lists (- {[]})", "by (auto simp: AF_ne PP_def QQ_def eq_commute [of \"[]\"])"], ["proof (state)\nthis:\n  list_of (AF k p) # PP \\<in> lists (- {[]})\n  list_of (AF k q) # QQ \\<in> lists (- {[]})\n\ngoal (7 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k p) # PP) = ka\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k q) # QQ) = k\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?c3 = acc_lengths 0 (list_of (AF k p) # PP)\n 4. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (list_of (AF k q) # QQ)\n 5. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?zs2 =\n    concat [?c3, list_of (AF k p), ?d3, list_of (AF k q)] @ interact PP QQ\n 6. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_sorted ?zs2\n 7. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    list.set ?zs2 \\<subseteq> N", "show \"list.set ((LENS p @ list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ ?INT)) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set\n     (LENS p @\n      list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ)\n    \\<subseteq> N", "using AF_subset_N RF_subset_N LENS_subset_N \\<open>p < m\\<close> \\<open>q < m\\<close> LENS_QQ_subset"], ["proof (prove)\nusing this:\n  AF ?k ?i \\<subseteq> N\n  ?i < m \\<Longrightarrow> RF ?j ?i \\<subseteq> N\n  ?i < m \\<Longrightarrow> list.set (LENS ?i) \\<subseteq> N\n  p < m\n  q < m\n  list.set LENS_QQ \\<subseteq> list.set (LENS q)\n\ngoal (1 subgoal):\n 1. list.set\n     (LENS p @\n      list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ)\n    \\<subseteq> N", "by (auto simp: subset_iff PP_def QQ_def)"], ["proof (state)\nthis:\n  list.set\n   (LENS p @ list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ)\n  \\<subseteq> N\n\ngoal (6 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k p) # PP) = ka\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length (list_of (AF k q) # QQ) = k\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?c3 = acc_lengths 0 (list_of (AF k p) # PP)\n 4. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (list_of (AF k q) # QQ)\n 5. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    LENS p @\n    list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ =\n    concat [?c3, list_of (AF k p), ?d3, list_of (AF k q)] @ interact PP QQ\n 6. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_sorted\n     (LENS p @\n      list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ)", "show \"length (list_of (AF k p) # PP) = ka\" \"length (list_of (AF k q) # QQ) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of (AF k p) # PP) = ka &&&\n    length (list_of (AF k q) # QQ) = k", "using \\<open>0 < ka\\<close> \\<open>0 < k\\<close>"], ["proof (prove)\nusing this:\n  0 < ka\n  0 < k\n\ngoal (1 subgoal):\n 1. length (list_of (AF k p) # PP) = ka &&&\n    length (list_of (AF k q) # QQ) = k", "by auto"], ["proof (state)\nthis:\n  length (list_of (AF k p) # PP) = ka\n  length (list_of (AF k q) # QQ) = k\n\ngoal (4 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?c3 = acc_lengths 0 (list_of (AF k p) # PP)\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (list_of (AF k q) # QQ)\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    LENS p @\n    list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ =\n    concat [?c3, list_of (AF k p), ?d3, list_of (AF k q)] @ interact PP QQ\n 4. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_sorted\n     (LENS p @\n      list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ)", "show \"LENS p = acc_lengths 0 (list_of (AF k p) # PP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENS p = acc_lengths 0 (list_of (AF k p) # PP)", "by (auto simp: LENS_def PP_def)"], ["proof (state)\nthis:\n  LENS p = acc_lengths 0 (list_of (AF k p) # PP)\n\ngoal (3 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (list_of (AF k q) # QQ)\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    LENS p @\n    list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ =\n    concat [LENS p, list_of (AF k p), ?d3, list_of (AF k q)] @\n    interact PP QQ\n 3. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_sorted\n     (LENS p @\n      list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ)", "show \"strict_sorted (LENS p @ list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ ?INT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted\n     (LENS p @\n      list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ)", "unfolding strict_sorted_append_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENS p\n    < list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ \\<and>\n    strict_sorted (LENS p) \\<and>\n    list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ interact PP QQ \\<and>\n    strict_sorted (list_of (AF k p)) \\<and>\n    LENS_QQ < list_of (AF k q) @ interact PP QQ \\<and>\n    strict_sorted LENS_QQ \\<and>\n    list_of (AF k q) < interact PP QQ \\<and>\n    strict_sorted (list_of (AF k q)) \\<and> strict_sorted (interact PP QQ)", "proof (intro conjI ss_INT)"], ["proof (state)\ngoal (8 subgoals):\n 1. LENS p < list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ\n 2. strict_sorted (LENS p)\n 3. list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ interact PP QQ\n 4. strict_sorted (list_of (AF k p))\n 5. LENS_QQ < list_of (AF k q) @ interact PP QQ\n 6. strict_sorted LENS_QQ\n 7. list_of (AF k q) < interact PP QQ\n 8. strict_sorted (list_of (AF k q))", "show \"LENS p < list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ ?INT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENS p < list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ", "using AF_non_Nil [of k p] \\<open>k \\<le> ka\\<close> \\<open>ka \\<le> Suc k\\<close> \\<open>p < m\\<close> card_AF_sum enum_DF_AF"], ["proof (prove)\nusing this:\n  list_of (AF k p) \\<noteq> []\n  k \\<le> ka\n  ka \\<le> Suc k\n  p < m\n  ?i < m \\<Longrightarrow>\n  card (AF k ?i) + (\\<Sum>j\\<in>{0<..<ka}. card (RF j ?i)) =\n  enum (DF k ?i) (ka - 1)\n  enum (DF k ?p) (ka - Suc 0) < hd (list_of (AF k ?p))\n\ngoal (1 subgoal):\n 1. LENS p < list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ", "by (simp add: enum_DF_AF less_list_def card_AF_sum LENS_def sum_sorted_list_of_set_map)"], ["proof (state)\nthis:\n  LENS p < list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ\n\ngoal (7 subgoals):\n 1. strict_sorted (LENS p)\n 2. list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ interact PP QQ\n 3. strict_sorted (list_of (AF k p))\n 4. LENS_QQ < list_of (AF k q) @ interact PP QQ\n 5. strict_sorted LENS_QQ\n 6. list_of (AF k q) < interact PP QQ\n 7. strict_sorted (list_of (AF k q))", "show \"strict_sorted (LENS p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (LENS p)", "unfolding LENS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted\n     (acc_lengths 0\n       (list_of (AF k p) #\n        map (list_of \\<circ> (\\<lambda>j. RF j p)) (list_of {0<..<ka})))", "by (rule strict_sorted_acc_lengths) (use RF_non_Nil AF_non_Nil kka in \\<open>auto simp: in_lists_conv_set\\<close>)"], ["proof (state)\nthis:\n  strict_sorted (LENS p)\n\ngoal (6 subgoals):\n 1. list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ interact PP QQ\n 2. strict_sorted (list_of (AF k p))\n 3. LENS_QQ < list_of (AF k q) @ interact PP QQ\n 4. strict_sorted LENS_QQ\n 5. list_of (AF k q) < interact PP QQ\n 6. strict_sorted (list_of (AF k q))", "show \"strict_sorted LENS_QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted LENS_QQ", "unfolding LENS_QQ_def QQ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted\n     (acc_lengths 0\n       (list_of (AF k q) #\n        map (list_of \\<circ> (\\<lambda>j. RF j q)) (list_of {0<..<k - 1}) @\n        [list_of (RF (k - 1) q \\<union> RF (ka - 1) q)]))", "by (rule strict_sorted_acc_lengths) (use RF_non_Nil AF_non_Nil kka in \\<open>auto simp: in_lists_conv_set\\<close>)"], ["proof (state)\nthis:\n  strict_sorted LENS_QQ\n\ngoal (5 subgoals):\n 1. list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ interact PP QQ\n 2. strict_sorted (list_of (AF k p))\n 3. LENS_QQ < list_of (AF k q) @ interact PP QQ\n 4. list_of (AF k q) < interact PP QQ\n 5. strict_sorted (list_of (AF k q))", "have last_AF_DF: \"last (list_of (AF k p)) < \\<Sqinter> (DF k q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (list_of (AF k p)) < \\<Sqinter> (DF k q)", "using AF_DF [OF \\<open>p < q\\<close>, of k] AF_non_Nil [of k p] DF_ne [of k q]"], ["proof (prove)\nusing this:\n  AF k p \\<lless> DF k q\n  list_of (AF k p) \\<noteq> []\n  DF k q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. last (list_of (AF k p)) < \\<Sqinter> (DF k q)", "by (metis Inf_nat_def1 finite_AF last_in_set less_sets_def set_sorted_list_of_set)"], ["proof (state)\nthis:\n  last (list_of (AF k p)) < \\<Sqinter> (DF k q)\n\ngoal (5 subgoals):\n 1. list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ interact PP QQ\n 2. strict_sorted (list_of (AF k p))\n 3. LENS_QQ < list_of (AF k q) @ interact PP QQ\n 4. list_of (AF k q) < interact PP QQ\n 5. strict_sorted (list_of (AF k q))", "then"], ["proof (chain)\npicking this:\n  last (list_of (AF k p)) < \\<Sqinter> (DF k q)", "show \"list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ ?INT\""], ["proof (prove)\nusing this:\n  last (list_of (AF k p)) < \\<Sqinter> (DF k q)\n\ngoal (1 subgoal):\n 1. list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ interact PP QQ", "by (simp add: less_list_def card_AF LENS_QQ_def)"], ["proof (state)\nthis:\n  list_of (AF k p) < LENS_QQ @ list_of (AF k q) @ interact PP QQ\n\ngoal (4 subgoals):\n 1. strict_sorted (list_of (AF k p))\n 2. LENS_QQ < list_of (AF k q) @ interact PP QQ\n 3. list_of (AF k q) < interact PP QQ\n 4. strict_sorted (list_of (AF k q))", "show \"LENS_QQ < list_of (AF k q) @ ?INT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENS_QQ < list_of (AF k q) @ interact PP QQ", "using AF_non_Nil [of k q] \\<open>q < m\\<close> card_AF_sum enum_DF_AF card_AF_sum_QQ"], ["proof (prove)\nusing this:\n  list_of (AF k q) \\<noteq> []\n  q < m\n  ?i < m \\<Longrightarrow>\n  card (AF k ?i) + (\\<Sum>j\\<in>{0<..<ka}. card (RF j ?i)) =\n  enum (DF k ?i) (ka - 1)\n  enum (DF k ?p) (ka - Suc 0) < hd (list_of (AF k ?p))\n  card (AF k q) + sum_list (map length QQ) = (\\<Sum>j<ka. card (RF j q))\n\ngoal (1 subgoal):\n 1. LENS_QQ < list_of (AF k q) @ interact PP QQ", "by (auto simp: less_list_def AF_ne hd_append card_AF_sum LENS_QQ_def)"], ["proof (state)\nthis:\n  LENS_QQ < list_of (AF k q) @ interact PP QQ\n\ngoal (3 subgoals):\n 1. strict_sorted (list_of (AF k p))\n 2. list_of (AF k q) < interact PP QQ\n 3. strict_sorted (list_of (AF k q))", "show \"list_of (AF k q) < ?INT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (AF k q) < interact PP QQ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of (AF k q) < interact PP QQ", "have \"AF k q \\<lless> RF (Suc 0) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AF k q \\<lless> RF (Suc 0) p", "using \\<open>0 < k\\<close> \\<open>p < m\\<close> \\<open>q < m\\<close>"], ["proof (prove)\nusing this:\n  0 < k\n  p < m\n  q < m\n\ngoal (1 subgoal):\n 1. AF k q \\<lless> RF (Suc 0) p", "by (simp add: RF_def less_QF flip: QF_0)"], ["proof (state)\nthis:\n  AF k q \\<lless> RF (Suc 0) p\n\ngoal (1 subgoal):\n 1. list_of (AF k q) < interact PP QQ", "then"], ["proof (chain)\npicking this:\n  AF k q \\<lless> RF (Suc 0) p", "have \"last (list_of (AF k q)) < hd (list_of (RF (Suc 0) p))\""], ["proof (prove)\nusing this:\n  AF k q \\<lless> RF (Suc 0) p\n\ngoal (1 subgoal):\n 1. last (list_of (AF k q)) < hd (list_of (RF (Suc 0) p))", "proof (rule less_setsD)"], ["proof (state)\ngoal (2 subgoals):\n 1. last (list_of (AF k q)) \\<in> AF k q\n 2. hd (list_of (RF (Suc 0) p)) \\<in> RF (Suc 0) p", "show \"last (list_of (AF k q)) \\<in> AF k q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (list_of (AF k q)) \\<in> AF k q", "using AF_non_Nil finite_AF last_in_set set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  list_of (AF ?k ?i) \\<noteq> []\n  finite (AF ?k ?i)\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> list.set ?as\n  finite ?A \\<Longrightarrow> list.set (list_of ?A) = ?A\n\ngoal (1 subgoal):\n 1. last (list_of (AF k q)) \\<in> AF k q", "by blast"], ["proof (state)\nthis:\n  last (list_of (AF k q)) \\<in> AF k q\n\ngoal (1 subgoal):\n 1. hd (list_of (RF (Suc 0) p)) \\<in> RF (Suc 0) p", "show \"hd (list_of (RF (Suc 0) p)) \\<in> RF (Suc 0) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (list_of (RF (Suc 0) p)) \\<in> RF (Suc 0) p", "by (metis RF_non_Nil Suc_mono \\<open>0 < k\\<close> finite_RF hd_in_set set_sorted_list_of_set)"], ["proof (state)\nthis:\n  hd (list_of (RF (Suc 0) p)) \\<in> RF (Suc 0) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (list_of (AF k q)) < hd (list_of (RF (Suc 0) p))\n\ngoal (1 subgoal):\n 1. list_of (AF k q) < interact PP QQ", "with \\<open>k > 0\\<close> \\<open>ka \\<ge> 2\\<close> RF_non_Nil"], ["proof (chain)\npicking this:\n  0 < k\n  2 \\<le> ka\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n  last (list_of (AF k q)) < hd (list_of (RF (Suc 0) p))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < k\n  2 \\<le> ka\n  ?j < Suc k \\<Longrightarrow> list_of (RF ?j ?i) \\<noteq> []\n  last (list_of (AF k q)) < hd (list_of (RF (Suc 0) p))\n\ngoal (1 subgoal):\n 1. list_of (AF k q) < interact PP QQ", "by (simp add: hd_interact less_list_def sorted_list_of_set_greaterThanLessThan PP_def QQ_def)"], ["proof (state)\nthis:\n  list_of (AF k q) < interact PP QQ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_of (AF k q) < interact PP QQ\n\ngoal (2 subgoals):\n 1. strict_sorted (list_of (AF k p))\n 2. strict_sorted (list_of (AF k q))", "qed auto"], ["proof (state)\nthis:\n  strict_sorted\n   (LENS p @ list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ)\n\ngoal (2 subgoals):\n 1. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?d3 = acc_lengths 0 (list_of (AF k q) # QQ)\n 2. (\\<And>zs.\n        \\<lbrakk>Form_Body ka k x y zs; list.set zs \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    LENS p @\n    list_of (AF k p) @ LENS_QQ @ list_of (AF k q) @ interact PP QQ =\n    concat [LENS p, list_of (AF k p), ?d3, list_of (AF k q)] @\n    interact PP QQ", "qed (auto simp: LENS_QQ_def)"], ["proof (state)\nthis:\n  Form_Body ka k x y zs\n  list.set zs \\<subseteq> N\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "proof (cases \"ka = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ka = k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. ka \\<noteq> k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "case True"], ["proof (state)\nthis:\n  ka = k\n\ngoal (2 subgoals):\n 1. ka = k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. ka \\<noteq> k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  ka = k", "have \"l = 2*k - 1\""], ["proof (prove)\nusing this:\n  ka = k\n\ngoal (1 subgoal):\n 1. l = 2 * k - 1", "by (simp add: kka(3) mult_2)"], ["proof (state)\nthis:\n  l = 2 * k - 1\n\ngoal (2 subgoals):\n 1. ka = k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n 2. ka \\<noteq> k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  l = 2 * k - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  l = 2 * k - 1\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "by (metis Form.intros(2) Form_Body_imp_inter_scheme True \\<open>0 < k\\<close> \\<open>U = {x, y}\\<close> kka zs zs_N)"], ["proof (state)\nthis:\n  Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. ka \\<noteq> k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ka \\<noteq> k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "case False"], ["proof (state)\nthis:\n  ka \\<noteq> k\n\ngoal (1 subgoal):\n 1. ka \\<noteq> k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  ka \\<noteq> k", "have \"l = 2*k\""], ["proof (prove)\nusing this:\n  ka \\<noteq> k\n\ngoal (1 subgoal):\n 1. l = 2 * k", "using kka"], ["proof (prove)\nusing this:\n  ka \\<noteq> k\n  k \\<le> ka\n  ka \\<le> Suc k\n  l = ka + k - Suc 0\n\ngoal (1 subgoal):\n 1. l = 2 * k", "by linarith"], ["proof (state)\nthis:\n  l = 2 * k\n\ngoal (1 subgoal):\n 1. ka \\<noteq> k \\<Longrightarrow>\n    Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "then"], ["proof (chain)\npicking this:\n  l = 2 * k", "show ?thesis"], ["proof (prove)\nusing this:\n  l = 2 * k\n\ngoal (1 subgoal):\n 1. Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N", "by (metis False Form.intros(3) Form_Body_imp_inter_scheme \\<open>0 < k\\<close> \\<open>U = {x, y}\\<close> antisym kka le_SucE zs zs_N)"], ["proof (state)\nthis:\n  Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Form l U \\<and> list.set (inter_scheme l U) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n  Form l ?U \\<and> list.set (inter_scheme l ?U) \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Larson's Lemma 3.8\\<close>"], ["", "subsubsection \\<open>Primitives needed for the inductive construction of @{term b}\\<close>"], ["", "definition IJ where \"IJ \\<equiv> \\<lambda>k. Sigma {..k} (\\<lambda>j::nat. {..<j})\""], ["", "lemma IJ_iff: \"u \\<in> IJ k \\<longleftrightarrow> (\\<exists>j i. u = (j,i) \\<and> i<j \\<and> j\\<le>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> IJ k) =\n    (\\<exists>j i. u = (j, i) \\<and> i < j \\<and> j \\<le> k)", "by (auto simp: IJ_def)"], ["", "lemma finite_IJ: \"finite (IJ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (IJ k)", "by (auto simp: IJ_def)"], ["", "fun prev where\n  \"prev 0 0 = None\"\n| \"prev (Suc 0) 0 = None\"\n| \"prev (Suc j) 0 = Some (j, j - Suc 0)\"\n| \"prev j (Suc i) = Some (j,i)\""], ["", "lemma prev_eq_None_iff: \"prev j i = None \\<longleftrightarrow> j \\<le> Suc 0 \\<and> i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prev j i = None) = (j \\<le> Suc 0 \\<and> i = 0)", "by (auto simp: le_Suc_eq elim: prev.elims)"], ["", "lemma prev_pair_less:\n  \"prev j i = Some ji' \\<Longrightarrow> (ji', (j,i)) \\<in> pair_less\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prev j i = Some ji' \\<Longrightarrow> (ji', j, i) \\<in> pair_less", "by (auto simp: pair_lessI1 elim: prev.elims)"], ["", "lemma prev_Some_less: \"\\<lbrakk>prev j i = Some (j',i'); i \\<le> j\\<rbrakk> \\<Longrightarrow> i' < j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prev j i = Some (j', i'); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> i' < j'", "by (auto elim: prev.elims)"], ["", "lemma prev_maximal:\n  \"\\<lbrakk>prev j i = Some (j',i'); (ji'', (j,i)) \\<in> pair_less; ji'' \\<in> IJ k\\<rbrakk>\n   \\<Longrightarrow> (ji'', (j',i')) \\<in> pair_less \\<or> ji'' = (j',i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prev j i = Some (j', i'); (ji'', j, i) \\<in> pair_less;\n     ji'' \\<in> IJ k\\<rbrakk>\n    \\<Longrightarrow> (ji'', j', i') \\<in> pair_less \\<or> ji'' = (j', i')", "by (force simp: IJ_def pair_less_def elim: prev.elims)"], ["", "lemma pair_less_prev:\n  assumes \"(u, (j,i)) \\<in> pair_less\" \"u \\<in> IJ k\"\n  shows \"prev j i = Some u \\<or> (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prev j i = Some u \\<or>\n    (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "proof (cases \"prev j i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. prev j i = None \\<Longrightarrow>\n    prev j i = Some u \\<or>\n    (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)\n 2. \\<And>a.\n       prev j i = Some a \\<Longrightarrow>\n       prev j i = Some u \\<or>\n       (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "case None"], ["proof (state)\nthis:\n  prev j i = None\n\ngoal (2 subgoals):\n 1. prev j i = None \\<Longrightarrow>\n    prev j i = Some u \\<or>\n    (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)\n 2. \\<And>a.\n       prev j i = Some a \\<Longrightarrow>\n       prev j i = Some u \\<or>\n       (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prev j i = Some u \\<or>\n    (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "proof (cases u)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       u = (a, b) \\<Longrightarrow>\n       prev j i = Some u \\<or>\n       (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "case (Pair j' i')"], ["proof (state)\nthis:\n  u = (j', i')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       u = (a, b) \\<Longrightarrow>\n       prev j i = Some u \\<or>\n       (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "then"], ["proof (chain)\npicking this:\n  u = (j', i')", "show ?thesis"], ["proof (prove)\nusing this:\n  u = (j', i')\n\ngoal (1 subgoal):\n 1. prev j i = Some u \\<or>\n    (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "using assms None"], ["proof (prove)\nusing this:\n  u = (j', i')\n  (u, j, i) \\<in> pair_less\n  u \\<in> IJ k\n  prev j i = None\n\ngoal (1 subgoal):\n 1. prev j i = Some u \\<or>\n    (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "by (simp add: prev_eq_None_iff pair_less_def IJ_def)"], ["proof (state)\nthis:\n  prev j i = Some u \\<or>\n  (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prev j i = Some u \\<or>\n  (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       prev j i = Some a \\<Longrightarrow>\n       prev j i = Some u \\<or>\n       (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       prev j i = Some a \\<Longrightarrow>\n       prev j i = Some u \\<or>\n       (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "case (Some a)"], ["proof (state)\nthis:\n  prev j i = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       prev j i = Some a \\<Longrightarrow>\n       prev j i = Some u \\<or>\n       (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "then"], ["proof (chain)\npicking this:\n  prev j i = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  prev j i = Some a\n\ngoal (1 subgoal):\n 1. prev j i = Some u \\<or>\n    (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)", "by (metis assms prev_maximal prod.exhaust_sel)"], ["proof (state)\nthis:\n  prev j i = Some u \\<or>\n  (\\<exists>x. (u, x) \\<in> pair_less \\<and> prev j i = Some x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Special primitives for the ordertype proof\\<close>"], ["", "definition USigma :: \"'a set set \\<Rightarrow> ('a set \\<Rightarrow> 'a set) \\<Rightarrow> 'a set set\"\n  where \"USigma \\<A> B \\<equiv> \\<Union>X\\<in>\\<A>. \\<Union>y\\<in>B X. {insert y X}\""], ["", "definition usplit\n  where \"usplit f A \\<equiv> f (A - {Max A}) (Max A)\""], ["", "lemma USigma_empty [simp]: \"USigma {} B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. USigma {} B = {}", "by (auto simp: USigma_def)"], ["", "lemma USigma_iff:\n  assumes \"\\<And>I j. I \\<in> \\<I> \\<Longrightarrow> I \\<lless> J I \\<and> finite I\"\n  shows \"x \\<in> USigma \\<I> J \\<longleftrightarrow> usplit (\\<lambda>I j. I\\<in>\\<I> \\<and> j\\<in>J I \\<and> x = insert j I) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "have [simp]: \"\\<And>I j. \\<lbrakk>I \\<in> \\<I>; j \\<in> J I\\<rbrakk> \\<Longrightarrow> Max (insert j I) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I j.\n       \\<lbrakk>I \\<in> \\<I>; j \\<in> J I\\<rbrakk>\n       \\<Longrightarrow> Max (insert j I) = j", "by (meson Max_insert2 assms less_imp_le less_sets_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> Max (insert ?j ?I) = ?j\n\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "have \"I - {j} \\<in> \\<I>\" if \"I \\<in> \\<I>\" \"j \\<in> J I\" for I j"], ["proof (prove)\ngoal (1 subgoal):\n 1. I - {j} \\<in> \\<I>", "using that"], ["proof (prove)\nusing this:\n  I \\<in> \\<I>\n  j \\<in> J I\n\ngoal (1 subgoal):\n 1. I - {j} \\<in> \\<I>", "by (metis Diff_empty Diff_insert0 assms less_irrefl less_sets_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> ?I - {?j} \\<in> \\<I>\n\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> ?I - {?j} \\<in> \\<I>\n\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "have \"j \\<in> J (I - {j})\" if \"I \\<in> \\<I>\" \"j \\<in> J I\" for I j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> J (I - {j})", "using that"], ["proof (prove)\nusing this:\n  I \\<in> \\<I>\n  j \\<in> J I\n\ngoal (1 subgoal):\n 1. j \\<in> J (I - {j})", "by (metis Diff_empty Diff_insert0 assms less_irrefl less_setsD)"], ["proof (state)\nthis:\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> ?j \\<in> J (?I - {?j})\n\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> ?j \\<in> J (?I - {?j})\n\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "have \"\\<exists>I\\<in>\\<I>. \\<exists>j\\<in>J I. x = insert j I\"\n      if \"x - {Max x} \\<in> \\<I>\" and \"Max x \\<in> J (x - {Max x})\" \"x \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>I\\<in>\\<I>. \\<exists>j\\<in>J I. x = insert j I", "using that"], ["proof (prove)\nusing this:\n  x - {Max x} \\<in> \\<I>\n  Max x \\<in> J (x - {Max x})\n  x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>I\\<in>\\<I>. \\<exists>j\\<in>J I. x = insert j I", "by (metis Max_in assms infinite_remove insert_Diff)"], ["proof (state)\nthis:\n  \\<lbrakk>x - {Max x} \\<in> \\<I>; Max x \\<in> J (x - {Max x});\n   x \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>I\\<in>\\<I>. \\<exists>j\\<in>J I. x = insert j I\n\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> ?I - {?j} \\<in> \\<I>\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> ?j \\<in> J (?I - {?j})\n  \\<lbrakk>x - {Max x} \\<in> \\<I>; Max x \\<in> J (x - {Max x});\n   x \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>I\\<in>\\<I>. \\<exists>j\\<in>J I. x = insert j I", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> ?I - {?j} \\<in> \\<I>\n  \\<lbrakk>?I \\<in> \\<I>; ?j \\<in> J ?I\\<rbrakk>\n  \\<Longrightarrow> ?j \\<in> J (?I - {?j})\n  \\<lbrakk>x - {Max x} \\<in> \\<I>; Max x \\<in> J (x - {Max x});\n   x \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>I\\<in>\\<I>. \\<exists>j\\<in>J I. x = insert j I\n\ngoal (1 subgoal):\n 1. (x \\<in> USigma \\<I> J) =\n    usplit\n     (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x", "by (auto simp: USigma_def usplit_def)"], ["proof (state)\nthis:\n  (x \\<in> USigma \\<I> J) =\n  usplit\n   (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> USigma \\<I> J) =\n  usplit\n   (\\<lambda>I j. I \\<in> \\<I> \\<and> j \\<in> J I \\<and> x = insert j I) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_append_image_IJ:\n  assumes lenB [simp]: \"\\<And>i j. i \\<in> \\<I> \\<Longrightarrow> j \\<in> J i \\<Longrightarrow> length (B j) = c\"\n    and AB: \"\\<And>i j. i \\<in> \\<I> \\<Longrightarrow> j \\<in> J i \\<Longrightarrow> A i < B j\"\n    and IJ: \"\\<And>i. i \\<in> \\<I> \\<Longrightarrow> i \\<lless> J i \\<and> finite i\"\n    and \\<beta>: \"\\<And>i. i \\<in> \\<I> \\<Longrightarrow> ordertype (B ` J i) (lenlex less_than) = \\<beta>\"\n    and A: \"inj_on A \\<I>\"\n  shows \"ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J) (lenlex less_than)\n       = \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)\"\n    (is \"ordertype ?AB ?R = _ * ?\\<alpha>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)", "proof (cases \"\\<I> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<I> = {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)\n 2. \\<I> \\<noteq> {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<I> = {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)\n 2. \\<I> \\<noteq> {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)", "case False"], ["proof (state)\nthis:\n  \\<I> \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<I> = {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)\n 2. \\<I> \\<noteq> {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)", "have \"Ord \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<beta>", "using \\<beta> False wf_Ord_ordertype"], ["proof (prove)\nusing this:\n  ?i \\<in> \\<I> \\<Longrightarrow>\n  ordertype (B ` J ?i) (lenlex less_than) = \\<beta>\n  \\<I> \\<noteq> {}\n  \\<lbrakk>wf ?r; trans ?r\\<rbrakk> \\<Longrightarrow> Ord (ordertype ?A ?r)\n\ngoal (1 subgoal):\n 1. Ord \\<beta>", "by fastforce"], ["proof (state)\nthis:\n  Ord \\<beta>\n\ngoal (2 subgoals):\n 1. \\<I> = {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)\n 2. \\<I> \\<noteq> {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)", "proof (subst ordertype_eq_iff)"], ["proof (state)\ngoal (6 subgoals):\n 1. Ord (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n 2. wf (lenlex less_than)\n 3. small (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n 4. total_on (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than)\n 5. trans (lenlex less_than)\n 6. \\<exists>f.\n       bij_betw f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n        (elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n       (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n           \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n              (f x < f y) = ((x, y) \\<in> lenlex less_than))", "define split where \"split \\<equiv> \\<lambda>l::nat list. (take (length l - c) l, (drop (length l - c) l))\""], ["proof (state)\nthis:\n  split \\<equiv> \\<lambda>l. (take (length l - c) l, drop (length l - c) l)\n\ngoal (6 subgoals):\n 1. Ord (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n 2. wf (lenlex less_than)\n 3. small (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n 4. total_on (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than)\n 5. trans (lenlex less_than)\n 6. \\<exists>f.\n       bij_betw f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n        (elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n       (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n           \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n              (f x < f y) = ((x, y) \\<in> lenlex less_than))", "have oB: \"ordermap (B ` J i) ?R (B j) \\<sqsubset> \\<beta>\" if \\<open>i \\<in> \\<I>\\<close> \\<open>j \\<in> J i\\<close> for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (B ` J i) (lenlex less_than) (B j) \\<sqsubset> \\<beta>", "using \\<beta> less_TC_iff that"], ["proof (prove)\nusing this:\n  ?i \\<in> \\<I> \\<Longrightarrow>\n  ordertype (B ` J ?i) (lenlex less_than) = \\<beta>\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  i \\<in> \\<I>\n  j \\<in> J i\n\ngoal (1 subgoal):\n 1. ordermap (B ` J i) (lenlex less_than) (B j) \\<sqsubset> \\<beta>", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<in> \\<I>; ?j \\<in> J ?i\\<rbrakk>\n  \\<Longrightarrow> ordermap (B ` J ?i) (lenlex less_than)\n                     (B ?j) \\<sqsubset>\n                    \\<beta>\n\ngoal (6 subgoals):\n 1. Ord (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n 2. wf (lenlex less_than)\n 3. small (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n 4. total_on (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than)\n 5. trans (lenlex less_than)\n 6. \\<exists>f.\n       bij_betw f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n        (elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n       (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n           \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n              (f x < f y) = ((x, y) \\<in> lenlex less_than))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i \\<in> \\<I>; ?j \\<in> J ?i\\<rbrakk>\n  \\<Longrightarrow> ordermap (B ` J ?i) (lenlex less_than)\n                     (B ?j) \\<sqsubset>\n                    \\<beta>", "show \"Ord (\\<beta> * ?\\<alpha>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> \\<I>; ?j \\<in> J ?i\\<rbrakk>\n  \\<Longrightarrow> ordermap (B ` J ?i) (lenlex less_than)\n                     (B ?j) \\<sqsubset>\n                    \\<beta>\n\ngoal (1 subgoal):\n 1. Ord (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))", "by (intro \\<open>Ord \\<beta>\\<close> wf_Ord_ordertype Ord_mult; simp)"], ["proof (state)\nthis:\n  Ord (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. small (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n 3. total_on (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than)\n 4. trans (lenlex less_than)\n 5. \\<exists>f.\n       bij_betw f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n        (elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n       (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n           \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n              (f x < f y) = ((x, y) \\<in> lenlex less_than))", "define f where \"f \\<equiv> \\<lambda>u. let (x,y) = split u in let i = inv_into \\<I> A x in\n                        \\<beta> * ordermap (A`\\<I>) ?R x + ordermap (B`J i) ?R y\""], ["proof (state)\nthis:\n  f \\<equiv>\n  \\<lambda>u.\n     let (x, y) = split u; i = inv_into \\<I> A x\n     in \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) x +\n        ordermap (B ` J i) (lenlex less_than) y\n\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. small (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n 3. total_on (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than)\n 4. trans (lenlex less_than)\n 5. \\<exists>f.\n       bij_betw f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n        (elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n       (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n           \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n              (f x < f y) = ((x, y) \\<in> lenlex less_than))", "have inv_into_IA [simp]: \"inv_into \\<I> A (A i) = i\" if \"i \\<in> \\<I>\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into \\<I> A (A i) = i", "by (simp add: A that)"], ["proof (state)\nthis:\n  ?i \\<in> \\<I> \\<Longrightarrow> inv_into \\<I> A (A ?i) = ?i\n\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. small (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n 3. total_on (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than)\n 4. trans (lenlex less_than)\n 5. \\<exists>f.\n       bij_betw f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n        (elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n       (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n           \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n              (f x < f y) = ((x, y) \\<in> lenlex less_than))", "show \"\\<exists>f. bij_betw f ?AB (elts (\\<beta> * ?\\<alpha>)) \\<and> (\\<forall>x\\<in>?AB. \\<forall>y\\<in>?AB. (f x < f y) = ((x, y) \\<in> ?R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n        (elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n       (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n           \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n              (f x < f y) = ((x, y) \\<in> lenlex less_than))", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (inj_on f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J) \\<and>\n        f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J =\n        elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n       (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n           \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n              (f x < f y) = ((x, y) \\<in> lenlex less_than))", "proof (intro exI conjI strip)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on ?f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n 2. ?f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J =\n    elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (?f x < ?f y) = ((x, y) \\<in> lenlex less_than)", "show \"inj_on f ?AB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)", "proof (clarsimp simp: f_def inj_on_def split_def USigma_iff IJ usplit_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n                ordermap (B ` J (x - {Max x})) (lenlex less_than)\n                 (B (Max x)) =\n                \\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n                ordermap (B ` J (y - {Max y})) (lenlex less_than)\n                 (B (Max y));\n        x - {Max x} \\<in> \\<I>; y - {Max y} \\<in> \\<I>;\n        Max x \\<in> J (x - {Max x}); x = insert (Max x) x;\n        Max y \\<in> J (y - {Max y}); y = insert (Max y) y\\<rbrakk>\n       \\<Longrightarrow> A (x - {Max x}) = A (y - {Max y}) \\<and>\n                         B (Max x) = B (Max y)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n                ordermap (B ` J (x - {Max x})) (lenlex less_than)\n                 (B (Max x)) =\n                \\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n                ordermap (B ` J (y - {Max y})) (lenlex less_than)\n                 (B (Max y));\n        x - {Max x} \\<in> \\<I>; y - {Max y} \\<in> \\<I>;\n        Max x \\<in> J (x - {Max x}); x = insert (Max x) x;\n        Max y \\<in> J (y - {Max y}); y = insert (Max y) y\\<rbrakk>\n       \\<Longrightarrow> A (x - {Max x}) = A (y - {Max y}) \\<and>\n                         B (Max x) = B (Max y)", "assume \\<section>: \"\\<beta> * ordermap (A ` \\<I>) ?R (A (x - {Max x})) + ordermap (B ` J (x - {Max x})) ?R (B (Max x))\n                 = \\<beta> * ordermap (A ` \\<I>) ?R (A (y - {Max y})) + ordermap (B ` J (y - {Max y})) ?R (B (Max y))\"\n          and x: \"x - {Max x} \\<in> \\<I>\"\n          and y: \"y - {Max y} \\<in> \\<I>\"\n          and mx: \"Max x \\<in> J (x - {Max x})\"\n          and \"x = insert (Max x) x\"\n          and my: \"Max y \\<in> J (y - {Max y})\""], ["proof (state)\nthis:\n  \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x)) =\n  \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n  ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n  x - {Max x} \\<in> \\<I>\n  y - {Max y} \\<in> \\<I>\n  Max x \\<in> J (x - {Max x})\n  x = insert (Max x) x\n  Max y \\<in> J (y - {Max y})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n                ordermap (B ` J (x - {Max x})) (lenlex less_than)\n                 (B (Max x)) =\n                \\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n                ordermap (B ` J (y - {Max y})) (lenlex less_than)\n                 (B (Max y));\n        x - {Max x} \\<in> \\<I>; y - {Max y} \\<in> \\<I>;\n        Max x \\<in> J (x - {Max x}); x = insert (Max x) x;\n        Max y \\<in> J (y - {Max y}); y = insert (Max y) y\\<rbrakk>\n       \\<Longrightarrow> A (x - {Max x}) = A (y - {Max y}) \\<and>\n                         B (Max x) = B (Max y)", "have \"ordermap (A`\\<I>) ?R (A (x - {Max x})) = ordermap (A`\\<I>) ?R (A (y - {Max y}))\"\n          and B_eq: \"ordermap (B ` J (x - {Max x})) ?R (B (Max x)) = ordermap (B ` J (y - {Max y})) ?R (B (Max y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n    ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) &&&\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x)) =\n    ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "using mult_cancellation_lemma [OF \\<section>] oB mx my x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>ordermap (B ` J (x - {Max x})) (lenlex less_than)\n            (B (Max x)) \\<sqsubset>\n           \\<beta>;\n   ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y)) \\<sqsubset>\n   \\<beta>\\<rbrakk>\n  \\<Longrightarrow> ordermap (A ` \\<I>) (lenlex less_than)\n                     (A (x - {Max x})) =\n                    ordermap (A ` \\<I>) (lenlex less_than)\n                     (A (y - {Max y})) \\<and>\n                    ordermap (B ` J (x - {Max x})) (lenlex less_than)\n                     (B (Max x)) =\n                    ordermap (B ` J (y - {Max y})) (lenlex less_than)\n                     (B (Max y))\n  \\<lbrakk>?i \\<in> \\<I>; ?j \\<in> J ?i\\<rbrakk>\n  \\<Longrightarrow> ordermap (B ` J ?i) (lenlex less_than)\n                     (B ?j) \\<sqsubset>\n                    \\<beta>\n  Max x \\<in> J (x - {Max x})\n  Max y \\<in> J (y - {Max y})\n  x - {Max x} \\<in> \\<I>\n  y - {Max y} \\<in> \\<I>\n\ngoal (1 subgoal):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n    ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) &&&\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x)) =\n    ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "by blast+"], ["proof (state)\nthis:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x)) =\n  ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n                ordermap (B ` J (x - {Max x})) (lenlex less_than)\n                 (B (Max x)) =\n                \\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n                ordermap (B ` J (y - {Max y})) (lenlex less_than)\n                 (B (Max y));\n        x - {Max x} \\<in> \\<I>; y - {Max y} \\<in> \\<I>;\n        Max x \\<in> J (x - {Max x}); x = insert (Max x) x;\n        Max y \\<in> J (y - {Max y}); y = insert (Max y) y\\<rbrakk>\n       \\<Longrightarrow> A (x - {Max x}) = A (y - {Max y}) \\<and>\n                         B (Max x) = B (Max y)", "then"], ["proof (chain)\npicking this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x)) =\n  ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "have \"A (x - {Max x}) = A (y - {Max y})\""], ["proof (prove)\nusing this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x)) =\n  ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y})", "using x y"], ["proof (prove)\nusing this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x)) =\n  ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n  x - {Max x} \\<in> \\<I>\n  y - {Max y} \\<in> \\<I>\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y})", "by auto"], ["proof (state)\nthis:\n  A (x - {Max x}) = A (y - {Max y})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n                ordermap (B ` J (x - {Max x})) (lenlex less_than)\n                 (B (Max x)) =\n                \\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n                ordermap (B ` J (y - {Max y})) (lenlex less_than)\n                 (B (Max y));\n        x - {Max x} \\<in> \\<I>; y - {Max y} \\<in> \\<I>;\n        Max x \\<in> J (x - {Max x}); x = insert (Max x) x;\n        Max y \\<in> J (y - {Max y}); y = insert (Max y) y\\<rbrakk>\n       \\<Longrightarrow> A (x - {Max x}) = A (y - {Max y}) \\<and>\n                         B (Max x) = B (Max y)", "then"], ["proof (chain)\npicking this:\n  A (x - {Max x}) = A (y - {Max y})", "have \"x - {Max x} = y - {Max y}\""], ["proof (prove)\nusing this:\n  A (x - {Max x}) = A (y - {Max y})\n\ngoal (1 subgoal):\n 1. x - {Max x} = y - {Max y}", "by (metis x y inv_into_IA)"], ["proof (state)\nthis:\n  x - {Max x} = y - {Max y}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n                ordermap (B ` J (x - {Max x})) (lenlex less_than)\n                 (B (Max x)) =\n                \\<beta> *\n                ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n                ordermap (B ` J (y - {Max y})) (lenlex less_than)\n                 (B (Max y));\n        x - {Max x} \\<in> \\<I>; y - {Max y} \\<in> \\<I>;\n        Max x \\<in> J (x - {Max x}); x = insert (Max x) x;\n        Max y \\<in> J (y - {Max y}); y = insert (Max y) y\\<rbrakk>\n       \\<Longrightarrow> A (x - {Max x}) = A (y - {Max y}) \\<and>\n                         B (Max x) = B (Max y)", "then"], ["proof (chain)\npicking this:\n  x - {Max x} = y - {Max y}", "show \"A (x - {Max x}) = A (y - {Max y}) \\<and> B (Max x) = B (Max y)\""], ["proof (prove)\nusing this:\n  x - {Max x} = y - {Max y}\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y}) \\<and> B (Max x) = B (Max y)", "using B_eq mx my"], ["proof (prove)\nusing this:\n  x - {Max x} = y - {Max y}\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x)) =\n  ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n  Max x \\<in> J (x - {Max x})\n  Max y \\<in> J (y - {Max y})\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y}) \\<and> B (Max x) = B (Max y)", "by auto"], ["proof (state)\nthis:\n  A (x - {Max x}) = A (y - {Max y}) \\<and> B (Max x) = B (Max y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n\ngoal (2 subgoals):\n 1. f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J =\n    elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> lenlex less_than)", "show \"f ` ?AB = elts (\\<beta> * ?\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J =\n    elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n    \\<subseteq> elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n 2. elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n    \\<subseteq> f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J", "show \"f ` ?AB \\<subseteq> elts (\\<beta> * ?\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n    \\<subseteq> elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))", "using \\<open>Ord \\<beta>\\<close>"], ["proof (prove)\nusing this:\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n    \\<subseteq> elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))", "apply (clarsimp simp add: f_def split_def USigma_iff IJ usplit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>Ord \\<beta>; xb - {Max xb} \\<in> \\<I>;\n        Max xb \\<in> J (xb - {Max xb}); xb = insert (Max xb) xb\\<rbrakk>\n       \\<Longrightarrow> \\<beta> *\n                         ordermap (A ` \\<I>) (lenlex less_than)\n                          (A (xb - {Max xb})) +\n                         ordermap (B ` J (xb - {Max xb})) (lenlex less_than)\n                          (B (Max xb))\n                         \\<in> elts\n                                (\\<beta> *\n                                 ordertype (A ` \\<I>) (lenlex less_than))", "by (metis Ord_mem_iff_less_TC TC_small add_mult_less image_eqI oB ordermap_in_ordertype trans_llt wf_Ord_ordertype wf_llt)"], ["proof (state)\nthis:\n  f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n  \\<subseteq> elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n\ngoal (1 subgoal):\n 1. elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n    \\<subseteq> f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J", "show \"elts (\\<beta> * ?\\<alpha>) \\<subseteq> f ` ?AB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n    \\<subseteq> f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J", "proof (clarsimp simp: f_def split_def image_iff USigma_iff IJ usplit_def Bex_def elim!: elts_multE split: prod.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "fix \\<gamma> \\<delta>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "assume \\<delta>: \"\\<delta> \\<in> elts \\<beta>\" and \\<gamma>: \"\\<gamma> \\<in> elts ?\\<alpha>\""], ["proof (state)\nthis:\n  \\<delta> \\<in> elts \\<beta>\n  \\<gamma> \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "have \"\\<gamma> \\<in> ordermap (A ` \\<I>) (lenlex less_than) ` A ` \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> \\<in> ordermap (A ` \\<I>) (lenlex less_than) ` A ` \\<I>", "by (meson \\<gamma> ordermap_surj subset_iff)"], ["proof (state)\nthis:\n  \\<gamma> \\<in> ordermap (A ` \\<I>) (lenlex less_than) ` A ` \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "then"], ["proof (chain)\npicking this:\n  \\<gamma> \\<in> ordermap (A ` \\<I>) (lenlex less_than) ` A ` \\<I>", "obtain i where \"i \\<in> \\<I>\" and yv: \"\\<gamma> = ordermap (A`\\<I>) ?R (A i)\""], ["proof (prove)\nusing this:\n  \\<gamma> \\<in> ordermap (A ` \\<I>) (lenlex less_than) ` A ` \\<I>\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> \\<I>;\n         \\<gamma> = ordermap (A ` \\<I>) (lenlex less_than) (A i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<in> \\<I>\n  \\<gamma> = ordermap (A ` \\<I>) (lenlex less_than) (A i)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "have \"\\<delta> \\<in> ordermap (B ` J i) (lenlex less_than) ` B ` J i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<in> ordermap (B ` J i) (lenlex less_than) ` B ` J i", "by (metis (no_types) \\<beta> \\<delta> \\<open>i \\<in> \\<I>\\<close> in_mono ordermap_surj)"], ["proof (state)\nthis:\n  \\<delta> \\<in> ordermap (B ` J i) (lenlex less_than) ` B ` J i\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "then"], ["proof (chain)\npicking this:\n  \\<delta> \\<in> ordermap (B ` J i) (lenlex less_than) ` B ` J i", "obtain j where \"j \\<in> J i\" and xu: \"\\<delta> = ordermap (B`J i) ?R (B j)\""], ["proof (prove)\nusing this:\n  \\<delta> \\<in> ordermap (B ` J i) (lenlex less_than) ` B ` J i\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> J i;\n         \\<delta> = ordermap (B ` J i) (lenlex less_than) (B j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j \\<in> J i\n  \\<delta> = ordermap (B ` J i) (lenlex less_than) (B j)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "then"], ["proof (chain)\npicking this:\n  j \\<in> J i\n  \\<delta> = ordermap (B ` J i) (lenlex less_than) (B j)", "have mji: \"Max (insert j i) = j\""], ["proof (prove)\nusing this:\n  j \\<in> J i\n  \\<delta> = ordermap (B ` J i) (lenlex less_than) (B j)\n\ngoal (1 subgoal):\n 1. Max (insert j i) = j", "by (meson IJ Max_insert2 \\<open>i \\<in> \\<I>\\<close> less_imp_le less_sets_def)"], ["proof (state)\nthis:\n  Max (insert j i) = j\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "have [simp]: \"i - {j} = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - {j} = i", "using IJ \\<open>i \\<in> \\<I>\\<close> \\<open>j \\<in> J i\\<close> less_setsD"], ["proof (prove)\nusing this:\n  ?i \\<in> \\<I> \\<Longrightarrow> ?i \\<lless> J ?i \\<and> finite ?i\n  i \\<in> \\<I>\n  j \\<in> J i\n  \\<lbrakk>?A \\<lless> ?B; ?a \\<in> ?A; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. i - {j} = i", "by fastforce"], ["proof (state)\nthis:\n  i - {j} = i\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts \\<beta>;\n        v \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa - {Max xa} \\<in> \\<I> \\<and>\n                                Max xa \\<in> J (xa - {Max xa}) \\<and>\n                                xa = insert (Max xa) xa \\<and>\n                                x = A (xa - {Max xa}) @ B (Max xa)) \\<and>\n                            \\<beta> * v + u =\n                            \\<beta> *\n                            ordermap (A ` \\<I>) (lenlex less_than)\n                             (take (length x - c) x) +\n                            ordermap\n                             (B `\n                              J (inv_into \\<I> A (take (length x - c) x)))\n                             (lenlex less_than) (drop (length x - c) x)", "show\n            \"\\<exists>l. (\\<exists>K. K - {Max K} \\<in> \\<I> \\<and> Max K \\<in> J (K - {Max K}) \\<and>\n                          K = insert (Max K) K \\<and>\n                          l = A (K - {Max K}) @ B (Max K)) \\<and> \\<beta> * \\<gamma> + \\<delta> =\n                    \\<beta> *\n                    ordermap (A ` \\<I>) ?R (take (length l - c) l) +\n                    ordermap (B ` J (inv_into \\<I> A (take (length l - c) l)))\n                     ?R (drop (length l - c) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       (\\<exists>K.\n           K - {Max K} \\<in> \\<I> \\<and>\n           Max K \\<in> J (K - {Max K}) \\<and>\n           K = insert (Max K) K \\<and>\n           l = A (K - {Max K}) @ B (Max K)) \\<and>\n       \\<beta> * \\<gamma> + \\<delta> =\n       \\<beta> *\n       ordermap (A ` \\<I>) (lenlex less_than) (take (length l - c) l) +\n       ordermap (B ` J (inv_into \\<I> A (take (length l - c) l)))\n        (lenlex less_than) (drop (length l - c) l)", "proof (intro conjI exI)"], ["proof (state)\ngoal (5 subgoals):\n 1. ?K2 - {Max ?K2} \\<in> \\<I>\n 2. Max ?K2 \\<in> J (?K2 - {Max ?K2})\n 3. ?K2 = insert (Max ?K2) ?K2\n 4. ?l = A (?K2 - {Max ?K2}) @ B (Max ?K2)\n 5. \\<beta> * \\<gamma> + \\<delta> =\n    \\<beta> *\n    ordermap (A ` \\<I>) (lenlex less_than) (take (length ?l - c) ?l) +\n    ordermap (B ` J (inv_into \\<I> A (take (length ?l - c) ?l)))\n     (lenlex less_than) (drop (length ?l - c) ?l)", "let ?ji = \"insert j i\""], ["proof (state)\ngoal (5 subgoals):\n 1. ?K2 - {Max ?K2} \\<in> \\<I>\n 2. Max ?K2 \\<in> J (?K2 - {Max ?K2})\n 3. ?K2 = insert (Max ?K2) ?K2\n 4. ?l = A (?K2 - {Max ?K2}) @ B (Max ?K2)\n 5. \\<beta> * \\<gamma> + \\<delta> =\n    \\<beta> *\n    ordermap (A ` \\<I>) (lenlex less_than) (take (length ?l - c) ?l) +\n    ordermap (B ` J (inv_into \\<I> A (take (length ?l - c) ?l)))\n     (lenlex less_than) (drop (length ?l - c) ?l)", "show \"A i @ B j = A (?ji - {Max ?ji}) @ B (Max ?ji)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A i @ B j = A (insert j i - {Max (insert j i)}) @ B (Max (insert j i))", "by (auto simp: mji)"], ["proof (state)\nthis:\n  A i @ B j = A (insert j i - {Max (insert j i)}) @ B (Max (insert j i))\n\ngoal (4 subgoals):\n 1. insert j i - {Max (insert j i)} \\<in> \\<I>\n 2. Max (insert j i) \\<in> J (insert j i - {Max (insert j i)})\n 3. insert j i = insert (Max (insert j i)) (insert j i)\n 4. \\<beta> * \\<gamma> + \\<delta> =\n    \\<beta> *\n    ordermap (A ` \\<I>) (lenlex less_than)\n     (take (length (A i @ B j) - c) (A i @ B j)) +\n    ordermap\n     (B ` J (inv_into \\<I> A (take (length (A i @ B j) - c) (A i @ B j))))\n     (lenlex less_than) (drop (length (A i @ B j) - c) (A i @ B j))", "qed (use \\<open>i \\<in> \\<I>\\<close> \\<open>j \\<in> J i\\<close> mji xu yv in auto)"], ["proof (state)\nthis:\n  \\<exists>l.\n     (\\<exists>K.\n         K - {Max K} \\<in> \\<I> \\<and>\n         Max K \\<in> J (K - {Max K}) \\<and>\n         K = insert (Max K) K \\<and> l = A (K - {Max K}) @ B (Max K)) \\<and>\n     \\<beta> * \\<gamma> + \\<delta> =\n     \\<beta> *\n     ordermap (A ` \\<I>) (lenlex less_than) (take (length l - c) l) +\n     ordermap (B ` J (inv_into \\<I> A (take (length l - c) l)))\n      (lenlex less_than) (drop (length l - c) l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n  \\<subseteq> f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ` usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J =\n  elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> lenlex less_than)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> lenlex less_than)", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> lenlex less_than)", "assume \"p \\<in> ?AB\" and \"q \\<in> ?AB\""], ["proof (state)\nthis:\n  p \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n  q \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> lenlex less_than)", "then"], ["proof (chain)\npicking this:\n  p \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n  q \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J", "obtain x y where peq: \"p = A (x - {Max x}) @ B (Max x)\"\n                      and qeq: \"q = A (y - {Max y}) @ B (Max y)\"\n                      and x: \"x - {Max x} \\<in> \\<I>\"\n                      and y: \"y - {Max y} \\<in> \\<I>\"\n                      and mx: \"Max x \\<in> J (x - {Max x})\"\n                      and my: \"Max y \\<in> J (y - {Max y})\""], ["proof (prove)\nusing this:\n  p \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n  q \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>p = A (x - {Max x}) @ B (Max x);\n         q = A (y - {Max y}) @ B (Max y); x - {Max x} \\<in> \\<I>;\n         y - {Max y} \\<in> \\<I>; Max x \\<in> J (x - {Max x});\n         Max y \\<in> J (y - {Max y})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: USigma_iff IJ usplit_def)"], ["proof (state)\nthis:\n  p = A (x - {Max x}) @ B (Max x)\n  q = A (y - {Max y}) @ B (Max y)\n  x - {Max x} \\<in> \\<I>\n  y - {Max y} \\<in> \\<I>\n  Max x \\<in> J (x - {Max x})\n  Max y \\<in> J (y - {Max y})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> lenlex less_than)", "let ?mx = \"x - {Max x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> lenlex less_than)", "let ?my = \"y - {Max y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J;\n        y \\<in> usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> lenlex less_than)", "show \"(f p < f q) \\<longleftrightarrow> ((p, q) \\<in> ?R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f p < f q) = ((p, q) \\<in> lenlex less_than)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f p < f q \\<Longrightarrow> (p, q) \\<in> lenlex less_than\n 2. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "assume \"f p < f q\""], ["proof (state)\nthis:\n  f p < f q\n\ngoal (2 subgoals):\n 1. f p < f q \\<Longrightarrow> (p, q) \\<in> lenlex less_than\n 2. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  f p < f q", "consider \"ordermap (A`\\<I>) ?R (A (x - {Max x})) < ordermap (A`\\<I>) ?R (A (y - {Max y}))\"\n          | \"ordermap (A`\\<I>) ?R (A (x - {Max x})) = ordermap (A`\\<I>) ?R (A (y - {Max y}))\"\n            \"ordermap (B`J (x - {Max x})) ?R (B (Max x)) < ordermap (B`J (y - {Max y})) ?R (B (Max y))\""], ["proof (prove)\nusing this:\n  f p < f q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n             < ordermap (A ` \\<I>) (lenlex less_than)\n                (A (y - {Max y})) \\<Longrightarrow>\n             thesis;\n     \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n              ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n      ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n      < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n         (B (Max y))\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using x y mx my"], ["proof (prove)\nusing this:\n  f p < f q\n  x - {Max x} \\<in> \\<I>\n  y - {Max y} \\<in> \\<I>\n  Max x \\<in> J (x - {Max x})\n  Max y \\<in> J (y - {Max y})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n             < ordermap (A ` \\<I>) (lenlex less_than)\n                (A (y - {Max y})) \\<Longrightarrow>\n             thesis;\n     \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n              ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n      ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n      < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n         (B (Max y))\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto dest: mult_cancellation_less simp: f_def split_def peq qeq oB)"], ["proof (state)\nthis:\n  \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n           < ordermap (A ` \\<I>) (lenlex less_than)\n              (A (y - {Max y})) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n            ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. f p < f q \\<Longrightarrow> (p, q) \\<in> lenlex less_than\n 2. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n           < ordermap (A ` \\<I>) (lenlex less_than)\n              (A (y - {Max y})) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n            ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"(A ?mx @ B (Max x), A ?my @ B (Max y)) \\<in> ?R\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n           < ordermap (A ` \\<I>) (lenlex less_than)\n              (A (y - {Max y})) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n            ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    < ordermap (A ` \\<I>) (lenlex less_than)\n       (A (y - {Max y})) \\<Longrightarrow>\n    (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than\n 2. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "case 1"], ["proof (state)\nthis:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n  < ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n\ngoal (2 subgoals):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    < ordermap (A ` \\<I>) (lenlex less_than)\n       (A (y - {Max y})) \\<Longrightarrow>\n    (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than\n 2. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "then"], ["proof (chain)\npicking this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n  < ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))", "have \"(A ?mx, A ?my) \\<in> ?R\""], ["proof (prove)\nusing this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n  < ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n\ngoal (1 subgoal):\n 1. (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than", "using x y"], ["proof (prove)\nusing this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n  < ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  x - {Max x} \\<in> \\<I>\n  y - {Max y} \\<in> \\<I>\n\ngoal (1 subgoal):\n 1. (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than", "by (force simp: Ord_mem_iff_lt intro: converse_ordermap_mono)"], ["proof (state)\nthis:\n  (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\n\ngoal (2 subgoals):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    < ordermap (A ` \\<I>) (lenlex less_than)\n       (A (y - {Max y})) \\<Longrightarrow>\n    (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than\n 2. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "then"], ["proof (chain)\npicking this:\n  (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than", "show ?thesis"], ["proof (prove)\nusing this:\n  (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than", "using x y mx my lenB lenlex_append1"], ["proof (prove)\nusing this:\n  (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\n  x - {Max x} \\<in> \\<I>\n  y - {Max y} \\<in> \\<I>\n  Max x \\<in> J (x - {Max x})\n  Max y \\<in> J (y - {Max y})\n  \\<lbrakk>?i \\<in> \\<I>; ?j \\<in> J ?i\\<rbrakk>\n  \\<Longrightarrow> length (B ?j) = c\n  \\<lbrakk>(?us, ?xs) \\<in> lenlex ?R; length ?vs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> (?us @ ?vs, ?xs @ ?ys) \\<in> lenlex ?R\n\ngoal (1 subgoal):\n 1. (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than", "by blast"], ["proof (state)\nthis:\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "case 2"], ["proof (state)\nthis:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "then"], ["proof (chain)\npicking this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "have \"A ?mx = A ?my\""], ["proof (prove)\nusing this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y})", "using \\<open>?my \\<in> \\<I>\\<close> \\<open>?mx \\<in> \\<I>\\<close>"], ["proof (prove)\nusing this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n  y - {Max y} \\<in> \\<I>\n  x - {Max x} \\<in> \\<I>\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y})", "by auto"], ["proof (state)\nthis:\n  A (x - {Max x}) = A (y - {Max y})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "then"], ["proof (chain)\npicking this:\n  A (x - {Max x}) = A (y - {Max y})", "have eq: \"?mx = ?my\""], ["proof (prove)\nusing this:\n  A (x - {Max x}) = A (y - {Max y})\n\ngoal (1 subgoal):\n 1. x - {Max x} = y - {Max y}", "by (metis \\<open>?my \\<in> \\<I>\\<close> \\<open>?mx \\<in> \\<I>\\<close> inv_into_IA)"], ["proof (state)\nthis:\n  x - {Max x} = y - {Max y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "then"], ["proof (chain)\npicking this:\n  x - {Max x} = y - {Max y}", "have \"(B (Max x), B (Max y)) \\<in> ?R\""], ["proof (prove)\nusing this:\n  x - {Max x} = y - {Max y}\n\ngoal (1 subgoal):\n 1. (B (Max x), B (Max y)) \\<in> lenlex less_than", "using mx my  2"], ["proof (prove)\nusing this:\n  x - {Max x} = y - {Max y}\n  Max x \\<in> J (x - {Max x})\n  Max y \\<in> J (y - {Max y})\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal (1 subgoal):\n 1. (B (Max x), B (Max y)) \\<in> lenlex less_than", "by (force simp: Ord_mem_iff_lt intro: converse_ordermap_mono)"], ["proof (state)\nthis:\n  (B (Max x), B (Max y)) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n             ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}));\n     ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n     < ordermap (B ` J (y - {Max y})) (lenlex less_than)\n        (B (Max y))\\<rbrakk>\n    \\<Longrightarrow> (A (x - {Max x}) @ B (Max x),\n                       A (y - {Max y}) @ B (Max y))\n                      \\<in> lenlex less_than", "with 2"], ["proof (chain)\npicking this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n  (B (Max x), B (Max y)) \\<in> lenlex less_than", "show ?thesis"], ["proof (prove)\nusing this:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) =\n  ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n  (B (Max x), B (Max y)) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than", "by (simp add: eq irrefl_less_than)"], ["proof (state)\nthis:\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than\n\ngoal (2 subgoals):\n 1. f p < f q \\<Longrightarrow> (p, q) \\<in> lenlex less_than\n 2. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than", "show \"(p,q) \\<in> ?R\""], ["proof (prove)\nusing this:\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> lenlex less_than", "by (simp add: peq qeq f_def split_def sorted_list_of_set_Un AB)"], ["proof (state)\nthis:\n  (p, q) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "assume pqR: \"(p,q) \\<in> ?R\""], ["proof (state)\nthis:\n  (p, q) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  (p, q) \\<in> lenlex less_than", "have \\<section>: \"(A ?mx @ B (Max x), A ?my @ B (Max y)) \\<in> ?R\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than", "using peq qeq"], ["proof (prove)\nusing this:\n  (p, q) \\<in> lenlex less_than\n  p = A (x - {Max x}) @ B (Max x)\n  q = A (y - {Max y}) @ B (Max y)\n\ngoal (1 subgoal):\n 1. (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n    \\<in> lenlex less_than", "by blast"], ["proof (state)\nthis:\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than", "consider \"(A ?mx, A ?my) \\<in> ?R\" | \"A ?mx = A ?my \\<and> (B (Max x), B (Max y)) \\<in> ?R\""], ["proof (prove)\nusing this:\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases \"(A ?mx, A ?my) \\<in> ?R\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<notin> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  (A (x - {Max x}), A (y - {Max y})) \\<notin> lenlex less_than\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<notin> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis", "have False if \"(A ?my, A ?mx) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>?my \\<in> \\<I>\\<close> \\<open>?mx \\<in> \\<I>\\<close> \"\\<section>\" \\<open>(Max y) \\<in> J ?my\\<close> \\<open>(Max x) \\<in> J ?mx\\<close> lenB lenlex_append1 omega_sum_1_less order.asym that)"], ["proof (state)\nthis:\n  (A (y - {Max y}), A (x - {Max x}))\n  \\<in> lenlex less_than \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<notin> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  (A (y - {Max y}), A (x - {Max x}))\n  \\<in> lenlex less_than \\<Longrightarrow>\n  False", "have \"A ?mx = A ?my\""], ["proof (prove)\nusing this:\n  (A (y - {Max y}), A (x - {Max x}))\n  \\<in> lenlex less_than \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y})", "by (meson False UNIV_I total_llt total_on_def)"], ["proof (state)\nthis:\n  A (x - {Max x}) = A (y - {Max y})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<notin> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  A (x - {Max x}) = A (y - {Max y})", "show ?thesis"], ["proof (prove)\nusing this:\n  A (x - {Max x}) = A (y - {Max y})\n\ngoal (1 subgoal):\n 1. thesis", "using \"\\<section>\" irrefl_less_than that(2)"], ["proof (prove)\nusing this:\n  A (x - {Max x}) = A (y - {Max y})\n  (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n  \\<in> lenlex less_than\n  irrefl less_than\n  A (x - {Max x}) = A (y - {Max y}) \\<and>\n  (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n             \\<in> lenlex less_than \\<Longrightarrow>\n             thesis;\n     A (x - {Max x}) = A (y - {Max y}) \\<and>\n     (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n     thesis;\n     (A (x - {Max x}) @ B (Max x), A (y - {Max y}) @ B (Max y))\n     \\<in> lenlex less_than;\n     (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\\<rbrakk>\n    \\<Longrightarrow> thesis", "qed (use that in blast)"], ["proof (state)\nthis:\n  \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n           \\<in> lenlex less_than \\<Longrightarrow>\n           ?thesis;\n   A (x - {Max x}) = A (y - {Max y}) \\<and>\n   (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n           \\<in> lenlex less_than \\<Longrightarrow>\n           ?thesis;\n   A (x - {Max x}) = A (y - {Max y}) \\<and>\n   (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"\\<beta> * ordermap (A`\\<I>) ?R (A ?mx) + ordermap (B`J ?mx) ?R (B (Max x))\n               < \\<beta> * ordermap (A`\\<I>) ?R (A ?my) + ordermap (B`J ?my) ?R (B (Max y))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(A (x - {Max x}), A (y - {Max y}))\n           \\<in> lenlex less_than \\<Longrightarrow>\n           ?thesis;\n   A (x - {Max x}) = A (y - {Max y}) \\<and>\n   (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. (A (x - {Max x}), A (y - {Max y}))\n    \\<in> lenlex less_than \\<Longrightarrow>\n    \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n 2. A (x - {Max x}) = A (y - {Max y}) \\<and>\n    (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n    \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "case 1"], ["proof (state)\nthis:\n  (A (x - {Max x}), A (y - {Max y})) \\<in> lenlex less_than\n\ngoal (2 subgoals):\n 1. (A (x - {Max x}), A (y - {Max y}))\n    \\<in> lenlex less_than \\<Longrightarrow>\n    \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n 2. A (x - {Max x}) = A (y - {Max y}) \\<and>\n    (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n    \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "proof (rule add_mult_less_add_mult)"], ["proof (state)\ngoal (7 subgoals):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    < ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n 2. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    \\<in> elts ?\\<beta>\n 3. ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n    \\<in> elts ?\\<beta>\n 4. ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    \\<in> elts \\<beta>\n 5. ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n    \\<in> elts \\<beta>\n 6. Ord \\<beta>\n 7. Ord ?\\<beta>", "show \"ordermap (A`\\<I>) (lenlex less_than) (A ?mx) < ordermap (A`\\<I>) (lenlex less_than) (A ?my)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    < ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))", "by (simp add: \"1\" \\<open>?my \\<in> \\<I>\\<close> \\<open>?mx \\<in> \\<I>\\<close> ordermap_mono_less)"], ["proof (state)\nthis:\n  ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n  < ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n\ngoal (6 subgoals):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    \\<in> elts ?\\<beta>\n 2. ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n    \\<in> elts ?\\<beta>\n 3. ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    \\<in> elts \\<beta>\n 4. ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n    \\<in> elts \\<beta>\n 5. Ord \\<beta>\n 6. Ord ?\\<beta>", "show \"Ord (ordertype (A`\\<I>) ?R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ordertype (A ` \\<I>) (lenlex less_than))", "using wf_Ord_ordertype"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf ?r; trans ?r\\<rbrakk> \\<Longrightarrow> Ord (ordertype ?A ?r)\n\ngoal (1 subgoal):\n 1. Ord (ordertype (A ` \\<I>) (lenlex less_than))", "by blast+"], ["proof (state)\nthis:\n  Ord (ordertype (A ` \\<I>) (lenlex less_than))\n\ngoal (5 subgoals):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\n 2. ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n    \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\n 3. ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    \\<in> elts \\<beta>\n 4. ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n    \\<in> elts \\<beta>\n 5. Ord \\<beta>", "show \"ordermap (B ` J ?mx) ?R (B (Max x)) \\<in> elts \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    \\<in> elts \\<beta>", "using Ord_less_TC_mem \\<open>Ord \\<beta>\\<close> \\<open>?mx \\<in> \\<I>\\<close> \\<open>(Max x) \\<in> J ?mx\\<close> oB"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; ?\\<beta> \\<sqsubset> ?\\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> \\<in> elts ?\\<alpha>\n  Ord \\<beta>\n  x - {Max x} \\<in> \\<I>\n  Max x \\<in> J (x - {Max x})\n  \\<lbrakk>?i \\<in> \\<I>; ?j \\<in> J ?i\\<rbrakk>\n  \\<Longrightarrow> ordermap (B ` J ?i) (lenlex less_than)\n                     (B ?j) \\<sqsubset>\n                    \\<beta>\n\ngoal (1 subgoal):\n 1. ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    \\<in> elts \\<beta>", "by blast"], ["proof (state)\nthis:\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  \\<in> elts \\<beta>\n\ngoal (4 subgoals):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\n 2. ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n    \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\n 3. ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n    \\<in> elts \\<beta>\n 4. Ord \\<beta>", "show \"ordermap (B ` J ?my) ?R (B (Max y)) \\<in> elts \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n    \\<in> elts \\<beta>", "using Ord_less_TC_mem \\<open>Ord \\<beta>\\<close> \\<open>?my \\<in> \\<I>\\<close> \\<open>(Max y) \\<in> J ?my\\<close> oB"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; ?\\<beta> \\<sqsubset> ?\\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> \\<in> elts ?\\<alpha>\n  Ord \\<beta>\n  y - {Max y} \\<in> \\<I>\n  Max y \\<in> J (y - {Max y})\n  \\<lbrakk>?i \\<in> \\<I>; ?j \\<in> J ?i\\<rbrakk>\n  \\<Longrightarrow> ordermap (B ` J ?i) (lenlex less_than)\n                     (B ?j) \\<sqsubset>\n                    \\<beta>\n\ngoal (1 subgoal):\n 1. ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n    \\<in> elts \\<beta>", "by blast"], ["proof (state)\nthis:\n  ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n  \\<in> elts \\<beta>\n\ngoal (3 subgoals):\n 1. ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x}))\n    \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\n 2. ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y}))\n    \\<in> elts (ordertype (A ` \\<I>) (lenlex less_than))\n 3. Ord \\<beta>", "qed (use \\<open>?my \\<in> \\<I>\\<close> \\<open>?mx \\<in> \\<I>\\<close> \\<open>Ord \\<beta>\\<close> in auto)"], ["proof (state)\nthis:\n  \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n    ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y}) \\<and>\n    (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n    \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y}) \\<and>\n    (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n    \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "case 2"], ["proof (state)\nthis:\n  A (x - {Max x}) = A (y - {Max y}) \\<and>\n  (B (Max x), B (Max y)) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. A (x - {Max x}) = A (y - {Max y}) \\<and>\n    (B (Max x), B (Max y)) \\<in> lenlex less_than \\<Longrightarrow>\n    \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "with \\<open>?mx \\<in> \\<I>\\<close>"], ["proof (chain)\npicking this:\n  x - {Max x} \\<in> \\<I>\n  A (x - {Max x}) = A (y - {Max y}) \\<and>\n  (B (Max x), B (Max y)) \\<in> lenlex less_than", "show ?thesis"], ["proof (prove)\nusing this:\n  x - {Max x} \\<in> \\<I>\n  A (x - {Max x}) = A (y - {Max y}) \\<and>\n  (B (Max x), B (Max y)) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "using \\<open>(Max y) \\<in> J ?my\\<close> \\<open>(Max x) \\<in> J ?mx\\<close> ordermap_mono_less"], ["proof (prove)\nusing this:\n  x - {Max x} \\<in> \\<I>\n  A (x - {Max x}) = A (y - {Max y}) \\<and>\n  (B (Max x), B (Max y)) \\<in> lenlex less_than\n  Max y \\<in> J (y - {Max y})\n  Max x \\<in> J (x - {Max x})\n  \\<lbrakk>(?w, ?x) \\<in> ?r; wf ?r; trans ?r; ?w \\<in> ?A; ?x \\<in> ?A;\n   small ?A\\<rbrakk>\n  \\<Longrightarrow> ordermap ?A ?r ?w < ordermap ?A ?r ?x\n\ngoal (1 subgoal):\n 1. \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n    ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n    < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n      ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "by (metis (no_types, hide_lams) Kirby.add_less_cancel_left TC_small image_iff inv_into_IA trans_llt wf_llt y)"], ["proof (state)\nthis:\n  \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n    ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n    ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> lenlex less_than \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n    ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))", "show \"f p < f q\""], ["proof (prove)\nusing this:\n  \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n    ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n\ngoal (1 subgoal):\n 1. f p < f q", "using \\<open>?my \\<in> \\<I>\\<close> \\<open>?mx \\<in> \\<I>\\<close> \\<open>(Max y) \\<in> J ?my\\<close> \\<open>(Max x) \\<in> J ?mx\\<close>"], ["proof (prove)\nusing this:\n  \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (x - {Max x})) +\n  ordermap (B ` J (x - {Max x})) (lenlex less_than) (B (Max x))\n  < \\<beta> * ordermap (A ` \\<I>) (lenlex less_than) (A (y - {Max y})) +\n    ordermap (B ` J (y - {Max y})) (lenlex less_than) (B (Max y))\n  y - {Max y} \\<in> \\<I>\n  x - {Max x} \\<in> \\<I>\n  Max y \\<in> J (y - {Max y})\n  Max x \\<in> J (x - {Max x})\n\ngoal (1 subgoal):\n 1. f p < f q", "by (auto simp: peq qeq f_def split_def AB)"], ["proof (state)\nthis:\n  f p < f q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f p < f q) = ((p, q) \\<in> lenlex less_than)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n      (elts (\\<beta> * ordertype (A ` \\<I>) (lenlex less_than))) \\<and>\n     (\\<forall>x\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n         \\<forall>y\\<in>usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J.\n            (f x < f y) = ((x, y) \\<in> lenlex less_than))\n\ngoal (4 subgoals):\n 1. wf (lenlex less_than)\n 2. small (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n 3. total_on (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than)\n 4. trans (lenlex less_than)", "qed auto"], ["proof (state)\nthis:\n  ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n   (lenlex less_than) =\n  \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<I> = {} \\<Longrightarrow>\n    ordertype (usplit (\\<lambda>i j. A i @ B j) ` USigma \\<I> J)\n     (lenlex less_than) =\n    \\<beta> * ordertype (A ` \\<I>) (lenlex less_than)", "qed auto"], ["", "subsubsection \\<open>The final part of 3.8, where two sequences are merged\\<close>"], ["", "inductive merge :: \"[nat list list,nat list list,nat list list,nat list list] \\<Rightarrow> bool\"\n  where NullNull: \"merge [] [] [] []\"\n      | Null: \"as \\<noteq> [] \\<Longrightarrow> merge as [] [concat as] []\"\n      | App: \"\\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> [];\n               concat as1 < concat bs1; concat bs1 < concat as2; merge as2 bs2 as bs\\<rbrakk>\n              \\<Longrightarrow> merge (as1@as2) (bs1@bs2) (concat as1 # as) (concat bs1 # bs)\""], ["", "inductive_simps Null1 [simp]: \"merge [] bs us vs\""], ["", "inductive_simps Null2 [simp]: \"merge as [] us vs\""], ["", "lemma merge_single:\n  \"\\<lbrakk>concat as < concat bs; concat as \\<noteq> []; concat bs \\<noteq> []\\<rbrakk> \\<Longrightarrow> merge as bs [concat as] [concat bs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>concat as < concat bs; concat as \\<noteq> [];\n     concat bs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> merge as bs [concat as] [concat bs]", "using merge.App [of as bs \"[]\" \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>as \\<noteq> []; bs \\<noteq> []; concat as < concat bs;\n   concat bs < concat []; merge [] [] ?as ?bs\\<rbrakk>\n  \\<Longrightarrow> merge (as @ []) (bs @ []) (concat as # ?as)\n                     (concat bs # ?bs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat as < concat bs; concat as \\<noteq> [];\n     concat bs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> merge as bs [concat as] [concat bs]", "by (fastforce simp add: less_list_def)"], ["", "lemma merge_length1_nonempty:\n  assumes \"merge as bs us vs\" \"as \\<in> lists (- {[]})\"\n  shows \"us \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists (- {[]})", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n  as \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. us \\<in> lists (- {[]})", "by induction (auto simp: mem_lists_non_Nil)"], ["", "lemma merge_length2_nonempty:\n  assumes \"merge as bs us vs\" \"bs \\<in> lists (- {[]})\"\n  shows \"vs \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> lists (- {[]})", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n  bs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. vs \\<in> lists (- {[]})", "by induction (auto simp: mem_lists_non_Nil)"], ["", "lemma merge_length1_gt_0:\n  assumes \"merge as bs us vs\" \"as \\<noteq> []\"\n  shows \"length us > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length us", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length us", "by induction auto"], ["", "lemma merge_length_le:\n  assumes \"merge as bs us vs\"\n  shows \"length vs \\<le> length us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs \\<le> length us", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n\ngoal (1 subgoal):\n 1. length vs \\<le> length us", "by induction auto"], ["", "lemma merge_length_le_Suc:\n  assumes \"merge as bs us vs\"\n  shows \"length us \\<le> Suc (length vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us \\<le> Suc (length vs)", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n\ngoal (1 subgoal):\n 1. length us \\<le> Suc (length vs)", "by induction auto"], ["", "lemma merge_length_less2:\n  assumes \"merge as bs us vs\"\n  shows \"length vs \\<le> length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs \\<le> length as", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n\ngoal (1 subgoal):\n 1. length vs \\<le> length as", "proof induction"], ["proof (state)\ngoal (3 subgoals):\n 1. length [] \\<le> length []\n 2. \\<And>as. as \\<noteq> [] \\<Longrightarrow> length [] \\<le> length as\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        length bs \\<le> length as2\\<rbrakk>\n       \\<Longrightarrow> length (concat bs1 # bs) \\<le> length (as1 @ as2)", "case (App as1 bs1 as2 bs2 as bs)"], ["proof (state)\nthis:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  length bs \\<le> length as2\n\ngoal (3 subgoals):\n 1. length [] \\<le> length []\n 2. \\<And>as. as \\<noteq> [] \\<Longrightarrow> length [] \\<le> length as\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        length bs \\<le> length as2\\<rbrakk>\n       \\<Longrightarrow> length (concat bs1 # bs) \\<le> length (as1 @ as2)", "then"], ["proof (chain)\npicking this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  length bs \\<le> length as2", "show ?case"], ["proof (prove)\nusing this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  length bs \\<le> length as2\n\ngoal (1 subgoal):\n 1. length (concat bs1 # bs) \\<le> length (as1 @ as2)", "by simp (metis One_nat_def Suc_eq_plus1 Suc_leI add.commute add_mono length_greater_0_conv)"], ["proof (state)\nthis:\n  length (concat bs1 # bs) \\<le> length (as1 @ as2)\n\ngoal (2 subgoals):\n 1. length [] \\<le> length []\n 2. \\<And>as. as \\<noteq> [] \\<Longrightarrow> length [] \\<le> length as", "qed auto"], ["", "lemma merge_preserves:\n  assumes \"merge as bs us vs\"\n  shows \"concat as = concat us \\<and> concat bs = concat vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat as = concat us \\<and> concat bs = concat vs", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n\ngoal (1 subgoal):\n 1. concat as = concat us \\<and> concat bs = concat vs", "by induction auto"], ["", "lemma merge_interact:\n  assumes \"merge as bs us vs\" \"strict_sorted (concat as)\" \"strict_sorted (concat bs)\"\n           \"bs \\<in> lists (- {[]})\"\n  shows \"strict_sorted (interact us vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact us vs)", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n  bs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. strict_sorted (interact us vs)", "proof induction"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (interact [] [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [concat as] [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> strict_sorted (interact as bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted\n                          (interact (concat as1 # as) (concat bs1 # bs))", "case (App as1 bs1 as2 bs2 as bs)"], ["proof (state)\nthis:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact as bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (interact [] [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [concat as] [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> strict_sorted (interact as bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted\n                          (interact (concat as1 # as) (concat bs1 # bs))", "then"], ["proof (chain)\npicking this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact as bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})", "have \"concat bs1 < concat bs\" \"concat bs1 < concat as\" and xx: \"concat bs1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact as bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. (concat bs1 < concat bs &&& concat bs1 < concat as) &&&\n    concat bs1 \\<noteq> []", "using merge_preserves strict_sorted_append_iff"], ["proof (prove)\nusing this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact as bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  concat ?as = concat ?us \\<and> concat ?bs = concat ?vs\n  strict_sorted (?xs @ ?ys) =\n  (?xs < ?ys \\<and> strict_sorted ?xs \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. (concat bs1 < concat bs &&& concat bs1 < concat as) &&&\n    concat bs1 \\<noteq> []", "by fastforce+"], ["proof (state)\nthis:\n  concat bs1 < concat bs\n  concat bs1 < concat as\n  concat bs1 \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (interact [] [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [concat as] [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> strict_sorted (interact as bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted\n                          (interact (concat as1 # as) (concat bs1 # bs))", "then"], ["proof (chain)\npicking this:\n  concat bs1 < concat bs\n  concat bs1 < concat as\n  concat bs1 \\<noteq> []", "have \"concat bs1 < interact as bs\""], ["proof (prove)\nusing this:\n  concat bs1 < concat bs\n  concat bs1 < concat as\n  concat bs1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. concat bs1 < interact as bs", "using App"], ["proof (prove)\nusing this:\n  concat bs1 < concat bs\n  concat bs1 < concat as\n  concat bs1 \\<noteq> []\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact as bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. concat bs1 < interact as bs", "apply (simp add: less_list_def del: concat_eq_Nil_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>concat bs \\<noteq> [] \\<longrightarrow>\n             last (concat bs1) < hd (concat bs);\n     concat as \\<noteq> [] \\<longrightarrow>\n     last (concat bs1) < hd (concat as);\n     concat bs1 \\<noteq> []; as1 \\<noteq> []; bs1 \\<noteq> [];\n     concat as1 \\<noteq> [] \\<longrightarrow>\n     last (concat as1) < hd (concat bs1);\n     concat as2 \\<noteq> [] \\<longrightarrow>\n     last (concat bs1) < hd (concat as2);\n     merge as2 bs2 as bs;\n     \\<lbrakk>strict_sorted (concat as2);\n      strict_sorted (concat bs2)\\<rbrakk>\n     \\<Longrightarrow> strict_sorted (interact as bs);\n     strict_sorted (concat as1 @ concat as2);\n     strict_sorted (concat bs1 @ concat bs2);\n     bs1 \\<in> lists (- {[]}) \\<and> bs2 \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> interact as bs \\<noteq> [] \\<longrightarrow>\n                      last (concat bs1) < hd (interact as bs)", "by (metis (full_types) Un_iff \\<open>concat bs1 < concat as\\<close> \\<open>concat bs1 < concat bs\\<close> last_in_set list.set_sel(1) set_interact sorted_wrt_append strict_sorted_append_iff strict_sorted_interact_imp_concat strict_sorted_sorted_wrt xx)"], ["proof (state)\nthis:\n  concat bs1 < interact as bs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (interact [] [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [concat as] [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> strict_sorted (interact as bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted\n                          (interact (concat as1 # as) (concat bs1 # bs))", "with App"], ["proof (chain)\npicking this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact as bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n  concat bs1 < interact as bs", "show ?case"], ["proof (prove)\nusing this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact as bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n  concat bs1 < interact as bs\n\ngoal (1 subgoal):\n 1. strict_sorted (interact (concat as1 # as) (concat bs1 # bs))", "apply (simp add: strict_sorted_append_iff del: concat_eq_Nil_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n     concat bs1 < concat as2; merge as2 bs2 as bs;\n     strict_sorted (interact as bs);\n     concat as1 < concat as2 \\<and>\n     strict_sorted (concat as1) \\<and> strict_sorted (concat as2);\n     concat bs1 < concat bs2 \\<and>\n     strict_sorted (concat bs1) \\<and> strict_sorted (concat bs2);\n     bs1 \\<in> lists (- {[]}) \\<and> bs2 \\<in> lists (- {[]});\n     concat bs1 < interact as bs\\<rbrakk>\n    \\<Longrightarrow> concat as1 < concat bs1 @ interact as bs", "by (metis hd_append2 less_list_def xx)"], ["proof (state)\nthis:\n  strict_sorted (interact (concat as1 # as) (concat bs1 # bs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> strict_sorted (interact [] [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> strict_sorted (interact [concat as] [])", "qed auto"], ["", "lemma acc_lengths_merge1:\n  assumes \"merge as bs us vs\"\n  shows \"list.set (acc_lengths k us) \\<subseteq> list.set (acc_lengths k as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (acc_lengths k us) \\<subseteq> list.set (acc_lengths k as)", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths k us) \\<subseteq> list.set (acc_lengths k as)", "proof (induction arbitrary: k)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])\n 2. \\<And>as k.\n       as \\<noteq> [] \\<Longrightarrow>\n       list.set (acc_lengths k [concat as])\n       \\<subseteq> list.set (acc_lengths k as)\n 3. \\<And>as1 bs1 as2 bs2 as bs k.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<And>k.\n           list.set (acc_lengths k as)\n           \\<subseteq> list.set (acc_lengths k as2)\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths k (concat as1 # as))\n                         \\<subseteq> list.set (acc_lengths k (as1 @ as2))", "case (App as1 bs1 as2 bs2 as bs)"], ["proof (state)\nthis:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  list.set (acc_lengths ?k as) \\<subseteq> list.set (acc_lengths ?k as2)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])\n 2. \\<And>as k.\n       as \\<noteq> [] \\<Longrightarrow>\n       list.set (acc_lengths k [concat as])\n       \\<subseteq> list.set (acc_lengths k as)\n 3. \\<And>as1 bs1 as2 bs2 as bs k.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<And>k.\n           list.set (acc_lengths k as)\n           \\<subseteq> list.set (acc_lengths k as2)\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths k (concat as1 # as))\n                         \\<subseteq> list.set (acc_lengths k (as1 @ as2))", "then"], ["proof (chain)\npicking this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  list.set (acc_lengths ?k as) \\<subseteq> list.set (acc_lengths ?k as2)", "show ?case"], ["proof (prove)\nusing this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  list.set (acc_lengths ?k as) \\<subseteq> list.set (acc_lengths ?k as2)\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths k (concat as1 # as))\n    \\<subseteq> list.set (acc_lengths k (as1 @ as2))", "apply (simp add: acc_lengths_append acc_lengths.simps strict_sorted_append_iff length_concat_acc_lengths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n     concat bs1 < concat as2; merge as2 bs2 as bs;\n     \\<And>k.\n        list.set (acc_lengths k as)\n        \\<subseteq> list.set (acc_lengths k as2)\\<rbrakk>\n    \\<Longrightarrow> list.set (acc_lengths (k + length (concat as1)) as)\n                      \\<subseteq> list.set (acc_lengths k as1) \\<union>\n                                  list.set\n                                   (acc_lengths\n                                     (k + sum_list (map length as1)) as2)", "by (simp add: le_supI2 length_concat)"], ["proof (state)\nthis:\n  list.set (acc_lengths k (concat as1 # as))\n  \\<subseteq> list.set (acc_lengths k (as1 @ as2))\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])\n 2. \\<And>as k.\n       as \\<noteq> [] \\<Longrightarrow>\n       list.set (acc_lengths k [concat as])\n       \\<subseteq> list.set (acc_lengths k as)", "qed (auto simp: acc_lengths.simps length_concat_acc_lengths)"], ["", "lemma acc_lengths_merge2:\n  assumes \"merge as bs us vs\"\n  shows \"list.set (acc_lengths k vs) \\<subseteq> list.set (acc_lengths k bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (acc_lengths k vs) \\<subseteq> list.set (acc_lengths k bs)", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths k vs) \\<subseteq> list.set (acc_lengths k bs)", "proof (induction arbitrary: k)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])\n 2. \\<And>as k.\n       as \\<noteq> [] \\<Longrightarrow>\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])\n 3. \\<And>as1 bs1 as2 bs2 as bs k.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<And>k.\n           list.set (acc_lengths k bs)\n           \\<subseteq> list.set (acc_lengths k bs2)\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths k (concat bs1 # bs))\n                         \\<subseteq> list.set (acc_lengths k (bs1 @ bs2))", "case (App as1 bs1 as2 bs2 as bs)"], ["proof (state)\nthis:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  list.set (acc_lengths ?k bs) \\<subseteq> list.set (acc_lengths ?k bs2)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])\n 2. \\<And>as k.\n       as \\<noteq> [] \\<Longrightarrow>\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])\n 3. \\<And>as1 bs1 as2 bs2 as bs k.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<And>k.\n           list.set (acc_lengths k bs)\n           \\<subseteq> list.set (acc_lengths k bs2)\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths k (concat bs1 # bs))\n                         \\<subseteq> list.set (acc_lengths k (bs1 @ bs2))", "then"], ["proof (chain)\npicking this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  list.set (acc_lengths ?k bs) \\<subseteq> list.set (acc_lengths ?k bs2)", "show ?case"], ["proof (prove)\nusing this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  list.set (acc_lengths ?k bs) \\<subseteq> list.set (acc_lengths ?k bs2)\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths k (concat bs1 # bs))\n    \\<subseteq> list.set (acc_lengths k (bs1 @ bs2))", "apply (simp add: acc_lengths_append acc_lengths.simps strict_sorted_append_iff length_concat_acc_lengths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n     concat bs1 < concat as2; merge as2 bs2 as bs;\n     \\<And>k.\n        list.set (acc_lengths k bs)\n        \\<subseteq> list.set (acc_lengths k bs2)\\<rbrakk>\n    \\<Longrightarrow> list.set (acc_lengths (k + length (concat bs1)) bs)\n                      \\<subseteq> list.set (acc_lengths k bs1) \\<union>\n                                  list.set\n                                   (acc_lengths\n                                     (k + sum_list (map length bs1)) bs2)", "by (simp add: le_supI2 length_concat)"], ["proof (state)\nthis:\n  list.set (acc_lengths k (concat bs1 # bs))\n  \\<subseteq> list.set (acc_lengths k (bs1 @ bs2))\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])\n 2. \\<And>as k.\n       as \\<noteq> [] \\<Longrightarrow>\n       list.set (acc_lengths k []) \\<subseteq> list.set (acc_lengths k [])", "qed (auto simp: acc_lengths.simps length_concat_acc_lengths)"], ["", "lemma length_hd_le_concat:\n  assumes \"as \\<noteq> []\" shows \"length (hd as) \\<le> length (concat as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (hd as) \\<le> length (concat as)", "by (metis (no_types) add.commute assms concat.simps(2) le_add2 length_append list.exhaust_sel)"], ["", "lemma length_hd_merge2:\n  assumes \"merge as bs us vs\"\n  shows \"length (hd bs) \\<le> length (hd vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (hd bs) \\<le> length (hd vs)", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n\ngoal (1 subgoal):\n 1. length (hd bs) \\<le> length (hd vs)", "by induction (auto simp: length_hd_le_concat)"], ["", "lemma merge_less_sets_hd:\n  assumes \"merge as bs us vs\" \"strict_sorted (concat as)\" \"strict_sorted (concat bs)\" \"bs \\<in> lists (- {[]})\"\n  shows \"list.set (hd us) \\<lless> list.set (concat vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (hd us) \\<lless> list.set (concat vs)", "using assms"], ["proof (prove)\nusing this:\n  merge as bs us vs\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n  bs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. list.set (hd us) \\<lless> list.set (concat vs)", "proof induction"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (hd []) \\<lless> list.set (concat [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd [concat as]) \\<lless>\n                         list.set (concat [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd (concat as1 # as)) \\<lless>\n                         list.set (concat (concat bs1 # bs))", "case (App as1 bs1 as2 bs2 as bs)"], ["proof (state)\nthis:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (hd []) \\<lless> list.set (concat [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd [concat as]) \\<lless>\n                         list.set (concat [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd (concat as1 # as)) \\<lless>\n                         list.set (concat (concat bs1 # bs))", "then"], ["proof (chain)\npicking this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})", "have \\<section>: \"list.set (concat bs1) \\<lless> list.set (concat bs2)\""], ["proof (prove)\nusing this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. list.set (concat bs1) \\<lless> list.set (concat bs2)", "by (force simp: dest: strict_sorted_imp_less_sets)+"], ["proof (state)\nthis:\n  list.set (concat bs1) \\<lless> list.set (concat bs2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (hd []) \\<lless> list.set (concat [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd [concat as]) \\<lless>\n                         list.set (concat [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd (concat as1 # as)) \\<lless>\n                         list.set (concat (concat bs1 # bs))", "have *: \"list.set (concat as1) \\<lless> list.set (concat bs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (concat as1) \\<lless> list.set (concat bs1)", "using App"], ["proof (prove)\nusing this:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. list.set (concat as1) \\<lless> list.set (concat bs1)", "by (metis concat_append strict_sorted_append_iff strict_sorted_imp_less_sets)"], ["proof (state)\nthis:\n  list.set (concat as1) \\<lless> list.set (concat bs1)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (hd []) \\<lless> list.set (concat [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd [concat as]) \\<lless>\n                         list.set (concat [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd (concat as1 # as)) \\<lless>\n                         list.set (concat (concat bs1 # bs))", "then"], ["proof (chain)\npicking this:\n  list.set (concat as1) \\<lless> list.set (concat bs1)", "have \"list.set (concat as1) \\<lless> list.set (concat bs)\""], ["proof (prove)\nusing this:\n  list.set (concat as1) \\<lless> list.set (concat bs1)\n\ngoal (1 subgoal):\n 1. list.set (concat as1) \\<lless> list.set (concat bs)", "using App \\<section> less_sets_trans merge_preserves"], ["proof (prove)\nusing this:\n  list.set (concat as1) \\<lless> list.set (concat bs1)\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   bs2 \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs)\n  strict_sorted (concat (as1 @ as2))\n  strict_sorted (concat (bs1 @ bs2))\n  bs1 @ bs2 \\<in> lists (- {[]})\n  list.set (concat bs1) \\<lless> list.set (concat bs2)\n  \\<lbrakk>?A \\<lless> ?B; ?B \\<lless> ?C; ?B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?A \\<lless> ?C\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  concat ?as = concat ?us \\<and> concat ?bs = concat ?vs\n\ngoal (1 subgoal):\n 1. list.set (concat as1) \\<lless> list.set (concat bs)", "by (metis List.set_empty append_in_lists_conv le_zero_eq length_concat_ge length_greater_0_conv list.size(3))"], ["proof (state)\nthis:\n  list.set (concat as1) \\<lless> list.set (concat bs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (hd []) \\<lless> list.set (concat [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd [concat as]) \\<lless>\n                         list.set (concat [])\n 3. \\<And>as1 bs1 as2 bs2 as bs.\n       \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n        concat bs1 < concat as2; merge as2 bs2 as bs;\n        \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n         bs2 \\<in> lists (- {[]})\\<rbrakk>\n        \\<Longrightarrow> list.set (hd as) \\<lless> list.set (concat bs);\n        strict_sorted (concat (as1 @ as2));\n        strict_sorted (concat (bs1 @ bs2));\n        bs1 @ bs2 \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd (concat as1 # as)) \\<lless>\n                         list.set (concat (concat bs1 # bs))", "with * App.hyps"], ["proof (chain)\npicking this:\n  list.set (concat as1) \\<lless> list.set (concat bs1)\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  list.set (concat as1) \\<lless> list.set (concat bs)", "show ?case"], ["proof (prove)\nusing this:\n  list.set (concat as1) \\<lless> list.set (concat bs1)\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  merge as2 bs2 as bs\n  list.set (concat as1) \\<lless> list.set (concat bs)\n\ngoal (1 subgoal):\n 1. list.set (hd (concat as1 # as)) \\<lless>\n    list.set (concat (concat bs1 # bs))", "by (fastforce simp add: less_sets_UN1 less_sets_UN2 less_sets_Un2)"], ["proof (state)\nthis:\n  list.set (hd (concat as1 # as)) \\<lless>\n  list.set (concat (concat bs1 # bs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); strict_sorted (concat []);\n     [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (hd []) \\<lless> list.set (concat [])\n 2. \\<And>as.\n       \\<lbrakk>as \\<noteq> []; strict_sorted (concat as);\n        strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (hd [concat as]) \\<lless>\n                         list.set (concat [])", "qed auto"], ["", "lemma set_takeWhile:\n  assumes \"strict_sorted (concat as)\" \"as \\<in> lists (- {[]})\"\n  shows \"list.set (takeWhile (\\<lambda>x. x < y) as) = {x \\<in> list.set as. x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (takeWhile (\\<lambda>x. x < y) as) =\n    {x \\<in> list.set as. x < y}", "using assms"], ["proof (prove)\nusing this:\n  strict_sorted (concat as)\n  as \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. list.set (takeWhile (\\<lambda>x. x < y) as) =\n    {x \\<in> list.set as. x < y}", "proof (induction as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) []) =\n                      {x \\<in> list.set []. x < y}\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>strict_sorted (concat as);\n                 as \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> list.set\n                                   (takeWhile (\\<lambda>x. x < y) as) =\n                                  {x \\<in> list.set as. x < y};\n        strict_sorted (concat (a # as));\n        a # as \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) (a # as)) =\n                         {x \\<in> list.set (a # as). x < y}", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>strict_sorted (concat as); as \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) as) =\n                    {x \\<in> list.set as. x < y}\n  strict_sorted (concat (a # as))\n  a # as \\<in> lists (- {[]})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) []) =\n                      {x \\<in> list.set []. x < y}\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>strict_sorted (concat as);\n                 as \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> list.set\n                                   (takeWhile (\\<lambda>x. x < y) as) =\n                                  {x \\<in> list.set as. x < y};\n        strict_sorted (concat (a # as));\n        a # as \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) (a # as)) =\n                         {x \\<in> list.set (a # as). x < y}", "have *: \"a < y\"\n    if a: \"a < concat as\" \"strict_sorted a\" \"strict_sorted (concat as)\" \"x < y\" \"x \\<noteq> []\" \"x \\<in> list.set as\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a < y", "have \"last x \\<in> list.set (concat as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last x \\<in> list.set (concat as)", "using set_concat that(5) that(6)"], ["proof (prove)\nusing this:\n  list.set (concat ?xs) = \\<Union> (list.set ` list.set ?xs)\n  x \\<noteq> []\n  x \\<in> list.set as\n\ngoal (1 subgoal):\n 1. last x \\<in> list.set (concat as)", "by fastforce"], ["proof (state)\nthis:\n  last x \\<in> list.set (concat as)\n\ngoal (1 subgoal):\n 1. a < y", "then"], ["proof (chain)\npicking this:\n  last x \\<in> list.set (concat as)", "have \"last a < hd (concat as)\""], ["proof (prove)\nusing this:\n  last x \\<in> list.set (concat as)\n\ngoal (1 subgoal):\n 1. last a < hd (concat as)", "using Cons.prems that"], ["proof (prove)\nusing this:\n  last x \\<in> list.set (concat as)\n  strict_sorted (concat (a # as))\n  a # as \\<in> lists (- {[]})\n  a < concat as\n  strict_sorted a\n  strict_sorted (concat as)\n  x < y\n  x \\<noteq> []\n  x \\<in> list.set as\n\ngoal (1 subgoal):\n 1. last a < hd (concat as)", "by (auto simp: less_list_def)"], ["proof (state)\nthis:\n  last a < hd (concat as)\n\ngoal (1 subgoal):\n 1. a < y", "also"], ["proof (state)\nthis:\n  last a < hd (concat as)\n\ngoal (1 subgoal):\n 1. a < y", "have \"\\<dots> \\<le> hd y\" if \"y \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (concat as) \\<le> hd y", "using that a"], ["proof (prove)\nusing this:\n  y \\<noteq> []\n  a < concat as\n  strict_sorted a\n  strict_sorted (concat as)\n  x < y\n  x \\<noteq> []\n  x \\<in> list.set as\n\ngoal (1 subgoal):\n 1. hd (concat as) \\<le> hd y", "by (meson \\<open>last x \\<in> list.set (concat as)\\<close> dual_order.strict_trans less_list_def not_le sorted_hd_le strict_sorted_imp_sorted)"], ["proof (state)\nthis:\n  y \\<noteq> [] \\<Longrightarrow> hd (concat as) \\<le> hd y\n\ngoal (1 subgoal):\n 1. a < y", "finally"], ["proof (chain)\npicking this:\n  y \\<noteq> [] \\<Longrightarrow> last a < hd y", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<noteq> [] \\<Longrightarrow> last a < hd y\n\ngoal (1 subgoal):\n 1. a < y", "by (simp add: less_list_def)"], ["proof (state)\nthis:\n  a < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a < concat as; strict_sorted a; strict_sorted (concat as);\n   ?x < y; ?x \\<noteq> []; ?x \\<in> list.set as\\<rbrakk>\n  \\<Longrightarrow> a < y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) []) =\n                      {x \\<in> list.set []. x < y}\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>strict_sorted (concat as);\n                 as \\<in> lists (- {[]})\\<rbrakk>\n                \\<Longrightarrow> list.set\n                                   (takeWhile (\\<lambda>x. x < y) as) =\n                                  {x \\<in> list.set as. x < y};\n        strict_sorted (concat (a # as));\n        a # as \\<in> lists (- {[]})\\<rbrakk>\n       \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) (a # as)) =\n                         {x \\<in> list.set (a # as). x < y}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a < concat as; strict_sorted a; strict_sorted (concat as);\n   ?x < y; ?x \\<noteq> []; ?x \\<in> list.set as\\<rbrakk>\n  \\<Longrightarrow> a < y", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < concat as; strict_sorted a; strict_sorted (concat as);\n   ?x < y; ?x \\<noteq> []; ?x \\<in> list.set as\\<rbrakk>\n  \\<Longrightarrow> a < y\n\ngoal (1 subgoal):\n 1. list.set (takeWhile (\\<lambda>x. x < y) (a # as)) =\n    {x \\<in> list.set (a # as). x < y}", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < concat as; strict_sorted a; strict_sorted (concat as);\n   ?x < y; ?x \\<noteq> []; ?x \\<in> list.set as\\<rbrakk>\n  \\<Longrightarrow> a < y\n  \\<lbrakk>strict_sorted (concat as); as \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) as) =\n                    {x \\<in> list.set as. x < y}\n  strict_sorted (concat (a # as))\n  a # as \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. list.set (takeWhile (\\<lambda>x. x < y) (a # as)) =\n    {x \\<in> list.set (a # as). x < y}", "by (auto simp: strict_sorted_append_iff)"], ["proof (state)\nthis:\n  list.set (takeWhile (\\<lambda>x. x < y) (a # as)) =\n  {x \\<in> list.set (a # as). x < y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_sorted (concat []); [] \\<in> lists (- {[]})\\<rbrakk>\n    \\<Longrightarrow> list.set (takeWhile (\\<lambda>x. x < y) []) =\n                      {x \\<in> list.set []. x < y}", "qed auto"], ["", "proposition merge_exists:\n  assumes \"strict_sorted (concat as)\" \"strict_sorted (concat bs)\"\n          \"as \\<in> lists (- {[]})\" \"bs \\<in> lists (- {[]})\"\n          \"hd as < hd bs\" \"as \\<noteq> []\" \"bs \\<noteq> []\"\n  and disj: \"\\<And>a b. \\<lbrakk>a \\<in> list.set as; b \\<in> list.set bs\\<rbrakk> \\<Longrightarrow> a<b \\<or> b<a\"\nshows \"\\<exists>us vs. merge as bs us vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us vs. merge as bs us vs", "using assms"], ["proof (prove)\nusing this:\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  hd as < hd bs\n  as \\<noteq> []\n  bs \\<noteq> []\n  \\<lbrakk>?a \\<in> list.set as; ?b \\<in> list.set bs\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a\n\ngoal (1 subgoal):\n 1. \\<exists>us vs. merge as bs us vs", "proof (induction \"length as + length bs\" arbitrary: as bs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>\\<And>asa bsa.\n                   \\<lbrakk>length asa + length bsa < length as + length bs;\n                    strict_sorted (concat asa); strict_sorted (concat bsa);\n                    asa \\<in> lists (- {[]}); bsa \\<in> lists (- {[]});\n                    hd asa < hd bsa; asa \\<noteq> []; bsa \\<noteq> [];\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> list.set asa;\n                        b \\<in> list.set bsa\\<rbrakk>\n                       \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>us. Ex (merge asa bsa us);\n        strict_sorted (concat as); strict_sorted (concat bs);\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]}); hd as < hd bs;\n        as \\<noteq> []; bs \\<noteq> [];\n        \\<And>a b.\n           \\<lbrakk>a \\<in> list.set as; b \\<in> list.set bs\\<rbrakk>\n           \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us. Ex (merge as bs us)", "case (less as bs)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?as + length ?bs < length as + length bs;\n   strict_sorted (concat ?as); strict_sorted (concat ?bs);\n   ?as \\<in> lists (- {[]}); ?bs \\<in> lists (- {[]}); hd ?as < hd ?bs;\n   ?as \\<noteq> []; ?bs \\<noteq> [];\n   \\<And>a b.\n      \\<lbrakk>a \\<in> list.set ?as; b \\<in> list.set ?bs\\<rbrakk>\n      \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>us. Ex (merge ?as ?bs us)\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  hd as < hd bs\n  as \\<noteq> []\n  bs \\<noteq> []\n  \\<lbrakk>?a \\<in> list.set as; ?b \\<in> list.set bs\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>\\<And>asa bsa.\n                   \\<lbrakk>length asa + length bsa < length as + length bs;\n                    strict_sorted (concat asa); strict_sorted (concat bsa);\n                    asa \\<in> lists (- {[]}); bsa \\<in> lists (- {[]});\n                    hd asa < hd bsa; asa \\<noteq> []; bsa \\<noteq> [];\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> list.set asa;\n                        b \\<in> list.set bsa\\<rbrakk>\n                       \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>us. Ex (merge asa bsa us);\n        strict_sorted (concat as); strict_sorted (concat bs);\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]}); hd as < hd bs;\n        as \\<noteq> []; bs \\<noteq> [];\n        \\<And>a b.\n           \\<lbrakk>a \\<in> list.set as; b \\<in> list.set bs\\<rbrakk>\n           \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us. Ex (merge as bs us)", "obtain as1 as2 bs1 bs2\n    where A: \"as1 \\<noteq> []\" \"bs1 \\<noteq> []\" \"concat as1 < concat bs1\" \"concat bs1 < concat as2\"\n      and B: \"as = as1@as2\" \"bs = bs1@bs2\" and C: \"bs2 = [] \\<or> (as2 \\<noteq> [] \\<and> hd as2 < hd bs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "define as1 where \"as1 \\<equiv> takeWhile (\\<lambda>x. x < hd bs) as\""], ["proof (state)\nthis:\n  as1 \\<equiv> takeWhile (\\<lambda>x. x < hd bs) as\n\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "define as2 where \"as2 \\<equiv> dropWhile (\\<lambda>x. x < hd bs) as\""], ["proof (state)\nthis:\n  as2 \\<equiv> dropWhile (\\<lambda>x. x < hd bs) as\n\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "define bs1 where \"bs1 \\<equiv> if as2=[] then bs else takeWhile (\\<lambda>x. x < hd as2) bs\""], ["proof (state)\nthis:\n  bs1 \\<equiv>\n  if as2 = [] then bs else takeWhile (\\<lambda>x. x < hd as2) bs\n\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "define bs2 where \"bs2 \\<equiv> if as2=[] then [] else dropWhile (\\<lambda>x. x < hd as2) bs\""], ["proof (state)\nthis:\n  bs2 \\<equiv>\n  if as2 = [] then [] else dropWhile (\\<lambda>x. x < hd as2) bs\n\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "have as1: \"as1 = takeWhile (\\<lambda>x. last x < hd (hd bs)) as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as1 = takeWhile (\\<lambda>x. last x < hd (hd bs)) as", "using less.prems"], ["proof (prove)\nusing this:\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  hd as < hd bs\n  as \\<noteq> []\n  bs \\<noteq> []\n  \\<lbrakk>?a \\<in> list.set as; ?b \\<in> list.set bs\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a\n\ngoal (1 subgoal):\n 1. as1 = takeWhile (\\<lambda>x. last x < hd (hd bs)) as", "by (auto simp: as1_def less_list_def cong: takeWhile_cong)"], ["proof (state)\nthis:\n  as1 = takeWhile (\\<lambda>x. last x < hd (hd bs)) as\n\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "have as2: \"as2 = dropWhile (\\<lambda>x. last x < hd (hd bs)) as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as2 = dropWhile (\\<lambda>x. last x < hd (hd bs)) as", "using less.prems"], ["proof (prove)\nusing this:\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  hd as < hd bs\n  as \\<noteq> []\n  bs \\<noteq> []\n  \\<lbrakk>?a \\<in> list.set as; ?b \\<in> list.set bs\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a\n\ngoal (1 subgoal):\n 1. as2 = dropWhile (\\<lambda>x. last x < hd (hd bs)) as", "by (auto simp: as2_def less_list_def cong: dropWhile_cong)"], ["proof (state)\nthis:\n  as2 = dropWhile (\\<lambda>x. last x < hd (hd bs)) as\n\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "have hd_as2: \"as2 \\<noteq> [] \\<Longrightarrow> \\<not> hd as2 < hd bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as2 \\<noteq> [] \\<Longrightarrow> \\<not> hd as2 < hd bs", "using as2_def hd_dropWhile"], ["proof (prove)\nusing this:\n  as2 \\<equiv> dropWhile (\\<lambda>x. x < hd bs) as\n  dropWhile ?P ?xs \\<noteq> [] \\<Longrightarrow>\n  \\<not> ?P (hd (dropWhile ?P ?xs))\n\ngoal (1 subgoal):\n 1. as2 \\<noteq> [] \\<Longrightarrow> \\<not> hd as2 < hd bs", "by metis"], ["proof (state)\nthis:\n  as2 \\<noteq> [] \\<Longrightarrow> \\<not> hd as2 < hd bs\n\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "have hd_bs2: \"bs2 \\<noteq> [] \\<Longrightarrow> \\<not> hd bs2 < hd as2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs2 \\<noteq> [] \\<Longrightarrow> \\<not> hd bs2 < hd as2", "using bs2_def hd_dropWhile"], ["proof (prove)\nusing this:\n  bs2 \\<equiv>\n  if as2 = [] then [] else dropWhile (\\<lambda>x. x < hd as2) bs\n  dropWhile ?P ?xs \\<noteq> [] \\<Longrightarrow>\n  \\<not> ?P (hd (dropWhile ?P ?xs))\n\ngoal (1 subgoal):\n 1. bs2 \\<noteq> [] \\<Longrightarrow> \\<not> hd bs2 < hd as2", "by metis"], ["proof (state)\nthis:\n  bs2 \\<noteq> [] \\<Longrightarrow> \\<not> hd bs2 < hd as2\n\ngoal (7 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?as1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?as1.2 < concat ?bs1.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = ?as1.2 @ ?as2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 7. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "show \"as1 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as1 \\<noteq> []", "by (simp add: as1_def less.prems takeWhile_eq_Nil_iff)"], ["proof (state)\nthis:\n  as1 \\<noteq> []\n\ngoal (6 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs1.2 \\<noteq> []\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat (takeWhile (\\<lambda>x. x < hd bs) as) < concat ?bs1.2\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat ?bs1.2 < concat ?as2.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = takeWhile (\\<lambda>x. x < hd bs) as @ ?as2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs = ?bs1.2 @ ?bs2.2\n 6. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "show \"bs1 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs1 \\<noteq> []", "by (metis as2 bs1_def hd_as2 hd_in_set less.prems(7) less.prems(8) set_dropWhileD takeWhile_eq_Nil_iff)"], ["proof (state)\nthis:\n  bs1 \\<noteq> []\n\ngoal (5 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat (takeWhile (\\<lambda>x. x < hd bs) as)\n    < concat\n       (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n        else takeWhile\n              (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as))\n              bs)\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat\n     (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n      else takeWhile\n            (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)\n    < concat ?as2.2\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as = takeWhile (\\<lambda>x. x < hd bs) as @ ?as2.2\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs =\n    (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n     else takeWhile\n           (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs) @\n    ?bs2.2\n 5. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?bs2.2 = [] \\<or> ?as2.2 \\<noteq> [] \\<and> hd ?as2.2 < hd ?bs2.2", "show \"bs2 = [] \\<or> (as2 \\<noteq> [] \\<and> hd as2 < hd bs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2", "by (metis as2_def bs2_def hd_bs2 less.prems(8) list.set_sel(1) set_dropWhileD)"], ["proof (state)\nthis:\n  bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\n\ngoal (4 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat (takeWhile (\\<lambda>x. x < hd bs) as)\n    < concat\n       (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n        else takeWhile\n              (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as))\n              bs)\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat\n     (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n      else takeWhile\n            (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)\n    < concat (dropWhile (\\<lambda>x. x < hd bs) as)\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as =\n    takeWhile (\\<lambda>x. x < hd bs) as @\n    dropWhile (\\<lambda>x. x < hd bs) as\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs =\n    (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n     else takeWhile\n           (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs) @\n    (if dropWhile (\\<lambda>x. x < hd bs) as = [] then []\n     else dropWhile\n           (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)", "have AB: \"list.set A \\<lless> list.set B\"\n      if \"A \\<in> list.set as1\" \"B \\<in> list.set bs\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set A \\<lless> list.set B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list.set A \\<lless> list.set B", "have \"A \\<in> list.set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> list.set as", "using that"], ["proof (prove)\nusing this:\n  A \\<in> list.set as1\n  B \\<in> list.set bs\n\ngoal (1 subgoal):\n 1. A \\<in> list.set as", "by (metis as1 set_takeWhileD)"], ["proof (state)\nthis:\n  A \\<in> list.set as\n\ngoal (1 subgoal):\n 1. list.set A \\<lless> list.set B", "then"], ["proof (chain)\npicking this:\n  A \\<in> list.set as", "have \"sorted A\""], ["proof (prove)\nusing this:\n  A \\<in> list.set as\n\ngoal (1 subgoal):\n 1. sorted A", "by (metis concat.simps(2) concat_append less.prems(1) sorted_append split_list_last strict_sorted_imp_sorted)"], ["proof (state)\nthis:\n  sorted A\n\ngoal (1 subgoal):\n 1. list.set A \\<lless> list.set B", "moreover"], ["proof (state)\nthis:\n  sorted A\n\ngoal (1 subgoal):\n 1. list.set A \\<lless> list.set B", "have \"sorted (hd bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (hd bs)", "by (metis concat.simps(2) hd_Cons_tl less.prems(2) less.prems(7) strict_sorted_append_iff strict_sorted_imp_sorted)"], ["proof (state)\nthis:\n  sorted (hd bs)\n\ngoal (1 subgoal):\n 1. list.set A \\<lless> list.set B", "ultimately"], ["proof (chain)\npicking this:\n  sorted A\n  sorted (hd bs)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted A\n  sorted (hd bs)\n\ngoal (1 subgoal):\n 1. list.set A \\<lless> list.set B", "using that"], ["proof (prove)\nusing this:\n  sorted A\n  sorted (hd bs)\n  A \\<in> list.set as1\n  B \\<in> list.set bs\n\ngoal (1 subgoal):\n 1. list.set A \\<lless> list.set B", "apply (clarsimp simp add: as1_def less.prems set_takeWhile less_list_iff_less_sets less_sets_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>sorted A; sorted (hd bs); B \\<in> list.set bs;\n        x \\<in> list.set A; y \\<in> list.set B; A \\<in> list.set as;\n        \\<forall>x\\<in>list.set A.\n           \\<forall>y\\<in>list.set (hd bs). x < y\\<rbrakk>\n       \\<Longrightarrow> x < y", "by (smt UN_I dual_order.strict_trans2 hd_concat less.prems(2) less.prems(4) less.prems(7) list.set_sel(1) mem_lists_non_Nil not_le set_concat sorted_hd_le strict_sorted_imp_sorted)"], ["proof (state)\nthis:\n  list.set A \\<lless> list.set B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> list.set as1; ?B \\<in> list.set bs\\<rbrakk>\n  \\<Longrightarrow> list.set ?A \\<lless> list.set ?B\n\ngoal (4 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat (takeWhile (\\<lambda>x. x < hd bs) as)\n    < concat\n       (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n        else takeWhile\n              (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as))\n              bs)\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat\n     (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n      else takeWhile\n            (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)\n    < concat (dropWhile (\\<lambda>x. x < hd bs) as)\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    as =\n    takeWhile (\\<lambda>x. x < hd bs) as @\n    dropWhile (\\<lambda>x. x < hd bs) as\n 4. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs =\n    (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n     else takeWhile\n           (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs) @\n    (if dropWhile (\\<lambda>x. x < hd bs) as = [] then []\n     else dropWhile\n           (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)", "show \"as = as1@as2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as = as1 @ as2", "by (simp add: as1_def as2_def)"], ["proof (state)\nthis:\n  as = as1 @ as2\n\ngoal (3 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat (takeWhile (\\<lambda>x. x < hd bs) as)\n    < concat\n       (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n        else takeWhile\n              (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as))\n              bs)\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat\n     (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n      else takeWhile\n            (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)\n    < concat (dropWhile (\\<lambda>x. x < hd bs) as)\n 3. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bs =\n    (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n     else takeWhile\n           (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs) @\n    (if dropWhile (\\<lambda>x. x < hd bs) as = [] then []\n     else dropWhile\n           (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)", "show \"bs = bs1@bs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs = bs1 @ bs2", "by (simp add: bs1_def bs2_def)"], ["proof (state)\nthis:\n  bs = bs1 @ bs2\n\ngoal (2 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat (takeWhile (\\<lambda>x. x < hd bs) as)\n    < concat\n       (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n        else takeWhile\n              (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as))\n              bs)\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat\n     (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n      else takeWhile\n            (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)\n    < concat (dropWhile (\\<lambda>x. x < hd bs) as)", "have \"list.set (concat as1) \\<lless> list.set (concat bs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (concat as1) \\<lless> list.set (concat bs1)", "using AB set_takeWhileD"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> list.set as1; ?B \\<in> list.set bs\\<rbrakk>\n  \\<Longrightarrow> list.set ?A \\<lless> list.set ?B\n  ?x \\<in> list.set (takeWhile ?P ?xs) \\<Longrightarrow>\n  ?x \\<in> list.set ?xs \\<and> ?P ?x\n\ngoal (1 subgoal):\n 1. list.set (concat as1) \\<lless> list.set (concat bs1)", "by (fastforce simp add: as1_def bs1_def less_sets_UN1 less_sets_UN2)"], ["proof (state)\nthis:\n  list.set (concat as1) \\<lless> list.set (concat bs1)\n\ngoal (2 subgoals):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat (takeWhile (\\<lambda>x. x < hd bs) as)\n    < concat\n       (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n        else takeWhile\n              (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as))\n              bs)\n 2. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat\n     (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n      else takeWhile\n            (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)\n    < concat (dropWhile (\\<lambda>x. x < hd bs) as)", "then"], ["proof (chain)\npicking this:\n  list.set (concat as1) \\<lless> list.set (concat bs1)", "show \"concat as1 < concat bs1\""], ["proof (prove)\nusing this:\n  list.set (concat as1) \\<lless> list.set (concat bs1)\n\ngoal (1 subgoal):\n 1. concat as1 < concat bs1", "by (rule less_sets_imp_list_less)"], ["proof (state)\nthis:\n  concat as1 < concat bs1\n\ngoal (1 subgoal):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat\n     (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n      else takeWhile\n            (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)\n    < concat (dropWhile (\\<lambda>x. x < hd bs) as)", "have \"list.set (concat bs1) \\<lless> list.set (concat as2)\" if \"as2 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (concat bs1) \\<lless> list.set (concat as2)", "proof (clarsimp simp add: bs1_def less_sets_UN1 less_sets_UN2 set_takeWhile less.prems)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B A.\n       \\<lbrakk>as2 \\<noteq> []; B \\<in> list.set as2; A \\<in> list.set bs;\n        A < hd as2\\<rbrakk>\n       \\<Longrightarrow> list.set A \\<lless> list.set B", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B A.\n       \\<lbrakk>as2 \\<noteq> []; B \\<in> list.set as2; A \\<in> list.set bs;\n        A < hd as2\\<rbrakk>\n       \\<Longrightarrow> list.set A \\<lless> list.set B", "assume \"A \\<in> list.set as2\" \"B \\<in> list.set bs\" \"B < hd as2\""], ["proof (state)\nthis:\n  A \\<in> list.set as2\n  B \\<in> list.set bs\n  B < hd as2\n\ngoal (1 subgoal):\n 1. \\<And>B A.\n       \\<lbrakk>as2 \\<noteq> []; B \\<in> list.set as2; A \\<in> list.set bs;\n        A < hd as2\\<rbrakk>\n       \\<Longrightarrow> list.set A \\<lless> list.set B", "with that"], ["proof (chain)\npicking this:\n  as2 \\<noteq> []\n  A \\<in> list.set as2\n  B \\<in> list.set bs\n  B < hd as2", "show \"list.set B \\<lless> list.set A\""], ["proof (prove)\nusing this:\n  as2 \\<noteq> []\n  A \\<in> list.set as2\n  B \\<in> list.set bs\n  B < hd as2\n\ngoal (1 subgoal):\n 1. list.set B \\<lless> list.set A", "using hd_as2 less.prems(1,2)"], ["proof (prove)\nusing this:\n  as2 \\<noteq> []\n  A \\<in> list.set as2\n  B \\<in> list.set bs\n  B < hd as2\n  as2 \\<noteq> [] \\<Longrightarrow> \\<not> hd as2 < hd bs\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n\ngoal (1 subgoal):\n 1. list.set B \\<lless> list.set A", "apply (clarsimp simp add: less_sets_def less_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>as2 \\<noteq> []; A \\<in> list.set as2; B \\<in> list.set bs;\n        B \\<noteq> [] \\<longrightarrow> last B < hd (hd as2);\n        strict_sorted (concat as); strict_sorted (concat bs);\n        x \\<in> list.set B; y \\<in> list.set A; hd as2 \\<noteq> [];\n        hd bs \\<noteq> []; \\<not> last (hd as2) < hd (hd bs)\\<rbrakk>\n       \\<Longrightarrow> x < y", "apply (auto simp: as2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>A \\<in> list.set (dropWhile (\\<lambda>x. x < hd bs) as);\n        B \\<in> list.set bs; strict_sorted (concat as);\n        strict_sorted (concat bs); x \\<in> list.set B; y \\<in> list.set A;\n        hd (dropWhile (\\<lambda>x. x < hd bs) as) \\<noteq> [];\n        hd bs \\<noteq> [];\n        \\<not> last (hd (dropWhile (\\<lambda>x. x < hd bs) as))\n               < hd (hd bs);\n        xa \\<in> list.set as; \\<not> xa < hd bs;\n        last B < hd (hd (dropWhile (\\<lambda>x. x < hd bs) as))\\<rbrakk>\n       \\<Longrightarrow> x < y", "apply (simp flip: as2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>A \\<in> list.set as2; B \\<in> list.set bs;\n        strict_sorted (concat as); strict_sorted (concat bs);\n        x \\<in> list.set B; y \\<in> list.set A; hd as2 \\<noteq> [];\n        hd bs \\<noteq> []; \\<not> last (hd as2) < hd (hd bs);\n        xa \\<in> list.set as; \\<not> xa < hd bs;\n        last B < hd (hd as2)\\<rbrakk>\n       \\<Longrightarrow> x < y", "by (metis UN_I \\<open>as = as1 @ as2\\<close> concat.simps(2) concat_append dual_order.strict_trans2 hd_concat in_set_conv_decomp_last not_le set_concat sorted_hd_le sorted_le_last sorted_sorted_wrt sorted_wrt_append strict_sorted_imp_sorted that)"], ["proof (state)\nthis:\n  list.set B \\<lless> list.set A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  as2 \\<noteq> [] \\<Longrightarrow>\n  list.set (concat bs1) \\<lless> list.set (concat as2)\n\ngoal (1 subgoal):\n 1. (\\<And>as1 bs1 as2 bs2.\n        \\<lbrakk>as1 \\<noteq> []; bs1 \\<noteq> []; concat as1 < concat bs1;\n         concat bs1 < concat as2; as = as1 @ as2; bs = bs1 @ bs2;\n         bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    concat\n     (if dropWhile (\\<lambda>x. x < hd bs) as = [] then bs\n      else takeWhile\n            (\\<lambda>x. x < hd (dropWhile (\\<lambda>x. x < hd bs) as)) bs)\n    < concat (dropWhile (\\<lambda>x. x < hd bs) as)", "then"], ["proof (chain)\npicking this:\n  as2 \\<noteq> [] \\<Longrightarrow>\n  list.set (concat bs1) \\<lless> list.set (concat as2)", "show \"concat bs1 < concat as2\""], ["proof (prove)\nusing this:\n  as2 \\<noteq> [] \\<Longrightarrow>\n  list.set (concat bs1) \\<lless> list.set (concat as2)\n\ngoal (1 subgoal):\n 1. concat bs1 < concat as2", "by (simp add: bs1_def less_sets_imp_list_less)"], ["proof (state)\nthis:\n  concat bs1 < concat as2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  as = as1 @ as2\n  bs = bs1 @ bs2\n  bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>\\<And>asa bsa.\n                   \\<lbrakk>length asa + length bsa < length as + length bs;\n                    strict_sorted (concat asa); strict_sorted (concat bsa);\n                    asa \\<in> lists (- {[]}); bsa \\<in> lists (- {[]});\n                    hd asa < hd bsa; asa \\<noteq> []; bsa \\<noteq> [];\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> list.set asa;\n                        b \\<in> list.set bsa\\<rbrakk>\n                       \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>us. Ex (merge asa bsa us);\n        strict_sorted (concat as); strict_sorted (concat bs);\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]}); hd as < hd bs;\n        as \\<noteq> []; bs \\<noteq> [];\n        \\<And>a b.\n           \\<lbrakk>a \\<in> list.set as; b \\<in> list.set bs\\<rbrakk>\n           \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us. Ex (merge as bs us)", "obtain cs ds where \"merge as2 bs2 cs ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs ds.\n        merge as2 bs2 cs ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"as2 = [] \\<or> bs2 = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     as2 = [] \\<or> bs2 = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     \\<not> (as2 = [] \\<or> bs2 = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  as2 = [] \\<or> bs2 = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     as2 = [] \\<or> bs2 = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     \\<not> (as2 = [] \\<or> bs2 = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  as2 = [] \\<or> bs2 = []", "show thesis"], ["proof (prove)\nusing this:\n  as2 = [] \\<or> bs2 = []\n\ngoal (1 subgoal):\n 1. thesis", "using that C NullNull Null"], ["proof (prove)\nusing this:\n  as2 = [] \\<or> bs2 = []\n  merge as2 bs2 ?cs ?ds \\<Longrightarrow> thesis\n  bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\n  merge [] [] [] []\n  ?as \\<noteq> [] \\<Longrightarrow> merge ?as [] [concat ?as] []\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     \\<not> (as2 = [] \\<or> bs2 = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     \\<not> (as2 = [] \\<or> bs2 = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \\<dagger>: \"length as2 + length bs2 < length as + length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as2 + length bs2 < length as + length bs", "by (simp add: A B)"], ["proof (state)\nthis:\n  length as2 + length bs2 < length as + length bs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     \\<not> (as2 = [] \\<or> bs2 = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> (as2 = [] \\<or> bs2 = [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     \\<not> (as2 = [] \\<or> bs2 = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<not> (as2 = [] \\<or> bs2 = [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     \\<not> (as2 = [] \\<or> bs2 = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"strict_sorted (concat as2)\" \"strict_sorted (concat bs2)\"\n      \"as2 \\<in> lists (- {[]})\" \"bs2 \\<in> lists (- {[]})\"\n      \"\\<And>a b. \\<lbrakk>a \\<in> list.set as2; b \\<in> list.set bs2\\<rbrakk> \\<Longrightarrow> a < b \\<or> b < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (strict_sorted (concat as2) &&& strict_sorted (concat bs2)) &&&\n    as2 \\<in> lists (- {[]}) &&&\n    bs2 \\<in> lists (- {[]}) &&&\n    (\\<And>a b.\n        \\<lbrakk>a \\<in> list.set as2; b \\<in> list.set bs2\\<rbrakk>\n        \\<Longrightarrow> a < b \\<or> b < a)", "using B less.prems strict_sorted_append_iff"], ["proof (prove)\nusing this:\n  as = as1 @ as2\n  bs = bs1 @ bs2\n  strict_sorted (concat as)\n  strict_sorted (concat bs)\n  as \\<in> lists (- {[]})\n  bs \\<in> lists (- {[]})\n  hd as < hd bs\n  as \\<noteq> []\n  bs \\<noteq> []\n  \\<lbrakk>?a \\<in> list.set as; ?b \\<in> list.set bs\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a\n  strict_sorted (?xs @ ?ys) =\n  (?xs < ?ys \\<and> strict_sorted ?xs \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. (strict_sorted (concat as2) &&& strict_sorted (concat bs2)) &&&\n    as2 \\<in> lists (- {[]}) &&&\n    bs2 \\<in> lists (- {[]}) &&&\n    (\\<And>a b.\n        \\<lbrakk>a \\<in> list.set as2; b \\<in> list.set bs2\\<rbrakk>\n        \\<Longrightarrow> a < b \\<or> b < a)", "by auto"], ["proof (state)\nthis:\n  strict_sorted (concat as2)\n  strict_sorted (concat bs2)\n  as2 \\<in> lists (- {[]})\n  bs2 \\<in> lists (- {[]})\n  \\<lbrakk>?a \\<in> list.set as2; ?b \\<in> list.set bs2\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>cs ds. merge as2 bs2 cs ds \\<Longrightarrow> thesis;\n     \\<not> (as2 = [] \\<or> bs2 = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (as2 = [] \\<or> bs2 = [])\n  strict_sorted (concat as2)\n  strict_sorted (concat bs2)\n  as2 \\<in> lists (- {[]})\n  bs2 \\<in> lists (- {[]})\n  \\<lbrakk>?a \\<in> list.set as2; ?b \\<in> list.set bs2\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (as2 = [] \\<or> bs2 = [])\n  strict_sorted (concat as2)\n  strict_sorted (concat bs2)\n  as2 \\<in> lists (- {[]})\n  bs2 \\<in> lists (- {[]})\n  \\<lbrakk>?a \\<in> list.set as2; ?b \\<in> list.set bs2\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a\n\ngoal (1 subgoal):\n 1. thesis", "using C less.hyps [OF \\<dagger>] False that"], ["proof (prove)\nusing this:\n  \\<not> (as2 = [] \\<or> bs2 = [])\n  strict_sorted (concat as2)\n  strict_sorted (concat bs2)\n  as2 \\<in> lists (- {[]})\n  bs2 \\<in> lists (- {[]})\n  \\<lbrakk>?a \\<in> list.set as2; ?b \\<in> list.set bs2\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b \\<or> ?b < ?a\n  bs2 = [] \\<or> as2 \\<noteq> [] \\<and> hd as2 < hd bs2\n  \\<lbrakk>strict_sorted (concat as2); strict_sorted (concat bs2);\n   as2 \\<in> lists (- {[]}); bs2 \\<in> lists (- {[]}); hd as2 < hd bs2;\n   as2 \\<noteq> []; bs2 \\<noteq> [];\n   \\<And>a b.\n      \\<lbrakk>a \\<in> list.set as2; b \\<in> list.set bs2\\<rbrakk>\n      \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>us. Ex (merge as2 bs2 us)\n  \\<not> (as2 = [] \\<or> bs2 = [])\n  merge as2 bs2 ?cs ?ds \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by force"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge as2 bs2 cs ds\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>\\<And>asa bsa.\n                   \\<lbrakk>length asa + length bsa < length as + length bs;\n                    strict_sorted (concat asa); strict_sorted (concat bsa);\n                    asa \\<in> lists (- {[]}); bsa \\<in> lists (- {[]});\n                    hd asa < hd bsa; asa \\<noteq> []; bsa \\<noteq> [];\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> list.set asa;\n                        b \\<in> list.set bsa\\<rbrakk>\n                       \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>us. Ex (merge asa bsa us);\n        strict_sorted (concat as); strict_sorted (concat bs);\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]}); hd as < hd bs;\n        as \\<noteq> []; bs \\<noteq> [];\n        \\<And>a b.\n           \\<lbrakk>a \\<in> list.set as; b \\<in> list.set bs\\<rbrakk>\n           \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us. Ex (merge as bs us)", "then"], ["proof (chain)\npicking this:\n  merge as2 bs2 cs ds", "obtain cs where \"merge (as1 @ as2) (bs1 @ bs2) (concat as1 # cs) (concat bs1 # ds)\""], ["proof (prove)\nusing this:\n  merge as2 bs2 cs ds\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        merge (as1 @ as2) (bs1 @ bs2) (concat as1 # cs)\n         (concat bs1 # ds) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using A merge.App"], ["proof (prove)\nusing this:\n  merge as2 bs2 cs ds\n  as1 \\<noteq> []\n  bs1 \\<noteq> []\n  concat as1 < concat bs1\n  concat bs1 < concat as2\n  \\<lbrakk>?as1.0 \\<noteq> []; ?bs1.0 \\<noteq> [];\n   concat ?as1.0 < concat ?bs1.0; concat ?bs1.0 < concat ?as2.0;\n   merge ?as2.0 ?bs2.0 ?as ?bs\\<rbrakk>\n  \\<Longrightarrow> merge (?as1.0 @ ?as2.0) (?bs1.0 @ ?bs2.0)\n                     (concat ?as1.0 # ?as) (concat ?bs1.0 # ?bs)\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        merge (as1 @ as2) (bs1 @ bs2) (concat as1 # cs)\n         (concat bs1 # ds) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  merge (as1 @ as2) (bs1 @ bs2) (concat as1 # cs) (concat bs1 # ds)\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>\\<And>asa bsa.\n                   \\<lbrakk>length asa + length bsa < length as + length bs;\n                    strict_sorted (concat asa); strict_sorted (concat bsa);\n                    asa \\<in> lists (- {[]}); bsa \\<in> lists (- {[]});\n                    hd asa < hd bsa; asa \\<noteq> []; bsa \\<noteq> [];\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> list.set asa;\n                        b \\<in> list.set bsa\\<rbrakk>\n                       \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>us. Ex (merge asa bsa us);\n        strict_sorted (concat as); strict_sorted (concat bs);\n        as \\<in> lists (- {[]}); bs \\<in> lists (- {[]}); hd as < hd bs;\n        as \\<noteq> []; bs \\<noteq> [];\n        \\<And>a b.\n           \\<lbrakk>a \\<in> list.set as; b \\<in> list.set bs\\<rbrakk>\n           \\<Longrightarrow> a < b \\<or> b < a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us. Ex (merge as bs us)", "then"], ["proof (chain)\npicking this:\n  merge (as1 @ as2) (bs1 @ bs2) (concat as1 # cs) (concat bs1 # ds)", "show ?case"], ["proof (prove)\nusing this:\n  merge (as1 @ as2) (bs1 @ bs2) (concat as1 # cs) (concat bs1 # ds)\n\ngoal (1 subgoal):\n 1. \\<exists>us. Ex (merge as bs us)", "using B"], ["proof (prove)\nusing this:\n  merge (as1 @ as2) (bs1 @ bs2) (concat as1 # cs) (concat bs1 # ds)\n  as = as1 @ as2\n  bs = bs1 @ bs2\n\ngoal (1 subgoal):\n 1. \\<exists>us. Ex (merge as bs us)", "by blast"], ["proof (state)\nthis:\n  \\<exists>us. Ex (merge as bs us)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Actual proof of lemma 3.8\\<close>"], ["", "text \\<open>Lemma 3.8 of Jean A. Larson, ibid.\\<close>"], ["", "proposition lemma_3_8:\n  assumes \"infinite N\"\n  obtains X where \"X \\<subseteq> WW\" \"ordertype X (lenlex less_than) = \\<omega>\\<up>\\<omega>\"\n            \"\\<And>u. u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                   \\<exists>l. Form l u \\<and> (l > 0 \\<longrightarrow> [enum N l] < inter_scheme l u \\<and> List.set (inter_scheme l u) \\<subseteq> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?LL = \"lenlex less_than\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define bf where \"bf \\<equiv> \\<lambda>M q. wfrec pair_less (\\<lambda>f (j,i).\n                                  let R = (case prev j i of None \\<Rightarrow> M | Some u \\<Rightarrow> snd (f u))\n                                  in grab R (q j i))\""], ["proof (state)\nthis:\n  bf \\<equiv>\n  \\<lambda>M q.\n     wfrec pair_less\n      (\\<lambda>f (j, i).\n          let R = case prev j i of None \\<Rightarrow> M\n                  | Some u \\<Rightarrow> snd (f u)\n          in grab R (q j i))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bf_rec: \"bf M q (j,i) =\n                 (let R = (case prev j i of None \\<Rightarrow> M | Some u \\<Rightarrow> snd (bf M q u))\n                  in  grab R (q j i))\" for M q j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. bf M q (j, i) =\n    (let R = case prev j i of None \\<Rightarrow> M\n             | Some u \\<Rightarrow> snd (bf M q u)\n     in grab R (q j i))", "by (subst (1) bf_def) (simp add: Let_def wfrec bf_def cut_apply prev_pair_less cong: conj_cong split: option.split)"], ["proof (state)\nthis:\n  bf ?M ?q (?j, ?i) =\n  (let R = case prev ?j ?i of None \\<Rightarrow> ?M\n           | Some u \\<Rightarrow> snd (bf ?M ?q u)\n   in grab R (?q ?j ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have infinite_bf [simp]: \"infinite (snd (bf M q u)) = infinite M\" for M q u"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (snd (bf M q u)) = infinite M", "using wf_pair_less"], ["proof (prove)\nusing this:\n  wf pair_less\n\ngoal (1 subgoal):\n 1. infinite (snd (bf M q u)) = infinite M", "proof (induction u rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> pair_less \\<Longrightarrow>\n           infinite (snd (bf M q y)) = infinite M) \\<Longrightarrow>\n       infinite (snd (bf M q x)) = infinite M", "case (less u)"], ["proof (state)\nthis:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  infinite (snd (bf M q ?y)) = infinite M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> pair_less \\<Longrightarrow>\n           infinite (snd (bf M q y)) = infinite M) \\<Longrightarrow>\n       infinite (snd (bf M q x)) = infinite M", "then"], ["proof (chain)\npicking this:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  infinite (snd (bf M q ?y)) = infinite M", "show ?case"], ["proof (prove)\nusing this:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  infinite (snd (bf M q ?y)) = infinite M\n\ngoal (1 subgoal):\n 1. infinite (snd (bf M q u)) = infinite M", "proof (cases u)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>y.\n                   (y, u) \\<in> pair_less \\<Longrightarrow>\n                   infinite (snd (bf M q y)) = infinite M;\n        u = (a, b)\\<rbrakk>\n       \\<Longrightarrow> infinite (snd (bf M q u)) = infinite M", "case (Pair j i)"], ["proof (state)\nthis:\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>y.\n                   (y, u) \\<in> pair_less \\<Longrightarrow>\n                   infinite (snd (bf M q y)) = infinite M;\n        u = (a, b)\\<rbrakk>\n       \\<Longrightarrow> infinite (snd (bf M q u)) = infinite M", "with less.IH prev_pair_less"], ["proof (chain)\npicking this:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  infinite (snd (bf M q ?y)) = infinite M\n  prev ?j ?i = Some ?ji' \\<Longrightarrow> (?ji', ?j, ?i) \\<in> pair_less\n  u = (j, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  infinite (snd (bf M q ?y)) = infinite M\n  prev ?j ?i = Some ?ji' \\<Longrightarrow> (?ji', ?j, ?i) \\<in> pair_less\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. infinite (snd (bf M q u)) = infinite M", "by (auto simp: bf_rec [of M q j i] split: option.split)"], ["proof (state)\nthis:\n  infinite (snd (bf M q u)) = infinite M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infinite (snd (bf M q u)) = infinite M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infinite (snd (bf ?M ?q ?u)) = infinite ?M\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bf_less_sets: \"fst (bf M q ij) \\<lless> snd (bf M q ij)\" if \"infinite M\" for M q ij"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (bf M q ij) \\<lless> snd (bf M q ij)", "using wf_pair_less"], ["proof (prove)\nusing this:\n  wf pair_less\n\ngoal (1 subgoal):\n 1. fst (bf M q ij) \\<lless> snd (bf M q ij)", "proof (induction ij rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> pair_less \\<Longrightarrow>\n           fst (bf M q y) \\<lless> snd (bf M q y)) \\<Longrightarrow>\n       fst (bf M q x) \\<lless> snd (bf M q x)", "case (less u)"], ["proof (state)\nthis:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  fst (bf M q ?y) \\<lless> snd (bf M q ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> pair_less \\<Longrightarrow>\n           fst (bf M q y) \\<lless> snd (bf M q y)) \\<Longrightarrow>\n       fst (bf M q x) \\<lless> snd (bf M q x)", "then"], ["proof (chain)\npicking this:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  fst (bf M q ?y) \\<lless> snd (bf M q ?y)", "show ?case"], ["proof (prove)\nusing this:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  fst (bf M q ?y) \\<lless> snd (bf M q ?y)\n\ngoal (1 subgoal):\n 1. fst (bf M q u) \\<lless> snd (bf M q u)", "proof (cases u)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>y.\n                   (y, u) \\<in> pair_less \\<Longrightarrow>\n                   fst (bf M q y) \\<lless> snd (bf M q y);\n        u = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fst (bf M q u) \\<lless> snd (bf M q u)", "case (Pair j i)"], ["proof (state)\nthis:\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>y.\n                   (y, u) \\<in> pair_less \\<Longrightarrow>\n                   fst (bf M q y) \\<lless> snd (bf M q y);\n        u = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fst (bf M q u) \\<lless> snd (bf M q u)", "with less_sets_grab"], ["proof (chain)\npicking this:\n  infinite ?N \\<Longrightarrow> fst (grab ?N ?n) \\<lless> snd (grab ?N ?n)\n  u = (j, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite ?N \\<Longrightarrow> fst (grab ?N ?n) \\<lless> snd (grab ?N ?n)\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. fst (bf M q u) \\<lless> snd (bf M q u)", "by (simp add: bf_rec [of M q j i] less.IH prev_pair_less that split: option.split)"], ["proof (state)\nthis:\n  fst (bf M q u) \\<lless> snd (bf M q u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (bf M q u) \\<lless> snd (bf M q u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infinite ?M \\<Longrightarrow>\n  fst (bf ?M ?q ?ij) \\<lless> snd (bf ?M ?q ?ij)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bf_subset: \"fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M\" for M q u"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M", "using wf_pair_less"], ["proof (prove)\nusing this:\n  wf pair_less\n\ngoal (1 subgoal):\n 1. fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M", "proof (induction u rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> pair_less \\<Longrightarrow>\n           fst (bf M q y) \\<subseteq> M \\<and>\n           snd (bf M q y) \\<subseteq> M) \\<Longrightarrow>\n       fst (bf M q x) \\<subseteq> M \\<and> snd (bf M q x) \\<subseteq> M", "case (less u)"], ["proof (state)\nthis:\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  fst (bf M q ?y) \\<subseteq> M \\<and> snd (bf M q ?y) \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> pair_less \\<Longrightarrow>\n           fst (bf M q y) \\<subseteq> M \\<and>\n           snd (bf M q y) \\<subseteq> M) \\<Longrightarrow>\n       fst (bf M q x) \\<subseteq> M \\<and> snd (bf M q x) \\<subseteq> M", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M", "proof (cases u)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       u = (a, b) \\<Longrightarrow>\n       fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M", "case (Pair j i)"], ["proof (state)\nthis:\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       u = (a, b) \\<Longrightarrow>\n       fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M", "then"], ["proof (chain)\npicking this:\n  u = (j, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M", "apply (simp add: bf_rec [of M q j i] that split: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = (j, i) \\<Longrightarrow>\n    (prev j i = None \\<longrightarrow>\n     fst (grab M (q j i)) \\<subseteq> M \\<and>\n     snd (grab M (q j i)) \\<subseteq> M) \\<and>\n    (\\<forall>a b.\n        prev j i = Some (a, b) \\<longrightarrow>\n        fst (grab (snd (bf M q (a, b))) (q j i)) \\<subseteq> M \\<and>\n        snd (grab (snd (bf M q (a, b))) (q j i)) \\<subseteq> M)", "using fst_grab_subset less.IH prev_pair_less snd_grab_subset"], ["proof (prove)\nusing this:\n  fst (grab ?N ?n) \\<subseteq> ?N\n  (?y, u) \\<in> pair_less \\<Longrightarrow>\n  fst (bf M q ?y) \\<subseteq> M \\<and> snd (bf M q ?y) \\<subseteq> M\n  prev ?j ?i = Some ?ji' \\<Longrightarrow> (?ji', ?j, ?i) \\<in> pair_less\n  snd (grab ?N ?n) \\<subseteq> ?N\n\ngoal (1 subgoal):\n 1. u = (j, i) \\<Longrightarrow>\n    (prev j i = None \\<longrightarrow>\n     fst (grab M (q j i)) \\<subseteq> M \\<and>\n     snd (grab M (q j i)) \\<subseteq> M) \\<and>\n    (\\<forall>a b.\n        prev j i = Some (a, b) \\<longrightarrow>\n        fst (grab (snd (bf M q (a, b))) (q j i)) \\<subseteq> M \\<and>\n        snd (grab (snd (bf M q (a, b))) (q j i)) \\<subseteq> M)", "by blast"], ["proof (state)\nthis:\n  fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (bf M q u) \\<subseteq> M \\<and> snd (bf M q u) \\<subseteq> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (bf ?M ?q ?u) \\<subseteq> ?M \\<and> snd (bf ?M ?q ?u) \\<subseteq> ?M\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have card_fst_bf: \"finite (fst (bf M q (j,i))) \\<and> card (fst (bf M q (j,i))) = q j i\" if \"infinite M\" for M q j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fst (bf M q (j, i))) \\<and> card (fst (bf M q (j, i))) = q j i", "by (simp add: that bf_rec [of M q j i] split: option.split)"], ["proof (state)\nthis:\n  infinite ?M \\<Longrightarrow>\n  finite (fst (bf ?M ?q (?j, ?i))) \\<and>\n  card (fst (bf ?M ?q (?j, ?i))) = ?q ?j ?i\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bf_cong: \"bf M q u = bf M q' u\"\n    if \"snd u \\<le> fst u\" and eq: \"\\<And>y x. \\<lbrakk>x\\<le>y; y\\<le>fst u\\<rbrakk> \\<Longrightarrow> q' y x = q y x\" for M q q' u"], ["proof (prove)\ngoal (1 subgoal):\n 1. bf M q u = bf M q' u", "using wf_pair_less that"], ["proof (prove)\nusing this:\n  wf pair_less\n  snd u \\<le> fst u\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> fst u\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n\ngoal (1 subgoal):\n 1. bf M q u = bf M q' u", "proof (induction u rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> pair_less; snd y \\<le> fst y;\n                    \\<And>x ya.\n                       \\<lbrakk>x \\<le> ya; ya \\<le> fst y\\<rbrakk>\n                       \\<Longrightarrow> q' ya x = q ya x\\<rbrakk>\n                   \\<Longrightarrow> bf M q y = bf M q' y;\n        snd x \\<le> fst x;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<le> y; y \\<le> fst x\\<rbrakk>\n           \\<Longrightarrow> q' y xa = q y xa\\<rbrakk>\n       \\<Longrightarrow> bf M q x = bf M q' x", "case (less u)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, u) \\<in> pair_less; snd ?y \\<le> fst ?y;\n   \\<And>x y.\n      \\<lbrakk>x \\<le> y; y \\<le> fst ?y\\<rbrakk>\n      \\<Longrightarrow> q' y x = q y x\\<rbrakk>\n  \\<Longrightarrow> bf M q ?y = bf M q' ?y\n  snd u \\<le> fst u\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> fst u\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> pair_less; snd y \\<le> fst y;\n                    \\<And>x ya.\n                       \\<lbrakk>x \\<le> ya; ya \\<le> fst y\\<rbrakk>\n                       \\<Longrightarrow> q' ya x = q ya x\\<rbrakk>\n                   \\<Longrightarrow> bf M q y = bf M q' y;\n        snd x \\<le> fst x;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<le> y; y \\<le> fst x\\<rbrakk>\n           \\<Longrightarrow> q' y xa = q y xa\\<rbrakk>\n       \\<Longrightarrow> bf M q x = bf M q' x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bf M q u = bf M q' u", "proof (cases u)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. u = (a, b) \\<Longrightarrow> bf M q u = bf M q' u", "case (Pair j i)"], ["proof (state)\nthis:\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. \\<And>a b. u = (a, b) \\<Longrightarrow> bf M q u = bf M q' u", "with less.prems"], ["proof (chain)\npicking this:\n  snd u \\<le> fst u\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> fst u\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n  u = (j, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  snd u \\<le> fst u\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> fst u\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. bf M q u = bf M q' u", "proof (clarsimp simp add: bf_rec [of M _ j i]  split: option.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>i \\<le> j;\n        \\<And>x y.\n           \\<lbrakk>x \\<le> y; y \\<le> j\\<rbrakk>\n           \\<Longrightarrow> q' y x = q y x;\n        u = (j, i); prev j i = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> grab (snd (bf M q (a, b))) (q j i) =\n                         grab (snd (bf M q' (a, b))) (q j i)", "fix j' i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>i \\<le> j;\n        \\<And>x y.\n           \\<lbrakk>x \\<le> y; y \\<le> j\\<rbrakk>\n           \\<Longrightarrow> q' y x = q y x;\n        u = (j, i); prev j i = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> grab (snd (bf M q (a, b))) (q j i) =\n                         grab (snd (bf M q' (a, b))) (q j i)", "assume *: \"prev j i = Some (j',i')\""], ["proof (state)\nthis:\n  prev j i = Some (j', i')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>i \\<le> j;\n        \\<And>x y.\n           \\<lbrakk>x \\<le> y; y \\<le> j\\<rbrakk>\n           \\<Longrightarrow> q' y x = q y x;\n        u = (j, i); prev j i = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> grab (snd (bf M q (a, b))) (q j i) =\n                         grab (snd (bf M q' (a, b))) (q j i)", "then"], ["proof (chain)\npicking this:\n  prev j i = Some (j', i')", "have **: \"((j', i'), u) \\<in> pair_less\""], ["proof (prove)\nusing this:\n  prev j i = Some (j', i')\n\ngoal (1 subgoal):\n 1. ((j', i'), u) \\<in> pair_less", "by (simp add: Pair prev_pair_less)"], ["proof (state)\nthis:\n  ((j', i'), u) \\<in> pair_less\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>i \\<le> j;\n        \\<And>x y.\n           \\<lbrakk>x \\<le> y; y \\<le> j\\<rbrakk>\n           \\<Longrightarrow> q' y x = q y x;\n        u = (j, i); prev j i = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> grab (snd (bf M q (a, b))) (q j i) =\n                         grab (snd (bf M q' (a, b))) (q j i)", "moreover"], ["proof (state)\nthis:\n  ((j', i'), u) \\<in> pair_less\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>i \\<le> j;\n        \\<And>x y.\n           \\<lbrakk>x \\<le> y; y \\<le> j\\<rbrakk>\n           \\<Longrightarrow> q' y x = q y x;\n        u = (j, i); prev j i = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> grab (snd (bf M q (a, b))) (q j i) =\n                         grab (snd (bf M q' (a, b))) (q j i)", "have \"i' < j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < j'", "using Pair less.prems"], ["proof (prove)\nusing this:\n  u = (j, i)\n  snd u \\<le> fst u\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> fst u\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n\ngoal (1 subgoal):\n 1. i' < j'", "by (simp add: prev_Some_less [OF *])"], ["proof (state)\nthis:\n  i' < j'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>i \\<le> j;\n        \\<And>x y.\n           \\<lbrakk>x \\<le> y; y \\<le> j\\<rbrakk>\n           \\<Longrightarrow> q' y x = q y x;\n        u = (j, i); prev j i = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> grab (snd (bf M q (a, b))) (q j i) =\n                         grab (snd (bf M q' (a, b))) (q j i)", "moreover"], ["proof (state)\nthis:\n  i' < j'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>i \\<le> j;\n        \\<And>x y.\n           \\<lbrakk>x \\<le> y; y \\<le> j\\<rbrakk>\n           \\<Longrightarrow> q' y x = q y x;\n        u = (j, i); prev j i = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> grab (snd (bf M q (a, b))) (q j i) =\n                         grab (snd (bf M q' (a, b))) (q j i)", "have \"\\<And>x y. \\<lbrakk>x \\<le> y; y \\<le> j'\\<rbrakk> \\<Longrightarrow> q' y x = q y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> q' y x = q y x", "using ** less.prems"], ["proof (prove)\nusing this:\n  ((j', i'), u) \\<in> pair_less\n  snd u \\<le> fst u\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> fst u\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> q' y x = q y x", "by (auto simp: pair_less_def Pair)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> j'\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>i \\<le> j;\n        \\<And>x y.\n           \\<lbrakk>x \\<le> y; y \\<le> j\\<rbrakk>\n           \\<Longrightarrow> q' y x = q y x;\n        u = (j, i); prev j i = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> grab (snd (bf M q (a, b))) (q j i) =\n                         grab (snd (bf M q' (a, b))) (q j i)", "ultimately"], ["proof (chain)\npicking this:\n  ((j', i'), u) \\<in> pair_less\n  i' < j'\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> j'\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x", "show \"grab (snd (bf M q (j',i'))) (q j i) = grab (snd (bf M q' (j',i'))) (q j i)\""], ["proof (prove)\nusing this:\n  ((j', i'), u) \\<in> pair_less\n  i' < j'\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> j'\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n\ngoal (1 subgoal):\n 1. grab (snd (bf M q (j', i'))) (q j i) =\n    grab (snd (bf M q' (j', i'))) (q j i)", "using less.IH"], ["proof (prove)\nusing this:\n  ((j', i'), u) \\<in> pair_less\n  i' < j'\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> j'\\<rbrakk>\n  \\<Longrightarrow> q' ?y ?x = q ?y ?x\n  \\<lbrakk>(?y, u) \\<in> pair_less; snd ?y \\<le> fst ?y;\n   \\<And>x y.\n      \\<lbrakk>x \\<le> y; y \\<le> fst ?y\\<rbrakk>\n      \\<Longrightarrow> q' y x = q y x\\<rbrakk>\n  \\<Longrightarrow> bf M q ?y = bf M q' ?y\n\ngoal (1 subgoal):\n 1. grab (snd (bf M q (j', i'))) (q j i) =\n    grab (snd (bf M q' (j', i'))) (q j i)", "by auto"], ["proof (state)\nthis:\n  grab (snd (bf M q (j', i'))) (q j i) =\n  grab (snd (bf M q' (j', i'))) (q j i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bf M q u = bf M q' u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bf M q u = bf M q' u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>snd ?u \\<le> fst ?u;\n   \\<And>y x.\n      \\<lbrakk>x \\<le> y; y \\<le> fst ?u\\<rbrakk>\n      \\<Longrightarrow> ?q' y x = ?q y x\\<rbrakk>\n  \\<Longrightarrow> bf ?M ?q ?u = bf ?M ?q' ?u\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define ediff where \"ediff \\<equiv> \\<lambda>D:: nat \\<Rightarrow> nat set. \\<lambda>j i. enum (D j) (Suc i) - enum (D j) i\""], ["proof (state)\nthis:\n  ediff \\<equiv> \\<lambda>D j i. enum (D j) (Suc i) - enum (D j) i\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define F where \"F \\<equiv> \\<lambda>l (dl,a0::nat set,b0::nat \\<times> nat \\<Rightarrow> nat set,M).\n          let (d,Md) = grab (nxt M (enum N (Suc (2 * Suc l)))) (Suc l) in\n          let (a,Ma) = grab Md (Min d) in\n          let Gb = bf Ma (ediff (dl(l := d))) in\n          let dl' = dl(l := d) in\n          (dl', a, fst \\<circ> Gb, snd (Gb(l, l-1)))\""], ["proof (state)\nthis:\n  F \\<equiv>\n  \\<lambda>l (dl, a0, b0, M).\n     let (d, Md) = grab (nxt M (enum N (Suc (2 * Suc l)))) (Suc l);\n         (a, Ma) = grab Md (Min d); Gb = bf Ma (ediff (dl(l := d)));\n         dl' = dl(l := d)\n     in (dl', a, fst \\<circ> Gb, snd (Gb (l, l - 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define DF where \"DF \\<equiv> rec_nat (\\<lambda>i\\<in>{..<0}. {}, {}, \\<lambda>p. {}, N) F\""], ["proof (state)\nthis:\n  DF \\<equiv> rec_nat (\\<lambda>i\\<in>{..<0}. {}, {}, \\<lambda>p. {}, N) F\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have DF_simps: \"DF 0 = (\\<lambda>i\\<in>{..<0}. {}, {}, \\<lambda>p. {}, N)\"\n                 \"DF (Suc l) = F l (DF l)\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF 0 = (\\<lambda>i\\<in>{..<0}. {}, {}, \\<lambda>p. {}, N) &&&\n    DF (Suc l) = F l (DF l)", "by (auto simp: DF_def)"], ["proof (state)\nthis:\n  DF 0 = (\\<lambda>i\\<in>{..<0}. {}, {}, \\<lambda>p. {}, N)\n  DF (Suc ?l) = F ?l (DF ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note cut_apply [simp]"], ["proof (state)\nthis:\n  (?x, ?a) \\<in> ?R \\<Longrightarrow> cut ?f ?R ?a ?x = ?f ?x\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have inf [rule_format]: \"\\<forall>dl al bl L. DF l = (dl,al,bl,L) \\<longrightarrow> infinite L\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>dl al bl L. DF l = (dl, al, bl, L) \\<longrightarrow> infinite L", "by (induction l) (auto simp: DF_simps F_def Let_def grab_eqD infinite_nxtN assms split: prod.split)"], ["proof (state)\nthis:\n  DF ?l = (?dl, ?al, ?bl, ?L) \\<Longrightarrow> infinite ?L\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define \\<Psi> where\n    \"\\<Psi> \\<equiv> \\<lambda>(dl, a, b :: nat \\<times> nat \\<Rightarrow> nat set, M::nat set). \\<lambda>l::nat.\n           dl l \\<lless> a \\<and> finite a \\<and> dl l \\<noteq> {} \\<and> a \\<noteq> {} \\<and>\n           (\\<forall>j\\<le>l. card (dl j) = Suc j) \\<and> a \\<lless> \\<Union>(range b) \\<and> range b \\<subseteq> Collect finite \\<and>\n           a \\<subseteq> N \\<and> \\<Union>(range b) \\<subseteq> N \\<and> infinite M \\<and> b(l,l-1) \\<lless> M \\<and>\n           M \\<subseteq> N\""], ["proof (state)\nthis:\n  \\<Psi> \\<equiv>\n  \\<lambda>(dl, a, b, M) l.\n     dl l \\<lless> a \\<and>\n     finite a \\<and>\n     dl l \\<noteq> {} \\<and>\n     a \\<noteq> {} \\<and>\n     (\\<forall>j\\<le>l. card (dl j) = Suc j) \\<and>\n     a \\<lless> \\<Union> (range b) \\<and>\n     range b \\<subseteq> Collect finite \\<and>\n     a \\<subseteq> N \\<and>\n     \\<Union> (range b) \\<subseteq> N \\<and>\n     infinite M \\<and> b (l, l - 1) \\<lless> M \\<and> M \\<subseteq> N\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<Psi>_DF: \"\\<Psi> (DF (Suc l)) l\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> (DF (Suc l)) l", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Psi> (DF (Suc 0)) 0\n 2. \\<And>l.\n       \\<Psi> (DF (Suc l)) l \\<Longrightarrow>\n       \\<Psi> (DF (Suc (Suc l))) (Suc l)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<Psi> (DF (Suc 0)) 0\n 2. \\<And>l.\n       \\<Psi> (DF (Suc l)) l \\<Longrightarrow>\n       \\<Psi> (DF (Suc (Suc l))) (Suc l)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> (DF (Suc 0)) 0", "using assms"], ["proof (prove)\nusing this:\n  infinite N\n\ngoal (1 subgoal):\n 1. \\<Psi> (DF (Suc 0)) 0", "apply (clarsimp simp add: bf_rec F_def DF_simps \\<Psi>_def split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>infinite N; grab x2 (Min x1) = (x1a, x2a);\n        grab (nxt N (enum N (Suc (Suc (Suc 0))))) (Suc 0) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<lless> x1a \\<and>\n                         finite x1a \\<and>\n                         x1 \\<noteq> {} \\<and>\n                         x1a \\<noteq> {} \\<and>\n                         card x1 = Suc 0 \\<and>\n                         x1a \\<lless>\n                         (\\<Union>x.\n                             fst (bf x2a\n                                   (ediff\n                                     (restrict ((\\<lambda>i. {})(0 := x1))\n {0}))\n                                   x)) \\<and>\n                         range\n                          (\\<lambda>x.\n                              fst (bf x2a\n                                    (ediff\n(restrict ((\\<lambda>i. {})(0 := x1)) {0}))\n                                    x))\n                         \\<subseteq> Collect finite \\<and>\n                         x1a \\<subseteq> N \\<and>\n                         (\\<Union>x.\n                             fst (bf x2a\n                                   (ediff\n                                     (restrict ((\\<lambda>i. {})(0 := x1))\n {0}))\n                                   x))\n                         \\<subseteq> N \\<and>\n                         infinite x2a \\<and>\n                         fst (grab x2a\n                               (ediff\n                                 (restrict ((\\<lambda>i. {})(0 := x1)) {0})\n                                 0 0)) \\<lless>\n                         snd (grab x2a\n                               (ediff\n                                 (restrict ((\\<lambda>i. {})(0 := x1)) {0})\n                                 0 0)) \\<and>\n                         snd (grab x2a\n                               (ediff\n                                 (restrict ((\\<lambda>i. {})(0 := x1)) {0})\n                                 0 0))\n                         \\<subseteq> N", "apply (drule grab_eqD, blast dest: grab_eqD infinite_nxtN)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>infinite N;\n        x1a \\<lless> x2a \\<and>\n        finite x1a \\<and>\n        card x1a = Min x1 \\<and>\n        infinite x2a \\<and> x1a \\<subseteq> x2 \\<and> x2a \\<subseteq> x2;\n        x1 \\<lless> x2 \\<and>\n        finite x1 \\<and>\n        card x1 = Suc 0 \\<and>\n        infinite x2 \\<and>\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0)))) \\<and>\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))))\\<rbrakk>\n       \\<Longrightarrow> x1 \\<lless> x1a \\<and>\n                         finite x1a \\<and>\n                         x1 \\<noteq> {} \\<and>\n                         x1a \\<noteq> {} \\<and>\n                         card x1 = Suc 0 \\<and>\n                         x1a \\<lless>\n                         (\\<Union>x.\n                             fst (bf x2a\n                                   (ediff\n                                     (restrict ((\\<lambda>i. {})(0 := x1))\n {0}))\n                                   x)) \\<and>\n                         range\n                          (\\<lambda>x.\n                              fst (bf x2a\n                                    (ediff\n(restrict ((\\<lambda>i. {})(0 := x1)) {0}))\n                                    x))\n                         \\<subseteq> Collect finite \\<and>\n                         x1a \\<subseteq> N \\<and>\n                         (\\<Union>x.\n                             fst (bf x2a\n                                   (ediff\n                                     (restrict ((\\<lambda>i. {})(0 := x1))\n {0}))\n                                   x))\n                         \\<subseteq> N \\<and>\n                         infinite x2a \\<and>\n                         fst (grab x2a\n                               (ediff\n                                 (restrict ((\\<lambda>i. {})(0 := x1)) {0})\n                                 0 0)) \\<lless>\n                         snd (grab x2a\n                               (ediff\n                                 (restrict ((\\<lambda>i. {})(0 := x1)) {0})\n                                 0 0)) \\<and>\n                         snd (grab x2a\n                               (ediff\n                                 (restrict ((\\<lambda>i. {})(0 := x1)) {0})\n                                 0 0))\n                         \\<subseteq> N", "apply (auto simp: less_sets_UN2 less_sets_grab card_fst_bf elim!: less_sets_weaken2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>infinite N; x1 \\<lless> x2; finite x1; Min x1 = 0;\n        card x1 = Suc 0; infinite x2a; infinite x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x1 x2 x1a x2a a b x.\n       \\<lbrakk>infinite N; x1 \\<lless> x2; finite x1a; finite x1;\n        card x1a = Min x1; card x1 = Suc 0; infinite x2a; infinite x2;\n        x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> fst (bf x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}))\n                      (a, b))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> x2a\n 3. \\<And>x1 x2 x1a x2a x.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> x1a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N\n 4. \\<And>x1 x2 x1a x2a x a b.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> fst (bf x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}))\n                      (a, b))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N\n 5. \\<And>x1 x2 x1a x2a x.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> snd (grab x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}) 0\n                        0))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N", "apply (metis Min_in card_eq_0_iff greaterThan_iff le_inf_iff less_nat_zero_code n_not_Suc_n nxt_def subsetD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a x2a a b x.\n       \\<lbrakk>infinite N; x1 \\<lless> x2; finite x1a; finite x1;\n        card x1a = Min x1; card x1 = Suc 0; infinite x2a; infinite x2;\n        x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> fst (bf x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}))\n                      (a, b))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> x2a\n 2. \\<And>x1 x2 x1a x2a x.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> x1a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N\n 3. \\<And>x1 x2 x1a x2a x a b.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> fst (bf x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}))\n                      (a, b))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N\n 4. \\<And>x1 x2 x1a x2a x.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> snd (grab x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}) 0\n                        0))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N", "using nxt_subset snd_grab_subset bf_subset"], ["proof (prove)\nusing this:\n  nxt ?N ?n \\<subseteq> ?N\n  snd (grab ?N ?n) \\<subseteq> ?N\n  fst (bf ?M ?q ?u) \\<subseteq> ?M \\<and> snd (bf ?M ?q ?u) \\<subseteq> ?M\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a x2a a b x.\n       \\<lbrakk>infinite N; x1 \\<lless> x2; finite x1a; finite x1;\n        card x1a = Min x1; card x1 = Suc 0; infinite x2a; infinite x2;\n        x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> fst (bf x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}))\n                      (a, b))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> x2a\n 2. \\<And>x1 x2 x1a x2a x.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> x1a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N\n 3. \\<And>x1 x2 x1a x2a x a b.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> fst (bf x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}))\n                      (a, b))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N\n 4. \\<And>x1 x2 x1a x2a x.\n       \\<lbrakk>infinite N; x1a \\<lless> x2a; x1 \\<lless> x2; finite x1a;\n        finite x1; card x1a = Min x1; card x1 = Suc 0; infinite x2a;\n        infinite x2; x1a \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x2 \\<subseteq> nxt N (enum N (Suc (Suc (Suc 0))));\n        x \\<in> snd (grab x2a\n                      (ediff (restrict ((\\<lambda>i. {})(0 := x1)) {0}) 0\n                        0))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> N", "by blast+"], ["proof (state)\nthis:\n  \\<Psi> (DF (Suc 0)) 0\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<Psi> (DF (Suc l)) l \\<Longrightarrow>\n       \\<Psi> (DF (Suc (Suc l))) (Suc l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<Psi> (DF (Suc l)) l \\<Longrightarrow>\n       \\<Psi> (DF (Suc (Suc l))) (Suc l)", "case (Suc l)"], ["proof (state)\nthis:\n  \\<Psi> (DF (Suc l)) l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<Psi> (DF (Suc l)) l \\<Longrightarrow>\n       \\<Psi> (DF (Suc (Suc l))) (Suc l)", "then"], ["proof (chain)\npicking this:\n  \\<Psi> (DF (Suc l)) l", "show ?case"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc l)) l\n\ngoal (1 subgoal):\n 1. \\<Psi> (DF (Suc (Suc l))) (Suc l)", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc l)) l\n  infinite N\n\ngoal (1 subgoal):\n 1. \\<Psi> (DF (Suc (Suc l))) (Suc l)", "unfolding Let_def DF_simps(2)[of \"Suc l\"] F_def \\<Psi>_def"], ["proof (prove)\nusing this:\n  (case DF (Suc l) of\n   (dl, a, b, M) \\<Rightarrow>\n     \\<lambda>l.\n        dl l \\<lless> a \\<and>\n        finite a \\<and>\n        dl l \\<noteq> {} \\<and>\n        a \\<noteq> {} \\<and>\n        (\\<forall>j\\<le>l. card (dl j) = Suc j) \\<and>\n        a \\<lless> \\<Union> (range b) \\<and>\n        range b \\<subseteq> Collect finite \\<and>\n        a \\<subseteq> N \\<and>\n        \\<Union> (range b) \\<subseteq> N \\<and>\n        infinite M \\<and> b (l, l - 1) \\<lless> M \\<and> M \\<subseteq> N)\n   l\n  infinite N\n\ngoal (1 subgoal):\n 1. (case case DF (Suc l) of\n          (dl, a0, b0, M) \\<Rightarrow>\n            case grab (nxt M (enum N (Suc (2 * Suc (Suc l)))))\n                  (Suc (Suc l)) of\n            (d, Md) \\<Rightarrow>\n              case grab Md (Min d) of\n              (a, Ma) \\<Rightarrow>\n                (dl(Suc l := d), a,\n                 fst \\<circ> bf Ma (ediff (dl(Suc l := d))),\n                 snd (bf Ma (ediff (dl(Suc l := d))) (Suc l, Suc l - 1))) of\n     (dl, a, b, M) \\<Rightarrow>\n       \\<lambda>l.\n          dl l \\<lless> a \\<and>\n          finite a \\<and>\n          dl l \\<noteq> {} \\<and>\n          a \\<noteq> {} \\<and>\n          (\\<forall>j\\<le>l. card (dl j) = Suc j) \\<and>\n          a \\<lless> \\<Union> (range b) \\<and>\n          range b \\<subseteq> Collect finite \\<and>\n          a \\<subseteq> N \\<and>\n          \\<Union> (range b) \\<subseteq> N \\<and>\n          infinite M \\<and> b (l, l - 1) \\<lless> M \\<and> M \\<subseteq> N)\n     (Suc l)", "apply (clarsimp simp add: bf_rec DF_simps split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa b x1a x2 x1b x2a.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a; x l \\<noteq> {};\n        a \\<noteq> {}; \\<forall>j\\<le>l. card (x j) = Suc j;\n        a \\<lless> \\<Union> (range aa); range aa \\<subseteq> Collect finite;\n        a \\<subseteq> N; \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l))))))))\n         (Suc (Suc l)) =\n        (x1a, x2);\n        F l (DF l) = (x, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> x1a \\<lless> x1b \\<and>\n                         finite x1b \\<and>\n                         x1a \\<noteq> {} \\<and>\n                         x1b \\<noteq> {} \\<and>\n                         card x1a = Suc (Suc l) \\<and>\n                         x1b \\<lless>\n                         (\\<Union>xa.\n                             fst (bf x2a (ediff (x(Suc l := x1a)))\n                                   xa)) \\<and>\n                         range\n                          (\\<lambda>xa.\n                              fst (bf x2a (ediff (x(Suc l := x1a))) xa))\n                         \\<subseteq> Collect finite \\<and>\n                         x1b \\<subseteq> N \\<and>\n                         (\\<Union>xa.\n                             fst (bf x2a (ediff (x(Suc l := x1a))) xa))\n                         \\<subseteq> N \\<and>\n                         infinite\n                          (case prev (Suc l) l of None \\<Rightarrow> x2a\n                           | Some u \\<Rightarrow>\n                               snd (bf x2a (ediff (x(Suc l := x1a)))\n                                     u)) \\<and>\n                         fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<and>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n                         \\<subseteq> N", "apply (drule grab_eqD, metis grab_eqD infinite_nxtN)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa b x1a x2 x1b x2a.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a; x l \\<noteq> {};\n        a \\<noteq> {}; \\<forall>j\\<le>l. card (x j) = Suc j;\n        a \\<lless> \\<Union> (range aa); range aa \\<subseteq> Collect finite;\n        a \\<subseteq> N; \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b);\n        x1b \\<lless> x2a \\<and>\n        finite x1b \\<and>\n        card x1b = Min x1a \\<and>\n        infinite x2a \\<and> x1b \\<subseteq> x2 \\<and> x2a \\<subseteq> x2;\n        x1a \\<lless> x2 \\<and>\n        finite x1a \\<and>\n        card x1a = Suc (Suc l) \\<and>\n        infinite x2 \\<and>\n        x1a\n        \\<subseteq> nxt b\n                     (enum N (Suc (Suc (Suc (Suc (Suc (2 * l))))))) \\<and>\n        x2 \\<subseteq> nxt b\n                        (enum N\n                          (Suc (Suc (Suc (Suc (Suc (2 * l)))))))\\<rbrakk>\n       \\<Longrightarrow> x1a \\<lless> x1b \\<and>\n                         finite x1b \\<and>\n                         x1a \\<noteq> {} \\<and>\n                         x1b \\<noteq> {} \\<and>\n                         card x1a = Suc (Suc l) \\<and>\n                         x1b \\<lless>\n                         (\\<Union>xa.\n                             fst (bf x2a (ediff (x(Suc l := x1a)))\n                                   xa)) \\<and>\n                         range\n                          (\\<lambda>xa.\n                              fst (bf x2a (ediff (x(Suc l := x1a))) xa))\n                         \\<subseteq> Collect finite \\<and>\n                         x1b \\<subseteq> N \\<and>\n                         (\\<Union>xa.\n                             fst (bf x2a (ediff (x(Suc l := x1a))) xa))\n                         \\<subseteq> N \\<and>\n                         infinite\n                          (case prev (Suc l) l of None \\<Rightarrow> x2a\n                           | Some u \\<Rightarrow>\n                               snd (bf x2a (ediff (x(Suc l := x1a)))\n                                     u)) \\<and>\n                         fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<and>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n                         \\<subseteq> N", "apply (safe, simp_all add: less_sets_UN2 less_sets_grab card_fst_bf)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> x1a \\<lless> x1b\n 2. \\<And>x a aa b x1a x2 x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1a \\<lless> x2; finite x1a;\n        Min x1a = 0; card x1a = Suc (Suc l); infinite x2a; infinite x2;\n        x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            x1b \\<lless>\n                            fst (bf x2a (ediff (x(Suc l := x1a))) (a, b))\n 4. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a; xc \\<in> x1b\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 5. \\<And>x a aa b x1a x2 x1b x2a xa xb xc ab ba.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> fst (bf x2a (ediff (x(Suc l := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 6. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        finite\n         (case prev (Suc l) l of None \\<Rightarrow> x2a\n          | Some u \\<Rightarrow>\n              snd (bf x2a (ediff (x(Suc l := x1a))) u))\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 8. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "apply (meson less_sets_weaken2)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x a aa b x1a x2 x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1a \\<lless> x2; finite x1a;\n        Min x1a = 0; card x1a = Suc (Suc l); infinite x2a; infinite x2;\n        x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            x1b \\<lless>\n                            fst (bf x2a (ediff (x(Suc l := x1a))) (a, b))\n 3. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a; xc \\<in> x1b\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 4. \\<And>x a aa b x1a x2 x1b x2a xa xb xc ab ba.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> fst (bf x2a (ediff (x(Suc l := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 5. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        finite\n         (case prev (Suc l) l of None \\<Rightarrow> x2a\n          | Some u \\<Rightarrow>\n              snd (bf x2a (ediff (x(Suc l := x1a))) u))\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 7. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "apply (metis (no_types, hide_lams) IntE Min_in card.empty greaterThan_iff leD not_less_eq_eq nxt_def subsetD zero_less_Suc)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            x1b \\<lless>\n                            fst (bf x2a (ediff (x(Suc l := x1a))) (a, b))\n 2. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a; xc \\<in> x1b\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 3. \\<And>x a aa b x1a x2 x1b x2a xa xb xc ab ba.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> fst (bf x2a (ediff (x(Suc l := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 4. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        finite\n         (case prev (Suc l) l of None \\<Rightarrow> x2a\n          | Some u \\<Rightarrow>\n              snd (bf x2a (ediff (x(Suc l := x1a))) u))\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 6. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "apply (meson bf_subset less_sets_weaken2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a; xc \\<in> x1b\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 2. \\<And>x a aa b x1a x2 x1b x2a xa xb xc ab ba.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> fst (bf x2a (ediff (x(Suc l := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 3. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        finite\n         (case prev (Suc l) l of None \\<Rightarrow> x2a\n          | Some u \\<Rightarrow>\n              snd (bf x2a (ediff (x(Suc l := x1a))) u))\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 5. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "apply (meson nxt_subset subset_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb xc ab ba.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>ab b. a \\<lless> aa (ab, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> fst (bf x2a (ediff (x(Suc l := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N\n 2. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        finite\n         (case prev (Suc l) l of None \\<Rightarrow> x2a\n          | Some u \\<Rightarrow>\n              snd (bf x2a (ediff (x(Suc l := x1a))) u))\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 4. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "apply (meson bf_subset nxt_subset subset_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        finite\n         (case prev (Suc l) l of None \\<Rightarrow> x2a\n          | Some u \\<Rightarrow>\n              snd (bf x2a (ediff (x(Suc l := x1a))) u))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 3. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "using bf_rec infinite_bf"], ["proof (prove)\nusing this:\n  bf ?M ?q (?j, ?i) =\n  (let R = case prev ?j ?i of None \\<Rightarrow> ?M\n           | Some u \\<Rightarrow> snd (bf ?M ?q u)\n   in grab R (?q ?j ?i))\n  infinite (snd (bf ?M ?q ?u)) = infinite ?M\n\ngoal (3 subgoals):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        finite\n         (case prev (Suc l) l of None \\<Rightarrow> x2a\n          | Some u \\<Rightarrow>\n              snd (bf x2a (ediff (x(Suc l := x1a))) u))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 3. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 2. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "using bf_less_sets bf_rec"], ["proof (prove)\nusing this:\n  infinite ?M \\<Longrightarrow>\n  fst (bf ?M ?q ?ij) \\<lless> snd (bf ?M ?q ?ij)\n  bf ?M ?q (?j, ?i) =\n  (let R = case prev ?j ?i of None \\<Rightarrow> ?M\n           | Some u \\<Rightarrow> snd (bf ?M ?q u)\n   in grab R (?q ?j ?i))\n\ngoal (2 subgoals):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a\\<rbrakk>\n       \\<Longrightarrow> fst (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l)) \\<lless>\n                         snd (grab\n                               (case prev (Suc l) l of\n                                None \\<Rightarrow> x2a\n                                | Some u \\<Rightarrow>\n                                    snd (bf x2a (ediff (x(Suc l := x1a)))\n    u))\n                               (ediff (x(Suc l := x1a)) (Suc l) l))\n 2. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa b x1a x2 x1b x2a xa xb xc.\n       \\<lbrakk>infinite N; x l \\<lless> a; finite a;\n        \\<forall>j\\<le>l. card (x j) = Suc j;\n        \\<forall>aaa b. a \\<lless> aa (aaa, b);\n        range aa \\<subseteq> Collect finite; a \\<subseteq> N;\n        \\<Union> (range aa) \\<subseteq> N; infinite b;\n        aa (l, l - Suc 0) \\<lless> b; b \\<subseteq> N;\n        F l (DF l) = (x, a, aa, b); x1b \\<lless> x2a; x1a \\<lless> x2;\n        finite x1b; finite x1a; card x1b = Min x1a; card x1a = Suc (Suc l);\n        infinite x2a; infinite x2; x1b \\<subseteq> x2; x2a \\<subseteq> x2;\n        x1a\n        \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (Suc (Suc (2 * l)))))));\n        xa \\<in> x l; xb \\<in> a;\n        xc \\<in> snd (grab\n                       (case prev (Suc l) l of None \\<Rightarrow> x2a\n                        | Some u \\<Rightarrow>\n                            snd (bf x2a (ediff (x(Suc l := x1a))) u))\n                       (ediff (x(Suc l := x1a)) (Suc l) l))\\<rbrakk>\n       \\<Longrightarrow> xc \\<in> N", "by (metis bf_rec bf_subset nxt_subset subsetD)"], ["proof (state)\nthis:\n  \\<Psi> (DF (Suc (Suc l))) (Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi> (DF (Suc ?l)) ?l\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define d where \"d \\<equiv> \\<lambda>k. let (dk,ak,bk,M) = DF(Suc k) in dk k\""], ["proof (state)\nthis:\n  d \\<equiv> \\<lambda>k. let (dk, ak, bk, M) = DF (Suc k) in dk k\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define a where \"a \\<equiv> \\<lambda>k. let (dk,ak,bk,M) = DF(Suc k) in ak\""], ["proof (state)\nthis:\n  a \\<equiv> \\<lambda>k. let (dk, ak, bk, M) = DF (Suc k) in ak\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define b where \"b \\<equiv> \\<lambda>k. let (dk,ak,bk,M) = DF(Suc k) in bk\""], ["proof (state)\nthis:\n  b \\<equiv> \\<lambda>k. let (dk, ak, bk, M) = DF (Suc k) in bk\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define M where \"M \\<equiv> \\<lambda>k. let (dk,ak,bk,M) = DF k in M\""], ["proof (state)\nthis:\n  M \\<equiv> \\<lambda>k. let (dk, ak, bk, M) = DF k in M\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have infinite_M [simp]: \"infinite (M k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (M k)", "by (auto simp: M_def inf split: prod.split)"], ["proof (state)\nthis:\n  infinite (M ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have M_Suc_subset: \"M (Suc k) \\<subseteq> M k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. M (Suc k) \\<subseteq> M k", "apply (clarsimp simp add: Let_def M_def F_def DF_simps split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a x.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b);\n        x \\<in> snd (bf x2a (ediff (x1(k := x1a))) (k, k - Suc 0))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b", "apply (drule grab_eqD, blast dest: infinite_nxtN local.inf)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a x.\n       \\<lbrakk>DF k = (x1, a, aa, b);\n        x \\<in> snd (bf x2a (ediff (x1(k := x1a))) (k, k - Suc 0));\n        x1a \\<lless> x2 \\<and>\n        finite x1a \\<and>\n        card x1a = Suc k \\<and>\n        infinite x2 \\<and>\n        x1a \\<subseteq> nxt b (enum N (Suc (Suc (Suc (2 * k))))) \\<and>\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (2 * k)))));\n        x1b \\<lless> x2a \\<and>\n        finite x1b \\<and>\n        card x1b = Min x1a \\<and>\n        infinite x2a \\<and>\n        x1b \\<subseteq> x2 \\<and> x2a \\<subseteq> x2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b", "using bf_subset nxt_subset"], ["proof (prove)\nusing this:\n  fst (bf ?M ?q ?u) \\<subseteq> ?M \\<and> snd (bf ?M ?q ?u) \\<subseteq> ?M\n  nxt ?N ?n \\<subseteq> ?N\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a x.\n       \\<lbrakk>DF k = (x1, a, aa, b);\n        x \\<in> snd (bf x2a (ediff (x1(k := x1a))) (k, k - Suc 0));\n        x1a \\<lless> x2 \\<and>\n        finite x1a \\<and>\n        card x1a = Suc k \\<and>\n        infinite x2 \\<and>\n        x1a \\<subseteq> nxt b (enum N (Suc (Suc (Suc (2 * k))))) \\<and>\n        x2 \\<subseteq> nxt b (enum N (Suc (Suc (Suc (2 * k)))));\n        x1b \\<lless> x2a \\<and>\n        finite x1b \\<and>\n        card x1b = Min x1a \\<and>\n        infinite x2a \\<and>\n        x1b \\<subseteq> x2 \\<and> x2a \\<subseteq> x2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b", "by blast"], ["proof (state)\nthis:\n  M (Suc ?k) \\<subseteq> M ?k\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have Inf_M_Suc_ge: \"Inf (M k) \\<le> Inf (M (Suc k))\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (M k) \\<le> \\<Sqinter> (M (Suc k))", "by (simp add: M_Suc_subset cInf_superset_mono infinite_imp_nonempty)"], ["proof (state)\nthis:\n  \\<Sqinter> (M ?k) \\<le> \\<Sqinter> (M (Suc ?k))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have Inf_M_telescoping: \"{Inf (M k)..} \\<subseteq> {Inf (M k')..}\" if \"k'\\<le>k\" for k k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<Sqinter> (M k)..} \\<subseteq> {\\<Sqinter> (M k')..}", "using that"], ["proof (prove)\nusing this:\n  k' \\<le> k\n\ngoal (1 subgoal):\n 1. {\\<Sqinter> (M k)..} \\<subseteq> {\\<Sqinter> (M k')..}", "by (induction \"k-k'\")(auto simp: Inf_M_Suc_ge M_Suc_subset cInf_superset_mono infinite_imp_nonempty lift_Suc_antimono_le)"], ["proof (state)\nthis:\n  ?k' \\<le> ?k \\<Longrightarrow>\n  {\\<Sqinter> (M ?k)..} \\<subseteq> {\\<Sqinter> (M ?k')..}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have d_eq: \"d k = fst (grab (nxt (M k) (enum N (Suc (2 * Suc k)))) (Suc k))\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. d k = fst (grab (nxt (M k) (enum N (Suc (2 * Suc k)))) (Suc k))", "by (simp add: d_def M_def Let_def DF_simps F_def split: prod.split)"], ["proof (state)\nthis:\n  d ?k = fst (grab (nxt (M ?k) (enum N (Suc (2 * Suc ?k)))) (Suc ?k))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  d ?k = fst (grab (nxt (M ?k) (enum N (Suc (2 * Suc ?k)))) (Suc ?k))", "have finite_d [simp]: \"finite (d k)\" for k"], ["proof (prove)\nusing this:\n  d ?k = fst (grab (nxt (M ?k) (enum N (Suc (2 * Suc ?k)))) (Suc ?k))\n\ngoal (1 subgoal):\n 1. finite (d k)", "by simp"], ["proof (state)\nthis:\n  finite (d ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  finite (d ?k)", "have d_ne [simp]: \"d k \\<noteq> {}\" for k"], ["proof (prove)\nusing this:\n  finite (d ?k)\n\ngoal (1 subgoal):\n 1. d k \\<noteq> {}", "by (metis card.empty card_grab d_eq infinite_M infinite_nxtN nat.distinct(1))"], ["proof (state)\nthis:\n  d ?k \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have a_eq: \"\\<exists>M. a k = fst (grab M (Min (d k))) \\<and> infinite M\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. a k = fst (grab M (Min (d k))) \\<and> infinite M", "apply (simp add: a_def d_def M_def Let_def DF_simps F_def split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x1 a aa b x1a x2 x1b.\n       (\\<exists>x2a. grab x2 (Min x1a) = (x1b, x2a)) \\<longrightarrow>\n       grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) =\n       (x1a, x2) \\<longrightarrow>\n       DF k = (x1, a, aa, b) \\<longrightarrow>\n       (\\<exists>M. x1b = fst (grab M (Min x1a)) \\<and> infinite M)", "by (metis fst_conv grab_eqD infinite_nxtN local.inf)"], ["proof (state)\nthis:\n  \\<exists>M. a ?k = fst (grab M (Min (d ?k))) \\<and> infinite M\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>M. a ?k = fst (grab M (Min (d ?k))) \\<and> infinite M", "have card_a: \"card (a k) = Inf (d k)\" for k"], ["proof (prove)\nusing this:\n  \\<exists>M. a ?k = fst (grab M (Min (d ?k))) \\<and> infinite M\n\ngoal (1 subgoal):\n 1. card (a k) = \\<Sqinter> (d k)", "by (metis cInf_eq_Min card_grab d_ne finite_d)"], ["proof (state)\nthis:\n  card (a ?k) = \\<Sqinter> (d ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have d_eq_dl: \"d k = dl k\" if \"(dl,a,b,P) = DF l\" \"k < l\" for k l dl a b P"], ["proof (prove)\ngoal (1 subgoal):\n 1. d k = dl k", "using that"], ["proof (prove)\nusing this:\n  (dl, a, b, P) = DF l\n  k < l\n\ngoal (1 subgoal):\n 1. d k = dl k", "by (induction l arbitrary: dl a b P) (simp_all add: d_def DF_simps F_def Let_def split: prod.split_asm prod.split)"], ["proof (state)\nthis:\n  \\<lbrakk>(?dl, ?a, ?b, ?P) = DF ?l; ?k < ?l\\<rbrakk>\n  \\<Longrightarrow> d ?k = ?dl ?k\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have card_d [simp]: \"card (d k) = Suc k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (d k) = Suc k", "by (auto simp: d_eq infinite_nxtN)"], ["proof (state)\nthis:\n  card (d ?k) = Suc ?k\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have d_ne [simp]: \"d j \\<noteq> {}\" and a_ne [simp]: \"a j \\<noteq> {}\"\n    and finite_d [simp]: \"finite (d j)\" and finite_a [simp]: \"finite (a j)\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d j \\<noteq> {} &&& a j \\<noteq> {}) &&& finite (d j) &&& finite (a j)", "using \\<Psi>_DF [of \"j\"]"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc j)) j\n\ngoal (1 subgoal):\n 1. (d j \\<noteq> {} &&& a j \\<noteq> {}) &&& finite (d j) &&& finite (a j)", "by (auto simp: \\<Psi>_def a_def d_def split: prod.split_asm)"], ["proof (state)\nthis:\n  d ?j \\<noteq> {}\n  a ?j \\<noteq> {}\n  finite (d ?j)\n  finite (a ?j)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have da: \"d k \\<lless> a k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. d k \\<lless> a k", "using \\<Psi>_DF [of \"k\"]"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc k)) k\n\ngoal (1 subgoal):\n 1. d k \\<lless> a k", "by (simp add: \\<Psi>_def a_def d_def split: prod.split_asm)"], ["proof (state)\nthis:\n  d ?k \\<lless> a ?k\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have ab_same: \"a k \\<lless> \\<Union>(range(b k))\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. a k \\<lless> \\<Union> (range (b k))", "using \\<Psi>_DF [of \"k\"]"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc k)) k\n\ngoal (1 subgoal):\n 1. a k \\<lless> \\<Union> (range (b k))", "by (simp add: \\<Psi>_def a_def b_def M_def split: prod.split_asm)"], ["proof (state)\nthis:\n  a ?k \\<lless> \\<Union> (range (b ?k))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have snd_bf_subset: \"snd (bf M r (j,i)) \\<subseteq> snd (bf M r (j',i'))\"\n    if ji: \"((j',i'), (j,i)) \\<in> pair_less\" \"(j',i') \\<in> IJ k\"\n    for M r k j i j' i'"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (bf M r (j, i)) \\<subseteq> snd (bf M r (j', i'))", "using wf_pair_less ji"], ["proof (prove)\nusing this:\n  wf pair_less\n  ((j', i'), j, i) \\<in> pair_less\n  (j', i') \\<in> IJ k\n\ngoal (1 subgoal):\n 1. snd (bf M r (j, i)) \\<subseteq> snd (bf M r (j', i'))", "proof (induction rule: wf_induct_rule [where a= \"(j,i)\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> pair_less;\n                    ((j', i'), y) \\<in> pair_less;\n                    (j', i') \\<in> IJ k\\<rbrakk>\n                   \\<Longrightarrow> snd (bf M r y)\n                                     \\<subseteq> snd (bf M r (j', i'));\n        ((j', i'), x) \\<in> pair_less; (j', i') \\<in> IJ k\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r x) \\<subseteq> snd (bf M r (j', i'))", "case (less u)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, u) \\<in> pair_less; ((j', i'), ?y) \\<in> pair_less;\n   (j', i') \\<in> IJ k\\<rbrakk>\n  \\<Longrightarrow> snd (bf M r ?y) \\<subseteq> snd (bf M r (j', i'))\n  ((j', i'), u) \\<in> pair_less\n  (j', i') \\<in> IJ k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> pair_less;\n                    ((j', i'), y) \\<in> pair_less;\n                    (j', i') \\<in> IJ k\\<rbrakk>\n                   \\<Longrightarrow> snd (bf M r y)\n                                     \\<subseteq> snd (bf M r (j', i'));\n        ((j', i'), x) \\<in> pair_less; (j', i') \\<in> IJ k\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r x) \\<subseteq> snd (bf M r (j', i'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "proof (cases u)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       u = (a, b) \\<Longrightarrow>\n       snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "case (Pair j i)"], ["proof (state)\nthis:\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       u = (a, b) \\<Longrightarrow>\n       snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "then"], ["proof (chain)\npicking this:\n  u = (j, i)", "consider \"prev j i = Some (j', i')\" | x where \"((j', i'), x) \\<in> pair_less\" \"prev j i = Some x\""], ["proof (prove)\nusing this:\n  u = (j, i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using less.prems pair_less_prev"], ["proof (prove)\nusing this:\n  u = (j, i)\n  ((j', i'), u) \\<in> pair_less\n  (j', i') \\<in> IJ k\n  \\<lbrakk>(?u, ?j, ?i) \\<in> pair_less; ?u \\<in> IJ ?k\\<rbrakk>\n  \\<Longrightarrow> prev ?j ?i = Some ?u \\<or>\n                    (\\<exists>x.\n                        (?u, x) \\<in> pair_less \\<and> prev ?j ?i = Some x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       u = (a, b) \\<Longrightarrow>\n       snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. prev j i = Some (j', i') \\<Longrightarrow>\n    snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))\n 2. \\<And>x.\n       \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "case 1"], ["proof (state)\nthis:\n  prev j i = Some (j', i')\n\ngoal (2 subgoals):\n 1. prev j i = Some (j', i') \\<Longrightarrow>\n    snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))\n 2. \\<And>x.\n       \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "then"], ["proof (chain)\npicking this:\n  prev j i = Some (j', i')", "show ?thesis"], ["proof (prove)\nusing this:\n  prev j i = Some (j', i')\n\ngoal (1 subgoal):\n 1. snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "by (simp add: Pair bf_rec snd_grab_subset)"], ["proof (state)\nthis:\n  snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "case 2"], ["proof (state)\nthis:\n  ((j', i'), x) \\<in> pair_less\n  prev j i = Some x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "then"], ["proof (chain)\npicking this:\n  ((j', i'), x) \\<in> pair_less\n  prev j i = Some x", "have \"snd (bf M r x) \\<subseteq> snd (bf M r (j', i'))\""], ["proof (prove)\nusing this:\n  ((j', i'), x) \\<in> pair_less\n  prev j i = Some x\n\ngoal (1 subgoal):\n 1. snd (bf M r x) \\<subseteq> snd (bf M r (j', i'))", "by (simp add: Pair less.IH prev_pair_less that(2))"], ["proof (state)\nthis:\n  snd (bf M r x) \\<subseteq> snd (bf M r (j', i'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "moreover"], ["proof (state)\nthis:\n  snd (bf M r x) \\<subseteq> snd (bf M r (j', i'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "have \"snd (bf M r u) \\<subseteq> snd (bf M r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (bf M r u) \\<subseteq> snd (bf M r x)", "by (simp add: 2 Pair bf_rec snd_grab_subset)"], ["proof (state)\nthis:\n  snd (bf M r u) \\<subseteq> snd (bf M r x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>((j', i'), x) \\<in> pair_less; prev j i = Some x\\<rbrakk>\n       \\<Longrightarrow> snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "ultimately"], ["proof (chain)\npicking this:\n  snd (bf M r x) \\<subseteq> snd (bf M r (j', i'))\n  snd (bf M r u) \\<subseteq> snd (bf M r x)", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (bf M r x) \\<subseteq> snd (bf M r (j', i'))\n  snd (bf M r u) \\<subseteq> snd (bf M r x)\n\ngoal (1 subgoal):\n 1. snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))", "by auto"], ["proof (state)\nthis:\n  snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (bf M r u) \\<subseteq> snd (bf M r (j', i'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>((?j', ?i'), ?j, ?i) \\<in> pair_less;\n   (?j', ?i') \\<in> IJ ?k\\<rbrakk>\n  \\<Longrightarrow> snd (bf ?M ?r (?j, ?i))\n                    \\<subseteq> snd (bf ?M ?r (?j', ?i'))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have less_bf: \"fst (bf M r (j',i')) \\<lless> fst (bf M r (j,i))\"\n    if ji: \"((j',i'), (j,i)) \\<in> pair_less\" \"(j',i') \\<in> IJ k\" and \"infinite M\"\n    for M r k j i j' i'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "consider \"prev j i = Some (j', i')\" | j'' i'' where \"((j', i'), (j'',i'')) \\<in> pair_less\" \"prev j i = Some (j'',i'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> thesis;\n     \\<And>j'' i''.\n        \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n         prev j i = Some (j'', i'')\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis pair_less_prev ji prod.exhaust_sel)"], ["proof (state)\nthis:\n  \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> ?thesis;\n   \\<And>j'' i''.\n      \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n       prev j i = Some (j'', i'')\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> ?thesis;\n   \\<And>j'' i''.\n      \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n       prev j i = Some (j'', i'')\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>prev j i = Some (j', i') \\<Longrightarrow> ?thesis;\n   \\<And>j'' i''.\n      \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n       prev j i = Some (j'', i'')\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. prev j i = Some (j', i') \\<Longrightarrow>\n    fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))\n 2. \\<And>j'' i''.\n       \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n        prev j i = Some (j'', i'')\\<rbrakk>\n       \\<Longrightarrow> fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "case 1"], ["proof (state)\nthis:\n  prev j i = Some (j', i')\n\ngoal (2 subgoals):\n 1. prev j i = Some (j', i') \\<Longrightarrow>\n    fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))\n 2. \\<And>j'' i''.\n       \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n        prev j i = Some (j'', i'')\\<rbrakk>\n       \\<Longrightarrow> fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "then"], ["proof (chain)\npicking this:\n  prev j i = Some (j', i')", "show ?thesis"], ["proof (prove)\nusing this:\n  prev j i = Some (j', i')\n\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "using bf_less_sets bf_rec infinite_bf less_sets_fst_grab \\<open>infinite M\\<close>"], ["proof (prove)\nusing this:\n  prev j i = Some (j', i')\n  infinite ?M \\<Longrightarrow>\n  fst (bf ?M ?q ?ij) \\<lless> snd (bf ?M ?q ?ij)\n  bf ?M ?q (?j, ?i) =\n  (let R = case prev ?j ?i of None \\<Rightarrow> ?M\n           | Some u \\<Rightarrow> snd (bf ?M ?q u)\n   in grab R (?q ?j ?i))\n  infinite (snd (bf ?M ?q ?u)) = infinite ?M\n  ?A \\<lless> ?N \\<Longrightarrow> ?A \\<lless> fst (grab ?N ?n)\n  infinite M\n\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "by auto"], ["proof (state)\nthis:\n  fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))\n\ngoal (1 subgoal):\n 1. \\<And>j'' i''.\n       \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n        prev j i = Some (j'', i'')\\<rbrakk>\n       \\<Longrightarrow> fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j'' i''.\n       \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n        prev j i = Some (j'', i'')\\<rbrakk>\n       \\<Longrightarrow> fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "case 2"], ["proof (state)\nthis:\n  ((j', i'), j'', i'') \\<in> pair_less\n  prev j i = Some (j'', i'')\n\ngoal (1 subgoal):\n 1. \\<And>j'' i''.\n       \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n        prev j i = Some (j'', i'')\\<rbrakk>\n       \\<Longrightarrow> fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "then"], ["proof (chain)\npicking this:\n  ((j', i'), j'', i'') \\<in> pair_less\n  prev j i = Some (j'', i'')", "have \"fst (bf M r (j',i')) \\<lless> snd (bf M r (j'',i''))\""], ["proof (prove)\nusing this:\n  ((j', i'), j'', i'') \\<in> pair_less\n  prev j i = Some (j'', i'')\n\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> snd (bf M r (j'', i''))", "by (meson bf_less_sets snd_bf_subset less_sets_weaken2 that)"], ["proof (state)\nthis:\n  fst (bf M r (j', i')) \\<lless> snd (bf M r (j'', i''))\n\ngoal (1 subgoal):\n 1. \\<And>j'' i''.\n       \\<lbrakk>((j', i'), j'', i'') \\<in> pair_less;\n        prev j i = Some (j'', i'')\\<rbrakk>\n       \\<Longrightarrow> fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "with 2"], ["proof (chain)\npicking this:\n  ((j', i'), j'', i'') \\<in> pair_less\n  prev j i = Some (j'', i'')\n  fst (bf M r (j', i')) \\<lless> snd (bf M r (j'', i''))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((j', i'), j'', i'') \\<in> pair_less\n  prev j i = Some (j'', i'')\n  fst (bf M r (j', i')) \\<lless> snd (bf M r (j'', i''))\n\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "using bf_rec infinite_bf less_sets_fst_grab \\<open>infinite M\\<close>"], ["proof (prove)\nusing this:\n  ((j', i'), j'', i'') \\<in> pair_less\n  prev j i = Some (j'', i'')\n  fst (bf M r (j', i')) \\<lless> snd (bf M r (j'', i''))\n  bf ?M ?q (?j, ?i) =\n  (let R = case prev ?j ?i of None \\<Rightarrow> ?M\n           | Some u \\<Rightarrow> snd (bf ?M ?q u)\n   in grab R (?q ?j ?i))\n  infinite (snd (bf ?M ?q ?u)) = infinite ?M\n  ?A \\<lless> ?N \\<Longrightarrow> ?A \\<lless> fst (grab ?N ?n)\n  infinite M\n\ngoal (1 subgoal):\n 1. fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))", "by auto"], ["proof (state)\nthis:\n  fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (bf M r (j', i')) \\<lless> fst (bf M r (j, i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>((?j', ?i'), ?j, ?i) \\<in> pair_less; (?j', ?i') \\<in> IJ ?k;\n   infinite ?M\\<rbrakk>\n  \\<Longrightarrow> fst (bf ?M ?r (?j', ?i')) \\<lless>\n                    fst (bf ?M ?r (?j, ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have aM: \"a k \\<lless> M (Suc k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. a k \\<lless> M (Suc k)", "apply (clarsimp simp add: a_def M_def DF_simps F_def Let_def split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> x1b \\<lless>\n                         snd (bf x2a (ediff (x1(k := x1a))) (k, k - Suc 0))", "by (meson bf_subset grab_eqD infinite_nxtN less_sets_weaken2 local.inf)"], ["proof (state)\nthis:\n  a ?k \\<lless> M (Suc ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  a ?k \\<lless> M (Suc ?k)", "have \"a k \\<lless> a (Suc k)\" for k"], ["proof (prove)\nusing this:\n  a ?k \\<lless> M (Suc ?k)\n\ngoal (1 subgoal):\n 1. a k \\<lless> a (Suc k)", "by (metis IntE card_d card.empty d_eq da fst_grab_subset less_sets_trans less_sets_weaken2 nat.distinct(1) nxt_def subsetI)"], ["proof (state)\nthis:\n  a ?k \\<lless> a (Suc ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  a ?k \\<lless> a (Suc ?k)", "have aa: \"a j \\<lless> a k\" if \"j<k\" for k j"], ["proof (prove)\nusing this:\n  a ?k \\<lless> a (Suc ?k)\n\ngoal (1 subgoal):\n 1. a j \\<lless> a k", "by (meson UNIV_I a_ne less_sets_imp_strict_mono_sets strict_mono_sets_def that)"], ["proof (state)\nthis:\n  ?j < ?k \\<Longrightarrow> a ?j \\<lless> a ?k\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?j < ?k \\<Longrightarrow> a ?j \\<lless> a ?k", "have ab: \"a k' \\<lless> b k (j,i)\" if \"k'\\<le>k\" for k k' j i"], ["proof (prove)\nusing this:\n  ?j < ?k \\<Longrightarrow> a ?j \\<lless> a ?k\n\ngoal (1 subgoal):\n 1. a k' \\<lless> b k (j, i)", "by (metis a_ne ab_same le_less less_sets_UN2 less_sets_trans rangeI that)"], ["proof (state)\nthis:\n  ?k' \\<le> ?k \\<Longrightarrow> a ?k' \\<lless> b ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have db: \"d j \\<lless> b k (j,i)\" if \"j\\<le>k\" for k j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. d j \\<lless> b k (j, i)", "by (meson a_ne ab da less_sets_trans that)"], ["proof (state)\nthis:\n  ?j \\<le> ?k \\<Longrightarrow> d ?j \\<lless> b ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bMkk: \"b k (k,k-1) \\<lless> M (Suc k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (k, k - 1) \\<lless> M (Suc k)", "using \\<Psi>_DF [of k]"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc k)) k\n\ngoal (1 subgoal):\n 1. b k (k, k - 1) \\<lless> M (Suc k)", "by (simp add: \\<Psi>_def b_def d_def M_def split: prod.split_asm)"], ["proof (state)\nthis:\n  b ?k (?k, ?k - 1) \\<lless> M (Suc ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b: \"\\<exists>P \\<subseteq> M k. infinite P \\<and> (\\<forall>j i. i\\<le>j \\<longrightarrow> j\\<le>k \\<longrightarrow> b k (j,i) = fst (bf P (ediff d) (j,i)))\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<subseteq>M k.\n       infinite P \\<and>\n       (\\<forall>j i.\n           i \\<le> j \\<longrightarrow>\n           j \\<le> k \\<longrightarrow>\n           b k (j, i) = fst (bf P (ediff d) (j, i)))", "proof (clarsimp simp: b_def DF_simps F_def Let_def split: prod.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "fix a a' d' dl bb P M' M''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "assume gr: \"grab M'' (Min d') = (a', M')\" \"grab (nxt P (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d', M'')\"\n      and DF: \"DF k = (dl, a, bb, P)\""], ["proof (state)\nthis:\n  grab M'' (Min d') = (a', M')\n  grab (nxt P (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d', M'')\n  DF k = (dl, a, bb, P)\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "have deq: \"d j = (if j = k then d' else dl j)\" if \"j\\<le>k\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. d j = (if j = k then d' else dl j)", "proof (cases \"j < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)\n 2. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "case True"], ["proof (state)\nthis:\n  j < k\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)\n 2. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "then"], ["proof (chain)\npicking this:\n  j < k", "show ?thesis"], ["proof (prove)\nusing this:\n  j < k\n\ngoal (1 subgoal):\n 1. d j = (if j = k then d' else dl j)", "by (metis DF d_eq_dl less_not_refl)"], ["proof (state)\nthis:\n  d j = (if j = k then d' else dl j)\n\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "case False"], ["proof (state)\nthis:\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "then"], ["proof (chain)\npicking this:\n  \\<not> j < k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. d j = (if j = k then d' else dl j)", "using that DF gr"], ["proof (prove)\nusing this:\n  \\<not> j < k\n  j \\<le> k\n  DF k = (dl, a, bb, P)\n  grab M'' (Min d') = (a', M')\n  grab (nxt P (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d', M'')\n\ngoal (1 subgoal):\n 1. d j = (if j = k then d' else dl j)", "by (auto simp: d_def DF_simps F_def Let_def split: prod.split)"], ["proof (state)\nthis:\n  d j = (if j = k then d' else dl j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j \\<le> k \\<Longrightarrow> d ?j = (if ?j = k then d' else dl ?j)\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "have \"M' \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M' \\<subseteq> P", "by (metis gr in_mono nxt_subset snd_conv snd_grab_subset subsetI)"], ["proof (state)\nthis:\n  M' \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "also"], ["proof (state)\nthis:\n  M' \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "have \"P \\<subseteq> M k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> M k", "using DF"], ["proof (prove)\nusing this:\n  DF k = (dl, a, bb, P)\n\ngoal (1 subgoal):\n 1. P \\<subseteq> M k", "by (simp add: M_def)"], ["proof (state)\nthis:\n  P \\<subseteq> M k\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "finally"], ["proof (chain)\npicking this:\n  M' \\<subseteq> M k", "have \"M' \\<subseteq> M k\""], ["proof (prove)\nusing this:\n  M' \\<subseteq> M k\n\ngoal (1 subgoal):\n 1. M' \\<subseteq> M k", "."], ["proof (state)\nthis:\n  M' \\<subseteq> M k\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "moreover"], ["proof (state)\nthis:\n  M' \\<subseteq> M k\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "have \"infinite M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite M'", "using DF"], ["proof (prove)\nusing this:\n  DF k = (dl, a, bb, P)\n\ngoal (1 subgoal):\n 1. infinite M'", "by (metis (mono_tags) finite_grab_iff gr infinite_nxtN local.inf snd_conv)"], ["proof (state)\nthis:\n  infinite M'\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "moreover"], ["proof (state)\nthis:\n  infinite M'\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "have \"ediff (dl(k := d')) j i = ediff d j i\" if \"j\\<le>k\" for j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. ediff (dl(k := d')) j i = ediff d j i", "by (simp add: deq that ediff_def)"], ["proof (state)\nthis:\n  ?j \\<le> k \\<Longrightarrow> ediff (dl(k := d')) ?j ?i = ediff d ?j ?i\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "then"], ["proof (chain)\npicking this:\n  ?j \\<le> k \\<Longrightarrow> ediff (dl(k := d')) ?j ?i = ediff d ?j ?i", "have \"bf M' (ediff (dl(k := d'))) (j,i)\n             = bf M' (ediff d) (j,i)\" if \"i \\<le> j\" \"j\\<le>k\" for j i"], ["proof (prove)\nusing this:\n  ?j \\<le> k \\<Longrightarrow> ediff (dl(k := d')) ?j ?i = ediff d ?j ?i\n\ngoal (1 subgoal):\n 1. bf M' (ediff (dl(k := d'))) (j, i) = bf M' (ediff d) (j, i)", "using bf_cong that"], ["proof (prove)\nusing this:\n  ?j \\<le> k \\<Longrightarrow> ediff (dl(k := d')) ?j ?i = ediff d ?j ?i\n  \\<lbrakk>snd ?u \\<le> fst ?u;\n   \\<And>y x.\n      \\<lbrakk>x \\<le> y; y \\<le> fst ?u\\<rbrakk>\n      \\<Longrightarrow> ?q' y x = ?q y x\\<rbrakk>\n  \\<Longrightarrow> bf ?M ?q ?u = bf ?M ?q' ?u\n  i \\<le> j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. bf M' (ediff (dl(k := d'))) (j, i) = bf M' (ediff d) (j, i)", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> bf M' (ediff (dl(k := d'))) (?j, ?i) =\n                    bf M' (ediff d) (?j, ?i)\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<subseteq>M k.\n                            infinite P \\<and>\n                            (\\<forall>j i.\n                                i \\<le> j \\<longrightarrow>\n                                j \\<le> k \\<longrightarrow>\n                                fst (bf x2a (ediff (x1(k := x1a))) (j, i)) =\n                                fst (bf P (ediff d) (j, i)))", "ultimately"], ["proof (chain)\npicking this:\n  M' \\<subseteq> M k\n  infinite M'\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> bf M' (ediff (dl(k := d'))) (?j, ?i) =\n                    bf M' (ediff d) (?j, ?i)", "show \"\\<exists>P\\<subseteq>M k. infinite P \\<and>\n                           (\\<forall>j i. i \\<le> j \\<longrightarrow> j \\<le> k\n                                        \\<longrightarrow> fst (bf M' (ediff (dl(k := d'))) (j,i))\n                         = fst (bf P (ediff d) (j,i)))\""], ["proof (prove)\nusing this:\n  M' \\<subseteq> M k\n  infinite M'\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> bf M' (ediff (dl(k := d'))) (?j, ?i) =\n                    bf M' (ediff d) (?j, ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<subseteq>M k.\n       infinite P \\<and>\n       (\\<forall>j i.\n           i \\<le> j \\<longrightarrow>\n           j \\<le> k \\<longrightarrow>\n           fst (bf M' (ediff (dl(k := d'))) (j, i)) =\n           fst (bf P (ediff d) (j, i)))", "by auto"], ["proof (state)\nthis:\n  \\<exists>P\\<subseteq>M k.\n     infinite P \\<and>\n     (\\<forall>j i.\n         i \\<le> j \\<longrightarrow>\n         j \\<le> k \\<longrightarrow>\n         fst (bf M' (ediff (dl(k := d'))) (j, i)) =\n         fst (bf P (ediff d) (j, i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P\\<subseteq>M ?k.\n     infinite P \\<and>\n     (\\<forall>j i.\n         i \\<le> j \\<longrightarrow>\n         j \\<le> ?k \\<longrightarrow>\n         b ?k (j, i) = fst (bf P (ediff d) (j, i)))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have card_b: \"card (b k (j,i)) = enum (d j) (Suc i) - enum (d j) i\" if \"j\\<le>k\" for k j i\n    \\<comment>\\<open>there's a short proof of this from the previous result but it would need @{term\"i\\<le>j\"}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b k (j, i)) = enum (d j) (Suc i) - enum (d j) i", "proof (clarsimp simp: b_def DF_simps F_def Let_def split: prod.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> card (fst (bf x2a (ediff (x1(k := x1a))) (j, i))) =\n                         enum (d j) (Suc i) - enum (d j) i", "fix dl\n      and a a' d':: \"nat set\"\n      and bb M M' M''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> card (fst (bf x2a (ediff (x1(k := x1a))) (j, i))) =\n                         enum (d j) (Suc i) - enum (d j) i", "assume gr: \"grab M'' (Min d') = (a', M')\" \"grab (nxt M (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d',M'')\"\n      and DF: \"DF k = (dl, a, bb, M)\""], ["proof (state)\nthis:\n  grab M'' (Min d') = (a', M')\n  grab (nxt M (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d', M'')\n  DF k = (dl, a, bb, M)\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> card (fst (bf x2a (ediff (x1(k := x1a))) (j, i))) =\n                         enum (d j) (Suc i) - enum (d j) i", "have \"d j = (if j = k then d' else dl j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d j = (if j = k then d' else dl j)", "proof (cases \"j < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)\n 2. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "case True"], ["proof (state)\nthis:\n  j < k\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)\n 2. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "then"], ["proof (chain)\npicking this:\n  j < k", "show ?thesis"], ["proof (prove)\nusing this:\n  j < k\n\ngoal (1 subgoal):\n 1. d j = (if j = k then d' else dl j)", "by (metis DF d_eq_dl less_not_refl)"], ["proof (state)\nthis:\n  d j = (if j = k then d' else dl j)\n\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "case False"], ["proof (state)\nthis:\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow> d j = (if j = k then d' else dl j)", "then"], ["proof (chain)\npicking this:\n  \\<not> j < k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. d j = (if j = k then d' else dl j)", "using that DF gr"], ["proof (prove)\nusing this:\n  \\<not> j < k\n  j \\<le> k\n  DF k = (dl, a, bb, M)\n  grab M'' (Min d') = (a', M')\n  grab (nxt M (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d', M'')\n\ngoal (1 subgoal):\n 1. d j = (if j = k then d' else dl j)", "by (auto simp: d_def DF_simps F_def Let_def split: prod.split)"], ["proof (state)\nthis:\n  d j = (if j = k then d' else dl j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d j = (if j = k then d' else dl j)\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> card (fst (bf x2a (ediff (x1(k := x1a))) (j, i))) =\n                         enum (d j) (Suc i) - enum (d j) i", "then"], ["proof (chain)\npicking this:\n  d j = (if j = k then d' else dl j)", "show \"card (fst (bf M' (ediff (dl(k := d'))) (j,i)))\n             = enum (d j) (Suc i) - enum (d j) i\""], ["proof (prove)\nusing this:\n  d j = (if j = k then d' else dl j)\n\ngoal (1 subgoal):\n 1. card (fst (bf M' (ediff (dl(k := d'))) (j, i))) =\n    enum (d j) (Suc i) - enum (d j) i", "using DF gr card_fst_bf grab_eqD infinite_nxtN local.inf ediff_def"], ["proof (prove)\nusing this:\n  d j = (if j = k then d' else dl j)\n  DF k = (dl, a, bb, M)\n  grab M'' (Min d') = (a', M')\n  grab (nxt M (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d', M'')\n  infinite ?M \\<Longrightarrow>\n  finite (fst (bf ?M ?q (?j, ?i))) \\<and>\n  card (fst (bf ?M ?q (?j, ?i))) = ?q ?j ?i\n  \\<lbrakk>grab ?N ?n = (?A, ?M); infinite ?N\\<rbrakk>\n  \\<Longrightarrow> ?A \\<lless> ?M \\<and>\n                    finite ?A \\<and>\n                    card ?A = ?n \\<and>\n                    infinite ?M \\<and>\n                    ?A \\<subseteq> ?N \\<and> ?M \\<subseteq> ?N\n  infinite ?N \\<Longrightarrow> infinite (nxt ?N ?n)\n  DF ?l = (?dl, ?al, ?bl, ?L) \\<Longrightarrow> infinite ?L\n  ediff \\<equiv> \\<lambda>D j i. enum (D j) (Suc i) - enum (D j) i\n\ngoal (1 subgoal):\n 1. card (fst (bf M' (ediff (dl(k := d'))) (j, i))) =\n    enum (d j) (Suc i) - enum (d j) i", "by auto"], ["proof (state)\nthis:\n  card (fst (bf M' (ediff (dl(k := d'))) (j, i))) =\n  enum (d j) (Suc i) - enum (d j) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j \\<le> ?k \\<Longrightarrow>\n  card (b ?k (?j, ?i)) = enum (d ?j) (Suc ?i) - enum (d ?j) ?i\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have card_b_pos: \"card (b k (j,i)) > 0\" if \"i < j\" \"j\\<le>k\" for k j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card (b k (j, i))", "by (simp add: card_b that finite_enumerate_step)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> 0 < card (b ?k (?j, ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b_ne [simp]: \"b k (j,i) \\<noteq> {}\" if \"i < j\" \"j\\<le>k\" for k j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<noteq> {}", "using card_b_pos [OF that] less_imp_neq"], ["proof (prove)\nusing this:\n  0 < card (b k (j, i))\n  ?x < ?y \\<Longrightarrow> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<noteq> {}", "by fastforce+"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have card_b_finite [simp]: \"finite (b k u)\" for k u"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b k u)", "using \\<Psi>_DF [of k]"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc k)) k\n\ngoal (1 subgoal):\n 1. finite (b k u)", "by (fastforce simp add: \\<Psi>_def b_def)"], ["proof (state)\nthis:\n  finite (b ?k ?u)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bM: \"b k (j,i) \\<lless> M (Suc k)\" if \"i<j\" \"j\\<le>k\" for i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> M (Suc k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> M (Suc k)", "obtain M' where \"M' \\<subseteq> M k\" \"infinite M'\"\n      and bk: \"\\<And>j i. i\\<le>j \\<Longrightarrow> j\\<le>k \\<Longrightarrow> b k (j,i) = fst (bf M' (ediff d) (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M' \\<subseteq> M k; infinite M';\n         \\<And>j i.\n            \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk>\n            \\<Longrightarrow> b k (j, i) =\n                              fst (bf M' (ediff d) (j, i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b"], ["proof (prove)\nusing this:\n  \\<exists>P\\<subseteq>M ?k.\n     infinite P \\<and>\n     (\\<forall>j i.\n         i \\<le> j \\<longrightarrow>\n         j \\<le> ?k \\<longrightarrow>\n         b ?k (j, i) = fst (bf P (ediff d) (j, i)))\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M' \\<subseteq> M k; infinite M';\n         \\<And>j i.\n            \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk>\n            \\<Longrightarrow> b k (j, i) =\n                              fst (bf M' (ediff d) (j, i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  M' \\<subseteq> M k\n  infinite M'\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> b k (?j, ?i) = fst (bf M' (ediff d) (?j, ?i))\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> M (Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> M (Suc k)", "proof (cases \"j=k \\<and> i = k-1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = k \\<and> i = k - 1 \\<Longrightarrow> b k (j, i) \\<lless> M (Suc k)\n 2. \\<not> (j = k \\<and> i = k - 1) \\<Longrightarrow>\n    b k (j, i) \\<lless> M (Suc k)", "case False"], ["proof (state)\nthis:\n  \\<not> (j = k \\<and> i = k - 1)\n\ngoal (2 subgoals):\n 1. j = k \\<and> i = k - 1 \\<Longrightarrow> b k (j, i) \\<lless> M (Suc k)\n 2. \\<not> (j = k \\<and> i = k - 1) \\<Longrightarrow>\n    b k (j, i) \\<lless> M (Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> M (Suc k)", "proof (rule less_sets_trans [OF _ bMkk])"], ["proof (state)\ngoal (2 subgoals):\n 1. b k (j, i) \\<lless> b k (k, k - 1)\n 2. b k (k, k - 1) \\<noteq> {}", "show \"b k (j,i) \\<lless> b k (k, k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> b k (k, k - 1)", "using that \\<open>infinite M'\\<close> False"], ["proof (prove)\nusing this:\n  i < j\n  j \\<le> k\n  infinite M'\n  \\<not> (j = k \\<and> i = k - 1)\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> b k (k, k - 1)", "by (force simp: bk pair_less_def IJ_def intro: less_bf)"], ["proof (state)\nthis:\n  b k (j, i) \\<lless> b k (k, k - 1)\n\ngoal (1 subgoal):\n 1. b k (k, k - 1) \\<noteq> {}", "show \"b k (k, k - 1) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (k, k - 1) \\<noteq> {}", "using b_ne that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<noteq> {}\n  i < j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. b k (k, k - 1) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  b k (k, k - 1) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b k (j, i) \\<lless> M (Suc k)\n\ngoal (1 subgoal):\n 1. j = k \\<and> i = k - 1 \\<Longrightarrow> b k (j, i) \\<lless> M (Suc k)", "qed (use bMkk in auto)"], ["proof (state)\nthis:\n  b k (j, i) \\<lless> M (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> M (Suc ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b_InfM: \"\\<Union> (range (b k)) \\<subseteq> {\\<Sqinter>(M k)..}\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range (b k)) \\<subseteq> {\\<Sqinter> (M k)..}", "proof (clarsimp simp add: \\<Psi>_def b_def M_def DF_simps F_def Let_def split: prod.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a x ab ba.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b);\n        x \\<in> fst (bf x2a (ediff (x1(k := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> b \\<le> x", "fix r dl :: \"nat \\<Rightarrow> nat set\"\n      and a b and d' a' M'' M' P :: \"nat set\"\n      and x j' i' :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a x ab ba.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b);\n        x \\<in> fst (bf x2a (ediff (x1(k := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> b \\<le> x", "assume gr: \"grab M'' (Min d') = (a', M')\"\n               \"grab (nxt P (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d', M'')\"\n      and DF: \"DF k = (dl, a, b, P)\"\n      and x: \"x \\<in> fst (bf M' (ediff (dl(k := d'))) (j', i'))\""], ["proof (state)\nthis:\n  grab M'' (Min d') = (a', M')\n  grab (nxt P (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (d', M'')\n  DF k = (dl, a, b, P)\n  x \\<in> fst (bf M' (ediff (dl(k := d'))) (j', i'))\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a x ab ba.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b);\n        x \\<in> fst (bf x2a (ediff (x1(k := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> b \\<le> x", "have \"infinite P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite P", "using DF local.inf"], ["proof (prove)\nusing this:\n  DF k = (dl, a, b, P)\n  DF ?l = (?dl, ?al, ?bl, ?L) \\<Longrightarrow> infinite ?L\n\ngoal (1 subgoal):\n 1. infinite P", "by blast"], ["proof (state)\nthis:\n  infinite P\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a x ab ba.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b);\n        x \\<in> fst (bf x2a (ediff (x1(k := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> b \\<le> x", "then"], ["proof (chain)\npicking this:\n  infinite P", "have \"M' \\<subseteq> P\""], ["proof (prove)\nusing this:\n  infinite P\n\ngoal (1 subgoal):\n 1. M' \\<subseteq> P", "by (meson gr grab_eqD infinite_nxtN nxt_subset order.trans)"], ["proof (state)\nthis:\n  M' \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<And>x1 a aa b x1a x2 x1b x2a x ab ba.\n       \\<lbrakk>grab x2 (Min x1a) = (x1b, x2a);\n        grab (nxt b (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1a, x2);\n        DF k = (x1, a, aa, b);\n        x \\<in> fst (bf x2a (ediff (x1(k := x1a))) (ab, ba))\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> b \\<le> x", "with bf_subset"], ["proof (chain)\npicking this:\n  fst (bf ?M ?q ?u) \\<subseteq> ?M \\<and> snd (bf ?M ?q ?u) \\<subseteq> ?M\n  M' \\<subseteq> P", "show \"\\<Sqinter> P \\<le> (x::nat)\""], ["proof (prove)\nusing this:\n  fst (bf ?M ?q ?u) \\<subseteq> ?M \\<and> snd (bf ?M ?q ?u) \\<subseteq> ?M\n  M' \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<Sqinter> P \\<le> x", "using Inf_nat_def x le_less_linear not_less_Least"], ["proof (prove)\nusing this:\n  fst (bf ?M ?q ?u) \\<subseteq> ?M \\<and> snd (bf ?M ?q ?u) \\<subseteq> ?M\n  M' \\<subseteq> P\n  \\<Sqinter> ?X = (LEAST n. n \\<in> ?X)\n  x \\<in> fst (bf M' (ediff (dl(k := d'))) (j', i'))\n  ?x \\<le> ?y \\<or> ?y < ?x\n  ?k < (LEAST x. ?P x) \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. \\<Sqinter> P \\<le> x", "by fastforce"], ["proof (state)\nthis:\n  \\<Sqinter> P \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (range (b ?k)) \\<subseteq> {\\<Sqinter> (M ?k)..}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b_Inf_M_Suc: \"b k (j,i) \\<lless> {Inf(M (Suc k))}\" if \"i<j\" \"j\\<le>k\" for k j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> {\\<Sqinter> (M (Suc k))}", "using bMkk [of k] that"], ["proof (prove)\nusing this:\n  b k (k, k - 1) \\<lless> M (Suc k)\n  i < j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> {\\<Sqinter> (M (Suc k))}", "by (metis Inf_nat_def1 bM finite.emptyI infinite_M less_setsD less_sets_singleton2)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> {\\<Sqinter> (M (Suc ?k))}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bb_same: \"b k (j',i') \\<lless> b k (j,i)\"\n    if \"((j',i'), (j,i)) \\<in> pair_less\" \"(j',i') \\<in> IJ k\" for k j i j' i'"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j', i') \\<lless> b k (j, i)", "using that"], ["proof (prove)\nusing this:\n  ((j', i'), j, i) \\<in> pair_less\n  (j', i') \\<in> IJ k\n\ngoal (1 subgoal):\n 1. b k (j', i') \\<lless> b k (j, i)", "unfolding b_def DF_simps F_def Let_def"], ["proof (prove)\nusing this:\n  ((j', i'), j, i) \\<in> pair_less\n  (j', i') \\<in> IJ k\n\ngoal (1 subgoal):\n 1. (case case DF k of\n          (dl, a0, b0, M) \\<Rightarrow>\n            case grab (nxt M (enum N (Suc (2 * Suc k)))) (Suc k) of\n            (d, Md) \\<Rightarrow>\n              case grab Md (Min d) of\n              (a, Ma) \\<Rightarrow>\n                (dl(k := d), a, fst \\<circ> bf Ma (ediff (dl(k := d))),\n                 snd (bf Ma (ediff (dl(k := d))) (k, k - 1))) of\n     (dk, ak, bk, M) \\<Rightarrow> bk)\n     (j', i') \\<lless>\n    (case case DF k of\n          (dl, a0, b0, M) \\<Rightarrow>\n            case grab (nxt M (enum N (Suc (2 * Suc k)))) (Suc k) of\n            (d, Md) \\<Rightarrow>\n              case grab Md (Min d) of\n              (a, Ma) \\<Rightarrow>\n                (dl(k := d), a, fst \\<circ> bf Ma (ediff (dl(k := d))),\n                 snd (bf Ma (ediff (dl(k := d))) (k, k - 1))) of\n     (dk, ak, bk, M) \\<Rightarrow> bk)\n     (j, i)", "by (auto simp: less_bf grab_eqD infinite_nxtN local.inf split: prod.split)"], ["proof (state)\nthis:\n  \\<lbrakk>((?j', ?i'), ?j, ?i) \\<in> pair_less;\n   (?j', ?i') \\<in> IJ ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j', ?i') \\<lless> b ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bb: \"b k' (j',i') \\<lless> b k (j,i)\"\n    if j: \"i' < j'\" \"j'\\<le>k'\" and k: \"k'<k\" for i i' j j' k' k"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k' (j', i') \\<lless> b k (j, i)", "proof (rule atLeast_less_sets)"], ["proof (state)\ngoal (2 subgoals):\n 1. b k' (j', i') \\<lless> {?x}\n 2. b k (j, i) \\<subseteq> {?x..}", "show \"b k' (j', i') \\<lless> {Inf(M (Suc k'))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b k' (j', i') \\<lless> {\\<Sqinter> (M (Suc k'))}", "using Suc_lessD b_Inf_M_Suc nat_less_le j"], ["proof (prove)\nusing this:\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> {\\<Sqinter> (M (Suc ?k))}\n  (?m < ?n) = (?m \\<le> ?n \\<and> ?m \\<noteq> ?n)\n  i' < j'\n  j' \\<le> k'\n\ngoal (1 subgoal):\n 1. b k' (j', i') \\<lless> {\\<Sqinter> (M (Suc k'))}", "by blast"], ["proof (state)\nthis:\n  b k' (j', i') \\<lless> {\\<Sqinter> (M (Suc k'))}\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<subseteq> {\\<Sqinter> (M (Suc k'))..}", "have \"b k (j,i) \\<subseteq> {\\<Sqinter>(M k)..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<subseteq> {\\<Sqinter> (M k)..}", "by (rule order_trans [OF _ b_InfM]) auto"], ["proof (state)\nthis:\n  b k (j, i) \\<subseteq> {\\<Sqinter> (M k)..}\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<subseteq> {\\<Sqinter> (M (Suc k'))..}", "also"], ["proof (state)\nthis:\n  b k (j, i) \\<subseteq> {\\<Sqinter> (M k)..}\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<subseteq> {\\<Sqinter> (M (Suc k'))..}", "have \"\\<dots>  \\<subseteq> {Inf(M (Suc k'))..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<Sqinter> (M k)..} \\<subseteq> {\\<Sqinter> (M (Suc k'))..}", "using Inf_M_telescoping k"], ["proof (prove)\nusing this:\n  ?k' \\<le> ?k \\<Longrightarrow>\n  {\\<Sqinter> (M ?k)..} \\<subseteq> {\\<Sqinter> (M ?k')..}\n  k' < k\n\ngoal (1 subgoal):\n 1. {\\<Sqinter> (M k)..} \\<subseteq> {\\<Sqinter> (M (Suc k'))..}", "by auto"], ["proof (state)\nthis:\n  {\\<Sqinter> (M k)..} \\<subseteq> {\\<Sqinter> (M (Suc k'))..}\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<subseteq> {\\<Sqinter> (M (Suc k'))..}", "finally"], ["proof (chain)\npicking this:\n  b k (j, i) \\<subseteq> {\\<Sqinter> (M (Suc k'))..}", "show \"b k (j,i) \\<subseteq> {Inf(M (Suc k'))..}\""], ["proof (prove)\nusing this:\n  b k (j, i) \\<subseteq> {\\<Sqinter> (M (Suc k'))..}\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<subseteq> {\\<Sqinter> (M (Suc k'))..}", "."], ["proof (state)\nthis:\n  b k (j, i) \\<subseteq> {\\<Sqinter> (M (Suc k'))..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < ?j'; ?j' \\<le> ?k'; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k' (?j', ?i') \\<lless> b ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have M_subset_N: \"M k \\<subseteq> N\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. M k \\<subseteq> N", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> M k \\<subseteq> N\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> M k \\<subseteq> N", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> M k \\<subseteq> N\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> M k \\<subseteq> N", "with \\<Psi>_DF [of k']"], ["proof (chain)\npicking this:\n  \\<Psi> (DF (Suc k')) k'\n  k = Suc k'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc k')) k'\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. M k \\<subseteq> N", "by (auto simp: M_def Let_def \\<Psi>_def split: prod.split)"], ["proof (state)\nthis:\n  M k \\<subseteq> N\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> M k \\<subseteq> N", "qed (auto simp: M_def DF_simps)"], ["proof (state)\nthis:\n  M ?k \\<subseteq> N\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have a_subset_N: \"a k \\<subseteq> N\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. a k \\<subseteq> N", "using \\<Psi>_DF [of k]"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc k)) k\n\ngoal (1 subgoal):\n 1. a k \\<subseteq> N", "by (simp add: a_def \\<Psi>_def split: prod.split prod.split_asm)"], ["proof (state)\nthis:\n  a ?k \\<subseteq> N\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have d_subset_N: \"d k \\<subseteq> N\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. d k \\<subseteq> N", "using M_subset_N [of k] d_eq fst_grab_subset nxt_subset"], ["proof (prove)\nusing this:\n  M k \\<subseteq> N\n  d ?k = fst (grab (nxt (M ?k) (enum N (Suc (2 * Suc ?k)))) (Suc ?k))\n  fst (grab ?N ?n) \\<subseteq> ?N\n  nxt ?N ?n \\<subseteq> ?N\n\ngoal (1 subgoal):\n 1. d k \\<subseteq> N", "by blast"], ["proof (state)\nthis:\n  d ?k \\<subseteq> N\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b_subset_N: \"b k (j,i) \\<subseteq> N\" for k j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<subseteq> N", "using \\<Psi>_DF [of k]"], ["proof (prove)\nusing this:\n  \\<Psi> (DF (Suc k)) k\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<subseteq> N", "by (force simp: b_def \\<Psi>_def)"], ["proof (state)\nthis:\n  b ?k (?j, ?i) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define \\<K>:: \"[nat,nat] \\<Rightarrow> nat set set\"\n    where \"\\<K> \\<equiv> \\<lambda>j0 j. nsets {j0<..} j\""], ["proof (state)\nthis:\n  \\<K> \\<equiv> \\<lambda>j0. nsets {j0<..}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<K>_finite: \"K \\<in> \\<K> j0 j \\<Longrightarrow> finite K\" for K j0 j"], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<in> \\<K> j0 j \\<Longrightarrow> finite K", "by (simp add: \\<K>_def nsets_def)"], ["proof (state)\nthis:\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> finite ?K\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<K>_card: \"K \\<in> \\<K> j0 j \\<Longrightarrow> card K = j\" for K j0 j"], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<in> \\<K> j0 j \\<Longrightarrow> card K = j", "by (simp add: \\<K>_def nsets_def)"], ["proof (state)\nthis:\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<K>_enum: \"j0 < enum K i\" if \"K \\<in> \\<K> j0 j\" \"i < card K\" for K j0 j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. j0 < enum K i", "using that"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j0 j\n  i < card K\n\ngoal (1 subgoal):\n 1. j0 < enum K i", "by (auto simp: \\<K>_def nsets_def finite_enumerate_in_set subset_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?i < card ?K\\<rbrakk>\n  \\<Longrightarrow> ?j0.0 < enum ?K ?i\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<K>_0 [simp]: \"\\<K> k 0 = {{}}\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<K> k 0 = {{}}", "by (auto simp: \\<K>_def)"], ["proof (state)\nthis:\n  \\<K> ?k 0 = {{}}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<K>_Suc: \"\\<K> j0 (Suc j) = USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\" (is \"?lhs = ?rhs\")\n    for j j0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<K> j0 (Suc j) =\n    USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<K> j0 (Suc j)\n    \\<subseteq> USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\n 2. USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\n    \\<subseteq> \\<K> j0 (Suc j)", "show \"\\<K> j0 (Suc j) \\<subseteq> USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<K> j0 (Suc j)\n    \\<subseteq> USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})", "unfolding \\<K>_def nsets_def USigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {N. N \\<subseteq> {j0<..} \\<and> finite N \\<and> card N = Suc j}\n    \\<subseteq> (\\<Union>X\\<in>{N. N \\<subseteq> {j0<..} \\<and>\n                                   finite N \\<and> card N = j}.\n                    \\<Union>y\\<in>{Max (insert j0 X)<..}. {insert y X})", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> {j0<..}; finite x; card x = Suc j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>{j0<..}.\n                            finite xa \\<and>\n                            card xa = j \\<and>\n                            (\\<exists>xb\\<in>{Max (insert j0 xa)<..}.\n                                x = insert xb xa)", "fix K"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> {j0<..}; finite x; card x = Suc j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>{j0<..}.\n                            finite xa \\<and>\n                            card xa = j \\<and>\n                            (\\<exists>xb\\<in>{Max (insert j0 xa)<..}.\n                                x = insert xb xa)", "assume K: \"K \\<subseteq> {j0<..}\" \"finite K\" \"card K = Suc j\""], ["proof (state)\nthis:\n  K \\<subseteq> {j0<..}\n  finite K\n  card K = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> {j0<..}; finite x; card x = Suc j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>{j0<..}.\n                            finite xa \\<and>\n                            card xa = j \\<and>\n                            (\\<exists>xb\\<in>{Max (insert j0 xa)<..}.\n                                x = insert xb xa)", "then"], ["proof (chain)\npicking this:\n  K \\<subseteq> {j0<..}\n  finite K\n  card K = Suc j", "obtain i where \"Max (insert j0 (K - {Max K})) < i\" \"K = insert i (K - {Max K})\""], ["proof (prove)\nusing this:\n  K \\<subseteq> {j0<..}\n  finite K\n  card K = Suc j\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>Max (insert j0 (K - {Max K})) < i;\n         K = insert i (K - {Max K})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (simp add: subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>j0 < i \\<and> (\\<forall>a\\<in>K - {Max K}. a < i);\n                 K = insert i (K - {Max K})\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>t. t \\<in> K \\<longrightarrow> j0 < t; finite K;\n     card K = Suc j\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis Diff_iff Max.coboundedI Max_in card_0_eq insert_Diff insert_iff le_neq_implies_less nat.distinct(1))"], ["proof (state)\nthis:\n  Max (insert j0 (K - {Max K})) < i\n  K = insert i (K - {Max K})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> {j0<..}; finite x; card x = Suc j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>{j0<..}.\n                            finite xa \\<and>\n                            card xa = j \\<and>\n                            (\\<exists>xb\\<in>{Max (insert j0 xa)<..}.\n                                x = insert xb xa)", "then"], ["proof (chain)\npicking this:\n  Max (insert j0 (K - {Max K})) < i\n  K = insert i (K - {Max K})", "show \"\\<exists>L\\<subseteq>{j0<..}. finite L \\<and> card L = j \\<and>\n                 (\\<exists>i\\<in>{Max (insert j0 L)<..}. K = insert i L)\""], ["proof (prove)\nusing this:\n  Max (insert j0 (K - {Max K})) < i\n  K = insert i (K - {Max K})\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<subseteq>{j0<..}.\n       finite L \\<and>\n       card L = j \\<and>\n       (\\<exists>i\\<in>{Max (insert j0 L)<..}. K = insert i L)", "using K"], ["proof (prove)\nusing this:\n  Max (insert j0 (K - {Max K})) < i\n  K = insert i (K - {Max K})\n  K \\<subseteq> {j0<..}\n  finite K\n  card K = Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<subseteq>{j0<..}.\n       finite L \\<and>\n       card L = j \\<and>\n       (\\<exists>i\\<in>{Max (insert j0 L)<..}. K = insert i L)", "by (metis Max_in card_Diff_singleton_if card_gt_0_iff diff_Suc_1 finite_Diff greaterThan_iff insert_subset zero_less_Suc)"], ["proof (state)\nthis:\n  \\<exists>L\\<subseteq>{j0<..}.\n     finite L \\<and>\n     card L = j \\<and>\n     (\\<exists>i\\<in>{Max (insert j0 L)<..}. K = insert i L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<K> j0 (Suc j)\n  \\<subseteq> USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\n\ngoal (1 subgoal):\n 1. USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\n    \\<subseteq> \\<K> j0 (Suc j)", "show \"?rhs \\<subseteq> \\<K> j0 (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\n    \\<subseteq> \\<K> j0 (Suc j)", "by (force simp:  \\<K>_def nsets_def USigma_def)"], ["proof (state)\nthis:\n  USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\n  \\<subseteq> \\<K> j0 (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<K> ?j0.0 (Suc ?j) =\n  USigma (\\<K> ?j0.0 ?j) (\\<lambda>K. {Max (insert ?j0.0 K)<..})\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define BB where \"BB \\<equiv> \\<lambda>j0 j K. list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0,i)))\""], ["proof (state)\nthis:\n  BB \\<equiv>\n  \\<lambda>j0 j K.\n     list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i)))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define XX where \"XX \\<equiv> \\<lambda>j. BB j j ` \\<K> j j\""], ["proof (state)\nthis:\n  XX \\<equiv> \\<lambda>j. BB j j ` \\<K> j j\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have less_list_of:  \"BB j i K < list_of (b l (j,i))\"\n    if K: \"K \\<in> \\<K> j i\" \"\\<forall>j\\<in>K. j < l\" and \"i \\<le> j\" \"j \\<le> l\" for j i K l"], ["proof (prove)\ngoal (1 subgoal):\n 1. BB j i K < list_of (b l (j, i))", "unfolding BB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)))\n    < list_of (b l (j, i))", "proof (rule less_sets_imp_sorted_list_of_set)"], ["proof (state)\ngoal (3 subgoals):\n 1. a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)) \\<lless> b l (j, i)\n 2. finite (a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)))\n 3. finite (b l (j, i))", "have \"\\<And>i. i < card K \\<Longrightarrow> b (enum K i) (j,i) \\<lless> b l (j, card K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < card K \\<Longrightarrow>\n       b (enum K i) (j, i) \\<lless> b l (j, card K)", "using that"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j i\n  \\<forall>j\\<in>K. j < l\n  i \\<le> j\n  j \\<le> l\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < card K \\<Longrightarrow>\n       b (enum K i) (j, i) \\<lless> b l (j, card K)", "by (metis \\<K>_card \\<K>_enum \\<K>_finite bb finite_enumerate_in_set nat_less_le less_le_trans)"], ["proof (state)\nthis:\n  ?i < card K \\<Longrightarrow>\n  b (enum K ?i) (j, ?i) \\<lless> b l (j, card K)\n\ngoal (3 subgoals):\n 1. a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)) \\<lless> b l (j, i)\n 2. finite (a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)))\n 3. finite (b l (j, i))", "then"], ["proof (chain)\npicking this:\n  ?i < card K \\<Longrightarrow>\n  b (enum K ?i) (j, ?i) \\<lless> b l (j, card K)", "show \"a j \\<union> (\\<Union>i<i. b (enum K i) (j,i)) \\<lless> b l (j,i)\""], ["proof (prove)\nusing this:\n  ?i < card K \\<Longrightarrow>\n  b (enum K ?i) (j, ?i) \\<lless> b l (j, card K)\n\ngoal (1 subgoal):\n 1. a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)) \\<lless> b l (j, i)", "using that"], ["proof (prove)\nusing this:\n  ?i < card K \\<Longrightarrow>\n  b (enum K ?i) (j, ?i) \\<lless> b l (j, card K)\n  K \\<in> \\<K> j i\n  \\<forall>j\\<in>K. j < l\n  i \\<le> j\n  j \\<le> l\n\ngoal (1 subgoal):\n 1. a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)) \\<lless> b l (j, i)", "unfolding \\<K>_def nsets_def"], ["proof (prove)\nusing this:\n  ?i < card K \\<Longrightarrow>\n  b (enum K ?i) (j, ?i) \\<lless> b l (j, card K)\n  K \\<in> {N. N \\<subseteq> {j<..} \\<and> finite N \\<and> card N = i}\n  \\<forall>j\\<in>K. j < l\n  i \\<le> j\n  j \\<le> l\n\ngoal (1 subgoal):\n 1. a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)) \\<lless> b l (j, i)", "by (auto simp: less_sets_Un1 less_sets_UN1 ab finite_enumerate_in_set subset_eq)"], ["proof (state)\nthis:\n  a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)) \\<lless> b l (j, i)\n\ngoal (2 subgoals):\n 1. finite (a j \\<union> (\\<Union>i<i. b (enum K i) (j, i)))\n 2. finite (b l (j, i))", "qed auto"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<in> \\<K> ?j ?i; \\<forall>j\\<in>?K. j < ?l; ?i \\<le> ?j;\n   ?j \\<le> ?l\\<rbrakk>\n  \\<Longrightarrow> BB ?j ?i ?K < list_of (b ?l (?j, ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have BB_Suc: \"BB j0 (Suc j) K = usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K\"\n    if j: \"j \\<le> j0\" and K: \"K \\<in> \\<K> j0 (Suc j)\" for j0 j K\n    \\<comment>\\<open>towards the ordertype proof\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have Kj: \"K \\<subseteq> {j0<..}\" and [simp]: \"finite K\" and cardK: \"card K = Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<subseteq> {j0<..} &&& finite K &&& card K = Suc j", "using K"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j0 (Suc j)\n\ngoal (1 subgoal):\n 1. K \\<subseteq> {j0<..} &&& finite K &&& card K = Suc j", "by (auto simp: \\<K>_def nsets_def)"], ["proof (state)\nthis:\n  K \\<subseteq> {j0<..}\n  finite K\n  card K = Suc j\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have KMK: \"K - {Max K} \\<in> \\<K> j0 j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K - {Max K} \\<in> \\<K> j0 j", "using that"], ["proof (prove)\nusing this:\n  j \\<le> j0\n  K \\<in> \\<K> j0 (Suc j)\n\ngoal (1 subgoal):\n 1. K - {Max K} \\<in> \\<K> j0 j", "by (simp add: \\<K>_Suc USigma_iff \\<K>_finite less_sets_def usplit_def)"], ["proof (state)\nthis:\n  K - {Max K} \\<in> \\<K> j0 j\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have \"j0 < Max K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j0 < Max K", "by (metis Kj Max_in cardK card_gt_0_iff greaterThan_iff subsetD zero_less_Suc)"], ["proof (state)\nthis:\n  j0 < Max K\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have MaxK: \"Max K = enum K j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max K = enum K j", "proof (rule Max_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite K\n 2. \\<And>y. y \\<in> K \\<Longrightarrow> y \\<le> enum K j\n 3. enum K j \\<in> K", "show \"enum K j \\<in> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum K j \\<in> K", "by (simp add: cardK finite_enumerate_in_set)"], ["proof (state)\nthis:\n  enum K j \\<in> K\n\ngoal (2 subgoals):\n 1. finite K\n 2. \\<And>y. y \\<in> K \\<Longrightarrow> y \\<le> enum K j", "show \"k \\<le> enum K j\" if \"k \\<in> K\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> enum K j", "using that K"], ["proof (prove)\nusing this:\n  k \\<in> K\n  K \\<in> \\<K> j0 (Suc j)\n\ngoal (1 subgoal):\n 1. k \\<le> enum K j", "by (metis \\<open>finite K\\<close> cardK enum_obtain_index_finite finite_enumerate_mono leI less_Suc_eq less_asym)"], ["proof (state)\nthis:\n  ?k \\<in> K \\<Longrightarrow> ?k \\<le> enum K j\n\ngoal (1 subgoal):\n 1. finite K", "qed auto"], ["proof (state)\nthis:\n  Max K = enum K j\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have ene: \"i<j \\<Longrightarrow> enum (K - {enum K j}) i = enum K i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> enum (K - {enum K j}) i = enum K i", "using finite_enumerate_Diff_singleton [OF \\<open>finite K\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < card K; enum K ?i < ?x\\<rbrakk>\n  \\<Longrightarrow> enum (K - {?x}) ?i = enum K ?i\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> enum (K - {enum K j}) i = enum K i", "by (simp add: cardK)"], ["proof (state)\nthis:\n  ?i < j \\<Longrightarrow> enum (K - {enum K j}) ?i = enum K ?i\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have \"BB j0 (Suc j) K = list_of ((a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x))) \\<union> b (enum K j) (j0, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    list_of\n     (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<union>\n      b (enum K j) (j0, j))", "by (simp add: BB_def lessThan_Suc Un_ac)"], ["proof (state)\nthis:\n  BB j0 (Suc j) K =\n  list_of\n   (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<union>\n    b (enum K j) (j0, j))\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "also"], ["proof (state)\nthis:\n  BB j0 (Suc j) K =\n  list_of\n   (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<union>\n    b (enum K j) (j0, j))\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have \"\\<dots> = list_of ((a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i)))) @ list_of (b (enum K j) (j0, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of\n     (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<union>\n      b (enum K j) (j0, j)) =\n    list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i))) @\n    list_of (b (enum K j) (j0, j))", "proof (rule sorted_list_of_set_Un)"], ["proof (state)\ngoal (3 subgoals):\n 1. a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<lless>\n    b (enum K j) (j0, j)\n 2. finite (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)))\n 3. finite (b (enum K j) (j0, j))", "have \"b (enum K i) (j0, i) \\<lless> b (enum K j) (j0, j)\" if \"i<j\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. b (enum K i) (j0, i) \\<lless> b (enum K j) (j0, j)", "proof (rule bb)"], ["proof (state)\ngoal (3 subgoals):\n 1. i < j0\n 2. j0 \\<le> enum K i\n 3. enum K i < enum K j", "show \"i < j0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j0", "using j that"], ["proof (prove)\nusing this:\n  j \\<le> j0\n  i < j\n\ngoal (1 subgoal):\n 1. i < j0", "by linarith"], ["proof (state)\nthis:\n  i < j0\n\ngoal (2 subgoals):\n 1. j0 \\<le> enum K i\n 2. enum K i < enum K j", "show \"j0 \\<le> enum K i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j0 \\<le> enum K i", "using that K"], ["proof (prove)\nusing this:\n  i < j\n  K \\<in> \\<K> j0 (Suc j)\n\ngoal (1 subgoal):\n 1. j0 \\<le> enum K i", "by (metis \\<K>_enum cardK less_SucI less_imp_le_nat)"], ["proof (state)\nthis:\n  j0 \\<le> enum K i\n\ngoal (1 subgoal):\n 1. enum K i < enum K j", "show \"enum K i < enum K j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum K i < enum K j", "by (simp add: cardK finite_enumerate_mono that)"], ["proof (state)\nthis:\n  enum K i < enum K j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < j \\<Longrightarrow>\n  b (enum K ?i) (j0, ?i) \\<lless> b (enum K j) (j0, j)\n\ngoal (3 subgoals):\n 1. a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<lless>\n    b (enum K j) (j0, j)\n 2. finite (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)))\n 3. finite (b (enum K j) (j0, j))", "moreover"], ["proof (state)\nthis:\n  ?i < j \\<Longrightarrow>\n  b (enum K ?i) (j0, ?i) \\<lless> b (enum K j) (j0, j)\n\ngoal (3 subgoals):\n 1. a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<lless>\n    b (enum K j) (j0, j)\n 2. finite (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)))\n 3. finite (b (enum K j) (j0, j))", "have \"a j0 \\<lless> b (enum K j) (j0, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a j0 \\<lless> b (enum K j) (j0, j)", "using MaxK \\<open>j0 < Max K\\<close> ab"], ["proof (prove)\nusing this:\n  Max K = enum K j\n  j0 < Max K\n  ?k' \\<le> ?k \\<Longrightarrow> a ?k' \\<lless> b ?k (?j, ?i)\n\ngoal (1 subgoal):\n 1. a j0 \\<lless> b (enum K j) (j0, j)", "by auto"], ["proof (state)\nthis:\n  a j0 \\<lless> b (enum K j) (j0, j)\n\ngoal (3 subgoals):\n 1. a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<lless>\n    b (enum K j) (j0, j)\n 2. finite (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)))\n 3. finite (b (enum K j) (j0, j))", "ultimately"], ["proof (chain)\npicking this:\n  ?i < j \\<Longrightarrow>\n  b (enum K ?i) (j0, ?i) \\<lless> b (enum K j) (j0, j)\n  a j0 \\<lless> b (enum K j) (j0, j)", "show \"a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<lless> b (enum K j) (j0, j)\""], ["proof (prove)\nusing this:\n  ?i < j \\<Longrightarrow>\n  b (enum K ?i) (j0, ?i) \\<lless> b (enum K j) (j0, j)\n  a j0 \\<lless> b (enum K j) (j0, j)\n\ngoal (1 subgoal):\n 1. a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<lless>\n    b (enum K j) (j0, j)", "by (simp add: less_sets_Un1 less_sets_UN1)"], ["proof (state)\nthis:\n  a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<lless>\n  b (enum K j) (j0, j)\n\ngoal (2 subgoals):\n 1. finite (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)))\n 2. finite (b (enum K j) (j0, j))", "qed (auto simp: finite_UnI)"], ["proof (state)\nthis:\n  list_of\n   (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<union>\n    b (enum K j) (j0, j)) =\n  list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i))) @\n  list_of (b (enum K j) (j0, j))\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "also"], ["proof (state)\nthis:\n  list_of\n   (a j0 \\<union> (\\<Union>x<j. b (enum K x) (j0, x)) \\<union>\n    b (enum K j) (j0, j)) =\n  list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i))) @\n  list_of (b (enum K j) (j0, j))\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have \"\\<dots> = BB j0 j (K - {Max K}) @ list_of (b (Max K) (j0, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i))) @\n    list_of (b (enum K j) (j0, j)) =\n    BB j0 j (K - {Max K}) @ list_of (b (Max K) (j0, j))", "by (simp add: BB_def MaxK ene)"], ["proof (state)\nthis:\n  list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i))) @\n  list_of (b (enum K j) (j0, j)) =\n  BB j0 j (K - {Max K}) @ list_of (b (Max K) (j0, j))\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "also"], ["proof (state)\nthis:\n  list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i))) @\n  list_of (b (enum K j) (j0, j)) =\n  BB j0 j (K - {Max K}) @ list_of (b (Max K) (j0, j))\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "have \"\\<dots> = usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BB j0 j (K - {Max K}) @ list_of (b (Max K) (j0, j)) =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "by (simp add: usplit_def)"], ["proof (state)\nthis:\n  BB j0 j (K - {Max K}) @ list_of (b (Max K) (j0, j)) =\n  usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "finally"], ["proof (chain)\npicking this:\n  BB j0 (Suc j) K =\n  usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "show ?thesis"], ["proof (prove)\nusing this:\n  BB j0 (Suc j) K =\n  usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) K =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K", "."], ["proof (state)\nthis:\n  BB j0 (Suc j) K =\n  usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?j \\<le> ?j0.0; ?K \\<in> \\<K> ?j0.0 (Suc ?j)\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 (Suc ?j) ?K =\n                    usplit\n                     (\\<lambda>L k.\n                         BB ?j0.0 ?j L @ list_of (b k (?j0.0, ?j)))\n                     ?K\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have enum_d_0: \"enum (d j) 0 = Inf (d j)\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum (d j) 0 = \\<Sqinter> (d j)", "using enum_0_eq_Inf_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?N; ?N \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> enum ?N 0 = \\<Sqinter> ?N\n\ngoal (1 subgoal):\n 1. enum (d j) 0 = \\<Sqinter> (d j)", "by auto"], ["proof (state)\nthis:\n  enum (d ?j) 0 = \\<Sqinter> (d ?j)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have Inf_b_less: \"\\<Sqinter>(b k' (j',i')) < \\<Sqinter>(b k (j,i))\"\n    if j: \"i' < j'\" \"i < j\" \"j'\\<le>k'\" \"j\\<le>k\" and k: \"k'<k\" for i i' j j' k' k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (b k' (j', i')) < \\<Sqinter> (b k (j, i))", "using bb [of i' j' k' k j i] that b_ne [of i' j' k'] b_ne [of i j k]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i' < j'; j' \\<le> k'; k' < k\\<rbrakk>\n  \\<Longrightarrow> b k' (j', i') \\<lless> b k (j, i)\n  i' < j'\n  i < j\n  j' \\<le> k'\n  j \\<le> k\n  k' < k\n  \\<lbrakk>i' < j'; j' \\<le> k'\\<rbrakk>\n  \\<Longrightarrow> b k' (j', i') \\<noteq> {}\n  \\<lbrakk>i < j; j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> b k (j, i) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (b k' (j', i')) < \\<Sqinter> (b k (j, i))", "by (simp add: less_sets_def Inf_nat_def1)"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < ?j'; ?i < ?j; ?j' \\<le> ?k'; ?j \\<le> ?k; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> (b ?k' (?j', ?i'))\n                    < \\<Sqinter> (b ?k (?j, ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b_ge_k: \"\\<Sqinter> (b k (k, k-1)) \\<ge> k-1\" if \"k>0\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k - 1 \\<le> \\<Sqinter> (b k (k, k - 1))", "using that"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. k - 1 \\<le> \\<Sqinter> (b k (k, k - 1))", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < 0 \\<Longrightarrow> 0 - 1 \\<le> \\<Sqinter> (b 0 (0, 0 - 1))\n 2. \\<And>k.\n       \\<lbrakk>0 < k \\<Longrightarrow>\n                k - 1 \\<le> \\<Sqinter> (b k (k, k - 1));\n        0 < Suc k\\<rbrakk>\n       \\<Longrightarrow> Suc k - 1\n                         \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))", "case (Suc k)"], ["proof (state)\nthis:\n  0 < k \\<Longrightarrow> k - 1 \\<le> \\<Sqinter> (b k (k, k - 1))\n  0 < Suc k\n\ngoal (2 subgoals):\n 1. 0 < 0 \\<Longrightarrow> 0 - 1 \\<le> \\<Sqinter> (b 0 (0, 0 - 1))\n 2. \\<And>k.\n       \\<lbrakk>0 < k \\<Longrightarrow>\n                k - 1 \\<le> \\<Sqinter> (b k (k, k - 1));\n        0 < Suc k\\<rbrakk>\n       \\<Longrightarrow> Suc k - 1\n                         \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))", "proof (cases \"k=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))", "have \"\\<Sqinter> (b k (k, k - Suc 0)) < \\<Sqinter> (b (Suc k) (Suc k, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (b k (k, k - Suc 0)) < \\<Sqinter> (b (Suc k) (Suc k, k))", "using False Inf_b_less"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<lbrakk>?i' < ?j'; ?i < ?j; ?j' \\<le> ?k'; ?j \\<le> ?k; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> (b ?k' (?j', ?i'))\n                    < \\<Sqinter> (b ?k (?j, ?i))\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (b k (k, k - Suc 0)) < \\<Sqinter> (b (Suc k) (Suc k, k))", "by auto"], ["proof (state)\nthis:\n  \\<Sqinter> (b k (k, k - Suc 0)) < \\<Sqinter> (b (Suc k) (Suc k, k))\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))", "with False Suc"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  0 < k \\<Longrightarrow> k - 1 \\<le> \\<Sqinter> (b k (k, k - 1))\n  0 < Suc k\n  \\<Sqinter> (b k (k, k - Suc 0)) < \\<Sqinter> (b (Suc k) (Suc k, k))", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  0 < k \\<Longrightarrow> k - 1 \\<le> \\<Sqinter> (b k (k, k - 1))\n  0 < Suc k\n  \\<Sqinter> (b k (k, k - Suc 0)) < \\<Sqinter> (b (Suc k) (Suc k, k))\n\ngoal (1 subgoal):\n 1. Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))", "by simp"], ["proof (state)\nthis:\n  Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))", "qed auto"], ["proof (state)\nthis:\n  Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (Suc k, Suc k - 1))\n\ngoal (1 subgoal):\n 1. 0 < 0 \\<Longrightarrow> 0 - 1 \\<le> \\<Sqinter> (b 0 (0, 0 - 1))", "qed auto"], ["proof (state)\nthis:\n  0 < ?k \\<Longrightarrow> ?k - 1 \\<le> \\<Sqinter> (b ?k (?k, ?k - 1))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b_ge: \"\\<Sqinter> (b k (j,i)) \\<ge> k-1\" if k: \"k>0\" \"k \\<ge> j\" and \"j > i\" for k j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. k - 1 \\<le> \\<Sqinter> (b k (j, i))", "using k"], ["proof (prove)\nusing this:\n  0 < k\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. k - 1 \\<le> \\<Sqinter> (b k (j, i))", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < 0; j \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 0 - 1 \\<le> \\<Sqinter> (b 0 (j, i))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>0 < k; j \\<le> k\\<rbrakk>\n                \\<Longrightarrow> k - 1 \\<le> \\<Sqinter> (b k (j, i));\n        0 < Suc k; j \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < k; j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> k - 1 \\<le> \\<Sqinter> (b k (j, i))\n  0 < Suc k\n  j \\<le> Suc k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < 0; j \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 0 - 1 \\<le> \\<Sqinter> (b 0 (j, i))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>0 < k; j \\<le> k\\<rbrakk>\n                \\<Longrightarrow> k - 1 \\<le> \\<Sqinter> (b k (j, i));\n        0 < Suc k; j \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "proof (cases \"j \\<le> k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))\n 2. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "case True"], ["proof (state)\nthis:\n  j \\<le> k\n\ngoal (2 subgoals):\n 1. j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))\n 2. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "have \"\\<Sqinter> (b k (j,i)) < \\<Sqinter> (b (Suc k) (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (b k (j, i)) < \\<Sqinter> (b (Suc k) (j, i))", "using \\<open>j > i\\<close> Suc True"], ["proof (prove)\nusing this:\n  i < j\n  \\<lbrakk>0 < k; j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> k - 1 \\<le> \\<Sqinter> (b k (j, i))\n  0 < Suc k\n  j \\<le> Suc k\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (b k (j, i)) < \\<Sqinter> (b (Suc k) (j, i))", "by (force intro: Inf_b_less)"], ["proof (state)\nthis:\n  \\<Sqinter> (b k (j, i)) < \\<Sqinter> (b (Suc k) (j, i))\n\ngoal (2 subgoals):\n 1. j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))\n 2. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "then"], ["proof (chain)\npicking this:\n  \\<Sqinter> (b k (j, i)) < \\<Sqinter> (b (Suc k) (j, i))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sqinter> (b k (j, i)) < \\<Sqinter> (b (Suc k) (j, i))\n\ngoal (1 subgoal):\n 1. Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "using Suc.IH True"], ["proof (prove)\nusing this:\n  \\<Sqinter> (b k (j, i)) < \\<Sqinter> (b (Suc k) (j, i))\n  \\<lbrakk>0 < k; j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> k - 1 \\<le> \\<Sqinter> (b k (j, i))\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "by linarith"], ["proof (state)\nthis:\n  Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "case False"], ["proof (state)\nthis:\n  \\<not> j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "then"], ["proof (chain)\npicking this:\n  \\<not> j \\<le> k", "have \"j = Suc k\""], ["proof (prove)\nusing this:\n  \\<not> j \\<le> k\n\ngoal (1 subgoal):\n 1. j = Suc k", "using Suc.prems(2)"], ["proof (prove)\nusing this:\n  \\<not> j \\<le> k\n  j \\<le> Suc k\n\ngoal (1 subgoal):\n 1. j = Suc k", "by linarith"], ["proof (state)\nthis:\n  j = Suc k\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "with \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i < j\n  j = Suc k", "have \"i < Suc k\""], ["proof (prove)\nusing this:\n  i < j\n  j = Suc k\n\ngoal (1 subgoal):\n 1. i < Suc k", "by fastforce"], ["proof (state)\nthis:\n  i < Suc k\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "moreover"], ["proof (state)\nthis:\n  i < Suc k\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "have \"\\<not> \\<Sqinter> (b (Suc k) (j,i)) < \\<Sqinter> (b (Suc k) (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<Sqinter> (b (Suc k) (j, i)) < \\<Sqinter> (b (Suc k) (j, i))", "by fastforce"], ["proof (state)\nthis:\n  \\<not> \\<Sqinter> (b (Suc k) (j, i)) < \\<Sqinter> (b (Suc k) (j, i))\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "ultimately"], ["proof (chain)\npicking this:\n  i < Suc k\n  \\<not> \\<Sqinter> (b (Suc k) (j, i)) < \\<Sqinter> (b (Suc k) (j, i))", "have \"\\<not> Suc (\\<Sqinter> (b (Suc k) (j,i))) < Suc k\""], ["proof (prove)\nusing this:\n  i < Suc k\n  \\<not> \\<Sqinter> (b (Suc k) (j, i)) < \\<Sqinter> (b (Suc k) (j, i))\n\ngoal (1 subgoal):\n 1. \\<not> Suc (\\<Sqinter> (b (Suc k) (j, i))) < Suc k", "by (metis Inf_b_less \\<open>j = Suc k\\<close> b_ge_k diff_Suc_1 leD le_refl lessI zero_less_Suc)"], ["proof (state)\nthis:\n  \\<not> Suc (\\<Sqinter> (b (Suc k) (j, i))) < Suc k\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> k \\<Longrightarrow>\n    Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "then"], ["proof (chain)\npicking this:\n  \\<not> Suc (\\<Sqinter> (b (Suc k) (j, i))) < Suc k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Suc (\\<Sqinter> (b (Suc k) (j, i))) < Suc k\n\ngoal (1 subgoal):\n 1. Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))", "by simp"], ["proof (state)\nthis:\n  Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc k - 1 \\<le> \\<Sqinter> (b (Suc k) (j, i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < 0; j \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 0 - 1 \\<le> \\<Sqinter> (b 0 (j, i))", "qed auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?k; ?j \\<le> ?k; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> ?k - 1 \\<le> \\<Sqinter> (b ?k (?j, ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have hd_b: \"hd (list_of (b k (j,i))) = \\<Sqinter> (b k (j,i))\"\n    if \"i < j\" \"j \\<le> k\" for k j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (list_of (b k (j, i))) = \\<Sqinter> (b k (j, i))", "using that"], ["proof (prove)\nusing this:\n  i < j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. hd (list_of (b k (j, i))) = \\<Sqinter> (b k (j, i))", "by (simp add: hd_list_of cInf_eq_Min)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> hd (list_of (b ?k (?j, ?i))) =\n                    \\<Sqinter> (b ?k (?j, ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b_disjoint_less: \"b (enum K i) (j0, i) \\<inter> b (enum K i') (j0, i') = {}\"\n    if K: \"K \\<subseteq> {j0<..}\" \"finite K\" \"card K \\<ge> j0\" \"i' < j\" \"i < i'\" \"j \\<le> j0\" for i i' j j0 K"], ["proof (prove)\ngoal (1 subgoal):\n 1. b (enum K i) (j0, i) \\<inter> b (enum K i') (j0, i') = {}", "proof (intro bb less_sets_imp_disjnt [unfolded disjnt_def])"], ["proof (state)\ngoal (3 subgoals):\n 1. i < j0\n 2. j0 \\<le> enum K i\n 3. enum K i < enum K i'", "show \"i < j0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j0", "using that"], ["proof (prove)\nusing this:\n  K \\<subseteq> {j0<..}\n  finite K\n  j0 \\<le> card K\n  i' < j\n  i < i'\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. i < j0", "by linarith"], ["proof (state)\nthis:\n  i < j0\n\ngoal (2 subgoals):\n 1. j0 \\<le> enum K i\n 2. enum K i < enum K i'", "then"], ["proof (chain)\npicking this:\n  i < j0", "show \"j0 \\<le> enum K i\""], ["proof (prove)\nusing this:\n  i < j0\n\ngoal (1 subgoal):\n 1. j0 \\<le> enum K i", "by (meson K finite_enumerate_in_set greaterThan_iff less_imp_le_nat less_le_trans subsetD)"], ["proof (state)\nthis:\n  j0 \\<le> enum K i\n\ngoal (1 subgoal):\n 1. enum K i < enum K i'", "show \"enum K i < enum K i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum K i < enum K i'", "using K \\<open>j \\<le> j0\\<close> that"], ["proof (prove)\nusing this:\n  K \\<subseteq> {j0<..}\n  finite K\n  j0 \\<le> card K\n  i' < j\n  i < i'\n  j \\<le> j0\n  j \\<le> j0\n  K \\<subseteq> {j0<..}\n  finite K\n  j0 \\<le> card K\n  i' < j\n  i < i'\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. enum K i < enum K i'", "by auto"], ["proof (state)\nthis:\n  enum K i < enum K i'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?i' < ?j; ?i < ?i'; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> b (enum ?K ?i) (?j0.0, ?i) \\<inter>\n                    b (enum ?K ?i') (?j0.0, ?i') =\n                    {}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have b_disjoint: \"b (enum K i) (j0, i) \\<inter> b (enum K i') (j0, i') = {}\"\n    if K: \"K \\<subseteq> {j0<..}\" \"finite K\" \"card K \\<ge> j0\" \"i < j\" \"i' < j\" \"i \\<noteq> i'\" \"j \\<le> j0\" for i i' j j0 K"], ["proof (prove)\ngoal (1 subgoal):\n 1. b (enum K i) (j0, i) \\<inter> b (enum K i') (j0, i') = {}", "using that b_disjoint_less inf_commute neq_iff"], ["proof (prove)\nusing this:\n  K \\<subseteq> {j0<..}\n  finite K\n  j0 \\<le> card K\n  i < j\n  i' < j\n  i \\<noteq> i'\n  j \\<le> j0\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?i' < ?j; ?i < ?i'; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> b (enum ?K ?i) (?j0.0, ?i) \\<inter>\n                    b (enum ?K ?i') (?j0.0, ?i') =\n                    {}\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  (?x \\<noteq> ?y) = (?x < ?y \\<or> ?y < ?x)\n\ngoal (1 subgoal):\n 1. b (enum K i) (j0, i) \\<inter> b (enum K i') (j0, i') = {}", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?i < ?j; ?i' < ?j; ?i \\<noteq> ?i'; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> b (enum ?K ?i) (?j0.0, ?i) \\<inter>\n                    b (enum ?K ?i') (?j0.0, ?i') =\n                    {}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have ot\\<omega>: \"ordertype ((\\<lambda>k. list_of (b k (j,i))) ` {Max (insert j K)<..}) ?LL = \\<omega>\"\n             (is \"?lhs = _\")\n    if K: \"K \\<in> \\<K> j i\" \"j > i\" for j i K"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "have Sucj: \"Suc (Max (insert j K)) \\<ge> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> Suc (Max (insert j K))", "using \\<K>_finite that(1) le_Suc_eq"], ["proof (prove)\nusing this:\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> finite ?K\n  K \\<in> \\<K> j i\n  (?m \\<le> Suc ?n) = (?m \\<le> ?n \\<or> ?m = Suc ?n)\n\ngoal (1 subgoal):\n 1. j \\<le> Suc (Max (insert j K))", "by auto"], ["proof (state)\nthis:\n  j \\<le> Suc (Max (insert j K))\n\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "let ?N = \"{Inf(b k (j,i))| k. Max (insert j K) < k}\""], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "have infN: \"infinite ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}", "proof (clarsimp simp add: infinite_nat_iff_unbounded_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>n\\<ge>m.\n          \\<exists>k.\n             n = \\<Sqinter> (b k (j, i)) \\<and> Max (insert j K) < k", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>n\\<ge>m.\n          \\<exists>k.\n             n = \\<Sqinter> (b k (j, i)) \\<and> Max (insert j K) < k", "show \"\\<exists>n\\<ge>m. \\<exists>k. n = \\<Sqinter> (b k (j,i)) \\<and> Max (insert j K) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m.\n       \\<exists>k. n = \\<Sqinter> (b k (j, i)) \\<and> Max (insert j K) < k", "using b_ge [of _ j i] \\<open>j > i\\<close> Sucj"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?k; j \\<le> ?k; i < j\\<rbrakk>\n  \\<Longrightarrow> ?k - 1 \\<le> \\<Sqinter> (b ?k (j, i))\n  i < j\n  j \\<le> Suc (Max (insert j K))\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m.\n       \\<exists>k. n = \\<Sqinter> (b k (j, i)) \\<and> Max (insert j K) < k", "by (metis (no_types, lifting) diff_Suc_1 le_SucI le_trans less_Suc_eq_le nat_le_linear zero_less_Suc)"], ["proof (state)\nthis:\n  \\<exists>n\\<ge>m.\n     \\<exists>k. n = \\<Sqinter> (b k (j, i)) \\<and> Max (insert j K) < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infinite {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "have [simp]: \"Max (insert j K) < k \\<longleftrightarrow> j < k \\<and> (\\<forall>a\\<in>K. a < k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Max (insert j K) < k) = (j < k \\<and> (\\<forall>a\\<in>K. a < k))", "using that"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j i\n  i < j\n\ngoal (1 subgoal):\n 1. (Max (insert j K) < k) = (j < k \\<and> (\\<forall>a\\<in>K. a < k))", "by (auto simp: \\<K>_finite)"], ["proof (state)\nthis:\n  (Max (insert j K) < ?k) = (j < ?k \\<and> (\\<forall>a\\<in>K. a < ?k))\n\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "have \"?lhs = ordertype ?N less_than\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    ordertype {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k} less_than", "proof (intro ordertype_eqI strip)"], ["proof (state)\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. bij_betw ?f ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((?f x, ?f y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "have \"list_of (b k (j,i)) = list_of (b k' (j,i))\"\n        if \"j \\<le> k\" \"j \\<le> k'\"  \"hd (list_of (b k (j,i))) = hd (list_of (b k' (j,i)))\"\n        for k k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (b k (j, i)) = list_of (b k' (j, i))", "by (metis Inf_b_less \\<open>i < j\\<close> hd_b nat_less_le not_le that)"], ["proof (state)\nthis:\n  \\<lbrakk>j \\<le> ?k; j \\<le> ?k';\n   hd (list_of (b ?k (j, i))) = hd (list_of (b ?k' (j, i)))\\<rbrakk>\n  \\<Longrightarrow> list_of (b ?k (j, i)) = list_of (b ?k' (j, i))\n\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. bij_betw ?f ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((?f x, ?f y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>j \\<le> ?k; j \\<le> ?k';\n   hd (list_of (b ?k (j, i))) = hd (list_of (b ?k' (j, i)))\\<rbrakk>\n  \\<Longrightarrow> list_of (b ?k (j, i)) = list_of (b ?k' (j, i))\n\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. bij_betw ?f ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((?f x, ?f y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "have \"\\<exists>k' j' i'. hd (list_of (b k (j,i))) = \\<Sqinter> (b k' (j', i')) \\<and> i' < j' \\<and> j' \\<le> k'\"\n        if \"j \\<le> k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k' j' i'.\n       hd (list_of (b k (j, i))) = \\<Sqinter> (b k' (j', i')) \\<and>\n       i' < j' \\<and> j' \\<le> k'", "using that \\<open>i < j\\<close> hd_b less_imp_le_nat"], ["proof (prove)\nusing this:\n  j \\<le> k\n  i < j\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> hd (list_of (b ?k (?j, ?i))) =\n                    \\<Sqinter> (b ?k (?j, ?i))\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<exists>k' j' i'.\n       hd (list_of (b k (j, i))) = \\<Sqinter> (b k' (j', i')) \\<and>\n       i' < j' \\<and> j' \\<le> k'", "by blast"], ["proof (state)\nthis:\n  j \\<le> ?k \\<Longrightarrow>\n  \\<exists>k' j' i'.\n     hd (list_of (b ?k (j, i))) = \\<Sqinter> (b k' (j', i')) \\<and>\n     i' < j' \\<and> j' \\<le> k'\n\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. bij_betw ?f ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((?f x, ?f y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "moreover"], ["proof (state)\nthis:\n  j \\<le> ?k \\<Longrightarrow>\n  \\<exists>k' j' i'.\n     hd (list_of (b ?k (j, i))) = \\<Sqinter> (b k' (j', i')) \\<and>\n     i' < j' \\<and> j' \\<le> k'\n\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. bij_betw ?f ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((?f x, ?f y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "have \"\\<exists>k'. hd (list_of (b k (j,i))) = \\<Sqinter> (b k' (j,i)) \\<and> j < k' \\<and> (\\<forall>a\\<in>K. a < k')\"\n         if \"j < k\" \"\\<forall>a\\<in>K. a < k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k'.\n       hd (list_of (b k (j, i))) = \\<Sqinter> (b k' (j, i)) \\<and>\n       j < k' \\<and> (\\<forall>a\\<in>K. a < k')", "using that K hd_b less_imp_le_nat"], ["proof (prove)\nusing this:\n  j < k\n  \\<forall>a\\<in>K. a < k\n  K \\<in> \\<K> j i\n  i < j\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> hd (list_of (b ?k (?j, ?i))) =\n                    \\<Sqinter> (b ?k (?j, ?i))\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<exists>k'.\n       hd (list_of (b k (j, i))) = \\<Sqinter> (b k' (j, i)) \\<and>\n       j < k' \\<and> (\\<forall>a\\<in>K. a < k')", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>j < ?k; \\<forall>a\\<in>K. a < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k'.\n                       hd (list_of (b ?k (j, i))) =\n                       \\<Sqinter> (b k' (j, i)) \\<and>\n                       j < k' \\<and> (\\<forall>a\\<in>K. a < k')\n\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. bij_betw ?f ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((?f x, ?f y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>j < ?k; \\<forall>a\\<in>K. a < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k'.\n                       hd (list_of (b ?k (j, i))) =\n                       \\<Sqinter> (b k' (j, i)) \\<and>\n                       j < k' \\<and> (\\<forall>a\\<in>K. a < k')\n\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. bij_betw ?f ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((?f x, ?f y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "have \"\\<Sqinter> (b k (j,i)) \\<in> hd ` (\\<lambda>k. list_of (b k (j,i))) ` {Max (insert j K)<..}\"\n        if \"j < k\" \"\\<forall>a\\<in>K. a < k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (b k (j, i))\n    \\<in> hd ` (\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..}", "using that K"], ["proof (prove)\nusing this:\n  j < k\n  \\<forall>a\\<in>K. a < k\n  K \\<in> \\<K> j i\n  i < j\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (b k (j, i))\n    \\<in> hd ` (\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..}", "by (auto simp: hd_b image_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>j < ?k; \\<forall>a\\<in>K. a < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> (b ?k (j, i))\n                    \\<in> hd `\n                          (\\<lambda>k. list_of (b k (j, i))) `\n                          {Max (insert j K)<..}\n\ngoal (6 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. bij_betw ?f ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((?f x, ?f y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>j \\<le> ?k; j \\<le> ?k';\n   hd (list_of (b ?k (j, i))) = hd (list_of (b ?k' (j, i)))\\<rbrakk>\n  \\<Longrightarrow> list_of (b ?k (j, i)) = list_of (b ?k' (j, i))\n  j \\<le> ?k \\<Longrightarrow>\n  \\<exists>k' j' i'.\n     hd (list_of (b ?k (j, i))) = \\<Sqinter> (b k' (j', i')) \\<and>\n     i' < j' \\<and> j' \\<le> k'\n  \\<lbrakk>j < ?k; \\<forall>a\\<in>K. a < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k'.\n                       hd (list_of (b ?k (j, i))) =\n                       \\<Sqinter> (b k' (j, i)) \\<and>\n                       j < k' \\<and> (\\<forall>a\\<in>K. a < k')\n  \\<lbrakk>j < ?k; \\<forall>a\\<in>K. a < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> (b ?k (j, i))\n                    \\<in> hd `\n                          (\\<lambda>k. list_of (b k (j, i))) `\n                          {Max (insert j K)<..}", "show \"bij_betw hd ((\\<lambda>k. list_of (b k (j,i))) ` {Max (insert j K)<..}) {\\<Sqinter> (b k (j,i)) |k. Max (insert j K) < k}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<le> ?k; j \\<le> ?k';\n   hd (list_of (b ?k (j, i))) = hd (list_of (b ?k' (j, i)))\\<rbrakk>\n  \\<Longrightarrow> list_of (b ?k (j, i)) = list_of (b ?k' (j, i))\n  j \\<le> ?k \\<Longrightarrow>\n  \\<exists>k' j' i'.\n     hd (list_of (b ?k (j, i))) = \\<Sqinter> (b k' (j', i')) \\<and>\n     i' < j' \\<and> j' \\<le> k'\n  \\<lbrakk>j < ?k; \\<forall>a\\<in>K. a < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k'.\n                       hd (list_of (b ?k (j, i))) =\n                       \\<Sqinter> (b k' (j, i)) \\<and>\n                       j < k' \\<and> (\\<forall>a\\<in>K. a < k')\n  \\<lbrakk>j < ?k; \\<forall>a\\<in>K. a < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> (b ?k (j, i))\n                    \\<in> hd `\n                          (\\<lambda>k. list_of (b k (j, i))) `\n                          {Max (insert j K)<..}\n\ngoal (1 subgoal):\n 1. bij_betw hd ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}", "by (auto simp: bij_betw_def inj_on_def)"], ["proof (state)\nthis:\n  bij_betw hd ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n   {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((hd x, hd y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((hd x, hd y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "fix ms ns"], ["proof (state)\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((hd x, hd y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "assume \"ms \\<in> (\\<lambda>k. list_of (b k (j,i))) ` {Max (insert j K)<..}\"\n        and \"ns \\<in> (\\<lambda>k. list_of (b k (j,i))) ` {Max (insert j K)<..}\""], ["proof (state)\nthis:\n  ms \\<in> (\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..}\n  ns \\<in> (\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..}\n\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((hd x, hd y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "with that"], ["proof (chain)\npicking this:\n  K \\<in> \\<K> j i\n  i < j\n  ms \\<in> (\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..}\n  ns \\<in> (\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..}", "obtain k k' where\n        ms: \"ms = list_of (b k (j,i))\" and ns: \"ns = list_of (b k' (j,i))\"\n        and \"j < k\" \"j < k'\" and lt_k: \"\\<forall>a\\<in>K. a < k\" and lt_k': \"\\<forall>a\\<in>K. a < k'\""], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j i\n  i < j\n  ms \\<in> (\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..}\n  ns \\<in> (\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..}\n\ngoal (1 subgoal):\n 1. (\\<And>k k'.\n        \\<lbrakk>ms = list_of (b k (j, i)); ns = list_of (b k' (j, i));\n         j < k; j < k'; \\<forall>a\\<in>K. a < k;\n         \\<forall>a\\<in>K. a < k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: \\<K>_finite)"], ["proof (state)\nthis:\n  ms = list_of (b k (j, i))\n  ns = list_of (b k' (j, i))\n  j < k\n  j < k'\n  \\<forall>a\\<in>K. a < k\n  \\<forall>a\\<in>K. a < k'\n\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((hd x, hd y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "then"], ["proof (chain)\npicking this:\n  ms = list_of (b k (j, i))\n  ns = list_of (b k' (j, i))\n  j < k\n  j < k'\n  \\<forall>a\\<in>K. a < k\n  \\<forall>a\\<in>K. a < k'", "have len_eq [simp]: \"length ns = length ms\""], ["proof (prove)\nusing this:\n  ms = list_of (b k (j, i))\n  ns = list_of (b k' (j, i))\n  j < k\n  j < k'\n  \\<forall>a\\<in>K. a < k\n  \\<forall>a\\<in>K. a < k'\n\ngoal (1 subgoal):\n 1. length ns = length ms", "by (simp add: card_b)"], ["proof (state)\nthis:\n  length ns = length ms\n\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((hd x, hd y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "have nz: \"length ns \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ns \\<noteq> 0", "using b_ne \\<open>i < j\\<close> \\<open>j < k'\\<close> ns"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<noteq> {}\n  i < j\n  j < k'\n  ns = list_of (b k' (j, i))\n\ngoal (1 subgoal):\n 1. length ns \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length ns \\<noteq> 0\n\ngoal (5 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                        {Max (insert j K)<..};\n        y \\<in> (\\<lambda>k. list_of (b k (j, i))) `\n                {Max (insert j K)<..}\\<rbrakk>\n       \\<Longrightarrow> ((hd x, hd y) \\<in> less_than) =\n                         ((x, y) \\<in> lenlex less_than)", "show \"(hd ms, hd ns) \\<in> less_than \\<longleftrightarrow> (ms, ns) \\<in> ?LL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((hd ms, hd ns) \\<in> less_than) = ((ms, ns) \\<in> lenlex less_than)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (hd ms, hd ns) \\<in> less_than \\<Longrightarrow>\n    (ms, ns) \\<in> lenlex less_than\n 2. (ms, ns) \\<in> lenlex less_than \\<Longrightarrow>\n    (hd ms, hd ns) \\<in> less_than", "assume \"(hd ms, hd ns) \\<in> less_than\""], ["proof (state)\nthis:\n  (hd ms, hd ns) \\<in> less_than\n\ngoal (2 subgoals):\n 1. (hd ms, hd ns) \\<in> less_than \\<Longrightarrow>\n    (ms, ns) \\<in> lenlex less_than\n 2. (ms, ns) \\<in> lenlex less_than \\<Longrightarrow>\n    (hd ms, hd ns) \\<in> less_than", "then"], ["proof (chain)\npicking this:\n  (hd ms, hd ns) \\<in> less_than", "show \"(ms, ns) \\<in> ?LL\""], ["proof (prove)\nusing this:\n  (hd ms, hd ns) \\<in> less_than\n\ngoal (1 subgoal):\n 1. (ms, ns) \\<in> lenlex less_than", "using that nz"], ["proof (prove)\nusing this:\n  (hd ms, hd ns) \\<in> less_than\n  K \\<in> \\<K> j i\n  i < j\n  length ns \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (ms, ns) \\<in> lenlex less_than", "by (fastforce simp add: lenlex_def \\<K>_finite card_b intro: hd_lex)"], ["proof (state)\nthis:\n  (ms, ns) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (ms, ns) \\<in> lenlex less_than \\<Longrightarrow>\n    (hd ms, hd ns) \\<in> less_than", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (ms, ns) \\<in> lenlex less_than \\<Longrightarrow>\n    (hd ms, hd ns) \\<in> less_than", "assume \\<section>: \"(ms, ns) \\<in> ?LL\""], ["proof (state)\nthis:\n  (ms, ns) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (ms, ns) \\<in> lenlex less_than \\<Longrightarrow>\n    (hd ms, hd ns) \\<in> less_than", "then"], ["proof (chain)\npicking this:\n  (ms, ns) \\<in> lenlex less_than", "have \"(list_of (b k' (j,i)), list_of (b k (j,i))) \\<notin> ?LL\""], ["proof (prove)\nusing this:\n  (ms, ns) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (list_of (b k' (j, i)), list_of (b k (j, i))) \\<notin> lenlex less_than", "using less_asym ms ns omega_sum_1_less"], ["proof (prove)\nusing this:\n  (ms, ns) \\<in> lenlex less_than\n  \\<lbrakk>?x < ?y; \\<not> ?P \\<Longrightarrow> ?y < ?x\\<rbrakk>\n  \\<Longrightarrow> ?P\n  ms = list_of (b k (j, i))\n  ns = list_of (b k' (j, i))\n  (?ms, ?ns) \\<in> lenlex less_than \\<Longrightarrow>\n  omega_sum (1 # ?ms) < omega_sum (1 # ?ns)\n\ngoal (1 subgoal):\n 1. (list_of (b k' (j, i)), list_of (b k (j, i))) \\<notin> lenlex less_than", "by blast"], ["proof (state)\nthis:\n  (list_of (b k' (j, i)), list_of (b k (j, i))) \\<notin> lenlex less_than\n\ngoal (1 subgoal):\n 1. (ms, ns) \\<in> lenlex less_than \\<Longrightarrow>\n    (hd ms, hd ns) \\<in> less_than", "then"], ["proof (chain)\npicking this:\n  (list_of (b k' (j, i)), list_of (b k (j, i))) \\<notin> lenlex less_than", "show \"(hd ms, hd ns) \\<in> less_than\""], ["proof (prove)\nusing this:\n  (list_of (b k' (j, i)), list_of (b k (j, i))) \\<notin> lenlex less_than\n\ngoal (1 subgoal):\n 1. (hd ms, hd ns) \\<in> less_than", "using \\<open>j < k\\<close> \\<open>j < k'\\<close> Inf_b_less [of i j i j] ms ns"], ["proof (prove)\nusing this:\n  (list_of (b k' (j, i)), list_of (b k (j, i))) \\<notin> lenlex less_than\n  j < k\n  j < k'\n  \\<lbrakk>i < j; i < j; j \\<le> ?k'; j \\<le> ?k; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> (b ?k' (j, i)) < \\<Sqinter> (b ?k (j, i))\n  ms = list_of (b k (j, i))\n  ns = list_of (b k' (j, i))\n\ngoal (1 subgoal):\n 1. (hd ms, hd ns) \\<in> less_than", "by (metis Cons_lenlex_iff \\<section> len_eq b_ne card_b_finite diff_Suc_1 hd_Cons_tl hd_b length_Cons less_or_eq_imp_le less_than_iff linorder_neqE_nat sorted_list_of_set_eq_Nil_iff that(2))"], ["proof (state)\nthis:\n  (hd ms, hd ns) \\<in> less_than\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((hd ms, hd ns) \\<in> less_than) = ((ms, ns) \\<in> lenlex less_than)\n\ngoal (4 subgoals):\n 1. wf (lenlex less_than)\n 2. total_on ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than)\n 3. small ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n 4. wf less_than", "qed auto"], ["proof (state)\nthis:\n  ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n   (lenlex less_than) =\n  ordertype {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k} less_than\n\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "also"], ["proof (state)\nthis:\n  ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n   (lenlex less_than) =\n  ordertype {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k} less_than\n\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "have \"\\<dots> = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k} less_than =\n    \\<omega>", "using infN ordertype_nat_\\<omega>"], ["proof (prove)\nusing this:\n  infinite {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k}\n  infinite ?N \\<Longrightarrow> ordertype ?N less_than = \\<omega>\n\ngoal (1 subgoal):\n 1. ordertype {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k} less_than =\n    \\<omega>", "by blast"], ["proof (state)\nthis:\n  ordertype {\\<Sqinter> (b k (j, i)) |k. Max (insert j K) < k} less_than =\n  \\<omega>\n\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "finally"], ["proof (chain)\npicking this:\n  ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n   (lenlex less_than) =\n  \\<omega>", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n   (lenlex less_than) =\n  \\<omega>\n\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n     (lenlex less_than) =\n    \\<omega>", "."], ["proof (state)\nthis:\n  ordertype ((\\<lambda>k. list_of (b k (j, i))) ` {Max (insert j K)<..})\n   (lenlex less_than) =\n  \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<in> \\<K> ?j ?i; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> ordertype\n                     ((\\<lambda>k. list_of (b k (?j, ?i))) `\n                      {Max (insert ?j ?K)<..})\n                     (lenlex less_than) =\n                    \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have ot\\<omega>j: \"ordertype (BB j0 j ` \\<K> j0 j) ?LL = \\<omega>\\<up>j\" if \"j \\<le> j0\" for j j0"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat j", "using that"], ["proof (prove)\nusing this:\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat j", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> j0 \\<Longrightarrow>\n    ordertype (BB j0 0 ` \\<K> j0 0) (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat 0\n 2. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> j0\n\ngoal (2 subgoals):\n 1. 0 \\<le> j0 \\<Longrightarrow>\n    ordertype (BB j0 0 ` \\<K> j0 0) (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat 0\n 2. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> j0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> j0\n\ngoal (1 subgoal):\n 1. ordertype (BB j0 0 ` \\<K> j0 0) (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat 0", "by (auto simp: XX_def)"], ["proof (state)\nthis:\n  ordertype (BB j0 0 ` \\<K> j0 0) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "case (Suc j)"], ["proof (state)\nthis:\n  j \\<le> j0 \\<Longrightarrow>\n  ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat j\n  Suc j \\<le> j0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "then"], ["proof (chain)\npicking this:\n  j \\<le> j0 \\<Longrightarrow>\n  ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat j\n  Suc j \\<le> j0", "have ih: \"ordertype (BB j0 j ` \\<K> j0 j) ?LL = \\<omega> \\<up> j\""], ["proof (prove)\nusing this:\n  j \\<le> j0 \\<Longrightarrow>\n  ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat j\n  Suc j \\<le> j0\n\ngoal (1 subgoal):\n 1. ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat j", "by simp"], ["proof (state)\nthis:\n  ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "have \"j \\<le> j0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> j0", "by (simp add: Suc.prems Suc_leD)"], ["proof (state)\nthis:\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "have inj_BB: \"inj_on (BB j0 j) ([{j0<..}]\\<^bsup>j\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (BB j0 j) ([{j0<..}]\\<^bsup>j\\<^esup>)", "proof (clarsimp simp: inj_on_def BB_def nsets_def subset_iff sorted_list_of_set_Un less_sets_UN2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume X [rule_format]: \"\\<forall>t. t \\<in> X \\<longrightarrow> j0 < t\"\n        and Y [rule_format]: \"\\<forall>t. t \\<in> Y \\<longrightarrow> j0 < t\"\n        and \"finite X\"\n        and jeq: \"j = card X\"\n        and \"finite Y\"\n        and \"card Y = card X\"\n        and eq: \"list_of (a j0 \\<union> (\\<Union>i<card X. b (enum X i) (j0,i)))\n               = list_of (a j0 \\<union> (\\<Union>i<card X. b (enum Y i) (j0,i)))\""], ["proof (state)\nthis:\n  ?t \\<in> X \\<Longrightarrow> j0 < ?t\n  ?t \\<in> Y \\<Longrightarrow> j0 < ?t\n  finite X\n  j = card X\n  finite Y\n  card Y = card X\n  list_of (a j0 \\<union> (\\<Union>i<card X. b (enum X i) (j0, i))) =\n  list_of (a j0 \\<union> (\\<Union>i<card X. b (enum Y i) (j0, i)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "have enumX: \"\\<And>n. \\<lbrakk>n < card X\\<rbrakk> \\<Longrightarrow> j0 \\<le> enum X n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. n < card X \\<Longrightarrow> j0 \\<le> enum X n", "using X \\<open>finite X\\<close> finite_enumerate_in_set less_imp_le_nat"], ["proof (prove)\nusing this:\n  ?t \\<in> X \\<Longrightarrow> j0 < ?t\n  finite X\n  \\<lbrakk>finite ?S; ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> enum ?S ?n \\<in> ?S\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<And>n. n < card X \\<Longrightarrow> j0 \\<le> enum X n", "by blast"], ["proof (state)\nthis:\n  ?n < card X \\<Longrightarrow> j0 \\<le> enum X ?n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "have enumY: \"\\<And>n. \\<lbrakk>n < card X\\<rbrakk> \\<Longrightarrow> j0 \\<le> enum Y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. n < card X \\<Longrightarrow> j0 \\<le> enum Y n", "by (simp add: Y \\<open>card Y = card X\\<close> \\<open>finite Y\\<close> finite_enumerate_in_set less_imp_le_nat)"], ["proof (state)\nthis:\n  ?n < card X \\<Longrightarrow> j0 \\<le> enum Y ?n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "have smX: \"strict_mono_sets {..<card X} (\\<lambda>i. b (enum X i) (j0, i))\"\n        and smY: \"strict_mono_sets {..<card X} (\\<lambda>i. b (enum Y i) (j0, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono_sets {..<card X} (\\<lambda>i. b (enum X i) (j0, i)) &&&\n    strict_mono_sets {..<card X} (\\<lambda>i. b (enum Y i) (j0, i))", "using Suc.prems \\<open>card Y = card X\\<close> \\<open>finite X\\<close> \\<open>finite Y\\<close> bb enumX enumY jeq"], ["proof (prove)\nusing this:\n  Suc j \\<le> j0\n  card Y = card X\n  finite X\n  finite Y\n  \\<lbrakk>?i' < ?j'; ?j' \\<le> ?k'; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k' (?j', ?i') \\<lless> b ?k (?j, ?i)\n  ?n < card X \\<Longrightarrow> j0 \\<le> enum X ?n\n  ?n < card X \\<Longrightarrow> j0 \\<le> enum Y ?n\n  j = card X\n\ngoal (1 subgoal):\n 1. strict_mono_sets {..<card X} (\\<lambda>i. b (enum X i) (j0, i)) &&&\n    strict_mono_sets {..<card X} (\\<lambda>i. b (enum Y i) (j0, i))", "by (auto simp: strict_mono_sets_def)"], ["proof (state)\nthis:\n  strict_mono_sets {..<card X} (\\<lambda>i. b (enum X i) (j0, i))\n  strict_mono_sets {..<card X} (\\<lambda>i. b (enum Y i) (j0, i))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "have len_eq: \"length ms = length ns\"\n        if \"(ms, ns) \\<in> list.set (zip (map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0,i))) (list_of {..<n}))\n                                     (map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0,i))) (list_of {..<n})))\"\n          \"n \\<le> card X\"\n        for ms ns n"], ["proof (prove)\ngoal (1 subgoal):\n 1. length ms = length ns", "using that"], ["proof (prove)\nusing this:\n  (ms, ns)\n  \\<in> list.set\n         (zip (map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i)))\n                (list_of {..<n}))\n           (map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i)))\n             (list_of {..<n})))\n  n \\<le> card X\n\ngoal (1 subgoal):\n 1. length ms = length ns", "by (induction n rule: nat.induct) (auto simp: card_b enumX enumY)"], ["proof (state)\nthis:\n  \\<lbrakk>(?ms, ?ns)\n           \\<in> list.set\n                  (zip (map (list_of \\<circ>\n                             (\\<lambda>i. b (enum X i) (j0, i)))\n                         (list_of {..<?n}))\n                    (map (list_of \\<circ>\n                          (\\<lambda>i. b (enum Y i) (j0, i)))\n                      (list_of {..<?n})));\n   ?n \\<le> card X\\<rbrakk>\n  \\<Longrightarrow> length ?ms = length ?ns\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"concat (map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i))) (list_of {..<card X}))\n          = concat (map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i))) (list_of {..<card X}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i)))\n       (list_of {..<card X})) =\n    concat\n     (map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i)))\n       (list_of {..<card X}))", "using eq"], ["proof (prove)\nusing this:\n  list_of (a j0 \\<union> (\\<Union>i<card X. b (enum X i) (j0, i))) =\n  list_of (a j0 \\<union> (\\<Union>i<card X. b (enum Y i) (j0, i)))\n\ngoal (1 subgoal):\n 1. concat\n     (map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i)))\n       (list_of {..<card X})) =\n    concat\n     (map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i)))\n       (list_of {..<card X}))", "by (simp add: sorted_list_of_set_Un less_sets_UN2 sorted_list_of_set_UN_lessThan ab enumX enumY smX smY)"], ["proof (state)\nthis:\n  concat\n   (map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i)))\n     (list_of {..<card X})) =\n  concat\n   (map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i)))\n     (list_of {..<card X}))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  concat\n   (map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i)))\n     (list_of {..<card X})) =\n  concat\n   (map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i)))\n     (list_of {..<card X}))", "have map_eq: \"map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i))) (list_of {..<card X})\n                       = map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i))) (list_of {..<card X})\""], ["proof (prove)\nusing this:\n  concat\n   (map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i)))\n     (list_of {..<card X})) =\n  concat\n   (map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i)))\n     (list_of {..<card X}))\n\ngoal (1 subgoal):\n 1. map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i)))\n     (list_of {..<card X}) =\n    map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i)))\n     (list_of {..<card X})", "by (rule concat_injective) (auto simp: len_eq split: prod.split)"], ["proof (state)\nthis:\n  map (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i)))\n   (list_of {..<card X}) =\n  map (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i)))\n   (list_of {..<card X})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"enum X i = enum Y i\" if \"i < card X\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum X i = enum Y i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. enum X i = enum Y i", "have \"Inf (b (enum X i) (j0,i)) = Inf (b (enum Y i) (j0,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (b (enum X i) (j0, i)) = \\<Sqinter> (b (enum Y i) (j0, i))", "using iffD1 [OF map_eq_conv, OF map_eq] Suc.prems that"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>list.set (list_of {..<card X}).\n     (list_of \\<circ> (\\<lambda>i. b (enum X i) (j0, i))) x =\n     (list_of \\<circ> (\\<lambda>i. b (enum Y i) (j0, i))) x\n  Suc j \\<le> j0\n  i < card X\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (b (enum X i) (j0, i)) = \\<Sqinter> (b (enum Y i) (j0, i))", "by (metis (mono_tags, lifting) card_b_finite comp_apply finite_lessThan lessThan_iff set_sorted_list_of_set)"], ["proof (state)\nthis:\n  \\<Sqinter> (b (enum X i) (j0, i)) = \\<Sqinter> (b (enum Y i) (j0, i))\n\ngoal (1 subgoal):\n 1. enum X i = enum Y i", "moreover"], ["proof (state)\nthis:\n  \\<Sqinter> (b (enum X i) (j0, i)) = \\<Sqinter> (b (enum Y i) (j0, i))\n\ngoal (1 subgoal):\n 1. enum X i = enum Y i", "have \"Inf (b (enum X i) (j0,i)) \\<in> (b (enum X i) (j0,i))\"\n          \"Inf (b (enum Y i) (j0,i)) \\<in> (b (enum Y i) (j0,i))\" \"i < j0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (b (enum X i) (j0, i)) \\<in> b (enum X i) (j0, i) &&&\n    \\<Sqinter> (b (enum Y i) (j0, i)) \\<in> b (enum Y i) (j0, i) &&& i < j0", "using Inf_nat_def1 Suc.prems b_ne enumX enumY jeq that"], ["proof (prove)\nusing this:\n  ?K \\<noteq> {} \\<Longrightarrow> \\<Sqinter> ?K \\<in> ?K\n  Suc j \\<le> j0\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<noteq> {}\n  ?n < card X \\<Longrightarrow> j0 \\<le> enum X ?n\n  ?n < card X \\<Longrightarrow> j0 \\<le> enum Y ?n\n  j = card X\n  i < card X\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (b (enum X i) (j0, i)) \\<in> b (enum X i) (j0, i) &&&\n    \\<Sqinter> (b (enum Y i) (j0, i)) \\<in> b (enum Y i) (j0, i) &&& i < j0", "by auto"], ["proof (state)\nthis:\n  \\<Sqinter> (b (enum X i) (j0, i)) \\<in> b (enum X i) (j0, i)\n  \\<Sqinter> (b (enum Y i) (j0, i)) \\<in> b (enum Y i) (j0, i)\n  i < j0\n\ngoal (1 subgoal):\n 1. enum X i = enum Y i", "ultimately"], ["proof (chain)\npicking this:\n  \\<Sqinter> (b (enum X i) (j0, i)) = \\<Sqinter> (b (enum Y i) (j0, i))\n  \\<Sqinter> (b (enum X i) (j0, i)) \\<in> b (enum X i) (j0, i)\n  \\<Sqinter> (b (enum Y i) (j0, i)) \\<in> b (enum Y i) (j0, i)\n  i < j0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sqinter> (b (enum X i) (j0, i)) = \\<Sqinter> (b (enum Y i) (j0, i))\n  \\<Sqinter> (b (enum X i) (j0, i)) \\<in> b (enum X i) (j0, i)\n  \\<Sqinter> (b (enum Y i) (j0, i)) \\<in> b (enum Y i) (j0, i)\n  i < j0\n\ngoal (1 subgoal):\n 1. enum X i = enum Y i", "by (metis Inf_b_less enumX enumY leI nat_less_le that)"], ["proof (state)\nthis:\n  enum X i = enum Y i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < card X \\<Longrightarrow> enum X ?i = enum Y ?i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>t. t \\<in> x \\<longrightarrow> j0 < t; finite x;\n        j = card x; \\<forall>t. t \\<in> y \\<longrightarrow> j0 < t;\n        finite y; card y = card x;\n        list_of (a j0 \\<union> (\\<Union>i<card x. b (enum x i) (j0, i))) =\n        list_of\n         (a j0 \\<union> (\\<Union>i<card x. b (enum y i) (j0, i)))\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  ?i < card X \\<Longrightarrow> enum X ?i = enum Y ?i", "show \"X = Y\""], ["proof (prove)\nusing this:\n  ?i < card X \\<Longrightarrow> enum X ?i = enum Y ?i\n\ngoal (1 subgoal):\n 1. X = Y", "by (simp add: \\<open>card Y = card X\\<close> \\<open>finite X\\<close> \\<open>finite Y\\<close> finite_enum_ext)"], ["proof (state)\nthis:\n  X = Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (BB j0 j) ([{j0<..}]\\<^bsup>j\\<^esup>)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "have BB_Suc': \"BB j0 (Suc j) X = usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) X\"\n      if \"X \\<in> USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. BB j0 (Suc j) X =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) X", "using that"], ["proof (prove)\nusing this:\n  X \\<in> USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})\n\ngoal (1 subgoal):\n 1. BB j0 (Suc j) X =\n    usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) X", "by (simp add: USigma_iff \\<K>_finite less_sets_def usplit_def \\<K>_Suc BB_Suc \\<open>j \\<le> j0\\<close>)"], ["proof (state)\nthis:\n  ?X \\<in> USigma (\\<K> j0 j)\n            (\\<lambda>K. {Max (insert j0 K)<..}) \\<Longrightarrow>\n  BB j0 (Suc j) ?X =\n  usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) ?X\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "have \"ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j)) ?LL\n        = ordertype\n           (usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) ` USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..})) ?LL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j)) (lenlex less_than) =\n    ordertype\n     (usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) `\n      USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..}))\n     (lenlex less_than)", "by (simp add: BB_Suc' \\<K>_Suc)"], ["proof (state)\nthis:\n  ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j)) (lenlex less_than) =\n  ordertype\n   (usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) `\n    USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..}))\n   (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "also"], ["proof (state)\nthis:\n  ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j)) (lenlex less_than) =\n  ordertype\n   (usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) `\n    USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..}))\n   (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "have \"\\<dots> = \\<omega> * ordertype (BB j0 j ` \\<K> j0 j) ?LL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype\n     (usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) `\n      USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..}))\n     (lenlex less_than) =\n    \\<omega> * ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than)", "proof (rule ordertype_append_image_IJ)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> BB j0 j L < list_of (b k (j0, j))\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 4. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>\n 5. inj_on (BB j0 j) (\\<K> j0 j)", "fix L k"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> BB j0 j L < list_of (b k (j0, j))\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 4. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>\n 5. inj_on (BB j0 j) (\\<K> j0 j)", "assume \"L \\<in> \\<K> j0 j\" and \"k \\<in> {Max (insert j0 L)<..}\""], ["proof (state)\nthis:\n  L \\<in> \\<K> j0 j\n  k \\<in> {Max (insert j0 L)<..}\n\ngoal (5 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> BB j0 j L < list_of (b k (j0, j))\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 4. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>\n 5. inj_on (BB j0 j) (\\<K> j0 j)", "then"], ["proof (chain)\npicking this:\n  L \\<in> \\<K> j0 j\n  k \\<in> {Max (insert j0 L)<..}", "have \"j0 < k\" and L: \"\\<And>a. a \\<in> L \\<Longrightarrow> a < k\""], ["proof (prove)\nusing this:\n  L \\<in> \\<K> j0 j\n  k \\<in> {Max (insert j0 L)<..}\n\ngoal (1 subgoal):\n 1. j0 < k &&& (\\<And>a. a \\<in> L \\<Longrightarrow> a < k)", "by (simp_all add: \\<K>_finite)"], ["proof (state)\nthis:\n  j0 < k\n  ?a \\<in> L \\<Longrightarrow> ?a < k\n\ngoal (5 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> BB j0 j L < list_of (b k (j0, j))\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 4. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>\n 5. inj_on (BB j0 j) (\\<K> j0 j)", "then"], ["proof (chain)\npicking this:\n  j0 < k\n  ?a \\<in> L \\<Longrightarrow> ?a < k", "show \"BB j0 j L < list_of (b k (j0, j))\""], ["proof (prove)\nusing this:\n  j0 < k\n  ?a \\<in> L \\<Longrightarrow> ?a < k\n\ngoal (1 subgoal):\n 1. BB j0 j L < list_of (b k (j0, j))", "by (simp add: \\<open>L \\<in> \\<K> j0 j\\<close> \\<open>j \\<le> j0\\<close> \\<K>_finite less_list_of)"], ["proof (state)\nthis:\n  BB j0 j L < list_of (b k (j0, j))\n\ngoal (4 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>\n 4. inj_on (BB j0 j) (\\<K> j0 j)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>\n 4. inj_on (BB j0 j) (\\<K> j0 j)", "show \"inj_on (BB j0 j) (\\<K> j0 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (BB j0 j) (\\<K> j0 j)", "by (simp add: \\<K>_def inj_BB)"], ["proof (state)\nthis:\n  inj_on (BB j0 j) (\\<K> j0 j)\n\ngoal (3 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>", "fix L"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>", "assume L: \"L \\<in> \\<K> j0 j\""], ["proof (state)\nthis:\n  L \\<in> \\<K> j0 j\n\ngoal (3 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n 3. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>", "then"], ["proof (chain)\npicking this:\n  L \\<in> \\<K> j0 j", "show \"L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\""], ["proof (prove)\nusing this:\n  L \\<in> \\<K> j0 j\n\ngoal (1 subgoal):\n 1. L \\<lless> {Max (insert j0 L)<..} \\<and> finite L", "by (metis \\<K>_finite atLeast_Suc_greaterThan finite_insert less_sets_Suc_Max less_sets_weaken1 subset_insertI)"], ["proof (state)\nthis:\n  L \\<lless> {Max (insert j0 L)<..} \\<and> finite L\n\ngoal (2 subgoals):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c\n 2. \\<And>L.\n       L \\<in> \\<K> j0 j \\<Longrightarrow>\n       ordertype\n        ((\\<lambda>j. list_of (b j (j0, j))) ` {Max (insert j0 L)<..})\n        (lenlex less_than) =\n       \\<omega>", "show \"ordertype ((\\<lambda>i. list_of (b i (j0, j))) ` {Max (insert j0 L)<..}) ?LL = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>i. list_of (b i (j0, j))) ` {Max (insert j0 L)<..})\n     (lenlex less_than) =\n    \\<omega>", "using L Suc.prems Suc_le_lessD ot\\<omega>"], ["proof (prove)\nusing this:\n  L \\<in> \\<K> j0 j\n  Suc j \\<le> j0\n  Suc ?m \\<le> ?n \\<Longrightarrow> ?m < ?n\n  \\<lbrakk>?K \\<in> \\<K> ?j ?i; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> ordertype\n                     ((\\<lambda>k. list_of (b k (?j, ?i))) `\n                      {Max (insert ?j ?K)<..})\n                     (lenlex less_than) =\n                    \\<omega>\n\ngoal (1 subgoal):\n 1. ordertype ((\\<lambda>i. list_of (b i (j0, j))) ` {Max (insert j0 L)<..})\n     (lenlex less_than) =\n    \\<omega>", "by blast"], ["proof (state)\nthis:\n  ordertype ((\\<lambda>i. list_of (b i (j0, j))) ` {Max (insert j0 L)<..})\n   (lenlex less_than) =\n  \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>L k.\n       \\<lbrakk>L \\<in> \\<K> j0 j; k \\<in> {Max (insert j0 L)<..}\\<rbrakk>\n       \\<Longrightarrow> length (list_of (b k (j0, j))) = ?c", "qed (auto simp: \\<K>_finite card_b)"], ["proof (state)\nthis:\n  ordertype\n   (usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) `\n    USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..}))\n   (lenlex less_than) =\n  \\<omega> * ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "also"], ["proof (state)\nthis:\n  ordertype\n   (usplit (\\<lambda>L k. BB j0 j L @ list_of (b k (j0, j))) `\n    USigma (\\<K> j0 j) (\\<lambda>K. {Max (insert j0 K)<..}))\n   (lenlex less_than) =\n  \\<omega> * ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "have \"\\<dots> = \\<omega> \\<up> ord_of_nat (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> * ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat (Suc j)", "by (metis ih One_nat_def Ord_\\<omega> Ord_ord_of_nat oexp_1_right oexp_add one_V_def ord_of_nat.simps(1) ord_of_nat.simps(2) ord_of_nat_add plus_1_eq_Suc)"], ["proof (state)\nthis:\n  \\<omega> * ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                ordertype (BB j0 j ` \\<K> j0 j) (lenlex less_than) =\n                \\<omega> \\<up> ord_of_nat j;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j))\n                          (lenlex less_than) =\n                         \\<omega> \\<up> ord_of_nat (Suc j)", "finally"], ["proof (chain)\npicking this:\n  ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j)) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat (Suc j)", "show ?case"], ["proof (prove)\nusing this:\n  ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j)) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat (Suc j)\n\ngoal (1 subgoal):\n 1. ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j)) (lenlex less_than) =\n    \\<omega> \\<up> ord_of_nat (Suc j)", "."], ["proof (state)\nthis:\n  ordertype (BB j0 (Suc j) ` \\<K> j0 (Suc j)) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j \\<le> ?j0.0 \\<Longrightarrow>\n  ordertype (BB ?j0.0 ?j ` \\<K> ?j0.0 ?j) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat ?j\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define seqs where \"seqs \\<equiv> \\<lambda>j0 j K. list_of (a j0) # (map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0,i))) (list_of {..<j}))\""], ["proof (state)\nthis:\n  seqs \\<equiv>\n  \\<lambda>j0 j K.\n     list_of (a j0) #\n     map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0, i)))\n      (list_of {..<j})\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have length_seqs [simp]: \"length (seqs j0 j K) = Suc j\" for j0 j K"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (seqs j0 j K) = Suc j", "by (simp add: seqs_def)"], ["proof (state)\nthis:\n  length (seqs ?j0.0 ?j ?K) = Suc ?j\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have BB_eq_concat_seqs: \"BB j0 j K = concat (seqs j0 j K)\"\n          and seqs_ne: \"seqs j0 j K \\<in> lists (- {[]})\"\n      if K: \"K \\<in> \\<K> j0 j\" and \"j \\<le> j0\" for K j j0"], ["proof (prove)\ngoal (1 subgoal):\n 1. BB j0 j K = concat (seqs j0 j K) &&& seqs j0 j K \\<in> lists (- {[]})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. BB j0 j K = concat (seqs j0 j K)\n 2. seqs j0 j K \\<in> lists (- {[]})", "have j0: \"\\<And>i. i < card K \\<Longrightarrow> j0 \\<le> enum K i\" and le_j0: \"card K \\<le> j0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i < card K \\<Longrightarrow> j0 \\<le> enum K i) &&&\n    card K \\<le> j0", "using finite_enumerate_in_set that"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?S; ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> enum ?S ?n \\<in> ?S\n  K \\<in> \\<K> j0 j\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. (\\<And>i. i < card K \\<Longrightarrow> j0 \\<le> enum K i) &&&\n    card K \\<le> j0", "unfolding \\<K>_def nsets_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?S; ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> enum ?S ?n \\<in> ?S\n  K \\<in> {N. N \\<subseteq> {j0<..} \\<and> finite N \\<and> card N = j}\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. (\\<And>i. i < card K \\<Longrightarrow> j0 \\<le> enum K i) &&&\n    card K \\<le> j0", "by fastforce+"], ["proof (state)\nthis:\n  ?i < card K \\<Longrightarrow> j0 \\<le> enum K ?i\n  card K \\<le> j0\n\ngoal (2 subgoals):\n 1. BB j0 j K = concat (seqs j0 j K)\n 2. seqs j0 j K \\<in> lists (- {[]})", "show \"BB j0 j K = concat (seqs j0 j K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BB j0 j K = concat (seqs j0 j K)", "using that"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j0 j\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. BB j0 j K = concat (seqs j0 j K)", "unfolding BB_def \\<K>_def nsets_def seqs_def"], ["proof (prove)\nusing this:\n  K \\<in> {N. N \\<subseteq> {j0<..} \\<and> finite N \\<and> card N = j}\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. list_of (a j0 \\<union> (\\<Union>i<j. b (enum K i) (j0, i))) =\n    concat\n     (list_of (a j0) #\n      map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0, i)))\n       (list_of {..<j}))", "by (fastforce simp: j0 ab bb less_sets_UN2 sorted_list_of_set_Un\n          strict_mono_sets_def sorted_list_of_set_UN_lessThan)"], ["proof (state)\nthis:\n  BB j0 j K = concat (seqs j0 j K)\n\ngoal (1 subgoal):\n 1. seqs j0 j K \\<in> lists (- {[]})", "have \"b (enum K i) (j0, i) \\<noteq> {}\" if \"i < card K\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. b (enum K i) (j0, i) \\<noteq> {}", "using j0 le_j0 less_le_trans that"], ["proof (prove)\nusing this:\n  ?i < card K \\<Longrightarrow> j0 \\<le> enum K ?i\n  card K \\<le> j0\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  i < card K\n\ngoal (1 subgoal):\n 1. b (enum K i) (j0, i) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  ?i < card K \\<Longrightarrow> b (enum K ?i) (j0, ?i) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. seqs j0 j K \\<in> lists (- {[]})", "moreover"], ["proof (state)\nthis:\n  ?i < card K \\<Longrightarrow> b (enum K ?i) (j0, ?i) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. seqs j0 j K \\<in> lists (- {[]})", "have \"card K = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card K = j", "using K \\<K>_card"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j0 j\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n\ngoal (1 subgoal):\n 1. card K = j", "by blast"], ["proof (state)\nthis:\n  card K = j\n\ngoal (1 subgoal):\n 1. seqs j0 j K \\<in> lists (- {[]})", "ultimately"], ["proof (chain)\npicking this:\n  ?i < card K \\<Longrightarrow> b (enum K ?i) (j0, ?i) \\<noteq> {}\n  card K = j", "show \"seqs j0 j K \\<in> lists (- {[]})\""], ["proof (prove)\nusing this:\n  ?i < card K \\<Longrightarrow> b (enum K ?i) (j0, ?i) \\<noteq> {}\n  card K = j\n\ngoal (1 subgoal):\n 1. seqs j0 j K \\<in> lists (- {[]})", "by (clarsimp simp: seqs_def) (metis card_b_finite sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  seqs j0 j K \\<in> lists (- {[]})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 ?j ?K = concat (seqs ?j0.0 ?j ?K)\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> seqs ?j0.0 ?j ?K \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have BB_decomp: \"\\<exists>cs. BB j0 j K = concat cs \\<and> cs \\<in> lists (- {[]})\"\n    if K: \"K \\<in> \\<K> j0 j\" and \"j \\<le> j0\" for K j j0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs. BB j0 j K = concat cs \\<and> cs \\<in> lists (- {[]})", "using BB_eq_concat_seqs seqs_ne K that(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 ?j ?K = concat (seqs ?j0.0 ?j ?K)\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> seqs ?j0.0 ?j ?K \\<in> lists (- {[]})\n  K \\<in> \\<K> j0 j\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. \\<exists>cs. BB j0 j K = concat cs \\<and> cs \\<in> lists (- {[]})", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs.\n                       BB ?j0.0 ?j ?K = concat cs \\<and>\n                       cs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have a_subset_M: \"a k \\<subseteq> M k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. a k \\<subseteq> M k", "apply (clarsimp simp: a_def M_def DF_simps F_def Let_def split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a dk ab ac ba x1 x2 x2a.\n       \\<lbrakk>x \\<in> a; DF k = (dk, ab, ac, ba);\n        grab (nxt ba (enum N (Suc (Suc (Suc (2 * k)))))) (Suc k) = (x1, x2);\n        grab x2 (Min x1) = (a, x2a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ba", "by (metis (no_types) fst_conv fst_grab_subset nxt_subset snd_conv snd_grab_subset subsetD)"], ["proof (state)\nthis:\n  a ?k \\<subseteq> M ?k\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have ba_Suc: \"b k (j,i) \\<lless> a (Suc k)\" if \"i < j\" \"j \\<le> k\" for i j k"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> a (Suc k)", "by (meson a_subset_M bM less_sets_weaken2 nat_less_le that(1) that(2))"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> a (Suc ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have ba: \"b k (j,i) \\<lless> a r\" if \"i < j\" \"j \\<le> k\" \"k < r\" for i j k r"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> a r", "by (metis Suc_lessI a_ne aa ba_Suc less_sets_trans that)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k; ?k < ?r\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> a ?r\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have disjnt_ba: \"disjnt (b k (j,i)) (a r)\" if \"i < j\" \"j \\<le> k\" for i j k r"], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (b k (j, i)) (a r)", "proof (cases \"k < r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)\n 2. \\<not> k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)", "case True"], ["proof (state)\nthis:\n  k < r\n\ngoal (2 subgoals):\n 1. k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)\n 2. \\<not> k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)", "then"], ["proof (chain)\npicking this:\n  k < r", "show ?thesis"], ["proof (prove)\nusing this:\n  k < r\n\ngoal (1 subgoal):\n 1. disjnt (b k (j, i)) (a r)", "by (simp add: ba less_sets_imp_disjnt that)"], ["proof (state)\nthis:\n  disjnt (b k (j, i)) (a r)\n\ngoal (1 subgoal):\n 1. \\<not> k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)", "case False"], ["proof (state)\nthis:\n  \\<not> k < r\n\ngoal (1 subgoal):\n 1. \\<not> k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)", "then"], ["proof (chain)\npicking this:\n  \\<not> k < r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> k < r\n\ngoal (1 subgoal):\n 1. disjnt (b k (j, i)) (a r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)", "have \"a r \\<lless> b k (j,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a r \\<lless> b k (j, i)", "by (metis False a_ne aa ab_same less_linear less_sets_UN2 less_sets_trans rangeI)"], ["proof (state)\nthis:\n  a r \\<lless> b k (j, i)\n\ngoal (1 subgoal):\n 1. \\<not> k < r \\<Longrightarrow> disjnt (b k (j, i)) (a r)", "then"], ["proof (chain)\npicking this:\n  a r \\<lless> b k (j, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  a r \\<lless> b k (j, i)\n\ngoal (1 subgoal):\n 1. disjnt (b k (j, i)) (a r)", "using disjnt_sym less_sets_imp_disjnt"], ["proof (prove)\nusing this:\n  a r \\<lless> b k (j, i)\n  disjnt ?A ?B \\<Longrightarrow> disjnt ?B ?A\n  ?A \\<lless> ?B \\<Longrightarrow> disjnt ?A ?B\n\ngoal (1 subgoal):\n 1. disjnt (b k (j, i)) (a r)", "by blast"], ["proof (state)\nthis:\n  disjnt (b k (j, i)) (a r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  disjnt (b k (j, i)) (a r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> disjnt (b ?k (?j, ?i)) (a ?r)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bb_disjnt: \"disjnt (b k (j,i)) (b l (r,q))\"\n    if \"q < r\" \"i < j\" \"j \\<le> k\" \"r \\<le> l\" \"j < r\" for i j q r k l"], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (b k (j, i)) (b l (r, q))", "proof (cases \"k=l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow> disjnt (b k (j, i)) (b l (r, q))\n 2. k \\<noteq> l \\<Longrightarrow> disjnt (b k (j, i)) (b l (r, q))", "case True"], ["proof (state)\nthis:\n  k = l\n\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow> disjnt (b k (j, i)) (b l (r, q))\n 2. k \\<noteq> l \\<Longrightarrow> disjnt (b k (j, i)) (b l (r, q))", "with that"], ["proof (chain)\npicking this:\n  q < r\n  i < j\n  j \\<le> k\n  r \\<le> l\n  j < r\n  k = l", "show ?thesis"], ["proof (prove)\nusing this:\n  q < r\n  i < j\n  j \\<le> k\n  r \\<le> l\n  j < r\n  k = l\n\ngoal (1 subgoal):\n 1. disjnt (b k (j, i)) (b l (r, q))", "by (force simp: pair_less_def IJ_def intro: bb_same less_sets_imp_disjnt)"], ["proof (state)\nthis:\n  disjnt (b k (j, i)) (b l (r, q))\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow> disjnt (b k (j, i)) (b l (r, q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow> disjnt (b k (j, i)) (b l (r, q))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow> disjnt (b k (j, i)) (b l (r, q))", "with that"], ["proof (chain)\npicking this:\n  q < r\n  i < j\n  j \\<le> k\n  r \\<le> l\n  j < r\n  k \\<noteq> l", "show ?thesis"], ["proof (prove)\nusing this:\n  q < r\n  i < j\n  j \\<le> k\n  r \\<le> l\n  j < r\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. disjnt (b k (j, i)) (b l (r, q))", "by (metis bb less_sets_imp_disjnt disjnt_sym nat_neq_iff)"], ["proof (state)\nthis:\n  disjnt (b k (j, i)) (b l (r, q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?q < ?r; ?i < ?j; ?j \\<le> ?k; ?r \\<le> ?l; ?j < ?r\\<rbrakk>\n  \\<Longrightarrow> disjnt (b ?k (?j, ?i)) (b ?l (?r, ?q))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have sum_card_b: \"(\\<Sum>i<j. card (b (enum K i) (j0, i))) = enum (d j0) j - enum (d j0) 0\"\n    if K: \"K \\<subseteq> {j0<..}\" \"finite K\" \"card K \\<ge> j0\" and \"j \\<le> j0\" for j0 j K"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<j. card (b (enum K i) (j0, i))) = enum (d j0) j - enum (d j0) 0", "using \\<open>j \\<le> j0\\<close>"], ["proof (prove)\nusing this:\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<j. card (b (enum K i) (j0, i))) = enum (d j0) j - enum (d j0) 0", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> j0 \\<Longrightarrow>\n    (\\<Sum>i<0. card (b (enum K i) (j0, i))) = enum (d j0) 0 - enum (d j0) 0\n 2. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "case 0"], ["proof (state)\nthis:\n  0 \\<le> j0\n\ngoal (2 subgoals):\n 1. 0 \\<le> j0 \\<Longrightarrow>\n    (\\<Sum>i<0. card (b (enum K i) (j0, i))) = enum (d j0) 0 - enum (d j0) 0\n 2. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "then"], ["proof (chain)\npicking this:\n  0 \\<le> j0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> j0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<0. card (b (enum K i) (j0, i))) = enum (d j0) 0 - enum (d j0) 0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<0. card (b (enum K i) (j0, i))) = enum (d j0) 0 - enum (d j0) 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "case (Suc j)"], ["proof (state)\nthis:\n  j \\<le> j0 \\<Longrightarrow>\n  (\\<Sum>i<j. card (b (enum K i) (j0, i))) = enum (d j0) j - enum (d j0) 0\n  Suc j \\<le> j0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "have dis: \"disjnt (b (enum K j) (j0, j)) (\\<Union>i<j. b (enum K i) (j0, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (b (enum K j) (j0, j)) (\\<Union>i<j. b (enum K i) (j0, i))", "proof (clarsimp simp add: b_disjoint)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < j \\<Longrightarrow>\n       disjnt (b (enum K j) (j0, j)) (b (enum K x) (j0, x))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < j \\<Longrightarrow>\n       disjnt (b (enum K j) (j0, j)) (b (enum K x) (j0, x))", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < j \\<Longrightarrow>\n       disjnt (b (enum K j) (j0, j)) (b (enum K x) (j0, x))", "show \"disjnt (b (enum K j) (j0, j)) (b (enum K i) (j0,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (b (enum K j) (j0, j)) (b (enum K i) (j0, i))", "by (meson Suc.prems \\<open>i < j\\<close> b_disjoint_less disjnt_def disjnt_sym less_Suc_eq that)"], ["proof (state)\nthis:\n  disjnt (b (enum K j) (j0, j)) (b (enum K i) (j0, i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  disjnt (b (enum K j) (j0, j)) (\\<Union>i<j. b (enum K i) (j0, i))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "have j0_less: \"j0 < enum K j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j0 < enum K j", "by (meson Suc.prems Suc_le_lessD finite_enumerate_in_set greaterThan_iff less_le_trans subsetD K)"], ["proof (state)\nthis:\n  j0 < enum K j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "have \"(\\<Sum>i<Suc j. card (b (enum K i) (j0, i)))\n          = card (b (enum K j) (j0, j)) + (\\<Sum>i<j. card (b (enum K i) (j0, i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n    card (b (enum K j) (j0, j)) + (\\<Sum>i<j. card (b (enum K i) (j0, i)))", "by (simp add: lessThan_Suc card_Un_disjnt [OF _ _ dis])"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n  card (b (enum K j) (j0, j)) + (\\<Sum>i<j. card (b (enum K i) (j0, i)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n  card (b (enum K j) (j0, j)) + (\\<Sum>i<j. card (b (enum K i) (j0, i)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "have \"\\<dots> = card (b (enum K j) (j0, j)) + enum (d j0) j - enum (d j0) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b (enum K j) (j0, j)) + (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n    card (b (enum K j) (j0, j)) + enum (d j0) j - enum (d j0) 0", "using \\<open>Suc j \\<le> j0\\<close>"], ["proof (prove)\nusing this:\n  Suc j \\<le> j0\n\ngoal (1 subgoal):\n 1. card (b (enum K j) (j0, j)) + (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n    card (b (enum K j) (j0, j)) + enum (d j0) j - enum (d j0) 0", "by (simp add: Suc.IH split: nat_diff_split)"], ["proof (state)\nthis:\n  card (b (enum K j) (j0, j)) + (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n  card (b (enum K j) (j0, j)) + enum (d j0) j - enum (d j0) 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "also"], ["proof (state)\nthis:\n  card (b (enum K j) (j0, j)) + (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n  card (b (enum K j) (j0, j)) + enum (d j0) j - enum (d j0) 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "have \"\\<dots> = enum (d j0) (Suc j) - enum (d j0) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b (enum K j) (j0, j)) + enum (d j0) j - enum (d j0) 0 =\n    enum (d j0) (Suc j) - enum (d j0) 0", "using j0_less"], ["proof (prove)\nusing this:\n  j0 < enum K j\n\ngoal (1 subgoal):\n 1. card (b (enum K j) (j0, j)) + enum (d j0) j - enum (d j0) 0 =\n    enum (d j0) (Suc j) - enum (d j0) 0", "apply (simp add: card_b split: nat_diff_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. j0 < enum K j \\<Longrightarrow>\n    \\<forall>da.\n       enum (d j0) j = enum (d j0) 0 + da \\<longrightarrow>\n       enum (d j0) (Suc j) < enum (d j0) 0 + da \\<longrightarrow>\n       (enum (d j0) (Suc j) < enum (d j0) 0 \\<longrightarrow> da = 0) \\<and>\n       (\\<forall>da. enum (d j0) (Suc j) \\<noteq> enum (d j0) 0 + da)", "by (metis Suc.prems card_d finite_d finite_enumerate_step le_imp_less_Suc less_asym)"], ["proof (state)\nthis:\n  card (b (enum K j) (j0, j)) + enum (d j0) j - enum (d j0) 0 =\n  enum (d j0) (Suc j) - enum (d j0) 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> j0 \\<Longrightarrow>\n                (\\<Sum>i<j. card (b (enum K i) (j0, i))) =\n                enum (d j0) j - enum (d j0) 0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n                         enum (d j0) (Suc j) - enum (d j0) 0", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n  enum (d j0) (Suc j) - enum (d j0) 0", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n  enum (d j0) (Suc j) - enum (d j0) 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n    enum (d j0) (Suc j) - enum (d j0) 0", "."], ["proof (state)\nthis:\n  (\\<Sum>i<Suc j. card (b (enum K i) (j0, i))) =\n  enum (d j0) (Suc j) - enum (d j0) 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i<?j. card (b (enum ?K i) (?j0.0, i))) =\n                    enum (d ?j0.0) ?j - enum (d ?j0.0) 0\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have card_UN_b: \"card (\\<Union>i<j. b (enum K i) (j0, i)) = enum (d j0) j - enum (d j0) 0\"\n    if K: \"K \\<subseteq> {j0<..}\" \"finite K\" \"card K \\<ge> j0\" and \"j \\<le> j0\" for j0 j K"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union>i<j. b (enum K i) (j0, i)) = enum (d j0) j - enum (d j0) 0", "using that"], ["proof (prove)\nusing this:\n  K \\<subseteq> {j0<..}\n  finite K\n  j0 \\<le> card K\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. card (\\<Union>i<j. b (enum K i) (j0, i)) = enum (d j0) j - enum (d j0) 0", "by (simp add: card_UN_disjoint sum_card_b b_disjoint)"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union>i<?j. b (enum ?K i) (?j0.0, i)) =\n                    enum (d ?j0.0) ?j - enum (d ?j0.0) 0\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have len_BB: \"length (BB j j K) = enum (d j) j\"\n    if K: \"K \\<in> \\<K> j j\" and \"j \\<le> j\" for j K"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (BB j j K) = enum (d j) j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (BB j j K) = enum (d j) j", "have dis_ab: \"\\<And>i. i < j \\<Longrightarrow> disjnt (a j) (b (enum K i) (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < j \\<Longrightarrow> disjnt (a j) (b (enum K i) (j, i))", "using K \\<K>_card \\<K>_enum ab less_sets_imp_disjnt nat_less_le"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j j\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?i < card ?K\\<rbrakk>\n  \\<Longrightarrow> ?j0.0 < enum ?K ?i\n  ?k' \\<le> ?k \\<Longrightarrow> a ?k' \\<lless> b ?k (?j, ?i)\n  ?A \\<lless> ?B \\<Longrightarrow> disjnt ?A ?B\n  (?m < ?n) = (?m \\<le> ?n \\<and> ?m \\<noteq> ?n)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < j \\<Longrightarrow> disjnt (a j) (b (enum K i) (j, i))", "by blast"], ["proof (state)\nthis:\n  ?i < j \\<Longrightarrow> disjnt (a j) (b (enum K ?i) (j, ?i))\n\ngoal (1 subgoal):\n 1. length (BB j j K) = enum (d j) j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (BB j j K) = enum (d j) j", "using K"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j j\n\ngoal (1 subgoal):\n 1. length (BB j j K) = enum (d j) j", "unfolding BB_def \\<K>_def nsets_def"], ["proof (prove)\nusing this:\n  K \\<in> {N. N \\<subseteq> {j<..} \\<and> finite N \\<and> card N = j}\n\ngoal (1 subgoal):\n 1. length (list_of (a j \\<union> (\\<Union>i<j. b (enum K i) (j, i)))) =\n    enum (d j) j", "by (simp add: card_UN_b card_Un_disjnt dis_ab card_a cInf_le_finite finite_enumerate_in_set enum_0_eq_Inf_finite)"], ["proof (state)\nthis:\n  length (BB j j K) = enum (d j) j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<in> \\<K> ?j ?j; ?j \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> length (BB ?j ?j ?K) = enum (d ?j) ?j\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"d k \\<lless> d (Suc k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. d k \\<lless> d (Suc k)", "by (metis aM a_ne d_eq da less_sets_fst_grab less_sets_trans less_sets_weaken2 nxt_subset)"], ["proof (state)\nthis:\n  d ?k \\<lless> d (Suc ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  d ?k \\<lless> d (Suc ?k)", "have dd: \"d k' \\<lless> d k\" if \"k' < k\" for k' k"], ["proof (prove)\nusing this:\n  d ?k \\<lless> d (Suc ?k)\n\ngoal (1 subgoal):\n 1. d k' \\<lless> d k", "by (meson UNIV_I d_ne less_sets_imp_strict_mono_sets strict_mono_sets_def that)"], ["proof (state)\nthis:\n  ?k' < ?k \\<Longrightarrow> d ?k' \\<lless> d ?k\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?X \\<subseteq> WW\n 2. ordertype ?X (lenlex less_than) = \\<omega> \\<up> \\<omega>\n 3. \\<And>u.\n       u \\<in> [?X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       \\<exists>l.\n          Form l u \\<and>\n          (0 < l \\<longrightarrow>\n           [enum N l] < inter_scheme l u \\<and>\n           list.set (inter_scheme l u) \\<subseteq> N)", "show \"(\\<Union> (range XX)) \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range XX) \\<subseteq> WW", "by (auto simp: XX_def BB_def WW_def)"], ["proof (state)\nthis:\n  \\<Union> (range XX) \\<subseteq> WW\n\ngoal (2 subgoals):\n 1. ordertype (\\<Union> (range XX)) (lenlex less_than) =\n    \\<omega> \\<up> \\<omega>\n 2. \\<And>u.\n       u \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       \\<exists>l.\n          Form l u \\<and>\n          (0 < l \\<longrightarrow>\n           [enum N l] < inter_scheme l u \\<and>\n           list.set (inter_scheme l u) \\<subseteq> N)", "show \"ordertype (\\<Union> (range XX)) (?LL) = \\<omega> \\<up> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (\\<Union> (range XX)) (lenlex less_than) =\n    \\<omega> \\<up> \\<omega>", "using ot\\<omega>j"], ["proof (prove)\nusing this:\n  ?j \\<le> ?j0.0 \\<Longrightarrow>\n  ordertype (BB ?j0.0 ?j ` \\<K> ?j0.0 ?j) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat ?j\n\ngoal (1 subgoal):\n 1. ordertype (\\<Union> (range XX)) (lenlex less_than) =\n    \\<omega> \\<up> \\<omega>", "by (simp add: XX_def ordertype_\\<omega>\\<omega>)"], ["proof (state)\nthis:\n  ordertype (\\<Union> (range XX)) (lenlex less_than) =\n  \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       \\<exists>l.\n          Form l u \\<and>\n          (0 < l \\<longrightarrow>\n           [enum N l] < inter_scheme l u \\<and>\n           list.set (inter_scheme l u) \\<subseteq> N)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       \\<exists>l.\n          Form l u \\<and>\n          (0 < l \\<longrightarrow>\n           [enum N l] < inter_scheme l u \\<and>\n           list.set (inter_scheme l u) \\<subseteq> N)", "fix U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       \\<exists>l.\n          Form l u \\<and>\n          (0 < l \\<longrightarrow>\n           [enum N l] < inter_scheme l u \\<and>\n           list.set (inter_scheme l u) \\<subseteq> N)", "assume U: \"U \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup>\""], ["proof (state)\nthis:\n  U \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       \\<exists>l.\n          Form l u \\<and>\n          (0 < l \\<longrightarrow>\n           [enum N l] < inter_scheme l u \\<and>\n           list.set (inter_scheme l u) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  U \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup>", "obtain x y where Ueq: \"U = {x,y}\" and len_xy: \"length x \\<le> length y\""], ["proof (prove)\nusing this:\n  U \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>U = {x, y}; length x \\<le> length y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: lenlex_nsets_2_eq lenlex_length)"], ["proof (state)\nthis:\n  U = {x, y}\n  length x \\<le> length y\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n       \\<exists>l.\n          Form l u \\<and>\n          (0 < l \\<longrightarrow>\n           [enum N l] < inter_scheme l u \\<and>\n           list.set (inter_scheme l u) \\<subseteq> N)", "show \"\\<exists>l. Form l U \\<and> (0 < l \\<longrightarrow> [enum N l] < inter_scheme l U \\<and> list.set (inter_scheme l U) \\<subseteq> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "proof (cases \"length x = length y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length x = length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)\n 2. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "case True"], ["proof (state)\nthis:\n  length x = length y\n\ngoal (2 subgoals):\n 1. length x = length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)\n 2. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  length x = length y", "show ?thesis"], ["proof (prove)\nusing this:\n  length x = length y\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "using Form.intros(1) U Ueq"], ["proof (prove)\nusing this:\n  length x = length y\n  \\<lbrakk>length ?xs = length ?ys; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> Form 0 {?xs, ?ys}\n  U \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup>\n  U = {x, y}\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>l.\n     Form l U \\<and>\n     (0 < l \\<longrightarrow>\n      [enum N l] < inter_scheme l U \\<and>\n      list.set (inter_scheme l U) \\<subseteq> N)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "case False"], ["proof (state)\nthis:\n  length x \\<noteq> length y\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  length x \\<noteq> length y", "have xy: \"length x < length y\""], ["proof (prove)\nusing this:\n  length x \\<noteq> length y\n\ngoal (1 subgoal):\n 1. length x < length y", "using len_xy"], ["proof (prove)\nusing this:\n  length x \\<noteq> length y\n  length x \\<le> length y\n\ngoal (1 subgoal):\n 1. length x < length y", "by auto"], ["proof (state)\nthis:\n  length x < length y\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "obtain j r K L where K: \"K \\<in> \\<K> j j\" and xeq: \"x = BB j j K\"\n        and ne: \"BB j j K \\<noteq> BB r r L\"\n        and L: \"L \\<in> \\<K> r r\" and yeq: \"y = BB r r L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>K j r L.\n        \\<lbrakk>K \\<in> \\<K> j j; x = BB j j K; BB j j K \\<noteq> BB r r L;\n         L \\<in> \\<K> r r; y = BB r r L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using U"], ["proof (prove)\nusing this:\n  U \\<in> [\\<Union> (range XX)]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. (\\<And>K j r L.\n        \\<lbrakk>K \\<in> \\<K> j j; x = BB j j K; BB j j K \\<noteq> BB r r L;\n         L \\<in> \\<K> r r; y = BB r r L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ueq XX_def)"], ["proof (state)\nthis:\n  K \\<in> \\<K> j j\n  x = BB j j K\n  BB j j K \\<noteq> BB r r L\n  L \\<in> \\<K> r r\n  y = BB r r L\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  K \\<in> \\<K> j j\n  x = BB j j K\n  BB j j K \\<noteq> BB r r L\n  L \\<in> \\<K> r r\n  y = BB r r L", "have \"length x = enum (d j) j\" \"length y = enum (d r) r\""], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j j\n  x = BB j j K\n  BB j j K \\<noteq> BB r r L\n  L \\<in> \\<K> r r\n  y = BB r r L\n\ngoal (1 subgoal):\n 1. length x = enum (d j) j &&& length y = enum (d r) r", "by (auto simp: len_BB)"], ["proof (state)\nthis:\n  length x = enum (d j) j\n  length y = enum (d r) r\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  length x = enum (d j) j\n  length y = enum (d r) r", "have \"j < r\""], ["proof (prove)\nusing this:\n  length x = enum (d j) j\n  length y = enum (d r) r\n\ngoal (1 subgoal):\n 1. j < r", "using xy dd"], ["proof (prove)\nusing this:\n  length x = enum (d j) j\n  length y = enum (d r) r\n  length x < length y\n  ?k' < ?k \\<Longrightarrow> d ?k' \\<lless> d ?k\n\ngoal (1 subgoal):\n 1. j < r", "by (metis card_d finite_enumerate_in_set finite_d lessI less_asym less_setsD linorder_neqE_nat)"], ["proof (state)\nthis:\n  j < r\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  j < r", "have aj_ar: \"a j \\<lless> a r\""], ["proof (prove)\nusing this:\n  j < r\n\ngoal (1 subgoal):\n 1. a j \\<lless> a r", "using aa"], ["proof (prove)\nusing this:\n  j < r\n  ?j < ?k \\<Longrightarrow> a ?j \\<lless> a ?k\n\ngoal (1 subgoal):\n 1. a j \\<lless> a r", "by auto"], ["proof (state)\nthis:\n  a j \\<lless> a r\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have Ksub: \"K \\<subseteq> {j<..}\" and \"finite K\" \"card K \\<ge> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<subseteq> {j<..} &&& finite K &&& j \\<le> card K", "using K"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j j\n\ngoal (1 subgoal):\n 1. K \\<subseteq> {j<..} &&& finite K &&& j \\<le> card K", "by (auto simp: \\<K>_def nsets_def)"], ["proof (state)\nthis:\n  K \\<subseteq> {j<..}\n  finite K\n  j \\<le> card K\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have Lsub: \"L \\<subseteq> {r<..}\" and \"finite L\" \"card L \\<ge> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<subseteq> {r<..} &&& finite L &&& r \\<le> card L", "using L"], ["proof (prove)\nusing this:\n  L \\<in> \\<K> r r\n\ngoal (1 subgoal):\n 1. L \\<subseteq> {r<..} &&& finite L &&& r \\<le> card L", "by (auto simp: \\<K>_def nsets_def)"], ["proof (state)\nthis:\n  L \\<subseteq> {r<..}\n  finite L\n  r \\<le> card L\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have enumK: \"enum K i > j\" if \"i < j\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < enum K i", "using K \\<K>_card \\<K>_enum that"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j j\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?i < card ?K\\<rbrakk>\n  \\<Longrightarrow> ?j0.0 < enum ?K ?i\n  i < j\n\ngoal (1 subgoal):\n 1. j < enum K i", "by blast"], ["proof (state)\nthis:\n  ?i < j \\<Longrightarrow> j < enum K ?i\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have enumL: \"enum L i > r\" if \"i < r\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < enum L i", "using L \\<K>_card \\<K>_enum that"], ["proof (prove)\nusing this:\n  L \\<in> \\<K> r r\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?i < card ?K\\<rbrakk>\n  \\<Longrightarrow> ?j0.0 < enum ?K ?i\n  i < r\n\ngoal (1 subgoal):\n 1. r < enum L i", "by blast"], ["proof (state)\nthis:\n  ?i < r \\<Longrightarrow> r < enum L ?i\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have \"list.set (acc_lengths w (seqs j0 j K)) \\<subseteq> (+) w ` d j0\"\n        if K: \"K \\<subseteq> {j0<..}\" \"finite K\" \"card K \\<ge> j0\" and \"j \\<le> j0\" for j0 j K w"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (acc_lengths w (seqs j0 j K)) \\<subseteq> (+) w ` d j0", "using \\<open>j \\<le> j0\\<close>"], ["proof (prove)\nusing this:\n  j \\<le> j0\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths w (seqs j0 j K)) \\<subseteq> (+) w ` d j0", "proof (induction j arbitrary: w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w.\n       0 \\<le> j0 \\<Longrightarrow>\n       list.set (acc_lengths w (seqs j0 0 K)) \\<subseteq> (+) w ` d j0\n 2. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "case 0"], ["proof (state)\nthis:\n  0 \\<le> j0\n\ngoal (2 subgoals):\n 1. \\<And>w.\n       0 \\<le> j0 \\<Longrightarrow>\n       list.set (acc_lengths w (seqs j0 0 K)) \\<subseteq> (+) w ` d j0\n 2. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "then"], ["proof (chain)\npicking this:\n  0 \\<le> j0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> j0\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths w (seqs j0 0 K)) \\<subseteq> (+) w ` d j0", "by (simp add: seqs_def acc_lengths.simps Inf_nat_def1 card_a)"], ["proof (state)\nthis:\n  list.set (acc_lengths w (seqs j0 0 K)) \\<subseteq> (+) w ` d j0\n\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "case (Suc j)"], ["proof (state)\nthis:\n  j \\<le> j0 \\<Longrightarrow>\n  list.set (acc_lengths ?w (seqs j0 j K)) \\<subseteq> (+) ?w ` d j0\n  Suc j \\<le> j0\n\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "let ?db = \"\\<Sqinter> (d j0) + ((\\<Sum>i<j. card (b (enum K i) (j0,i))) + card (b (enum K j) (j0,j)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "have \"j0 < enum K j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j0 < enum K j", "by (meson Suc.prems Suc_le_lessD finite_enumerate_in_set greaterThan_iff le_trans subsetD K)"], ["proof (state)\nthis:\n  j0 < enum K j\n\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "then"], ["proof (chain)\npicking this:\n  j0 < enum K j", "have \"?db = enum (d j0) (Suc j)\""], ["proof (prove)\nusing this:\n  j0 < enum K j\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (d j0) +\n    ((\\<Sum>i<j. card (b (enum K i) (j0, i))) +\n     card (b (enum K j) (j0, j))) =\n    enum (d j0) (Suc j)", "using Suc.prems"], ["proof (prove)\nusing this:\n  j0 < enum K j\n  Suc j \\<le> j0\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (d j0) +\n    ((\\<Sum>i<j. card (b (enum K i) (j0, i))) +\n     card (b (enum K j) (j0, j))) =\n    enum (d j0) (Suc j)", "apply (simp add: sum_card_b card_b that enum_d_0 split: nat_diff_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j0 < enum K j; Suc j \\<le> j0\\<rbrakk>\n    \\<Longrightarrow> enum (d j0) j < \\<Sqinter> (d j0) \\<longrightarrow>\n                      (\\<forall>da.\n                          enum (d j0) (Suc j) \\<noteq> enum (d j0) j + da)", "by (simp add: cInf_le_finite finite_enumerate_in_set leD)"], ["proof (state)\nthis:\n  \\<Sqinter> (d j0) +\n  ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j))) =\n  enum (d j0) (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "then"], ["proof (chain)\npicking this:\n  \\<Sqinter> (d j0) +\n  ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j))) =\n  enum (d j0) (Suc j)", "have \"?db \\<in> d j0\""], ["proof (prove)\nusing this:\n  \\<Sqinter> (d j0) +\n  ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j))) =\n  enum (d j0) (Suc j)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (d j0) +\n    ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j)))\n    \\<in> d j0", "using Suc.prems finite_enumerate_in_set"], ["proof (prove)\nusing this:\n  \\<Sqinter> (d j0) +\n  ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j))) =\n  enum (d j0) (Suc j)\n  Suc j \\<le> j0\n  \\<lbrakk>finite ?S; ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> enum ?S ?n \\<in> ?S\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (d j0) +\n    ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j)))\n    \\<in> d j0", "by (auto simp: finite_enumerate_in_set)"], ["proof (state)\nthis:\n  \\<Sqinter> (d j0) +\n  ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j)))\n  \\<in> d j0\n\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "moreover"], ["proof (state)\nthis:\n  \\<Sqinter> (d j0) +\n  ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j)))\n  \\<in> d j0\n\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "have \"list.set (acc_lengths w (seqs j0 j K)) \\<subseteq> (+) w ` d j0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (acc_lengths w (seqs j0 j K)) \\<subseteq> (+) w ` d j0", "by (simp add: Suc Suc_leD)"], ["proof (state)\nthis:\n  list.set (acc_lengths w (seqs j0 j K)) \\<subseteq> (+) w ` d j0\n\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "then"], ["proof (chain)\npicking this:\n  list.set (acc_lengths w (seqs j0 j K)) \\<subseteq> (+) w ` d j0", "have \"list.set (acc_lengths (w + \\<Sqinter> (d j0))\n                             (map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0,i))) (list_of {..<j})))\n                   \\<subseteq> (+) w ` d j0\""], ["proof (prove)\nusing this:\n  list.set (acc_lengths w (seqs j0 j K)) \\<subseteq> (+) w ` d j0\n\ngoal (1 subgoal):\n 1. list.set\n     (acc_lengths (w + \\<Sqinter> (d j0))\n       (map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0, i)))\n         (list_of {..<j})))\n    \\<subseteq> (+) w ` d j0", "by (simp add: seqs_def acc_lengths.simps card_a subset_insertI)"], ["proof (state)\nthis:\n  list.set\n   (acc_lengths (w + \\<Sqinter> (d j0))\n     (map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0, i)))\n       (list_of {..<j})))\n  \\<subseteq> (+) w ` d j0\n\ngoal (1 subgoal):\n 1. \\<And>j w.\n       \\<lbrakk>\\<And>w.\n                   j \\<le> j0 \\<Longrightarrow>\n                   list.set (acc_lengths w (seqs j0 j K))\n                   \\<subseteq> (+) w ` d j0;\n        Suc j \\<le> j0\\<rbrakk>\n       \\<Longrightarrow> list.set (acc_lengths w (seqs j0 (Suc j) K))\n                         \\<subseteq> (+) w ` d j0", "ultimately"], ["proof (chain)\npicking this:\n  \\<Sqinter> (d j0) +\n  ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j)))\n  \\<in> d j0\n  list.set\n   (acc_lengths (w + \\<Sqinter> (d j0))\n     (map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0, i)))\n       (list_of {..<j})))\n  \\<subseteq> (+) w ` d j0", "show ?case"], ["proof (prove)\nusing this:\n  \\<Sqinter> (d j0) +\n  ((\\<Sum>i<j. card (b (enum K i) (j0, i))) + card (b (enum K j) (j0, j)))\n  \\<in> d j0\n  list.set\n   (acc_lengths (w + \\<Sqinter> (d j0))\n     (map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0, i)))\n       (list_of {..<j})))\n  \\<subseteq> (+) w ` d j0\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths w (seqs j0 (Suc j) K)) \\<subseteq> (+) w ` d j0", "by (simp add: seqs_def acc_lengths.simps acc_lengths_append image_iff Inf_nat_def1\n                        sum_sorted_list_of_set_map card_a)"], ["proof (state)\nthis:\n  list.set (acc_lengths w (seqs j0 (Suc j) K)) \\<subseteq> (+) w ` d j0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> list.set (acc_lengths ?w (seqs ?j0.0 ?j ?K))\n                    \\<subseteq> (+) ?w ` d ?j0.0\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> list.set (acc_lengths ?w (seqs ?j0.0 ?j ?K))\n                    \\<subseteq> (+) ?w ` d ?j0.0", "have acc_lengths_subset_d: \"list.set (acc_lengths 0 (seqs j0 j K)) \\<subseteq> d j0\"\n        if K: \"K \\<subseteq> {j0<..}\" \"finite K\" \"card K \\<ge> j0\" and \"j \\<le> j0\" for j0 j K"], ["proof (prove)\nusing this:\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> list.set (acc_lengths ?w (seqs ?j0.0 ?j ?K))\n                    \\<subseteq> (+) ?w ` d ?j0.0\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths 0 (seqs j0 j K)) \\<subseteq> d j0", "by (metis image_add_0 that)"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> list.set (acc_lengths 0 (seqs ?j0.0 ?j ?K))\n                    \\<subseteq> d ?j0.0\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have \"strict_sorted x\" \"strict_sorted y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted x &&& strict_sorted y", "by (auto simp: xeq yeq BB_def)"], ["proof (state)\nthis:\n  strict_sorted x\n  strict_sorted y\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have disjnt_xy: \"disjnt (list.set x) (list.set y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "have \"disjnt (a j) (a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (a j) (a r)", "using \\<open>j < r\\<close> aa less_sets_imp_disjnt"], ["proof (prove)\nusing this:\n  j < r\n  ?j < ?k \\<Longrightarrow> a ?j \\<lless> a ?k\n  ?A \\<lless> ?B \\<Longrightarrow> disjnt ?A ?B\n\ngoal (1 subgoal):\n 1. disjnt (a j) (a r)", "by blast"], ["proof (state)\nthis:\n  disjnt (a j) (a r)\n\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "moreover"], ["proof (state)\nthis:\n  disjnt (a j) (a r)\n\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "have \"disjnt (b (enum K i) (j,i)) (a r)\" if \"i < j\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (b (enum K i) (j, i)) (a r)", "by (simp add: disjnt_ba enumK less_imp_le_nat that)"], ["proof (state)\nthis:\n  ?i < j \\<Longrightarrow> disjnt (b (enum K ?i) (j, ?i)) (a r)\n\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "moreover"], ["proof (state)\nthis:\n  ?i < j \\<Longrightarrow> disjnt (b (enum K ?i) (j, ?i)) (a r)\n\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "have \"disjnt (a j) (b (enum L q) (r,q))\" if \"q < r\" for q"], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (a j) (b (enum L q) (r, q))", "by (meson disjnt_ba disjnt_sym enumL less_imp_le_nat that)"], ["proof (state)\nthis:\n  ?q < r \\<Longrightarrow> disjnt (a j) (b (enum L ?q) (r, ?q))\n\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "moreover"], ["proof (state)\nthis:\n  ?q < r \\<Longrightarrow> disjnt (a j) (b (enum L ?q) (r, ?q))\n\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "have \"disjnt (b (enum K i) (j,i)) (b (enum L q) (r,q))\" if \"i < j\" \"q < r\" for i q"], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (b (enum K i) (j, i)) (b (enum L q) (r, q))", "by (meson \\<open>j < r\\<close> bb_disjnt enumK enumL less_imp_le that)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < j; ?q < r\\<rbrakk>\n  \\<Longrightarrow> disjnt (b (enum K ?i) (j, ?i)) (b (enum L ?q) (r, ?q))\n\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "ultimately"], ["proof (chain)\npicking this:\n  disjnt (a j) (a r)\n  ?i < j \\<Longrightarrow> disjnt (b (enum K ?i) (j, ?i)) (a r)\n  ?q < r \\<Longrightarrow> disjnt (a j) (b (enum L ?q) (r, ?q))\n  \\<lbrakk>?i < j; ?q < r\\<rbrakk>\n  \\<Longrightarrow> disjnt (b (enum K ?i) (j, ?i)) (b (enum L ?q) (r, ?q))", "show ?thesis"], ["proof (prove)\nusing this:\n  disjnt (a j) (a r)\n  ?i < j \\<Longrightarrow> disjnt (b (enum K ?i) (j, ?i)) (a r)\n  ?q < r \\<Longrightarrow> disjnt (a j) (b (enum L ?q) (r, ?q))\n  \\<lbrakk>?i < j; ?q < r\\<rbrakk>\n  \\<Longrightarrow> disjnt (b (enum K ?i) (j, ?i)) (b (enum L ?q) (r, ?q))\n\ngoal (1 subgoal):\n 1. disjnt (list.set x) (list.set y)", "by (simp add: xeq yeq BB_def)"], ["proof (state)\nthis:\n  disjnt (list.set x) (list.set y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  disjnt (list.set x) (list.set y)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have \"\\<exists>us vs. merge (seqs j j K) (seqs r r L) us vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us vs. merge (seqs j j K) (seqs r r L) us vs", "proof (rule merge_exists)"], ["proof (state)\ngoal (8 subgoals):\n 1. strict_sorted (concat (seqs j j K))\n 2. strict_sorted (concat (seqs r r L))\n 3. seqs j j K \\<in> lists (- {[]})\n 4. seqs r r L \\<in> lists (- {[]})\n 5. hd (seqs j j K) < hd (seqs r r L)\n 6. seqs j j K \\<noteq> []\n 7. seqs r r L \\<noteq> []\n 8. \\<And>a b.\n       \\<lbrakk>a \\<in> list.set (seqs j j K);\n        b \\<in> list.set (seqs r r L)\\<rbrakk>\n       \\<Longrightarrow> a < b \\<or> b < a", "show \"strict_sorted (concat (seqs j j K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat (seqs j j K))", "using BB_eq_concat_seqs K \\<open>strict_sorted x\\<close> xeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 ?j ?K = concat (seqs ?j0.0 ?j ?K)\n  K \\<in> \\<K> j j\n  strict_sorted x\n  x = BB j j K\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (seqs j j K))", "by auto"], ["proof (state)\nthis:\n  strict_sorted (concat (seqs j j K))\n\ngoal (7 subgoals):\n 1. strict_sorted (concat (seqs r r L))\n 2. seqs j j K \\<in> lists (- {[]})\n 3. seqs r r L \\<in> lists (- {[]})\n 4. hd (seqs j j K) < hd (seqs r r L)\n 5. seqs j j K \\<noteq> []\n 6. seqs r r L \\<noteq> []\n 7. \\<And>a b.\n       \\<lbrakk>a \\<in> list.set (seqs j j K);\n        b \\<in> list.set (seqs r r L)\\<rbrakk>\n       \\<Longrightarrow> a < b \\<or> b < a", "show \"strict_sorted (concat (seqs r r L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat (seqs r r L))", "using BB_eq_concat_seqs L \\<open>strict_sorted y\\<close> yeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 ?j ?K = concat (seqs ?j0.0 ?j ?K)\n  L \\<in> \\<K> r r\n  strict_sorted y\n  y = BB r r L\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (seqs r r L))", "by auto"], ["proof (state)\nthis:\n  strict_sorted (concat (seqs r r L))\n\ngoal (6 subgoals):\n 1. seqs j j K \\<in> lists (- {[]})\n 2. seqs r r L \\<in> lists (- {[]})\n 3. hd (seqs j j K) < hd (seqs r r L)\n 4. seqs j j K \\<noteq> []\n 5. seqs r r L \\<noteq> []\n 6. \\<And>a b.\n       \\<lbrakk>a \\<in> list.set (seqs j j K);\n        b \\<in> list.set (seqs r r L)\\<rbrakk>\n       \\<Longrightarrow> a < b \\<or> b < a", "show \"seqs j j K \\<in> lists (- {[]})\" \"seqs r r L \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqs j j K \\<in> lists (- {[]}) &&& seqs r r L \\<in> lists (- {[]})", "by (auto simp: K L seqs_ne)"], ["proof (state)\nthis:\n  seqs j j K \\<in> lists (- {[]})\n  seqs r r L \\<in> lists (- {[]})\n\ngoal (4 subgoals):\n 1. hd (seqs j j K) < hd (seqs r r L)\n 2. seqs j j K \\<noteq> []\n 3. seqs r r L \\<noteq> []\n 4. \\<And>a b.\n       \\<lbrakk>a \\<in> list.set (seqs j j K);\n        b \\<in> list.set (seqs r r L)\\<rbrakk>\n       \\<Longrightarrow> a < b \\<or> b < a", "show \"hd (seqs j j K) < hd (seqs r r L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (seqs j j K) < hd (seqs r r L)", "by (simp add: aj_ar less_sets_imp_list_less seqs_def)"], ["proof (state)\nthis:\n  hd (seqs j j K) < hd (seqs r r L)\n\ngoal (3 subgoals):\n 1. seqs j j K \\<noteq> []\n 2. seqs r r L \\<noteq> []\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> list.set (seqs j j K);\n        b \\<in> list.set (seqs r r L)\\<rbrakk>\n       \\<Longrightarrow> a < b \\<or> b < a", "show \"seqs j j K \\<noteq> []\" \"seqs r r L \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqs j j K \\<noteq> [] &&& seqs r r L \\<noteq> []", "using seqs_def"], ["proof (prove)\nusing this:\n  seqs \\<equiv>\n  \\<lambda>j0 j K.\n     list_of (a j0) #\n     map (list_of \\<circ> (\\<lambda>i. b (enum K i) (j0, i)))\n      (list_of {..<j})\n\ngoal (1 subgoal):\n 1. seqs j j K \\<noteq> [] &&& seqs r r L \\<noteq> []", "by blast+"], ["proof (state)\nthis:\n  seqs j j K \\<noteq> []\n  seqs r r L \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> list.set (seqs j j K);\n        b \\<in> list.set (seqs r r L)\\<rbrakk>\n       \\<Longrightarrow> a < b \\<or> b < a", "have less_bb: \"b (enum K i) (j,i) \\<lless> b (enum L p) (r, p)\"\n          if neg: \"\\<not> b (enum L p) (r, p) \\<lless> b (enum K i) (j,i)\" and \"i < j\" \"p < r\"\n          for i p"], ["proof (prove)\ngoal (1 subgoal):\n 1. b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "proof (cases \"enum K i\" \"enum L p\" rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. enum K i < enum L p \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n 2. enum K i = enum L p \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n 3. enum L p < enum K i \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "case less"], ["proof (state)\nthis:\n  enum K i < enum L p\n\ngoal (3 subgoals):\n 1. enum K i < enum L p \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n 2. enum K i = enum L p \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n 3. enum L p < enum K i \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "then"], ["proof (chain)\npicking this:\n  enum K i < enum L p", "show ?thesis"], ["proof (prove)\nusing this:\n  enum K i < enum L p\n\ngoal (1 subgoal):\n 1. b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "by (simp add: bb enumK less_imp_le_nat \\<open>i < j\\<close>)"], ["proof (state)\nthis:\n  b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n\ngoal (2 subgoals):\n 1. enum K i = enum L p \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n 2. enum L p < enum K i \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. enum K i = enum L p \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n 2. enum L p < enum K i \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "case equal"], ["proof (state)\nthis:\n  enum K i = enum L p\n\ngoal (2 subgoals):\n 1. enum K i = enum L p \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n 2. enum L p < enum K i \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "then"], ["proof (chain)\npicking this:\n  enum K i = enum L p", "show ?thesis"], ["proof (prove)\nusing this:\n  enum K i = enum L p\n\ngoal (1 subgoal):\n 1. b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "using \\<open>j < r\\<close> enumK \\<open>i < j\\<close>"], ["proof (prove)\nusing this:\n  enum K i = enum L p\n  j < r\n  ?i < j \\<Longrightarrow> j < enum K ?i\n  i < j\n\ngoal (1 subgoal):\n 1. b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "by (force simp: IJ_iff pair_less_def intro: bb_same)"], ["proof (state)\nthis:\n  b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n\ngoal (1 subgoal):\n 1. enum L p < enum K i \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. enum L p < enum K i \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "case greater"], ["proof (state)\nthis:\n  enum L p < enum K i\n\ngoal (1 subgoal):\n 1. enum L p < enum K i \\<Longrightarrow>\n    b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "then"], ["proof (chain)\npicking this:\n  enum L p < enum K i", "show ?thesis"], ["proof (prove)\nusing this:\n  enum L p < enum K i\n\ngoal (1 subgoal):\n 1. b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "using bb enumL less_imp_le_nat neg \\<open>p < r\\<close>"], ["proof (prove)\nusing this:\n  enum L p < enum K i\n  \\<lbrakk>?i' < ?j'; ?j' \\<le> ?k'; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k' (?j', ?i') \\<lless> b ?k (?j, ?i)\n  ?i < r \\<Longrightarrow> r < enum L ?i\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n  \\<not> b (enum L p) (r, p) \\<lless> b (enum K i) (j, i)\n  p < r\n\ngoal (1 subgoal):\n 1. b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)", "by blast"], ["proof (state)\nthis:\n  b (enum K i) (j, i) \\<lless> b (enum L p) (r, p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> b (enum L ?p) (r, ?p) \\<lless> b (enum K ?i) (j, ?i);\n   ?i < j; ?p < r\\<rbrakk>\n  \\<Longrightarrow> b (enum K ?i) (j, ?i) \\<lless> b (enum L ?p) (r, ?p)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> list.set (seqs j j K);\n        b \\<in> list.set (seqs r r L)\\<rbrakk>\n       \\<Longrightarrow> a < b \\<or> b < a", "show \"u < v \\<or> v < u\"\n          if \"u \\<in> list.set (seqs j j K)\" and \"v \\<in> list.set (seqs r r L)\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. u < v \\<or> v < u", "using that enumK enumL"], ["proof (prove)\nusing this:\n  u \\<in> list.set (seqs j j K)\n  v \\<in> list.set (seqs r r L)\n  ?i < j \\<Longrightarrow> j < enum K ?i\n  ?i < r \\<Longrightarrow> r < enum L ?i\n\ngoal (1 subgoal):\n 1. u < v \\<or> v < u", "apply (auto simp: seqs_def aj_ar intro!: less_bb less_sets_imp_list_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>i. i < j \\<Longrightarrow> j < enum K i;\n        \\<And>i. i < r \\<Longrightarrow> r < enum L i;\n        \\<not> b (enum L x) (r, x) \\<lless> a j; u = list_of (a j);\n        v = list_of (b (enum L x) (r, x)); x < r\\<rbrakk>\n       \\<Longrightarrow> a j \\<lless> b (enum L x) (r, x)\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i. i < j \\<Longrightarrow> j < enum K i;\n        \\<And>i. i < r \\<Longrightarrow> r < enum L i;\n        \\<not> a r \\<lless> b (enum K x) (j, x);\n        u = list_of (b (enum K x) (j, x)); x < j; v = list_of (a r)\\<rbrakk>\n       \\<Longrightarrow> b (enum K x) (j, x) \\<lless> a r", "apply (meson ab ba less_imp_le_nat not_le)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?u \\<in> list.set (seqs j j K);\n   ?v \\<in> list.set (seqs r r L)\\<rbrakk>\n  \\<Longrightarrow> ?u < ?v \\<or> ?v < ?u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>us vs. merge (seqs j j K) (seqs r r L) us vs\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  \\<exists>us vs. merge (seqs j j K) (seqs r r L) us vs", "obtain uus vvs where merge: \"merge (seqs j j K) (seqs r r L) uus vvs\""], ["proof (prove)\nusing this:\n  \\<exists>us vs. merge (seqs j j K) (seqs r r L) us vs\n\ngoal (1 subgoal):\n 1. (\\<And>uus vvs.\n        merge (seqs j j K) (seqs r r L) uus vvs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  merge (seqs j j K) (seqs r r L) uus vvs\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  merge (seqs j j K) (seqs r r L) uus vvs", "have \"uus \\<noteq> []\""], ["proof (prove)\nusing this:\n  merge (seqs j j K) (seqs r r L) uus vvs\n\ngoal (1 subgoal):\n 1. uus \\<noteq> []", "using merge_length1_gt_0"], ["proof (prove)\nusing this:\n  merge (seqs j j K) (seqs r r L) uus vvs\n  \\<lbrakk>merge ?as ?bs ?us ?vs; ?as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> 0 < length ?us\n\ngoal (1 subgoal):\n 1. uus \\<noteq> []", "by (auto simp: seqs_def)"], ["proof (state)\nthis:\n  uus \\<noteq> []\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  uus \\<noteq> []", "obtain u1 us where us: \"u1#us = uus\""], ["proof (prove)\nusing this:\n  uus \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>u1 us. u1 # us = uus \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis neq_Nil_conv)"], ["proof (state)\nthis:\n  u1 # us = uus\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "define ku where \"ku \\<equiv> length (u1#us)\""], ["proof (state)\nthis:\n  ku \\<equiv> length (u1 # us)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "define ps where \"ps \\<equiv> acc_lengths 0 (u1#us)\""], ["proof (state)\nthis:\n  ps \\<equiv> acc_lengths 0 (u1 # us)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have us_ne: \"u1#us \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 # us \\<in> lists (- {[]})", "using merge_length1_nonempty seqs_ne us merge us K"], ["proof (prove)\nusing this:\n  \\<lbrakk>merge ?as ?bs ?us ?vs; ?as \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> ?us \\<in> lists (- {[]})\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> seqs ?j0.0 ?j ?K \\<in> lists (- {[]})\n  u1 # us = uus\n  merge (seqs j j K) (seqs r r L) uus vvs\n  u1 # us = uus\n  K \\<in> \\<K> j j\n\ngoal (1 subgoal):\n 1. u1 # us \\<in> lists (- {[]})", "by auto"], ["proof (state)\nthis:\n  u1 # us \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have xu_eq: \"x = concat (u1#us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = concat (u1 # us)", "using BB_eq_concat_seqs K merge merge_preserves us xeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 ?j ?K = concat (seqs ?j0.0 ?j ?K)\n  K \\<in> \\<K> j j\n  merge (seqs j j K) (seqs r r L) uus vvs\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  concat ?as = concat ?us \\<and> concat ?bs = concat ?vs\n  u1 # us = uus\n  x = BB j j K\n\ngoal (1 subgoal):\n 1. x = concat (u1 # us)", "by auto"], ["proof (state)\nthis:\n  x = concat (u1 # us)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  x = concat (u1 # us)", "have \"strict_sorted u1\""], ["proof (prove)\nusing this:\n  x = concat (u1 # us)\n\ngoal (1 subgoal):\n 1. strict_sorted u1", "using \\<open>strict_sorted x\\<close> strict_sorted_append_iff"], ["proof (prove)\nusing this:\n  x = concat (u1 # us)\n  strict_sorted x\n  strict_sorted (?xs @ ?ys) =\n  (?xs < ?ys \\<and> strict_sorted ?xs \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. strict_sorted u1", "by auto"], ["proof (state)\nthis:\n  strict_sorted u1\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have u_sub: \"list.set ps \\<subseteq> list.set (acc_lengths 0 (seqs j j K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set ps \\<subseteq> list.set (acc_lengths 0 (seqs j j K))", "using acc_lengths_merge1 merge ps_def us"], ["proof (prove)\nusing this:\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  list.set (acc_lengths ?k ?us) \\<subseteq> list.set (acc_lengths ?k ?as)\n  merge (seqs j j K) (seqs r r L) uus vvs\n  ps \\<equiv> acc_lengths 0 (u1 # us)\n  u1 # us = uus\n\ngoal (1 subgoal):\n 1. list.set ps \\<subseteq> list.set (acc_lengths 0 (seqs j j K))", "by blast"], ["proof (state)\nthis:\n  list.set ps \\<subseteq> list.set (acc_lengths 0 (seqs j j K))\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have \"vvs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vvs \\<noteq> []", "using merge BB_eq_concat_seqs L merge_preserves xy yeq"], ["proof (prove)\nusing this:\n  merge (seqs j j K) (seqs r r L) uus vvs\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 ?j ?K = concat (seqs ?j0.0 ?j ?K)\n  L \\<in> \\<K> r r\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  concat ?as = concat ?us \\<and> concat ?bs = concat ?vs\n  length x < length y\n  y = BB r r L\n\ngoal (1 subgoal):\n 1. vvs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  vvs \\<noteq> []\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  vvs \\<noteq> []", "obtain v1 vs where vs: \"v1#vs = vvs\""], ["proof (prove)\nusing this:\n  vvs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>v1 vs. v1 # vs = vvs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis neq_Nil_conv)"], ["proof (state)\nthis:\n  v1 # vs = vvs\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "define kv where \"kv \\<equiv> length (v1#vs)\""], ["proof (state)\nthis:\n  kv \\<equiv> length (v1 # vs)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "define qs where \"qs \\<equiv> acc_lengths 0 (v1#vs)\""], ["proof (state)\nthis:\n  qs \\<equiv> acc_lengths 0 (v1 # vs)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have vs_ne: \"v1#vs \\<in> lists (- {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 # vs \\<in> lists (- {[]})", "using L merge merge_length2_nonempty seqs_ne vs"], ["proof (prove)\nusing this:\n  L \\<in> \\<K> r r\n  merge (seqs j j K) (seqs r r L) uus vvs\n  \\<lbrakk>merge ?as ?bs ?us ?vs; ?bs \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> ?vs \\<in> lists (- {[]})\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> seqs ?j0.0 ?j ?K \\<in> lists (- {[]})\n  v1 # vs = vvs\n\ngoal (1 subgoal):\n 1. v1 # vs \\<in> lists (- {[]})", "by auto"], ["proof (state)\nthis:\n  v1 # vs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have yv_eq: \"y = concat (v1#vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = concat (v1 # vs)", "using BB_eq_concat_seqs L merge merge_preserves vs yeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 ?j ?K = concat (seqs ?j0.0 ?j ?K)\n  L \\<in> \\<K> r r\n  merge (seqs j j K) (seqs r r L) uus vvs\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  concat ?as = concat ?us \\<and> concat ?bs = concat ?vs\n  v1 # vs = vvs\n  y = BB r r L\n\ngoal (1 subgoal):\n 1. y = concat (v1 # vs)", "by auto"], ["proof (state)\nthis:\n  y = concat (v1 # vs)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  y = concat (v1 # vs)", "have \"strict_sorted v1\""], ["proof (prove)\nusing this:\n  y = concat (v1 # vs)\n\ngoal (1 subgoal):\n 1. strict_sorted v1", "using \\<open>strict_sorted y\\<close> strict_sorted_append_iff"], ["proof (prove)\nusing this:\n  y = concat (v1 # vs)\n  strict_sorted y\n  strict_sorted (?xs @ ?ys) =\n  (?xs < ?ys \\<and> strict_sorted ?xs \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. strict_sorted v1", "by auto"], ["proof (state)\nthis:\n  strict_sorted v1\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have v_sub: \"list.set qs \\<subseteq> list.set (acc_lengths 0 (seqs r r L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set qs \\<subseteq> list.set (acc_lengths 0 (seqs r r L))", "using acc_lengths_merge2 merge qs_def vs"], ["proof (prove)\nusing this:\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  list.set (acc_lengths ?k ?vs) \\<subseteq> list.set (acc_lengths ?k ?bs)\n  merge (seqs j j K) (seqs r r L) uus vvs\n  qs \\<equiv> acc_lengths 0 (v1 # vs)\n  v1 # vs = vvs\n\ngoal (1 subgoal):\n 1. list.set qs \\<subseteq> list.set (acc_lengths 0 (seqs r r L))", "by blast"], ["proof (state)\nthis:\n  list.set qs \\<subseteq> list.set (acc_lengths 0 (seqs r r L))\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have ss_concat_jj: \"strict_sorted (concat (seqs j j K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (concat (seqs j j K))", "using BB_eq_concat_seqs K \\<open>strict_sorted x\\<close> xeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> BB ?j0.0 ?j ?K = concat (seqs ?j0.0 ?j ?K)\n  K \\<in> \\<K> j j\n  strict_sorted x\n  x = BB j j K\n\ngoal (1 subgoal):\n 1. strict_sorted (concat (seqs j j K))", "by auto"], ["proof (state)\nthis:\n  strict_sorted (concat (seqs j j K))\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  strict_sorted (concat (seqs j j K))", "obtain k: \"0 < kv\" \"kv \\<le> ku\" \"ku \\<le> Suc kv\" \"kv \\<le> Suc j\""], ["proof (prove)\nusing this:\n  strict_sorted (concat (seqs j j K))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 < kv; kv \\<le> ku; ku \\<le> Suc kv; kv \\<le> Suc j\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using us vs merge_length_le merge_length_le_Suc merge_length_less2 merge"], ["proof (prove)\nusing this:\n  strict_sorted (concat (seqs j j K))\n  u1 # us = uus\n  v1 # vs = vvs\n  merge ?as ?bs ?us ?vs \\<Longrightarrow> length ?vs \\<le> length ?us\n  merge ?as ?bs ?us ?vs \\<Longrightarrow> length ?us \\<le> Suc (length ?vs)\n  merge ?as ?bs ?us ?vs \\<Longrightarrow> length ?vs \\<le> length ?as\n  merge (seqs j j K) (seqs r r L) uus vvs\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 < kv; kv \\<le> ku; ku \\<le> Suc kv; kv \\<le> Suc j\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ku_def kv_def"], ["proof (prove)\nusing this:\n  strict_sorted (concat (seqs j j K))\n  u1 # us = uus\n  v1 # vs = vvs\n  merge ?as ?bs ?us ?vs \\<Longrightarrow> length ?vs \\<le> length ?us\n  merge ?as ?bs ?us ?vs \\<Longrightarrow> length ?us \\<le> Suc (length ?vs)\n  merge ?as ?bs ?us ?vs \\<Longrightarrow> length ?vs \\<le> length ?as\n  merge (seqs j j K) (seqs r r L) uus vvs\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 < length (v1 # vs); length (v1 # vs) \\<le> length (u1 # us);\n      length (u1 # us) \\<le> Suc (length (v1 # vs));\n      length (v1 # vs) \\<le> Suc j\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  0 < kv\n  kv \\<le> ku\n  ku \\<le> Suc kv\n  kv \\<le> Suc j\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "define zs where \"zs \\<equiv> concat [ps,u1,qs,v1] @ interact us vs\""], ["proof (state)\nthis:\n  zs \\<equiv> concat [ps, u1, qs, v1] @ interact us vs\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have ss: \"strict_sorted zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted zs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. strict_sorted zs", "have ssp: \"strict_sorted ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted ps", "unfolding ps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (acc_lengths 0 (u1 # us))", "by (meson strict_sorted_acc_lengths us_ne)"], ["proof (state)\nthis:\n  strict_sorted ps\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have ssq: \"strict_sorted qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted qs", "unfolding qs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (acc_lengths 0 (v1 # vs))", "by (meson strict_sorted_acc_lengths vs_ne)"], ["proof (state)\nthis:\n  strict_sorted qs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"d j \\<lless> list.set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d j \\<lless> list.set x", "using da [of j] db [of j]  K \\<K>_card \\<K>_enum nat_less_le"], ["proof (prove)\nusing this:\n  d j \\<lless> a j\n  j \\<le> ?k \\<Longrightarrow> d j \\<lless> b ?k (j, ?i)\n  K \\<in> \\<K> j j\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?i < card ?K\\<rbrakk>\n  \\<Longrightarrow> ?j0.0 < enum ?K ?i\n  (?m < ?n) = (?m \\<le> ?n \\<and> ?m \\<noteq> ?n)\n\ngoal (1 subgoal):\n 1. d j \\<lless> list.set x", "by (auto simp: xeq BB_def less_sets_Un2 less_sets_UN2)"], ["proof (state)\nthis:\n  d j \\<lless> list.set x\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  d j \\<lless> list.set x", "have ac_x: \"acc_lengths 0 (seqs j j K) < x\""], ["proof (prove)\nusing this:\n  d j \\<lless> list.set x\n\ngoal (1 subgoal):\n 1. acc_lengths 0 (seqs j j K) < x", "by (meson Ksub \\<open>finite K\\<close> \\<open>j \\<le> card K\\<close> acc_lengths_subset_d dual_order.refl less_sets_imp_list_less less_sets_weaken1)"], ["proof (state)\nthis:\n  acc_lengths 0 (seqs j j K) < x\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  acc_lengths 0 (seqs j j K) < x", "have \"ps < u1\""], ["proof (prove)\nusing this:\n  acc_lengths 0 (seqs j j K) < x\n\ngoal (1 subgoal):\n 1. ps < u1", "by (metis K Ksub UnI1 \\<K>_card \\<open>finite K\\<close> \\<open>j \\<le> card K\\<close> \\<open>d j \\<lless> list.set x\\<close> acc_lengths_subset_d concat.simps(2) empty_iff empty_set hd_append2 less_list_def less_sets_imp_list_less less_sets_weaken1 list.set_sel(1) set_append u_sub xu_eq)"], ["proof (state)\nthis:\n  ps < u1\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"d r \\<lless> list.set y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d r \\<lless> list.set y", "using da [of r] db [of r]  L \\<K>_card \\<K>_enum nat_less_le"], ["proof (prove)\nusing this:\n  d r \\<lless> a r\n  r \\<le> ?k \\<Longrightarrow> d r \\<lless> b ?k (r, ?i)\n  L \\<in> \\<K> r r\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?i < card ?K\\<rbrakk>\n  \\<Longrightarrow> ?j0.0 < enum ?K ?i\n  (?m < ?n) = (?m \\<le> ?n \\<and> ?m \\<noteq> ?n)\n\ngoal (1 subgoal):\n 1. d r \\<lless> list.set y", "by (auto simp: yeq BB_def less_sets_Un2 less_sets_UN2)"], ["proof (state)\nthis:\n  d r \\<lless> list.set y\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  d r \\<lless> list.set y", "have \"acc_lengths 0 (seqs r r L) < y\""], ["proof (prove)\nusing this:\n  d r \\<lless> list.set y\n\ngoal (1 subgoal):\n 1. acc_lengths 0 (seqs r r L) < y", "by (meson Lsub \\<open>finite L\\<close> \\<open>r \\<le> card L\\<close> acc_lengths_subset_d dual_order.refl less_sets_imp_list_less less_sets_weaken1)"], ["proof (state)\nthis:\n  acc_lengths 0 (seqs r r L) < y\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  acc_lengths 0 (seqs r r L) < y", "have \"qs < v1\""], ["proof (prove)\nusing this:\n  acc_lengths 0 (seqs r r L) < y\n\ngoal (1 subgoal):\n 1. qs < v1", "by (metis L Lsub UnI1 \\<K>_card \\<open>finite L\\<close> \\<open>r \\<le> card L\\<close> \\<open>d r \\<lless> list.set y\\<close> acc_lengths_subset_d concat.simps(2) empty_iff empty_set hd_append2 less_list_def less_sets_imp_list_less less_sets_weaken1 list.set_sel(1) set_append v_sub yv_eq)"], ["proof (state)\nthis:\n  qs < v1\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have carda_v1: \"card (a r) \\<le> length v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (a r) \\<le> length v1", "using length_hd_merge2 [OF merge]"], ["proof (prove)\nusing this:\n  length (hd (seqs r r L)) \\<le> length (hd vvs)\n\ngoal (1 subgoal):\n 1. card (a r) \\<le> length v1", "unfolding vs [symmetric]"], ["proof (prove)\nusing this:\n  length (hd (seqs r r L)) \\<le> length (hd (v1 # vs))\n\ngoal (1 subgoal):\n 1. card (a r) \\<le> length v1", "by (simp add: seqs_def)"], ["proof (state)\nthis:\n  card (a r) \\<le> length v1\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have ab_enumK: \"\\<And>i. i < j \\<Longrightarrow> a j \\<lless> b (enum K i) (j,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < j \\<Longrightarrow> a j \\<lless> b (enum K i) (j, i)", "by (meson ab enumK le_trans less_imp_le_nat)"], ["proof (state)\nthis:\n  ?i < j \\<Longrightarrow> a j \\<lless> b (enum K ?i) (j, ?i)\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have ab_enumL: \"\\<And>q. q < r \\<Longrightarrow> a j \\<lless> b (enum L q) (r,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. q < r \\<Longrightarrow> a j \\<lless> b (enum L q) (r, q)", "by (meson \\<open>j < r\\<close> ab enumL le_trans less_imp_le_nat)"], ["proof (state)\nthis:\n  ?q < r \\<Longrightarrow> a j \\<lless> b (enum L ?q) (r, ?q)\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  ?q < r \\<Longrightarrow> a j \\<lless> b (enum L ?q) (r, ?q)", "have ay: \"a j \\<lless> list.set y\""], ["proof (prove)\nusing this:\n  ?q < r \\<Longrightarrow> a j \\<lless> b (enum L ?q) (r, ?q)\n\ngoal (1 subgoal):\n 1. a j \\<lless> list.set y", "by (auto simp: yeq BB_def less_sets_Un2 less_sets_UN2 aj_ar)"], ["proof (state)\nthis:\n  a j \\<lless> list.set y\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have disjnt_hd_last_K_y: \"disjnt {hd l..last l} (list.set y)\"\n          if l: \"l \\<in> list.set (seqs j j K)\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt {hd l..last l} (list.set y)", "proof (clarsimp simp add: yeq BB_def disjnt_iff Ball_def, intro conjI strip)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> a r\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x; xa < r\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b (enum L xa) (r, xa)", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> a r\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x; xa < r\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b (enum L xa) (r, xa)", "assume u: \"u \\<le> last l\" and \"hd l \\<le> u\""], ["proof (state)\nthis:\n  u \\<le> last l\n  hd l \\<le> u\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> a r\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x; xa < r\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b (enum L xa) (r, xa)", "with l"], ["proof (chain)\npicking this:\n  l \\<in> list.set (seqs j j K)\n  u \\<le> last l\n  hd l \\<le> u", "consider \"u \\<le> last (list_of (a j))\" \"hd (list_of (a j)) \\<le> u\"\n            | i where \"i<j\" \"u \\<le> last (list_of (b (enum K i) (j,i)))\" \"hd (list_of (b (enum K i) (j,i))) \\<le> u\""], ["proof (prove)\nusing this:\n  l \\<in> list.set (seqs j j K)\n  u \\<le> last l\n  hd l \\<le> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>u \\<le> last (list_of (a j));\n              hd (list_of (a j)) \\<le> u\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>i.\n        \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n         hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (force simp: seqs_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>u \\<le> last (list_of (a j));\n            hd (list_of (a j)) \\<le> u\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>i.\n      \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n       hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> a r\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x; xa < r\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b (enum L xa) (r, xa)", "note l_cases = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>u \\<le> last (list_of (a j));\n            hd (list_of (a j)) \\<le> u\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>i.\n      \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n       hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> a r\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x; xa < r\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b (enum L xa) (r, xa)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>u \\<le> last (list_of (a j));\n            hd (list_of (a j)) \\<le> u\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>i.\n      \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n       hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"u \\<notin> a r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>u \\<le> last (list_of (a j));\n            hd (list_of (a j)) \\<le> u\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>i.\n      \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n       hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. u \\<notin> a r", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<le> last (list_of (a j));\n     hd (list_of (a j)) \\<le> u\\<rbrakk>\n    \\<Longrightarrow> u \\<notin> a r\n 2. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> a r", "case 1"], ["proof (state)\nthis:\n  u \\<le> last (list_of (a j))\n  hd (list_of (a j)) \\<le> u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<le> last (list_of (a j));\n     hd (list_of (a j)) \\<le> u\\<rbrakk>\n    \\<Longrightarrow> u \\<notin> a r\n 2. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> a r", "then"], ["proof (chain)\npicking this:\n  u \\<le> last (list_of (a j))\n  hd (list_of (a j)) \\<le> u", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<le> last (list_of (a j))\n  hd (list_of (a j)) \\<le> u\n\ngoal (1 subgoal):\n 1. u \\<notin> a r", "by (metis a_ne aj_ar finite_a last_in_set leD less_setsD set_sorted_list_of_set sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  u \\<notin> a r\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> a r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> a r", "case 2"], ["proof (state)\nthis:\n  i < j\n  u \\<le> last (list_of (b (enum K i) (j, i)))\n  hd (list_of (b (enum K i) (j, i))) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> a r", "then"], ["proof (chain)\npicking this:\n  i < j\n  u \\<le> last (list_of (b (enum K i) (j, i)))\n  hd (list_of (b (enum K i) (j, i))) \\<le> u", "show ?thesis"], ["proof (prove)\nusing this:\n  i < j\n  u \\<le> last (list_of (b (enum K i) (j, i)))\n  hd (list_of (b (enum K i) (j, i))) \\<le> u\n\ngoal (1 subgoal):\n 1. u \\<notin> a r", "by (metis enumK ab ba Inf_nat_def1 b_ne card_b_finite hd_b last_in_set less_asym less_setsD not_le set_sorted_list_of_set sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  u \\<notin> a r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<notin> a r\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x; xa < r\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b (enum L xa) (r, xa)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x; xa < r\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b (enum L xa) (r, xa)", "assume \"q < r\""], ["proof (state)\nthis:\n  q < r\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<le> last l; hd l \\<le> x; xa < r\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b (enum L xa) (r, xa)", "show \"u \\<notin> b (enum L q) (r,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> b (enum L q) (r, q)", "using l_cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>u \\<le> last (list_of (a j));\n            hd (list_of (a j)) \\<le> u\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>i.\n      \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n       hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. u \\<notin> b (enum L q) (r, q)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<le> last (list_of (a j));\n     hd (list_of (a j)) \\<le> u\\<rbrakk>\n    \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)\n 2. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)", "case 1"], ["proof (state)\nthis:\n  u \\<le> last (list_of (a j))\n  hd (list_of (a j)) \\<le> u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<le> last (list_of (a j));\n     hd (list_of (a j)) \\<le> u\\<rbrakk>\n    \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)\n 2. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)", "then"], ["proof (chain)\npicking this:\n  u \\<le> last (list_of (a j))\n  hd (list_of (a j)) \\<le> u", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<le> last (list_of (a j))\n  hd (list_of (a j)) \\<le> u\n\ngoal (1 subgoal):\n 1. u \\<notin> b (enum L q) (r, q)", "by (metis \\<open>q < r\\<close> a_ne ab_enumL finite_a last_in_set leD less_setsD set_sorted_list_of_set sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  u \\<notin> b (enum L q) (r, q)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)", "case 2"], ["proof (state)\nthis:\n  i < j\n  u \\<le> last (list_of (b (enum K i) (j, i)))\n  hd (list_of (b (enum K i) (j, i))) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < j; u \\<le> last (list_of (b (enum K i) (j, i)));\n        hd (list_of (b (enum K i) (j, i))) \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> b (enum L q) (r, q)", "proof (cases \"enum K i = enum L q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. enum K i = enum L q \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)\n 2. enum K i \\<noteq> enum L q \\<Longrightarrow>\n    u \\<notin> b (enum L q) (r, q)", "case True"], ["proof (state)\nthis:\n  enum K i = enum L q\n\ngoal (2 subgoals):\n 1. enum K i = enum L q \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)\n 2. enum K i \\<noteq> enum L q \\<Longrightarrow>\n    u \\<notin> b (enum L q) (r, q)", "then"], ["proof (chain)\npicking this:\n  enum K i = enum L q", "show ?thesis"], ["proof (prove)\nusing this:\n  enum K i = enum L q\n\ngoal (1 subgoal):\n 1. u \\<notin> b (enum L q) (r, q)", "using 2 bb_same [of concl: \"enum L q\" j i r q] \\<open>j < r\\<close>"], ["proof (prove)\nusing this:\n  enum K i = enum L q\n  i < j\n  u \\<le> last (list_of (b (enum K i) (j, i)))\n  hd (list_of (b (enum K i) (j, i))) \\<le> u\n  \\<lbrakk>((j, i), r, q) \\<in> pair_less;\n   (j, i) \\<in> IJ (enum L q)\\<rbrakk>\n  \\<Longrightarrow> b (enum L q) (j, i) \\<lless> b (enum L q) (r, q)\n  j < r\n\ngoal (1 subgoal):\n 1. u \\<notin> b (enum L q) (r, q)", "apply (simp add: IJ_def pair_less_def less_sets_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enum K i = enum L q; i < j;\n     u \\<le> last (list_of (b (enum L q) (j, i)));\n     hd (list_of (b (enum L q) (j, i))) \\<le> u;\n     j \\<le> enum L q \\<Longrightarrow>\n     \\<forall>x\\<in>b (enum L q) (j, i).\n        \\<forall>xa\\<in>b (enum L q) (r, q). x < xa;\n     j < r\\<rbrakk>\n    \\<Longrightarrow> u \\<notin> b (enum L q) (r, q)", "by (metis enumK b_ne card_b_finite last_in_set leD less_imp_le_nat set_sorted_list_of_set sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  u \\<notin> b (enum L q) (r, q)\n\ngoal (1 subgoal):\n 1. enum K i \\<noteq> enum L q \\<Longrightarrow>\n    u \\<notin> b (enum L q) (r, q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. enum K i \\<noteq> enum L q \\<Longrightarrow>\n    u \\<notin> b (enum L q) (r, q)", "case False"], ["proof (state)\nthis:\n  enum K i \\<noteq> enum L q\n\ngoal (1 subgoal):\n 1. enum K i \\<noteq> enum L q \\<Longrightarrow>\n    u \\<notin> b (enum L q) (r, q)", "with 2 bb enumK enumL"], ["proof (chain)\npicking this:\n  i < j\n  u \\<le> last (list_of (b (enum K i) (j, i)))\n  hd (list_of (b (enum K i) (j, i))) \\<le> u\n  \\<lbrakk>?i' < ?j'; ?j' \\<le> ?k'; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k' (?j', ?i') \\<lless> b ?k (?j, ?i)\n  ?i < j \\<Longrightarrow> j < enum K ?i\n  ?i < r \\<Longrightarrow> r < enum L ?i\n  enum K i \\<noteq> enum L q", "show ?thesis"], ["proof (prove)\nusing this:\n  i < j\n  u \\<le> last (list_of (b (enum K i) (j, i)))\n  hd (list_of (b (enum K i) (j, i))) \\<le> u\n  \\<lbrakk>?i' < ?j'; ?j' \\<le> ?k'; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> b ?k' (?j', ?i') \\<lless> b ?k (?j, ?i)\n  ?i < j \\<Longrightarrow> j < enum K ?i\n  ?i < r \\<Longrightarrow> r < enum L ?i\n  enum K i \\<noteq> enum L q\n\ngoal (1 subgoal):\n 1. u \\<notin> b (enum L q) (r, q)", "unfolding less_sets_def"], ["proof (prove)\nusing this:\n  i < j\n  u \\<le> last (list_of (b (enum K i) (j, i)))\n  hd (list_of (b (enum K i) (j, i))) \\<le> u\n  \\<lbrakk>?i' < ?j'; ?j' \\<le> ?k'; ?k' < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>b ?k' (?j', ?i').\n                       \\<forall>y\\<in>b ?k (?j, ?i). x < y\n  ?i < j \\<Longrightarrow> j < enum K ?i\n  ?i < r \\<Longrightarrow> r < enum L ?i\n  enum K i \\<noteq> enum L q\n\ngoal (1 subgoal):\n 1. u \\<notin> b (enum L q) (r, q)", "by (metis \\<open>q < r\\<close> b_ne card_b_finite last_in_set leD less_imp_le_nat list.set_sel(1) nat_neq_iff set_sorted_list_of_set sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  u \\<notin> b (enum L q) (r, q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<notin> b (enum L q) (r, q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<notin> b (enum L q) (r, q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?l \\<in> list.set (seqs j j K) \\<Longrightarrow>\n  disjnt {hd ?l..last ?l} (list.set y)\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have u1_y: \"list.set u1 \\<lless> list.set y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set u1 \\<lless> list.set y", "using vs yv_eq L \\<open>strict_sorted y\\<close> merge merge_less_sets_hd merge_preserves seqs_ne ss_concat_jj us"], ["proof (prove)\nusing this:\n  v1 # vs = vvs\n  y = concat (v1 # vs)\n  L \\<in> \\<K> r r\n  strict_sorted y\n  merge (seqs j j K) (seqs r r L) uus vvs\n  \\<lbrakk>merge ?as ?bs ?us ?vs; strict_sorted (concat ?as);\n   strict_sorted (concat ?bs); ?bs \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> list.set (hd ?us) \\<lless> list.set (concat ?vs)\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  concat ?as = concat ?us \\<and> concat ?bs = concat ?vs\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> seqs ?j0.0 ?j ?K \\<in> lists (- {[]})\n  strict_sorted (concat (seqs j j K))\n  u1 # us = uus\n\ngoal (1 subgoal):\n 1. list.set u1 \\<lless> list.set y", "by fastforce"], ["proof (state)\nthis:\n  list.set u1 \\<lless> list.set y\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have u1_subset_seqs: \"list.set u1 \\<subseteq> list.set (concat (seqs j j K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set u1 \\<subseteq> list.set (concat (seqs j j K))", "using merge_preserves [OF merge] us"], ["proof (prove)\nusing this:\n  concat (seqs j j K) = concat uus \\<and> concat (seqs r r L) = concat vvs\n  u1 # us = uus\n\ngoal (1 subgoal):\n 1. list.set u1 \\<subseteq> list.set (concat (seqs j j K))", "by auto"], ["proof (state)\nthis:\n  list.set u1 \\<subseteq> list.set (concat (seqs j j K))\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"b k (j,i) \\<lless> d (Suc k)\" if \"j\\<le>k\" \"i<j\" for k j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> d (Suc k)", "by (metis bM d_eq less_sets_fst_grab less_sets_weaken2 nxt_subset that)"], ["proof (state)\nthis:\n  \\<lbrakk>?j \\<le> ?k; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> d (Suc ?k)\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j \\<le> ?k; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> d (Suc ?k)", "have bd: \"b k (j,i) \\<lless> d k'\" if \"j\\<le>k\" \"i<j\" \"k < k'\" for k k' j i"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j \\<le> ?k; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> d (Suc ?k)\n\ngoal (1 subgoal):\n 1. b k (j, i) \\<lless> d k'", "by (metis Suc_lessI d_ne dd less_sets_trans that)"], ["proof (state)\nthis:\n  \\<lbrakk>?j \\<le> ?k; ?i < ?j; ?k < ?k'\\<rbrakk>\n  \\<Longrightarrow> b ?k (?j, ?i) \\<lless> d ?k'\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"a k \\<lless> d (Suc k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. a k \\<lless> d (Suc k)", "by (metis aM d_eq less_sets_fst_grab less_sets_weaken2 nxt_subset)"], ["proof (state)\nthis:\n  a ?k \\<lless> d (Suc ?k)\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  a ?k \\<lless> d (Suc ?k)", "have ad: \"a k \\<lless> d k'\" if \"k<k'\" for k k'"], ["proof (prove)\nusing this:\n  a ?k \\<lless> d (Suc ?k)\n\ngoal (1 subgoal):\n 1. a k \\<lless> d k'", "by (metis Suc_lessI d_ne dd less_sets_trans that)"], ["proof (state)\nthis:\n  ?k < ?k' \\<Longrightarrow> a ?k \\<lless> d ?k'\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"u1 < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 < y", "by (simp add: u1_y less_sets_imp_list_less)"], ["proof (state)\nthis:\n  u1 < y\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"n < Inf (d r)\" if n: \"n \\<in> list.set u1\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (d r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (d r)", "obtain l where l: \"l \\<in> list.set (seqs j j K)\" and n: \"n \\<in> list.set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> list.set (seqs j j K); n \\<in> list.set l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using n u1_subset_seqs"], ["proof (prove)\nusing this:\n  n \\<in> list.set u1\n  list.set u1 \\<subseteq> list.set (concat (seqs j j K))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> list.set (seqs j j K); n \\<in> list.set l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l \\<in> list.set (seqs j j K)\n  n \\<in> list.set l\n\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (d r)", "then"], ["proof (chain)\npicking this:\n  l \\<in> list.set (seqs j j K)\n  n \\<in> list.set l", "consider \"l = list_of (a j)\" | i where \"l = list_of (b (enum K i) (j,i))\" \"i < j\""], ["proof (prove)\nusing this:\n  l \\<in> list.set (seqs j j K)\n  n \\<in> list.set l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = list_of (a j) \\<Longrightarrow> thesis;\n     \\<And>i.\n        \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (force simp: seqs_def)"], ["proof (state)\nthis:\n  \\<lbrakk>l = list_of (a j) \\<Longrightarrow> ?thesis;\n   \\<And>i.\n      \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (d r)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>l = list_of (a j) \\<Longrightarrow> ?thesis;\n   \\<And>i.\n      \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>l = list_of (a j) \\<Longrightarrow> ?thesis;\n   \\<And>i.\n      \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (d r)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. l = list_of (a j) \\<Longrightarrow> n < \\<Sqinter> (d r)\n 2. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "case 1"], ["proof (state)\nthis:\n  l = list_of (a j)\n\ngoal (2 subgoals):\n 1. l = list_of (a j) \\<Longrightarrow> n < \\<Sqinter> (d r)\n 2. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "then"], ["proof (chain)\npicking this:\n  l = list_of (a j)", "show ?thesis"], ["proof (prove)\nusing this:\n  l = list_of (a j)\n\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (d r)", "by (metis Inf_nat_def1 \\<open>j < r\\<close> ad d_ne finite_a less_setsD n set_sorted_list_of_set)"], ["proof (state)\nthis:\n  n < \\<Sqinter> (d r)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "case 2"], ["proof (state)\nthis:\n  l = list_of (b (enum K i) (j, i))\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "then"], ["proof (chain)\npicking this:\n  l = list_of (b (enum K i) (j, i))\n  i < j", "have \"Min (b (enum K i) (j,i)) \\<le> n\""], ["proof (prove)\nusing this:\n  l = list_of (b (enum K i) (j, i))\n  i < j\n\ngoal (1 subgoal):\n 1. Min (b (enum K i) (j, i)) \\<le> n", "using n"], ["proof (prove)\nusing this:\n  l = list_of (b (enum K i) (j, i))\n  i < j\n  n \\<in> list.set l\n\ngoal (1 subgoal):\n 1. Min (b (enum K i) (j, i)) \\<le> n", "by (simp add: less_list_def disjnt_iff less_sets_def)"], ["proof (state)\nthis:\n  Min (b (enum K i) (j, i)) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "also"], ["proof (state)\nthis:\n  Min (b (enum K i) (j, i)) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "have f8: \"n < hd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < hd y", "using less_setsD that u1_y"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<lless> ?B; ?a \\<in> ?A; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n  n \\<in> list.set u1\n  list.set u1 \\<lless> list.set y\n\ngoal (1 subgoal):\n 1. n < hd y", "by (metis gr_implies_not0 list.set_sel(1) list.size(3) xy)"], ["proof (state)\nthis:\n  n < hd y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "finally"], ["proof (chain)\npicking this:\n  Min (b (enum K i) (j, i)) < hd y", "have \"l < y\""], ["proof (prove)\nusing this:\n  Min (b (enum K i) (j, i)) < hd y\n\ngoal (1 subgoal):\n 1. l < y", "using 2 disjnt_hd_last_K_y [OF l] u1_y"], ["proof (prove)\nusing this:\n  Min (b (enum K i) (j, i)) < hd y\n  l = list_of (b (enum K i) (j, i))\n  i < j\n  disjnt {hd l..last l} (list.set y)\n  list.set u1 \\<lless> list.set y\n\ngoal (1 subgoal):\n 1. l < y", "apply (simp add: less_list_def disjnt_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Min (b (enum K i) (j, i)) < hd y;\n     l = list_of (b (enum K i) (j, i)); i < j;\n     \\<forall>x\\<le>last (list_of (b (enum K i) (j, i))).\n        hd (list_of (b (enum K i) (j, i))) \\<le> x \\<longrightarrow>\n        x \\<notin> list.set y;\n     list.set u1 \\<lless> list.set y\\<rbrakk>\n    \\<Longrightarrow> b (enum K i) (j, i) \\<noteq> {} \\<and>\n                      y \\<noteq> [] \\<longrightarrow>\n                      last (list_of (b (enum K i) (j, i))) < hd y", "by (metis card_b_finite hd_list_of leI less_imp_le_nat list.set_sel(1))"], ["proof (state)\nthis:\n  l < y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "moreover"], ["proof (state)\nthis:\n  l < y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "have \"last (list_of (b (enum K i) (j,i))) < hd (list_of (a r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (list_of (b (enum K i) (j, i))) < hd (list_of (a r))", "using \\<open>l < y\\<close> L n"], ["proof (prove)\nusing this:\n  l < y\n  L \\<in> \\<K> r r\n  n \\<in> list.set l\n\ngoal (1 subgoal):\n 1. last (list_of (b (enum K i) (j, i))) < hd (list_of (a r))", "by (auto simp:  2yeq BB_eq_concat_seqs seqs_def less_list_def)"], ["proof (state)\nthis:\n  last (list_of (b (enum K i) (j, i))) < hd (list_of (a r))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "then"], ["proof (chain)\npicking this:\n  last (list_of (b (enum K i) (j, i))) < hd (list_of (a r))", "have \"enum K i < r\""], ["proof (prove)\nusing this:\n  last (list_of (b (enum K i) (j, i))) < hd (list_of (a r))\n\ngoal (1 subgoal):\n 1. enum K i < r", "by (metis \"2\"(1) a_ne ab card_b_finite empty_iff finite.emptyI finite_a last_in_set leI less_asym less_setsD list.set_sel(1) n set_sorted_list_of_set)"], ["proof (state)\nthis:\n  enum K i < r\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "moreover"], ["proof (state)\nthis:\n  enum K i < r\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "have \"j \\<le> enum K i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> enum K i", "by (simp add: \"2\"(2) enumK less_imp_le_nat)"], ["proof (state)\nthis:\n  j \\<le> enum K i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l = list_of (b (enum K i) (j, i)); i < j\\<rbrakk>\n       \\<Longrightarrow> n < \\<Sqinter> (d r)", "ultimately"], ["proof (chain)\npicking this:\n  l < y\n  enum K i < r\n  j \\<le> enum K i", "show ?thesis"], ["proof (prove)\nusing this:\n  l < y\n  enum K i < r\n  j \\<le> enum K i\n\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (d r)", "using 2 n bd [of j \"enum K i\" i r] Inf_nat_def1 less_setsD"], ["proof (prove)\nusing this:\n  l < y\n  enum K i < r\n  j \\<le> enum K i\n  l = list_of (b (enum K i) (j, i))\n  i < j\n  n \\<in> list.set l\n  \\<lbrakk>j \\<le> enum K i; i < j; enum K i < r\\<rbrakk>\n  \\<Longrightarrow> b (enum K i) (j, i) \\<lless> d r\n  ?K \\<noteq> {} \\<Longrightarrow> \\<Sqinter> ?K \\<in> ?K\n  \\<lbrakk>?A \\<lless> ?B; ?a \\<in> ?A; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. n < \\<Sqinter> (d r)", "by force"], ["proof (state)\nthis:\n  n < \\<Sqinter> (d r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < \\<Sqinter> (d r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?n \\<in> list.set u1 \\<Longrightarrow> ?n < \\<Sqinter> (d r)\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  ?n \\<in> list.set u1 \\<Longrightarrow> ?n < \\<Sqinter> (d r)", "have \"last u1 < Inf (d r)\""], ["proof (prove)\nusing this:\n  ?n \\<in> list.set u1 \\<Longrightarrow> ?n < \\<Sqinter> (d r)\n\ngoal (1 subgoal):\n 1. last u1 < \\<Sqinter> (d r)", "using \\<open>uus \\<noteq> []\\<close> us_ne"], ["proof (prove)\nusing this:\n  ?n \\<in> list.set u1 \\<Longrightarrow> ?n < \\<Sqinter> (d r)\n  uus \\<noteq> []\n  u1 # us \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. last u1 < \\<Sqinter> (d r)", "by auto"], ["proof (state)\nthis:\n  last u1 < \\<Sqinter> (d r)\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "also"], ["proof (state)\nthis:\n  last u1 < \\<Sqinter> (d r)\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"\\<dots> \\<le> length v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (d r) \\<le> length v1", "using card_a carda_v1"], ["proof (prove)\nusing this:\n  card (a ?k) = \\<Sqinter> (d ?k)\n  card (a r) \\<le> length v1\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (d r) \\<le> length v1", "by auto"], ["proof (state)\nthis:\n  \\<Sqinter> (d r) \\<le> length v1\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "finally"], ["proof (chain)\npicking this:\n  last u1 < length v1", "have \"last u1 < length v1\""], ["proof (prove)\nusing this:\n  last u1 < length v1\n\ngoal (1 subgoal):\n 1. last u1 < length v1", "."], ["proof (state)\nthis:\n  last u1 < length v1\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  last u1 < length v1", "have \"u1 < qs\""], ["proof (prove)\nusing this:\n  last u1 < length v1\n\ngoal (1 subgoal):\n 1. u1 < qs", "by (simp add: qs_def acc_lengths.simps less_list_def)"], ["proof (state)\nthis:\n  u1 < qs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"strict_sorted (interact (u1#us) (v1#vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (interact (u1 # us) (v1 # vs))", "using L \\<open>strict_sorted x\\<close> \\<open>strict_sorted y\\<close> merge merge_interact merge_preserves seqs_ne us vs xu_eq yv_eq"], ["proof (prove)\nusing this:\n  L \\<in> \\<K> r r\n  strict_sorted x\n  strict_sorted y\n  merge (seqs j j K) (seqs r r L) uus vvs\n  \\<lbrakk>merge ?as ?bs ?us ?vs; strict_sorted (concat ?as);\n   strict_sorted (concat ?bs); ?bs \\<in> lists (- {[]})\\<rbrakk>\n  \\<Longrightarrow> strict_sorted (interact ?us ?vs)\n  merge ?as ?bs ?us ?vs \\<Longrightarrow>\n  concat ?as = concat ?us \\<and> concat ?bs = concat ?vs\n  \\<lbrakk>?K \\<in> \\<K> ?j0.0 ?j; ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> seqs ?j0.0 ?j ?K \\<in> lists (- {[]})\n  u1 # us = uus\n  v1 # vs = vvs\n  x = concat (u1 # us)\n  y = concat (v1 # vs)\n\ngoal (1 subgoal):\n 1. strict_sorted (interact (u1 # us) (v1 # vs))", "by auto"], ["proof (state)\nthis:\n  strict_sorted (interact (u1 # us) (v1 # vs))\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "then"], ["proof (chain)\npicking this:\n  strict_sorted (interact (u1 # us) (v1 # vs))", "have \"strict_sorted (interact us vs)\" \"v1 < interact us vs\""], ["proof (prove)\nusing this:\n  strict_sorted (interact (u1 # us) (v1 # vs))\n\ngoal (1 subgoal):\n 1. strict_sorted (interact us vs) &&& v1 < interact us vs", "by (auto simp: strict_sorted_append_iff)"], ["proof (state)\nthis:\n  strict_sorted (interact us vs)\n  v1 < interact us vs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "moreover"], ["proof (state)\nthis:\n  strict_sorted (interact us vs)\n  v1 < interact us vs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"ps < u1 @ qs @ v1 @ interact us vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps < u1 @ qs @ v1 @ interact us vs", "using \\<open>ps < u1\\<close> us_ne"], ["proof (prove)\nusing this:\n  ps < u1\n  u1 # us \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. ps < u1 @ qs @ v1 @ interact us vs", "unfolding less_list_def"], ["proof (prove)\nusing this:\n  ps \\<noteq> [] \\<and> u1 \\<noteq> [] \\<longrightarrow> last ps < hd u1\n  u1 # us \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. ps \\<noteq> [] \\<and>\n    u1 @ qs @ v1 @ interact us vs \\<noteq> [] \\<longrightarrow>\n    last ps < hd (u1 @ qs @ v1 @ interact us vs)", "by auto"], ["proof (state)\nthis:\n  ps < u1 @ qs @ v1 @ interact us vs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "moreover"], ["proof (state)\nthis:\n  ps < u1 @ qs @ v1 @ interact us vs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"u1 < qs @ v1 @ interact us vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 < qs @ v1 @ interact us vs", "by (metis \\<open>u1 < qs\\<close> \\<open>vvs \\<noteq> []\\<close> acc_lengths_eq_Nil_iff hd_append less_list_def qs_def vs)"], ["proof (state)\nthis:\n  u1 < qs @ v1 @ interact us vs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "moreover"], ["proof (state)\nthis:\n  u1 < qs @ v1 @ interact us vs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "have \"qs < v1 @ interact us vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs < v1 @ interact us vs", "using \\<open>qs < v1\\<close> us_ne \\<open>last u1 < length v1\\<close> vs_ne"], ["proof (prove)\nusing this:\n  qs < v1\n  u1 # us \\<in> lists (- {[]})\n  last u1 < length v1\n  v1 # vs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. qs < v1 @ interact us vs", "by (auto simp: less_list_def)"], ["proof (state)\nthis:\n  qs < v1 @ interact us vs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "ultimately"], ["proof (chain)\npicking this:\n  strict_sorted (interact us vs)\n  v1 < interact us vs\n  ps < u1 @ qs @ v1 @ interact us vs\n  u1 < qs @ v1 @ interact us vs\n  qs < v1 @ interact us vs", "show ?thesis"], ["proof (prove)\nusing this:\n  strict_sorted (interact us vs)\n  v1 < interact us vs\n  ps < u1 @ qs @ v1 @ interact us vs\n  u1 < qs @ v1 @ interact us vs\n  qs < v1 @ interact us vs\n\ngoal (1 subgoal):\n 1. strict_sorted zs", "by (simp add: zs_def strict_sorted_append_iff ssp ssq \\<open>strict_sorted u1\\<close> \\<open>strict_sorted v1\\<close>)"], ["proof (state)\nthis:\n  strict_sorted zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strict_sorted zs\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have ps_subset_d: \"list.set ps \\<subseteq> d j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set ps \\<subseteq> d j", "using K Ksub \\<K>_card \\<open>finite K\\<close> acc_lengths_subset_d u_sub"], ["proof (prove)\nusing this:\n  K \\<in> \\<K> j j\n  K \\<subseteq> {j<..}\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n  finite K\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> list.set (acc_lengths 0 (seqs ?j0.0 ?j ?K))\n                    \\<subseteq> d ?j0.0\n  list.set ps \\<subseteq> list.set (acc_lengths 0 (seqs j j K))\n\ngoal (1 subgoal):\n 1. list.set ps \\<subseteq> d j", "by blast"], ["proof (state)\nthis:\n  list.set ps \\<subseteq> d j\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have ps_less_u1: \"ps < u1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps < u1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ps < u1", "have \"hd u1 = hd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd u1 = hd x", "using us_ne"], ["proof (prove)\nusing this:\n  u1 # us \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. hd u1 = hd x", "by (auto simp: xu_eq)"], ["proof (state)\nthis:\n  hd u1 = hd x\n\ngoal (1 subgoal):\n 1. ps < u1", "then"], ["proof (chain)\npicking this:\n  hd u1 = hd x", "have \"hd u1 \\<in> a j\""], ["proof (prove)\nusing this:\n  hd u1 = hd x\n\ngoal (1 subgoal):\n 1. hd u1 \\<in> a j", "by (simp add: xeq BB_eq_concat_seqs K seqs_def hd_append hd_list_of)"], ["proof (state)\nthis:\n  hd u1 \\<in> a j\n\ngoal (1 subgoal):\n 1. ps < u1", "then"], ["proof (chain)\npicking this:\n  hd u1 \\<in> a j", "have \"list.set ps \\<lless> {hd u1}\""], ["proof (prove)\nusing this:\n  hd u1 \\<in> a j\n\ngoal (1 subgoal):\n 1. list.set ps \\<lless> {hd u1}", "by (metis da ps_subset_d less_sets_def singletonD subset_iff)"], ["proof (state)\nthis:\n  list.set ps \\<lless> {hd u1}\n\ngoal (1 subgoal):\n 1. ps < u1", "then"], ["proof (chain)\npicking this:\n  list.set ps \\<lless> {hd u1}", "show ?thesis"], ["proof (prove)\nusing this:\n  list.set ps \\<lless> {hd u1}\n\ngoal (1 subgoal):\n 1. ps < u1", "by (metis less_hd_imp_less list.set(2) empty_set less_sets_imp_list_less)"], ["proof (state)\nthis:\n  ps < u1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps < u1\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have qs_subset_d: \"list.set qs \\<subseteq> d r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set qs \\<subseteq> d r", "using L Lsub \\<K>_card \\<open>finite L\\<close> acc_lengths_subset_d v_sub"], ["proof (prove)\nusing this:\n  L \\<in> \\<K> r r\n  L \\<subseteq> {r<..}\n  ?K \\<in> \\<K> ?j0.0 ?j \\<Longrightarrow> card ?K = ?j\n  finite L\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> list.set (acc_lengths 0 (seqs ?j0.0 ?j ?K))\n                    \\<subseteq> d ?j0.0\n  list.set qs \\<subseteq> list.set (acc_lengths 0 (seqs r r L))\n\ngoal (1 subgoal):\n 1. list.set qs \\<subseteq> d r", "by blast"], ["proof (state)\nthis:\n  list.set qs \\<subseteq> d r\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have qs_less_v1: \"qs < v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs < v1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. qs < v1", "have \"hd v1 = hd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd v1 = hd y", "using vs_ne"], ["proof (prove)\nusing this:\n  v1 # vs \\<in> lists (- {[]})\n\ngoal (1 subgoal):\n 1. hd v1 = hd y", "by (auto simp: yv_eq)"], ["proof (state)\nthis:\n  hd v1 = hd y\n\ngoal (1 subgoal):\n 1. qs < v1", "then"], ["proof (chain)\npicking this:\n  hd v1 = hd y", "have \"hd v1 \\<in> a r\""], ["proof (prove)\nusing this:\n  hd v1 = hd y\n\ngoal (1 subgoal):\n 1. hd v1 \\<in> a r", "by (simp add: yeq BB_eq_concat_seqs L seqs_def hd_append hd_list_of)"], ["proof (state)\nthis:\n  hd v1 \\<in> a r\n\ngoal (1 subgoal):\n 1. qs < v1", "then"], ["proof (chain)\npicking this:\n  hd v1 \\<in> a r", "have \"list.set qs \\<lless> {hd v1}\""], ["proof (prove)\nusing this:\n  hd v1 \\<in> a r\n\ngoal (1 subgoal):\n 1. list.set qs \\<lless> {hd v1}", "by (metis da qs_subset_d less_sets_def singletonD subset_iff)"], ["proof (state)\nthis:\n  list.set qs \\<lless> {hd v1}\n\ngoal (1 subgoal):\n 1. qs < v1", "then"], ["proof (chain)\npicking this:\n  list.set qs \\<lless> {hd v1}", "show ?thesis"], ["proof (prove)\nusing this:\n  list.set qs \\<lless> {hd v1}\n\ngoal (1 subgoal):\n 1. qs < v1", "by (metis less_hd_imp_less list.set(2) empty_set less_sets_imp_list_less)"], ["proof (state)\nthis:\n  qs < v1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qs < v1\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have FB: \"Form_Body ku kv x y zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form_Body ku kv x y zs", "unfolding Form_Body.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys a as b bs ka kb c d zsa.\n       ku = ka \\<and>\n       kv = kb \\<and>\n       x = xs \\<and>\n       y = ys \\<and>\n       zs = zsa \\<and>\n       length xs < length ys \\<and>\n       xs = concat (a # as) \\<and>\n       ys = concat (b # bs) \\<and>\n       a # as \\<in> lists (- {[]}) \\<and>\n       b # bs \\<in> lists (- {[]}) \\<and>\n       length (a # as) = ka \\<and>\n       length (b # bs) = kb \\<and>\n       c = acc_lengths 0 (a # as) \\<and>\n       d = acc_lengths 0 (b # bs) \\<and>\n       zsa = concat [c, a, d, b] @ interact as bs \\<and> strict_sorted zsa", "using ku_def kv_def ps_def qs_def ss us_ne vs_ne xu_eq xy yv_eq zs_def"], ["proof (prove)\nusing this:\n  ku \\<equiv> length (u1 # us)\n  kv \\<equiv> length (v1 # vs)\n  ps \\<equiv> acc_lengths 0 (u1 # us)\n  qs \\<equiv> acc_lengths 0 (v1 # vs)\n  strict_sorted zs\n  u1 # us \\<in> lists (- {[]})\n  v1 # vs \\<in> lists (- {[]})\n  x = concat (u1 # us)\n  length x < length y\n  y = concat (v1 # vs)\n  zs \\<equiv> concat [ps, u1, qs, v1] @ interact us vs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys a as b bs ka kb c d zsa.\n       ku = ka \\<and>\n       kv = kb \\<and>\n       x = xs \\<and>\n       y = ys \\<and>\n       zs = zsa \\<and>\n       length xs < length ys \\<and>\n       xs = concat (a # as) \\<and>\n       ys = concat (b # bs) \\<and>\n       a # as \\<in> lists (- {[]}) \\<and>\n       b # bs \\<in> lists (- {[]}) \\<and>\n       length (a # as) = ka \\<and>\n       length (b # bs) = kb \\<and>\n       c = acc_lengths 0 (a # as) \\<and>\n       d = acc_lengths 0 (b # bs) \\<and>\n       zsa = concat [c, a, d, b] @ interact as bs \\<and> strict_sorted zsa", "by blast"], ["proof (state)\nthis:\n  Form_Body ku kv x y zs\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  Form_Body ku kv x y zs", "have \"zs = (inter_scheme ((ku+kv) - Suc 0) {x,y})\""], ["proof (prove)\nusing this:\n  Form_Body ku kv x y zs\n\ngoal (1 subgoal):\n 1. zs = inter_scheme (ku + kv - Suc 0) {x, y}", "by (simp add: Form_Body_imp_inter_scheme k)"], ["proof (state)\nthis:\n  zs = inter_scheme (ku + kv - Suc 0) {x, y}\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "obtain l where \"l \\<le> 2 * (Suc j)\" and l: \"Form l U\" and zs_eq_interact: \"zs = inter_scheme l {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<le> 2 * Suc j; Form l U;\n         zs = inter_scheme l {x, y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<le> 2 * Suc j; Form l U;\n         zs = inter_scheme l {x, y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 \\<le> 2 * Suc j\n 2. (\\<And>l.\n        \\<lbrakk>l \\<le> 2 * Suc j; Form l U;\n         zs = inter_scheme l {x, y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    Form ?l2 U\n 3. (\\<And>l.\n        \\<lbrakk>l \\<le> 2 * Suc j; Form l U;\n         zs = inter_scheme l {x, y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    zs = inter_scheme ?l2 {x, y}", "show \"ku+kv-1 \\<le> 2 * (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ku + kv - 1 \\<le> 2 * Suc j", "using k"], ["proof (prove)\nusing this:\n  0 < kv\n  kv \\<le> ku\n  ku \\<le> Suc kv\n  kv \\<le> Suc j\n\ngoal (1 subgoal):\n 1. ku + kv - 1 \\<le> 2 * Suc j", "by auto"], ["proof (state)\nthis:\n  ku + kv - 1 \\<le> 2 * Suc j\n\ngoal (2 subgoals):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<le> 2 * Suc j; Form l U;\n         zs = inter_scheme l {x, y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    Form (ku + kv - 1) U\n 2. (\\<And>l.\n        \\<lbrakk>l \\<le> 2 * Suc j; Form l U;\n         zs = inter_scheme l {x, y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    zs = inter_scheme (ku + kv - 1) {x, y}", "show \"Form (ku+kv-1) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form (ku + kv - 1) U", "proof (cases \"ku=kv\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ku = kv \\<Longrightarrow> Form (ku + kv - 1) U\n 2. ku \\<noteq> kv \\<Longrightarrow> Form (ku + kv - 1) U", "case True"], ["proof (state)\nthis:\n  ku = kv\n\ngoal (2 subgoals):\n 1. ku = kv \\<Longrightarrow> Form (ku + kv - 1) U\n 2. ku \\<noteq> kv \\<Longrightarrow> Form (ku + kv - 1) U", "then"], ["proof (chain)\npicking this:\n  ku = kv", "show ?thesis"], ["proof (prove)\nusing this:\n  ku = kv\n\ngoal (1 subgoal):\n 1. Form (ku + kv - 1) U", "using FB Form.simps Ueq \\<open>0 < kv\\<close>"], ["proof (prove)\nusing this:\n  ku = kv\n  Form_Body ku kv x y zs\n  Form ?a1.0 ?a2.0 =\n  ((\\<exists>xs ys.\n       ?a1.0 = 0 \\<and>\n       ?a2.0 = {xs, ys} \\<and>\n       length xs = length ys \\<and> xs \\<noteq> ys) \\<or>\n   (\\<exists>k xs ys zs.\n       ?a1.0 = 2 * k - 1 \\<and>\n       ?a2.0 = {xs, ys} \\<and> Form_Body k k xs ys zs \\<and> 0 < k) \\<or>\n   (\\<exists>k xs ys zs.\n       ?a1.0 = 2 * k \\<and>\n       ?a2.0 = {xs, ys} \\<and> Form_Body (Suc k) k xs ys zs \\<and> 0 < k))\n  U = {x, y}\n  0 < kv\n\ngoal (1 subgoal):\n 1. Form (ku + kv - 1) U", "by (auto simp: mult_2)"], ["proof (state)\nthis:\n  Form (ku + kv - 1) U\n\ngoal (1 subgoal):\n 1. ku \\<noteq> kv \\<Longrightarrow> Form (ku + kv - 1) U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ku \\<noteq> kv \\<Longrightarrow> Form (ku + kv - 1) U", "case False"], ["proof (state)\nthis:\n  ku \\<noteq> kv\n\ngoal (1 subgoal):\n 1. ku \\<noteq> kv \\<Longrightarrow> Form (ku + kv - 1) U", "then"], ["proof (chain)\npicking this:\n  ku \\<noteq> kv", "have \"ku = Suc kv\""], ["proof (prove)\nusing this:\n  ku \\<noteq> kv\n\ngoal (1 subgoal):\n 1. ku = Suc kv", "using k"], ["proof (prove)\nusing this:\n  ku \\<noteq> kv\n  0 < kv\n  kv \\<le> ku\n  ku \\<le> Suc kv\n  kv \\<le> Suc j\n\ngoal (1 subgoal):\n 1. ku = Suc kv", "by auto"], ["proof (state)\nthis:\n  ku = Suc kv\n\ngoal (1 subgoal):\n 1. ku \\<noteq> kv \\<Longrightarrow> Form (ku + kv - 1) U", "then"], ["proof (chain)\npicking this:\n  ku = Suc kv", "show ?thesis"], ["proof (prove)\nusing this:\n  ku = Suc kv\n\ngoal (1 subgoal):\n 1. Form (ku + kv - 1) U", "using FB Form.simps Ueq \\<open>0 < kv\\<close>"], ["proof (prove)\nusing this:\n  ku = Suc kv\n  Form_Body ku kv x y zs\n  Form ?a1.0 ?a2.0 =\n  ((\\<exists>xs ys.\n       ?a1.0 = 0 \\<and>\n       ?a2.0 = {xs, ys} \\<and>\n       length xs = length ys \\<and> xs \\<noteq> ys) \\<or>\n   (\\<exists>k xs ys zs.\n       ?a1.0 = 2 * k - 1 \\<and>\n       ?a2.0 = {xs, ys} \\<and> Form_Body k k xs ys zs \\<and> 0 < k) \\<or>\n   (\\<exists>k xs ys zs.\n       ?a1.0 = 2 * k \\<and>\n       ?a2.0 = {xs, ys} \\<and> Form_Body (Suc k) k xs ys zs \\<and> 0 < k))\n  U = {x, y}\n  0 < kv\n\ngoal (1 subgoal):\n 1. Form (ku + kv - 1) U", "by auto"], ["proof (state)\nthis:\n  Form (ku + kv - 1) U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Form (ku + kv - 1) U\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<le> 2 * Suc j; Form l U;\n         zs = inter_scheme l {x, y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    zs = inter_scheme (ku + kv - 1) {x, y}", "show \"zs = inter_scheme (ku + kv - 1) {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs = inter_scheme (ku + kv - 1) {x, y}", "using Form_Body_imp_inter_scheme"], ["proof (prove)\nusing this:\n  \\<lbrakk>Form_Body ?ka ?kb ?xs ?ys ?zs; 0 < ?kb; ?kb \\<le> ?ka;\n   ?ka \\<le> Suc ?kb\\<rbrakk>\n  \\<Longrightarrow> ?zs = inter_scheme (?ka + ?kb - Suc 0) {?xs, ?ys}\n\ngoal (1 subgoal):\n 1. zs = inter_scheme (ku + kv - 1) {x, y}", "by (simp add: FB k)"], ["proof (state)\nthis:\n  zs = inter_scheme (ku + kv - 1) {x, y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<le> 2 * Suc j\n  Form l U\n  zs = inter_scheme l {x, y}\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "then"], ["proof (chain)\npicking this:\n  l \\<le> 2 * Suc j\n  Form l U\n  zs = inter_scheme l {x, y}", "have \"enum N l \\<le> enum N (Suc (2 * Suc j))\""], ["proof (prove)\nusing this:\n  l \\<le> 2 * Suc j\n  Form l U\n  zs = inter_scheme l {x, y}\n\ngoal (1 subgoal):\n 1. enum N l \\<le> enum N (Suc (2 * Suc j))", "by (simp add: assms less_imp_le_nat)"], ["proof (state)\nthis:\n  enum N l \\<le> enum N (Suc (2 * Suc j))\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "also"], ["proof (state)\nthis:\n  enum N l \\<le> enum N (Suc (2 * Suc j))\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have \"\\<dots> < Min (d j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum N (Suc (2 * Suc j)) < Min (d j)", "by (metis Min_in card_0_eq card_d d_eq finite_d fst_grab_subset greaterThan_iff in_mono le_inf_iff nxt_def old.nat.distinct(2))"], ["proof (state)\nthis:\n  enum N (Suc (2 * Suc j)) < Min (d j)\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "finally"], ["proof (chain)\npicking this:\n  enum N l < Min (d j)", "have ls: \"{enum N l} \\<lless> d j\""], ["proof (prove)\nusing this:\n  enum N l < Min (d j)\n\ngoal (1 subgoal):\n 1. {enum N l} \\<lless> d j", "by simp"], ["proof (state)\nthis:\n  {enum N l} \\<lless> d j\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "have \"l > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l", "by (metis l False Form_0_cases_raw Set.doubleton_eq_iff Ueq gr0I)"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. length x \\<noteq> length y \\<Longrightarrow>\n    \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       Form l U \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l U \\<and>\n        list.set (inter_scheme l U) \\<subseteq> N)", "unfolding Ueq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       Form l {x, y} \\<and>\n       (0 < l \\<longrightarrow>\n        [enum N l] < inter_scheme l {x, y} \\<and>\n        list.set (inter_scheme l {x, y}) \\<subseteq> N)", "proof (intro exI conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. Form ?l {x, y}\n 2. 0 < ?l \\<Longrightarrow> [enum N ?l] < inter_scheme ?l {x, y}\n 3. 0 < ?l \\<Longrightarrow> list.set (inter_scheme ?l {x, y}) \\<subseteq> N", "have zs_subset: \"list.set zs \\<subseteq> list.set (acc_lengths 0 (seqs j j K)) \\<union> list.set (acc_lengths 0 (seqs r r L)) \\<union> list.set x \\<union> list.set y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set zs\n    \\<subseteq> list.set (acc_lengths 0 (seqs j j K)) \\<union>\n                list.set (acc_lengths 0 (seqs r r L)) \\<union>\n                list.set x \\<union>\n                list.set y", "using u_sub v_sub"], ["proof (prove)\nusing this:\n  list.set ps \\<subseteq> list.set (acc_lengths 0 (seqs j j K))\n  list.set qs \\<subseteq> list.set (acc_lengths 0 (seqs r r L))\n\ngoal (1 subgoal):\n 1. list.set zs\n    \\<subseteq> list.set (acc_lengths 0 (seqs j j K)) \\<union>\n                list.set (acc_lengths 0 (seqs r r L)) \\<union>\n                list.set x \\<union>\n                list.set y", "by (auto simp: zs_def xu_eq yv_eq)"], ["proof (state)\nthis:\n  list.set zs\n  \\<subseteq> list.set (acc_lengths 0 (seqs j j K)) \\<union>\n              list.set (acc_lengths 0 (seqs r r L)) \\<union>\n              list.set x \\<union>\n              list.set y\n\ngoal (3 subgoals):\n 1. Form ?l {x, y}\n 2. 0 < ?l \\<Longrightarrow> [enum N ?l] < inter_scheme ?l {x, y}\n 3. 0 < ?l \\<Longrightarrow> list.set (inter_scheme ?l {x, y}) \\<subseteq> N", "also"], ["proof (state)\nthis:\n  list.set zs\n  \\<subseteq> list.set (acc_lengths 0 (seqs j j K)) \\<union>\n              list.set (acc_lengths 0 (seqs r r L)) \\<union>\n              list.set x \\<union>\n              list.set y\n\ngoal (3 subgoals):\n 1. Form ?l {x, y}\n 2. 0 < ?l \\<Longrightarrow> [enum N ?l] < inter_scheme ?l {x, y}\n 3. 0 < ?l \\<Longrightarrow> list.set (inter_scheme ?l {x, y}) \\<subseteq> N", "have \"\\<dots> \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (acc_lengths 0 (seqs j j K)) \\<union>\n    list.set (acc_lengths 0 (seqs r r L)) \\<union>\n    list.set x \\<union>\n    list.set y\n    \\<subseteq> N", "proof (simp, intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. list.set (acc_lengths 0 (seqs j j K)) \\<subseteq> N\n 2. list.set (acc_lengths 0 (seqs r r L)) \\<subseteq> N\n 3. list.set x \\<subseteq> N\n 4. list.set y \\<subseteq> N", "show \"list.set (acc_lengths 0 (seqs j j K)) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (acc_lengths 0 (seqs j j K)) \\<subseteq> N", "using d_subset_N Ksub \\<open>finite K\\<close> \\<open>j \\<le> card K\\<close> acc_lengths_subset_d"], ["proof (prove)\nusing this:\n  d ?k \\<subseteq> N\n  K \\<subseteq> {j<..}\n  finite K\n  j \\<le> card K\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> list.set (acc_lengths 0 (seqs ?j0.0 ?j ?K))\n                    \\<subseteq> d ?j0.0\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths 0 (seqs j j K)) \\<subseteq> N", "by blast"], ["proof (state)\nthis:\n  list.set (acc_lengths 0 (seqs j j K)) \\<subseteq> N\n\ngoal (3 subgoals):\n 1. list.set (acc_lengths 0 (seqs r r L)) \\<subseteq> N\n 2. list.set x \\<subseteq> N\n 3. list.set y \\<subseteq> N", "show \"list.set (acc_lengths 0 (seqs r r L)) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (acc_lengths 0 (seqs r r L)) \\<subseteq> N", "using d_subset_N Lsub \\<open>finite L\\<close> \\<open>r \\<le> card L\\<close> acc_lengths_subset_d"], ["proof (prove)\nusing this:\n  d ?k \\<subseteq> N\n  L \\<subseteq> {r<..}\n  finite L\n  r \\<le> card L\n  \\<lbrakk>?K \\<subseteq> {?j0.0<..}; finite ?K; ?j0.0 \\<le> card ?K;\n   ?j \\<le> ?j0.0\\<rbrakk>\n  \\<Longrightarrow> list.set (acc_lengths 0 (seqs ?j0.0 ?j ?K))\n                    \\<subseteq> d ?j0.0\n\ngoal (1 subgoal):\n 1. list.set (acc_lengths 0 (seqs r r L)) \\<subseteq> N", "by blast"], ["proof (state)\nthis:\n  list.set (acc_lengths 0 (seqs r r L)) \\<subseteq> N\n\ngoal (2 subgoals):\n 1. list.set x \\<subseteq> N\n 2. list.set y \\<subseteq> N", "show \"list.set x \\<subseteq> N\" \"list.set y \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set x \\<subseteq> N &&& list.set y \\<subseteq> N", "by (simp_all add: xeq yeq BB_def a_subset_N UN_least b_subset_N)"], ["proof (state)\nthis:\n  list.set x \\<subseteq> N\n  list.set y \\<subseteq> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list.set (acc_lengths 0 (seqs j j K)) \\<union>\n  list.set (acc_lengths 0 (seqs r r L)) \\<union>\n  list.set x \\<union>\n  list.set y\n  \\<subseteq> N\n\ngoal (3 subgoals):\n 1. Form ?l {x, y}\n 2. 0 < ?l \\<Longrightarrow> [enum N ?l] < inter_scheme ?l {x, y}\n 3. 0 < ?l \\<Longrightarrow> list.set (inter_scheme ?l {x, y}) \\<subseteq> N", "finally"], ["proof (chain)\npicking this:\n  list.set zs \\<subseteq> N", "show \"list.set (inter_scheme l {x, y}) \\<subseteq> N\""], ["proof (prove)\nusing this:\n  list.set zs \\<subseteq> N\n\ngoal (1 subgoal):\n 1. list.set (inter_scheme l {x, y}) \\<subseteq> N", "using zs_eq_interact"], ["proof (prove)\nusing this:\n  list.set zs \\<subseteq> N\n  zs = inter_scheme l {x, y}\n\ngoal (1 subgoal):\n 1. list.set (inter_scheme l {x, y}) \\<subseteq> N", "by blast"], ["proof (state)\nthis:\n  list.set (inter_scheme l {x, y}) \\<subseteq> N\n\ngoal (2 subgoals):\n 1. Form l {x, y}\n 2. 0 < l \\<Longrightarrow> [enum N l] < inter_scheme l {x, y}", "have \"[enum N l] < ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [enum N l] < ps", "using ps_subset_d ls"], ["proof (prove)\nusing this:\n  list.set ps \\<subseteq> d j\n  {enum N l} \\<lless> d j\n\ngoal (1 subgoal):\n 1. [enum N l] < ps", "by (metis empty_set less_sets_imp_list_less less_sets_weaken2 list.simps(15))"], ["proof (state)\nthis:\n  [enum N l] < ps\n\ngoal (2 subgoals):\n 1. Form l {x, y}\n 2. 0 < l \\<Longrightarrow> [enum N l] < inter_scheme l {x, y}", "then"], ["proof (chain)\npicking this:\n  [enum N l] < ps", "show \"[enum N l] < inter_scheme l {x, y}\""], ["proof (prove)\nusing this:\n  [enum N l] < ps\n\ngoal (1 subgoal):\n 1. [enum N l] < inter_scheme l {x, y}", "by (simp add: zs_def less_list_def ps_def flip: zs_eq_interact)"], ["proof (state)\nthis:\n  [enum N l] < inter_scheme l {x, y}\n\ngoal (1 subgoal):\n 1. Form l {x, y}", "qed (use Ueq l in blast)"], ["proof (state)\nthis:\n  \\<exists>l.\n     Form l U \\<and>\n     (0 < l \\<longrightarrow>\n      [enum N l] < inter_scheme l U \\<and>\n      list.set (inter_scheme l U) \\<subseteq> N)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l.\n     Form l U \\<and>\n     (0 < l \\<longrightarrow>\n      [enum N l] < inter_scheme l U \\<and>\n      list.set (inter_scheme l U) \\<subseteq> N)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The main partition theorem for @{term \"\\<omega>\\<up>\\<omega>\"}\\<close>"], ["", "definition iso_ll where \"iso_ll A B \\<equiv> iso (lenlex less_than \\<inter> (A\\<times>A)) (lenlex less_than \\<inter> (B\\<times>B))\""], ["", "corollary ordertype_eq_ordertype_iso_ll:\n  assumes \"Field (Restr (lenlex less_than) A) = A\" \"Field (Restr (lenlex less_than) B) = B\"\n  shows \"(ordertype A (lenlex less_than) = ordertype B (lenlex less_than))\n         \\<longleftrightarrow> (\\<exists>f. iso_ll A B f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordertype A (lenlex less_than) = ordertype B (lenlex less_than)) =\n    (\\<exists>f. iso_ll A B f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ordertype A (lenlex less_than) = ordertype B (lenlex less_than)) =\n    (\\<exists>f. iso_ll A B f)", "have \"total_on A (lenlex less_than) \\<and> total_on B (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_on A (lenlex less_than) \\<and> total_on B (lenlex less_than)", "by (meson UNIV_I total_lenlex total_on_def total_on_less_than)"], ["proof (state)\nthis:\n  total_on A (lenlex less_than) \\<and> total_on B (lenlex less_than)\n\ngoal (1 subgoal):\n 1. (ordertype A (lenlex less_than) = ordertype B (lenlex less_than)) =\n    (\\<exists>f. iso_ll A B f)", "then"], ["proof (chain)\npicking this:\n  total_on A (lenlex less_than) \\<and> total_on B (lenlex less_than)", "show ?thesis"], ["proof (prove)\nusing this:\n  total_on A (lenlex less_than) \\<and> total_on B (lenlex less_than)\n\ngoal (1 subgoal):\n 1. (ordertype A (lenlex less_than) = ordertype B (lenlex less_than)) =\n    (\\<exists>f. iso_ll A B f)", "by (simp add: assms wf_lenlex lenlex_transI iso_ll_def ordertype_eq_ordertype_iso_Restr)"], ["proof (state)\nthis:\n  (ordertype A (lenlex less_than) = ordertype B (lenlex less_than)) =\n  (\\<exists>f. iso_ll A B f)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem partition_\\<omega>\\<omega>_aux:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\"\n  shows \"partn_lst (lenlex less_than) WW [\\<omega>\\<up>\\<omega>,\\<alpha>] 2\" (is \"partn_lst ?R WW [\\<omega>\\<up>\\<omega>,\\<alpha>] 2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "proof (cases \"\\<alpha> \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2\n 2. \\<not> \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "case True"], ["proof (state)\nthis:\n  \\<alpha> \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2\n 2. \\<not> \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> 1\n\ngoal (1 subgoal):\n 1. Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "using strict_sorted_into_WW"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> 1\n  strict_sorted (into_WW ?x ?ns)\n\ngoal (1 subgoal):\n 1. Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "unfolding WW_def"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> 1\n  strict_sorted (into_WW ?x ?ns)\n\ngoal (1 subgoal):\n 1. Partitions.partn_lst (lenlex less_than) {l. strict_sorted l}\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "by (auto intro!: partn_lst_triv1[where i=1])"], ["proof (state)\nthis:\n  Partitions.partn_lst (lenlex less_than) WW\n   [\\<omega> \\<up> \\<omega>, \\<alpha>] 2\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "case False"], ["proof (state)\nthis:\n  \\<not> \\<alpha> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "obtain m where m: \"\\<alpha> = ord_of_nat m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<alpha> = ord_of_nat m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms elts_\\<omega>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts \\<omega>\n  elts \\<omega> = {\\<alpha>. \\<exists>n. \\<alpha> = ord_of_nat n}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<alpha> = ord_of_nat m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<alpha> = ord_of_nat m\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = ord_of_nat m", "have \"m>1\""], ["proof (prove)\nusing this:\n  \\<alpha> = ord_of_nat m\n\ngoal (1 subgoal):\n 1. 1 < m", "using False"], ["proof (prove)\nusing this:\n  \\<alpha> = ord_of_nat m\n  \\<not> \\<alpha> \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 < m", "by auto"], ["proof (state)\nthis:\n  1 < m\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<le> 1 \\<Longrightarrow>\n    Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partitions.partn_lst (lenlex less_than) WW\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "unfolding partn_lst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>[WW]\\<^bsup>2\\<^esup> \\<rightarrow>\n                   {..<length [\\<omega> \\<up> \\<omega>, \\<alpha>]}.\n       \\<exists>i<length [\\<omega> \\<up> \\<omega>, \\<alpha>].\n          \\<exists>H\\<subseteq>WW.\n             ordertype H (lenlex less_than) =\n             [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n             f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow>\n               {..<Suc (Suc 0)} \\<Longrightarrow>\n       \\<exists>i<Suc (Suc 0).\n          \\<exists>H\\<subseteq>WW.\n             ordertype H (lenlex less_than) =\n             [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n             f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow>\n               {..<Suc (Suc 0)} \\<Longrightarrow>\n       \\<exists>i<Suc (Suc 0).\n          \\<exists>H\\<subseteq>WW.\n             ordertype H (lenlex less_than) =\n             [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n             f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}", "assume f: \"f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\""], ["proof (state)\nthis:\n  f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow>\n               {..<Suc (Suc 0)} \\<Longrightarrow>\n       \\<exists>i<Suc (Suc 0).\n          \\<exists>H\\<subseteq>WW.\n             ordertype H (lenlex less_than) =\n             [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n             f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}", "let ?P0 = \"\\<exists>X \\<subseteq> WW. ordertype X ?R = \\<omega>\\<up>\\<omega> \\<and> f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow>\n               {..<Suc (Suc 0)} \\<Longrightarrow>\n       \\<exists>i<Suc (Suc 0).\n          \\<exists>H\\<subseteq>WW.\n             ordertype H (lenlex less_than) =\n             [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n             f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}", "let ?P1 = \"\\<exists>M \\<subseteq> WW. ordertype M ?R = \\<alpha> \\<and> f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow>\n               {..<Suc (Suc 0)} \\<Longrightarrow>\n       \\<exists>i<Suc (Suc 0).\n          \\<exists>H\\<subseteq>WW.\n             ordertype H (lenlex less_than) =\n             [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n             f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}", "have \\<dagger>: \"?P0 \\<or> ?P1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>X\\<subseteq>WW.\n        ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n        f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}) \\<or>\n    (\\<exists>M\\<subseteq>WW.\n        ordertype M (lenlex less_than) = \\<alpha> \\<and>\n        f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1})", "proof (rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "assume not1: \"\\<not> ?P1\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>M\\<subseteq>WW.\n             ordertype M (lenlex less_than) = \\<alpha> \\<and>\n             f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have \"\\<exists>W'. ordertype W' ?R = \\<omega>\\<up>n \\<and> f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and> W' \\<subseteq> WW_seg (n*m)\" for n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat n \\<and>\n       f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n       W' \\<subseteq> WW_seg (n * m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat n \\<and>\n       f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n       W' \\<subseteq> WW_seg (n * m)", "have fnm: \"f \\<in> [WW_seg (n*m)]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> [WW_seg (n * m)]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}", "using f WW_seg_subset_WW [of \"n*m\"]"], ["proof (prove)\nusing this:\n  f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n  WW_seg (n * m) \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. f \\<in> [WW_seg (n * m)]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}", "by (meson in_mono nsets_Pi_contra)"], ["proof (state)\nthis:\n  f \\<in> [WW_seg (n * m)]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat n \\<and>\n       f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n       W' \\<subseteq> WW_seg (n * m)", "have *: \"partn_lst ?R (WW_seg (n*m)) [\\<omega>\\<up>n, ord_of_nat m] 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partitions.partn_lst (lenlex less_than) (WW_seg (n * m))\n     [\\<omega> \\<up> ord_of_nat n, ord_of_nat m] 2", "using ordertype_WW_seg [of \"n*m\"]"], ["proof (prove)\nusing this:\n  ordertype (WW_seg (n * m)) (lenlex less_than) =\n  \\<omega> \\<up> ord_of_nat (n * m)\n\ngoal (1 subgoal):\n 1. Partitions.partn_lst (lenlex less_than) (WW_seg (n * m))\n     [\\<omega> \\<up> ord_of_nat n, ord_of_nat m] 2", "by (simp add: partn_lst_VWF_imp_partn_lst [OF Theorem_3_2])"], ["proof (state)\nthis:\n  Partitions.partn_lst (lenlex less_than) (WW_seg (n * m))\n   [\\<omega> \\<up> ord_of_nat n, ord_of_nat m] 2\n\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat n \\<and>\n       f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n       W' \\<subseteq> WW_seg (n * m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat n \\<and>\n       f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n       W' \\<subseteq> WW_seg (n * m)", "using partn_lst_E [OF * fnm, simplified]"], ["proof (prove)\nusing this:\n  (\\<And>i H.\n      \\<lbrakk>i < Suc (Suc 0); H \\<subseteq> WW_seg (n * m);\n       ordertype H (lenlex less_than) =\n       [\\<omega> \\<up> ord_of_nat n, ord_of_nat m] ! i;\n       f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat n \\<and>\n       f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n       W' \\<subseteq> WW_seg (n * m)", "by (metis (no_types, hide_lams) One_nat_def Suc_1 WW_seg_subset_WW order.trans less_2_cases m not1 nth_Cons' nth_Cons_Suc)"], ["proof (state)\nthis:\n  \\<exists>W'.\n     ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat n \\<and>\n     f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n     W' \\<subseteq> WW_seg (n * m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>W'.\n     ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat ?n \\<and>\n     f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n     W' \\<subseteq> WW_seg (?n * m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "then"], ["proof (chain)\npicking this:\n  \\<exists>W'.\n     ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat ?n \\<and>\n     f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n     W' \\<subseteq> WW_seg (?n * m)", "obtain W':: \"nat \\<Rightarrow> nat list set\"\n          where otW': \"\\<And>n. ordertype (W' n) ?R = \\<omega>\\<up>n\"\n          and f_W': \"\\<And>n. f ` [W' n]\\<^bsup>2\\<^esup> \\<subseteq> {0}\"\n          and seg_W': \"\\<And>n. W' n \\<subseteq> WW_seg (n*m)\""], ["proof (prove)\nusing this:\n  \\<exists>W'.\n     ordertype W' (lenlex less_than) = \\<omega> \\<up> ord_of_nat ?n \\<and>\n     f ` [W']\\<^bsup>2\\<^esup> \\<subseteq> {0} \\<and>\n     W' \\<subseteq> WW_seg (?n * m)\n\ngoal (1 subgoal):\n 1. (\\<And>W'.\n        \\<lbrakk>\\<And>n.\n                    ordertype (W' n) (lenlex less_than) =\n                    \\<omega> \\<up> ord_of_nat n;\n         \\<And>n. f ` [W' n]\\<^bsup>2\\<^esup> \\<subseteq> {0};\n         \\<And>n. W' n \\<subseteq> WW_seg (n * m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ordertype (W' ?n) (lenlex less_than) = \\<omega> \\<up> ord_of_nat ?n\n  f ` [W' ?n]\\<^bsup>2\\<^esup> \\<subseteq> {0}\n  W' ?n \\<subseteq> WW_seg (?n * m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "define WW' where \"WW' \\<equiv> (\\<Union>n. W' n)\""], ["proof (state)\nthis:\n  WW' \\<equiv> \\<Union> (range W')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have \"WW' \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WW' \\<subseteq> WW", "using seg_W' WW_seg_subset_WW"], ["proof (prove)\nusing this:\n  W' ?n \\<subseteq> WW_seg (?n * m)\n  WW_seg ?n \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. WW' \\<subseteq> WW", "by (force simp: WW'_def)"], ["proof (state)\nthis:\n  WW' \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "with f"], ["proof (chain)\npicking this:\n  f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n  WW' \\<subseteq> WW", "have f': \"f \\<in> [WW']\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\""], ["proof (prove)\nusing this:\n  f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n  WW' \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. f \\<in> [WW']\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}", "using nsets_mono"], ["proof (prove)\nusing this:\n  f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n  WW' \\<subseteq> WW\n  ?A \\<subseteq> ?B \\<Longrightarrow>\n  [?A]\\<^bsup>?n\\<^esup> \\<subseteq> [?B]\\<^bsup>?n\\<^esup>\n\ngoal (1 subgoal):\n 1. f \\<in> [WW']\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}", "by fastforce"], ["proof (state)\nthis:\n  f \\<in> [WW']\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have ot': \"ordertype WW' ?R = \\<omega>\\<up>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype WW' (lenlex less_than) = \\<omega> \\<up> \\<omega>", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ordertype WW' (lenlex less_than) \\<le> \\<omega> \\<up> \\<omega>\n 2. \\<omega> \\<up> \\<omega> \\<le> ordertype WW' (lenlex less_than)", "have \"ordertype WW' ?R \\<le> ordertype WW ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype WW' (lenlex less_than) \\<le> ordertype WW (lenlex less_than)", "by (simp add: \\<open>WW' \\<subseteq> WW\\<close> lenlex_transI ordertype_mono wf_lenlex)"], ["proof (state)\nthis:\n  ordertype WW' (lenlex less_than) \\<le> ordertype WW (lenlex less_than)\n\ngoal (2 subgoals):\n 1. ordertype WW' (lenlex less_than) \\<le> \\<omega> \\<up> \\<omega>\n 2. \\<omega> \\<up> \\<omega> \\<le> ordertype WW' (lenlex less_than)", "with ordertype_WW"], ["proof (chain)\npicking this:\n  ordertype WW (lenlex less_than) = \\<omega> \\<up> \\<omega>\n  ordertype WW' (lenlex less_than) \\<le> ordertype WW (lenlex less_than)", "show \"ordertype WW' ?R \\<le> \\<omega> \\<up> \\<omega>\""], ["proof (prove)\nusing this:\n  ordertype WW (lenlex less_than) = \\<omega> \\<up> \\<omega>\n  ordertype WW' (lenlex less_than) \\<le> ordertype WW (lenlex less_than)\n\ngoal (1 subgoal):\n 1. ordertype WW' (lenlex less_than) \\<le> \\<omega> \\<up> \\<omega>", "by simp"], ["proof (state)\nthis:\n  ordertype WW' (lenlex less_than) \\<le> \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW' (lenlex less_than)", "have \"\\<omega> \\<up> n \\<le> ordertype (\\<Union> (range W')) ?R\" for n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ord_of_nat n\n    \\<le> ordertype (\\<Union> (range W')) (lenlex less_than)", "by (metis TC_small UNIV_I UN_I otW' lenlex_transI ordertype_mono subsetI trans_less_than wf_lenlex wf_less_than)"], ["proof (state)\nthis:\n  \\<omega> \\<up> ord_of_nat ?n\n  \\<le> ordertype (\\<Union> (range W')) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW' (lenlex less_than)", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> ord_of_nat ?n\n  \\<le> ordertype (\\<Union> (range W')) (lenlex less_than)", "show \"\\<omega> \\<up> \\<omega> \\<le> ordertype WW' ?R\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> ord_of_nat ?n\n  \\<le> ordertype (\\<Union> (range W')) (lenlex less_than)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<omega> \\<le> ordertype WW' (lenlex less_than)", "by (auto simp: elts_\\<omega> oexp_Limit ZFC_in_HOL.SUP_le_iff WW'_def)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<omega> \\<le> ordertype WW' (lenlex less_than)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ordertype WW' (lenlex less_than) = \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have FR_WW: \"Field (Restr (lenlex less_than) WW) = WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Restr (lenlex less_than) WW) = WW", "by (simp add: Limit_omega_oexp Limit_ordertype_imp_Field_Restr ordertype_WW)"], ["proof (state)\nthis:\n  Field (Restr (lenlex less_than) WW) = WW\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have FR_WW': \"Field (Restr (lenlex less_than) WW') = WW'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Restr (lenlex less_than) WW') = WW'", "by (simp add: Limit_omega_oexp Limit_ordertype_imp_Field_Restr ot')"], ["proof (state)\nthis:\n  Field (Restr (lenlex less_than) WW') = WW'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have FR_W: \"Field (Restr (lenlex less_than) (WW_seg n)) = WW_seg n\" if \"n>0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Restr (lenlex less_than) (WW_seg n)) = WW_seg n", "by (simp add: Limit_omega_oexp ordertype_WW_seg that Limit_ordertype_imp_Field_Restr)"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow>\n  Field (Restr (lenlex less_than) (WW_seg ?n)) = WW_seg ?n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have FR_W': \"Field (Restr (lenlex less_than) (W' n)) = W' n\" if \"n>0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Restr (lenlex less_than) (W' n)) = W' n", "by (simp add: Limit_omega_oexp otW' that Limit_ordertype_imp_Field_Restr)"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow> Field (Restr (lenlex less_than) (W' ?n)) = W' ?n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have \"\\<exists>h. iso_ll (WW_seg n) (W' n) h\" if \"n>0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h. iso_ll (WW_seg n) (W' n) h", "proof (subst ordertype_eq_ordertype_iso_ll [symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. Field (Restr (lenlex less_than) (WW_seg n)) = WW_seg n\n 2. Field (Restr (lenlex less_than) (W' n)) = W' n\n 3. ordertype (WW_seg n) (lenlex less_than) =\n    ordertype (W' n) (lenlex less_than)", "show \"ordertype (WW_seg n) (lenlex less_than) = ordertype (W' n) (lenlex less_than)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (WW_seg n) (lenlex less_than) =\n    ordertype (W' n) (lenlex less_than)", "by (simp add: ordertype_WW_seg otW')"], ["proof (state)\nthis:\n  ordertype (WW_seg n) (lenlex less_than) =\n  ordertype (W' n) (lenlex less_than)\n\ngoal (2 subgoals):\n 1. Field (Restr (lenlex less_than) (WW_seg n)) = WW_seg n\n 2. Field (Restr (lenlex less_than) (W' n)) = W' n", "qed (auto simp: FR_W FR_W' that)"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow> \\<exists>h. iso_ll (WW_seg ?n) (W' ?n) h\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "then"], ["proof (chain)\npicking this:\n  0 < ?n \\<Longrightarrow> \\<exists>h. iso_ll (WW_seg ?n) (W' ?n) h", "obtain h_seg where h_seg: \"\\<And>n. n > 0 \\<Longrightarrow> iso_ll (WW_seg n) (W' n) (h_seg n)\""], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> \\<exists>h. iso_ll (WW_seg ?n) (W' ?n) h\n\ngoal (1 subgoal):\n 1. (\\<And>h_seg.\n        (\\<And>n.\n            0 < n \\<Longrightarrow>\n            iso_ll (WW_seg n) (W' n) (h_seg n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow> iso_ll (WW_seg ?n) (W' ?n) (h_seg ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "define h where \"h \\<equiv> \\<lambda>l. if l=[] then [] else h_seg (length l) l\""], ["proof (state)\nthis:\n  h \\<equiv> \\<lambda>l. if l = [] then [] else h_seg (length l) l\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have bij_h_seg: \"\\<And>n. n > 0 \\<Longrightarrow> bij_betw (h_seg n) (WW_seg n) (W' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. 0 < n \\<Longrightarrow> bij_betw (h_seg n) (WW_seg n) (W' n)", "using h_seg"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> iso_ll (WW_seg ?n) (W' ?n) (h_seg ?n)\n\ngoal (1 subgoal):\n 1. \\<And>n. 0 < n \\<Longrightarrow> bij_betw (h_seg n) (WW_seg n) (W' n)", "by (simp add: iso_ll_def iso_iff2 FR_W FR_W')"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow> bij_betw (h_seg ?n) (WW_seg ?n) (W' ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have len_h_seg: \"length (h_seg (length l) l) = length l * m\"\n        if \"length l > 0\" \"l \\<in> WW\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (h_seg (length l) l) = length l * m", "using bij_betwE [OF bij_h_seg] seg_W' that"], ["proof (prove)\nusing this:\n  0 < ?n1 \\<Longrightarrow>\n  \\<forall>a\\<in>WW_seg ?n1. h_seg ?n1 a \\<in> W' ?n1\n  W' ?n \\<subseteq> WW_seg (?n * m)\n  0 < length l\n  l \\<in> WW\n\ngoal (1 subgoal):\n 1. length (h_seg (length l) l) = length l * m", "by (simp add: WW_seg_def subset_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < length ?l; ?l \\<in> WW\\<rbrakk>\n  \\<Longrightarrow> length (h_seg (length ?l) ?l) = length ?l * m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have hlen: \"length (h x) = length (h y) \\<longleftrightarrow> length x = length y\" if \"x \\<in> WW\" \"y \\<in> WW\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (h x) = length (h y)) = (length x = length y)", "using that \\<open>1 < m\\<close> h_def len_h_seg"], ["proof (prove)\nusing this:\n  x \\<in> WW\n  y \\<in> WW\n  1 < m\n  h \\<equiv> \\<lambda>l. if l = [] then [] else h_seg (length l) l\n  \\<lbrakk>0 < length ?l; ?l \\<in> WW\\<rbrakk>\n  \\<Longrightarrow> length (h_seg (length ?l) ?l) = length ?l * m\n\ngoal (1 subgoal):\n 1. (length (h x) = length (h y)) = (length x = length y)", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> WW; ?y \\<in> WW\\<rbrakk>\n  \\<Longrightarrow> (length (h ?x) = length (h ?y)) =\n                    (length ?x = length ?y)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have h: \"iso_ll WW WW' h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iso_ll WW WW' h", "unfolding iso_ll_def iso_iff2 FR_WW FR_WW'"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw h WW WW' \\<and>\n    (\\<forall>a\\<in>WW.\n        \\<forall>b\\<in>WW.\n           ((a, b) \\<in> Restr (lenlex less_than) WW) =\n           ((h a, h b) \\<in> Restr (lenlex less_than) WW'))", "proof (intro conjI strip)"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw h WW WW'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> WW; b \\<in> WW\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> Restr (lenlex less_than) WW) =\n                         ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "have W'_ne: \"W' n \\<noteq> {}\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. W' n \\<noteq> {}", "using otW' [of n]"], ["proof (prove)\nusing this:\n  ordertype (W' n) (lenlex less_than) = \\<omega> \\<up> ord_of_nat n\n\ngoal (1 subgoal):\n 1. W' n \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  W' ?n \\<noteq> {}\n\ngoal (2 subgoals):\n 1. bij_betw h WW WW'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> WW; b \\<in> WW\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> Restr (lenlex less_than) WW) =\n                         ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "then"], ["proof (chain)\npicking this:\n  W' ?n \\<noteq> {}", "have \"[] \\<in> WW'\""], ["proof (prove)\nusing this:\n  W' ?n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. [] \\<in> WW'", "using seg_W' [of 0]"], ["proof (prove)\nusing this:\n  W' ?n \\<noteq> {}\n  W' 0 \\<subseteq> WW_seg (0 * m)\n\ngoal (1 subgoal):\n 1. [] \\<in> WW'", "by (auto simp: WW'_def WW_seg_def)"], ["proof (state)\nthis:\n  [] \\<in> WW'\n\ngoal (2 subgoals):\n 1. bij_betw h WW WW'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> WW; b \\<in> WW\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> Restr (lenlex less_than) WW) =\n                         ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "let ?g = \"\\<lambda>l. if l=[] then l else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\""], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw h WW WW'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> WW; b \\<in> WW\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> Restr (lenlex less_than) WW) =\n                         ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "have h_seg_iff: \"\\<And>n a b. \\<lbrakk>a \\<in> WW_seg n; b \\<in> WW_seg n; n>0\\<rbrakk> \\<Longrightarrow>\n                          (a, b) \\<in> lenlex less_than \\<longleftrightarrow>\n                          (h_seg n a, h_seg n b) \\<in> lenlex less_than \\<and> h_seg n a \\<in> W' n \\<and> h_seg n b \\<in> W' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       \\<lbrakk>a \\<in> WW_seg n; b \\<in> WW_seg n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> lenlex less_than) =\n                         ((h_seg n a, h_seg n b)\n                          \\<in> lenlex less_than \\<and>\n                          h_seg n a \\<in> W' n \\<and> h_seg n b \\<in> W' n)", "using h_seg"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> iso_ll (WW_seg ?n) (W' ?n) (h_seg ?n)\n\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       \\<lbrakk>a \\<in> WW_seg n; b \\<in> WW_seg n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> lenlex less_than) =\n                         ((h_seg n a, h_seg n b)\n                          \\<in> lenlex less_than \\<and>\n                          h_seg n a \\<in> W' n \\<and> h_seg n b \\<in> W' n)", "by (auto simp: iso_ll_def iso_iff2 FR_W FR_W')"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> WW_seg ?n; ?b \\<in> WW_seg ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> ((?a, ?b) \\<in> lenlex less_than) =\n                    ((h_seg ?n ?a, h_seg ?n ?b)\n                     \\<in> lenlex less_than \\<and>\n                     h_seg ?n ?a \\<in> W' ?n \\<and> h_seg ?n ?b \\<in> W' ?n)\n\ngoal (2 subgoals):\n 1. bij_betw h WW WW'\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> WW; b \\<in> WW\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> Restr (lenlex less_than) WW) =\n                         ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "show \"bij_betw h WW WW'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw h WW WW'", "unfolding bij_betw_iff_bijections"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (\\<forall>x\\<in>WW. h x \\<in> WW' \\<and> g (h x) = x) \\<and>\n       (\\<forall>y\\<in>WW'. g y \\<in> WW \\<and> h (g y) = y)", "proof (intro exI conjI ballI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> WW \\<Longrightarrow> h x \\<in> WW'\n 2. \\<And>x. x \\<in> WW \\<Longrightarrow> ?g (h x) = x\n 3. \\<And>y. y \\<in> WW' \\<Longrightarrow> ?g y \\<in> WW\n 4. \\<And>y. y \\<in> WW' \\<Longrightarrow> h (?g y) = y", "fix l"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> WW \\<Longrightarrow> h x \\<in> WW'\n 2. \\<And>x. x \\<in> WW \\<Longrightarrow> ?g (h x) = x\n 3. \\<And>y. y \\<in> WW' \\<Longrightarrow> ?g y \\<in> WW\n 4. \\<And>y. y \\<in> WW' \\<Longrightarrow> h (?g y) = y", "assume \"l \\<in> WW\""], ["proof (state)\nthis:\n  l \\<in> WW\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> WW \\<Longrightarrow> h x \\<in> WW'\n 2. \\<And>x. x \\<in> WW \\<Longrightarrow> ?g (h x) = x\n 3. \\<And>y. y \\<in> WW' \\<Longrightarrow> ?g y \\<in> WW\n 4. \\<And>y. y \\<in> WW' \\<Longrightarrow> h (?g y) = y", "then"], ["proof (chain)\npicking this:\n  l \\<in> WW", "have l: \"l \\<in> WW_seg (length l)\""], ["proof (prove)\nusing this:\n  l \\<in> WW\n\ngoal (1 subgoal):\n 1. l \\<in> WW_seg (length l)", "by (simp add: WW_seg_def)"], ["proof (state)\nthis:\n  l \\<in> WW_seg (length l)\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> WW \\<Longrightarrow> h x \\<in> WW'\n 2. \\<And>x. x \\<in> WW \\<Longrightarrow> ?g (h x) = x\n 3. \\<And>y. y \\<in> WW' \\<Longrightarrow> ?g y \\<in> WW\n 4. \\<And>y. y \\<in> WW' \\<Longrightarrow> h (?g y) = y", "have \"h l \\<in> W' (length l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h l \\<in> W' (length l)", "proof (cases \"l=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow> h l \\<in> W' (length l)\n 2. l \\<noteq> [] \\<Longrightarrow> h l \\<in> W' (length l)", "case True"], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow> h l \\<in> W' (length l)\n 2. l \\<noteq> [] \\<Longrightarrow> h l \\<in> W' (length l)", "with seg_W' [of 0] W'_ne"], ["proof (chain)\npicking this:\n  W' 0 \\<subseteq> WW_seg (0 * m)\n  W' ?n \\<noteq> {}\n  l = []", "show ?thesis"], ["proof (prove)\nusing this:\n  W' 0 \\<subseteq> WW_seg (0 * m)\n  W' ?n \\<noteq> {}\n  l = []\n\ngoal (1 subgoal):\n 1. h l \\<in> W' (length l)", "by (auto simp: WW_seg_def h_def)"], ["proof (state)\nthis:\n  h l \\<in> W' (length l)\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> h l \\<in> W' (length l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> h l \\<in> W' (length l)", "case False"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> h l \\<in> W' (length l)", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. h l \\<in> W' (length l)", "using bij_betwE bij_h_seg h_def l"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n  0 < ?n \\<Longrightarrow> bij_betw (h_seg ?n) (WW_seg ?n) (W' ?n)\n  h \\<equiv> \\<lambda>l. if l = [] then [] else h_seg (length l) l\n  l \\<in> WW_seg (length l)\n\ngoal (1 subgoal):\n 1. h l \\<in> W' (length l)", "by fastforce"], ["proof (state)\nthis:\n  h l \\<in> W' (length l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h l \\<in> W' (length l)\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> WW \\<Longrightarrow> h x \\<in> WW'\n 2. \\<And>x. x \\<in> WW \\<Longrightarrow> ?g (h x) = x\n 3. \\<And>y. y \\<in> WW' \\<Longrightarrow> ?g y \\<in> WW\n 4. \\<And>y. y \\<in> WW' \\<Longrightarrow> h (?g y) = y", "show \"h l \\<in> WW'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h l \\<in> WW'", "using WW'_def \\<open>h l \\<in> W' (length l)\\<close>"], ["proof (prove)\nusing this:\n  WW' \\<equiv> \\<Union> (range W')\n  h l \\<in> W' (length l)\n\ngoal (1 subgoal):\n 1. h l \\<in> WW'", "by blast"], ["proof (state)\nthis:\n  h l \\<in> WW'\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> WW \\<Longrightarrow> ?g (h x) = x\n 2. \\<And>y. y \\<in> WW' \\<Longrightarrow> ?g y \\<in> WW\n 3. \\<And>y. y \\<in> WW' \\<Longrightarrow> h (?g y) = y", "show \"?g (h l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l", "proof (cases \"l=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l\n 2. l \\<noteq> [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l", "case False"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l\n 2. l \\<noteq> [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "have \"length l > 0\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length l", "by auto"], ["proof (state)\nthis:\n  0 < length l\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l\n 2. l \\<noteq> [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l", "then"], ["proof (chain)\npicking this:\n  0 < length l", "have \"h_seg (length l) l \\<noteq> []\""], ["proof (prove)\nusing this:\n  0 < length l\n\ngoal (1 subgoal):\n 1. h_seg (length l) l \\<noteq> []", "using \\<open>1 < m\\<close> \\<open>l \\<in> WW\\<close> len_h_seg"], ["proof (prove)\nusing this:\n  0 < length l\n  1 < m\n  l \\<in> WW\n  \\<lbrakk>0 < length ?l; ?l \\<in> WW\\<rbrakk>\n  \\<Longrightarrow> length (h_seg (length ?l) ?l) = length ?l * m\n\ngoal (1 subgoal):\n 1. h_seg (length l) l \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  h_seg (length l) l \\<noteq> []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l\n 2. l \\<noteq> [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l", "with \\<open>1 < m\\<close>"], ["proof (chain)\npicking this:\n  1 < m\n  h_seg (length l) l \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < m\n  h_seg (length l) l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l", "apply (simp add: h_def len_h_seg \\<open>l \\<in> WW\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < m; h_seg (length l) l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> l \\<noteq> [] \\<longrightarrow>\n                      inv_into (WW_seg (length l)) (h_seg (length l))\n                       (h_seg (length l) l) =\n                      l", "by (meson \\<open>0 < length l\\<close> bij_betw_inv_into_left bij_h_seg l)"], ["proof (state)\nthis:\n  (if h l = [] then h l\n   else inv_into (WW_seg (length (h l) div m)) (h_seg (length (h l) div m))\n         (h l)) =\n  l\n\ngoal (1 subgoal):\n 1. l = [] \\<Longrightarrow>\n    (if h l = [] then h l\n     else inv_into (WW_seg (length (h l) div m))\n           (h_seg (length (h l) div m)) (h l)) =\n    l", "qed (auto simp: h_def)"], ["proof (state)\nthis:\n  (if h l = [] then h l\n   else inv_into (WW_seg (length (h l) div m)) (h_seg (length (h l) div m))\n         (h l)) =\n  l\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       (if y = [] then y\n        else inv_into (WW_seg (length y div m)) (h_seg (length y div m)) y)\n       \\<in> WW\n 2. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       h (if y = [] then y\n          else inv_into (WW_seg (length y div m)) (h_seg (length y div m))\n                y) =\n       y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       (if y = [] then y\n        else inv_into (WW_seg (length y div m)) (h_seg (length y div m)) y)\n       \\<in> WW\n 2. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       h (if y = [] then y\n          else inv_into (WW_seg (length y div m)) (h_seg (length y div m))\n                y) =\n       y", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       (if y = [] then y\n        else inv_into (WW_seg (length y div m)) (h_seg (length y div m)) y)\n       \\<in> WW\n 2. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       h (if y = [] then y\n          else inv_into (WW_seg (length y div m)) (h_seg (length y div m))\n                y) =\n       y", "assume \"l \\<in> WW'\""], ["proof (state)\nthis:\n  l \\<in> WW'\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       (if y = [] then y\n        else inv_into (WW_seg (length y div m)) (h_seg (length y div m)) y)\n       \\<in> WW\n 2. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       h (if y = [] then y\n          else inv_into (WW_seg (length y div m)) (h_seg (length y div m))\n                y) =\n       y", "then"], ["proof (chain)\npicking this:\n  l \\<in> WW'", "have l: \"l \\<in> W' (length l div m)\""], ["proof (prove)\nusing this:\n  l \\<in> WW'\n\ngoal (1 subgoal):\n 1. l \\<in> W' (length l div m)", "using WW_seg_def \\<open>1 < m\\<close> seg_W'"], ["proof (prove)\nusing this:\n  l \\<in> WW'\n  WW_seg ?n \\<equiv> {l \\<in> WW. length l = ?n}\n  1 < m\n  W' ?n \\<subseteq> WW_seg (?n * m)\n\ngoal (1 subgoal):\n 1. l \\<in> W' (length l div m)", "by (fastforce simp: WW'_def)"], ["proof (state)\nthis:\n  l \\<in> W' (length l div m)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       (if y = [] then y\n        else inv_into (WW_seg (length y div m)) (h_seg (length y div m)) y)\n       \\<in> WW\n 2. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       h (if y = [] then y\n          else inv_into (WW_seg (length y div m)) (h_seg (length y div m))\n                y) =\n       y", "show \"?g l \\<in> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW", "proof (cases \"l=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW\n 2. l \\<noteq> [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW", "case False"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW\n 2. l \\<noteq> [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "have \"l \\<notin> W' 0\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<notin> W' 0", "using WW_seg_def seg_W'"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  WW_seg ?n \\<equiv> {l \\<in> WW. length l = ?n}\n  W' ?n \\<subseteq> WW_seg (?n * m)\n\ngoal (1 subgoal):\n 1. l \\<notin> W' 0", "by fastforce"], ["proof (state)\nthis:\n  l \\<notin> W' 0\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW\n 2. l \\<noteq> [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW", "with l"], ["proof (chain)\npicking this:\n  l \\<in> W' (length l div m)\n  l \\<notin> W' 0", "have \"inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l \\<in> WW_seg (length l div m)\""], ["proof (prove)\nusing this:\n  l \\<in> W' (length l div m)\n  l \\<notin> W' 0\n\ngoal (1 subgoal):\n 1. inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n    \\<in> WW_seg (length l div m)", "by (metis Nat.neq0_conv bij_betwE bij_betw_inv_into bij_h_seg)"], ["proof (state)\nthis:\n  inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n  \\<in> WW_seg (length l div m)\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW\n 2. l \\<noteq> [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW", "then"], ["proof (chain)\npicking this:\n  inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n  \\<in> WW_seg (length l div m)", "show ?thesis"], ["proof (prove)\nusing this:\n  inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n  \\<in> WW_seg (length l div m)\n\ngoal (1 subgoal):\n 1. (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW", "using False WW_seg_subset_WW"], ["proof (prove)\nusing this:\n  inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n  \\<in> WW_seg (length l div m)\n  l \\<noteq> []\n  WW_seg ?n \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW", "by auto"], ["proof (state)\nthis:\n  (if l = [] then l\n   else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n  \\<in> WW\n\ngoal (1 subgoal):\n 1. l = [] \\<Longrightarrow>\n    (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n    \\<in> WW", "qed (auto simp: WW_def)"], ["proof (state)\nthis:\n  (if l = [] then l\n   else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l)\n  \\<in> WW\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> WW' \\<Longrightarrow>\n       h (if y = [] then y\n          else inv_into (WW_seg (length y div m)) (h_seg (length y div m))\n                y) =\n       y", "show \"h (?g l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l", "proof (cases \"l=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l\n 2. l \\<noteq> [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l", "case False"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l\n 2. l \\<noteq> [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "have \"0 < length l div m\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length l div m", "using WW_seg_def l seg_W'"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  WW_seg ?n \\<equiv> {l \\<in> WW. length l = ?n}\n  l \\<in> W' (length l div m)\n  W' ?n \\<subseteq> WW_seg (?n * m)\n\ngoal (1 subgoal):\n 1. 0 < length l div m", "by fastforce"], ["proof (state)\nthis:\n  0 < length l div m\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l\n 2. l \\<noteq> [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l", "then"], ["proof (chain)\npicking this:\n  0 < length l div m", "have \"inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l \\<in> WW_seg (length l div m)\""], ["proof (prove)\nusing this:\n  0 < length l div m\n\ngoal (1 subgoal):\n 1. inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n    \\<in> WW_seg (length l div m)", "by (metis bij_betw_imp_surj_on bij_h_seg inv_into_into l)"], ["proof (state)\nthis:\n  inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n  \\<in> WW_seg (length l div m)\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l\n 2. l \\<noteq> [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l", "then"], ["proof (chain)\npicking this:\n  inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n  \\<in> WW_seg (length l div m)", "show ?thesis"], ["proof (prove)\nusing this:\n  inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n  \\<in> WW_seg (length l div m)\n\ngoal (1 subgoal):\n 1. h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l", "using bij_h_seg [of \"length l div m\"] WW_seg_def \\<open>0 < length l div m\\<close> bij_betw_inv_into_right l"], ["proof (prove)\nusing this:\n  inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l\n  \\<in> WW_seg (length l div m)\n  0 < length l div m \\<Longrightarrow>\n  bij_betw (h_seg (length l div m)) (WW_seg (length l div m))\n   (W' (length l div m))\n  WW_seg ?n \\<equiv> {l \\<in> WW. length l = ?n}\n  0 < length l div m\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a' \\<in> ?A'\\<rbrakk>\n  \\<Longrightarrow> ?f (inv_into ?A ?f ?a') = ?a'\n  l \\<in> W' (length l div m)\n\ngoal (1 subgoal):\n 1. h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l", "by (fastforce simp add: h_def)"], ["proof (state)\nthis:\n  h (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n  l\n\ngoal (1 subgoal):\n 1. l = [] \\<Longrightarrow>\n    h (if l = [] then l\n       else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n    l", "qed (auto simp: h_def)"], ["proof (state)\nthis:\n  h (if l = [] then l\n     else inv_into (WW_seg (length l div m)) (h_seg (length l div m)) l) =\n  l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw h WW WW'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> WW; b \\<in> WW\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> Restr (lenlex less_than) WW) =\n                         ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> WW; b \\<in> WW\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> Restr (lenlex less_than) WW) =\n                         ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "assume \"a \\<in> WW\" \"b \\<in> WW\""], ["proof (state)\nthis:\n  a \\<in> WW\n  b \\<in> WW\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> WW; b \\<in> WW\\<rbrakk>\n       \\<Longrightarrow> ((a, b) \\<in> Restr (lenlex less_than) WW) =\n                         ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "show \"(a, b) \\<in> Restr (lenlex less_than) WW \\<longleftrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'\"\n          (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> Restr (lenlex less_than) WW) =\n    ((h a, h b) \\<in> Restr (lenlex less_than) WW')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (a, b) \\<in> Restr (lenlex less_than) WW \\<Longrightarrow>\n    (h a, h b) \\<in> Restr (lenlex less_than) WW'\n 2. (h a, h b) \\<in> Restr (lenlex less_than) WW' \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW", "assume L: ?lhs"], ["proof (state)\nthis:\n  (a, b) \\<in> Restr (lenlex less_than) WW\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> Restr (lenlex less_than) WW \\<Longrightarrow>\n    (h a, h b) \\<in> Restr (lenlex less_than) WW'\n 2. (h a, h b) \\<in> Restr (lenlex less_than) WW' \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> Restr (lenlex less_than) WW", "consider \"length a < length b\" | \"length a = length b\" \"(a, b) \\<in> lex less_than\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> Restr (lenlex less_than) WW\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a < length b \\<Longrightarrow> thesis;\n     \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: lenlex_conv)"], ["proof (state)\nthis:\n  \\<lbrakk>length a < length b \\<Longrightarrow> ?thesis;\n   \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> Restr (lenlex less_than) WW \\<Longrightarrow>\n    (h a, h b) \\<in> Restr (lenlex less_than) WW'\n 2. (h a, h b) \\<in> Restr (lenlex less_than) WW' \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length a < length b \\<Longrightarrow> ?thesis;\n   \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?rhs"], ["proof (prove)\nusing this:\n  \\<lbrakk>length a < length b \\<Longrightarrow> ?thesis;\n   \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. length a < length b \\<Longrightarrow>\n    (h a, h b) \\<in> Restr (lenlex less_than) WW'\n 2. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "case 1"], ["proof (state)\nthis:\n  length a < length b\n\ngoal (2 subgoals):\n 1. length a < length b \\<Longrightarrow>\n    (h a, h b) \\<in> Restr (lenlex less_than) WW'\n 2. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "then"], ["proof (chain)\npicking this:\n  length a < length b", "have \"length (h a) < length (h b)\""], ["proof (prove)\nusing this:\n  length a < length b\n\ngoal (1 subgoal):\n 1. length (h a) < length (h b)", "using \\<open>1 < m\\<close> \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close> h_def len_h_seg"], ["proof (prove)\nusing this:\n  length a < length b\n  1 < m\n  a \\<in> WW\n  b \\<in> WW\n  h \\<equiv> \\<lambda>l. if l = [] then [] else h_seg (length l) l\n  \\<lbrakk>0 < length ?l; ?l \\<in> WW\\<rbrakk>\n  \\<Longrightarrow> length (h_seg (length ?l) ?l) = length ?l * m\n\ngoal (1 subgoal):\n 1. length (h a) < length (h b)", "by auto"], ["proof (state)\nthis:\n  length (h a) < length (h b)\n\ngoal (2 subgoals):\n 1. length a < length b \\<Longrightarrow>\n    (h a, h b) \\<in> Restr (lenlex less_than) WW'\n 2. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "then"], ["proof (chain)\npicking this:\n  length (h a) < length (h b)", "have \"(h a, h b) \\<in> lenlex less_than\""], ["proof (prove)\nusing this:\n  length (h a) < length (h b)\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> lenlex less_than", "by (auto simp: lenlex_conv)"], ["proof (state)\nthis:\n  (h a, h b) \\<in> lenlex less_than\n\ngoal (2 subgoals):\n 1. length a < length b \\<Longrightarrow>\n    (h a, h b) \\<in> Restr (lenlex less_than) WW'\n 2. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "then"], ["proof (chain)\npicking this:\n  (h a, h b) \\<in> lenlex less_than", "show ?thesis"], ["proof (prove)\nusing this:\n  (h a, h b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW'", "using \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close> \\<open>bij_betw h WW WW'\\<close> bij_betwE"], ["proof (prove)\nusing this:\n  (h a, h b) \\<in> lenlex less_than\n  a \\<in> WW\n  b \\<in> WW\n  bij_betw h WW WW'\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW'", "by fastforce"], ["proof (state)\nthis:\n  (h a, h b) \\<in> Restr (lenlex less_than) WW'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "case 2"], ["proof (state)\nthis:\n  length a = length b\n  (a, b) \\<in> lex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "then"], ["proof (chain)\npicking this:\n  length a = length b\n  (a, b) \\<in> lex less_than", "have ab: \"a \\<in> WW_seg (length a)\" \"b \\<in> WW_seg (length a)\""], ["proof (prove)\nusing this:\n  length a = length b\n  (a, b) \\<in> lex less_than\n\ngoal (1 subgoal):\n 1. a \\<in> WW_seg (length a) &&& b \\<in> WW_seg (length a)", "using \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close>"], ["proof (prove)\nusing this:\n  length a = length b\n  (a, b) \\<in> lex less_than\n  a \\<in> WW\n  b \\<in> WW\n\ngoal (1 subgoal):\n 1. a \\<in> WW_seg (length a) &&& b \\<in> WW_seg (length a)", "by (auto simp: WW_seg_def)"], ["proof (state)\nthis:\n  a \\<in> WW_seg (length a)\n  b \\<in> WW_seg (length a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "have \"length (h a) = length (h b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (h a) = length (h b)", "using 2 \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close> h_def len_h_seg"], ["proof (prove)\nusing this:\n  length a = length b\n  (a, b) \\<in> lex less_than\n  a \\<in> WW\n  b \\<in> WW\n  h \\<equiv> \\<lambda>l. if l = [] then [] else h_seg (length l) l\n  \\<lbrakk>0 < length ?l; ?l \\<in> WW\\<rbrakk>\n  \\<Longrightarrow> length (h_seg (length ?l) ?l) = length ?l * m\n\ngoal (1 subgoal):\n 1. length (h a) = length (h b)", "by force"], ["proof (state)\nthis:\n  length (h a) = length (h b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "moreover"], ["proof (state)\nthis:\n  length (h a) = length (h b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "have \"(a, b) \\<in> lenlex less_than\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> lenlex less_than", "using L"], ["proof (prove)\nusing this:\n  (a, b) \\<in> Restr (lenlex less_than) WW\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> lenlex less_than", "by blast"], ["proof (state)\nthis:\n  (a, b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> lenlex less_than", "have \"(h_seg (length a) a, h_seg (length a) b) \\<in> lenlex less_than\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (h_seg (length a) a, h_seg (length a) b) \\<in> lenlex less_than", "using 2 ab h_seg_iff"], ["proof (prove)\nusing this:\n  (a, b) \\<in> lenlex less_than\n  length a = length b\n  (a, b) \\<in> lex less_than\n  a \\<in> WW_seg (length a)\n  b \\<in> WW_seg (length a)\n  \\<lbrakk>?a \\<in> WW_seg ?n; ?b \\<in> WW_seg ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> ((?a, ?b) \\<in> lenlex less_than) =\n                    ((h_seg ?n ?a, h_seg ?n ?b)\n                     \\<in> lenlex less_than \\<and>\n                     h_seg ?n ?a \\<in> W' ?n \\<and> h_seg ?n ?b \\<in> W' ?n)\n\ngoal (1 subgoal):\n 1. (h_seg (length a) a, h_seg (length a) b) \\<in> lenlex less_than", "by blast"], ["proof (state)\nthis:\n  (h_seg (length a) a, h_seg (length a) b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (a, b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (h a, h b) \\<in> Restr (lenlex less_than) WW'", "ultimately"], ["proof (chain)\npicking this:\n  length (h a) = length (h b)\n  (h_seg (length a) a, h_seg (length a) b) \\<in> lenlex less_than", "show ?thesis"], ["proof (prove)\nusing this:\n  length (h a) = length (h b)\n  (h_seg (length a) a, h_seg (length a) b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW'", "using 2 \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close> \\<open>bij_betw h WW WW'\\<close> bij_betwE h_def"], ["proof (prove)\nusing this:\n  length (h a) = length (h b)\n  (h_seg (length a) a, h_seg (length a) b) \\<in> lenlex less_than\n  length a = length b\n  (a, b) \\<in> lex less_than\n  a \\<in> WW\n  b \\<in> WW\n  bij_betw h WW WW'\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n  h \\<equiv> \\<lambda>l. if l = [] then [] else h_seg (length l) l\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW'", "by fastforce"], ["proof (state)\nthis:\n  (h a, h b) \\<in> Restr (lenlex less_than) WW'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (h a, h b) \\<in> Restr (lenlex less_than) WW'\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW' \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW' \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW", "assume R: ?rhs"], ["proof (state)\nthis:\n  (h a, h b) \\<in> Restr (lenlex less_than) WW'\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW' \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  (h a, h b) \\<in> Restr (lenlex less_than) WW'", "have R': \"(h a, h b) \\<in> lenlex less_than\""], ["proof (prove)\nusing this:\n  (h a, h b) \\<in> Restr (lenlex less_than) WW'\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> lenlex less_than", "by blast"], ["proof (state)\nthis:\n  (h a, h b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW' \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  (h a, h b) \\<in> lenlex less_than", "consider \"length a < length b\"\n            | \"length a = length b\" \"(h a, h b) \\<in> lex less_than\""], ["proof (prove)\nusing this:\n  (h a, h b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a < length b \\<Longrightarrow> thesis;\n     \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using  \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close> \\<open>m > 1\\<close>"], ["proof (prove)\nusing this:\n  (h a, h b) \\<in> lenlex less_than\n  a \\<in> WW\n  b \\<in> WW\n  1 < m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a < length b \\<Longrightarrow> thesis;\n     \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: lenlex_conv h_def len_h_seg split: if_split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>length a < length b \\<Longrightarrow> ?thesis;\n   \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (h a, h b) \\<in> Restr (lenlex less_than) WW' \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length a < length b \\<Longrightarrow> ?thesis;\n   \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<lbrakk>length a < length b \\<Longrightarrow> ?thesis;\n   \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> Restr (lenlex less_than) WW", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. length a < length b \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW\n 2. \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> Restr (lenlex less_than) WW", "case 1"], ["proof (state)\nthis:\n  length a < length b\n\ngoal (2 subgoals):\n 1. length a < length b \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW\n 2. \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  length a < length b", "have \"(a, b) \\<in> lenlex less_than\""], ["proof (prove)\nusing this:\n  length a < length b\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> lenlex less_than", "using omega_sum_less_iff"], ["proof (prove)\nusing this:\n  length a < length b\n  (((length ?ms, omega_sum ?ms), length ?ns, omega_sum ?ns)\n   \\<in> less_than <*lex*> VWF) =\n  ((?ms, ?ns) \\<in> lenlex less_than)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> lenlex less_than", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> lenlex less_than\n\ngoal (2 subgoals):\n 1. length a < length b \\<Longrightarrow>\n    (a, b) \\<in> Restr (lenlex less_than) WW\n 2. \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> lenlex less_than", "show ?thesis"], ["proof (prove)\nusing this:\n  (a, b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> Restr (lenlex less_than) WW", "by (simp add: \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close>)"], ["proof (state)\nthis:\n  (a, b) \\<in> Restr (lenlex less_than) WW\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> Restr (lenlex less_than) WW", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> Restr (lenlex less_than) WW", "case 2"], ["proof (state)\nthis:\n  length a = length b\n  (h a, h b) \\<in> lex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  length a = length b\n  (h a, h b) \\<in> lex less_than", "have ab: \"a \\<in> WW_seg (length a)\" \"b \\<in> WW_seg (length a)\""], ["proof (prove)\nusing this:\n  length a = length b\n  (h a, h b) \\<in> lex less_than\n\ngoal (1 subgoal):\n 1. a \\<in> WW_seg (length a) &&& b \\<in> WW_seg (length a)", "using \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close>"], ["proof (prove)\nusing this:\n  length a = length b\n  (h a, h b) \\<in> lex less_than\n  a \\<in> WW\n  b \\<in> WW\n\ngoal (1 subgoal):\n 1. a \\<in> WW_seg (length a) &&& b \\<in> WW_seg (length a)", "by (auto simp: WW_seg_def)"], ["proof (state)\nthis:\n  a \\<in> WW_seg (length a)\n  b \\<in> WW_seg (length a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  a \\<in> WW_seg (length a)\n  b \\<in> WW_seg (length a)", "have \"(a, b) \\<in> lenlex less_than\""], ["proof (prove)\nusing this:\n  a \\<in> WW_seg (length a)\n  b \\<in> WW_seg (length a)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> lenlex less_than", "using bij_betwE [OF bij_h_seg] \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close> R' 2"], ["proof (prove)\nusing this:\n  a \\<in> WW_seg (length a)\n  b \\<in> WW_seg (length a)\n  0 < ?n1 \\<Longrightarrow>\n  \\<forall>a\\<in>WW_seg ?n1. h_seg ?n1 a \\<in> W' ?n1\n  a \\<in> WW\n  b \\<in> WW\n  (h a, h b) \\<in> lenlex less_than\n  length a = length b\n  (h a, h b) \\<in> lex less_than\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> lenlex less_than", "by (simp add: h_def h_seg_iff split: if_split_asm)"], ["proof (state)\nthis:\n  (a, b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b; (h a, h b) \\<in> lex less_than\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> Restr (lenlex less_than) WW", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> lenlex less_than", "show ?thesis"], ["proof (prove)\nusing this:\n  (a, b) \\<in> lenlex less_than\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> Restr (lenlex less_than) WW", "using \\<open>a \\<in> WW\\<close> \\<open>b \\<in> WW\\<close>"], ["proof (prove)\nusing this:\n  (a, b) \\<in> lenlex less_than\n  a \\<in> WW\n  b \\<in> WW\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> Restr (lenlex less_than) WW", "by blast"], ["proof (state)\nthis:\n  (a, b) \\<in> Restr (lenlex less_than) WW\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b) \\<in> Restr (lenlex less_than) WW\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((a, b) \\<in> Restr (lenlex less_than) WW) =\n  ((h a, h b) \\<in> Restr (lenlex less_than) WW')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  iso_ll WW WW' h\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "let ?fh = \"f \\<circ> image h\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have \"bij_betw h WW WW'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw h WW WW'", "using h"], ["proof (prove)\nusing this:\n  iso_ll WW WW' h\n\ngoal (1 subgoal):\n 1. bij_betw h WW WW'", "unfolding iso_ll_def iso_iff2"], ["proof (prove)\nusing this:\n  bij_betw h (Field (Restr (lenlex less_than) WW))\n   (Field (Restr (lenlex less_than) WW')) \\<and>\n  (\\<forall>a\\<in>Field (Restr (lenlex less_than) WW).\n      \\<forall>b\\<in>Field (Restr (lenlex less_than) WW).\n         ((a, b) \\<in> Restr (lenlex less_than) WW) =\n         ((h a, h b) \\<in> Restr (lenlex less_than) WW'))\n\ngoal (1 subgoal):\n 1. bij_betw h WW WW'", "by (fastforce simp: FR_WW FR_WW')"], ["proof (state)\nthis:\n  bij_betw h WW WW'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "moreover"], ["proof (state)\nthis:\n  bij_betw h WW WW'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have \"{..<Suc (Suc 0)} = {0,1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<Suc (Suc 0)} = {0, 1}", "by auto"], ["proof (state)\nthis:\n  {..<Suc (Suc 0)} = {0, 1}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "ultimately"], ["proof (chain)\npicking this:\n  bij_betw h WW WW'\n  {..<Suc (Suc 0)} = {0, 1}", "have fh: \"?fh \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {0,1}\""], ["proof (prove)\nusing this:\n  bij_betw h WW WW'\n  {..<Suc (Suc 0)} = {0, 1}\n\ngoal (1 subgoal):\n 1. f \\<circ> (`) h \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {0, 1}", "unfolding Pi_iff"], ["proof (prove)\nusing this:\n  bij_betw h WW WW'\n  {..<Suc (Suc 0)} = {0, 1}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>[WW]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) i \\<in> {0, 1}", "using bij_betwE f' bij_betw_nsets"], ["proof (prove)\nusing this:\n  bij_betw h WW WW'\n  {..<Suc (Suc 0)} = {0, 1}\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n  f \\<in> [WW']\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n  bij_betw ?f ?A ?B \\<Longrightarrow>\n  bij_betw ((`) ?f) ([?A]\\<^bsup>?n\\<^esup>) ([?B]\\<^bsup>?n\\<^esup>)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>[WW]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) i \\<in> {0, 1}", "by (metis PiE comp_apply)"], ["proof (state)\nthis:\n  f \\<circ> (`) h \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {0, 1}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have \"f{x,y} = 0\" if \"x \\<in> WW'\" \"y \\<in> WW'\" \"length x = length y\" \"x \\<noteq> y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f {x, y} = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f {x, y} = 0", "obtain p q where \"x \\<in> W' p\" and \"y \\<in> W' q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>x \\<in> W' p; y \\<in> W' q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using WW'_def \\<open>x \\<in> WW'\\<close> \\<open>y \\<in> WW'\\<close>"], ["proof (prove)\nusing this:\n  WW' \\<equiv> \\<Union> (range W')\n  x \\<in> WW'\n  y \\<in> WW'\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>x \\<in> W' p; y \\<in> W' q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> W' p\n  y \\<in> W' q\n\ngoal (1 subgoal):\n 1. f {x, y} = 0", "then"], ["proof (chain)\npicking this:\n  x \\<in> W' p\n  y \\<in> W' q", "obtain n where \"{x,y} \\<in> [W' n]\\<^bsup>2\\<^esup>\""], ["proof (prove)\nusing this:\n  x \\<in> W' p\n  y \\<in> W' q\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        {x, y} \\<in> [W' n]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using seg_W' \\<open>1 < m\\<close> \\<open>length x = length y\\<close> \\<open>x \\<noteq> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> W' p\n  y \\<in> W' q\n  W' ?n \\<subseteq> WW_seg (?n * m)\n  1 < m\n  length x = length y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        {x, y} \\<in> [W' n]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: WW'_def WW_seg_def subset_iff)"], ["proof (state)\nthis:\n  {x, y} \\<in> [W' n]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. f {x, y} = 0", "then"], ["proof (chain)\npicking this:\n  {x, y} \\<in> [W' n]\\<^bsup>2\\<^esup>", "show \"f{x,y} = 0\""], ["proof (prove)\nusing this:\n  {x, y} \\<in> [W' n]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. f {x, y} = 0", "using f_W'"], ["proof (prove)\nusing this:\n  {x, y} \\<in> [W' n]\\<^bsup>2\\<^esup>\n  f ` [W' ?n]\\<^bsup>2\\<^esup> \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. f {x, y} = 0", "by blast"], ["proof (state)\nthis:\n  f {x, y} = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> WW'; ?y \\<in> WW'; length ?x = length ?y;\n   ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> f {?x, ?y} = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> WW'; ?y \\<in> WW'; length ?x = length ?y;\n   ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> f {?x, ?y} = 0", "have fh_eq_0_eqlen: \"?fh{x,y} = 0\" if \"x \\<in> WW\" \"y \\<in> WW\" \"length x = length y\" \"x \\<noteq> y\" for x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> WW'; ?y \\<in> WW'; length ?x = length ?y;\n   ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> f {?x, ?y} = 0\n\ngoal (1 subgoal):\n 1. (f \\<circ> (`) h) {x, y} = 0", "using  \\<open>bij_betw h WW WW'\\<close>  that hlen"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> WW'; ?y \\<in> WW'; length ?x = length ?y;\n   ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> f {?x, ?y} = 0\n  bij_betw h WW WW'\n  x \\<in> WW\n  y \\<in> WW\n  length x = length y\n  x \\<noteq> y\n  \\<lbrakk>?x \\<in> WW; ?y \\<in> WW\\<rbrakk>\n  \\<Longrightarrow> (length (h ?x) = length (h ?y)) =\n                    (length ?x = length ?y)\n\ngoal (1 subgoal):\n 1. (f \\<circ> (`) h) {x, y} = 0", "by (simp add: bij_betw_iff_bijections) metis"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> WW; ?y \\<in> WW; length ?x = length ?y;\n   ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> (f \\<circ> (`) h) {?x, ?y} = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have m_f_0: \"\\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x = 0\" if \"M \\<subseteq> WW\" \"card M = m\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x = 0", "have \"finite M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite M", "using False m that"], ["proof (prove)\nusing this:\n  \\<not> \\<alpha> \\<le> 1\n  \\<alpha> = ord_of_nat m\n  M \\<subseteq> WW\n  card M = m\n\ngoal (1 subgoal):\n 1. finite M", "by auto"], ["proof (state)\nthis:\n  finite M\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x = 0", "with not1 [simplified, rule_format, of M] f"], ["proof (chain)\npicking this:\n  \\<lbrakk>ordertype M (lenlex less_than) = \\<alpha>;\n   M \\<subseteq> WW\\<rbrakk>\n  \\<Longrightarrow> \\<not> f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {Suc 0}\n  f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n  finite M", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ordertype M (lenlex less_than) = \\<alpha>;\n   M \\<subseteq> WW\\<rbrakk>\n  \\<Longrightarrow> \\<not> f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {Suc 0}\n  f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n  finite M\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x = 0", "using that \\<open>1 < m\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>ordertype M (lenlex less_than) = \\<alpha>;\n   M \\<subseteq> WW\\<rbrakk>\n  \\<Longrightarrow> \\<not> f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {Suc 0}\n  f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow> {..<Suc (Suc 0)}\n  finite M\n  M \\<subseteq> WW\n  card M = m\n  1 < m\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x = 0", "apply (simp add: Pi_iff image_subset_iff finite_ordertype_eq_card m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x \\<noteq> Suc 0;\n     \\<forall>i\\<in>[WW]\\<^bsup>2\\<^esup>. f i < Suc (Suc 0); finite M;\n     M \\<subseteq> WW; card M = m; Suc 0 < m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x = 0", "by (metis less_2_cases nsets_mono numeral_2_eq_2 subset_iff)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. f x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?M \\<subseteq> WW; card ?M = m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>[?M]\\<^bsup>2\\<^esup>. f x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have m_fh_0: \"\\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. ?fh x = 0\" if \"M \\<subseteq> WW\" \"card M = m\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0", "have \"h ` M \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ` M \\<subseteq> WW", "using \\<open>WW' \\<subseteq> WW\\<close> \\<open>bij_betw h WW WW'\\<close> bij_betwE that(1)"], ["proof (prove)\nusing this:\n  WW' \\<subseteq> WW\n  bij_betw h WW WW'\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n  M \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. h ` M \\<subseteq> WW", "by fastforce"], ["proof (state)\nthis:\n  h ` M \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0", "moreover"], ["proof (state)\nthis:\n  h ` M \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0", "have \"card (h ` M) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (h ` M) = m", "by (metis \\<open>bij_betw h WW WW'\\<close> bij_betw_def bij_betw_subset card_image that)"], ["proof (state)\nthis:\n  card (h ` M) = m\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0", "ultimately"], ["proof (chain)\npicking this:\n  h ` M \\<subseteq> WW\n  card (h ` M) = m", "have \"\\<exists>x \\<in> [h ` M]\\<^bsup>2\\<^esup>. f x = 0\""], ["proof (prove)\nusing this:\n  h ` M \\<subseteq> WW\n  card (h ` M) = m\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[h ` M]\\<^bsup>2\\<^esup>. f x = 0", "by (metis m_f_0)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>[h ` M]\\<^bsup>2\\<^esup>. f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>[h ` M]\\<^bsup>2\\<^esup>. f x = 0", "obtain Y where \"f (h ` Y) = 0\" \"finite Y\" \"card Y = 2\" \"Y \\<subseteq> M\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>[h ` M]\\<^bsup>2\\<^esup>. f x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>f (h ` Y) = 0; finite Y; card Y = 2;\n         Y \\<subseteq> M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (simp add: nsets_def subset_image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Y.\n                \\<lbrakk>f (h ` Y) = 0; finite Y; card Y = 2;\n                 Y \\<subseteq> M\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>x.\n        (\\<exists>AA\\<subseteq>M. x = h ` AA) \\<and>\n        finite x \\<and> card x = 2 \\<and> f x = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis \\<open>M \\<subseteq> WW\\<close> \\<open>bij_betw h WW WW'\\<close> bij_betw_def card_image card.infinite inj_on_subset zero_neq_numeral)"], ["proof (state)\nthis:\n  f (h ` Y) = 0\n  finite Y\n  card Y = 2\n  Y \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0", "then"], ["proof (chain)\npicking this:\n  f (h ` Y) = 0\n  finite Y\n  card Y = 2\n  Y \\<subseteq> M", "show ?thesis"], ["proof (prove)\nusing this:\n  f (h ` Y) = 0\n  finite Y\n  card Y = 2\n  Y \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0", "by (auto simp: nsets_def)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>. (f \\<circ> (`) h) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?M \\<subseteq> WW; card ?M = m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>[?M]\\<^bsup>2\\<^esup>.\n                       (f \\<circ> (`) h) x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "obtain N j where \"infinite N\"\n        and N: \"\\<And>k u. \\<lbrakk>k > 0; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u; [enum N k] < inter_scheme k u; List.set (inter_scheme k u) \\<subseteq> N\\<rbrakk> \\<Longrightarrow> ?fh u = j k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> (f \\<circ> (`) h) u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lemma_3_6 [OF fh]"], ["proof (prove)\nusing this:\n  (\\<And>N j.\n      \\<lbrakk>infinite N;\n       \\<And>k u.\n          \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n           [enum N k] < inter_scheme k u;\n           list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n          \\<Longrightarrow> (f \\<circ> (`) h) u = j k\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>N j.\n        \\<lbrakk>infinite N;\n         \\<And>k u.\n            \\<lbrakk>0 < k; u \\<in> [WW]\\<^bsup>2\\<^esup>; Form k u;\n             [enum N k] < inter_scheme k u;\n             list.set (inter_scheme k u) \\<subseteq> N\\<rbrakk>\n            \\<Longrightarrow> (f \\<circ> (`) h) u = j k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  infinite N\n  \\<lbrakk>0 < ?k; ?u \\<in> [WW]\\<^bsup>2\\<^esup>; Form ?k ?u;\n   [enum N ?k] < inter_scheme ?k ?u;\n   list.set (inter_scheme ?k ?u) \\<subseteq> N\\<rbrakk>\n  \\<Longrightarrow> (f \\<circ> (`) h) ?u = j ?k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have infN': \"infinite (enum N ` {k<..})\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (enum N ` {k<..})", "by (simp add: \\<open>infinite N\\<close> enum_works finite_image_iff infinite_Ioi strict_mono_imp_inj_on)"], ["proof (state)\nthis:\n  infinite (enum N ` {?k<..})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have j_0: \"j k = 0\" if \"k>0\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. j k = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j k = 0", "obtain M where M: \"M \\<in> [WW]\\<^bsup>m\\<^esup>\"\n                 and MF: \"\\<And>u. u \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow> Form k u\"\n                 and Mi: \"\\<And>u. u \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow> List.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n         \\<And>u. u \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow> Form k u;\n         \\<And>u.\n            u \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lemma_3_7 [OF infN' \\<open>k > 0\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>M.\n      \\<lbrakk>M \\<in> [WW]\\<^bsup>?m\\<^esup>;\n       \\<And>U.\n          U \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n          Form k U \\<and>\n          list.set (inter_scheme k U) \\<subseteq> enum N ` {?k1<..}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> [WW]\\<^bsup>m\\<^esup>;\n         \\<And>u. u \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow> Form k u;\n         \\<And>u.\n            u \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  M \\<in> [WW]\\<^bsup>m\\<^esup>\n  ?u \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow> Form k ?u\n  ?u \\<in> [M]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n  list.set (inter_scheme k ?u) \\<subseteq> enum N ` {k<..}\n\ngoal (1 subgoal):\n 1. j k = 0", "obtain u where u: \"u \\<in> [M]\\<^bsup>2\\<^esup>\" \"?fh u = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> [M]\\<^bsup>2\\<^esup>;\n         (f \\<circ> (`) h) u = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using m_fh_0 [of M] M [unfolded nsets_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<subseteq> WW; card M = m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>[M]\\<^bsup>2\\<^esup>.\n                       (f \\<circ> (`) h) x = 0\n  M \\<in> {N. N \\<subseteq> WW \\<and> finite N \\<and> card N = m}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> [M]\\<^bsup>2\\<^esup>;\n         (f \\<circ> (`) h) u = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  u \\<in> [M]\\<^bsup>2\\<^esup>\n  (f \\<circ> (`) h) u = 0\n\ngoal (1 subgoal):\n 1. j k = 0", "moreover"], ["proof (state)\nthis:\n  u \\<in> [M]\\<^bsup>2\\<^esup>\n  (f \\<circ> (`) h) u = 0\n\ngoal (1 subgoal):\n 1. j k = 0", "have \\<section>: \"Form k u\" \"List.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form k u &&& list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}", "by (simp_all add: MF Mi \\<open>u \\<in> [M]\\<^bsup>2\\<^esup>\\<close>)"], ["proof (state)\nthis:\n  Form k u\n  list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\n\ngoal (1 subgoal):\n 1. j k = 0", "moreover"], ["proof (state)\nthis:\n  Form k u\n  list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\n\ngoal (1 subgoal):\n 1. j k = 0", "have \"u \\<in> [WW]\\<^bsup>2\\<^esup>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> [WW]\\<^bsup>2\\<^esup>", "using M u"], ["proof (prove)\nusing this:\n  M \\<in> [WW]\\<^bsup>m\\<^esup>\n  u \\<in> [M]\\<^bsup>2\\<^esup>\n  (f \\<circ> (`) h) u = 0\n\ngoal (1 subgoal):\n 1. u \\<in> [WW]\\<^bsup>2\\<^esup>", "by (auto simp: nsets_def)"], ["proof (state)\nthis:\n  u \\<in> [WW]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. j k = 0", "moreover"], ["proof (state)\nthis:\n  u \\<in> [WW]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. j k = 0", "have \"enum N ` {k<..} \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum N ` {k<..} \\<subseteq> N", "using \\<open>infinite N\\<close> range_enum"], ["proof (prove)\nusing this:\n  infinite N\n  infinite ?N \\<Longrightarrow> range (enum ?N) = ?N\n\ngoal (1 subgoal):\n 1. enum N ` {k<..} \\<subseteq> N", "by auto"], ["proof (state)\nthis:\n  enum N ` {k<..} \\<subseteq> N\n\ngoal (1 subgoal):\n 1. j k = 0", "moreover"], ["proof (state)\nthis:\n  enum N ` {k<..} \\<subseteq> N\n\ngoal (1 subgoal):\n 1. j k = 0", "have \"[enum N k] < inter_scheme k u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [enum N k] < inter_scheme k u", "using inter_scheme [of k u]  strict_mono_enum [OF \\<open>infinite N\\<close>] \\<section>"], ["proof (prove)\nusing this:\n  \\<lbrakk>Form k u; 0 < k;\n   \\<And>ka kb xs ys.\n      \\<lbrakk>k = ka + kb - 1; u = {xs, ys};\n       Form_Body ka kb xs ys (inter_scheme k u); 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  strict_mono (enum N)\n  Form k u\n  list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\n\ngoal (1 subgoal):\n 1. [enum N k] < inter_scheme k u", "apply (auto simp: less_list_def subset_image_iff subset_eq Bex_def image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>thesis.\n                \\<lbrakk>0 < k;\n                 \\<And>ka kb xs ys.\n                    \\<lbrakk>k = ka + kb - Suc 0; u = {xs, ys};\n                     Form_Body ka kb xs ys\n                      (inter_scheme (ka + kb - Suc 0) {xs, ys});\n                     0 < kb; kb \\<le> ka; ka \\<le> Suc kb\\<rbrakk>\n                    \\<Longrightarrow> thesis\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     strict_mono (enum N); Form k u;\n     \\<forall>x\\<in>list.set (inter_scheme k u).\n        \\<exists>xa>k. x = enum N xa;\n     inter_scheme k u \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> enum N k < hd (inter_scheme k u)", "by (metis hd_in_set strict_mono_def)"], ["proof (state)\nthis:\n  [enum N k] < inter_scheme k u\n\ngoal (1 subgoal):\n 1. j k = 0", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> [M]\\<^bsup>2\\<^esup>\n  (f \\<circ> (`) h) u = 0\n  Form k u\n  list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\n  u \\<in> [WW]\\<^bsup>2\\<^esup>\n  enum N ` {k<..} \\<subseteq> N\n  [enum N k] < inter_scheme k u", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> [M]\\<^bsup>2\\<^esup>\n  (f \\<circ> (`) h) u = 0\n  Form k u\n  list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\n  u \\<in> [WW]\\<^bsup>2\\<^esup>\n  enum N ` {k<..} \\<subseteq> N\n  [enum N k] < inter_scheme k u\n\ngoal (1 subgoal):\n 1. j k = 0", "using N that"], ["proof (prove)\nusing this:\n  u \\<in> [M]\\<^bsup>2\\<^esup>\n  (f \\<circ> (`) h) u = 0\n  Form k u\n  list.set (inter_scheme k u) \\<subseteq> enum N ` {k<..}\n  u \\<in> [WW]\\<^bsup>2\\<^esup>\n  enum N ` {k<..} \\<subseteq> N\n  [enum N k] < inter_scheme k u\n  \\<lbrakk>0 < ?k; ?u \\<in> [WW]\\<^bsup>2\\<^esup>; Form ?k ?u;\n   [enum N ?k] < inter_scheme ?k ?u;\n   list.set (inter_scheme ?k ?u) \\<subseteq> N\\<rbrakk>\n  \\<Longrightarrow> (f \\<circ> (`) h) ?u = j ?k\n  0 < k\n\ngoal (1 subgoal):\n 1. j k = 0", "by auto"], ["proof (state)\nthis:\n  j k = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?k \\<Longrightarrow> j ?k = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "obtain X where \"X \\<subseteq> WW\" and otX: \"ordertype X (lenlex less_than) = \\<omega>\\<up>\\<omega>\"\n            and X: \"\\<And>u. u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n                   \\<exists>l. Form l u \\<and> (l > 0 \\<longrightarrow> [enum N l] < inter_scheme l u \\<and> List.set (inter_scheme l u) \\<subseteq> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lemma_3_8 [OF \\<open>infinite N\\<close>] ot'"], ["proof (prove)\nusing this:\n  (\\<And>X.\n      \\<lbrakk>X \\<subseteq> WW;\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n       \\<And>u.\n          u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n          \\<exists>l.\n             Form l u \\<and>\n             (0 < l \\<longrightarrow>\n              [enum N l] < inter_scheme l u \\<and>\n              list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  ordertype WW' (lenlex less_than) = \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> WW;\n         ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>;\n         \\<And>u.\n            u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n            \\<exists>l.\n               Form l u \\<and>\n               (0 < l \\<longrightarrow>\n                [enum N l] < inter_scheme l u \\<and>\n                list.set (inter_scheme l u) \\<subseteq> N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  X \\<subseteq> WW\n  ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>\n  ?u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n  \\<exists>l.\n     Form l ?u \\<and>\n     (0 < l \\<longrightarrow>\n      [enum N l] < inter_scheme l ?u \\<and>\n      list.set (inter_scheme l ?u) \\<subseteq> N)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "have 0: \"?fh ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> (`) h) ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow> f (h ` xa) = 0", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow> f (h ` xa) = 0", "assume u: \"u \\<in> [X]\\<^bsup>2\\<^esup>\""], ["proof (state)\nthis:\n  u \\<in> [X]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow> f (h ` xa) = 0", "obtain l where \"Form l u\" and l: \"l > 0 \\<longrightarrow> [enum N l] < inter_scheme l u \\<and> List.set (inter_scheme l u) \\<subseteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>Form l u;\n         0 < l \\<longrightarrow>\n         [enum N l] < inter_scheme l u \\<and>\n         list.set (inter_scheme l u) \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using u X"], ["proof (prove)\nusing this:\n  u \\<in> [X]\\<^bsup>2\\<^esup>\n  ?u \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow>\n  \\<exists>l.\n     Form l ?u \\<and>\n     (0 < l \\<longrightarrow>\n      [enum N l] < inter_scheme l ?u \\<and>\n      list.set (inter_scheme l ?u) \\<subseteq> N)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>Form l u;\n         0 < l \\<longrightarrow>\n         [enum N l] < inter_scheme l u \\<and>\n         list.set (inter_scheme l u) \\<subseteq> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Form l u\n  0 < l \\<longrightarrow>\n  [enum N l] < inter_scheme l u \\<and>\n  list.set (inter_scheme l u) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow> f (h ` xa) = 0", "have \"?fh u = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> (`) h) u = 0", "proof (cases \"l > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0\n 2. \\<not> 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < l\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0\n 2. \\<not> 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < l", "have \"l = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < l\n\ngoal (1 subgoal):\n 1. l = 0", "by blast"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0\n 2. \\<not> 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0", "then"], ["proof (chain)\npicking this:\n  l = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  l = 0\n\ngoal (1 subgoal):\n 1. (f \\<circ> (`) h) u = 0", "by (metis Form_0_cases_raw \\<open>Form l u\\<close> \\<open>X \\<subseteq> WW\\<close> doubleton_in_nsets_2 fh_eq_0_eqlen subset_iff u)"], ["proof (state)\nthis:\n  (f \\<circ> (`) h) u = 0\n\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0", "case True"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0", "then"], ["proof (chain)\npicking this:\n  0 < l", "obtain \"[enum N l] < inter_scheme l u\" \"List.set (inter_scheme l u) \\<subseteq> N\" \"j l = 0\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>[enum N l] < inter_scheme l u;\n      list.set (inter_scheme l u) \\<subseteq> N; j l = 0\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Nat.neq0_conv j_0 l"], ["proof (prove)\nusing this:\n  0 < l\n  (?n \\<noteq> 0) = (0 < ?n)\n  0 < ?k \\<Longrightarrow> j ?k = 0\n  0 < l \\<longrightarrow>\n  [enum N l] < inter_scheme l u \\<and>\n  list.set (inter_scheme l u) \\<subseteq> N\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>[enum N l] < inter_scheme l u;\n      list.set (inter_scheme l u) \\<subseteq> N; j l = 0\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [enum N l] < inter_scheme l u\n  list.set (inter_scheme l u) \\<subseteq> N\n  j l = 0\n\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow> (f \\<circ> (`) h) u = 0", "with True"], ["proof (chain)\npicking this:\n  0 < l\n  [enum N l] < inter_scheme l u\n  list.set (inter_scheme l u) \\<subseteq> N\n  j l = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < l\n  [enum N l] < inter_scheme l u\n  list.set (inter_scheme l u) \\<subseteq> N\n  j l = 0\n\ngoal (1 subgoal):\n 1. (f \\<circ> (`) h) u = 0", "using \\<open>X \\<subseteq> WW\\<close> N inter_scheme \\<open>Form l u\\<close> doubleton_in_nsets_2 u"], ["proof (prove)\nusing this:\n  0 < l\n  [enum N l] < inter_scheme l u\n  list.set (inter_scheme l u) \\<subseteq> N\n  j l = 0\n  X \\<subseteq> WW\n  \\<lbrakk>0 < ?k; ?u \\<in> [WW]\\<^bsup>2\\<^esup>; Form ?k ?u;\n   [enum N ?k] < inter_scheme ?k ?u;\n   list.set (inter_scheme ?k ?u) \\<subseteq> N\\<rbrakk>\n  \\<Longrightarrow> (f \\<circ> (`) h) ?u = j ?k\n  \\<lbrakk>Form ?l ?U; 0 < ?l;\n   \\<And>ka kb xs ys.\n      \\<lbrakk>?l = ka + kb - 1; ?U = {xs, ys};\n       Form_Body ka kb xs ys (inter_scheme ?l ?U); 0 < kb; kb \\<le> ka;\n       ka \\<le> Suc kb\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Form l u\n  ({?x, ?y} \\<in> [?A]\\<^bsup>2\\<^esup>) =\n  (?x \\<in> ?A \\<and> ?y \\<in> ?A \\<and> ?x \\<noteq> ?y)\n  u \\<in> [X]\\<^bsup>2\\<^esup>\n\ngoal (1 subgoal):\n 1. (f \\<circ> (`) h) u = 0", "by (auto simp: nsets_def)"], ["proof (state)\nthis:\n  (f \\<circ> (`) h) u = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<circ> (`) h) u = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> [X]\\<^bsup>2\\<^esup> \\<Longrightarrow> f (h ` xa) = 0", "then"], ["proof (chain)\npicking this:\n  (f \\<circ> (`) h) u = 0", "show \"f (h ` u) = 0\""], ["proof (prove)\nusing this:\n  (f \\<circ> (`) h) u = 0\n\ngoal (1 subgoal):\n 1. f (h ` u) = 0", "by auto"], ["proof (state)\nthis:\n  f (h ` u) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<circ> (`) h) ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>M\\<subseteq>WW.\n               ordertype M (lenlex less_than) = \\<alpha> \\<and>\n               f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1}) \\<Longrightarrow>\n    \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "show ?P0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X\\<subseteq>WW.\n       ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n       f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "proof (intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?X \\<subseteq> WW\n 2. ordertype ?X (lenlex less_than) = \\<omega> \\<up> \\<omega>\n 3. f ` [?X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "show \"h ` X \\<subseteq> WW\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ` X \\<subseteq> WW", "using \\<open>WW' \\<subseteq> WW\\<close> \\<open>X \\<subseteq> WW\\<close> \\<open>bij_betw h WW WW'\\<close> bij_betw_imp_surj_on"], ["proof (prove)\nusing this:\n  WW' \\<subseteq> WW\n  X \\<subseteq> WW\n  bij_betw h WW WW'\n  bij_betw ?f ?A ?B \\<Longrightarrow> ?f ` ?A = ?B\n\ngoal (1 subgoal):\n 1. h ` X \\<subseteq> WW", "by fastforce"], ["proof (state)\nthis:\n  h ` X \\<subseteq> WW\n\ngoal (2 subgoals):\n 1. ordertype (h ` X) (lenlex less_than) = \\<omega> \\<up> \\<omega>\n 2. f ` [h ` X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "show \"ordertype (h ` X) (lenlex less_than) = \\<omega> \\<up> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (h ` X) (lenlex less_than) = \\<omega> \\<up> \\<omega>", "proof (subst ordertype_inc_eq)"], ["proof (state)\ngoal (6 subgoals):\n 1. small X\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X; y \\<in> X; (x, y) \\<in> ?r\\<rbrakk>\n       \\<Longrightarrow> (h x, h y) \\<in> lenlex less_than\n 3. wf ?r\n 4. total_on X ?r\n 5. wf (lenlex less_than)\n 6. ordertype X ?r = \\<omega> \\<up> \\<omega>", "show \"(h x, h y) \\<in> lenlex less_than\"\n            if \"x \\<in> X\" \"y \\<in> X\" \"(x, y) \\<in> lenlex less_than\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h x, h y) \\<in> lenlex less_than", "using that h \\<open>X \\<subseteq> WW\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> X\n  y \\<in> X\n  (x, y) \\<in> lenlex less_than\n  iso_ll WW WW' h\n  X \\<subseteq> WW\n\ngoal (1 subgoal):\n 1. (h x, h y) \\<in> lenlex less_than", "by (auto simp: FR_WW FR_WW' iso_iff2 iso_ll_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> X; ?y \\<in> X; (?x, ?y) \\<in> lenlex less_than\\<rbrakk>\n  \\<Longrightarrow> (h ?x, h ?y) \\<in> lenlex less_than\n\ngoal (5 subgoals):\n 1. small X\n 2. wf (lenlex less_than)\n 3. total_on X (lenlex less_than)\n 4. wf (lenlex less_than)\n 5. ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega>", "qed (use otX in auto)"], ["proof (state)\nthis:\n  ordertype (h ` X) (lenlex less_than) = \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. f ` [h ` X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "show \"f ` [h ` X]\\<^bsup>2\\<^esup> \\<subseteq> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` [h ` X]\\<^bsup>2\\<^esup> \\<subseteq> {0}", "proof (clarsimp simp: image_subset_iff nsets_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "assume \"Y \\<subseteq> h ` X\" and \"finite Y\" and \"card Y = 2\""], ["proof (state)\nthis:\n  Y \\<subseteq> h ` X\n  finite Y\n  card Y = 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "have \"inv_into WW h ` Y \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into WW h ` Y \\<subseteq> X", "using \\<open>X \\<subseteq> WW\\<close> \\<open>Y \\<subseteq> h ` X\\<close> \\<open>bij_betw h WW WW'\\<close> bij_betw_inv_into_LEFT"], ["proof (prove)\nusing this:\n  X \\<subseteq> WW\n  Y \\<subseteq> h ` X\n  bij_betw h WW WW'\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f ` ?f ` ?B = ?B\n\ngoal (1 subgoal):\n 1. inv_into WW h ` Y \\<subseteq> X", "by blast"], ["proof (state)\nthis:\n  inv_into WW h ` Y \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "moreover"], ["proof (state)\nthis:\n  inv_into WW h ` Y \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "have \"finite (inv_into WW h ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (inv_into WW h ` Y)", "using \\<open>finite Y\\<close>"], ["proof (prove)\nusing this:\n  finite Y\n\ngoal (1 subgoal):\n 1. finite (inv_into WW h ` Y)", "by blast"], ["proof (state)\nthis:\n  finite (inv_into WW h ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "moreover"], ["proof (state)\nthis:\n  finite (inv_into WW h ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "have \"card (inv_into WW h ` Y) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (inv_into WW h ` Y) = 2", "by (metis \\<open>X \\<subseteq> WW\\<close> \\<open>Y \\<subseteq> h ` X\\<close> \\<open>card Y = 2\\<close> card_image inj_on_inv_into subset_image_iff subset_trans)"], ["proof (state)\nthis:\n  card (inv_into WW h ` Y) = 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "ultimately"], ["proof (chain)\npicking this:\n  inv_into WW h ` Y \\<subseteq> X\n  finite (inv_into WW h ` Y)\n  card (inv_into WW h ` Y) = 2", "have \"f (h ` inv_into WW h ` Y) = 0\""], ["proof (prove)\nusing this:\n  inv_into WW h ` Y \\<subseteq> X\n  finite (inv_into WW h ` Y)\n  card (inv_into WW h ` Y) = 2\n\ngoal (1 subgoal):\n 1. f (h ` inv_into WW h ` Y) = 0", "using 0"], ["proof (prove)\nusing this:\n  inv_into WW h ` Y \\<subseteq> X\n  finite (inv_into WW h ` Y)\n  card (inv_into WW h ` Y) = 2\n  (f \\<circ> (`) h) ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. f (h ` inv_into WW h ` Y) = 0", "by (auto simp: image_subset_iff nsets_def)"], ["proof (state)\nthis:\n  f (h ` inv_into WW h ` Y) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<subseteq> h ` X; finite x; card x = 2\\<rbrakk>\n       \\<Longrightarrow> f x = 0", "then"], ["proof (chain)\npicking this:\n  f (h ` inv_into WW h ` Y) = 0", "show \"f Y = 0\""], ["proof (prove)\nusing this:\n  f (h ` inv_into WW h ` Y) = 0\n\ngoal (1 subgoal):\n 1. f Y = 0", "by (metis \\<open>X \\<subseteq> WW\\<close> \\<open>Y \\<subseteq> h ` X\\<close> image_inv_into_cancel image_mono order_trans)"], ["proof (state)\nthis:\n  f Y = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ` [h ` X]\\<^bsup>2\\<^esup> \\<subseteq> {0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X\\<subseteq>WW.\n     ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n     f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>X\\<subseteq>WW.\n      ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n      f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}) \\<or>\n  (\\<exists>M\\<subseteq>WW.\n      ordertype M (lenlex less_than) = \\<alpha> \\<and>\n      f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1})\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> [WW]\\<^bsup>2\\<^esup> \\<rightarrow>\n               {..<Suc (Suc 0)} \\<Longrightarrow>\n       \\<exists>i<Suc (Suc 0).\n          \\<exists>H\\<subseteq>WW.\n             ordertype H (lenlex less_than) =\n             [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n             f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}", "then"], ["proof (chain)\npicking this:\n  (\\<exists>X\\<subseteq>WW.\n      ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n      f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}) \\<or>\n  (\\<exists>M\\<subseteq>WW.\n      ordertype M (lenlex less_than) = \\<alpha> \\<and>\n      f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1})", "show \"\\<exists>i<Suc (Suc 0). \\<exists>H\\<subseteq>WW. ordertype H ?R = [\\<omega>\\<up>\\<omega>, \\<alpha>] ! i \\<and> f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}\""], ["proof (prove)\nusing this:\n  (\\<exists>X\\<subseteq>WW.\n      ordertype X (lenlex less_than) = \\<omega> \\<up> \\<omega> \\<and>\n      f ` [X]\\<^bsup>2\\<^esup> \\<subseteq> {0}) \\<or>\n  (\\<exists>M\\<subseteq>WW.\n      ordertype M (lenlex less_than) = \\<alpha> \\<and>\n      f ` [M]\\<^bsup>2\\<^esup> \\<subseteq> {1})\n\ngoal (1 subgoal):\n 1. \\<exists>i<Suc (Suc 0).\n       \\<exists>H\\<subseteq>WW.\n          ordertype H (lenlex less_than) =\n          [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n          f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}", "by (metis One_nat_def lessI nth_Cons_0 nth_Cons_Suc zero_less_Suc)"], ["proof (state)\nthis:\n  \\<exists>i<Suc (Suc 0).\n     \\<exists>H\\<subseteq>WW.\n        ordertype H (lenlex less_than) =\n        [\\<omega> \\<up> \\<omega>, \\<alpha>] ! i \\<and>\n        f ` [H]\\<^bsup>2\\<^esup> \\<subseteq> {i}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Partitions.partn_lst (lenlex less_than) WW\n   [\\<omega> \\<up> \\<omega>, \\<alpha>] 2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 3.1 of Jean A. Larson, ibid.\\<close>"], ["", "theorem partition_\\<omega>\\<omega>: \"\\<alpha> \\<in> elts \\<omega> \\<Longrightarrow> partn_lst_VWF (\\<omega>\\<up>\\<omega>) [\\<omega>\\<up>\\<omega>,\\<alpha>] 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<omega> \\<Longrightarrow>\n    partn_lst_VWF (\\<omega> \\<up> \\<omega>)\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "using partn_lst_imp_partn_lst_VWF_eq [OF partition_\\<omega>\\<omega>_aux] ordertype_WW"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<alpha>1 \\<in> elts \\<omega>;\n   ordertype WW (lenlex less_than) = ?\\<beta>; small WW;\n   wf (lenlex less_than); trans (lenlex less_than);\n   total_on WW (lenlex less_than)\\<rbrakk>\n  \\<Longrightarrow> partn_lst_VWF ?\\<beta>\n                     [\\<omega> \\<up> \\<omega>, ?\\<alpha>1] 2\n  ordertype WW (lenlex less_than) = \\<omega> \\<up> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<omega> \\<Longrightarrow>\n    partn_lst_VWF (\\<omega> \\<up> \\<omega>)\n     [\\<omega> \\<up> \\<omega>, \\<alpha>] 2", "by auto"], ["", "end"]]}