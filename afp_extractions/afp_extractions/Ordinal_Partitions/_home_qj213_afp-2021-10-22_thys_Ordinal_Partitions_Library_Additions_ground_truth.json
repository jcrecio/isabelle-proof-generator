{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordinal_Partitions/Library_Additions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordinal_Partitions", "problem_names": ["lemma finite_enumerate_Diff_singleton:\n  fixes S :: \"'a::wellorder set\"\n  assumes \"finite S\" and i: \"i < card S\" \"enumerate S i < x\"\n  shows \"enumerate (S - {x}) i = enumerate S i\"", "lemma hd_lex: \"\\<lbrakk>hd ms < hd ns; length ms = length ns; ns \\<noteq> []\\<rbrakk> \\<Longrightarrow> (ms, ns) \\<in> lex less_than\"", "lemma sorted_hd_le:\n  assumes \"sorted xs\" \"x \\<in> list.set xs\"\n  shows \"hd xs \\<le> x\"", "lemma sorted_le_last:\n  assumes \"sorted xs\" \"x \\<in> list.set xs\"\n  shows \"x \\<le> last xs\"", "lemma hd_list_of:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"hd (sorted_list_of_set A) = Min A\"", "lemma sorted_hd_le_last:\n  assumes \"sorted xs\" \"xs \\<noteq> []\"\n  shows \"hd xs \\<le> last xs\"", "lemma sorted_list_of_set_set_of [simp]: \"strict_sorted l \\<Longrightarrow> sorted_list_of_set (list.set l) = l\"", "lemma range_strict_mono_ext:\n  fixes f::\"nat \\<Rightarrow> 'a::linorder\"\n  assumes eq: \"range f = range g\"\n      and sm: \"strict_mono f\" \"strict_mono g\"\n    shows \"f = g\"", "lemma strict_mono_setsD:\n  assumes \"strict_mono_sets A f\" \"x < y\" \"x \\<in> A\" \"y \\<in> A\"\n  shows \"less_sets (f x) (f y)\"", "lemma strict_mono_on_o: \"\\<lbrakk>strict_mono_on r A; strict_mono_on s B; s ` B \\<subseteq> A\\<rbrakk> \\<Longrightarrow> strict_mono_on (r \\<circ> s) B\"", "lemma strict_mono_sets_imp_disjoint:\n  fixes A :: \"'a::linorder set\"\n  assumes \"strict_mono_sets A f\"\n  shows \"pairwise (\\<lambda>x y. disjnt (f x) (f y)) A\"", "lemma strict_mono_sets_subset:\n  assumes \"strict_mono_sets B f\" \"A \\<subseteq> B\"\n  shows \"strict_mono_sets A f\"", "lemma strict_mono_less_sets_Min:\n  assumes \"strict_mono_sets I f\" \"finite I\" \"I \\<noteq> {}\"\n  shows \"less_sets (f (Min I)) (\\<Union> (f ` (I - {Min I})))\"", "lemma pair_less_iff1 [simp]: \"((x,y), (x,z)) \\<in> pair_less \\<longleftrightarrow> y<z\"", "lemma infinite_finite_Inter:\n  assumes \"finite \\<A>\" \"\\<A>\\<noteq>{}\" \"\\<And>A. A \\<in> \\<A> \\<Longrightarrow> infinite A\"\n    and \"\\<And>A B. \\<lbrakk>A \\<in> \\<A>; B \\<in> \\<A>\\<rbrakk> \\<Longrightarrow> A \\<inter> B \\<in> \\<A>\"\n  shows \"infinite (\\<Inter>\\<A>)\"", "lemma atLeast_less_sets: \"\\<lbrakk>less_sets A {x}; B \\<subseteq> {x..}\\<rbrakk> \\<Longrightarrow> less_sets A B\"", "lemma sorted_list_of_set_insert_cons:\n  assumes \"finite A\" \"less_sets {a} A\"\n  shows \"sorted_list_of_set (insert a A) = a # sorted_list_of_set A\"", "lemma sorted_list_of_set_Un:\n  assumes AB: \"less_sets A B\" and fin: \"finite A\" \"finite B\"\n  shows \"sorted_list_of_set (A \\<union> B) = sorted_list_of_set A @ sorted_list_of_set B\"", "lemma sorted_list_of_set_UN_lessThan:\n  fixes k::nat\n  assumes sm: \"strict_mono_sets {..<k} A\" and \"\\<And>i. i < k \\<Longrightarrow> finite (A i)\"\n  shows \"sorted_list_of_set (\\<Union>i<k. A i) = concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k}))\"", "lemma sorted_list_of_set_UN_atMost:\n  fixes k::nat\n  assumes \"strict_mono_sets {..k} A\" and \"\\<And>i. i \\<le> k \\<Longrightarrow> finite (A i)\"\n  shows \"sorted_list_of_set (\\<Union>i\\<le>k. A i) = concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..k}))\"", "lemma nat_infinite_iff:\n  fixes N :: \"nat set\"\n  shows \"infinite N \\<longleftrightarrow> (\\<exists>f::nat\\<Rightarrow>nat. N = range f \\<and> strict_mono f)\"", "lemma enum_works:\n  fixes N :: \"nat set\"\n  assumes \"infinite N\"\n  shows \"N = range (enum N) \\<and> strict_mono (enum N)\"", "lemma range_enum: \"range (enum N) = N\" and strict_mono_enum: \"strict_mono (enum N)\"\n  if \"infinite N\" for N :: \"nat set\"", "lemma enum_0_eq_Inf:\n  fixes N :: \"nat set\"\n  assumes \"infinite N\"\n  shows \"enum N 0 = Inf N\"", "lemma enum_works_finite:\n  fixes N :: \"nat set\"\n  assumes \"finite N\"\n  shows \"N = enum N ` {..<card N} \\<and> strict_mono_on (enum N) {..<card N}\"", "lemma enum_obtain_index_finite:\n  fixes N :: \"nat set\"\n  assumes \"x \\<in> N\" \"finite N\" \n  obtains i where \"i < card N\" \"x = enum N i\"", "lemma enum_0_eq_Inf_finite:\n  fixes N :: \"nat set\"\n  assumes \"finite N\" \"N \\<noteq> {}\"\n  shows \"enum N 0 = Inf N\"", "lemma greaterThan_less_enum:\n  fixes N :: \"nat set\"\n  assumes \"N \\<subseteq> {x<..}\" \"infinite N\"\n  shows \"x < enum N i\"", "lemma atLeast_le_enum:\n  fixes N :: \"nat set\"\n  assumes \"N \\<subseteq> {x..}\" \"infinite N\"\n  shows \"x \\<le> enum N i\"", "lemma less_sets_empty1 [simp]: \"less_sets {} A\" and less_sets_empty2 [simp]: \"less_sets A {}\"", "lemma less_sets_singleton1 [simp]: \"less_sets {a} A \\<longleftrightarrow> (\\<forall>x\\<in>A. a < x)\" \n  and less_sets_singleton2 [simp]: \"less_sets A {a} \\<longleftrightarrow> (\\<forall>x\\<in>A. x < a)\"", "lemma less_sets_atMost [simp]: \"less_sets {..a} A \\<longleftrightarrow> (\\<forall>x\\<in>A. a < x)\" \n  and less_sets_alLeast [simp]: \"less_sets A {a..} \\<longleftrightarrow> (\\<forall>x\\<in>A. x < a)\"", "lemma less_sets_imp_strict_mono_sets:\n  assumes \"\\<And>i. less_sets (A i) (A (Suc i))\" \"\\<And>i. i>0 \\<Longrightarrow> A i \\<noteq> {}\"\n  shows \"strict_mono_sets UNIV A\"", "lemma less_sets_Suc_Max:  \n  assumes \"finite A\"\n  shows \"less_sets A {Suc (Max A)..}\"", "lemma infinite_nat_greaterThan:\n  fixes m::nat\n  assumes \"infinite N\"\n  shows \"infinite (N \\<inter> {m<..})\""], "translations": [["", "lemma finite_enumerate_Diff_singleton:\n  fixes S :: \"'a::wellorder set\"\n  assumes \"finite S\" and i: \"i < card S\" \"enumerate S i < x\"\n  shows \"enumerate (S - {x}) i = enumerate S i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellorder_class.enumerate (S - {x}) i = wellorder_class.enumerate S i", "using i"], ["proof (prove)\nusing this:\n  i < card S\n  wellorder_class.enumerate S i < x\n\ngoal (1 subgoal):\n 1. wellorder_class.enumerate (S - {x}) i = wellorder_class.enumerate S i", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < card S; wellorder_class.enumerate S 0 < x\\<rbrakk>\n    \\<Longrightarrow> wellorder_class.enumerate (S - {x}) 0 =\n                      wellorder_class.enumerate S 0\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "case 0"], ["proof (state)\nthis:\n  0 < card S\n  wellorder_class.enumerate S 0 < x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < card S; wellorder_class.enumerate S 0 < x\\<rbrakk>\n    \\<Longrightarrow> wellorder_class.enumerate (S - {x}) 0 =\n                      wellorder_class.enumerate S 0\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "have \"(LEAST i. i \\<in> S \\<and> i\\<noteq>x) = (LEAST i. i \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i. i \\<in> S \\<and> i \\<noteq> x) = (LEAST i. i \\<in> S)", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. (LEAST i. i \\<in> S) \\<in> S \\<and> (LEAST i. i \\<in> S) \\<noteq> x\n 2. \\<And>y.\n       y \\<in> S \\<and> y \\<noteq> x \\<Longrightarrow>\n       (LEAST i. i \\<in> S) \\<le> y", "have \"\\<exists>t. t \\<in> S \\<and> t\\<noteq>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. t \\<in> S \\<and> t \\<noteq> x", "using 0 \\<open>finite S\\<close> finite_enumerate_in_set"], ["proof (prove)\nusing this:\n  0 < card S\n  wellorder_class.enumerate S 0 < x\n  finite S\n  \\<lbrakk>finite ?S; ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> wellorder_class.enumerate ?S ?n \\<in> ?S\n\ngoal (1 subgoal):\n 1. \\<exists>t. t \\<in> S \\<and> t \\<noteq> x", "by blast"], ["proof (state)\nthis:\n  \\<exists>t. t \\<in> S \\<and> t \\<noteq> x\n\ngoal (2 subgoals):\n 1. (LEAST i. i \\<in> S) \\<in> S \\<and> (LEAST i. i \\<in> S) \\<noteq> x\n 2. \\<And>y.\n       y \\<in> S \\<and> y \\<noteq> x \\<Longrightarrow>\n       (LEAST i. i \\<in> S) \\<le> y", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. t \\<in> S \\<and> t \\<noteq> x", "show \"(LEAST i. i \\<in> S) \\<in> S \\<and> (LEAST i. i \\<in> S) \\<noteq> x\""], ["proof (prove)\nusing this:\n  \\<exists>t. t \\<in> S \\<and> t \\<noteq> x\n\ngoal (1 subgoal):\n 1. (LEAST i. i \\<in> S) \\<in> S \\<and> (LEAST i. i \\<in> S) \\<noteq> x", "by (metis \"0.prems\"(2) LeastI enumerate_0 not_less_Least)"], ["proof (state)\nthis:\n  (LEAST i. i \\<in> S) \\<in> S \\<and> (LEAST i. i \\<in> S) \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S \\<and> y \\<noteq> x \\<Longrightarrow>\n       (LEAST i. i \\<in> S) \\<le> y", "qed (simp add: Least_le)"], ["proof (state)\nthis:\n  (LEAST i. i \\<in> S \\<and> i \\<noteq> x) = (LEAST i. i \\<in> S)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < card S; wellorder_class.enumerate S 0 < x\\<rbrakk>\n    \\<Longrightarrow> wellorder_class.enumerate (S - {x}) 0 =\n                      wellorder_class.enumerate S 0\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "then"], ["proof (chain)\npicking this:\n  (LEAST i. i \\<in> S \\<and> i \\<noteq> x) = (LEAST i. i \\<in> S)", "show ?case"], ["proof (prove)\nusing this:\n  (LEAST i. i \\<in> S \\<and> i \\<noteq> x) = (LEAST i. i \\<in> S)\n\ngoal (1 subgoal):\n 1. wellorder_class.enumerate (S - {x}) 0 = wellorder_class.enumerate S 0", "by (auto simp: enumerate_0)"], ["proof (state)\nthis:\n  wellorder_class.enumerate (S - {x}) 0 = wellorder_class.enumerate S 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>i < card S; wellorder_class.enumerate S i < x\\<rbrakk>\n  \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                    wellorder_class.enumerate S i\n  Suc i < card S\n  wellorder_class.enumerate S (Suc i) < x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < card S; wellorder_class.enumerate S i < x\\<rbrakk>\n  \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                    wellorder_class.enumerate S i\n  Suc i < card S\n  wellorder_class.enumerate S (Suc i) < x", "have x: \"enumerate S i < x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < card S; wellorder_class.enumerate S i < x\\<rbrakk>\n  \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                    wellorder_class.enumerate S i\n  Suc i < card S\n  wellorder_class.enumerate S (Suc i) < x\n\ngoal (1 subgoal):\n 1. wellorder_class.enumerate S i < x", "by (meson enumerate_step finite_enumerate_step less_trans)"], ["proof (state)\nthis:\n  wellorder_class.enumerate S i < x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "have cardSx: \"Suc i < card (S - {x})\" and \"i < card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < card (S - {x}) &&& i < card S", "using Suc \\<open>finite S\\<close> card_Diff_singleton_if finite_enumerate_Ex"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < card S; wellorder_class.enumerate S i < x\\<rbrakk>\n  \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                    wellorder_class.enumerate S i\n  Suc i < card S\n  wellorder_class.enumerate S (Suc i) < x\n  finite S\n  finite ?A \\<Longrightarrow>\n  card (?A - {?x}) = (if ?x \\<in> ?A then card ?A - 1 else card ?A)\n  \\<lbrakk>finite ?S; ?s \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<card ?S. wellorder_class.enumerate ?S n = ?s\n\ngoal (1 subgoal):\n 1. Suc i < card (S - {x}) &&& i < card S", "by fastforce+"], ["proof (state)\nthis:\n  Suc i < card (S - {x})\n  i < card S\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "have \"(LEAST s. s \\<in> S \\<and> s\\<noteq>x \\<and> enumerate (S - {x}) i < s) = (LEAST s. s \\<in> S \\<and> enumerate S i < s)\"\n       (is \"_ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST s.\n        s \\<in> S \\<and>\n        s \\<noteq> x \\<and> wellorder_class.enumerate (S - {x}) i < s) =\n    (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)", "proof (intro Least_equality conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<in> S\n 2. (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<noteq> x\n 3. wellorder_class.enumerate (S - {x}) i\n    < (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)\n 4. \\<And>y.\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and>\n       wellorder_class.enumerate (S - {x}) i < y \\<Longrightarrow>\n       (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<le> y", "show \"?r \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<in> S", "by (metis (lifting) LeastI Suc.prems(1) assms(1) finite_enumerate_in_set finite_enumerate_step)"], ["proof (state)\nthis:\n  (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<in> S\n\ngoal (3 subgoals):\n 1. (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<noteq> x\n 2. wellorder_class.enumerate (S - {x}) i\n    < (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)\n 3. \\<And>y.\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and>\n       wellorder_class.enumerate (S - {x}) i < y \\<Longrightarrow>\n       (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<le> y", "show \"?r \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<noteq> x", "using Suc.prems not_less_Least [of _ \"\\<lambda>t. t \\<in> S \\<and> enumerate S i < t\"] \n       \\<open>finite S\\<close> finite_enumerate_in_set finite_enumerate_step"], ["proof (prove)\nusing this:\n  Suc i < card S\n  wellorder_class.enumerate S (Suc i) < x\n  ?k < (LEAST x.\n           x \\<in> S \\<and>\n           wellorder_class.enumerate S i < x) \\<Longrightarrow>\n  \\<not> (?k \\<in> S \\<and> wellorder_class.enumerate S i < ?k)\n  finite S\n  \\<lbrakk>finite ?S; ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> wellorder_class.enumerate ?S ?n \\<in> ?S\n  \\<lbrakk>finite ?S; Suc ?n < card ?S\\<rbrakk>\n  \\<Longrightarrow> wellorder_class.enumerate ?S ?n\n                    < wellorder_class.enumerate ?S (Suc ?n)\n\ngoal (1 subgoal):\n 1. (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<noteq> x", "by blast"], ["proof (state)\nthis:\n  (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<noteq> x\n\ngoal (2 subgoals):\n 1. wellorder_class.enumerate (S - {x}) i\n    < (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)\n 2. \\<And>y.\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and>\n       wellorder_class.enumerate (S - {x}) i < y \\<Longrightarrow>\n       (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<le> y", "show \"enumerate (S - {x}) i < ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellorder_class.enumerate (S - {x}) i\n    < (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)", "by (metis (full_types) Suc.IH Suc.prems(1) \\<open>i < card S\\<close> enumerate_Suc'' enumerate_step finite_enumerate_Suc'' finite_enumerate_step x)"], ["proof (state)\nthis:\n  wellorder_class.enumerate (S - {x}) i\n  < (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and>\n       wellorder_class.enumerate (S - {x}) i < y \\<Longrightarrow>\n       (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<le> y", "show \"\\<And>y. y \\<in> S \\<and> y \\<noteq> x \\<and> enumerate (S - {x}) i < y \\<Longrightarrow> ?r \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and>\n       wellorder_class.enumerate (S - {x}) i < y \\<Longrightarrow>\n       (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<le> y", "by (simp add: Least_le Suc.IH \\<open>i < card S\\<close> x)"], ["proof (state)\nthis:\n  ?y \\<in> S \\<and>\n  ?y \\<noteq> x \\<and>\n  wellorder_class.enumerate (S - {x}) i < ?y \\<Longrightarrow>\n  (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s) \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST s.\n      s \\<in> S \\<and>\n      s \\<noteq> x \\<and> wellorder_class.enumerate (S - {x}) i < s) =\n  (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < card S;\n                 wellorder_class.enumerate S i < x\\<rbrakk>\n                \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                                  wellorder_class.enumerate S i;\n        Suc i < card S; wellorder_class.enumerate S (Suc i) < x\\<rbrakk>\n       \\<Longrightarrow> wellorder_class.enumerate (S - {x}) (Suc i) =\n                         wellorder_class.enumerate S (Suc i)", "then"], ["proof (chain)\npicking this:\n  (LEAST s.\n      s \\<in> S \\<and>\n      s \\<noteq> x \\<and> wellorder_class.enumerate (S - {x}) i < s) =\n  (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)", "show ?case"], ["proof (prove)\nusing this:\n  (LEAST s.\n      s \\<in> S \\<and>\n      s \\<noteq> x \\<and> wellorder_class.enumerate (S - {x}) i < s) =\n  (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)\n\ngoal (1 subgoal):\n 1. wellorder_class.enumerate (S - {x}) (Suc i) =\n    wellorder_class.enumerate S (Suc i)", "using Suc assms"], ["proof (prove)\nusing this:\n  (LEAST s.\n      s \\<in> S \\<and>\n      s \\<noteq> x \\<and> wellorder_class.enumerate (S - {x}) i < s) =\n  (LEAST s. s \\<in> S \\<and> wellorder_class.enumerate S i < s)\n  \\<lbrakk>i < card S; wellorder_class.enumerate S i < x\\<rbrakk>\n  \\<Longrightarrow> wellorder_class.enumerate (S - {x}) i =\n                    wellorder_class.enumerate S i\n  Suc i < card S\n  wellorder_class.enumerate S (Suc i) < x\n  finite S\n  i < card S\n  wellorder_class.enumerate S i < x\n\ngoal (1 subgoal):\n 1. wellorder_class.enumerate (S - {x}) (Suc i) =\n    wellorder_class.enumerate S (Suc i)", "by (simp add: finite_enumerate_Suc'' cardSx)"], ["proof (state)\nthis:\n  wellorder_class.enumerate (S - {x}) (Suc i) =\n  wellorder_class.enumerate S (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hd_lex: \"\\<lbrakk>hd ms < hd ns; length ms = length ns; ns \\<noteq> []\\<rbrakk> \\<Longrightarrow> (ms, ns) \\<in> lex less_than\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hd ms < hd ns; length ms = length ns; ns \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (ms, ns) \\<in> lex less_than", "by (metis hd_Cons_tl length_0_conv less_than_iff lexord_cons_cons lexord_lex)"], ["", "lemma sorted_hd_le:\n  assumes \"sorted xs\" \"x \\<in> list.set xs\"\n  shows \"hd xs \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<le> x", "using assms"], ["proof (prove)\nusing this:\n  sorted xs\n  x \\<in> list.set xs\n\ngoal (1 subgoal):\n 1. hd xs \\<le> x", "by (induction xs) (auto simp: less_imp_le)"], ["", "lemma sorted_le_last:\n  assumes \"sorted xs\" \"x \\<in> list.set xs\"\n  shows \"x \\<le> last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> last xs", "using assms"], ["proof (prove)\nusing this:\n  sorted xs\n  x \\<in> list.set xs\n\ngoal (1 subgoal):\n 1. x \\<le> last xs", "by (induction xs) (auto simp: less_imp_le)"], ["", "lemma hd_list_of:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"hd (sorted_list_of_set A) = Min A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (sorted_list_of_set A) = Min A", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. hd (sorted_list_of_set A) \\<le> Min A\n 2. Min A \\<le> hd (sorted_list_of_set A)", "have \"Min A \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min A \\<in> A", "by (simp add: assms)"], ["proof (state)\nthis:\n  Min A \\<in> A\n\ngoal (2 subgoals):\n 1. hd (sorted_list_of_set A) \\<le> Min A\n 2. Min A \\<le> hd (sorted_list_of_set A)", "then"], ["proof (chain)\npicking this:\n  Min A \\<in> A", "show \"hd (sorted_list_of_set A) \\<le> Min A\""], ["proof (prove)\nusing this:\n  Min A \\<in> A\n\ngoal (1 subgoal):\n 1. hd (sorted_list_of_set A) \\<le> Min A", "by (simp add: sorted_hd_le \\<open>finite A\\<close>)"], ["proof (state)\nthis:\n  hd (sorted_list_of_set A) \\<le> Min A\n\ngoal (1 subgoal):\n 1. Min A \\<le> hd (sorted_list_of_set A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Min A \\<le> hd (sorted_list_of_set A)", "show \"Min A \\<le> hd (sorted_list_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min A \\<le> hd (sorted_list_of_set A)", "by (metis Min_le assms hd_in_set set_sorted_list_of_set sorted_list_of_set_eq_Nil_iff)"], ["proof (state)\nthis:\n  Min A \\<le> hd (sorted_list_of_set A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_hd_le_last:\n  assumes \"sorted xs\" \"xs \\<noteq> []\"\n  shows \"hd xs \\<le> last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<le> last xs", "using assms"], ["proof (prove)\nusing this:\n  sorted xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd xs \\<le> last xs", "by (simp add: sorted_hd_le)"], ["", "lemma sorted_list_of_set_set_of [simp]: \"strict_sorted l \\<Longrightarrow> sorted_list_of_set (list.set l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted l \\<Longrightarrow> sorted_list_of_set (list.set l) = l", "by (simp add: strict_sorted_equal)"], ["", "lemma range_strict_mono_ext:\n  fixes f::\"nat \\<Rightarrow> 'a::linorder\"\n  assumes eq: \"range f = range g\"\n      and sm: \"strict_mono f\" \"strict_mono g\"\n    shows \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "show \"f n = g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n = g n", "proof (induction n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y. y < x \\<Longrightarrow> f y = g y) \\<Longrightarrow>\n       f x = g x", "case (less n)"], ["proof (state)\nthis:\n  ?y < n \\<Longrightarrow> f ?y = g ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y. y < x \\<Longrightarrow> f y = g y) \\<Longrightarrow>\n       f x = g x", "obtain x y where xy: \"f n = g y\" \"f x = g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y x.\n        \\<lbrakk>f n = g y; f x = g n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis eq imageE rangeI)"], ["proof (state)\nthis:\n  f n = g y\n  f x = g n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y. y < x \\<Longrightarrow> f y = g y) \\<Longrightarrow>\n       f x = g x", "then"], ["proof (chain)\npicking this:\n  f n = g y\n  f x = g n", "have \"n = y\""], ["proof (prove)\nusing this:\n  f n = g y\n  f x = g n\n\ngoal (1 subgoal):\n 1. n = y", "by (metis (no_types) less.IH neq_iff sm strict_mono_less xy)"], ["proof (state)\nthis:\n  n = y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y. y < x \\<Longrightarrow> f y = g y) \\<Longrightarrow>\n       f x = g x", "then"], ["proof (chain)\npicking this:\n  n = y", "show ?case"], ["proof (prove)\nusing this:\n  n = y\n\ngoal (1 subgoal):\n 1. f n = g n", "using xy"], ["proof (prove)\nusing this:\n  n = y\n  f n = g y\n  f x = g n\n\ngoal (1 subgoal):\n 1. f n = g n", "by auto"], ["proof (state)\nthis:\n  f n = g n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f n = g n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Other material\\<close>"], ["", "definition strict_mono_sets :: \"['a::order set, 'a::order \\<Rightarrow> 'b::order set] \\<Rightarrow> bool\" where\n  \"strict_mono_sets A f \\<equiv> \\<forall>x\\<in>A. \\<forall>y\\<in>A. x < y \\<longrightarrow> less_sets (f x) (f y)\""], ["", "lemma strict_mono_setsD:\n  assumes \"strict_mono_sets A f\" \"x < y\" \"x \\<in> A\" \"y \\<in> A\"\n  shows \"less_sets (f x) (f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<lless> f y", "using assms"], ["proof (prove)\nusing this:\n  strict_mono_sets A f\n  x < y\n  x \\<in> A\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. f x \\<lless> f y", "by (auto simp: strict_mono_sets_def)"], ["", "lemma strict_mono_on_o: \"\\<lbrakk>strict_mono_on r A; strict_mono_on s B; s ` B \\<subseteq> A\\<rbrakk> \\<Longrightarrow> strict_mono_on (r \\<circ> s) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_mono_on r A; strict_mono_on s B;\n     s ` B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> strict_mono_on (r \\<circ> s) B", "by (auto simp: image_subset_iff strict_mono_on_def)"], ["", "lemma strict_mono_sets_imp_disjoint:\n  fixes A :: \"'a::linorder set\"\n  assumes \"strict_mono_sets A f\"\n  shows \"pairwise (\\<lambda>x y. disjnt (f x) (f y)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise (\\<lambda>x y. disjnt (f x) (f y)) A", "using assms"], ["proof (prove)\nusing this:\n  strict_mono_sets A f\n\ngoal (1 subgoal):\n 1. pairwise (\\<lambda>x y. disjnt (f x) (f y)) A", "unfolding strict_mono_sets_def pairwise_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. x < y \\<longrightarrow> f x \\<lless> f y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. x \\<noteq> y \\<longrightarrow> disjnt (f x) (f y)", "by (meson antisym_conv3 disjnt_sym less_sets_imp_disjnt)"], ["", "lemma strict_mono_sets_subset:\n  assumes \"strict_mono_sets B f\" \"A \\<subseteq> B\"\n  shows \"strict_mono_sets A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono_sets A f", "using assms"], ["proof (prove)\nusing this:\n  strict_mono_sets B f\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. strict_mono_sets A f", "by (auto simp: strict_mono_sets_def)"], ["", "lemma strict_mono_less_sets_Min:\n  assumes \"strict_mono_sets I f\" \"finite I\" \"I \\<noteq> {}\"\n  shows \"less_sets (f (Min I)) (\\<Union> (f ` (I - {Min I})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Min I) \\<lless> \\<Union> (f ` (I - {Min I}))", "using assms"], ["proof (prove)\nusing this:\n  strict_mono_sets I f\n  finite I\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. f (Min I) \\<lless> \\<Union> (f ` (I - {Min I}))", "by (simp add: strict_mono_sets_def less_sets_UN2 dual_order.strict_iff_order)"], ["", "lemma pair_less_iff1 [simp]: \"((x,y), (x,z)) \\<in> pair_less \\<longleftrightarrow> y<z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((x, y), x, z) \\<in> pair_less) = (y < z)", "by (simp add: pair_less_def)"], ["", "lemma infinite_finite_Inter:\n  assumes \"finite \\<A>\" \"\\<A>\\<noteq>{}\" \"\\<And>A. A \\<in> \\<A> \\<Longrightarrow> infinite A\"\n    and \"\\<And>A B. \\<lbrakk>A \\<in> \\<A>; B \\<in> \\<A>\\<rbrakk> \\<Longrightarrow> A \\<inter> B \\<in> \\<A>\"\n  shows \"infinite (\\<Inter>\\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (\\<Inter> \\<A>)", "by (simp add: assms finite_Inf_in)"], ["", "lemma atLeast_less_sets: \"\\<lbrakk>less_sets A {x}; B \\<subseteq> {x..}\\<rbrakk> \\<Longrightarrow> less_sets A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<lless> {x}; B \\<subseteq> {x..}\\<rbrakk>\n    \\<Longrightarrow> A \\<lless> B", "by (force simp: less_sets_def subset_iff)"], ["", "subsection \\<open>The list-of function\\<close>"], ["", "lemma sorted_list_of_set_insert_cons:\n  assumes \"finite A\" \"less_sets {a} A\"\n  shows \"sorted_list_of_set (insert a A) = a # sorted_list_of_set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (insert a A) = a # sorted_list_of_set A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_list_of_set (insert a A) = a # sorted_list_of_set A", "have \"strict_sorted (a # sorted_list_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (a # sorted_list_of_set A)", "using assms less_setsD"], ["proof (prove)\nusing this:\n  finite A\n  {a} \\<lless> A\n  \\<lbrakk>?A \\<lless> ?B; ?a \\<in> ?A; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. strict_sorted (a # sorted_list_of_set A)", "by auto"], ["proof (state)\nthis:\n  strict_sorted (a # sorted_list_of_set A)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (insert a A) = a # sorted_list_of_set A", "moreover"], ["proof (state)\nthis:\n  strict_sorted (a # sorted_list_of_set A)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (insert a A) = a # sorted_list_of_set A", "have \"list.set (a # sorted_list_of_set A) = insert a A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (a # sorted_list_of_set A) = insert a A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  {a} \\<lless> A\n\ngoal (1 subgoal):\n 1. list.set (a # sorted_list_of_set A) = insert a A", "by force"], ["proof (state)\nthis:\n  list.set (a # sorted_list_of_set A) = insert a A\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (insert a A) = a # sorted_list_of_set A", "moreover"], ["proof (state)\nthis:\n  list.set (a # sorted_list_of_set A) = insert a A\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (insert a A) = a # sorted_list_of_set A", "have \"length (a # sorted_list_of_set A) = card (insert a A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (a # sorted_list_of_set A) = card (insert a A)", "using assms card_insert_if less_setsD"], ["proof (prove)\nusing this:\n  finite A\n  {a} \\<lless> A\n  finite ?A \\<Longrightarrow>\n  card (insert ?x ?A) = (if ?x \\<in> ?A then card ?A else Suc (card ?A))\n  \\<lbrakk>?A \\<lless> ?B; ?a \\<in> ?A; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. length (a # sorted_list_of_set A) = card (insert a A)", "by fastforce"], ["proof (state)\nthis:\n  length (a # sorted_list_of_set A) = card (insert a A)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (insert a A) = a # sorted_list_of_set A", "ultimately"], ["proof (chain)\npicking this:\n  strict_sorted (a # sorted_list_of_set A)\n  list.set (a # sorted_list_of_set A) = insert a A\n  length (a # sorted_list_of_set A) = card (insert a A)", "show ?thesis"], ["proof (prove)\nusing this:\n  strict_sorted (a # sorted_list_of_set A)\n  list.set (a # sorted_list_of_set A) = insert a A\n  length (a # sorted_list_of_set A) = card (insert a A)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (insert a A) = a # sorted_list_of_set A", "by (metis \\<open>finite A\\<close> finite_insert sorted_list_of_set_unique)"], ["proof (state)\nthis:\n  sorted_list_of_set (insert a A) = a # sorted_list_of_set A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_list_of_set_Un:\n  assumes AB: \"less_sets A B\" and fin: \"finite A\" \"finite B\"\n  shows \"sorted_list_of_set (A \\<union> B) = sorted_list_of_set A @ sorted_list_of_set B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (A \\<union> B) =\n    sorted_list_of_set A @ sorted_list_of_set B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_list_of_set (A \\<union> B) =\n    sorted_list_of_set A @ sorted_list_of_set B", "have \"strict_sorted (sorted_list_of_set A @ sorted_list_of_set B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (sorted_list_of_set A @ sorted_list_of_set B)", "using AB"], ["proof (prove)\nusing this:\n  A \\<lless> B\n\ngoal (1 subgoal):\n 1. strict_sorted (sorted_list_of_set A @ sorted_list_of_set B)", "unfolding less_sets_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>A. \\<forall>y\\<in>B. x < y\n\ngoal (1 subgoal):\n 1. strict_sorted (sorted_list_of_set A @ sorted_list_of_set B)", "by (metis fin set_sorted_list_of_set sorted_wrt_append strict_sorted_list_of_set strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  strict_sorted (sorted_list_of_set A @ sorted_list_of_set B)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (A \\<union> B) =\n    sorted_list_of_set A @ sorted_list_of_set B", "moreover"], ["proof (state)\nthis:\n  strict_sorted (sorted_list_of_set A @ sorted_list_of_set B)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (A \\<union> B) =\n    sorted_list_of_set A @ sorted_list_of_set B", "have \"card A + card B = card (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A + card B = card (A \\<union> B)", "using less_sets_imp_disjnt [OF AB]"], ["proof (prove)\nusing this:\n  disjnt A B\n\ngoal (1 subgoal):\n 1. card A + card B = card (A \\<union> B)", "by (simp add: assms card_Un_disjoint disjnt_def)"], ["proof (state)\nthis:\n  card A + card B = card (A \\<union> B)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (A \\<union> B) =\n    sorted_list_of_set A @ sorted_list_of_set B", "ultimately"], ["proof (chain)\npicking this:\n  strict_sorted (sorted_list_of_set A @ sorted_list_of_set B)\n  card A + card B = card (A \\<union> B)", "show ?thesis"], ["proof (prove)\nusing this:\n  strict_sorted (sorted_list_of_set A @ sorted_list_of_set B)\n  card A + card B = card (A \\<union> B)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (A \\<union> B) =\n    sorted_list_of_set A @ sorted_list_of_set B", "by (simp add: assms strict_sorted_equal)"], ["proof (state)\nthis:\n  sorted_list_of_set (A \\<union> B) =\n  sorted_list_of_set A @ sorted_list_of_set B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_list_of_set_UN_lessThan:\n  fixes k::nat\n  assumes sm: \"strict_mono_sets {..<k} A\" and \"\\<And>i. i < k \\<Longrightarrow> finite (A i)\"\n  shows \"sorted_list_of_set (\\<Union>i<k. A i) = concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..<k})) =\n    concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k}))", "using assms"], ["proof (prove)\nusing this:\n  strict_mono_sets {..<k} A\n  ?i < k \\<Longrightarrow> finite (A ?i)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..<k})) =\n    concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k}))", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_mono_sets {..<0} A;\n     \\<And>i. i < 0 \\<Longrightarrow> finite (A i)\\<rbrakk>\n    \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<0})) =\n                      concat\n                       (map (sorted_list_of_set \\<circ> A)\n                         (sorted_list_of_set {..<0}))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "case 0"], ["proof (state)\nthis:\n  strict_mono_sets {..<0} A\n  ?i < 0 \\<Longrightarrow> finite (A ?i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_mono_sets {..<0} A;\n     \\<And>i. i < 0 \\<Longrightarrow> finite (A i)\\<rbrakk>\n    \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<0})) =\n                      concat\n                       (map (sorted_list_of_set \\<circ> A)\n                         (sorted_list_of_set {..<0}))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "then"], ["proof (chain)\npicking this:\n  strict_mono_sets {..<0} A\n  ?i < 0 \\<Longrightarrow> finite (A ?i)", "show ?case"], ["proof (prove)\nusing this:\n  strict_mono_sets {..<0} A\n  ?i < 0 \\<Longrightarrow> finite (A ?i)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..<0})) =\n    concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<0}))", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set (\\<Union> (A ` {..<0})) =\n  concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<0}))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>strict_mono_sets {..<k} A;\n   \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n  \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<k})) =\n                    concat\n                     (map (sorted_list_of_set \\<circ> A)\n                       (sorted_list_of_set {..<k}))\n  strict_mono_sets {..<Suc k} A\n  ?i < Suc k \\<Longrightarrow> finite (A ?i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "have ls: \"less_sets (\\<Union> (A ` {..<k})) (A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (A ` {..<k}) \\<lless> A k", "using sm Suc.prems(1) strict_mono_setsD"], ["proof (prove)\nusing this:\n  strict_mono_sets {..<k} A\n  strict_mono_sets {..<Suc k} A\n  \\<lbrakk>strict_mono_sets ?A ?f; ?x < ?y; ?x \\<in> ?A;\n   ?y \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?x \\<lless> ?f ?y\n\ngoal (1 subgoal):\n 1. \\<Union> (A ` {..<k}) \\<lless> A k", "by (force simp: less_sets_UN1)"], ["proof (state)\nthis:\n  \\<Union> (A ` {..<k}) \\<lless> A k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "have \"sorted_list_of_set (\\<Union> (A ` {..<Suc k})) = sorted_list_of_set (\\<Union> (A ` {..<k}) \\<union> A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n    sorted_list_of_set (\\<Union> (A ` {..<k}) \\<union> A k)", "by (simp add: Un_commute lessThan_Suc)"], ["proof (state)\nthis:\n  sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n  sorted_list_of_set (\\<Union> (A ` {..<k}) \\<union> A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "also"], ["proof (state)\nthis:\n  sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n  sorted_list_of_set (\\<Union> (A ` {..<k}) \\<union> A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "have \"\\<dots> = sorted_list_of_set (\\<Union> (A ` {..<k})) @ sorted_list_of_set (A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..<k}) \\<union> A k) =\n    sorted_list_of_set (\\<Union> (A ` {..<k})) @ sorted_list_of_set (A k)", "by (rule sorted_list_of_set_Un) (auto simp: Suc.prems ls)"], ["proof (state)\nthis:\n  sorted_list_of_set (\\<Union> (A ` {..<k}) \\<union> A k) =\n  sorted_list_of_set (\\<Union> (A ` {..<k})) @ sorted_list_of_set (A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "also"], ["proof (state)\nthis:\n  sorted_list_of_set (\\<Union> (A ` {..<k}) \\<union> A k) =\n  sorted_list_of_set (\\<Union> (A ` {..<k})) @ sorted_list_of_set (A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "have \"\\<dots> = concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k})) @ sorted_list_of_set (A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..<k})) @ sorted_list_of_set (A k) =\n    concat\n     (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k})) @\n    sorted_list_of_set (A k)", "using Suc strict_mono_sets_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>strict_mono_sets {..<k} A;\n   \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n  \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<k})) =\n                    concat\n                     (map (sorted_list_of_set \\<circ> A)\n                       (sorted_list_of_set {..<k}))\n  strict_mono_sets {..<Suc k} A\n  ?i < Suc k \\<Longrightarrow> finite (A ?i)\n  strict_mono_sets ?A ?f \\<equiv>\n  \\<forall>x\\<in>?A.\n     \\<forall>y\\<in>?A. x < y \\<longrightarrow> ?f x \\<lless> ?f y\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..<k})) @ sorted_list_of_set (A k) =\n    concat\n     (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k})) @\n    sorted_list_of_set (A k)", "by fastforce"], ["proof (state)\nthis:\n  sorted_list_of_set (\\<Union> (A ` {..<k})) @ sorted_list_of_set (A k) =\n  concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k})) @\n  sorted_list_of_set (A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "also"], ["proof (state)\nthis:\n  sorted_list_of_set (\\<Union> (A ` {..<k})) @ sorted_list_of_set (A k) =\n  concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k})) @\n  sorted_list_of_set (A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "have \"\\<dots> = concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<Suc k}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k})) @\n    sorted_list_of_set (A k) =\n    concat\n     (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<Suc k}))", "using strict_mono_sets_def"], ["proof (prove)\nusing this:\n  strict_mono_sets ?A ?f \\<equiv>\n  \\<forall>x\\<in>?A.\n     \\<forall>y\\<in>?A. x < y \\<longrightarrow> ?f x \\<lless> ?f y\n\ngoal (1 subgoal):\n 1. concat\n     (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k})) @\n    sorted_list_of_set (A k) =\n    concat\n     (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<Suc k}))", "by fastforce"], ["proof (state)\nthis:\n  concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<k})) @\n  sorted_list_of_set (A k) =\n  concat\n   (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<Suc k}))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>strict_mono_sets {..<k} A;\n                 \\<And>i. i < k \\<Longrightarrow> finite (A i)\\<rbrakk>\n                \\<Longrightarrow> sorted_list_of_set\n                                   (\\<Union> (A ` {..<k})) =\n                                  concat\n                                   (map (sorted_list_of_set \\<circ> A)\n                                     (sorted_list_of_set {..<k}));\n        strict_mono_sets {..<Suc k} A;\n        \\<And>i. i < Suc k \\<Longrightarrow> finite (A i)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n                         concat\n                          (map (sorted_list_of_set \\<circ> A)\n                            (sorted_list_of_set {..<Suc k}))", "finally"], ["proof (chain)\npicking this:\n  sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n  concat\n   (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<Suc k}))", "show ?case"], ["proof (prove)\nusing this:\n  sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n  concat\n   (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<Suc k}))\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n    concat\n     (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<Suc k}))", "."], ["proof (state)\nthis:\n  sorted_list_of_set (\\<Union> (A ` {..<Suc k})) =\n  concat\n   (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..<Suc k}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_list_of_set_UN_atMost:\n  fixes k::nat\n  assumes \"strict_mono_sets {..k} A\" and \"\\<And>i. i \\<le> k \\<Longrightarrow> finite (A i)\"\n  shows \"sorted_list_of_set (\\<Union>i\\<le>k. A i) = concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..k}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (\\<Union> (A ` {..k})) =\n    concat (map (sorted_list_of_set \\<circ> A) (sorted_list_of_set {..k}))", "by (metis assms lessThan_Suc_atMost less_Suc_eq_le sorted_list_of_set_UN_lessThan)"], ["", "subsection \\<open>Monotonic enumeration of a countably infinite set\\<close>"], ["", "abbreviation \"enum \\<equiv> enumerate\""], ["", "text \\<open>Could be generalised to infinite countable sets of any type\\<close>"], ["", "lemma nat_infinite_iff:\n  fixes N :: \"nat set\"\n  shows \"infinite N \\<longleftrightarrow> (\\<exists>f::nat\\<Rightarrow>nat. N = range f \\<and> strict_mono f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite N = (\\<exists>f. N = range f \\<and> strict_mono f)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. infinite N \\<Longrightarrow>\n    \\<exists>f. N = range f \\<and> strict_mono f\n 2. \\<And>f.\n       \\<lbrakk>strict_mono f; N = range f; finite (range f)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"infinite N\""], ["proof (state)\nthis:\n  infinite N\n\ngoal (2 subgoals):\n 1. infinite N \\<Longrightarrow>\n    \\<exists>f. N = range f \\<and> strict_mono f\n 2. \\<And>f.\n       \\<lbrakk>strict_mono f; N = range f; finite (range f)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  infinite N", "show \"\\<exists>f. N = range (f::nat \\<Rightarrow> nat) \\<and> strict_mono f\""], ["proof (prove)\nusing this:\n  infinite N\n\ngoal (1 subgoal):\n 1. \\<exists>f. N = range f \\<and> strict_mono f", "by (metis bij_betw_imp_surj_on bij_enumerate enumerate_mono strict_mono_def)"], ["proof (state)\nthis:\n  \\<exists>f. N = range f \\<and> strict_mono f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>strict_mono f; N = range f; finite (range f)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>strict_mono f; N = range f; finite (range f)\\<rbrakk>\n       \\<Longrightarrow> False", "fix f :: \"nat \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>strict_mono f; N = range f; finite (range f)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"strict_mono f\" and \"N = range f\" and \"finite (range f)\""], ["proof (state)\nthis:\n  strict_mono f\n  N = range f\n  finite (range f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>strict_mono f; N = range f; finite (range f)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  strict_mono f\n  N = range f\n  finite (range f)", "show False"], ["proof (prove)\nusing this:\n  strict_mono f\n  N = range f\n  finite (range f)\n\ngoal (1 subgoal):\n 1. False", "using range_inj_infinite strict_mono_imp_inj_on"], ["proof (prove)\nusing this:\n  strict_mono f\n  N = range f\n  finite (range f)\n  inj ?f \\<Longrightarrow> infinite (range ?f)\n  strict_mono ?f \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enum_works:\n  fixes N :: \"nat set\"\n  assumes \"infinite N\"\n  shows \"N = range (enum N) \\<and> strict_mono (enum N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = range (enum N) \\<and> strict_mono (enum N)", "by (metis assms bij_betw_imp_surj_on bij_enumerate enumerate_mono strict_monoI)"], ["", "lemma range_enum: \"range (enum N) = N\" and strict_mono_enum: \"strict_mono (enum N)\"\n  if \"infinite N\" for N :: \"nat set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (enum N) = N &&& strict_mono (enum N)", "using enum_works [OF that]"], ["proof (prove)\nusing this:\n  N = range (enum N) \\<and> strict_mono (enum N)\n\ngoal (1 subgoal):\n 1. range (enum N) = N &&& strict_mono (enum N)", "by auto"], ["", "lemma enum_0_eq_Inf:\n  fixes N :: \"nat set\"\n  assumes \"infinite N\"\n  shows \"enum N 0 = Inf N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "have \"enum N 0 \\<in> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum N 0 \\<in> N", "using assms range_enum"], ["proof (prove)\nusing this:\n  infinite N\n  infinite ?N \\<Longrightarrow> range (enum ?N) = ?N\n\ngoal (1 subgoal):\n 1. enum N 0 \\<in> N", "by auto"], ["proof (state)\nthis:\n  enum N 0 \\<in> N\n\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "moreover"], ["proof (state)\nthis:\n  enum N 0 \\<in> N\n\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "have \"\\<And>x. x \\<in> N \\<Longrightarrow> enum N 0 \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> N \\<Longrightarrow> enum N 0 \\<le> x", "by (metis (mono_tags, hide_lams) assms imageE le0 less_mono_imp_le_mono range_enum strict_monoD strict_mono_enum)"], ["proof (state)\nthis:\n  ?x \\<in> N \\<Longrightarrow> enum N 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "ultimately"], ["proof (chain)\npicking this:\n  enum N 0 \\<in> N\n  ?x \\<in> N \\<Longrightarrow> enum N 0 \\<le> ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  enum N 0 \\<in> N\n  ?x \\<in> N \\<Longrightarrow> enum N 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "by (metis cInf_eq_minimum)"], ["proof (state)\nthis:\n  enum N 0 = \\<Sqinter> N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enum_works_finite:\n  fixes N :: \"nat set\"\n  assumes \"finite N\"\n  shows \"N = enum N ` {..<card N} \\<and> strict_mono_on (enum N) {..<card N}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = enum N ` {..<card N} \\<and> strict_mono_on (enum N) {..<card N}", "using assms"], ["proof (prove)\nusing this:\n  finite N\n\ngoal (1 subgoal):\n 1. N = enum N ` {..<card N} \\<and> strict_mono_on (enum N) {..<card N}", "by (metis bij_betw_imp_surj_on finite_bij_enumerate finite_enumerate_mono lessThan_iff strict_mono_onI)"], ["", "lemma enum_obtain_index_finite:\n  fixes N :: \"nat set\"\n  assumes \"x \\<in> N\" \"finite N\" \n  obtains i where \"i < card N\" \"x = enum N i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < card N; x = enum N i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>x \\<in> N\\<close> \\<open>finite N\\<close> enum_works_finite imageE lessThan_iff)"], ["", "lemma enum_0_eq_Inf_finite:\n  fixes N :: \"nat set\"\n  assumes \"finite N\" \"N \\<noteq> {}\"\n  shows \"enum N 0 = Inf N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "have \"enum N 0 \\<in> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum N 0 \\<in> N", "by (metis Nat.neq0_conv assms empty_is_image enum_works_finite image_eqI lessThan_empty_iff lessThan_iff)"], ["proof (state)\nthis:\n  enum N 0 \\<in> N\n\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "moreover"], ["proof (state)\nthis:\n  enum N 0 \\<in> N\n\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "have \"enum N 0 \\<le> x\" if \"x \\<in> N\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum N 0 \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. enum N 0 \\<le> x", "obtain i where \"i < card N\" \"x = enum N i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < card N; x = enum N i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>x \\<in> N\\<close> \\<open>finite N\\<close> enum_obtain_index_finite)"], ["proof (state)\nthis:\n  i < card N\n  x = enum N i\n\ngoal (1 subgoal):\n 1. enum N 0 \\<le> x", "with assms"], ["proof (chain)\npicking this:\n  finite N\n  N \\<noteq> {}\n  i < card N\n  x = enum N i", "show ?thesis"], ["proof (prove)\nusing this:\n  finite N\n  N \\<noteq> {}\n  i < card N\n  x = enum N i\n\ngoal (1 subgoal):\n 1. enum N 0 \\<le> x", "by (metis Nat.neq0_conv finite_enumerate_mono less_or_eq_imp_le)"], ["proof (state)\nthis:\n  enum N 0 \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> N \\<Longrightarrow> enum N 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "ultimately"], ["proof (chain)\npicking this:\n  enum N 0 \\<in> N\n  ?x \\<in> N \\<Longrightarrow> enum N 0 \\<le> ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  enum N 0 \\<in> N\n  ?x \\<in> N \\<Longrightarrow> enum N 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. enum N 0 = \\<Sqinter> N", "by (metis cInf_eq_minimum)"], ["proof (state)\nthis:\n  enum N 0 = \\<Sqinter> N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma greaterThan_less_enum:\n  fixes N :: \"nat set\"\n  assumes \"N \\<subseteq> {x<..}\" \"infinite N\"\n  shows \"x < enum N i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < enum N i", "using assms range_enum"], ["proof (prove)\nusing this:\n  N \\<subseteq> {x<..}\n  infinite N\n  infinite ?N \\<Longrightarrow> range (enum ?N) = ?N\n\ngoal (1 subgoal):\n 1. x < enum N i", "by fastforce"], ["", "lemma atLeast_le_enum:\n  fixes N :: \"nat set\"\n  assumes \"N \\<subseteq> {x..}\" \"infinite N\"\n  shows \"x \\<le> enum N i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> enum N i", "using assms range_enum"], ["proof (prove)\nusing this:\n  N \\<subseteq> {x..}\n  infinite N\n  infinite ?N \\<Longrightarrow> range (enum ?N) = ?N\n\ngoal (1 subgoal):\n 1. x \\<le> enum N i", "by fastforce"], ["", "lemma less_sets_empty1 [simp]: \"less_sets {} A\" and less_sets_empty2 [simp]: \"less_sets A {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<lless> A &&& A \\<lless> {}", "by (simp_all add: less_sets_def)"], ["", "lemma less_sets_singleton1 [simp]: \"less_sets {a} A \\<longleftrightarrow> (\\<forall>x\\<in>A. a < x)\" \n  and less_sets_singleton2 [simp]: \"less_sets A {a} \\<longleftrightarrow> (\\<forall>x\\<in>A. x < a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a} \\<lless> A) = (\\<forall>x\\<in>A. a < x) &&&\n    (A \\<lless> {a}) = (\\<forall>x\\<in>A. x < a)", "by (simp_all add: less_sets_def)"], ["", "lemma less_sets_atMost [simp]: \"less_sets {..a} A \\<longleftrightarrow> (\\<forall>x\\<in>A. a < x)\" \n  and less_sets_alLeast [simp]: \"less_sets A {a..} \\<longleftrightarrow> (\\<forall>x\\<in>A. x < a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({..a} \\<lless> A) = (\\<forall>x\\<in>A. a < x) &&&\n    (A \\<lless> {a..}) = (\\<forall>x\\<in>A. x < a)", "by (auto simp: less_sets_def)"], ["", "lemma less_sets_imp_strict_mono_sets:\n  assumes \"\\<And>i. less_sets (A i) (A (Suc i))\" \"\\<And>i. i>0 \\<Longrightarrow> A i \\<noteq> {}\"\n  shows \"strict_mono_sets UNIV A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono_sets UNIV A", "proof (clarsimp simp: strict_mono_sets_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x < y \\<Longrightarrow> A x \\<lless> A y", "fix i j::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x < y \\<Longrightarrow> A x \\<lless> A y", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>x y. x < y \\<Longrightarrow> A x \\<lless> A y", "then"], ["proof (chain)\npicking this:\n  i < j", "show \"less_sets (A i) (A j)\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. A i \\<lless> A j", "proof (induction \"j-i\" arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 = j - i; i < j\\<rbrakk> \\<Longrightarrow> A i \\<lless> A j\n 2. \\<And>x i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>x = j - i; i < j\\<rbrakk>\n                   \\<Longrightarrow> A i \\<lless> A j;\n        Suc x = j - i; i < j\\<rbrakk>\n       \\<Longrightarrow> A i \\<lless> A j", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?j - ?i; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> A ?i \\<lless> A ?j\n  Suc x = j - i\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 = j - i; i < j\\<rbrakk> \\<Longrightarrow> A i \\<lless> A j\n 2. \\<And>x i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>x = j - i; i < j\\<rbrakk>\n                   \\<Longrightarrow> A i \\<lless> A j;\n        Suc x = j - i; i < j\\<rbrakk>\n       \\<Longrightarrow> A i \\<lless> A j", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?j - ?i; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> A ?i \\<lless> A ?j\n  Suc x = j - i\n  i < j", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?j - ?i; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> A ?i \\<lless> A ?j\n  Suc x = j - i\n  i < j\n\ngoal (1 subgoal):\n 1. A i \\<lless> A j", "by (metis Suc_diff_Suc Suc_inject Suc_mono assms less_Suc_eq less_sets_trans zero_less_Suc)"], ["proof (state)\nthis:\n  A i \\<lless> A j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 = j - i; i < j\\<rbrakk> \\<Longrightarrow> A i \\<lless> A j", "qed auto"], ["proof (state)\nthis:\n  A i \\<lless> A j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_sets_Suc_Max:  \n  assumes \"finite A\"\n  shows \"less_sets A {Suc (Max A)..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<lless> {Suc (Max A)..}", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> A \\<lless> {Suc (Max A)..}\n 2. A \\<noteq> {} \\<Longrightarrow> A \\<lless> {Suc (Max A)..}", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> A \\<lless> {Suc (Max A)..}\n 2. A \\<noteq> {} \\<Longrightarrow> A \\<lless> {Suc (Max A)..}", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<lless> {Suc (Max A)..}", "by (simp add: assms less_Suc_eq_le)"], ["proof (state)\nthis:\n  A \\<lless> {Suc (Max A)..}\n\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow> A \\<lless> {Suc (Max A)..}", "qed auto"], ["", "lemma infinite_nat_greaterThan:\n  fixes m::nat\n  assumes \"infinite N\"\n  shows \"infinite (N \\<inter> {m<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (N \\<inter> {m<..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (N \\<inter> {m<..})", "have \"N \\<subseteq> -{m<..} \\<union> (N \\<inter> {m<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<subseteq> - {m<..} \\<union> N \\<inter> {m<..}", "by blast"], ["proof (state)\nthis:\n  N \\<subseteq> - {m<..} \\<union> N \\<inter> {m<..}\n\ngoal (1 subgoal):\n 1. infinite (N \\<inter> {m<..})", "moreover"], ["proof (state)\nthis:\n  N \\<subseteq> - {m<..} \\<union> N \\<inter> {m<..}\n\ngoal (1 subgoal):\n 1. infinite (N \\<inter> {m<..})", "have \"finite (-{m<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (- {m<..})", "by simp"], ["proof (state)\nthis:\n  finite (- {m<..})\n\ngoal (1 subgoal):\n 1. infinite (N \\<inter> {m<..})", "ultimately"], ["proof (chain)\npicking this:\n  N \\<subseteq> - {m<..} \\<union> N \\<inter> {m<..}\n  finite (- {m<..})", "show ?thesis"], ["proof (prove)\nusing this:\n  N \\<subseteq> - {m<..} \\<union> N \\<inter> {m<..}\n  finite (- {m<..})\n\ngoal (1 subgoal):\n 1. infinite (N \\<inter> {m<..})", "using assms finite_subset"], ["proof (prove)\nusing this:\n  N \\<subseteq> - {m<..} \\<union> N \\<inter> {m<..}\n  finite (- {m<..})\n  infinite N\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. infinite (N \\<inter> {m<..})", "by blast"], ["proof (state)\nthis:\n  infinite (N \\<inter> {m<..})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}