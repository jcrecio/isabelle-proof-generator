{"file_name": "/home/qj213/afp-2021-10-22/thys/Zeta_3_Irrational/Zeta_3_Irrational.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Zeta_3_Irrational", "problem_names": ["lemma degree_higher_pderiv: \"degree ((pderiv ^^ n) p) = degree p - n\"\n  for p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors,semiring_char_0} poly\"", "lemma pcompose_power_left: \"pcompose (p ^ n) q = pcompose p q ^ n\"", "lemma pderiv_sum: \"pderiv (\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. pderiv (f x))\"", "lemma higher_pderiv_minus: \"(pderiv ^^ n) (-p :: 'a :: idom poly) = -(pderiv ^^ n) p\"", "lemma pderiv_power: \"pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1)) * pderiv p\"", "lemma pderiv_monom: \"pderiv (monom c n) = monom (of_nat n * c) (n - 1)\"", "lemma higher_pderiv_monom:\n  \"k \\<le> n \\<Longrightarrow> (pderiv ^^ k) (monom c n) = monom (of_nat (pochhammer (n - k + 1) k) * c) (n - k)\"", "lemma higher_pderiv_mult:\n  \"(pderiv ^^ n) (p * q) =\n     (\\<Sum>k\\<le>n. Polynomial.smult (of_nat (n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q))\"", "theorem (in pair_sigma_finite) Fubini_set_integrable:\n  fixes f :: \"_ \\<Rightarrow> _::{banach, second_countable_topology}\"\n  assumes f[measurable]: \"set_borel_measurable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\"\n    and integ1: \"set_integrable M1 A (\\<lambda>x. \\<integral>y\\<in>B. norm (f (x, y)) \\<partial>M2)\"\n    and integ2: \"AE x\\<in>A in M1. set_integrable M2 B (\\<lambda>y. f (x, y))\"\n  shows \"set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\"", "lemma (in pair_sigma_finite) set_integral_fst':\n  fixes f :: \"_ \\<Rightarrow> 'c :: {second_countable_topology, banach}\"\n  assumes \"set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\"\n  shows   \"set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n             (\\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y) \\<partial>M2) \\<partial>M1)\"", "lemma (in pair_sigma_finite) set_integral_snd:\n  fixes f :: \"_ \\<Rightarrow> 'c :: {second_countable_topology, banach}\"\n  assumes \"set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\"\n  shows   \"set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n             (\\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y) \\<partial>M1) \\<partial>M2)\"", "lemma (in pair_sigma_finite) nn_integral_swap:\n  assumes [measurable]: \"f \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)\"\n  shows \"(\\<integral>\\<^sup>+x. f x \\<partial>(M1 \\<Otimes>\\<^sub>M M2)) = (\\<integral>\\<^sup>+(y,x). f (x,y) \\<partial>(M2 \\<Otimes>\\<^sub>M M1))\"", "lemma set_integrable_bound:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n    and g :: \"'a \\<Rightarrow> 'c::{banach, second_countable_topology}\"\n  shows \"set_integrable M A f \\<Longrightarrow> set_borel_measurable M A g \\<Longrightarrow>\n           (AE x in M. x \\<in> A \\<longrightarrow> norm (g x) \\<le> norm (f x)) \\<Longrightarrow> set_integrable M A g\"", "lemma set_integrableI_nonneg:\n  fixes f :: \"'a \\<Rightarrow> real\"\n  assumes \"set_borel_measurable M A f\"\n  assumes \"AE x in M. x \\<in> A \\<longrightarrow> 0 \\<le> f x\" \"(\\<integral>\\<^sup>+x\\<in>A. f x \\<partial>M) < \\<infinity>\"\n  shows \"set_integrable M A f\"", "lemma set_integral_eq_nn_integral:\n  assumes \"set_borel_measurable M A f\"\n  assumes \"set_nn_integral M A f = ennreal x\" \"x \\<ge> 0\"\n  assumes \"AE x in M. x \\<in> A \\<longrightarrow> f x \\<ge> 0\"\n  shows   \"set_integrable M A f\"\n    and   \"set_lebesgue_integral M A f = x\"", "lemma set_integral_0 [simp, intro]: \"set_integrable M A (\\<lambda>y. 0)\"", "lemma set_integrable_sum:\n  fixes f :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ :: {banach, second_countable_topology}\"\n  assumes \"finite B\"\n  assumes \"\\<And>x. x \\<in> B \\<Longrightarrow> set_integrable M A (f x)\"\n  shows \"set_integrable M A (\\<lambda>y. \\<Sum>x\\<in>B. f x y)\"", "lemma set_integral_sum:\n  fixes f :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ :: {banach, second_countable_topology}\"\n  assumes \"finite B\"\n  assumes \"\\<And>x. x \\<in> B \\<Longrightarrow> set_integrable M A (f x)\"\n  shows \"set_lebesgue_integral M A (\\<lambda>y. \\<Sum>x\\<in>B. f x y) = (\\<Sum>x\\<in>B. set_lebesgue_integral M A (f x))\"", "lemma set_nn_integral_cong:\n  assumes \"M = M'\" \"A = B\" \"\\<And>x. x \\<in> space M \\<inter> A \\<Longrightarrow> f x = g x\"\n  shows   \"set_nn_integral M A f = set_nn_integral M' B g\"", "lemma set_nn_integral_mono:\n  assumes \"\\<And>x. x \\<in> space M \\<inter> A \\<Longrightarrow> f x \\<le> g x\"\n  shows   \"set_nn_integral M A f \\<le> set_nn_integral M A g\"", "lemma\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes \"a \\<le> b\"\n  assumes deriv: \"\\<And>x. a \\<le> x \\<Longrightarrow> x \\<le> b \\<Longrightarrow> (F has_field_derivative f x) (at x within {a..b})\"\n  assumes cont: \"continuous_on {a..b} f\"\n  shows has_bochner_integral_FTC_Icc_real:\n      \"has_bochner_integral lborel (\\<lambda>x. f x * indicator {a .. b} x) (F b - F a)\" (is ?has)\n    and integral_FTC_Icc_real: \"(\\<integral>x. f x * indicator {a .. b} x \\<partial>lborel) = F b - F a\" (is ?eq)", "lemma integral_by_parts_integrable:\n  fixes f g F G::\"real \\<Rightarrow> real\"\n  assumes \"a \\<le> b\"\n  assumes cont_f[intro]: \"continuous_on {a..b} f\"\n  assumes cont_g[intro]: \"continuous_on {a..b} g\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (F has_field_derivative f x) (at x within {a..b})\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (G has_field_derivative g x) (at x within {a..b})\"\n  shows  \"integrable lborel (\\<lambda>x.((F x) * (g x) + (f x) * (G x)) * indicator {a .. b} x)\"", "lemma integral_by_parts:\n  fixes f g F G::\"real \\<Rightarrow> real\"\n  assumes [arith]: \"a \\<le> b\"\n  assumes cont_f[intro]: \"continuous_on {a..b} f\"\n  assumes cont_g[intro]: \"continuous_on {a..b} g\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (F has_field_derivative f x) (at x within {a..b})\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (G has_field_derivative g x) (at x within {a..b})\"\n  shows \"(\\<integral>x. (F x * g x) * indicator {a .. b} x \\<partial>lborel)\n            =  F b * G b - F a * G a - \\<integral>x. (f x * G x) * indicator {a .. b} x \\<partial>lborel\"", "lemma interval_lebesgue_integral_by_parts:\n  assumes \"a \\<le> b\"\n  assumes cont_f[intro]: \"continuous_on {a..b} f\"\n  assumes cont_g[intro]: \"continuous_on {a..b} g\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (F has_field_derivative f x) (at x within {a..b})\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (G has_field_derivative g x) (at x within {a..b})\"\n  shows \"(LBINT x=a..b. F x * g x) = F b * G b - F a * G a - (LBINT x=a..b. f x * G x)\"", "lemma interval_lebesgue_integral_by_parts_01:\n  assumes cont_f[intro]: \"continuous_on {0..1} f\"\n  assumes cont_g[intro]: \"continuous_on {0..1} g\"\n  assumes [intro]: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> (F has_field_derivative f x) (at x within {0..1})\"\n  assumes [intro]: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> (G has_field_derivative g x) (at x within {0..1})\"\n  shows \"(LBINT x=0..1. F x * g x) = F 1 * G 1 - F 0 * G 0 - (LBINT x=0..1. f x * G x)\"", "lemma continuous_on_imp_set_integrable_cbox:\n  fixes h :: \"'a :: euclidean_space \\<Rightarrow> real\"\n  assumes \"continuous_on (cbox a b) h\"\n  shows   \"set_integrable lborel (cbox a b) h\"", "lemma gen_shleg_poly_altdef:\n  assumes \"k \\<le> n\"\n  shows \"gen_shleg_poly k =\n            (\\<Sum>i\\<le>k. smult ((-1)^(k-i) * of_nat (k choose i) *\n                    pochhammer (n-i+1) i * pochhammer (n-k+i+1) (k-i))\n                    ([:0, 1:] ^ (n - i) * [:1, -1:] ^ (n-k+i)))\"", "lemma degree_gen_shleg_poly [simp]: \"degree (gen_shleg_poly k) = 2 * n - k\"", "lemma gen_shleg_poly_n: \"gen_shleg_poly n = smult (fact n) shleg_poly\"", "lemma degree_shleg_poly [simp]: \"degree shleg_poly = n\"", "lemma pderiv_gen_shleg_poly [simp]: \"pderiv (gen_shleg_poly k) = gen_shleg_poly (Suc k)\"", "lemma Gen_Shleg_altdef:\n  assumes \"k \\<le> n\"\n  shows   \"Gen_Shleg k x = (\\<Sum>i\\<le>k. (-1)^(k-i) * of_nat (k choose i) *\n                            of_int (pochhammer (n-i+1) i * pochhammer (n-k+i+1) (k-i)) *\n                            x ^ (n - i) * (1 - x) ^ (n-k+i))\"", "lemma Gen_Shleg_0 [simp]: \"k < n \\<Longrightarrow> Gen_Shleg k 0 = 0\"", "lemma Gen_Shleg_1 [simp]: \"k < n \\<Longrightarrow> Gen_Shleg k 1 = 0\"", "lemma Gen_Shleg_n_0 [simp]: \"Gen_Shleg n 0 = fact n\"", "lemma Gen_Shleg_n_1 [simp]: \"Gen_Shleg n 1 = (-1) ^ n * fact n\"", "lemma Shleg_altdef: \"Shleg x = Gen_Shleg n x / fact n\"", "lemma Shleg_0 [simp]: \"Shleg 0 = 1\" and Shleg_1 [simp]: \"Shleg 1 = (-1) ^ n\"", "lemma Gen_Shleg_0_left: \"Gen_Shleg 0 x = x ^ n * (1 - x) ^ n\"", "lemma has_field_derivative_Gen_Shleg:\n  \"(Gen_Shleg k has_field_derivative Gen_Shleg (Suc k) x) (at x)\"", "lemma continuous_on_Gen_Shleg: \"continuous_on A (Gen_Shleg k)\"", "lemma continuous_on_Gen_Shleg' [continuous_intros]:\n  \"continuous_on A f \\<Longrightarrow> continuous_on A (\\<lambda>x. Gen_Shleg k (f x))\"", "lemma continuous_on_Shleg: \"continuous_on A Shleg\"", "lemma continuous_on_Shleg' [continuous_intros]:\n  \"continuous_on A f \\<Longrightarrow> continuous_on A (\\<lambda>x. Shleg (f x))\"", "lemma measurable_Gen_Shleg [measurable]: \"Gen_Shleg n \\<in> borel_measurable borel\"", "lemma measurable_Shleg [measurable]: \"Shleg \\<in> borel_measurable borel\"", "lemma Re_zeta_ge_1:\n  assumes \"x > 1\"\n  shows   \"Re (zeta (of_real x)) \\<ge> 1\"", "lemma sums_zeta_of_nat_offset:\n  fixes r :: nat\n  assumes n: \"n > 1\"\n  shows \"(\\<lambda>k. 1 / (r + k + 1) ^ n) sums (zeta (of_nat n) - (\\<Sum>k=1..r. 1 / k ^ n))\"", "lemma sums_Re_zeta_of_nat_offset:\n  fixes r :: nat\n  assumes n: \"n > 1\"\n  shows \"(\\<lambda>k. 1 / (r + k + 1) ^ n) sums (Re (zeta (of_nat n)) - (\\<Sum>k=1..r. 1 / k ^ n))\"", "lemma sum_rationals_common_divisor:\n  fixes f g :: \"'a \\<Rightarrow> int\"\n  assumes \"finite A\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0\"\n  shows   \"\\<exists>c. (\\<Sum>x\\<in>A. f x / g x) = real_of_int c / (LCM x\\<in>A. g x)\"", "lemma sum_rationals_common_divisor':\n  fixes f g :: \"'a \\<Rightarrow> int\"\n  assumes \"finite A\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0\" and \"(\\<And>x. x \\<in> A \\<Longrightarrow> g x dvd d)\" and \"d \\<noteq> 0\"\n  shows   \"\\<exists>c. (\\<Sum>x\\<in>A. f x / g x) = real_of_int c / real_of_int d\"", "lemma\n  fixes x y z :: real\n  assumes xyz: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\" \"z \\<in> {0..1}\"\n  shows beukers_denom_ineq: \"(1 - x * y) * z < 1\" and beukers_denom_neq: \"(1 - x * y) * z \\<noteq> 1\"", "lemma integral_0_1_ln_times_powr:\n  assumes \"e > -1\"\n  shows   \"(LBINT x=0..1. -ln x * x powr e) = 1 / (e + 1)\\<^sup>2\"\n    and   \"interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. -ln x * x powr e)\"", "lemma interval_lebesgue_integral_lborel_01_cong:\n  assumes \"\\<And>x. x \\<in> {0<..<1} \\<Longrightarrow> f x = g x\"\n  shows   \"interval_lebesgue_integral lborel 0 1 f =\n           interval_lebesgue_integral lborel 0 1 g\"", "lemma nn_integral_0_1_ln_times_powr:\n  assumes \"e > -1\"\n  shows    \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y powr e) \\<partial>lborel) = ennreal (1 / (e + 1)\\<^sup>2)\"", "lemma nn_integral_0_1_ln_times_power:\n  \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y ^ n) \\<partial>lborel) = ennreal (1 / (n + 1)\\<^sup>2)\"", "lemma nn_integral_0_1_power:\n  \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (y ^ n) \\<partial>lborel) = ennreal (1 / (n + 1))\"", "lemma beukers_nn_integral1_altdef:\n  \"beukers_nn_integral1 r s =\n     (\\<integral>\\<^sup>+(w,x,y)\\<in>{0<..<1}\\<times>{0<..<1}\\<times>{0<..<1}.\n       ennreal (1 / (1-(1-x*y)*w) * x^r * y^s) \\<partial>lborel)\"", "lemma beukers_nn_integral1_series:\n  \"beukers_nn_integral1 r s = (\\<Sum>k. ennreal (1/((k+r+1)^2*(k+s+1)) + 1/((k+r+1)*(k+s+1)^2)))\"", "lemma beukers_nn_integral1_same:\n  assumes \"r = s\"\n  shows   \"beukers_nn_integral1 r s = ennreal (2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3)))\"\n    and   \"2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3)) \\<ge> 0\"", "lemma beukers_integral1_same:\n  assumes \"r = s\"\n  shows   \"beukers_integral1 r s = 2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3))\"", "lemma beukers_nn_integral1_different:\n  assumes \"r > s\"\n  shows   \"beukers_nn_integral1 r s = ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / k ^ 2) / (r - s))\"", "lemma beukers_integral1_different:\n  assumes \"r > s\"\n  shows   \"beukers_integral1 r s = (\\<Sum>k\\<in>{s<..r}. 1 / k ^ 2) / (r - s)\"", "lemma beukers_nn_integral1_swap:\n  \"beukers_nn_integral1 r s = beukers_nn_integral1 s r\"", "lemma beukers_nn_integral1_finite: \"beukers_nn_integral1 r s < \\<infinity>\"", "lemma beukers_integral1_integrable:\n  \"set_integrable lborel ({0<..<1}\\<times>{0<..<1})\n     (\\<lambda>(x,y). (-ln (x*y) / (1 - x*y) * x^r * y^s :: real))\"", "lemma beukers_integral1_integrable':\n  \"set_integrable lborel ({0<..<1}\\<times>{0<..<1}\\<times>{0<..<1})\n     (\\<lambda>(z,x,y). (x^r * y^s / (1 - (1 - x*y) * z) :: real))\"", "lemma beukers_integral1_conv_nn_integral:\n  \"beukers_integral1 r s = enn2real (beukers_nn_integral1 r s)\"", "lemma beukers_integral1_swap: \"beukers_integral1 r s = beukers_integral1 s r\"", "lemma beukers_integral2_conv_int_combination:\n  obtains A B :: int where \"A > 0\" and\n    \"beukers_integral2 = of_int A * Re (zeta 3) + of_int B / of_nat (Lcm {1..n} ^ 3)\"", "lemma beukers_integral2_integrable:\n  \"set_integrable lborel D (\\<lambda>(x,y). -ln (x*y) / (1 - x*y) * P x * P y)\"", "lemma beukers_integral3_integrand_bound:\n  fixes x y z :: real\n  assumes xyz: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\" \"z \\<in> {0<..<1}\"\n  shows   \"(x*(1-x)*y*(1-y)*z*(1-z)) / (1-(1-x*y)*z) \\<le> 1 / 27\" (is \"?lhs \\<le> _\")", "lemma beukers_nn_integral3_le:\n  \"beukers_nn_integral3 \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))\"", "lemma beukers_nn_integral3_finite: \"beukers_nn_integral3 < \\<infinity>\"", "lemma beukers_integral3_integrable:\n  \"set_integrable lborel D' (\\<lambda>(w,x,y). (x*(1-x)*y*(1-y)*w*(1-w))^n / (1-(1-x*y)*w)^(n+1))\"", "lemma beukers_integral3_conv_nn_integral:\n  \"beukers_integral3 = enn2real beukers_nn_integral3\"", "lemma beukers_integral3_le: \"beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\"", "lemma beukers_nn_integral3_pos: \"beukers_nn_integral3 > 0\"", "lemma beukers_integral3_pos: \"beukers_integral3 > 0\"", "lemma beukers_aux_ln_conv_integral:\n  fixes x y :: real\n  assumes xy: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\"\n  shows \"-ln (x*y) / (1-x*y) = (LBINT z=0..1. 1 / (1-(1-x*y)*z))\"", "lemma beukers_aux_by_parts_aux:\n  assumes xz: \"x \\<in> {0<..<1}\" \"z \\<in> {0<..<1}\" and \"k \\<le> n\"\n  shows \"(LBINT y=0..1. Q n y * (1/(1-(1-x*y)*z))) =\n         (LBINT y=0..1. Q (n-k) y * (fact k * (x*z)^k / (1-(1-x*y)*z) ^ (k+1)))\"", "lemma beukers_aux_by_parts:\n  assumes xz: \"x \\<in> {0<..<1}\" \"z \\<in> {0<..<1}\"\n  shows \"(LBINT y=0..1. P y / (1-(1-x*y)*z)) =\n         (LBINT y=0..1. (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z) ^ (n+1))\"", "lemma beukers_aux_integral_transform1:\n  fixes z :: real\n  assumes z: \"z \\<in> {0<..<1}\"\n  shows   \"(LBINT (x,y):D. P x * P y / (1-(1-x*y)*z)) =\n           (LBINT (x,y):D. P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1))\"", "lemma beukers_aux_integral_transform2:\n  assumes xy: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\"\n  shows \"(LBINT z=0..1. (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)) =\n         (LBINT w=0..1. (1-w)^n * (1-y)^n / (1-(1-x*y)*w))\"", "lemma beukers_aux_integral_transform3:\n  assumes w: \"w \\<in> {0<..<1}\"\n  shows   \"(LBINT (x,y):D. P x * (1-y)^n / (1-(1-x*y)*w)) =\n           (LBINT (x,y):D. (1-y)^n * (x*y*w)^n * (1-x)^n / (1-(1-x*y)*w)^(n+1))\"", "lemma beukers_aux_integrable1:\n  \"set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x,y),z). P x * P y / (1-(1-x*y)*z))\"", "lemma beukers_aux_integrable2:\n  \"set_integrable lborel D' (\\<lambda>(z,x,y). P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z) ^ (n+1))\"", "lemma beukers_aux_integrable3:\n  \"set_integrable lborel D' (\\<lambda>(w,x,y). P x * (1-w)^n * (1-y)^n / (1-(1-x*y)*w))\"", "lemma beukers_integral2_conv_3: \"beukers_integral2 = beukers_integral3\"", "lemma zeta_3_linear_combination_bounds:\n  obtains A B :: int\n  where \"A > 0\"\n        \"A * Re (zeta 3) + B \\<in> {0 <.. 2 * Re (zeta 3) * Lcm {1..n} ^ 3 / 27 ^ n}\"", "lemma beukers_key_inequality:\n  fixes a :: int and b :: nat\n  assumes \"b > 0\" and ab: \"Re (zeta 3) = a / b\"\n  shows   \"2 * b * Re (zeta 3) * Lcm {1..n} ^ 3 / 27 ^ n \\<ge> 1\"", "lemma smallo_power: \"n > 0 \\<Longrightarrow> f \\<in> o[F](g) \\<Longrightarrow> (\\<lambda>x. f x ^ n) \\<in> o[F](\\<lambda>x. g x ^ n)\"", "theorem zeta_3_irrational: \"zeta 3 \\<notin> \\<rat>\""], "translations": [["", "lemma degree_higher_pderiv: \"degree ((pderiv ^^ n) p) = degree p - n\"\n  for p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors,semiring_char_0} poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ((pderiv ^^ n) p) = degree p - n", "by (induction n arbitrary: p) (auto simp: degree_pderiv)"], ["", "lemma pcompose_power_left: \"pcompose (p ^ n) q = pcompose p q ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ n \\<circ>\\<^sub>p q = (p \\<circ>\\<^sub>p q) ^ n", "by (induction n) (auto simp: pcompose_mult pcompose_1)"], ["", "lemma pderiv_sum: \"pderiv (\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. pderiv (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (sum f A) = (\\<Sum>x\\<in>A. pderiv (f x))", "by (induction A rule: infinite_finite_induct) (auto simp: pderiv_add)"], ["", "lemma higher_pderiv_minus: \"(pderiv ^^ n) (-p :: 'a :: idom poly) = -(pderiv ^^ n) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ n) (- p) = - (pderiv ^^ n) p", "by (induction n) (auto simp: pderiv_minus)"], ["", "lemma pderiv_power: \"pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1)) * pderiv p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (p ^ n) = Polynomial.smult (of_nat n) (p ^ (n - 1)) * pderiv p", "by (cases n) (simp_all add: pderiv_power_Suc del: power_Suc)"], ["", "lemma pderiv_monom: \"pderiv (monom c n) = monom (of_nat n * c) (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (Polynomial.monom c n) = Polynomial.monom (of_nat n * c) (n - 1)", "by (simp add: monom_altdef pderiv_smult pderiv_power pderiv_pCons mult_ac)"], ["", "lemma higher_pderiv_monom:\n  \"k \\<le> n \\<Longrightarrow> (pderiv ^^ k) (monom c n) = monom (of_nat (pochhammer (n - k + 1) k) * c) (n - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow>\n    (pderiv ^^ k) (Polynomial.monom c n) =\n    Polynomial.monom (of_nat (pochhammer (n - k + 1) k) * c) (n - k)", "by (induction k) (auto simp: pderiv_monom pochhammer_rec Suc_diff_le Suc_diff_Suc mult_ac)"], ["", "lemma higher_pderiv_mult:\n  \"(pderiv ^^ n) (p * q) =\n     (\\<Sum>k\\<le>n. Polynomial.smult (of_nat (n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ n) (p * q) =\n    (\\<Sum>k\\<le>n.\n        Polynomial.smult (of_nat (n choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q))", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "case (Suc n)"], ["proof (state)\nthis:\n  (pderiv ^^ n) (p * q) =\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have eq: \"(Suc n choose k) = (n choose k) + (n choose (k-1))\" if \"k > 0\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n choose k = n choose k + (n choose (k - 1))", "using that"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. Suc n choose k = n choose k + (n choose (k - 1))", "by (cases k) auto"], ["proof (state)\nthis:\n  0 < ?k \\<Longrightarrow>\n  Suc n choose ?k = n choose ?k + (n choose (?k - 1))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"(pderiv ^^ Suc n) (p * q) =\n          (\\<Sum>k\\<le>n. smult (of_nat (n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n          (\\<Sum>k\\<le>n. smult (of_nat (n choose k)) ((pderiv ^^ Suc k) p * (pderiv ^^ (n - k)) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ Suc n) (p * q) =\n    (\\<Sum>k\\<le>n.\n        Polynomial.smult (of_nat (n choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n    (\\<Sum>k\\<le>n.\n        Polynomial.smult (of_nat (n choose k))\n         ((pderiv ^^ Suc k) p * (pderiv ^^ (n - k)) q))", "by (simp add: Suc pderiv_sum pderiv_smult pderiv_mult sum.distrib smult_add_right algebra_simps Suc_diff_le)"], ["proof (state)\nthis:\n  (pderiv ^^ Suc n) (p * q) =\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ Suc k) p * (pderiv ^^ (n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "also"], ["proof (state)\nthis:\n  (pderiv ^^ Suc n) (p * q) =\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ Suc k) p * (pderiv ^^ (n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"(\\<Sum>k\\<le>n. smult (of_nat (n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n             (\\<Sum>k\\<in>insert 0 {1..n}. smult (of_nat (n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        Polynomial.smult (of_nat (n choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n    (\\<Sum>k\\<in>insert 0 {1..n}.\n       Polynomial.smult (of_nat (n choose k))\n        ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n  (\\<Sum>k\\<in>insert 0 {1..n}.\n     Polynomial.smult (of_nat (n choose k))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n  (\\<Sum>k\\<in>insert 0 {1..n}.\n     Polynomial.smult (of_nat (n choose k))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"\\<dots> = (\\<Sum>k=1..n. smult (of_nat (n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) + p * (pderiv ^^ Suc n) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert 0 {1..n}.\n       Polynomial.smult (of_nat (n choose k))\n        ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n    (\\<Sum>k = 1..n.\n        Polynomial.smult (of_nat (n choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n    p * (pderiv ^^ Suc n) q", "by (subst sum.insert) (auto simp: add_ac)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert 0 {1..n}.\n     Polynomial.smult (of_nat (n choose k))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  p * (pderiv ^^ Suc n) q\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert 0 {1..n}.\n     Polynomial.smult (of_nat (n choose k))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  p * (pderiv ^^ Suc n) q\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"(\\<Sum>k\\<le>n. smult (of_nat (n choose k)) ((pderiv ^^ Suc k) p * (pderiv ^^ (n - k)) q)) =\n             (\\<Sum>k=1..n+1. smult (of_nat (n choose (k-1))) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        Polynomial.smult (of_nat (n choose k))\n         ((pderiv ^^ Suc k) p * (pderiv ^^ (n - k)) q)) =\n    (\\<Sum>k = 1..n + 1.\n        Polynomial.smult (of_nat (n choose (k - 1)))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>k. k - 1\" Suc]) auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ Suc k) p * (pderiv ^^ (n - k)) q)) =\n  (\\<Sum>k = 1..n + 1.\n      Polynomial.smult (of_nat (n choose (k - 1)))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ Suc k) p * (pderiv ^^ (n - k)) q)) =\n  (\\<Sum>k = 1..n + 1.\n      Polynomial.smult (of_nat (n choose (k - 1)))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"\\<dots> = (\\<Sum>k\\<in>insert (n+1) {1..n}. smult (of_nat (n choose (k-1))) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n + 1.\n        Polynomial.smult (of_nat (n choose (k - 1)))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n    (\\<Sum>k\\<in>insert (n + 1) {1..n}.\n       Polynomial.smult (of_nat (n choose (k - 1)))\n        ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n + 1.\n      Polynomial.smult (of_nat (n choose (k - 1)))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n  (\\<Sum>k\\<in>insert (n + 1) {1..n}.\n     Polynomial.smult (of_nat (n choose (k - 1)))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n + 1.\n      Polynomial.smult (of_nat (n choose (k - 1)))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n  (\\<Sum>k\\<in>insert (n + 1) {1..n}.\n     Polynomial.smult (of_nat (n choose (k - 1)))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"\\<dots> = (\\<Sum>k=1..n. smult (of_nat (n choose (k-1))) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) + (pderiv ^^ Suc n) p * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert (n + 1) {1..n}.\n       Polynomial.smult (of_nat (n choose (k - 1)))\n        ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n    (\\<Sum>k = 1..n.\n        Polynomial.smult (of_nat (n choose (k - 1)))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n    (pderiv ^^ Suc n) p * q", "by (subst sum.insert) (auto simp: add_ac)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert (n + 1) {1..n}.\n     Polynomial.smult (of_nat (n choose (k - 1)))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (n choose (k - 1)))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  (pderiv ^^ Suc n) p * q\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert (n + 1) {1..n}.\n     Polynomial.smult (of_nat (n choose (k - 1)))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) =\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (n choose (k - 1)))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  (pderiv ^^ Suc n) p * q\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"(\\<Sum>k=1..n. smult (of_nat (n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n                 p * (pderiv ^^ Suc n) q + \\<dots> =\n             (\\<Sum>k=1..n. smult (of_nat (Suc n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n                 p * (pderiv ^^ Suc n) q + (pderiv ^^ Suc n) p * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        Polynomial.smult (of_nat (n choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n    p * (pderiv ^^ Suc n) q +\n    ((\\<Sum>k = 1..n.\n         Polynomial.smult (of_nat (n choose (k - 1)))\n          ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n     (pderiv ^^ Suc n) p * q) =\n    (\\<Sum>k = 1..n.\n        Polynomial.smult (of_nat (Suc n choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n    p * (pderiv ^^ Suc n) q +\n    (pderiv ^^ Suc n) p * q", "by (simp add: sum.distrib algebra_simps smult_add_right eq smult_add_left)"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  p * (pderiv ^^ Suc n) q +\n  ((\\<Sum>k = 1..n.\n       Polynomial.smult (of_nat (n choose (k - 1)))\n        ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n   (pderiv ^^ Suc n) p * q) =\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (Suc n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  p * (pderiv ^^ Suc n) q +\n  (pderiv ^^ Suc n) p * q\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  p * (pderiv ^^ Suc n) q +\n  ((\\<Sum>k = 1..n.\n       Polynomial.smult (of_nat (n choose (k - 1)))\n        ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n   (pderiv ^^ Suc n) p * q) =\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (Suc n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  p * (pderiv ^^ Suc n) q +\n  (pderiv ^^ Suc n) p * q\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"\\<dots> = (\\<Sum>k\\<in>{1..n}\\<union>{0,Suc n}. smult (of_nat (Suc n choose k)) ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        Polynomial.smult (of_nat (Suc n choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n    p * (pderiv ^^ Suc n) q +\n    (pderiv ^^ Suc n) p * q =\n    (\\<Sum>k\\<in>{1..n} \\<union> {0, Suc n}.\n       Polynomial.smult (of_nat (Suc n choose k))\n        ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "by (subst sum.union_disjoint) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (Suc n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  p * (pderiv ^^ Suc n) q +\n  (pderiv ^^ Suc n) p * q =\n  (\\<Sum>k\\<in>{1..n} \\<union> {0, Suc n}.\n     Polynomial.smult (of_nat (Suc n choose k))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      Polynomial.smult (of_nat (Suc n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q)) +\n  p * (pderiv ^^ Suc n) q +\n  (pderiv ^^ Suc n) p * q =\n  (\\<Sum>k\\<in>{1..n} \\<union> {0, Suc n}.\n     Polynomial.smult (of_nat (Suc n choose k))\n      ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "have \"{1..n}\\<union>{0,Suc n} = {..Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..n} \\<union> {0, Suc n} = {..Suc n}", "by auto"], ["proof (state)\nthis:\n  {1..n} \\<union> {0, Suc n} = {..Suc n}\n\ngoal (2 subgoals):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))\n 2. \\<And>n.\n       (pderiv ^^ n) (p * q) =\n       (\\<Sum>k\\<le>n.\n           Polynomial.smult (of_nat (n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (n - k)) q)) \\<Longrightarrow>\n       (pderiv ^^ Suc n) (p * q) =\n       (\\<Sum>k\\<le>Suc n.\n           Polynomial.smult (of_nat (Suc n choose k))\n            ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "finally"], ["proof (chain)\npicking this:\n  (pderiv ^^ Suc n) (p * q) =\n  (\\<Sum>k\\<le>Suc n.\n      Polynomial.smult (of_nat (Suc n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "show ?case"], ["proof (prove)\nusing this:\n  (pderiv ^^ Suc n) (p * q) =\n  (\\<Sum>k\\<le>Suc n.\n      Polynomial.smult (of_nat (Suc n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (1 subgoal):\n 1. (pderiv ^^ Suc n) (p * q) =\n    (\\<Sum>k\\<le>Suc n.\n        Polynomial.smult (of_nat (Suc n choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))", "."], ["proof (state)\nthis:\n  (pderiv ^^ Suc n) (p * q) =\n  (\\<Sum>k\\<le>Suc n.\n      Polynomial.smult (of_nat (Suc n choose k))\n       ((pderiv ^^ k) p * (pderiv ^^ (Suc n - k)) q))\n\ngoal (1 subgoal):\n 1. (pderiv ^^ 0) (p * q) =\n    (\\<Sum>k\\<le>0.\n        Polynomial.smult (of_nat (0 choose k))\n         ((pderiv ^^ k) p * (pderiv ^^ (0 - k)) q))", "qed auto"], ["", "subsection \\<open>Auxiliary facts about integrals\\<close>"], ["", "theorem (in pair_sigma_finite) Fubini_set_integrable:\n  fixes f :: \"_ \\<Rightarrow> _::{banach, second_countable_topology}\"\n  assumes f[measurable]: \"set_borel_measurable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\"\n    and integ1: \"set_integrable M1 A (\\<lambda>x. \\<integral>y\\<in>B. norm (f (x, y)) \\<partial>M2)\"\n    and integ2: \"AE x\\<in>A in M1. set_integrable M2 B (\\<lambda>y. f (x, y))\"\n  shows \"set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f", "unfolding set_integrable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable (M1 \\<Otimes>\\<^sub>M M2)\n     (\\<lambda>x. indicat_real (A \\<times> B) x *\\<^sub>R f x)", "proof (rule Fubini_integrable)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x. indicat_real (A \\<times> B) x *\\<^sub>R f x)\n    \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)\n 2. integrable M1\n     (\\<lambda>x.\n         LINT y|M2.\n            norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))\n 3. AE x in M1. integrable M2\n                 (\\<lambda>y.\n                     indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "note integ1"], ["proof (state)\nthis:\n  set_integrable M1 A\n   (\\<lambda>x. \\<integral>y\\<in>B. norm (f (x, y))\\<partial>M2)\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. indicat_real (A \\<times> B) x *\\<^sub>R f x)\n    \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)\n 2. integrable M1\n     (\\<lambda>x.\n         LINT y|M2.\n            norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))\n 3. AE x in M1. integrable M2\n                 (\\<lambda>y.\n                     indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "also"], ["proof (state)\nthis:\n  set_integrable M1 A\n   (\\<lambda>x. \\<integral>y\\<in>B. norm (f (x, y))\\<partial>M2)\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. indicat_real (A \\<times> B) x *\\<^sub>R f x)\n    \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)\n 2. integrable M1\n     (\\<lambda>x.\n         LINT y|M2.\n            norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))\n 3. AE x in M1. integrable M2\n                 (\\<lambda>y.\n                     indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "have \"set_integrable M1 A (\\<lambda>x. \\<integral>y\\<in>B. norm (f (x, y)) \\<partial>M2) \\<longleftrightarrow>\n        integrable M1 (\\<lambda>x. LINT y|M2. norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable M1 A\n     (\\<lambda>x. \\<integral>y\\<in>B. norm (f (x, y))\\<partial>M2) =\n    integrable M1\n     (\\<lambda>x.\n         LINT y|M2.\n            norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))", "unfolding set_integrable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M1\n     (\\<lambda>x.\n         indicat_real A x *\\<^sub>R\n         (\\<integral>y\\<in>B. norm (f (x, y))\\<partial>M2)) =\n    integrable M1\n     (\\<lambda>x.\n         LINT y|M2.\n            norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))", "by (intro integrable_cong) (auto simp: indicator_def set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  set_integrable M1 A\n   (\\<lambda>x. \\<integral>y\\<in>B. norm (f (x, y))\\<partial>M2) =\n  integrable M1\n   (\\<lambda>x.\n       LINT y|M2.\n          norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. indicat_real (A \\<times> B) x *\\<^sub>R f x)\n    \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)\n 2. integrable M1\n     (\\<lambda>x.\n         LINT y|M2.\n            norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))\n 3. AE x in M1. integrable M2\n                 (\\<lambda>y.\n                     indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "finally"], ["proof (chain)\npicking this:\n  integrable M1\n   (\\<lambda>x.\n       LINT y|M2.\n          norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))", "show \\<dots>"], ["proof (prove)\nusing this:\n  integrable M1\n   (\\<lambda>x.\n       LINT y|M2.\n          norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))\n\ngoal (1 subgoal):\n 1. integrable M1\n     (\\<lambda>x.\n         LINT y|M2.\n            norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))", "."], ["proof (state)\nthis:\n  integrable M1\n   (\\<lambda>x.\n       LINT y|M2.\n          norm (indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)))\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. indicat_real (A \\<times> B) x *\\<^sub>R f x)\n    \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)\n 2. AE x in M1. integrable M2\n                 (\\<lambda>y.\n                     indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. indicat_real (A \\<times> B) x *\\<^sub>R f x)\n    \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)\n 2. AE x in M1. integrable M2\n                 (\\<lambda>y.\n                     indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "from integ2"], ["proof (chain)\npicking this:\n  AE x\\<in>A in M1. set_integrable M2 B (\\<lambda>y. f (x, y))", "show \"AE x in M1. integrable M2 (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\""], ["proof (prove)\nusing this:\n  AE x\\<in>A in M1. set_integrable M2 B (\\<lambda>y. f (x, y))\n\ngoal (1 subgoal):\n 1. AE x in M1. integrable M2\n                 (\\<lambda>y.\n                     indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<longrightarrow>\n       set_integrable M2 B (\\<lambda>y. f (x, y)) \\<Longrightarrow>\n       integrable M2\n        (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "case (elim x)"], ["proof (state)\nthis:\n  x \\<in> A \\<longrightarrow> set_integrable M2 B (\\<lambda>y. f (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<longrightarrow>\n       set_integrable M2 B (\\<lambda>y. f (x, y)) \\<Longrightarrow>\n       integrable M2\n        (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "show \"integrable M2 (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "proof (cases \"x \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n 2. x \\<notin> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "case True"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n 2. x \\<notin> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "with elim"], ["proof (chain)\npicking this:\n  x \\<in> A \\<longrightarrow> set_integrable M2 B (\\<lambda>y. f (x, y))\n  x \\<in> A", "have \"set_integrable M2 B (\\<lambda>y. f (x, y))\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<longrightarrow> set_integrable M2 B (\\<lambda>y. f (x, y))\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. set_integrable M2 B (\\<lambda>y. f (x, y))", "by simp"], ["proof (state)\nthis:\n  set_integrable M2 B (\\<lambda>y. f (x, y))\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n 2. x \\<notin> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "also"], ["proof (state)\nthis:\n  set_integrable M2 B (\\<lambda>y. f (x, y))\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n 2. x \\<notin> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "have \"?this \\<longleftrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable M2 B (\\<lambda>y. f (x, y)) =\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "unfolding set_integrable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M2 (\\<lambda>xa. indicat_real B xa *\\<^sub>R f (x, xa)) =\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "using True"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. integrable M2 (\\<lambda>xa. indicat_real B xa *\\<^sub>R f (x, xa)) =\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "by (intro integrable_cong) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  set_integrable M2 B (\\<lambda>y. f (x, y)) =\n  integrable M2\n   (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n 2. x \\<notin> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "finally"], ["proof (chain)\npicking this:\n  integrable M2\n   (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "show ?thesis"], ["proof (prove)\nusing this:\n  integrable M2\n   (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n\ngoal (1 subgoal):\n 1. integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "."], ["proof (state)\nthis:\n  integrable M2\n   (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Longrightarrow>\n    integrable M2\n     (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))", "qed auto"], ["proof (state)\nthis:\n  integrable M2\n   (\\<lambda>y. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE x in M1. integrable M2\n               (\\<lambda>y.\n                   indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. indicat_real (A \\<times> B) x *\\<^sub>R f x)\n    \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)", "qed (insert assms, auto simp: set_borel_measurable_def)"], ["", "lemma (in pair_sigma_finite) set_integral_fst':\n  fixes f :: \"_ \\<Rightarrow> 'c :: {second_countable_topology, banach}\"\n  assumes \"set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\"\n  shows   \"set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n             (\\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y) \\<partial>M2) \\<partial>M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "have \"set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n          (\\<integral>z. indicator (A \\<times> B) z *\\<^sub>R f z \\<partial>(M1 \\<Otimes>\\<^sub>M M2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n       indicat_real (A \\<times> B) z *\\<^sub>R f z", "by (simp add: set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n     indicat_real (A \\<times> B) z *\\<^sub>R f z\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "also"], ["proof (state)\nthis:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n     indicat_real (A \\<times> B) z *\\<^sub>R f z\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "have \"\\<dots> = (\\<integral>x. \\<integral>y. indicator (A \\<times> B) (x,y) *\\<^sub>R f (x,y) \\<partial>M2 \\<partial>M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n       indicat_real (A \\<times> B) z *\\<^sub>R f z =\n    LINT x|M1.\n       LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)", "using assms"], ["proof (prove)\nusing this:\n  set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\n\ngoal (1 subgoal):\n 1. LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n       indicat_real (A \\<times> B) z *\\<^sub>R f z =\n    LINT x|M1.\n       LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)", "by (subst integral_fst' [symmetric]) (auto simp: set_integrable_def)"], ["proof (state)\nthis:\n  LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n     indicat_real (A \\<times> B) z *\\<^sub>R f z =\n  LINT x|M1.\n     LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "also"], ["proof (state)\nthis:\n  LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n     indicat_real (A \\<times> B) z *\\<^sub>R f z =\n  LINT x|M1.\n     LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "have \"\\<dots> = (\\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x,y) \\<partial>M2) \\<partial>M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|M1.\n       LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y) =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "unfolding set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|M1.\n       LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y) =\n    LINT x|M1.\n       indicat_real A x *\\<^sub>R\n       (LINT xa|M2. indicat_real B xa *\\<^sub>R f (x, xa))", "by (intro Bochner_Integration.integral_cong refl) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  LINT x|M1.\n     LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y) =\n  \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\\<partial>M1\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "finally"], ["proof (chain)\npicking this:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\\<partial>M1", "show ?thesis"], ["proof (prove)\nusing this:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\\<partial>M1\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\n    \\<partial>M1", "."], ["proof (state)\nthis:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  \\<integral>x\\<in>A. (\\<integral>y\\<in>B. f (x, y)\\<partial>M2)\\<partial>M1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in pair_sigma_finite) set_integral_snd:\n  fixes f :: \"_ \\<Rightarrow> 'c :: {second_countable_topology, banach}\"\n  assumes \"set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\"\n  shows   \"set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n             (\\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y) \\<partial>M1) \\<partial>M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "have \"set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n          (\\<integral>z. indicator (A \\<times> B) z *\\<^sub>R f z \\<partial>(M1 \\<Otimes>\\<^sub>M M2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n       indicat_real (A \\<times> B) z *\\<^sub>R f z", "by (simp add: set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n     indicat_real (A \\<times> B) z *\\<^sub>R f z\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "also"], ["proof (state)\nthis:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n     indicat_real (A \\<times> B) z *\\<^sub>R f z\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "have \"\\<dots> = (\\<integral>y. \\<integral>x. indicator (A \\<times> B) (x,y) *\\<^sub>R f (x,y) \\<partial>M1 \\<partial>M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n       indicat_real (A \\<times> B) z *\\<^sub>R f z =\n    LINT y|M2.\n       LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)", "using assms"], ["proof (prove)\nusing this:\n  set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f\n\ngoal (1 subgoal):\n 1. LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n       indicat_real (A \\<times> B) z *\\<^sub>R f z =\n    LINT y|M2.\n       LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)", "by (subst integral_snd) (auto simp: set_integrable_def case_prod_unfold)"], ["proof (state)\nthis:\n  LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n     indicat_real (A \\<times> B) z *\\<^sub>R f z =\n  LINT y|M2.\n     LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "also"], ["proof (state)\nthis:\n  LINT z|(M1 \\<Otimes>\\<^sub>M M2).\n     indicat_real (A \\<times> B) z *\\<^sub>R f z =\n  LINT y|M2.\n     LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y)\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "have \"\\<dots> = (\\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x,y) \\<partial>M1) \\<partial>M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT y|M2.\n       LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y) =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "unfolding set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT y|M2.\n       LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y) =\n    LINT x|M2.\n       indicat_real B x *\\<^sub>R\n       (LINT xa|M1. indicat_real A xa *\\<^sub>R f (xa, x))", "by (intro Bochner_Integration.integral_cong refl) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  LINT y|M2.\n     LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f (x, y) =\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\\<partial>M2\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "finally"], ["proof (chain)\npicking this:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\\<partial>M2", "show ?thesis"], ["proof (prove)\nusing this:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\\<partial>M2\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n    \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\n    \\<partial>M2", "."], ["proof (state)\nthis:\n  set_lebesgue_integral (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) f =\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f (x, y)\\<partial>M1)\\<partial>M2\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition (in pair_sigma_finite) Fubini_set_integral:\n  fixes f :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ :: {banach, second_countable_topology}\"\n  assumes f: \"set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B) (case_prod f)\"\n  shows \"(\\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y \\<partial>M1) \\<partial>M2) = (\\<integral>x\\<in>A. (\\<integral>y\\<in>B. f x y \\<partial>M2) \\<partial>M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "have \"(\\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y \\<partial>M1) \\<partial>M2) = (\\<integral>y. (\\<integral>x. indicator (A \\<times> B) (x, y) *\\<^sub>R f x y \\<partial>M1) \\<partial>M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    LINT y|M2. LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y", "unfolding set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|M2.\n       indicat_real B x *\\<^sub>R\n       (LINT xa|M1. indicat_real A xa *\\<^sub>R f xa x) =\n    LINT y|M2. LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y", "by (intro Bochner_Integration.integral_cong) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\\<partial>M2 =\n  LINT y|M2. LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y\n\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "also"], ["proof (state)\nthis:\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\\<partial>M2 =\n  LINT y|M2. LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y\n\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "have \"\\<dots> = (\\<integral>x. (\\<integral>y. indicator (A \\<times> B) (x, y) *\\<^sub>R f x y \\<partial>M2) \\<partial>M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT y|M2.\n       LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y =\n    LINT x|M1. LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y", "using assms"], ["proof (prove)\nusing this:\n  set_integrable (M1 \\<Otimes>\\<^sub>M M2) (A \\<times> B)\n   (\\<lambda>(x, y). f x y)\n\ngoal (1 subgoal):\n 1. LINT y|M2.\n       LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y =\n    LINT x|M1. LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y", "by (intro Fubini_integral) (auto simp: set_integrable_def case_prod_unfold)"], ["proof (state)\nthis:\n  LINT y|M2. LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y =\n  LINT x|M1. LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y\n\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "also"], ["proof (state)\nthis:\n  LINT y|M2. LINT x|M1. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y =\n  LINT x|M1. LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y\n\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "have \"\\<dots> = (\\<integral>x\\<in>A. (\\<integral>y\\<in>B. f x y \\<partial>M2) \\<partial>M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|M1.\n       LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "unfolding set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|M1.\n       LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y =\n    LINT x|M1.\n       indicat_real A x *\\<^sub>R\n       (LINT xa|M2. indicat_real B xa *\\<^sub>R f x xa)", "by (intro Bochner_Integration.integral_cong) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  LINT x|M1. LINT y|M2. indicat_real (A \\<times> B) (x, y) *\\<^sub>R f x y =\n  \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1\n\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "finally"], ["proof (chain)\npicking this:\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\\<partial>M2 =\n  \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\\<partial>M2 =\n  \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1\n\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\n    \\<partial>M2 =\n    \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1", "."], ["proof (state)\nthis:\n  \\<integral>y\\<in>B. (\\<integral>x\\<in>A. f x y\\<partial>M1)\\<partial>M2 =\n  \\<integral>x\\<in>A. set_lebesgue_integral M2 B (f x)\\<partial>M1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in pair_sigma_finite) nn_integral_swap:\n  assumes [measurable]: \"f \\<in> borel_measurable (M1 \\<Otimes>\\<^sub>M M2)\"\n  shows \"(\\<integral>\\<^sup>+x. f x \\<partial>(M1 \\<Otimes>\\<^sub>M M2)) = (\\<integral>\\<^sup>+(y,x). f (x,y) \\<partial>(M2 \\<Otimes>\\<^sub>M M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (M1 \\<Otimes>\\<^sub>M M2) f =\n    \\<integral>\\<^sup>+ (y, x). f (x, y) \\<partial>M2 \\<Otimes>\\<^sub>M M1", "by (subst distr_pair_swap, subst nn_integral_distr) (auto simp: case_prod_unfold)"], ["", "lemma set_integrable_bound:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n    and g :: \"'a \\<Rightarrow> 'c::{banach, second_countable_topology}\"\n  shows \"set_integrable M A f \\<Longrightarrow> set_borel_measurable M A g \\<Longrightarrow>\n           (AE x in M. x \\<in> A \\<longrightarrow> norm (g x) \\<le> norm (f x)) \\<Longrightarrow> set_integrable M A g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_integrable M A f; set_borel_measurable M A g;\n     AE x\\<in>A in M. norm (g x) \\<le> norm (f x)\\<rbrakk>\n    \\<Longrightarrow> set_integrable M A g", "unfolding set_integrable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>integrable M (\\<lambda>x. indicat_real A x *\\<^sub>R f x);\n     set_borel_measurable M A g;\n     AE x\\<in>A in M. norm (g x) \\<le> norm (f x)\\<rbrakk>\n    \\<Longrightarrow> integrable M\n                       (\\<lambda>x. indicat_real A x *\\<^sub>R g x)", "apply (erule Bochner_Integration.integrable_bound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set_borel_measurable M A g;\n     AE x\\<in>A in M. norm (g x) \\<le> norm (f x)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. indicat_real A x *\\<^sub>R g x)\n                      \\<in> borel_measurable M\n 2. \\<lbrakk>set_borel_measurable M A g;\n     AE x\\<in>A in M. norm (g x) \\<le> norm (f x)\\<rbrakk>\n    \\<Longrightarrow> AE x in M. norm (indicat_real A x *\\<^sub>R g x)\n                                 \\<le> norm (indicat_real A x *\\<^sub>R f x)", "apply (simp add: set_borel_measurable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_borel_measurable M A g;\n     AE x\\<in>A in M. norm (g x) \\<le> norm (f x)\\<rbrakk>\n    \\<Longrightarrow> AE x in M. norm (indicat_real A x *\\<^sub>R g x)\n                                 \\<le> norm (indicat_real A x *\\<^sub>R f x)", "apply (erule eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>set_borel_measurable M A g;\n        x \\<in> A \\<longrightarrow> norm (g x) \\<le> norm (f x)\\<rbrakk>\n       \\<Longrightarrow> norm (indicat_real A x *\\<^sub>R g x)\n                         \\<le> norm (indicat_real A x *\\<^sub>R f x)", "apply (auto simp: indicator_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_integrableI_nonneg:\n  fixes f :: \"'a \\<Rightarrow> real\"\n  assumes \"set_borel_measurable M A f\"\n  assumes \"AE x in M. x \\<in> A \\<longrightarrow> 0 \\<le> f x\" \"(\\<integral>\\<^sup>+x\\<in>A. f x \\<partial>M) < \\<infinity>\"\n  shows \"set_integrable M A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable M A f", "unfolding set_integrable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>x. indicat_real A x *\\<^sub>R f x)", "proof (rule integrableI_nonneg)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x. indicat_real A x *\\<^sub>R f x) \\<in> borel_measurable M\n 2. AE x in M. 0 \\<le> indicat_real A x *\\<^sub>R f x\n 3. \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                       \\<partial>M\n    < \\<infinity>", "from assms"], ["proof (chain)\npicking this:\n  set_borel_measurable M A f\n  AE x\\<in>A in M. 0 \\<le> f x\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M < \\<infinity>", "show \"(\\<lambda>x. indicator A x *\\<^sub>R f x) \\<in> borel_measurable M\""], ["proof (prove)\nusing this:\n  set_borel_measurable M A f\n  AE x\\<in>A in M. 0 \\<le> f x\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M < \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. indicat_real A x *\\<^sub>R f x) \\<in> borel_measurable M", "by (simp add: set_borel_measurable_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. indicat_real A x *\\<^sub>R f x) \\<in> borel_measurable M\n\ngoal (2 subgoals):\n 1. AE x in M. 0 \\<le> indicat_real A x *\\<^sub>R f x\n 2. \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                       \\<partial>M\n    < \\<infinity>", "from assms(2)"], ["proof (chain)\npicking this:\n  AE x\\<in>A in M. 0 \\<le> f x", "show \"AE x in M. 0 \\<le> indicat_real A x *\\<^sub>R f x\""], ["proof (prove)\nusing this:\n  AE x\\<in>A in M. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. AE x in M. 0 \\<le> indicat_real A x *\\<^sub>R f x", "by eventually_elim (auto simp: indicator_def)"], ["proof (state)\nthis:\n  AE x in M. 0 \\<le> indicat_real A x *\\<^sub>R f x\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                       \\<partial>M\n    < \\<infinity>", "have \"(\\<integral>\\<^sup>+x. ennreal (indicator A x *\\<^sub>R f x) \\<partial>M) = (\\<integral>\\<^sup>+x\\<in>A. f x \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                       \\<partial>M =\n    \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M", "by (intro nn_integral_cong) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                     \\<partial>M =\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                       \\<partial>M\n    < \\<infinity>", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                     \\<partial>M =\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                       \\<partial>M\n    < \\<infinity>", "have \"\\<dots> < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M < \\<infinity>", "by fact"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                       \\<partial>M\n    < \\<infinity>", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                     \\<partial>M\n  < \\<infinity>", "show \"(\\<integral>\\<^sup>+x. ennreal (indicator A x *\\<^sub>R f x) \\<partial>M) < \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                     \\<partial>M\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                       \\<partial>M\n    < \\<infinity>", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real A x *\\<^sub>R f x)\n                     \\<partial>M\n  < \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_integral_eq_nn_integral:\n  assumes \"set_borel_measurable M A f\"\n  assumes \"set_nn_integral M A f = ennreal x\" \"x \\<ge> 0\"\n  assumes \"AE x in M. x \\<in> A \\<longrightarrow> f x \\<ge> 0\"\n  shows   \"set_integrable M A f\"\n    and   \"set_lebesgue_integral M A f = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable M A f &&& set_lebesgue_integral M A f = x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set_integrable M A f\n 2. set_lebesgue_integral M A f = x", "have eq: \"(\\<lambda>x. (if x \\<in> A then 1 else 0) * f x) = (\\<lambda>x. if x \\<in> A then f x else 0)\"\n           \"(\\<lambda>x. if x \\<in> A then ennreal (f x) else 0) =\n              (\\<lambda>x. ennreal (f x) * (if x \\<in> A then 1 else 0))\"\n           \"(\\<lambda>x. ennreal (f x * (if x \\<in> A then 1 else 0))) =\n              (\\<lambda>x. ennreal (f x) * (if x \\<in> A then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (if x \\<in> A then 1 else 0) * f x) =\n    (\\<lambda>x. if x \\<in> A then f x else 0) &&&\n    (\\<lambda>x. if x \\<in> A then ennreal (f x) else 0) =\n    (\\<lambda>x. ennreal (f x) * (if x \\<in> A then 1 else 0)) &&&\n    (\\<lambda>x. ennreal (f x * (if x \\<in> A then 1 else 0))) =\n    (\\<lambda>x. ennreal (f x) * (if x \\<in> A then 1 else 0))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. (if x \\<in> A then 1 else 0) * f x) =\n  (\\<lambda>x. if x \\<in> A then f x else 0)\n  (\\<lambda>x. if x \\<in> A then ennreal (f x) else 0) =\n  (\\<lambda>x. ennreal (f x) * (if x \\<in> A then 1 else 0))\n  (\\<lambda>x. ennreal (f x * (if x \\<in> A then 1 else 0))) =\n  (\\<lambda>x. ennreal (f x) * (if x \\<in> A then 1 else 0))\n\ngoal (2 subgoals):\n 1. set_integrable M A f\n 2. set_lebesgue_integral M A f = x", "from assms"], ["proof (chain)\npicking this:\n  set_borel_measurable M A f\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M = ennreal x\n  0 \\<le> x\n  AE x\\<in>A in M. 0 \\<le> f x", "show *: \"set_integrable M A f\""], ["proof (prove)\nusing this:\n  set_borel_measurable M A f\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M = ennreal x\n  0 \\<le> x\n  AE x\\<in>A in M. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. set_integrable M A f", "by (intro set_integrableI_nonneg) auto"], ["proof (state)\nthis:\n  set_integrable M A f\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral M A f = x", "have \"set_lebesgue_integral M A f = enn2real (set_nn_integral M A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_lebesgue_integral M A f =\n    enn2real (\\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M)", "unfolding set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|M. indicat_real A x *\\<^sub>R f x =\n    enn2real (\\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M)", "using assms(1,4) * eq"], ["proof (prove)\nusing this:\n  set_borel_measurable M A f\n  AE x\\<in>A in M. 0 \\<le> f x\n  set_integrable M A f\n  (\\<lambda>x. (if x \\<in> A then 1 else 0) * f x) =\n  (\\<lambda>x. if x \\<in> A then f x else 0)\n  (\\<lambda>x. if x \\<in> A then ennreal (f x) else 0) =\n  (\\<lambda>x. ennreal (f x) * (if x \\<in> A then 1 else 0))\n  (\\<lambda>x. ennreal (f x * (if x \\<in> A then 1 else 0))) =\n  (\\<lambda>x. ennreal (f x) * (if x \\<in> A then 1 else 0))\n\ngoal (1 subgoal):\n 1. LINT x|M. indicat_real A x *\\<^sub>R f x =\n    enn2real (\\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M)", "by (subst integral_eq_nn_integral)\n       (auto intro!: nn_integral_cong simp: indicator_def set_integrable_def mult_ac)"], ["proof (state)\nthis:\n  set_lebesgue_integral M A f =\n  enn2real (\\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M)\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral M A f = x", "also"], ["proof (state)\nthis:\n  set_lebesgue_integral M A f =\n  enn2real (\\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M)\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral M A f = x", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (\\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M) = x", "using assms"], ["proof (prove)\nusing this:\n  set_borel_measurable M A f\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M = ennreal x\n  0 \\<le> x\n  AE x\\<in>A in M. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. enn2real (\\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M) = x", "by simp"], ["proof (state)\nthis:\n  enn2real (\\<integral>\\<^sup>+x\\<in>A. ennreal (f x)\\<partial>M) = x\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral M A f = x", "finally"], ["proof (chain)\npicking this:\n  set_lebesgue_integral M A f = x", "show \"set_lebesgue_integral M A f = x\""], ["proof (prove)\nusing this:\n  set_lebesgue_integral M A f = x\n\ngoal (1 subgoal):\n 1. set_lebesgue_integral M A f = x", "."], ["proof (state)\nthis:\n  set_lebesgue_integral M A f = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_integral_0 [simp, intro]: \"set_integrable M A (\\<lambda>y. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable M A (\\<lambda>y. 0::'b)", "by (simp add: set_integrable_def)"], ["", "lemma set_integrable_sum:\n  fixes f :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ :: {banach, second_countable_topology}\"\n  assumes \"finite B\"\n  assumes \"\\<And>x. x \\<in> B \\<Longrightarrow> set_integrable M A (f x)\"\n  shows \"set_integrable M A (\\<lambda>y. \\<Sum>x\\<in>B. f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable M A (\\<lambda>y. \\<Sum>x\\<in>B. f x y)", "using assms"], ["proof (prove)\nusing this:\n  finite B\n  ?x \\<in> B \\<Longrightarrow> set_integrable M A (f ?x)\n\ngoal (1 subgoal):\n 1. set_integrable M A (\\<lambda>y. \\<Sum>x\\<in>B. f x y)", "by (induction rule: finite_induct) (auto intro!: set_integral_add)"], ["", "lemma set_integral_sum:\n  fixes f :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ :: {banach, second_countable_topology}\"\n  assumes \"finite B\"\n  assumes \"\\<And>x. x \\<in> B \\<Longrightarrow> set_integrable M A (f x)\"\n  shows \"set_lebesgue_integral M A (\\<lambda>y. \\<Sum>x\\<in>B. f x y) = (\\<Sum>x\\<in>B. set_lebesgue_integral M A (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>A. (\\<Sum>x\\<in>B. f x y)\\<partial>M =\n    (\\<Sum>x\\<in>B. set_lebesgue_integral M A (f x))", "using assms"], ["proof (prove)\nusing this:\n  finite B\n  ?x \\<in> B \\<Longrightarrow> set_integrable M A (f ?x)\n\ngoal (1 subgoal):\n 1. \\<integral>y\\<in>A. (\\<Sum>x\\<in>B. f x y)\\<partial>M =\n    (\\<Sum>x\\<in>B. set_lebesgue_integral M A (f x))", "apply (induction rule: finite_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> {} \\<Longrightarrow>\n        set_integrable M A (f x)) \\<Longrightarrow>\n    \\<integral>y\\<in>A. (\\<Sum>x\\<in>{}. f x y)\\<partial>M =\n    (\\<Sum>x\\<in>{}. set_lebesgue_integral M A (f x))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow>\n            set_integrable M A (f x)) \\<Longrightarrow>\n        \\<integral>y\\<in>A. (\\<Sum>x\\<in>F. f x y)\\<partial>M =\n        (\\<Sum>x\\<in>F. set_lebesgue_integral M A (f x));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow>\n           set_integrable M A (f xa)\\<rbrakk>\n       \\<Longrightarrow> \\<integral>y\\<in>A. (\\<Sum>x\\<in>insert x F. f x y)\n                         \\<partial>M =\n                         (\\<Sum>x\\<in>insert x F.\n                            set_lebesgue_integral M A (f x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow>\n            set_integrable M A (f x)) \\<Longrightarrow>\n        \\<integral>y\\<in>A. (\\<Sum>x\\<in>F. f x y)\\<partial>M =\n        (\\<Sum>x\\<in>F. set_lebesgue_integral M A (f x));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow>\n           set_integrable M A (f xa)\\<rbrakk>\n       \\<Longrightarrow> \\<integral>y\\<in>A. (\\<Sum>x\\<in>insert x F. f x y)\n                         \\<partial>M =\n                         (\\<Sum>x\\<in>insert x F.\n                            set_lebesgue_integral M A (f x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<integral>y\\<in>A. (\\<Sum>x\\<in>F. f x y)\\<partial>M =\n        (\\<Sum>x\\<in>F. set_lebesgue_integral M A (f x));\n        \\<And>xa.\n           xa = x \\<or> xa \\<in> F \\<Longrightarrow>\n           set_integrable M A (f xa)\\<rbrakk>\n       \\<Longrightarrow> \\<integral>y\\<in>A.\n                                    (f x y + (\\<Sum>x\\<in>F. f x y))\n                         \\<partial>M =\n                         set_lebesgue_integral M A (f x) +\n                         (\\<Sum>x\\<in>F. set_lebesgue_integral M A (f x))", "apply (subst set_integral_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<integral>y\\<in>A. (\\<Sum>x\\<in>F. f x y)\\<partial>M =\n        (\\<Sum>x\\<in>F. set_lebesgue_integral M A (f x));\n        \\<And>xa.\n           xa = x \\<or> xa \\<in> F \\<Longrightarrow>\n           set_integrable M A (f xa)\\<rbrakk>\n       \\<Longrightarrow> set_integrable M A (f x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<integral>y\\<in>A. (\\<Sum>x\\<in>F. f x y)\\<partial>M =\n        (\\<Sum>x\\<in>F. set_lebesgue_integral M A (f x));\n        \\<And>xa.\n           xa = x \\<or> xa \\<in> F \\<Longrightarrow>\n           set_integrable M A (f xa)\\<rbrakk>\n       \\<Longrightarrow> set_integrable M A\n                          (\\<lambda>y. \\<Sum>x\\<in>F. f x y)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<integral>y\\<in>A. (\\<Sum>x\\<in>F. f x y)\\<partial>M =\n        (\\<Sum>x\\<in>F. set_lebesgue_integral M A (f x));\n        \\<And>xa.\n           xa = x \\<or> xa \\<in> F \\<Longrightarrow>\n           set_integrable M A (f xa)\\<rbrakk>\n       \\<Longrightarrow> set_lebesgue_integral M A (f x) +\n                         (\\<integral>x\\<in>A. (\\<Sum>xa\\<in>F. f xa x)\n                          \\<partial>M) =\n                         set_lebesgue_integral M A (f x) +\n                         (\\<Sum>x\\<in>F. set_lebesgue_integral M A (f x))", "apply (auto intro!: set_integrable_sum)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_nn_integral_cong:\n  assumes \"M = M'\" \"A = B\" \"\\<And>x. x \\<in> space M \\<inter> A \\<Longrightarrow> f x = g x\"\n  shows   \"set_nn_integral M A f = set_nn_integral M' B g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral M A f = set_nn_integral M' B g", "using assms"], ["proof (prove)\nusing this:\n  M = M'\n  A = B\n  ?x \\<in> space M \\<inter> A \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. set_nn_integral M A f = set_nn_integral M' B g", "unfolding assms(1,2)"], ["proof (prove)\nusing this:\n  M' = M'\n  B = B\n  ?x \\<in> space M' \\<inter> B \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. set_nn_integral M' B f = set_nn_integral M' B g", "by (intro nn_integral_cong) (auto simp: indicator_def)"], ["", "lemma set_nn_integral_mono:\n  assumes \"\\<And>x. x \\<in> space M \\<inter> A \\<Longrightarrow> f x \\<le> g x\"\n  shows   \"set_nn_integral M A f \\<le> set_nn_integral M A g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral M A f \\<le> set_nn_integral M A g", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> space M \\<inter> A \\<Longrightarrow> f ?x \\<le> g ?x\n\ngoal (1 subgoal):\n 1. set_nn_integral M A f \\<le> set_nn_integral M A g", "by (intro nn_integral_mono) (auto simp: indicator_def)"], ["", "lemma\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes \"a \\<le> b\"\n  assumes deriv: \"\\<And>x. a \\<le> x \\<Longrightarrow> x \\<le> b \\<Longrightarrow> (F has_field_derivative f x) (at x within {a..b})\"\n  assumes cont: \"continuous_on {a..b} f\"\n  shows has_bochner_integral_FTC_Icc_real:\n      \"has_bochner_integral lborel (\\<lambda>x. f x * indicator {a .. b} x) (F b - F a)\" (is ?has)\n    and integral_FTC_Icc_real: \"(\\<integral>x. f x * indicator {a .. b} x \\<partial>lborel) = F b - F a\" (is ?eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel (\\<lambda>x. f x * indicat_real {a..b} x)\n     (F b - F a) &&&\n    LBINT x. f x * indicat_real {a..b} x = F b - F a", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. has_bochner_integral lborel (\\<lambda>x. f x * indicat_real {a..b} x)\n     (F b - F a)\n 2. LBINT x. f x * indicat_real {a..b} x = F b - F a", "have 1: \"\\<And>x. a \\<le> x \\<Longrightarrow> x \\<le> b \\<Longrightarrow> (F has_vector_derivative f x) (at x within {a .. b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> (F has_vector_derivative f x) (at x within {a..b})", "unfolding has_field_derivative_iff_has_vector_derivative[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> (F has_real_derivative f x) (at x within {a..b})", "using deriv"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> (F has_real_derivative f ?x) (at ?x within {a..b})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> (F has_real_derivative f x) (at x within {a..b})", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> (F has_vector_derivative f ?x) (at ?x within {a..b})\n\ngoal (2 subgoals):\n 1. has_bochner_integral lborel (\\<lambda>x. f x * indicat_real {a..b} x)\n     (F b - F a)\n 2. LBINT x. f x * indicat_real {a..b} x = F b - F a", "show ?has ?eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel (\\<lambda>x. f x * indicat_real {a..b} x)\n     (F b - F a) &&&\n    LBINT x. f x * indicat_real {a..b} x = F b - F a", "using has_bochner_integral_FTC_Icc[OF \\<open>a \\<le> b\\<close> 1 cont] integral_FTC_Icc[OF \\<open>a \\<le> b\\<close> 1 cont]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n              \\<Longrightarrow> a \\<le> x;\n   \\<And>x.\n      \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n      \\<Longrightarrow> x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> has_bochner_integral lborel\n                     (\\<lambda>x. indicat_real {a..b} x *\\<^sub>R f x)\n                     (F b - F a)\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n              \\<Longrightarrow> a \\<le> x;\n   \\<And>x.\n      \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n      \\<Longrightarrow> x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> LBINT x. indicat_real {a..b} x *\\<^sub>R f x = F b - F a\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel (\\<lambda>x. f x * indicat_real {a..b} x)\n     (F b - F a) &&&\n    LBINT x. f x * indicat_real {a..b} x = F b - F a", "by (auto simp: mult.commute)"], ["proof (state)\nthis:\n  has_bochner_integral lborel (\\<lambda>x. f x * indicat_real {a..b} x)\n   (F b - F a)\n  LBINT x. f x * indicat_real {a..b} x = F b - F a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma integral_by_parts_integrable:\n  fixes f g F G::\"real \\<Rightarrow> real\"\n  assumes \"a \\<le> b\"\n  assumes cont_f[intro]: \"continuous_on {a..b} f\"\n  assumes cont_g[intro]: \"continuous_on {a..b} g\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (F has_field_derivative f x) (at x within {a..b})\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (G has_field_derivative g x) (at x within {a..b})\"\n  shows  \"integrable lborel (\\<lambda>x.((F x) * (g x) + (f x) * (G x)) * indicator {a .. b} x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable lborel\n     (\\<lambda>x. (F x * g x + f x * G x) * indicat_real {a..b} x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. integrable lborel\n     (\\<lambda>x. (F x * g x + f x * G x) * indicat_real {a..b} x)", "have \"integrable lborel (\\<lambda>x. indicator {a..b} x *\\<^sub>R ((F x) * (g x) + (f x) * (G x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable lborel\n     (\\<lambda>x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x))", "by (intro borel_integrable_compact continuous_intros assms)\n       (auto intro!: DERIV_continuous_on assms)"], ["proof (state)\nthis:\n  integrable lborel\n   (\\<lambda>x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x))\n\ngoal (1 subgoal):\n 1. integrable lborel\n     (\\<lambda>x. (F x * g x + f x * G x) * indicat_real {a..b} x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  integrable lborel\n   (\\<lambda>x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x))\n\ngoal (1 subgoal):\n 1. integrable lborel\n     (\\<lambda>x. (F x * g x + f x * G x) * indicat_real {a..b} x)", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  integrable lborel\n   (\\<lambda>x. (F x * g x + f x * G x) * indicat_real {a..b} x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma integral_by_parts:\n  fixes f g F G::\"real \\<Rightarrow> real\"\n  assumes [arith]: \"a \\<le> b\"\n  assumes cont_f[intro]: \"continuous_on {a..b} f\"\n  assumes cont_g[intro]: \"continuous_on {a..b} g\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (F has_field_derivative f x) (at x within {a..b})\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (G has_field_derivative g x) (at x within {a..b})\"\n  shows \"(\\<integral>x. (F x * g x) * indicator {a .. b} x \\<partial>lborel)\n            =  F b * G b - F a * G a - \\<integral>x. (f x * G x) * indicator {a .. b} x \\<partial>lborel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x. F x * g x * indicat_real {a..b} x =\n    F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT x. F x * g x * indicat_real {a..b} x =\n    F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)", "have 0: \"(\\<integral>x. (F x * g x + f x * G x) * indicator {a .. b} x \\<partial>lborel) = F b * G b - F a * G a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x. (F x * g x + f x * G x) * indicat_real {a..b} x =\n    F b * G b - F a * G a", "by (rule integral_FTC_Icc_real, auto intro!: derivative_eq_intros continuous_intros)\n       (auto intro!: assms DERIV_continuous_on)"], ["proof (state)\nthis:\n  LBINT x. (F x * g x + f x * G x) * indicat_real {a..b} x =\n  F b * G b - F a * G a\n\ngoal (1 subgoal):\n 1. LBINT x. F x * g x * indicat_real {a..b} x =\n    F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)", "have [continuous_intros]: \"continuous_on {a..b} F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} F", "by (rule DERIV_continuous_on assms)+"], ["proof (state)\nthis:\n  continuous_on {a..b} F\n\ngoal (1 subgoal):\n 1. LBINT x. F x * g x * indicat_real {a..b} x =\n    F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)", "have [continuous_intros]: \"continuous_on {a..b} G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} G", "by (rule DERIV_continuous_on assms)+"], ["proof (state)\nthis:\n  continuous_on {a..b} G\n\ngoal (1 subgoal):\n 1. LBINT x. F x * g x * indicat_real {a..b} x =\n    F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)", "have \"(\\<integral>x. indicator {a..b} x *\\<^sub>R (F x * g x + f x * G x) \\<partial>lborel) =\n    (\\<integral>x. indicator {a..b} x *\\<^sub>R(F x * g x) \\<partial>lborel) + \\<integral>x. indicator {a..b} x *\\<^sub>R (f x * G x) \\<partial>lborel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x) =\n    (LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x)) +\n    (LBINT x. indicat_real {a..b} x *\\<^sub>R (f x * G x))", "apply (subst Bochner_Integration.integral_add[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. integrable lborel\n     (\\<lambda>x. indicat_real {a..b} x *\\<^sub>R (F x * g x))\n 2. integrable lborel\n     (\\<lambda>x. indicat_real {a..b} x *\\<^sub>R (f x * G x))\n 3. LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x) =\n    LBINT x.\n      indicat_real {a..b} x *\\<^sub>R (F x * g x) +\n      indicat_real {a..b} x *\\<^sub>R (f x * G x)", "apply (rule borel_integrable_compact; force intro!: continuous_intros assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. integrable lborel\n     (\\<lambda>x. indicat_real {a..b} x *\\<^sub>R (f x * G x))\n 2. LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x) =\n    LBINT x.\n      indicat_real {a..b} x *\\<^sub>R (F x * g x) +\n      indicat_real {a..b} x *\\<^sub>R (f x * G x)", "apply (rule borel_integrable_compact; force intro!: continuous_intros assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x) =\n    LBINT x.\n      indicat_real {a..b} x *\\<^sub>R (F x * g x) +\n      indicat_real {a..b} x *\\<^sub>R (f x * G x)", "apply (simp add: algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x) =\n  (LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x)) +\n  (LBINT x. indicat_real {a..b} x *\\<^sub>R (f x * G x))\n\ngoal (1 subgoal):\n 1. LBINT x. F x * g x * indicat_real {a..b} x =\n    F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x) =\n  (LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x)) +\n  (LBINT x. indicat_real {a..b} x *\\<^sub>R (f x * G x))\n\ngoal (1 subgoal):\n 1. LBINT x. F x * g x * indicat_real {a..b} x =\n    F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)", "using 0"], ["proof (prove)\nusing this:\n  LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x + f x * G x) =\n  (LBINT x. indicat_real {a..b} x *\\<^sub>R (F x * g x)) +\n  (LBINT x. indicat_real {a..b} x *\\<^sub>R (f x * G x))\n  LBINT x. (F x * g x + f x * G x) * indicat_real {a..b} x =\n  F b * G b - F a * G a\n\ngoal (1 subgoal):\n 1. LBINT x. F x * g x * indicat_real {a..b} x =\n    F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  LBINT x. F x * g x * indicat_real {a..b} x =\n  F b * G b - F a * G a - (LBINT x. f x * G x * indicat_real {a..b} x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interval_lebesgue_integral_by_parts:\n  assumes \"a \\<le> b\"\n  assumes cont_f[intro]: \"continuous_on {a..b} f\"\n  assumes cont_g[intro]: \"continuous_on {a..b} g\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (F has_field_derivative f x) (at x within {a..b})\"\n  assumes [intro]: \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> (G has_field_derivative g x) (at x within {a..b})\"\n  shows \"(LBINT x=a..b. F x * g x) = F b * G b - F a * G a - (LBINT x=a..b. f x * G x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=ereal a..ereal b. F x * g x =\n    F b * G b - F a * G a - (LBINT x=ereal a..ereal b. f x * G x)", "using integral_by_parts[of a b f g F G] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> b; continuous_on {a..b} f; continuous_on {a..b} g;\n   \\<And>x.\n      x \\<in> {a..b} \\<Longrightarrow>\n      (F has_real_derivative f x) (at x within {a..b});\n   \\<And>x.\n      x \\<in> {a..b} \\<Longrightarrow>\n      (G has_real_derivative g x) (at x within {a..b})\\<rbrakk>\n  \\<Longrightarrow> LBINT x. F x * g x * indicat_real {a..b} x =\n                    F b * G b - F a * G a -\n                    (LBINT x. f x * G x * indicat_real {a..b} x)\n  a \\<le> b\n  continuous_on {a..b} f\n  continuous_on {a..b} g\n  ?x \\<in> {a..b} \\<Longrightarrow>\n  (F has_real_derivative f ?x) (at ?x within {a..b})\n  ?x \\<in> {a..b} \\<Longrightarrow>\n  (G has_real_derivative g ?x) (at ?x within {a..b})\n\ngoal (1 subgoal):\n 1. LBINT x=ereal a..ereal b. F x * g x =\n    F b * G b - F a * G a - (LBINT x=ereal a..ereal b. f x * G x)", "by (simp add: interval_integral_Icc set_lebesgue_integral_def mult_ac)"], ["", "lemma interval_lebesgue_integral_by_parts_01:\n  assumes cont_f[intro]: \"continuous_on {0..1} f\"\n  assumes cont_g[intro]: \"continuous_on {0..1} g\"\n  assumes [intro]: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> (F has_field_derivative f x) (at x within {0..1})\"\n  assumes [intro]: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> (G has_field_derivative g x) (at x within {0..1})\"\n  shows \"(LBINT x=0..1. F x * g x) = F 1 * G 1 - F 0 * G 0 - (LBINT x=0..1. f x * G x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. F x * g x =\n    F 1 * G 1 - F 0 * G 0 - (LBINT x=0..1. f x * G x)", "using interval_lebesgue_integral_by_parts[of 0 1 f g F G] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1; continuous_on {0..1} f; continuous_on {0..1} g;\n   \\<And>x.\n      x \\<in> {0..1} \\<Longrightarrow>\n      (F has_real_derivative f x) (at x within {0..1});\n   \\<And>x.\n      x \\<in> {0..1} \\<Longrightarrow>\n      (G has_real_derivative g x) (at x within {0..1})\\<rbrakk>\n  \\<Longrightarrow> LBINT x=ereal 0..ereal 1. F x * g x =\n                    F 1 * G 1 - F 0 * G 0 -\n                    (LBINT x=ereal 0..ereal 1. f x * G x)\n  continuous_on {0..1} f\n  continuous_on {0..1} g\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (F has_real_derivative f ?x) (at ?x within {0..1})\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (G has_real_derivative g ?x) (at ?x within {0..1})\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. F x * g x =\n    F 1 * G 1 - F 0 * G 0 - (LBINT x=0..1. f x * G x)", "by (simp add: zero_ereal_def one_ereal_def)"], ["", "lemma continuous_on_imp_set_integrable_cbox:\n  fixes h :: \"'a :: euclidean_space \\<Rightarrow> real\"\n  assumes \"continuous_on (cbox a b) h\"\n  shows   \"set_integrable lborel (cbox a b) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox a b) h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox a b) h", "from assms"], ["proof (chain)\npicking this:\n  continuous_on (cbox a b) h", "have \"h absolutely_integrable_on cbox a b\""], ["proof (prove)\nusing this:\n  continuous_on (cbox a b) h\n\ngoal (1 subgoal):\n 1. h absolutely_integrable_on cbox a b", "by (rule absolutely_integrable_continuous)"], ["proof (state)\nthis:\n  h absolutely_integrable_on cbox a b\n\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox a b) h", "moreover"], ["proof (state)\nthis:\n  h absolutely_integrable_on cbox a b\n\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox a b) h", "have \"(\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x) \\<in> borel_measurable borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)\n    \\<in> borel_measurable borel", "by (rule borel_measurable_continuous_on_indicator) (use assms in auto)"], ["proof (state)\nthis:\n  (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)\n  \\<in> borel_measurable borel\n\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox a b) h", "ultimately"], ["proof (chain)\npicking this:\n  h absolutely_integrable_on cbox a b\n  (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)\n  \\<in> borel_measurable borel", "show ?thesis"], ["proof (prove)\nusing this:\n  h absolutely_integrable_on cbox a b\n  (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)\n  \\<in> borel_measurable borel\n\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox a b) h", "unfolding set_integrable_def"], ["proof (prove)\nusing this:\n  integrable lebesgue (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)\n  (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)\n  \\<in> borel_measurable borel\n\ngoal (1 subgoal):\n 1. integrable lborel (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)", "using assms"], ["proof (prove)\nusing this:\n  integrable lebesgue (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)\n  (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)\n  \\<in> borel_measurable borel\n  continuous_on (cbox a b) h\n\ngoal (1 subgoal):\n 1. integrable lborel (\\<lambda>x. indicat_real (cbox a b) x *\\<^sub>R h x)", "by (subst (asm) integrable_completion) auto"], ["proof (state)\nthis:\n  set_integrable lborel (cbox a b) h\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Shifted Legendre polynomials\\<close>"], ["", "text \\<open>\n  The first ingredient we need to show Ap?ry's theorem is the \\<^emph>\\<open>shifted\n  Legendre polynomials\\<close>\n    \\[P_n(X) = \\frac{1}{n!} \\frac{\\partial^n}{\\partial X^n} (X^n(1-X)^n)\\]\n  and the auxiliary polynomials\n    \\[Q_{n,k}(X) = \\frac{\\partial^k}{\\partial X^k} (X^n(1-X)^n)\\ .\\]\n  Note that $P_n$ is in fact an \\emph{integer} polynomial.\n\n  Only some very basic properties of these will be proven, since that is all we will need.\n\\<close>"], ["", "context\n  fixes n :: nat\nbegin"], ["", "definition gen_shleg_poly :: \"nat \\<Rightarrow> int poly\" where\n  \"gen_shleg_poly k = (pderiv ^^ k) ([:0, 1, -1:] ^ n)\""], ["", "definition shleg_poly where \"shleg_poly = gen_shleg_poly n div [:fact n:]\""], ["", "text \\<open>\n  We can easily prove the following more explicit formula for $Q_{n,k}$:\n  \\[Q_{n,k}(X) = \\sum_{i=0}^k (-1)^{k-1} {k \\choose i}\n      n^{\\underline{i}}\\, n^{\\underline{k-i}}\\, X^{n-i}\\, (1-X)^{n-k+i}\\]\n\\<close>"], ["", "lemma gen_shleg_poly_altdef:\n  assumes \"k \\<le> n\"\n  shows \"gen_shleg_poly k =\n            (\\<Sum>i\\<le>k. smult ((-1)^(k-i) * of_nat (k choose i) *\n                    pochhammer (n-i+1) i * pochhammer (n-k+i+1) (k-i))\n                    ([:0, 1:] ^ (n - i) * [:1, -1:] ^ (n-k+i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have *: \"(pderiv ^^ i) (x \\<circ>\\<^sub>p [:1, -1:]) =\n          smult ((-1) ^ i) ((pderiv ^^ i) x \\<circ>\\<^sub>p [:1, -1:])\" for i and x :: \"int poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ i) (x \\<circ>\\<^sub>p [:1, - 1:]) =\n    Polynomial.smult ((- 1) ^ i)\n     ((pderiv ^^ i) x \\<circ>\\<^sub>p [:1, - 1:])", "by (induction i arbitrary: x)\n       (auto simp: pderiv_smult pderiv_pcompose funpow_Suc_right pderiv_pCons\n                   higher_pderiv_minus simp del: funpow.simps(2))"], ["proof (state)\nthis:\n  (pderiv ^^ ?i) (?x \\<circ>\\<^sub>p [:1, - 1:]) =\n  Polynomial.smult ((- 1) ^ ?i)\n   ((pderiv ^^ ?i) ?x \\<circ>\\<^sub>p [:1, - 1:])\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have \"gen_shleg_poly k = (pderiv ^^ k) ([:0, 1, -1:] ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k = (pderiv ^^ k) ([:0, 1, - 1:] ^ n)", "by (simp add: gen_shleg_poly_def)"], ["proof (state)\nthis:\n  local.gen_shleg_poly k = (pderiv ^^ k) ([:0, 1, - 1:] ^ n)\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "also"], ["proof (state)\nthis:\n  local.gen_shleg_poly k = (pderiv ^^ k) ([:0, 1, - 1:] ^ n)\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have \"[:0, 1, -1::int:] = [:0, 1:] * [:1, -1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0, 1, - 1:] = [:0, 1:] * [:1, - 1:]", "by simp"], ["proof (state)\nthis:\n  [:0, 1, - 1:] = [:0, 1:] * [:1, - 1:]\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "also"], ["proof (state)\nthis:\n  [:0, 1, - 1:] = [:0, 1:] * [:1, - 1:]\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have \"\\<dots> ^ n = [:0, 1:] ^ n * [:1, -1:] ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:0, 1:] * [:1, - 1:]) ^ n = [:0, 1:] ^ n * [:1, - 1:] ^ n", "by (simp flip: power_mult_distrib)"], ["proof (state)\nthis:\n  ([:0, 1:] * [:1, - 1:]) ^ n = [:0, 1:] ^ n * [:1, - 1:] ^ n\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "also"], ["proof (state)\nthis:\n  ([:0, 1:] * [:1, - 1:]) ^ n = [:0, 1:] ^ n * [:1, - 1:] ^ n\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have \"(pderiv ^^ k) \\<dots> =\n               (\\<Sum>i\\<le>k. smult (of_nat (k choose i)) ((pderiv ^^ i)\n                 ([:0, 1:] ^ n) * (pderiv ^^ (k - i)) ([:1, -1:] ^ n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ k) ([:0, 1:] ^ n * [:1, - 1:] ^ n) =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult (int (k choose i))\n         ((pderiv ^^ i) ([:0, 1:] ^ n) *\n          (pderiv ^^ (k - i)) ([:1, - 1:] ^ n)))", "by (simp add: higher_pderiv_mult)"], ["proof (state)\nthis:\n  (pderiv ^^ k) ([:0, 1:] ^ n * [:1, - 1:] ^ n) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult (int (k choose i))\n       ((pderiv ^^ i) ([:0, 1:] ^ n) *\n        (pderiv ^^ (k - i)) ([:1, - 1:] ^ n)))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "also"], ["proof (state)\nthis:\n  (pderiv ^^ k) ([:0, 1:] ^ n * [:1, - 1:] ^ n) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult (int (k choose i))\n       ((pderiv ^^ i) ([:0, 1:] ^ n) *\n        (pderiv ^^ (k - i)) ([:1, - 1:] ^ n)))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have \"\\<dots> = (\\<Sum>i\\<le>k. smult (of_nat (k choose i))\n                    ((pderiv ^^ i) (monom 1 n) * (pderiv ^^ (k - i)) (monom 1 n \\<circ>\\<^sub>p [:1, -1:])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k.\n        Polynomial.smult (int (k choose i))\n         ((pderiv ^^ i) ([:0, 1:] ^ n) *\n          (pderiv ^^ (k - i)) ([:1, - 1:] ^ n))) =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult (int (k choose i))\n         ((pderiv ^^ i) (Polynomial.monom 1 n) *\n          (pderiv ^^ (k - i))\n           (Polynomial.monom 1 n \\<circ>\\<^sub>p [:1, - 1:])))", "by (simp add: monom_altdef pcompose_pCons pcompose_power_left)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult (int (k choose i))\n       ((pderiv ^^ i) ([:0, 1:] ^ n) *\n        (pderiv ^^ (k - i)) ([:1, - 1:] ^ n))) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult (int (k choose i))\n       ((pderiv ^^ i) (Polynomial.monom 1 n) *\n        (pderiv ^^ (k - i))\n         (Polynomial.monom 1 n \\<circ>\\<^sub>p [:1, - 1:])))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult (int (k choose i))\n       ((pderiv ^^ i) ([:0, 1:] ^ n) *\n        (pderiv ^^ (k - i)) ([:1, - 1:] ^ n))) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult (int (k choose i))\n       ((pderiv ^^ i) (Polynomial.monom 1 n) *\n        (pderiv ^^ (k - i))\n         (Polynomial.monom 1 n \\<circ>\\<^sub>p [:1, - 1:])))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have \"\\<dots> = (\\<Sum>i\\<le>k. smult ((-1) ^ (k - i) * of_nat (k choose i))\n                   ((pderiv ^^ i) (monom 1 n) * ((pderiv ^^ (k - i)) (monom 1 n) \\<circ>\\<^sub>p [:1, -1:])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k.\n        Polynomial.smult (int (k choose i))\n         ((pderiv ^^ i) (Polynomial.monom 1 n) *\n          (pderiv ^^ (k - i))\n           (Polynomial.monom 1 n \\<circ>\\<^sub>p [:1, - 1:]))) =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n         ((pderiv ^^ i) (Polynomial.monom 1 n) *\n          (pderiv ^^ (k - i)) (Polynomial.monom 1 n) \\<circ>\\<^sub>p\n          [:1, - 1:]))", "by (simp add: * mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult (int (k choose i))\n       ((pderiv ^^ i) (Polynomial.monom 1 n) *\n        (pderiv ^^ (k - i))\n         (Polynomial.monom 1 n \\<circ>\\<^sub>p [:1, - 1:]))) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n       ((pderiv ^^ i) (Polynomial.monom 1 n) *\n        (pderiv ^^ (k - i)) (Polynomial.monom 1 n) \\<circ>\\<^sub>p\n        [:1, - 1:]))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult (int (k choose i))\n       ((pderiv ^^ i) (Polynomial.monom 1 n) *\n        (pderiv ^^ (k - i))\n         (Polynomial.monom 1 n \\<circ>\\<^sub>p [:1, - 1:]))) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n       ((pderiv ^^ i) (Polynomial.monom 1 n) *\n        (pderiv ^^ (k - i)) (Polynomial.monom 1 n) \\<circ>\\<^sub>p\n        [:1, - 1:]))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have \"\\<dots> = (\\<Sum>i\\<le>k. smult ((-1) ^ (k - i) * of_nat (k choose i))\n                   (monom (pochhammer (n - i + 1) i) (n - i) *\n                    monom (pochhammer (n - k + i + 1) (k - i)) (n - k + i) \\<circ>\\<^sub>p [:1, -1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k.\n        Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n         ((pderiv ^^ i) (Polynomial.monom 1 n) *\n          (pderiv ^^ (k - i)) (Polynomial.monom 1 n) \\<circ>\\<^sub>p\n          [:1, - 1:])) =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n         (Polynomial.monom (int (pochhammer (n - i + 1) i)) (n - i) *\n          Polynomial.monom (int (pochhammer (n - k + i + 1) (k - i)))\n           (n - k + i) \\<circ>\\<^sub>p\n          [:1, - 1:]))", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k.\n        Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n         ((pderiv ^^ i) (Polynomial.monom 1 n) *\n          (pderiv ^^ (k - i)) (Polynomial.monom 1 n) \\<circ>\\<^sub>p\n          [:1, - 1:])) =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n         (Polynomial.monom (int (pochhammer (n - i + 1) i)) (n - i) *\n          Polynomial.monom (int (pochhammer (n - k + i + 1) (k - i)))\n           (n - k + i) \\<circ>\\<^sub>p\n          [:1, - 1:]))", "by (simp add: higher_pderiv_monom)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n       ((pderiv ^^ i) (Polynomial.monom 1 n) *\n        (pderiv ^^ (k - i)) (Polynomial.monom 1 n) \\<circ>\\<^sub>p\n        [:1, - 1:])) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n       (Polynomial.monom (int (pochhammer (n - i + 1) i)) (n - i) *\n        Polynomial.monom (int (pochhammer (n - k + i + 1) (k - i)))\n         (n - k + i) \\<circ>\\<^sub>p\n        [:1, - 1:]))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n       ((pderiv ^^ i) (Polynomial.monom 1 n) *\n        (pderiv ^^ (k - i)) (Polynomial.monom 1 n) \\<circ>\\<^sub>p\n        [:1, - 1:])) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n       (Polynomial.monom (int (pochhammer (n - i + 1) i)) (n - i) *\n        Polynomial.monom (int (pochhammer (n - k + i + 1) (k - i)))\n         (n - k + i) \\<circ>\\<^sub>p\n        [:1, - 1:]))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "have \"\\<dots> = (\\<Sum>i\\<le>k. smult ((-1) ^ (k - i) * of_nat (k choose i) * pochhammer (n - i + 1) i * pochhammer (n - k + i + 1) (k - i))\n                   ([:0, 1:] ^ (n - i) * [:1, -1:] ^ (n - k + i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k.\n        Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n         (Polynomial.monom (int (pochhammer (n - i + 1) i)) (n - i) *\n          Polynomial.monom (int (pochhammer (n - k + i + 1) (k - i)))\n           (n - k + i) \\<circ>\\<^sub>p\n          [:1, - 1:])) =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "by (simp add: monom_altdef algebra_simps pcompose_smult pcompose_power_left pcompose_pCons)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult ((- 1) ^ (k - i) * int (k choose i))\n       (Polynomial.monom (int (pochhammer (n - i + 1) i)) (n - i) *\n        Polynomial.monom (int (pochhammer (n - k + i + 1) (k - i)))\n         (n - k + i) \\<circ>\\<^sub>p\n        [:1, - 1:])) =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult\n       ((- 1) ^ (k - i) * int (k choose i) *\n        int (pochhammer (n - i + 1) i) *\n        int (pochhammer (n - k + i + 1) (k - i)))\n       ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "finally"], ["proof (chain)\npicking this:\n  local.gen_shleg_poly k =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult\n       ((- 1) ^ (k - i) * int (k choose i) *\n        int (pochhammer (n - i + 1) i) *\n        int (pochhammer (n - k + i + 1) (k - i)))\n       ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.gen_shleg_poly k =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult\n       ((- 1) ^ (k - i) * int (k choose i) *\n        int (pochhammer (n - i + 1) i) *\n        int (pochhammer (n - k + i + 1) (k - i)))\n       ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly k =\n    (\\<Sum>i\\<le>k.\n        Polynomial.smult\n         ((- 1) ^ (k - i) * int (k choose i) *\n          int (pochhammer (n - i + 1) i) *\n          int (pochhammer (n - k + i + 1) (k - i)))\n         ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))", "."], ["proof (state)\nthis:\n  local.gen_shleg_poly k =\n  (\\<Sum>i\\<le>k.\n      Polynomial.smult\n       ((- 1) ^ (k - i) * int (k choose i) *\n        int (pochhammer (n - i + 1) i) *\n        int (pochhammer (n - k + i + 1) (k - i)))\n       ([:0, 1:] ^ (n - i) * [:1, - 1:] ^ (n - k + i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_gen_shleg_poly [simp]: \"degree (gen_shleg_poly k) = 2 * n - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (local.gen_shleg_poly k) = 2 * n - k", "by (simp add: gen_shleg_poly_def degree_higher_pderiv degree_power_eq)"], ["", "lemma gen_shleg_poly_n: \"gen_shleg_poly n = smult (fact n) shleg_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "obtain r where r: \"gen_shleg_poly n = [:fact n:] * r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        local.gen_shleg_poly n = [:fact n:] * r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding gen_shleg_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        (pderiv ^^ n) ([:0, 1, - 1:] ^ n) = [:fact n:] * r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using fact_dvd_higher_pderiv[of n \"[:0,1,-1:]^n\"]"], ["proof (prove)\nusing this:\n  [:fact n:] dvd (pderiv ^^ n) ([:0, 1, - 1:] ^ n)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        (pderiv ^^ n) ([:0, 1, - 1:] ^ n) = [:fact n:] * r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  local.gen_shleg_poly n = [:fact n:] * r\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "have \"smult (fact n) shleg_poly = smult (fact n) (gen_shleg_poly n div [:fact n:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (fact n) local.shleg_poly =\n    Polynomial.smult (fact n) (local.gen_shleg_poly n div [:fact n:])", "by (simp add: shleg_poly_def)"], ["proof (state)\nthis:\n  Polynomial.smult (fact n) local.shleg_poly =\n  Polynomial.smult (fact n) (local.gen_shleg_poly n div [:fact n:])\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "also"], ["proof (state)\nthis:\n  Polynomial.smult (fact n) local.shleg_poly =\n  Polynomial.smult (fact n) (local.gen_shleg_poly n div [:fact n:])\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "note r"], ["proof (state)\nthis:\n  local.gen_shleg_poly n = [:fact n:] * r\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "also"], ["proof (state)\nthis:\n  local.gen_shleg_poly n = [:fact n:] * r\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "have \"[:fact n:] * r div [:fact n:] = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:fact n:] * r div [:fact n:] = r", "by (rule nonzero_mult_div_cancel_left) auto"], ["proof (state)\nthis:\n  [:fact n:] * r div [:fact n:] = r\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult (fact n) local.shleg_poly = Polynomial.smult (fact n) r", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.smult (fact n) local.shleg_poly = Polynomial.smult (fact n) r\n\ngoal (1 subgoal):\n 1. local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly", "by (simp add: r)"], ["proof (state)\nthis:\n  local.gen_shleg_poly n = Polynomial.smult (fact n) local.shleg_poly\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_shleg_poly [simp]: \"degree shleg_poly = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree local.shleg_poly = n", "using degree_gen_shleg_poly[of n]"], ["proof (prove)\nusing this:\n  degree (local.gen_shleg_poly n) = 2 * n - n\n\ngoal (1 subgoal):\n 1. degree local.shleg_poly = n", "by (simp add: gen_shleg_poly_n)"], ["", "lemma pderiv_gen_shleg_poly [simp]: \"pderiv (gen_shleg_poly k) = gen_shleg_poly (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (local.gen_shleg_poly k) = local.gen_shleg_poly (Suc k)", "by (simp add: gen_shleg_poly_def)"], ["", "text \\<open>\n  The following functions are the interpretation of the shifted Legendre polynomials\n  and the auxiliary polynomials as a function from reals to reals.\n\\<close>"], ["", "definition Gen_Shleg :: \"nat \\<Rightarrow> real \\<Rightarrow> real\"\n  where \"Gen_Shleg k x = poly (of_int_poly (gen_shleg_poly k)) x\""], ["", "definition Shleg :: \"real \\<Rightarrow> real\" where \"Shleg = poly (of_int_poly shleg_poly)\""], ["", "lemma Gen_Shleg_altdef:\n  assumes \"k \\<le> n\"\n  shows   \"Gen_Shleg k x = (\\<Sum>i\\<le>k. (-1)^(k-i) * of_nat (k choose i) *\n                            of_int (pochhammer (n-i+1) i * pochhammer (n-k+i+1) (k-i)) *\n                            x ^ (n - i) * (1 - x) ^ (n-k+i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Gen_Shleg k x =\n    (\\<Sum>i\\<le>k.\n        (- 1) ^ (k - i) * real (k choose i) *\n        real_of_int\n         (int (pochhammer (n - i + 1) i *\n               pochhammer (n - k + i + 1) (k - i))) *\n        x ^ (n - i) *\n        (1 - x) ^ (n - k + i))", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg k x =\n    (\\<Sum>i\\<le>k.\n        (- 1) ^ (k - i) * real (k choose i) *\n        real_of_int\n         (int (pochhammer (n - i + 1) i *\n               pochhammer (n - k + i + 1) (k - i))) *\n        x ^ (n - i) *\n        (1 - x) ^ (n - k + i))", "by (simp add: Gen_Shleg_def gen_shleg_poly_altdef poly_sum mult_ac)"], ["", "lemma Gen_Shleg_0 [simp]: \"k < n \\<Longrightarrow> Gen_Shleg k 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> local.Gen_Shleg k 0 = 0", "by (simp add: Gen_Shleg_altdef zero_power)"], ["", "lemma Gen_Shleg_1 [simp]: \"k < n \\<Longrightarrow> Gen_Shleg k 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> local.Gen_Shleg k 1 = 0", "by (simp add: Gen_Shleg_altdef zero_power)"], ["", "lemma Gen_Shleg_n_0 [simp]: \"Gen_Shleg n 0 = fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 = fact n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 = fact n", "have \"Gen_Shleg n 0 = (\\<Sum>i\\<le>n. (-1) ^ (n-i) * real (n choose i) *\n        (real (pochhammer (Suc (n-i)) i) *\n         real (pochhammer (Suc i) (n-i))) * 0 ^ (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 =\n    (\\<Sum>i\\<le>n.\n        (- 1) ^ (n - i) * real (n choose i) *\n        (real (pochhammer (Suc (n - i)) i) *\n         real (pochhammer (Suc i) (n - i))) *\n        0 ^ (n - i))", "by (simp add: Gen_Shleg_altdef)"], ["proof (state)\nthis:\n  local.Gen_Shleg n 0 =\n  (\\<Sum>i\\<le>n.\n      (- 1) ^ (n - i) * real (n choose i) *\n      (real (pochhammer (Suc (n - i)) i) *\n       real (pochhammer (Suc i) (n - i))) *\n      0 ^ (n - i))\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 = fact n", "also"], ["proof (state)\nthis:\n  local.Gen_Shleg n 0 =\n  (\\<Sum>i\\<le>n.\n      (- 1) ^ (n - i) * real (n choose i) *\n      (real (pochhammer (Suc (n - i)) i) *\n       real (pochhammer (Suc i) (n - i))) *\n      0 ^ (n - i))\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 = fact n", "have \"\\<dots> = (\\<Sum>i\\<in>{n}. (-1) ^ (n-i) * real (n choose i) *\n        (real (pochhammer (Suc (n-i)) i) *\n         real (pochhammer (Suc i) (n-i))) * 0 ^ (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        (- 1) ^ (n - i) * real (n choose i) *\n        (real (pochhammer (Suc (n - i)) i) *\n         real (pochhammer (Suc i) (n - i))) *\n        0 ^ (n - i)) =\n    (\\<Sum>i\\<in>{n}.\n       (- 1) ^ (n - i) * real (n choose i) *\n       (real (pochhammer (Suc (n - i)) i) *\n        real (pochhammer (Suc i) (n - i))) *\n       0 ^ (n - i))", "by (intro sum.mono_neutral_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      (- 1) ^ (n - i) * real (n choose i) *\n      (real (pochhammer (Suc (n - i)) i) *\n       real (pochhammer (Suc i) (n - i))) *\n      0 ^ (n - i)) =\n  (\\<Sum>i\\<in>{n}.\n     (- 1) ^ (n - i) * real (n choose i) *\n     (real (pochhammer (Suc (n - i)) i) *\n      real (pochhammer (Suc i) (n - i))) *\n     0 ^ (n - i))\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 = fact n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      (- 1) ^ (n - i) * real (n choose i) *\n      (real (pochhammer (Suc (n - i)) i) *\n       real (pochhammer (Suc i) (n - i))) *\n      0 ^ (n - i)) =\n  (\\<Sum>i\\<in>{n}.\n     (- 1) ^ (n - i) * real (n choose i) *\n     (real (pochhammer (Suc (n - i)) i) *\n      real (pochhammer (Suc i) (n - i))) *\n     0 ^ (n - i))\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 = fact n", "have \"\\<dots> = fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{n}.\n       (- 1) ^ (n - i) * real (n choose i) *\n       (real (pochhammer (Suc (n - i)) i) *\n        real (pochhammer (Suc i) (n - i))) *\n       0 ^ (n - i)) =\n    fact n", "by (simp add: pochhammer_fact flip: pochhammer_of_nat)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{n}.\n     (- 1) ^ (n - i) * real (n choose i) *\n     (real (pochhammer (Suc (n - i)) i) *\n      real (pochhammer (Suc i) (n - i))) *\n     0 ^ (n - i)) =\n  fact n\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 = fact n", "finally"], ["proof (chain)\npicking this:\n  local.Gen_Shleg n 0 = fact n", "show ?thesis"], ["proof (prove)\nusing this:\n  local.Gen_Shleg n 0 = fact n\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 0 = fact n", "."], ["proof (state)\nthis:\n  local.Gen_Shleg n 0 = fact n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gen_Shleg_n_1 [simp]: \"Gen_Shleg n 1 = (-1) ^ n * fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "have \"Gen_Shleg n 1 = (\\<Sum>i\\<le>n. (-1) ^ (n-i) * real (n choose i) *\n        (real (pochhammer (Suc (n-i)) i) *\n         real (pochhammer (Suc i) (n-i))) * 0 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 =\n    (\\<Sum>i\\<le>n.\n        (- 1) ^ (n - i) * real (n choose i) *\n        (real (pochhammer (Suc (n - i)) i) *\n         real (pochhammer (Suc i) (n - i))) *\n        0 ^ i)", "by (simp add: Gen_Shleg_altdef)"], ["proof (state)\nthis:\n  local.Gen_Shleg n 1 =\n  (\\<Sum>i\\<le>n.\n      (- 1) ^ (n - i) * real (n choose i) *\n      (real (pochhammer (Suc (n - i)) i) *\n       real (pochhammer (Suc i) (n - i))) *\n      0 ^ i)\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "also"], ["proof (state)\nthis:\n  local.Gen_Shleg n 1 =\n  (\\<Sum>i\\<le>n.\n      (- 1) ^ (n - i) * real (n choose i) *\n      (real (pochhammer (Suc (n - i)) i) *\n       real (pochhammer (Suc i) (n - i))) *\n      0 ^ i)\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "have \"\\<dots> = (\\<Sum>i\\<in>{0}. (-1) ^ (n-i) * real (n choose i) *\n        (real (pochhammer (Suc (n-i)) i) *\n         real (pochhammer (Suc i) (n-i))) * 0 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        (- 1) ^ (n - i) * real (n choose i) *\n        (real (pochhammer (Suc (n - i)) i) *\n         real (pochhammer (Suc i) (n - i))) *\n        0 ^ i) =\n    (\\<Sum>i\\<in>{0}.\n       (- 1) ^ (n - i) * real (n choose i) *\n       (real (pochhammer (Suc (n - i)) i) *\n        real (pochhammer (Suc i) (n - i))) *\n       0 ^ i)", "by (intro sum.mono_neutral_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      (- 1) ^ (n - i) * real (n choose i) *\n      (real (pochhammer (Suc (n - i)) i) *\n       real (pochhammer (Suc i) (n - i))) *\n      0 ^ i) =\n  (\\<Sum>i\\<in>{0}.\n     (- 1) ^ (n - i) * real (n choose i) *\n     (real (pochhammer (Suc (n - i)) i) *\n      real (pochhammer (Suc i) (n - i))) *\n     0 ^ i)\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      (- 1) ^ (n - i) * real (n choose i) *\n      (real (pochhammer (Suc (n - i)) i) *\n       real (pochhammer (Suc i) (n - i))) *\n      0 ^ i) =\n  (\\<Sum>i\\<in>{0}.\n     (- 1) ^ (n - i) * real (n choose i) *\n     (real (pochhammer (Suc (n - i)) i) *\n      real (pochhammer (Suc i) (n - i))) *\n     0 ^ i)\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "have \"\\<dots> = (-1) ^ n * fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{0}.\n       (- 1) ^ (n - i) * real (n choose i) *\n       (real (pochhammer (Suc (n - i)) i) *\n        real (pochhammer (Suc i) (n - i))) *\n       0 ^ i) =\n    (- 1) ^ n * fact n", "by (simp add: pochhammer_fact flip: pochhammer_of_nat)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{0}.\n     (- 1) ^ (n - i) * real (n choose i) *\n     (real (pochhammer (Suc (n - i)) i) *\n      real (pochhammer (Suc i) (n - i))) *\n     0 ^ i) =\n  (- 1) ^ n * fact n\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "finally"], ["proof (chain)\npicking this:\n  local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "show ?thesis"], ["proof (prove)\nusing this:\n  local.Gen_Shleg n 1 = (- 1) ^ n * fact n\n\ngoal (1 subgoal):\n 1. local.Gen_Shleg n 1 = (- 1) ^ n * fact n", "."], ["proof (state)\nthis:\n  local.Gen_Shleg n 1 = (- 1) ^ n * fact n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Shleg_altdef: \"Shleg x = Gen_Shleg n x / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Shleg x = local.Gen_Shleg n x / fact n", "by (simp add: Shleg_def Gen_Shleg_def gen_shleg_poly_n)"], ["", "lemma Shleg_0 [simp]: \"Shleg 0 = 1\" and Shleg_1 [simp]: \"Shleg 1 = (-1) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Shleg 0 = 1 &&& local.Shleg 1 = (- 1) ^ n", "by (simp_all add: Shleg_altdef)"], ["", "lemma Gen_Shleg_0_left: \"Gen_Shleg 0 x = x ^ n * (1 - x) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Gen_Shleg 0 x = x ^ n * (1 - x) ^ n", "by (simp add: Gen_Shleg_def gen_shleg_poly_def power_mult_distrib)"], ["", "lemma has_field_derivative_Gen_Shleg:\n  \"(Gen_Shleg k has_field_derivative Gen_Shleg (Suc k) x) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.Gen_Shleg k has_real_derivative local.Gen_Shleg (Suc k) x) (at x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (local.Gen_Shleg k has_real_derivative local.Gen_Shleg (Suc k) x) (at x)", "note [derivative_intros] = poly_DERIV"], ["proof (state)\nthis:\n  (poly ?p has_field_derivative poly (pderiv ?p) ?x) (at ?x)\n\ngoal (1 subgoal):\n 1. (local.Gen_Shleg k has_real_derivative local.Gen_Shleg (Suc k) x) (at x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.Gen_Shleg k has_real_derivative local.Gen_Shleg (Suc k) x) (at x)", "unfolding Gen_Shleg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (of_int_poly (local.gen_shleg_poly k)) has_real_derivative\n     poly (of_int_poly (local.gen_shleg_poly (Suc k))) x)\n     (at x)", "by (rule derivative_eq_intros) auto"], ["proof (state)\nthis:\n  (local.Gen_Shleg k has_real_derivative local.Gen_Shleg (Suc k) x) (at x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_Gen_Shleg: \"continuous_on A (Gen_Shleg k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A (local.Gen_Shleg k)", "by (auto simp: Gen_Shleg_def intro!: continuous_intros)"], ["", "lemma continuous_on_Gen_Shleg' [continuous_intros]:\n  \"continuous_on A f \\<Longrightarrow> continuous_on A (\\<lambda>x. Gen_Shleg k (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A f \\<Longrightarrow>\n    continuous_on A (\\<lambda>x. local.Gen_Shleg k (f x))", "by (rule continuous_on_compose2[OF continuous_on_Gen_Shleg[of UNIV]]) auto"], ["", "lemma continuous_on_Shleg: \"continuous_on A Shleg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A local.Shleg", "by (auto simp: Shleg_def intro!: continuous_intros)"], ["", "lemma continuous_on_Shleg' [continuous_intros]:\n  \"continuous_on A f \\<Longrightarrow> continuous_on A (\\<lambda>x. Shleg (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A f \\<Longrightarrow>\n    continuous_on A (\\<lambda>x. local.Shleg (f x))", "by (rule continuous_on_compose2[OF continuous_on_Shleg[of UNIV]]) auto"], ["", "lemma measurable_Gen_Shleg [measurable]: \"Gen_Shleg n \\<in> borel_measurable borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Gen_Shleg n \\<in> borel_measurable borel", "by (intro borel_measurable_continuous_onI continuous_on_Gen_Shleg)"], ["", "lemma measurable_Shleg [measurable]: \"Shleg \\<in> borel_measurable borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Shleg \\<in> borel_measurable borel", "by (intro borel_measurable_continuous_onI continuous_on_Shleg)"], ["", "end"], ["", "subsection \\<open>Auxiliary facts about the \\<open>\\<zeta>\\<close> function\\<close>"], ["", "lemma Re_zeta_ge_1:\n  assumes \"x > 1\"\n  shows   \"Re (zeta (of_real x)) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> Re (zeta (complex_of_real x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> Re (zeta (complex_of_real x))", "have *: \"(\\<lambda>n. real (Suc n) powr -x) sums Re (zeta (complex_of_real x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Suc n) powr - x) sums Re (zeta (complex_of_real x))", "using sums_Re[OF sums_zeta[of \"of_real x\"]] assms"], ["proof (prove)\nusing this:\n  1 < Re (complex_of_real x) \\<Longrightarrow>\n  (\\<lambda>n. Re (of_nat (Suc n) powr - complex_of_real x)) sums\n  Re (zeta (complex_of_real x))\n  1 < x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Suc n) powr - x) sums Re (zeta (complex_of_real x))", "by (simp add: powr_Reals_eq)"], ["proof (state)\nthis:\n  (\\<lambda>n. real (Suc n) powr - x) sums Re (zeta (complex_of_real x))\n\ngoal (1 subgoal):\n 1. 1 \\<le> Re (zeta (complex_of_real x))", "show \"Re (zeta (of_real x)) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> Re (zeta (complex_of_real x))", "proof (rule sums_le[OF _ _ *])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. ?f n \\<le> real (Suc n) powr - x\n 2. ?f sums 1", "show \"(\\<lambda>n. if n = 0 then 1 else 0) sums 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. if n = 0 then 1::'a else (0::'a)) sums (1::'a)", "by (rule sums_single)"], ["proof (state)\nthis:\n  (\\<lambda>n. if n = 0 then 1::?'a1 else (0::?'a1)) sums (1::?'a1)\n\ngoal (1 subgoal):\n 1. \\<And>n. (if n = 0 then 1 else 0) \\<le> real (Suc n) powr - x", "qed auto"], ["proof (state)\nthis:\n  1 \\<le> Re (zeta (complex_of_real x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sums_zeta_of_nat_offset:\n  fixes r :: nat\n  assumes n: \"n > 1\"\n  shows \"(\\<lambda>k. 1 / (r + k + 1) ^ n) sums (zeta (of_nat n) - (\\<Sum>k=1..r. 1 / k ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n    (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n    (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "have \"(\\<lambda>k. 1 / (k + 1) ^ n) sums zeta (of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((x + 1) ^ n))) sums\n    zeta (of_nat n)", "using sums_zeta[of \"of_nat n\"] n"], ["proof (prove)\nusing this:\n  1 < Re (of_nat n) \\<Longrightarrow>\n  (\\<lambda>na. of_nat (Suc na) powr - of_nat n) sums zeta (of_nat n)\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((x + 1) ^ n))) sums\n    zeta (of_nat n)", "by (simp add: powr_minus field_simps flip: of_nat_Suc)"], ["proof (state)\nthis:\n  (\\<lambda>x. complex_of_real (1 / real ((x + 1) ^ n))) sums\n  zeta (of_nat n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n    (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "from sums_split_initial_segment[OF this, of r]"], ["proof (chain)\npicking this:\n  (\\<lambda>i. complex_of_real (1 / real ((i + r + 1) ^ n))) sums\n  (zeta (of_nat n) - (\\<Sum>i<r. complex_of_real (1 / real ((i + 1) ^ n))))", "have \"(\\<lambda>k. 1 / (r + k + 1) ^ n) sums (zeta (of_nat n) - (\\<Sum>k<r. 1 / Suc k ^ n))\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. complex_of_real (1 / real ((i + r + 1) ^ n))) sums\n  (zeta (of_nat n) - (\\<Sum>i<r. complex_of_real (1 / real ((i + 1) ^ n))))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n    (zeta (of_nat n) - complex_of_real (\\<Sum>k<r. 1 / real (Suc k ^ n)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n  (zeta (of_nat n) - complex_of_real (\\<Sum>k<r. 1 / real (Suc k ^ n)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n    (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n  (zeta (of_nat n) - complex_of_real (\\<Sum>k<r. 1 / real (Suc k ^ n)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n    (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "have \"(\\<Sum>k<r. 1 / Suc k ^ n) = (\\<Sum>k=1..r. 1 / k ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<r. 1 / real (Suc k ^ n)) = (\\<Sum>k = 1..r. 1 / real (k ^ n))", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>k. k - 1\" Suc]) auto"], ["proof (state)\nthis:\n  (\\<Sum>k<r. 1 / real (Suc k ^ n)) = (\\<Sum>k = 1..r. 1 / real (k ^ n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n    (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n  (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n  (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n    (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "."], ["proof (state)\nthis:\n  (\\<lambda>x. complex_of_real (1 / real ((r + x + 1) ^ n))) sums\n  (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sums_Re_zeta_of_nat_offset:\n  fixes r :: nat\n  assumes n: \"n > 1\"\n  shows \"(\\<lambda>k. 1 / (r + k + 1) ^ n) sums (Re (zeta (of_nat n)) - (\\<Sum>k=1..r. 1 / k ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real ((r + k + 1) ^ n)) sums\n    (Re (zeta (of_nat n)) - (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real ((r + k + 1) ^ n)) sums\n    (Re (zeta (of_nat n)) - (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "have \"(\\<lambda>k. Re (1 / (r + k + 1) ^ n)) sums (Re (zeta (of_nat n) - (\\<Sum>k=1..r. 1 / k ^ n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. Re (complex_of_real (1 / real ((r + k + 1) ^ n)))) sums\n    Re (zeta (of_nat n) -\n        complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "by (intro sums_Re sums_zeta_of_nat_offset assms)"], ["proof (state)\nthis:\n  (\\<lambda>k. Re (complex_of_real (1 / real ((r + k + 1) ^ n)))) sums\n  Re (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real ((r + k + 1) ^ n)) sums\n    (Re (zeta (of_nat n)) - (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>k. Re (complex_of_real (1 / real ((r + k + 1) ^ n)))) sums\n  Re (zeta (of_nat n) - complex_of_real (\\<Sum>k = 1..r. 1 / real (k ^ n)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real ((r + k + 1) ^ n)) sums\n    (Re (zeta (of_nat n)) - (\\<Sum>k = 1..r. 1 / real (k ^ n)))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / real ((r + k + 1) ^ n)) sums\n  (Re (zeta (of_nat n)) - (\\<Sum>k = 1..r. 1 / real (k ^ n)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Divisor of a sum of rationals\\<close>"], ["", "text \\<open>\n  A finite sum of rationals of the form $\\frac{a_1}{b_1} + \\ldots + \\frac{a_n}{b_n}$\n  can be brought into the form $\\frac{c}{d}$, where $d$ is the LCM of the $b_i$ (or\n  some integer multiple thereof).\n\\<close>"], ["", "lemma sum_rationals_common_divisor:\n  fixes f g :: \"'a \\<Rightarrow> int\"\n  assumes \"finite A\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0\"\n  shows   \"\\<exists>c. (\\<Sum>x\\<in>A. f x / g x) = real_of_int c / (LCM x\\<in>A. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int (Lcm (g ` A))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  ?x \\<in> A \\<Longrightarrow> g ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int (Lcm (g ` A))", "proof (induction rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x. x \\<in> {} \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n    \\<exists>c.\n       (\\<Sum>x\\<in>{}. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int (Lcm (g ` {}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "case empty"], ["proof (state)\nthis:\n  ?x \\<in> {} \\<Longrightarrow> g ?x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (\\<And>x. x \\<in> {} \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n    \\<exists>c.\n       (\\<Sum>x\\<in>{}. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int (Lcm (g ` {}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "thus ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> {} \\<Longrightarrow> g ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>{}. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int (Lcm (g ` {}))", "by auto"], ["proof (state)\nthis:\n  \\<exists>c.\n     (\\<Sum>x\\<in>{}. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` {}))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "define d where \"d = (LCM x\\<in>A. g x)\""], ["proof (state)\nthis:\n  d = Lcm (g ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0", "have [simp]: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by (auto simp: d_def Lcm_0_iff)"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0", "have [simp]: \"g x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0", "obtain c where c: \"(\\<Sum>x\\<in>A. f x / g x) = real_of_int c / real_of_int d\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n        real_of_int c / real_of_int d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: d_def)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n  real_of_int c / real_of_int d\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "define e1 where \"e1 = lcm d (g x) div d\""], ["proof (state)\nthis:\n  e1 = lcm d (g x) div d\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "define e2 where \"e2 = lcm d (g x) div g x\""], ["proof (state)\nthis:\n  e2 = lcm d (g x) div g x\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "have \"(\\<Sum>y\\<in>insert x A. f y / g y) = c / d + f x / g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>insert x A. real_of_int (f y) / real_of_int (g y)) =\n    real_of_int c / real_of_int d + real_of_int (f x) / real_of_int (g x)", "using insert c"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0\n  (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n  real_of_int c / real_of_int d\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>insert x A. real_of_int (f y) / real_of_int (g y)) =\n    real_of_int c / real_of_int d + real_of_int (f x) / real_of_int (g x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>insert x A. real_of_int (f y) / real_of_int (g y)) =\n  real_of_int c / real_of_int d + real_of_int (f x) / real_of_int (g x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>insert x A. real_of_int (f y) / real_of_int (g y)) =\n  real_of_int c / real_of_int d + real_of_int (f x) / real_of_int (g x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "have \"c / d = (c * e1) / lcm d (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int c / real_of_int d =\n    real_of_int (c * e1) / real_of_int (lcm d (g x))", "by (simp add: e1_def real_of_int_div)"], ["proof (state)\nthis:\n  real_of_int c / real_of_int d =\n  real_of_int (c * e1) / real_of_int (lcm d (g x))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "also"], ["proof (state)\nthis:\n  real_of_int c / real_of_int d =\n  real_of_int (c * e1) / real_of_int (lcm d (g x))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "have \"f x / g x = (f x * e2) / lcm d (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (f x) / real_of_int (g x) =\n    real_of_int (f x * e2) / real_of_int (lcm d (g x))", "by (simp add: e2_def real_of_int_div)"], ["proof (state)\nthis:\n  real_of_int (f x) / real_of_int (g x) =\n  real_of_int (f x * e2) / real_of_int (lcm d (g x))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "also"], ["proof (state)\nthis:\n  real_of_int (f x) / real_of_int (g x) =\n  real_of_int (f x * e2) / real_of_int (lcm d (g x))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "have \"(c * e1) / lcm d (g x) + \\<dots> = (c * e1 + f x * e2) / (LCM x\\<in>insert x A. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (c * e1) / real_of_int (lcm d (g x)) +\n    real_of_int (f x * e2) / real_of_int (lcm d (g x)) =\n    real_of_int (c * e1 + f x * e2) / real_of_int (Lcm (g ` insert x A))", "using insert"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  (\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n  ?x \\<in> insert x A \\<Longrightarrow> g ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int (c * e1) / real_of_int (lcm d (g x)) +\n    real_of_int (f x * e2) / real_of_int (lcm d (g x)) =\n    real_of_int (c * e1 + f x * e2) / real_of_int (Lcm (g ` insert x A))", "by (simp add: add_divide_distrib lcm.commute d_def)"], ["proof (state)\nthis:\n  real_of_int (c * e1) / real_of_int (lcm d (g x)) +\n  real_of_int (f x * e2) / real_of_int (lcm d (g x)) =\n  real_of_int (c * e1 + f x * e2) / real_of_int (Lcm (g ` insert x A))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x.\n            x \\<in> F \\<Longrightarrow> g x \\<noteq> 0) \\<Longrightarrow>\n        \\<exists>c.\n           (\\<Sum>x\\<in>F. real_of_int (f x) / real_of_int (g x)) =\n           real_of_int c / real_of_int (Lcm (g ` F));\n        \\<And>xa.\n           xa \\<in> insert x F \\<Longrightarrow> g xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Sum>x\\<in>insert x F.\n                               real_of_int (f x) / real_of_int (g x)) =\n                            real_of_int c /\n                            real_of_int (Lcm (g ` insert x F))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>insert x A. real_of_int (f y) / real_of_int (g y)) =\n  real_of_int (c * e1 + f x * e2) / real_of_int (Lcm (g ` insert x A))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>insert x A. real_of_int (f y) / real_of_int (g y)) =\n  real_of_int (c * e1 + f x * e2) / real_of_int (Lcm (g ` insert x A))\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>insert x A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int (Lcm (g ` insert x A))", ".."], ["proof (state)\nthis:\n  \\<exists>c.\n     (\\<Sum>x\\<in>insert x A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` insert x A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_rationals_common_divisor':\n  fixes f g :: \"'a \\<Rightarrow> int\"\n  assumes \"finite A\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> g x \\<noteq> 0\" and \"(\\<And>x. x \\<in> A \\<Longrightarrow> g x dvd d)\" and \"d \\<noteq> 0\"\n  shows   \"\\<exists>c. (\\<Sum>x\\<in>A. f x / g x) = real_of_int c / real_of_int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "define d' where \"d' = (LCM x\\<in>A. g x)\""], ["proof (state)\nthis:\n  d' = Lcm (g ` A)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "have \"d' dvd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d' dvd d", "unfolding d'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lcm (g ` A) dvd d", "using assms(3)"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> g ?x dvd d\n\ngoal (1 subgoal):\n 1. Lcm (g ` A) dvd d", "by (auto simp: Lcm_dvd_iff)"], ["proof (state)\nthis:\n  d' dvd d\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "then"], ["proof (chain)\npicking this:\n  d' dvd d", "obtain e where e: \"d = d' * e\""], ["proof (prove)\nusing this:\n  d' dvd d\n\ngoal (1 subgoal):\n 1. (\\<And>e. d = d' * e \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  d = d' * e\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "have \"\\<exists>c. (\\<Sum>x\\<in>A. f x / g x) = real_of_int c / (LCM x\\<in>A. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int (Lcm (g ` A))", "by (rule sum_rationals_common_divisor) fact+"], ["proof (state)\nthis:\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))", "obtain c where c: \"(\\<Sum>x\\<in>A. f x / g x) = real_of_int c / real_of_int d'\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n        real_of_int c / real_of_int d' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding d'_def"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int (Lcm (g ` A))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n        real_of_int c / real_of_int (Lcm (g ` A)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n  real_of_int c / real_of_int d'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n  real_of_int c / real_of_int d'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "have \"\\<dots> = real_of_int (c * e) / real_of_int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int c / real_of_int d' = real_of_int (c * e) / real_of_int d", "using \\<open>d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int c / real_of_int d' = real_of_int (c * e) / real_of_int d", "by (simp add: e)"], ["proof (state)\nthis:\n  real_of_int c / real_of_int d' = real_of_int (c * e) / real_of_int d\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n  real_of_int (c * e) / real_of_int d", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n  real_of_int (c * e) / real_of_int d\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n       real_of_int c / real_of_int d", ".."], ["proof (state)\nthis:\n  \\<exists>c.\n     (\\<Sum>x\\<in>A. real_of_int (f x) / real_of_int (g x)) =\n     real_of_int c / real_of_int d\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The first double integral\\<close>"], ["", "text \\<open>\n  We shall now investigate the double integral\n  \\[I_1 := \\int_0^1 \\int_0^1 -\\frac{\\ln(xy)}{1-xy}\\,x^r y^s\\, \\text{d}x\\,\\text{d}y\\ .\\]\n  Since everything is non-negative for now, we can work over the extended non-negative\n  real numbers and the issues of integrability or summability do not arise at all.\n\\<close>"], ["", "definition beukers_nn_integral1 :: \"nat \\<Rightarrow> nat \\<Rightarrow> ennreal\" where\n  \"beukers_nn_integral1 r s =\n     (\\<integral>\\<^sup>+(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. ennreal (-ln (x*y) / (1 - x*y) * x^r * y^s) \\<partial>lborel)\""], ["", "definition beukers_integral1 :: \"nat \\<Rightarrow> nat \\<Rightarrow> real\" where\n  \"beukers_integral1 r s = (\\<integral>(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. (-ln (x*y) / (1 - x*y) * x^r * y^s) \\<partial>lborel)\""], ["", "lemma\n  fixes x y z :: real\n  assumes xyz: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\" \"z \\<in> {0..1}\"\n  shows beukers_denom_ineq: \"(1 - x * y) * z < 1\" and beukers_denom_neq: \"(1 - x * y) * z \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * z < 1 &&& (1 - x * y) * z \\<noteq> 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "from xyz"], ["proof (chain)\npicking this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0..1}", "have *: \"x * y < 1 * 1\""], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. x * y < 1 * 1", "by (intro mult_strict_mono) auto"], ["proof (state)\nthis:\n  x * y < 1 * 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "from *"], ["proof (chain)\npicking this:\n  x * y < 1 * 1", "have \"(1 - x * y) * z \\<le> (1 - x * y) * 1\""], ["proof (prove)\nusing this:\n  x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * z \\<le> (1 - x * y) * 1", "using xyz"], ["proof (prove)\nusing this:\n  x * y < 1 * 1\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - x * y) * z \\<le> (1 - x * y) * 1", "by (intro mult_left_mono) auto"], ["proof (state)\nthis:\n  (1 - x * y) * z \\<le> (1 - x * y) * 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "also"], ["proof (state)\nthis:\n  (1 - x * y) * z \\<le> (1 - x * y) * 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "have \"\\<dots> < 1 * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * 1 < 1 * 1", "using xyz"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - x * y) * 1 < 1 * 1", "by (intro mult_strict_right_mono) auto"], ["proof (state)\nthis:\n  (1 - x * y) * 1 < 1 * 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "finally"], ["proof (chain)\npicking this:\n  (1 - x * y) * z < 1 * 1", "show \"(1 - x * y) * z < 1\" \"(1 - x * y) * z \\<noteq> 1\""], ["proof (prove)\nusing this:\n  (1 - x * y) * z < 1 * 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * z < 1 &&& (1 - x * y) * z \\<noteq> 1", "by simp_all"], ["proof (state)\nthis:\n  (1 - x * y) * z < 1\n  (1 - x * y) * z \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We first evaluate the improper integral\n    \\[\\int_0^1 -\\ln x \\cdot x^e\\,\\text{d}x = \\frac{1}{(e+1)^2}\\ .\\]\n  for any $e>-1$.\n\\<close>"], ["", "lemma integral_0_1_ln_times_powr:\n  assumes \"e > -1\"\n  shows   \"(LBINT x=0..1. -ln x * x powr e) = 1 / (e + 1)\\<^sup>2\"\n    and   \"interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. -ln x * x powr e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2 &&&\n    interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "define f where \"f = (\\<lambda>x. -ln x * x powr e)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. - ln x * x powr e)\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "define F where \"F = (\\<lambda>x. x powr (e + 1) * (1 - (e + 1) * ln x) / (e + 1) ^ 2)\""], ["proof (state)\nthis:\n  F = (\\<lambda>x. x powr (e + 1) * (1 - (e + 1) * ln x) / (e + 1)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "have 0: \"isCont f x\" if \"x \\<in> {0<..<1}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. isCont f x", "by (auto intro!: continuous_intros simp: f_def)"], ["proof (state)\nthis:\n  ?x \\<in> {0<..<1} \\<Longrightarrow> isCont f ?x\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "have 1: \"(F has_real_derivative f x) (at x)\" if \"x \\<in> {0<..<1}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (F has_real_derivative f x) (at x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (F has_real_derivative f x) (at x)", "show \"(F has_real_derivative f x) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F has_real_derivative f x) (at x)", "unfolding F_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (e + 1) * (1 - (e + 1) * ln x) /\n         (e + 1)\\<^sup>2) has_real_derivative\n     - ln x * x powr e)\n     (at x)", "using that assms"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  - 1 < e\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (e + 1) * (1 - (e + 1) * ln x) /\n         (e + 1)\\<^sup>2) has_real_derivative\n     - ln x * x powr e)\n     (at x)", "apply (insert that assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {0<..<1}; - 1 < e\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           x powr (e + 1) * (1 - (e + 1) * ln x) /\n                           (e + 1)\\<^sup>2) has_real_derivative\n                       - ln x * x powr e)\n                       (at x)", "apply (rule derivative_eq_intros refl | simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x \\<and> x < 1; - 1 < e\\<rbrakk>\n    \\<Longrightarrow> ((e + 1) * x powr e * (1 - (e + 1) * ln x) -\n                       (e + 1) * x powr (e + 1) / x) *\n                      (e + 1)\\<^sup>2 /\n                      (e + 1) ^ 4 =\n                      - (ln x * x powr e)", "apply (simp add: divide_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x \\<and> x < 1; - 1 < e\\<rbrakk>\n    \\<Longrightarrow> ((e + 1) * x powr e * (1 - (e + 1) * ln x) * x -\n                       (e + 1) * x powr (e + 1)) *\n                      (e + 1)\\<^sup>2 =\n                      - (ln x * x powr e * (x * (e + 1) ^ 4))", "apply (simp add: power2_eq_square algebra_simps powr_add power_numeral_reduce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (F has_real_derivative f x) (at x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0<..<1} \\<Longrightarrow> (F has_real_derivative f ?x) (at ?x)\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "have 2: \"AE x in lborel. ereal 0 < ereal x \\<longrightarrow> ereal x < ereal 1 \\<longrightarrow> 0 \\<le> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in lborel. ereal 0 < ereal x \\<longrightarrow>\n                    ereal x < ereal 1 \\<longrightarrow> 0 \\<le> f x", "by (intro AE_I2) (auto simp: f_def mult_nonpos_nonneg)"], ["proof (state)\nthis:\n  AE x in lborel. ereal 0 < ereal x \\<longrightarrow>\n                  ereal x < ereal 1 \\<longrightarrow> 0 \\<le> f x\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "have 3: \"((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_right (ereal 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_right (ereal 0))", "unfolding ereal_tendsto_simps F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (e + 1) * (1 - (e + 1) * ln x) /\n         (e + 1)\\<^sup>2) \\<longlongrightarrow>\n     0)\n     (at_right 0)", "using assms"], ["proof (prove)\nusing this:\n  - 1 < e\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (e + 1) * (1 - (e + 1) * ln x) /\n         (e + 1)\\<^sup>2) \\<longlongrightarrow>\n     0)\n     (at_right 0)", "by real_asymp"], ["proof (state)\nthis:\n  ((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_right (ereal 0))\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "have 4: \"((F \\<circ> real_of_ereal) \\<longlongrightarrow> F 1) (at_left (ereal 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F \\<circ> real_of_ereal) \\<longlongrightarrow> F 1)\n     (at_left (ereal 1))", "unfolding ereal_tendsto_simps F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (e + 1) * (1 - (e + 1) * ln x) /\n         (e + 1)\\<^sup>2) \\<longlongrightarrow>\n     1 powr (e + 1) * (1 - (e + 1) * ln 1) / (e + 1)\\<^sup>2)\n     (at_left 1)", "using assms"], ["proof (prove)\nusing this:\n  - 1 < e\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (e + 1) * (1 - (e + 1) * ln x) /\n         (e + 1)\\<^sup>2) \\<longlongrightarrow>\n     1 powr (e + 1) * (1 - (e + 1) * ln 1) / (e + 1)\\<^sup>2)\n     (at_left 1)", "by real_asymp (simp add: field_simps)"], ["proof (state)\nthis:\n  ((F \\<circ> real_of_ereal) \\<longlongrightarrow> F 1) (at_left (ereal 1))\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "have \"(LBINT x=ereal 0..ereal 1. f x) = F 1 - 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interval_lebesgue_integral lborel (ereal 0) (ereal 1) f = F 1 - 0", "by (rule interval_integral_FTC_nonneg[where F = F])\n       (use 0 1 2 3 4 in auto)"], ["proof (state)\nthis:\n  interval_lebesgue_integral lborel (ereal 0) (ereal 1) f = F 1 - 0\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n 2. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "thus \"(LBINT x=0..1. -ln x * x powr e) = 1 / (e + 1)\\<^sup>2\""], ["proof (prove)\nusing this:\n  interval_lebesgue_integral lborel (ereal 0) (ereal 1) f = F 1 - 0\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2", "by (simp add: F_def zero_ereal_def one_ereal_def f_def)"], ["proof (state)\nthis:\n  LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n\ngoal (1 subgoal):\n 1. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "have \"set_integrable lborel (einterval (ereal 0) (ereal 1)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval (ereal 0) (ereal 1)) f", "by (rule interval_integral_FTC_nonneg)\n       (use 0 1 2 3 4 in auto)"], ["proof (state)\nthis:\n  set_integrable lborel (einterval (ereal 0) (ereal 1)) f\n\ngoal (1 subgoal):\n 1. interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "thus \"interval_lebesgue_integrable lborel 0 1 f\""], ["proof (prove)\nusing this:\n  set_integrable lborel (einterval (ereal 0) (ereal 1)) f\n\ngoal (1 subgoal):\n 1. interval_lebesgue_integrable lborel 0 1 f", "by (simp add: interval_lebesgue_integrable_def einterval_def)"], ["proof (state)\nthis:\n  interval_lebesgue_integrable lborel 0 1 f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interval_lebesgue_integral_lborel_01_cong:\n  assumes \"\\<And>x. x \\<in> {0<..<1} \\<Longrightarrow> f x = g x\"\n  shows   \"interval_lebesgue_integral lborel 0 1 f =\n           interval_lebesgue_integral lborel 0 1 g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interval_lebesgue_integral lborel 0 1 f =\n    interval_lebesgue_integral lborel 0 1 g", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> {0<..<1} \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. interval_lebesgue_integral lborel 0 1 f =\n    interval_lebesgue_integral lborel 0 1 g", "by (subst (1 2) interval_integral_Ioo)\n     (auto intro!: set_lebesgue_integral_cong assms)"], ["", "lemma nn_integral_0_1_ln_times_powr:\n  assumes \"e > -1\"\n  shows    \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y powr e) \\<partial>lborel) = ennreal (1 / (e + 1)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "have *: \"(LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2)\"\n          \"interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2 &&&\n    interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "using integral_0_1_ln_times_powr[OF assms]"], ["proof (prove)\nusing this:\n  LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n  interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2 &&&\n    interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)", "by simp_all"], ["proof (state)\nthis:\n  LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n  interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "have eq: \"(\\<lambda>y. (if 0 < y \\<and> y < 1 then 1 else 0) * ln y * y powr e) =\n            (\\<lambda>y. if 0 < y \\<and> y < 1 then ln y * y powr e else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. (if 0 < y \\<and> y < 1 then 1 else 0) * ln y * y powr e) =\n    (\\<lambda>y. if 0 < y \\<and> y < 1 then ln y * y powr e else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>y. (if 0 < y \\<and> y < 1 then 1 else 0) * ln y * y powr e) =\n  (\\<lambda>y. if 0 < y \\<and> y < 1 then ln y * y powr e else 0)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "have \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y powr e) \\<partial>lborel) =\n           (\\<integral>\\<^sup>+y. ennreal (-ln y * y powr e * indicator {0<..<1} y) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ y. ennreal\n                            (- ln y * y powr e * indicat_real {0<..<1} y)\n                       \\<partial>lborel", "by (intro nn_integral_cong) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ y. ennreal\n                          (- ln y * y powr e * indicat_real {0<..<1} y)\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ y. ennreal\n                          (- ln y * y powr e * indicat_real {0<..<1} y)\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "have \"\\<dots> = ennreal (1 / (e + 1)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. ennreal\n                            (- ln y * y powr e * indicat_real {0<..<1} y)\n                       \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "using * eq"], ["proof (prove)\nusing this:\n  LBINT x=0..1. - ln x * x powr e = 1 / (e + 1)\\<^sup>2\n  interval_lebesgue_integrable lborel 0 1 (\\<lambda>x. - ln x * x powr e)\n  (\\<lambda>y. (if 0 < y \\<and> y < 1 then 1 else 0) * ln y * y powr e) =\n  (\\<lambda>y. if 0 < y \\<and> y < 1 then ln y * y powr e else 0)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. ennreal\n                            (- ln y * y powr e * indicat_real {0<..<1} y)\n                       \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "by (subst nn_integral_eq_integral)\n       (auto intro!: AE_I2 simp: indicator_def interval_lebesgue_integrable_def\n               set_integrable_def one_ereal_def zero_ereal_def interval_integral_Ioo\n                mult_ac mult_nonpos_nonneg set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. ennreal\n                          (- ln y * y powr e * indicat_real {0<..<1} y)\n                     \\<partial>lborel =\n  ennreal (1 / (e + 1)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n  \\<partial>lborel =\n  ennreal (1 / (e + 1)\\<^sup>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n  \\<partial>lborel =\n  ennreal (1 / (e + 1)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n    \\<partial>lborel =\n    ennreal (1 / (e + 1)\\<^sup>2)", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr e)\n  \\<partial>lborel =\n  ennreal (1 / (e + 1)\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nn_integral_0_1_ln_times_power:\n  \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y ^ n) \\<partial>lborel) = ennreal (1 / (n + 1)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n    \\<partial>lborel =\n    ennreal (1 / (real n + 1)\\<^sup>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n    \\<partial>lborel =\n    ennreal (1 / (real n + 1)\\<^sup>2)", "have \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y ^ n) \\<partial>lborel) =\n          (\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y powr real n) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr real n)\n    \\<partial>lborel", "by (intro set_nn_integral_cong) (auto simp: powr_realpow)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr real n)\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n    \\<partial>lborel =\n    ennreal (1 / (real n + 1)\\<^sup>2)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr real n)\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n    \\<partial>lborel =\n    ennreal (1 / (real n + 1)\\<^sup>2)", "have \"\\<dots> = ennreal (1 / (n + 1)^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr real n)\n    \\<partial>lborel =\n    ennreal (1 / real ((n + 1)\\<^sup>2))", "by (subst nn_integral_0_1_ln_times_powr) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x powr real n)\n  \\<partial>lborel =\n  ennreal (1 / real ((n + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n    \\<partial>lborel =\n    ennreal (1 / (real n + 1)\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n  \\<partial>lborel =\n  ennreal (1 / real ((n + 1)\\<^sup>2))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n  \\<partial>lborel =\n  ennreal (1 / real ((n + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n    \\<partial>lborel =\n    ennreal (1 / (real n + 1)\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ n)\n  \\<partial>lborel =\n  ennreal (1 / (real n + 1)\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Next, we also evaluate the more trivial integral\n    \\[\\int_0^1 x^n\\ \\text{d}x\\ .\\]\n\\<close>"], ["", "lemma nn_integral_0_1_power:\n  \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (y ^ n) \\<partial>lborel) = ennreal (1 / (n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "have *: \"((\\<lambda>a. a ^ (n + 1) / real (n + 1)) has_real_derivative x ^ n) (at x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a. a ^ (n + 1) / real (n + 1)) has_real_derivative x ^ n)\n     (at x)", "by (rule derivative_eq_intros refl | simp)+"], ["proof (state)\nthis:\n  ((\\<lambda>a. a ^ (n + 1) / real (n + 1)) has_real_derivative ?x ^ n)\n   (at ?x)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "have \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (y ^ n) \\<partial>lborel) = (\\<integral>\\<^sup>+y\\<in>{0..1}. ennreal (y ^ n) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..1}. ennreal (x ^ n)\\<partial>lborel", "by (intro nn_integral_cong_AE AE_I[of _ _ \"{0,1}\"])\n       (auto simp: indicator_def emeasure_lborel_countable)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0..1}. ennreal (x ^ n)\\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0..1}. ennreal (x ^ n)\\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "have \"\\<dots> = ennreal (1 ^ (n + 1) / (n + 1) - 0 ^ (n + 1) / (n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 ^ (n + 1) / real (n + 1) - 0 ^ (n + 1) / real (n + 1))", "using *"], ["proof (prove)\nusing this:\n  ((\\<lambda>a. a ^ (n + 1) / real (n + 1)) has_real_derivative ?x ^ n)\n   (at ?x)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 ^ (n + 1) / real (n + 1) - 0 ^ (n + 1) / real (n + 1))", "by (intro nn_integral_FTC_Icc) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..1}. ennreal (x ^ n)\\<partial>lborel =\n  ennreal (1 ^ (n + 1) / real (n + 1) - 0 ^ (n + 1) / real (n + 1))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..1}. ennreal (x ^ n)\\<partial>lborel =\n  ennreal (1 ^ (n + 1) / real (n + 1) - 0 ^ (n + 1) / real (n + 1))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "have \"\\<dots> = ennreal (1 / (n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 ^ (n + 1) / real (n + 1) - 0 ^ (n + 1) / real (n + 1)) =\n    ennreal (1 / real (n + 1))", "by simp"], ["proof (state)\nthis:\n  ennreal (1 ^ (n + 1) / real (n + 1) - 0 ^ (n + 1) / real (n + 1)) =\n  ennreal (1 / real (n + 1))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n  ennreal (1 / real (n + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n  ennreal (1 / real (n + 1))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n    ennreal (1 / (real n + 1))", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ n)\\<partial>lborel =\n  ennreal (1 / (real n + 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  $I_1$ can alternatively be written as the triple integral\n    \\[\\int_0^1\\int_0^1\\int_0^1\n        \\frac{x^r y^s}{1-(1-xy)w}\\ \\text{d}x\\,\\text{d}y\\,\\text{d}w\\ .\\]\n\\<close>"], ["", "lemma beukers_nn_integral1_altdef:\n  \"beukers_nn_integral1 r s =\n     (\\<integral>\\<^sup>+(w,x,y)\\<in>{0<..<1}\\<times>{0<..<1}\\<times>{0<..<1}.\n       ennreal (1 / (1-(1-x*y)*w) * x^r * y^s) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel", "have \"(\\<integral>\\<^sup>+(w,x,y)\\<in>{0<..<1}\\<times>{0<..<1}\\<times>{0<..<1}.\n           ennreal (1 / (1-(1-x*y)*w) * x^r * y^s) \\<partial>lborel) =\n        (\\<integral>\\<^sup>+(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. (\\<integral>\\<^sup>+w\\<in>{0<..<1}.\n           ennreal (1 / (1-(1-x*y)*w) * x^r * y^s) \\<partial>lborel) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n                          \\<partial>lborel)\n    \\<partial>lborel", "by (subst lborel_prod [symmetric], subst lborel_pair.nn_integral_snd [symmetric])\n       (auto simp: case_prod_unfold indicator_def simp flip: lborel_prod intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (w, xa, y) \\<Rightarrow>\n                        ennreal\n                         (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n                        \\<partial>lborel)\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (w, xa, y) \\<Rightarrow>\n                        ennreal\n                         (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n                        \\<partial>lborel)\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel", "have \"\\<dots> = (\\<integral>\\<^sup>+(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. ennreal (-ln (x*y)/(1-x*y) * x^r * y^s) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n                          \\<partial>lborel)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal\n                           (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n    \\<partial>lborel", "proof (intro nn_integral_cong, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> space lborel \\<Longrightarrow>\n       (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                           ennreal\n                            (1 / (1 - (1 - a * b) * x) * a ^ r * b ^ s)\n        \\<partial>lborel) *\n       indicator ({0<..<1} \\<times> {0<..<1}) (a, b) =\n       ennreal (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) *\n       indicator ({0<..<1} \\<times> {0<..<1}) (a, b)", "fix x y :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> space lborel \\<Longrightarrow>\n       (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                           ennreal\n                            (1 / (1 - (1 - a * b) * x) * a ^ r * b ^ s)\n        \\<partial>lborel) *\n       indicator ({0<..<1} \\<times> {0<..<1}) (a, b) =\n       ennreal (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) *\n       indicator ({0<..<1} \\<times> {0<..<1}) (a, b)", "have \"(\\<integral>\\<^sup>+w\\<in>{0<..<1}. ennreal (1/(1-(1-x*y)*w)*x^r*y^s) \\<partial>lborel) =\n             ennreal (-ln (x*y)*x^r*y^s/(1-x*y))\"\n      if xy: \"(x, y) \\<in> {0<..<1} \\<times> {0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "from xy"], ["proof (chain)\npicking this:\n  (x, y) \\<in> {0<..<1} \\<times> {0<..<1}", "have \"x * y < 1\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> {0<..<1} \\<times> {0<..<1}\n\ngoal (1 subgoal):\n 1. x * y < 1", "using mult_strict_mono[of x 1 y 1]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {0<..<1} \\<times> {0<..<1}\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. x * y < 1", "by simp"], ["proof (state)\nthis:\n  x * y < 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "have deriv: \"((\\<lambda>w. -ln (1-(1-x*y)*w) / (1-x*y)) has_real_derivative\n              1/(1-(1-x*y)*w)) (at w)\" if w: \"w \\<in> {0..1}\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>w.\n         - ln (1 - (1 - x * y) * w) / (1 - x * y)) has_real_derivative\n     1 / (1 - (1 - x * y) * w))\n     (at w)", "by (insert xy w \\<open>x*y<1\\<close> beukers_denom_ineq[of x y w])\n           (rule derivative_eq_intros refl | simp add: divide_simps)+"], ["proof (state)\nthis:\n  ?w \\<in> {0..1} \\<Longrightarrow>\n  ((\\<lambda>w.\n       - ln (1 - (1 - x * y) * w) / (1 - x * y)) has_real_derivative\n   1 / (1 - (1 - x * y) * ?w))\n   (at ?w)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "have \"(\\<integral>\\<^sup>+w\\<in>{0<..<1}. ennreal (1/(1-(1-x*y)*w)*x^r*y^s) \\<partial>lborel) =\n              ennreal (x^r*y^s) * (\\<integral>\\<^sup>+w\\<in>{0<..<1}. ennreal (1/(1-(1-x*y)*w)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (x ^ r * y ^ s) *\n    (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                        ennreal (1 / (1 - (1 - x * y) * xa))\n     \\<partial>lborel)", "using xy"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {0<..<1} \\<times> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (x ^ r * y ^ s) *\n    (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                        ennreal (1 / (1 - (1 - x * y) * xa))\n     \\<partial>lborel)", "by (subst nn_integral_cmult [symmetric])\n                    (auto intro!: nn_integral_cong simp: indicator_def simp flip: ennreal_mult')"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n  \\<partial>lborel =\n  ennreal (x ^ r * y ^ s) *\n  (\\<integral>\\<^sup>+xa\\<in>{0<..<1}. ennreal (1 / (1 - (1 - x * y) * xa))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n  \\<partial>lborel =\n  ennreal (x ^ r * y ^ s) *\n  (\\<integral>\\<^sup>+xa\\<in>{0<..<1}. ennreal (1 / (1 - (1 - x * y) * xa))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "have \"(\\<integral>\\<^sup>+w\\<in>{0<..<1}. ennreal (1/(1-(1-x*y)*w)) \\<partial>lborel) =\n                 (\\<integral>\\<^sup>+w\\<in>{0..1}. ennreal (1/(1-(1-x*y)*w)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}. ennreal (1 / (1 - (1 - x * y) * xa))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+xa\\<in>{0..1}. ennreal (1 / (1 - (1 - x * y) * xa))\n    \\<partial>lborel", "by (intro nn_integral_cong_AE AE_I[of _ _ \"{0,1}\"])\n           (auto simp: emeasure_lborel_countable indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}. ennreal (1 / (1 - (1 - x * y) * xa))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+xa\\<in>{0..1}. ennreal (1 / (1 - (1 - x * y) * xa))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}. ennreal (1 / (1 - (1 - x * y) * xa))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+xa\\<in>{0..1}. ennreal (1 / (1 - (1 - x * y) * xa))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "have \"(\\<integral>\\<^sup>+w\\<in>{0..1}. ennreal (1/(1-(1-x*y)*w)) \\<partial>lborel) =\n                   ennreal (-ln (1-(1-x*y)*1)/(1-x*y) - (-ln (1-(1-x*y)*0)/(1-x*y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0..1}. ennreal (1 / (1 - (1 - x * y) * xa))\n    \\<partial>lborel =\n    ennreal\n     (- ln (1 - (1 - x * y) * 1) / (1 - x * y) -\n      - ln (1 - (1 - x * y) * 0) / (1 - x * y))", "using xy deriv less_imp_le[OF beukers_denom_ineq[of x y]]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {0<..<1} \\<times> {0<..<1}\n  ?w \\<in> {0..1} \\<Longrightarrow>\n  ((\\<lambda>w.\n       - ln (1 - (1 - x * y) * w) / (1 - x * y)) has_real_derivative\n   1 / (1 - (1 - x * y) * ?w))\n   (at ?w)\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; ?z1 \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * ?z1 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0..1}. ennreal (1 / (1 - (1 - x * y) * xa))\n    \\<partial>lborel =\n    ennreal\n     (- ln (1 - (1 - x * y) * 1) / (1 - x * y) -\n      - ln (1 - (1 - x * y) * 0) / (1 - x * y))", "by (intro nn_integral_FTC_Icc) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0..1}. ennreal (1 / (1 - (1 - x * y) * xa))\n  \\<partial>lborel =\n  ennreal\n   (- ln (1 - (1 - x * y) * 1) / (1 - x * y) -\n    - ln (1 - (1 - x * y) * 0) / (1 - x * y))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n  \\<partial>lborel =\n  ennreal (x ^ r * y ^ s) *\n  ennreal\n   (- ln (1 - (1 - x * y) * 1) / (1 - x * y) -\n    - ln (1 - (1 - x * y) * 0) / (1 - x * y))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n  \\<partial>lborel =\n  ennreal (x ^ r * y ^ s) *\n  ennreal\n   (- ln (1 - (1 - x * y) * 1) / (1 - x * y) -\n    - ln (1 - (1 - x * y) * 0) / (1 - x * y))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "using xy"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n  \\<partial>lborel =\n  ennreal (x ^ r * y ^ s) *\n  ennreal\n   (- ln (1 - (1 - x * y) * 1) / (1 - x * y) -\n    - ln (1 - (1 - x * y) * 0) / (1 - x * y))\n  (x, y) \\<in> {0<..<1} \\<times> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n    \\<partial>lborel =\n    ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))", "by (simp flip: ennreal_mult' ennreal_mult'' add: mult_ac)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n  \\<partial>lborel =\n  ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> {0<..<1} \\<times> {0<..<1} \\<Longrightarrow>\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n  \\<partial>lborel =\n  ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> space lborel \\<Longrightarrow>\n       (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                           ennreal\n                            (1 / (1 - (1 - a * b) * x) * a ^ r * b ^ s)\n        \\<partial>lborel) *\n       indicator ({0<..<1} \\<times> {0<..<1}) (a, b) =\n       ennreal (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) *\n       indicator ({0<..<1} \\<times> {0<..<1}) (a, b)", "thus \"(\\<integral>\\<^sup>+w\\<in>{0<..<1}. ennreal (1/(1-(1-x*y)*w)*x^r*y^s) \\<partial>lborel) * indicator ({0<..<1}\\<times>{0<..<1}) (x, y) =\n           ennreal (-ln (x*y)/(1-x*y)*x^r*y^s) * indicator ({0<..<1}\\<times>{0<..<1}) (x, y)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> {0<..<1} \\<times> {0<..<1} \\<Longrightarrow>\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n  \\<partial>lborel =\n  ennreal (- ln (x * y) * x ^ r * y ^ s / (1 - x * y))\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                        ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n     \\<partial>lborel) *\n    indicator ({0<..<1} \\<times> {0<..<1}) (x, y) =\n    ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s) *\n    indicator ({0<..<1} \\<times> {0<..<1}) (x, y)", "by (auto simp: indicator_def)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                      ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n   \\<partial>lborel) *\n  indicator ({0<..<1} \\<times> {0<..<1}) (x, y) =\n  ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s) *\n  indicator ({0<..<1} \\<times> {0<..<1}) (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n                        \\<partial>lborel)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal\n                         (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n     ennreal (1 / (1 - (1 - x * y) * xa) * x ^ r * y ^ s)\n                        \\<partial>lborel)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal\n                         (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel", "have \"\\<dots> = beukers_nn_integral1 r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal\n                           (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n    \\<partial>lborel =\n    beukers_nn_integral1 r s", "by (simp add: beukers_nn_integral1_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal\n                         (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n  \\<partial>lborel =\n  beukers_nn_integral1 r s\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (w, xa, y) \\<Rightarrow>\n                        ennreal\n                         (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n  \\<partial>lborel =\n  beukers_nn_integral1 r s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (w, xa, y) \\<Rightarrow>\n                        ennreal\n                         (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n  \\<partial>lborel =\n  beukers_nn_integral1 r s\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (w, xa, y) \\<Rightarrow>\n                          ennreal\n                           (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n    \\<partial>lborel", ".."], ["proof (state)\nthis:\n  beukers_nn_integral1 r s =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (w, xa, y) \\<Rightarrow>\n                        ennreal\n                         (1 / (1 - (1 - xa * y) * w) * xa ^ r * y ^ s))\n  \\<partial>lborel\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes r s :: nat and I1 I2' :: real and I2 :: ennreal and D :: \"(real \\<times> real \\<times> real) set\"\n  assumes rs: \"s \\<le> r\"\n  defines \"D \\<equiv> {0<..<1}\\<times>{0<..<1}\\<times>{0<..<1}\"\nbegin"], ["", "text \\<open>\n  By unfolding the geometric series, pulling the summation out and evaluating the integrals,\n  we find that\n    \\[I_1 = \\sum_{k=0}^\\infty \\frac{1}{(k+r+1)^2(k+s+1)} + \\frac{1}{(k+r+1)(k+s+1)^2}\\ .\\]\n\\<close>"], ["", "lemma beukers_nn_integral1_series:\n  \"beukers_nn_integral1 r s = (\\<Sum>k. ennreal (1/((k+r+1)^2*(k+s+1)) + 1/((k+r+1)*(k+s+1)^2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "have \"beukers_nn_integral1 r s =\n          (\\<integral>\\<^sup>+(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. (\\<Sum>k. ennreal (-ln (x*y) * x^(k+r) * y^(k+s))) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          \\<Sum>k.\n                             ennreal\n                              (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n    \\<partial>lborel", "unfolding beukers_nn_integral1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal\n                           (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          \\<Sum>k.\n                             ennreal\n                              (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n    \\<partial>lborel", "proof (intro set_nn_integral_cong refl, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "fix x y :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "assume xy: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\""], ["proof (state)\nthis:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "from xy"], ["proof (chain)\npicking this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}", "have \"x * y < 1\""], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. x * y < 1", "using mult_strict_mono[of x 1 y 1]"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. x * y < 1", "by simp"], ["proof (state)\nthis:\n  x * y < 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "have \"(\\<Sum>k. ennreal (-ln (x*y) * x^(k+r) * y^(k+s))) =\n             ennreal (-ln (x*y) * x^r * y^s) * (\\<Sum>k. ennreal ((x*y)^k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k. ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s))) =\n    ennreal (- ln (x * y) * x ^ r * y ^ s) *\n    (\\<Sum>k. ennreal ((x * y) ^ k))", "using xy"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>k. ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s))) =\n    ennreal (- ln (x * y) * x ^ r * y ^ s) *\n    (\\<Sum>k. ennreal ((x * y) ^ k))", "by (subst ennreal_suminf_cmult [symmetric], subst ennreal_mult'' [symmetric])\n                  (auto simp: power_add mult_ac power_mult_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>k. ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s))) =\n  ennreal (- ln (x * y) * x ^ r * y ^ s) * (\\<Sum>k. ennreal ((x * y) ^ k))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k. ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s))) =\n  ennreal (- ln (x * y) * x ^ r * y ^ s) * (\\<Sum>k. ennreal ((x * y) ^ k))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "have \"(\\<Sum>k. ennreal ((x*y)^k)) = ennreal (1 / (1 - x*y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k. ennreal ((x * y) ^ k)) = ennreal (1 / (1 - x * y))", "using geometric_sums[of \"x*y\"] \\<open>x * y < 1\\<close> xy"], ["proof (prove)\nusing this:\n  norm (x * y) < 1 \\<Longrightarrow> (^) (x * y) sums (1 / (1 - x * y))\n  x * y < 1\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>k. ennreal ((x * y) ^ k)) = ennreal (1 / (1 - x * y))", "by (intro suminf_ennreal_eq) auto"], ["proof (state)\nthis:\n  (\\<Sum>k. ennreal ((x * y) ^ k)) = ennreal (1 / (1 - x * y))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k. ennreal ((x * y) ^ k)) = ennreal (1 / (1 - x * y))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "have \"ennreal (-ln (x*y) * x^r * y^s) * \\<dots> =\n                 ennreal (-ln (x*y) / (1 - x*y) * x^r * y^s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (- ln (x * y) * x ^ r * y ^ s) * ennreal (1 / (1 - x * y)) =\n    ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s)", "using \\<open>x * y < 1\\<close>"], ["proof (prove)\nusing this:\n  x * y < 1\n\ngoal (1 subgoal):\n 1. ennreal (- ln (x * y) * x ^ r * y ^ s) * ennreal (1 / (1 - x * y)) =\n    ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s)", "by (subst ennreal_mult'' [symmetric]) auto"], ["proof (state)\nthis:\n  ennreal (- ln (x * y) * x ^ r * y ^ s) * ennreal (1 / (1 - x * y)) =\n  ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (- ln (a * b) / (1 - a * b) * a ^ r * b ^ s) =\n                         (\\<Sum>k.\n                             ennreal\n                              (- ln (a * b) * a ^ (k + r) * b ^ (k + s)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k. ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s))) =\n  ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s)", "show \"ennreal (-ln (x*y) / (1 - x*y) * x^r * y^s) =\n                    (\\<Sum>k. ennreal (-ln (x*y) * x^(k+r) * y^(k+s)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>k. ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s))) =\n  ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n\ngoal (1 subgoal):\n 1. ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s) =\n    (\\<Sum>k. ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))", ".."], ["proof (state)\nthis:\n  ennreal (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s) =\n  (\\<Sum>k. ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  beukers_nn_integral1 r s =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        \\<Sum>k.\n                           ennreal\n                            (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "also"], ["proof (state)\nthis:\n  beukers_nn_integral1 r s =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        \\<Sum>k.\n                           ennreal\n                            (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "have \"\\<dots> = (\\<Sum>k. (\\<integral>\\<^sup>+(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. (ennreal (-ln (x*y) * x^(k+r) * y^(k+s))) \\<partial>lborel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          \\<Sum>k.\n                             ennreal\n                              (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n    \\<partial>lborel =\n    (\\<Sum>k.\n        \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                           (case x of\n                            (x, y) \\<Rightarrow>\n                              ennreal\n                               (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n        \\<partial>lborel)", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (\\<Sum>k.\n                           ennreal\n                            (- ln (fst x * snd x) * fst x ^ (k + r) *\n                             snd x ^ (k + s)))\n    \\<partial>lborel =\n    (\\<Sum>k.\n        \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                           ennreal\n                            (- ln (fst x * snd x) * fst x ^ (k + r) *\n                             snd x ^ (k + s))\n        \\<partial>lborel)", "by (subst nn_integral_suminf [symmetric]) (auto simp flip: borel_prod)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        \\<Sum>k.\n                           ennreal\n                            (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel =\n  (\\<Sum>k.\n      \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            ennreal\n                             (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        \\<Sum>k.\n                           ennreal\n                            (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel =\n  (\\<Sum>k.\n      \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            ennreal\n                             (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "have \"\\<dots> = (\\<Sum>k. ennreal (1 / ((k+r+1)^2*(k+s+1)) + 1 / ((k+r+1)*(k+s+1)^2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k.\n        \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                           (case x of\n                            (x, y) \\<Rightarrow>\n                              ennreal\n                               (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n        \\<partial>lborel) =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "proof (rule suminf_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "fix k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "define F where \"F = (\\<lambda>x y::real. x + y)\""], ["proof (state)\nthis:\n  F = (+)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"(\\<integral>\\<^sup>+(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. ennreal (-ln (x*y) * x^(k+r) * y^(k+s)) \\<partial>lborel) =\n            (\\<integral>\\<^sup>+x\\<in>{0<..<1}. (\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln (x*y) * x^(k+r) * y^(k+s)) \\<partial>lborel) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal\n                           (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n     ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                        \\<partial>lborel)\n    \\<partial>lborel", "unfolding case_prod_unfold lborel_prod [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (- ln (fst x * snd x) * fst x ^ (k + r) *\n                         snd x ^ (k + s))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n     ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                        \\<partial>lborel)\n    \\<partial>lborel", "by (subst lborel.nn_integral_fst [symmetric]) (auto intro!: nn_integral_cong simp: indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n   ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                      \\<partial>lborel)\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n   ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                      \\<partial>lborel)\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"\\<dots> = (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (-ln x * x^(k+r) / (k+s+1) + x^(k+r)/(k+s+1)^2) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n     ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                        \\<partial>lborel)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       ennreal\n                        (- ln x * x ^ (k + r) / real (k + s + 1) +\n                         x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n    \\<partial>lborel", "proof (intro set_nn_integral_cong refl, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "fix x :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "assume x: \"x \\<in> {0<..<1}\""], ["proof (state)\nthis:\n  x \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln (x*y) * x^(k+r) * y^(k+s)) \\<partial>lborel) =\n              (\\<integral>\\<^sup>+y\\<in>{0<..<1}. (ennreal (-ln x * x^(k+r) * y^(k+s)) + ennreal (-ln y * x^(k+r) * y^(k+s))) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       (ennreal (- ln x * x ^ (k + r) * xa ^ (k + s)) +\n                        ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s)))\n    \\<partial>lborel", "by (intro set_nn_integral_cong)\n           (use x in \\<open>auto simp: ln_mult ring_distribs mult_nonpos_nonneg simp flip: ennreal_plus\\<close>)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     (ennreal (- ln x * x ^ (k + r) * xa ^ (k + s)) +\n                      ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s)))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     (ennreal (- ln x * x ^ (k + r) * xa ^ (k + s)) +\n                      ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s)))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"\\<dots> = (\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln x * x^(k+r) * y^(k+s)) \\<partial>lborel) +\n                      (\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * x^(k+r) * y^(k+s)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       (ennreal (- ln x * x ^ (k + r) * xa ^ (k + s)) +\n                        ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s)))\n    \\<partial>lborel =\n    (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                        ennreal (- ln x * x ^ (k + r) * xa ^ (k + s))\n     \\<partial>lborel) +\n    (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                        ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s))\n     \\<partial>lborel)", "by (subst nn_integral_add [symmetric]) (auto intro!: nn_integral_cong simp: indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     (ennreal (- ln x * x ^ (k + r) * xa ^ (k + s)) +\n                      ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s)))\n  \\<partial>lborel =\n  (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                      ennreal (- ln x * x ^ (k + r) * xa ^ (k + s))\n   \\<partial>lborel) +\n  (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                      ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     (ennreal (- ln x * x ^ (k + r) * xa ^ (k + s)) +\n                      ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s)))\n  \\<partial>lborel =\n  (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                      ennreal (- ln x * x ^ (k + r) * xa ^ (k + s))\n   \\<partial>lborel) +\n  (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                      ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln x * x^(k+r) * y^(k+s)) \\<partial>lborel) =\n                 ennreal (-ln x * x^(k+r)) * (\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (y^(k+s)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (- ln x * x ^ (k + r) * xa ^ (k + s))\n    \\<partial>lborel =\n    ennreal (- ln x * x ^ (k + r)) *\n    (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + s))\n     \\<partial>lborel)", "by (subst nn_integral_cmult [symmetric])\n           (auto intro!: nn_integral_cong simp: indicator_def simp flip: ennreal_mult'')"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln x * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  ennreal (- ln x * x ^ (k + r)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + s))\\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln x * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  ennreal (- ln x * x ^ (k + r)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + s))\\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (y^(k+s)) \\<partial>lborel) = ennreal (1/(k+s+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + s))\n    \\<partial>lborel =\n    ennreal (1 / real (k + s + 1))", "by (subst nn_integral_0_1_power) simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + s))\\<partial>lborel =\n  ennreal (1 / real (k + s + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + s))\\<partial>lborel =\n  ennreal (1 / real (k + s + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"ennreal (-ln x * x^(k+r)) * \\<dots> = ennreal (-ln x * x^(k+r) / (k+s+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (- ln x * x ^ (k + r)) * ennreal (1 / real (k + s + 1)) =\n    ennreal (- ln x * x ^ (k + r) / real (k + s + 1))", "by (subst ennreal_mult'' [symmetric]) auto"], ["proof (state)\nthis:\n  ennreal (- ln x * x ^ (k + r)) * ennreal (1 / real (k + s + 1)) =\n  ennreal (- ln x * x ^ (k + r) / real (k + s + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  ennreal (- ln x * x ^ (k + r)) * ennreal (1 / real (k + s + 1)) =\n  ennreal (- ln x * x ^ (k + r) / real (k + s + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * x^(k+r) * y^(k+s)) \\<partial>lborel) =\n                   ennreal (x^(k+r)) * (\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y^(k+s)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s))\n    \\<partial>lborel =\n    ennreal (x ^ (k + r)) *\n    (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + s))\n     \\<partial>lborel)", "by (subst nn_integral_cmult [symmetric])\n           (use x in \\<open>auto intro!: nn_integral_cong simp: indicator_def mult_ac simp flip: ennreal_mult'\\<close>)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  ennreal (x ^ (k + r)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + s))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln xa * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  ennreal (x ^ (k + r)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + s))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln y * y^(k+s)) \\<partial>lborel) = ennreal (1 / (k + s + 1)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + s))\n    \\<partial>lborel =\n    ennreal (1 / real ((k + s + 1)\\<^sup>2))", "by (subst nn_integral_0_1_ln_times_power) simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + s))\n  \\<partial>lborel =\n  ennreal (1 / real ((k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + s))\n  \\<partial>lborel =\n  ennreal (1 / real ((k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"ennreal (x ^ (k + r)) * \\<dots> = ennreal (x ^ (k + r) / (k + s + 1) ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (x ^ (k + r)) * ennreal (1 / real ((k + s + 1)\\<^sup>2)) =\n    ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "by (subst ennreal_mult'' [symmetric]) auto"], ["proof (state)\nthis:\n  ennreal (x ^ (k + r)) * ennreal (1 / real ((k + s + 1)\\<^sup>2)) =\n  ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  ennreal (x ^ (k + r)) * ennreal (1 / real ((k + s + 1)\\<^sup>2)) =\n  ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "have \"ennreal (- ln x * x ^ (k + r) / (k + s + 1)) + \\<dots> =\n                   ennreal (-ln x * x^(k+r) / (k+s+1) + x^(k+r)/(k+s+1)^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n    ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)) =\n    ennreal\n     (- ln x * x ^ (k + r) / real (k + s + 1) +\n      x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n    ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)) =\n    ennreal\n     (- ln x * x ^ (k + r) / real (k + s + 1) +\n      x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "by (subst ennreal_plus) (auto simp: mult_nonpos_nonneg divide_nonpos_nonneg)"], ["proof (state)\nthis:\n  ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n  ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)) =\n  ennreal\n   (- ln x * x ^ (k + r) / real (k + s + 1) +\n    x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; x \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n      ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                         \\<partial>lborel =\n                         ennreal\n                          (- ln x * x ^ (k + r) / real (k + s + 1) +\n                           x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  ennreal\n   (- ln x * x ^ (k + r) / real (k + s + 1) +\n    x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "show \"(\\<integral>\\<^sup>+y\\<in>{0<..<1}. ennreal (-ln (x*y) * x^(k+r) * y^(k+s)) \\<partial>lborel) =\n                      ennreal (-ln x * x^(k+r) / (k+s+1) + x^(k+r)/(k+s+1)^2)\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  ennreal\n   (- ln x * x ^ (k + r) / real (k + s + 1) +\n    x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                       ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n    \\<partial>lborel =\n    ennreal\n     (- ln x * x ^ (k + r) / real (k + s + 1) +\n      x ^ (k + r) / real ((k + s + 1)\\<^sup>2))", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n                     ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n  \\<partial>lborel =\n  ennreal\n   (- ln x * x ^ (k + r) / real (k + s + 1) +\n    x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n   ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                      \\<partial>lborel)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     ennreal\n                      (- ln x * x ^ (k + r) / real (k + s + 1) +\n                       x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     (\\<integral>\\<^sup>+xa\\<in>{0<..<1}.\n   ennreal (- ln (x * xa) * x ^ (k + r) * xa ^ (k + s))\n                      \\<partial>lborel)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     ennreal\n                      (- ln x * x ^ (k + r) / real (k + s + 1) +\n                       x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"\\<dots> = (\\<integral>\\<^sup>+x\\<in>{0<..<1}. (ennreal (-ln x * x^(k+r) / (k+s+1)) +\n                       ennreal (x^(k+r)/(k+s+1)^2)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       ennreal\n                        (- ln x * x ^ (k + r) / real (k + s + 1) +\n                         x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       (ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n                        ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)))\n    \\<partial>lborel", "by (intro set_nn_integral_cong refl, subst ennreal_plus)\n         (auto simp: mult_nonpos_nonneg divide_nonpos_nonneg)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     ennreal\n                      (- ln x * x ^ (k + r) / real (k + s + 1) +\n                       x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     (ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n                      ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     ennreal\n                      (- ln x * x ^ (k + r) / real (k + s + 1) +\n                       x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     (ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n                      ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"\\<dots> = (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (-ln x * x^(k+r) / (k+s+1)) \\<partial>lborel) +\n                    (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x^(k+r)/(k+s+1)^2) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       (ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n                        ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)))\n    \\<partial>lborel =\n    (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                        ennreal (- ln x * x ^ (k + r) / real (k + s + 1))\n     \\<partial>lborel) +\n    (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                        ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n     \\<partial>lborel)", "by (subst nn_integral_add [symmetric]) (auto intro!: nn_integral_cong simp: indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     (ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n                      ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)))\n  \\<partial>lborel =\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                      ennreal (- ln x * x ^ (k + r) / real (k + s + 1))\n   \\<partial>lborel) +\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                      ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     (ennreal (- ln x * x ^ (k + r) / real (k + s + 1)) +\n                      ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2)))\n  \\<partial>lborel =\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                      ennreal (- ln x * x ^ (k + r) / real (k + s + 1))\n   \\<partial>lborel) +\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                      ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"(\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (-ln x * x^(k+r) / (k+s+1)) \\<partial>lborel) =\n                  ennreal (1 / (k+s+1)) * (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (-ln x * x^(k+r)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       ennreal (- ln x * x ^ (k + r) / real (k + s + 1))\n    \\<partial>lborel =\n    ennreal (1 / real (k + s + 1)) *\n    (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + r))\n     \\<partial>lborel)", "by (subst nn_integral_cmult [symmetric])\n         (auto intro!: nn_integral_cong simp: indicator_def simp flip: ennreal_mult')"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     ennreal (- ln x * x ^ (k + r) / real (k + s + 1))\n  \\<partial>lborel =\n  ennreal (1 / real (k + s + 1)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + r))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     ennreal (- ln x * x ^ (k + r) / real (k + s + 1))\n  \\<partial>lborel =\n  ennreal (1 / real (k + s + 1)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + r))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"\\<dots> = ennreal (1 / ((k+s+1) * (k+r+1)^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 / real (k + s + 1)) *\n    (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + r))\n     \\<partial>lborel) =\n    ennreal (1 / real ((k + s + 1) * (k + r + 1)\\<^sup>2))", "by (subst nn_integral_0_1_ln_times_power, subst ennreal_mult [symmetric]) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  ennreal (1 / real (k + s + 1)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + r))\n   \\<partial>lborel) =\n  ennreal (1 / real ((k + s + 1) * (k + r + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  ennreal (1 / real (k + s + 1)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (- ln x * x ^ (k + r))\n   \\<partial>lborel) =\n  ennreal (1 / real ((k + s + 1) * (k + r + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"(\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x^(k+r)/(k+s+1)^2) \\<partial>lborel) =\n                  ennreal (1/(k+s+1)^2) * (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x^(k+r)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                       ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n    \\<partial>lborel =\n    ennreal (1 / real ((k + s + 1)\\<^sup>2)) *\n    (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + r))\n     \\<partial>lborel)", "by (subst nn_integral_cmult [symmetric])\n         (auto intro!: nn_integral_cong simp: indicator_def simp flip: ennreal_mult')"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n  \\<partial>lborel =\n  ennreal (1 / real ((k + s + 1)\\<^sup>2)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + r))\\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1}.\n                     ennreal (x ^ (k + r) / real ((k + s + 1)\\<^sup>2))\n  \\<partial>lborel =\n  ennreal (1 / real ((k + s + 1)\\<^sup>2)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + r))\\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"\\<dots> = ennreal (1/((k+r+1)*(k+s+1)^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 / real ((k + s + 1)\\<^sup>2)) *\n    (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + r))\n     \\<partial>lborel) =\n    ennreal (1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))", "by (subst nn_integral_0_1_power, subst ennreal_mult [symmetric]) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  ennreal (1 / real ((k + s + 1)\\<^sup>2)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + r))\n   \\<partial>lborel) =\n  ennreal (1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  ennreal (1 / real ((k + s + 1)\\<^sup>2)) *\n  (\\<integral>\\<^sup>+x\\<in>{0<..<1}. ennreal (x ^ (k + r))\n   \\<partial>lborel) =\n  ennreal (1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "have \"ennreal (1 / ((k+s+1) * (k+r+1)^2)) + \\<dots> =\n                 ennreal (1/((k+r+1)^2*(k+s+1)) + 1/((k+r+1)*(k+s+1)^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 / real ((k + s + 1) * (k + r + 1)\\<^sup>2)) +\n    ennreal (1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)) =\n    ennreal\n     (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n      1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))", "by (subst ennreal_plus [symmetric]) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  ennreal (1 / real ((k + s + 1) * (k + r + 1)\\<^sup>2)) +\n  ennreal (1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)) =\n  ennreal\n   (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n    1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                          (case x of\n                           (x, y) \\<Rightarrow>\n                             ennreal\n                              (- ln (x * y) * x ^ (n + r) * y ^ (n + s)))\n       \\<partial>lborel =\n       ennreal\n        (1 / real ((n + r + 1)\\<^sup>2 * (n + s + 1)) +\n         1 / real ((n + r + 1) * (n + s + 1)\\<^sup>2))", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel =\n  ennreal\n   (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n    1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))", "show \"(\\<integral>\\<^sup>+(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. ennreal (-ln (x*y) * x^(k+r) * y^(k+s)) \\<partial>lborel) = \\<dots>\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel =\n  ennreal\n   (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n    1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal\n                           (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n    \\<partial>lborel =\n    ennreal\n     (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n      1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n  \\<partial>lborel =\n  ennreal\n   (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n    1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k.\n      \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            ennreal\n                             (- ln (x * y) * x ^ (k + r) * y ^ (k + s)))\n      \\<partial>lborel) =\n  (\\<Sum>k.\n      ennreal\n       (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n        1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "finally"], ["proof (chain)\npicking this:\n  beukers_nn_integral1 r s =\n  (\\<Sum>k.\n      ennreal\n       (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n        1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  beukers_nn_integral1 r s =\n  (\\<Sum>k.\n      ennreal\n       (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n        1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))", "."], ["proof (state)\nthis:\n  beukers_nn_integral1 r s =\n  (\\<Sum>k.\n      ennreal\n       (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n        1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Remembering that $\\zeta(3) = \\sum k^{-3}$, it is easy to see that if $r = s$, this sum is simply\n    \\[2\\left(\\zeta(3) - \\sum_{k=1}^r \\frac{1}{k^3}\\right)\\ .\\]\n\\<close>"], ["", "lemma beukers_nn_integral1_same:\n  assumes \"r = s\"\n  shows   \"beukers_nn_integral1 r s = ennreal (2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3)))\"\n    and   \"2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))) &&&\n    0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n 2. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "from assms"], ["proof (chain)\npicking this:\n  r = s", "have [simp]: \"s = r\""], ["proof (prove)\nusing this:\n  r = s\n\ngoal (1 subgoal):\n 1. s = r", "by simp"], ["proof (state)\nthis:\n  s = r\n\ngoal (2 subgoals):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n 2. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "have *: \"Suc 2 = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 2 = 3", "by simp"], ["proof (state)\nthis:\n  Suc 2 = 3\n\ngoal (2 subgoals):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n 2. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "have \"beukers_nn_integral1 r s = (\\<Sum>k. ennreal (2 / (r + k + 1) ^ 3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    (\\<Sum>k. ennreal (2 / real ((r + k + 1) ^ 3)))", "unfolding beukers_nn_integral1_series"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))) =\n    (\\<Sum>k. ennreal (2 / real ((r + k + 1) ^ 3)))", "by (simp only: assms power_Suc [symmetric] mult.commute[of \"x ^ 2\" for x] *\n                   times_divide_eq_right mult_1_right add_ac flip: mult_2)"], ["proof (state)\nthis:\n  beukers_nn_integral1 r s = (\\<Sum>k. ennreal (2 / real ((r + k + 1) ^ 3)))\n\ngoal (2 subgoals):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n 2. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "also"], ["proof (state)\nthis:\n  beukers_nn_integral1 r s = (\\<Sum>k. ennreal (2 / real ((r + k + 1) ^ 3)))\n\ngoal (2 subgoals):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n 2. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "have **: \"(\\<lambda>k. 2 / (r + k + 1) ^ 3) sums\n              (2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 2 / real ((r + k + 1) ^ 3)) sums\n    (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))", "using sums_mult[OF sums_Re_zeta_of_nat_offset[of 3], of 2]"], ["proof (prove)\nusing this:\n  1 < 3 \\<Longrightarrow>\n  (\\<lambda>n. 2 * (1 / real ((?r1 + n + 1) ^ 3))) sums\n  (2 * (Re (zeta (of_nat 3)) - (\\<Sum>k = 1..?r1. 1 / real (k ^ 3))))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 2 / real ((r + k + 1) ^ 3)) sums\n    (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>k. 2 / real ((r + k + 1) ^ 3)) sums\n  (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n\ngoal (2 subgoals):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n 2. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "hence \"(\\<Sum>k. ennreal (2 / (r + k + 1) ^ 3)) = ennreal \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. 2 / real ((r + k + 1) ^ 3)) sums\n  (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k. ennreal (2 / real ((r + k + 1) ^ 3))) =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))", "by (intro suminf_ennreal_eq) auto"], ["proof (state)\nthis:\n  (\\<Sum>k. ennreal (2 / real ((r + k + 1) ^ 3))) =\n  ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n\ngoal (2 subgoals):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n 2. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "finally"], ["proof (chain)\npicking this:\n  beukers_nn_integral1 r s =\n  ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))", "show \"beukers_nn_integral1 r s = ennreal (2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3)))\""], ["proof (prove)\nusing this:\n  beukers_nn_integral1 r s =\n  ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))", "."], ["proof (state)\nthis:\n  beukers_nn_integral1 r s =\n  ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n\ngoal (1 subgoal):\n 1. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "show \"2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "by (rule sums_le[OF _ sums_zero **]) auto"], ["proof (state)\nthis:\n  0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beukers_integral1_same:\n  assumes \"r = s\"\n  shows   \"beukers_integral1 r s = 2 * (Re (zeta 3) - (\\<Sum>k=1..r. 1 / k ^ 3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "have \"ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0\" if \"a \\<in> {0<..<1}\" \"b \\<in> {0<..<1}\" for a b :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0", "using that mult_strict_mono[of a 1 b 1]"], ["proof (prove)\nusing this:\n  a \\<in> {0<..<1}\n  b \\<in> {0<..<1}\n  \\<lbrakk>a < 1; b < 1; 0 < 1; 0 \\<le> b\\<rbrakk>\n  \\<Longrightarrow> a * b < 1 * 1\n\ngoal (1 subgoal):\n 1. ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0", "by (intro mult_nonpos_nonneg divide_nonpos_nonneg) auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "using beukers_nn_integral1_same[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n  beukers_nn_integral1 r s =\n  ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n  0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))\n\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "unfolding beukers_nn_integral1_def beukers_integral1_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal\n                         (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n  \\<partial>lborel =\n  ennreal (2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3))))\n  0 \\<le> 2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):{0<..<1} \\<times> {0<..<1}.\n       - ln (x * y) / (1 - x * y) * x ^ r * y ^ s =\n    2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))", "by (intro set_integral_eq_nn_integral AE_I2)\n       (auto simp flip: lborel_prod simp: case_prod_unfold set_borel_measurable_def\n             intro: divide_nonpos_nonneg mult_nonpos_nonneg)"], ["proof (state)\nthis:\n  beukers_integral1 r s =\n  2 * (Re (zeta 3) - (\\<Sum>k = 1..r. 1 / real (k ^ 3)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  In contrast, for \\<open>r > s\\<close>, we find that\n    \\[I_1 = \\frac{1}{r-s} \\sum_{k=s+1}^r \\frac{1}{k^2}\\ .\\]\n\\<close>"], ["", "lemma beukers_nn_integral1_different:\n  assumes \"r > s\"\n  shows   \"beukers_nn_integral1 r s = ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / k ^ 2) / (r - s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "have \"(\\<lambda>k. 1 / (r - s) * (1 / (s + k + 1) ^ 2 - 1 / (r + k + 1) ^ 2))\n          sums (1 / (r - s) * ((Re (zeta (of_nat 2)) - (\\<Sum>k=1..s. 1/k^2)) -\n                               (Re (zeta (of_nat 2)) - (\\<Sum>k=1..r. 1/k^2))))\"\n    (is \"_ sums ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        1 / real (r - s) *\n        (1 / real ((s + k + 1)\\<^sup>2) -\n         1 / real ((r + k + 1)\\<^sup>2))) sums\n    (1 / real (r - s) *\n     (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) -\n      (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)))))", "by (intro sums_mult sums_diff sums_Re_zeta_of_nat_offset) auto"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      1 / real (r - s) *\n      (1 / real ((s + k + 1)\\<^sup>2) -\n       1 / real ((r + k + 1)\\<^sup>2))) sums\n  (1 / real (r - s) *\n   (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) -\n    (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)))))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "also"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      1 / real (r - s) *\n      (1 / real ((s + k + 1)\\<^sup>2) -\n       1 / real ((r + k + 1)\\<^sup>2))) sums\n  (1 / real (r - s) *\n   (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) -\n    (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)))))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "have \"?S = ((\\<Sum>k=1..r. 1/k^2) - (\\<Sum>k=1..s. 1/k^2)) / (r - s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real (r - s) *\n    (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) -\n     (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)))) =\n    ((\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)) -\n     (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2))) /\n    real (r - s)", "by (simp add: algebra_simps diff_divide_distrib)"], ["proof (state)\nthis:\n  1 / real (r - s) *\n  (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) -\n   (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)))) =\n  ((\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)) -\n   (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2))) /\n  real (r - s)\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "also"], ["proof (state)\nthis:\n  1 / real (r - s) *\n  (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) -\n   (Re (zeta (of_nat 2)) - (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)))) =\n  ((\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)) -\n   (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2))) /\n  real (r - s)\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "have \"(\\<Sum>k=1..r. 1/k^2) - (\\<Sum>k=1..s. 1/k^2) = (\\<Sum>k\\<in>{1..r}-{1..s}. 1/k^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)) -\n    (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) =\n    (\\<Sum>k\\<in>{1..r} - {1..s}. 1 / real (k\\<^sup>2))", "using assms"], ["proof (prove)\nusing this:\n  s < r\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)) -\n    (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) =\n    (\\<Sum>k\\<in>{1..r} - {1..s}. 1 / real (k\\<^sup>2))", "by (subst Groups_Big.sum_diff) auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)) -\n  (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) =\n  (\\<Sum>k\\<in>{1..r} - {1..s}. 1 / real (k\\<^sup>2))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..r. 1 / real (k\\<^sup>2)) -\n  (\\<Sum>k = 1..s. 1 / real (k\\<^sup>2)) =\n  (\\<Sum>k\\<in>{1..r} - {1..s}. 1 / real (k\\<^sup>2))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "have \"{1..r} - {1..s} = {s<..r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..r} - {1..s} = {s<..r}", "by auto"], ["proof (state)\nthis:\n  {1..r} - {1..s} = {s<..r}\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "also"], ["proof (state)\nthis:\n  {1..r} - {1..s} = {s<..r}\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "have \"(\\<lambda>k. 1 / (r - s) * (1 / (s + k + 1) ^ 2 - 1 / (r + k + 1) ^ 2)) =\n               (\\<lambda>k. 1 / ((k+r+1) * (k+s+1)^2) + 1 / ((k+r+1)^2 * (k+s+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        1 / real (r - s) *\n        (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2))) =\n    (\\<lambda>k.\n        1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n        1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)))", "proof (intro ext, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       1 / real (r - s) *\n       (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n       1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n       1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))", "case (1 k)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>k.\n       1 / real (r - s) *\n       (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n       1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n       1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))", "define x where \"x = real (k + r + 1)\""], ["proof (state)\nthis:\n  x = real (k + r + 1)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       1 / real (r - s) *\n       (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n       1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n       1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))", "define y where \"y = real (k + s + 1)\""], ["proof (state)\nthis:\n  y = real (k + s + 1)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       1 / real (r - s) *\n       (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n       1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n       1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))", "have [simp]: \"x \\<noteq> 0\" \"y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 &&& y \\<noteq> 0", "by (auto simp: x_def y_def)"], ["proof (state)\nthis:\n  x \\<noteq> 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       1 / real (r - s) *\n       (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n       1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n       1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))", "have \"(x\\<^sup>2 * y + x * y\\<^sup>2) * (real r - real s) = x * y * (x\\<^sup>2 - y\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>2 * y + x * y\\<^sup>2) * (real r - real s) =\n    x * y * (x\\<^sup>2 - y\\<^sup>2)", "by (simp add: algebra_simps power2_eq_square x_def y_def)"], ["proof (state)\nthis:\n  (x\\<^sup>2 * y + x * y\\<^sup>2) * (real r - real s) =\n  x * y * (x\\<^sup>2 - y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       1 / real (r - s) *\n       (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n       1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n       1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))", "hence \"1 / (x*y^2) + 1 / (x^2*y) = 1 / (r - s) * (1 / y^2 - 1 / x^2)\""], ["proof (prove)\nusing this:\n  (x\\<^sup>2 * y + x * y\\<^sup>2) * (real r - real s) =\n  x * y * (x\\<^sup>2 - y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 1 / (x * y\\<^sup>2) + 1 / (x\\<^sup>2 * y) =\n    1 / real (r - s) * (1 / y\\<^sup>2 - 1 / x\\<^sup>2)", "using assms"], ["proof (prove)\nusing this:\n  (x\\<^sup>2 * y + x * y\\<^sup>2) * (real r - real s) =\n  x * y * (x\\<^sup>2 - y\\<^sup>2)\n  s < r\n\ngoal (1 subgoal):\n 1. 1 / (x * y\\<^sup>2) + 1 / (x\\<^sup>2 * y) =\n    1 / real (r - s) * (1 / y\\<^sup>2 - 1 / x\\<^sup>2)", "by (simp add: divide_simps of_nat_diff)"], ["proof (state)\nthis:\n  1 / (x * y\\<^sup>2) + 1 / (x\\<^sup>2 * y) =\n  1 / real (r - s) * (1 / y\\<^sup>2 - 1 / x\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       1 / real (r - s) *\n       (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n       1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n       1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))", "thus ?case"], ["proof (prove)\nusing this:\n  1 / (x * y\\<^sup>2) + 1 / (x\\<^sup>2 * y) =\n  1 / real (r - s) * (1 / y\\<^sup>2 - 1 / x\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 1 / real (r - s) *\n    (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n    1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n    1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))", "by (simp add: x_def y_def algebra_simps)"], ["proof (state)\nthis:\n  1 / real (r - s) *\n  (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2)) =\n  1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n  1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      1 / real (r - s) *\n      (1 / real ((s + k + 1)\\<^sup>2) - 1 / real ((r + k + 1)\\<^sup>2))) =\n  (\\<lambda>k.\n      1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n      1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k.\n      1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n      1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))) sums\n  ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>k.\n      1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n      1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))) sums\n  ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "unfolding beukers_nn_integral1_series"], ["proof (prove)\nusing this:\n  (\\<lambda>k.\n      1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2) +\n      1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1))) sums\n  ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k.\n        ennreal\n         (1 / real ((k + r + 1)\\<^sup>2 * (k + s + 1)) +\n          1 / real ((k + r + 1) * (k + s + 1)\\<^sup>2))) =\n    ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))", "by (intro suminf_ennreal_eq) (auto simp: add_ac)"], ["proof (state)\nthis:\n  beukers_nn_integral1 r s =\n  ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beukers_integral1_different:\n  assumes \"r > s\"\n  shows   \"beukers_integral1 r s = (\\<Sum>k\\<in>{s<..r}. 1 / k ^ 2) / (r - s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    (\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    (\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s)", "have \"ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0\" if \"a \\<in> {0<..<1}\" \"b \\<in> {0<..<1}\" for a b :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0", "using that mult_strict_mono[of a 1 b 1]"], ["proof (prove)\nusing this:\n  a \\<in> {0<..<1}\n  b \\<in> {0<..<1}\n  \\<lbrakk>a < 1; b < 1; 0 < 1; 0 \\<le> b\\<rbrakk>\n  \\<Longrightarrow> a * b < 1 * 1\n\ngoal (1 subgoal):\n 1. ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0", "by (intro mult_nonpos_nonneg divide_nonpos_nonneg) auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    (\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    (\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s)", "using beukers_nn_integral1_different[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n  beukers_nn_integral1 r s =\n  ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))\n\ngoal (1 subgoal):\n 1. beukers_integral1 r s =\n    (\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s)", "unfolding beukers_nn_integral1_def beukers_integral1_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal\n                         (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n  \\<partial>lborel =\n  ennreal ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):{0<..<1} \\<times> {0<..<1}.\n       - ln (x * y) / (1 - x * y) * x ^ r * y ^ s =\n    (\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s)", "by (intro set_integral_eq_nn_integral AE_I2)\n       (auto simp flip: lborel_prod simp: case_prod_unfold set_borel_measurable_def\n             intro: divide_nonpos_nonneg mult_nonpos_nonneg intro!: sum_nonneg divide_nonneg_nonneg)"], ["proof (state)\nthis:\n  beukers_integral1 r s =\n  (\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) / real (r - s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  It is also easy to see that if we exchange \\<open>r\\<close> and \\<open>s\\<close>, nothing changes.\n\\<close>"], ["", "lemma beukers_nn_integral1_swap:\n  \"beukers_nn_integral1 r s = beukers_nn_integral1 s r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s = beukers_nn_integral1 s r", "unfolding beukers_nn_integral1_def lborel_prod [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal\n                           (- ln (x * y) / (1 - x * y) * x ^ r * y ^ s))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal\n                           (- ln (x * y) / (1 - x * y) * x ^ s * y ^ r))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel", "by (subst lborel_pair.nn_integral_swap, simp)\n     (intro nn_integral_cong, auto simp: indicator_def algebra_simps split: if_splits)"], ["", "lemma beukers_nn_integral1_finite: \"beukers_nn_integral1 r s < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s < \\<infinity>", "using beukers_nn_integral1_different[of r s] beukers_nn_integral1_different[of s r]"], ["proof (prove)\nusing this:\n  \\<lbrakk>r \\<le> s; r < s\\<rbrakk>\n  \\<Longrightarrow> beukers_nn_integral1 s r =\n                    ennreal\n                     ((\\<Sum>k\\<in>{r<..s}. 1 / real (k\\<^sup>2)) /\n                      real (s - r))\n  \\<lbrakk>s \\<le> r; s < r\\<rbrakk>\n  \\<Longrightarrow> beukers_nn_integral1 r s =\n                    ennreal\n                     ((\\<Sum>k\\<in>{s<..r}. 1 / real (k\\<^sup>2)) /\n                      real (r - s))\n\ngoal (1 subgoal):\n 1. beukers_nn_integral1 r s < \\<infinity>", "by (cases r s rule: linorder_cases)\n     (simp_all add: beukers_nn_integral1_same beukers_nn_integral1_swap)"], ["", "lemma beukers_integral1_integrable:\n  \"set_integrable lborel ({0<..<1}\\<times>{0<..<1})\n     (\\<lambda>(x,y). (-ln (x*y) / (1 - x*y) * x^r * y^s :: real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)", "proof (intro set_integrableI_nonneg AE_I2; clarify?)"], ["proof (state)\ngoal (3 subgoals):\n 1. set_borel_measurable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> - ln (a * b) / (1 - a * b) * a ^ r * b ^ s\n 3. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (x, y) \\<Rightarrow>\n                           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n    \\<partial>lborel\n    < \\<infinity>", "fix x y :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. set_borel_measurable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> - ln (a * b) / (1 - a * b) * a ^ r * b ^ s\n 3. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (x, y) \\<Rightarrow>\n                           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n    \\<partial>lborel\n    < \\<infinity>", "assume xy: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\""], ["proof (state)\nthis:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (3 subgoals):\n 1. set_borel_measurable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> - ln (a * b) / (1 - a * b) * a ^ r * b ^ s\n 3. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (x, y) \\<Rightarrow>\n                           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n    \\<partial>lborel\n    < \\<infinity>", "have \"0 \\<ge> ln (x * y) / (1 - x * y) * x ^ r * y ^ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (x * y) / (1 - x * y) * x ^ r * y ^ s \\<le> 0", "using mult_strict_mono[of x 1 y 1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. ln (x * y) / (1 - x * y) * x ^ r * y ^ s \\<le> 0", "by (intro mult_nonpos_nonneg divide_nonpos_nonneg) (use xy in auto)"], ["proof (state)\nthis:\n  ln (x * y) / (1 - x * y) * x ^ r * y ^ s \\<le> 0\n\ngoal (3 subgoals):\n 1. set_borel_measurable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; a \\<in> {0<..<1};\n        b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> - ln (a * b) / (1 - a * b) * a ^ r * b ^ s\n 3. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (x, y) \\<Rightarrow>\n                           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n    \\<partial>lborel\n    < \\<infinity>", "thus \"0 \\<le> - ln (x * y) / (1 - x * y) * x ^ r * y ^ s\""], ["proof (prove)\nusing this:\n  ln (x * y) / (1 - x * y) * x ^ r * y ^ s \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> - ln (x * y) / (1 - x * y) * x ^ r * y ^ s", "by simp"], ["proof (state)\nthis:\n  0 \\<le> - ln (x * y) / (1 - x * y) * x ^ r * y ^ s\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n 2. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (x, y) \\<Rightarrow>\n                           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n    \\<partial>lborel\n    < \\<infinity>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n 2. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (x, y) \\<Rightarrow>\n                           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n    \\<partial>lborel\n    < \\<infinity>", "show \"\\<integral>\\<^sup>+x\\<in>{0<..<1}\\<times>{0<..<1}. ennreal (case x of (x, y) \\<Rightarrow>\n           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s) \\<partial>lborel < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (x, y) \\<Rightarrow>\n                           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n    \\<partial>lborel\n    < \\<infinity>", "using beukers_nn_integral1_finite"], ["proof (prove)\nusing this:\n  beukers_nn_integral1 ?r ?s < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (x, y) \\<Rightarrow>\n                           - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n    \\<partial>lborel\n    < \\<infinity>", "by (simp add: beukers_nn_integral1_def case_prod_unfold)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     ennreal\n                      (case x of\n                       (x, y) \\<Rightarrow>\n                         - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)\n  \\<partial>lborel\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. set_borel_measurable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ r * y ^ s)", "qed (simp_all flip: lborel_prod add: set_borel_measurable_def)"], ["", "lemma beukers_integral1_integrable':\n  \"set_integrable lborel ({0<..<1}\\<times>{0<..<1}\\<times>{0<..<1})\n     (\\<lambda>(z,x,y). (x^r * y^s / (1 - (1 - x*y) * z) :: real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). x ^ r * y ^ s / (1 - (1 - x * y) * z))", "proof (intro set_integrableI_nonneg AE_I2; clarify?)"], ["proof (state)\ngoal (3 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). x ^ r * y ^ s / (1 - (1 - x * y) * z))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> aa ^ r * b ^ s / (1 - (1 - aa * b) * a)\n 3. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (z, xa, y) \\<Rightarrow>\n                           xa ^ r * y ^ s / (1 - (1 - xa * y) * z))\n    \\<partial>lborel\n    < \\<infinity>", "fix x y z :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). x ^ r * y ^ s / (1 - (1 - x * y) * z))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> aa ^ r * b ^ s / (1 - (1 - aa * b) * a)\n 3. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (z, xa, y) \\<Rightarrow>\n                           xa ^ r * y ^ s / (1 - (1 - xa * y) * z))\n    \\<partial>lborel\n    < \\<infinity>", "assume xyz: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\" \"z \\<in> {0<..<1}\""], ["proof (state)\nthis:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (3 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). x ^ r * y ^ s / (1 - (1 - x * y) * z))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> aa ^ r * b ^ s / (1 - (1 - aa * b) * a)\n 3. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (z, xa, y) \\<Rightarrow>\n                           xa ^ r * y ^ s / (1 - (1 - xa * y) * z))\n    \\<partial>lborel\n    < \\<infinity>", "show \"0 \\<le> x^r * y^s / (1 - (1 - x*y) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x ^ r * y ^ s / (1 - (1 - x * y) * z)", "using mult_strict_mono[of x 1 y 1] xyz beukers_denom_ineq[of x y z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; z \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * z < 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> x ^ r * y ^ s / (1 - (1 - x * y) * z)", "by (intro mult_nonneg_nonneg divide_nonneg_nonneg) auto"], ["proof (state)\nthis:\n  0 \\<le> x ^ r * y ^ s / (1 - (1 - x * y) * z)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). x ^ r * y ^ s / (1 - (1 - x * y) * z))\n 2. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (z, xa, y) \\<Rightarrow>\n                           xa ^ r * y ^ s / (1 - (1 - xa * y) * z))\n    \\<partial>lborel\n    < \\<infinity>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). x ^ r * y ^ s / (1 - (1 - x * y) * z))\n 2. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (z, xa, y) \\<Rightarrow>\n                           xa ^ r * y ^ s / (1 - (1 - xa * y) * z))\n    \\<partial>lborel\n    < \\<infinity>", "show \"\\<integral>\\<^sup>+x\\<in>{0<..<1}\\<times>{0<..<1}\\<times>{0<..<1}. ennreal (case x of (z,x,y) \\<Rightarrow>\n           x ^ r * y ^ s / (1-(1-x*y)*z)) \\<partial>lborel < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (z, x, y) \\<Rightarrow>\n                           x ^ r * y ^ s / (1 - (1 - x * y) * z))\n    \\<partial>lborel\n    < \\<infinity>", "using beukers_nn_integral1_finite"], ["proof (prove)\nusing this:\n  beukers_nn_integral1 ?r ?s < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                       ennreal\n                        (case x of\n                         (z, x, y) \\<Rightarrow>\n                           x ^ r * y ^ s / (1 - (1 - x * y) * z))\n    \\<partial>lborel\n    < \\<infinity>", "by (simp add: beukers_nn_integral1_altdef case_prod_unfold)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                     ennreal\n                      (case x of\n                       (z, x, y) \\<Rightarrow>\n                         x ^ r * y ^ s / (1 - (1 - x * y) * z))\n  \\<partial>lborel\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). x ^ r * y ^ s / (1 - (1 - x * y) * z))", "qed (simp_all flip: lborel_prod add: set_borel_measurable_def)"], ["", "lemma beukers_integral1_conv_nn_integral:\n  \"beukers_integral1 r s = enn2real (beukers_nn_integral1 r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_integral1 r s = enn2real (beukers_nn_integral1 r s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. beukers_integral1 r s = enn2real (beukers_nn_integral1 r s)", "have \"ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0\" if \"a \\<in> {0<..<1}\" \"b \\<in> {0<..<1}\"\n    for a b :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0", "using mult_strict_mono[of a 1 b 1] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < 1; b < 1; 0 < 1; 0 \\<le> b\\<rbrakk>\n  \\<Longrightarrow> a * b < 1 * 1\n  a \\<in> {0<..<1}\n  b \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ln (a * b) * a ^ r * b ^ s / (1 - a * b) \\<le> 0", "by (intro divide_nonpos_nonneg mult_nonpos_nonneg) auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n\ngoal (1 subgoal):\n 1. beukers_integral1 r s = enn2real (beukers_nn_integral1 r s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n\ngoal (1 subgoal):\n 1. beukers_integral1 r s = enn2real (beukers_nn_integral1 r s)", "unfolding beukers_integral1_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n\ngoal (1 subgoal):\n 1. LBINT (x, y):{0<..<1} \\<times> {0<..<1}.\n       - ln (x * y) / (1 - x * y) * x ^ r * y ^ s =\n    enn2real (beukers_nn_integral1 r s)", "using beukers_nn_integral1_finite[of r s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0<..<1}; ?b \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ln (?a * ?b) * ?a ^ r * ?b ^ s / (1 - ?a * ?b) \\<le> 0\n  beukers_nn_integral1 r s < \\<infinity>\n\ngoal (1 subgoal):\n 1. LBINT (x, y):{0<..<1} \\<times> {0<..<1}.\n       - ln (x * y) / (1 - x * y) * x ^ r * y ^ s =\n    enn2real (beukers_nn_integral1 r s)", "by (intro set_integral_eq_nn_integral)\n       (auto simp: case_prod_unfold beukers_nn_integral1_def\n                   set_borel_measurable_def simp flip: borel_prod\n             intro!: AE_I2 intro: divide_nonpos_nonneg mult_nonpos_nonneg)"], ["proof (state)\nthis:\n  beukers_integral1 r s = enn2real (beukers_nn_integral1 r s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beukers_integral1_swap: \"beukers_integral1 r s = beukers_integral1 s r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beukers_integral1 r s = beukers_integral1 s r", "by (simp add: beukers_integral1_conv_nn_integral beukers_nn_integral1_swap)"], ["", "subsection \\<open>The second double integral\\<close>"], ["", "context\n  fixes n :: nat\n  fixes D :: \"(real \\<times> real) set\" and D' :: \"(real \\<times> real \\<times> real) set\"\n  fixes P :: \"real \\<Rightarrow> real\" and Q :: \"nat \\<Rightarrow> real \\<Rightarrow> real\"\n  defines \"D \\<equiv> {0<..<1} \\<times> {0<..<1}\" and \"D' \\<equiv> {0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}\"\n  defines \"Q \\<equiv> Gen_Shleg n\" and \"P \\<equiv> Shleg n\"\nbegin"], ["", "text \\<open>\n  The next integral to consider is the following variant of $I_1$:\n  \\[I_2 :=\n      \\int_0^1 \\int_0^1 -\\frac{\\ln(xy)}{1-xy} P_n(x) P_n(y)\\,\\text{d}x\\,\\text{d}y\\ .\\]\n\\<close>"], ["", "definition beukers_integral2 :: real where\n  \"beukers_integral2 = (\\<integral>(x,y)\\<in>D. (-ln (x*y) / (1-x*y) * P x * P y) \\<partial>lborel)\""], ["", "text \\<open>\n  $I_2$ is simply a sum of integrals of type $I_1$, so using our results for\n  $I_1$, we can write $I_2$ in the form $A \\zeta(3) + \\frac{B}{\\text{lcm}\\{1\\ldots n\\}^3}$\n  where $A$ and $B$ are integers and $A > 0$:\n\\<close>"], ["", "lemma beukers_integral2_conv_int_combination:\n  obtains A B :: int where \"A > 0\" and\n    \"beukers_integral2 = of_int A * Re (zeta 3) + of_int B / of_nat (Lcm {1..n} ^ 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?I1 = \"(\\<lambda>i. (i, i)) ` {..n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?I2 = \"Set.filter (\\<lambda>(i,j). i \\<noteq> j) ({..n}\\<times>{..n})\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?I3 = \"Set.filter (\\<lambda>(i,j). i < j) ({..n}\\<times>{..n})\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?I4 = \"Set.filter (\\<lambda>(i,j). i > j) ({..n}\\<times>{..n})\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define p where \"p = shleg_poly n\""], ["proof (state)\nthis:\n  p = shleg_poly n\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define I where \"I = (SIGMA i:{..n}. {1..i})\""], ["proof (state)\nthis:\n  I = Sigma {..n} (atLeastAtMost 1)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define J where \"J = (SIGMA (i,j):?I4. {j<..i})\""], ["proof (state)\nthis:\n  J =\n  (SIGMA (i, j):Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n      {j<..i})\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define h where \"h = beukers_integral1\""], ["proof (state)\nthis:\n  h = beukers_integral1\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define A :: int where \"A = (\\<Sum>i\\<le>n. 2 * poly.coeff p i ^ 2)\""], ["proof (state)\nthis:\n  A = (\\<Sum>i\\<le>n. 2 * (poly.coeff p i)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define B1 where \"B1 = (\\<Sum>(i,k)\\<in>I. real_of_int (-2 * coeff p i ^ 2) / real_of_int (k ^ 3))\""], ["proof (state)\nthis:\n  B1 =\n  (\\<Sum>(i, k)\\<in>I.\n     real_of_int (- 2 * (poly.coeff p i)\\<^sup>2) /\n     real_of_int (int (k ^ 3)))\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define B2 where \"B2 = (\\<Sum>((i,j),k)\\<in>J. real_of_int (2 * coeff p i * coeff p j) / real_of_int (k^2*(i-j)))\""], ["proof (state)\nthis:\n  B2 =\n  (\\<Sum>((i, j), k)\\<in>J.\n     real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n     real_of_int (int (k\\<^sup>2 * (i - j))))\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define d where \"d = Lcm {1..n} ^ 3\""], ["proof (state)\nthis:\n  d = Lcm {1..n} ^ 3\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \"h i j = h j i\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. h i j = h j i", "by (simp add: h_def beukers_integral1_swap)"], ["proof (state)\nthis:\n  h ?i ?j = h ?j ?i\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"beukers_integral2 =\n        (\\<integral>(x,y)\\<in>D. (\\<Sum>(i,j)\\<in>{..n}\\<times>{..n}. coeff p i * coeff p j *\n           -ln (x*y) / (1-x*y) * x ^ i * y ^ j) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_integral2 =\n    LBINT (x, y):D.\n       (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n          real_of_int (poly.coeff p i * poly.coeff p j) * - ln (x * y) /\n          (1 - x * y) *\n          x ^ i *\n          y ^ j)", "unfolding beukers_integral2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. - ln (x * y) / (1 - x * y) * P x * P y =\n    LBINT (x, y):D.\n       (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n          real_of_int (poly.coeff p i * poly.coeff p j) * - ln (x * y) /\n          (1 - x * y) *\n          x ^ i *\n          y ^ j)", "by (subst sum.cartesian_product [symmetric])\n       (simp add: poly_altdef P_def Shleg_def mult_ac case_prod_unfold p_def\n                  sum_distrib_left sum_distrib_right sum_negf sum_divide_distrib)"], ["proof (state)\nthis:\n  local.beukers_integral2 =\n  LBINT (x, y):D.\n     (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n        real_of_int (poly.coeff p i * poly.coeff p j) * - ln (x * y) /\n        (1 - x * y) *\n        x ^ i *\n        y ^ j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  local.beukers_integral2 =\n  LBINT (x, y):D.\n     (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n        real_of_int (poly.coeff p i * poly.coeff p j) * - ln (x * y) /\n        (1 - x * y) *\n        x ^ i *\n        y ^ j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (\\<Sum>(i,j)\\<in>{..n}\\<times>{..n}. coeff p i * coeff p j * h i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D.\n       (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n          real_of_int (poly.coeff p i * poly.coeff p j) * - ln (x * y) /\n          (1 - x * y) *\n          x ^ i *\n          y ^ j) =\n    (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j)", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT pa:D.\n       (\\<Sum>pb\\<in>{..n} \\<times> {..n}.\n          real_of_int (poly.coeff p (fst pb) * poly.coeff p (snd pb)) *\n          - ln (fst pa * snd pa) /\n          (1 - fst pa * snd pa) *\n          fst pa ^ fst pb *\n          snd pa ^ snd pb) =\n    (\\<Sum>pa\\<in>{..n} \\<times> {..n}.\n       real_of_int (poly.coeff p (fst pa) * poly.coeff p (snd pa)) *\n       h (fst pa) (snd pa))", "proof (subst set_integral_sum)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ({..n} \\<times> {..n})\n 2. \\<And>x.\n       x \\<in> {..n} \\<times> {..n} \\<Longrightarrow>\n       set_integrable lborel D\n        (\\<lambda>pa.\n            real_of_int (poly.coeff p (fst x) * poly.coeff p (snd x)) *\n            - ln (fst pa * snd pa) /\n            (1 - fst pa * snd pa) *\n            fst pa ^ fst x *\n            snd pa ^ snd x)\n 3. (\\<Sum>x\\<in>{..n} \\<times> {..n}.\n       LBINT pa:D.\n          real_of_int (poly.coeff p (fst x) * poly.coeff p (snd x)) *\n          - ln (fst pa * snd pa) /\n          (1 - fst pa * snd pa) *\n          fst pa ^ fst x *\n          snd pa ^ snd x) =\n    (\\<Sum>pa\\<in>{..n} \\<times> {..n}.\n       real_of_int (poly.coeff p (fst pa) * poly.coeff p (snd pa)) *\n       h (fst pa) (snd pa))", "fix ij :: \"nat \\<times> nat\""], ["proof (state)\ngoal (3 subgoals):\n 1. finite ({..n} \\<times> {..n})\n 2. \\<And>x.\n       x \\<in> {..n} \\<times> {..n} \\<Longrightarrow>\n       set_integrable lborel D\n        (\\<lambda>pa.\n            real_of_int (poly.coeff p (fst x) * poly.coeff p (snd x)) *\n            - ln (fst pa * snd pa) /\n            (1 - fst pa * snd pa) *\n            fst pa ^ fst x *\n            snd pa ^ snd x)\n 3. (\\<Sum>x\\<in>{..n} \\<times> {..n}.\n       LBINT pa:D.\n          real_of_int (poly.coeff p (fst x) * poly.coeff p (snd x)) *\n          - ln (fst pa * snd pa) /\n          (1 - fst pa * snd pa) *\n          fst pa ^ fst x *\n          snd pa ^ snd x) =\n    (\\<Sum>pa\\<in>{..n} \\<times> {..n}.\n       real_of_int (poly.coeff p (fst pa) * poly.coeff p (snd pa)) *\n       h (fst pa) (snd pa))", "have \"set_integrable lborel D\n          (\\<lambda>(x,y). real_of_int (coeff p (fst ij) * coeff p (snd ij)) *\n                 (-ln (x*y) / (1-x*y) * x ^ fst ij * y ^ snd ij))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y).\n         real_of_int (poly.coeff p (fst ij) * poly.coeff p (snd ij)) *\n         (- ln (x * y) / (1 - x * y) * x ^ fst ij * y ^ snd ij))", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>pa.\n         real_of_int (poly.coeff p (fst ij) * poly.coeff p (snd ij)) *\n         (- ln (fst pa * snd pa) / (1 - fst pa * snd pa) * fst pa ^ fst ij *\n          snd pa ^ snd ij))", "using beukers_integral1_integrable[of \"fst ij\" \"snd ij\"]"], ["proof (prove)\nusing this:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n   (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ fst ij * y ^ snd ij)\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>pa.\n         real_of_int (poly.coeff p (fst ij) * poly.coeff p (snd ij)) *\n         (- ln (fst pa * snd pa) / (1 - fst pa * snd pa) * fst pa ^ fst ij *\n          snd pa ^ snd ij))", "by (intro set_integrable_mult_right) (auto simp: D_def case_prod_unfold)"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>(x, y).\n       real_of_int (poly.coeff p (fst ij) * poly.coeff p (snd ij)) *\n       (- ln (x * y) / (1 - x * y) * x ^ fst ij * y ^ snd ij))\n\ngoal (3 subgoals):\n 1. finite ({..n} \\<times> {..n})\n 2. \\<And>x.\n       x \\<in> {..n} \\<times> {..n} \\<Longrightarrow>\n       set_integrable lborel D\n        (\\<lambda>pa.\n            real_of_int (poly.coeff p (fst x) * poly.coeff p (snd x)) *\n            - ln (fst pa * snd pa) /\n            (1 - fst pa * snd pa) *\n            fst pa ^ fst x *\n            snd pa ^ snd x)\n 3. (\\<Sum>x\\<in>{..n} \\<times> {..n}.\n       LBINT pa:D.\n          real_of_int (poly.coeff p (fst x) * poly.coeff p (snd x)) *\n          - ln (fst pa * snd pa) /\n          (1 - fst pa * snd pa) *\n          fst pa ^ fst x *\n          snd pa ^ snd x) =\n    (\\<Sum>pa\\<in>{..n} \\<times> {..n}.\n       real_of_int (poly.coeff p (fst pa) * poly.coeff p (snd pa)) *\n       h (fst pa) (snd pa))", "thus \"set_integrable lborel D\n          (\\<lambda>pa. real_of_int (coeff p (fst ij) * coeff p (snd ij)) *\n                 -ln (fst pa * snd pa) / (1 - fst pa * snd pa) * fst pa ^ fst ij * snd pa ^ snd ij)\""], ["proof (prove)\nusing this:\n  set_integrable lborel D\n   (\\<lambda>(x, y).\n       real_of_int (poly.coeff p (fst ij) * poly.coeff p (snd ij)) *\n       (- ln (x * y) / (1 - x * y) * x ^ fst ij * y ^ snd ij))\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>pa.\n         real_of_int (poly.coeff p (fst ij) * poly.coeff p (snd ij)) *\n         - ln (fst pa * snd pa) /\n         (1 - fst pa * snd pa) *\n         fst pa ^ fst ij *\n         snd pa ^ snd ij)", "by (simp add: mult_ac case_prod_unfold)"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>pa.\n       real_of_int (poly.coeff p (fst ij) * poly.coeff p (snd ij)) *\n       - ln (fst pa * snd pa) /\n       (1 - fst pa * snd pa) *\n       fst pa ^ fst ij *\n       snd pa ^ snd ij)\n\ngoal (2 subgoals):\n 1. finite ({..n} \\<times> {..n})\n 2. (\\<Sum>x\\<in>{..n} \\<times> {..n}.\n       LBINT pa:D.\n          real_of_int (poly.coeff p (fst x) * poly.coeff p (snd x)) *\n          - ln (fst pa * snd pa) /\n          (1 - fst pa * snd pa) *\n          fst pa ^ fst x *\n          snd pa ^ snd x) =\n    (\\<Sum>pa\\<in>{..n} \\<times> {..n}.\n       real_of_int (poly.coeff p (fst pa) * poly.coeff p (snd pa)) *\n       h (fst pa) (snd pa))", "qed (auto simp: beukers_integral1_def h_def case_prod_unfold mult.assoc D_def\n            simp flip: set_integral_mult_right)"], ["proof (state)\nthis:\n  LBINT (x, y):D.\n     (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n        real_of_int (poly.coeff p i * poly.coeff p j) * - ln (x * y) /\n        (1 - x * y) *\n        x ^ i *\n        y ^ j) =\n  (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  LBINT (x, y):D.\n     (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n        real_of_int (poly.coeff p i * poly.coeff p j) * - ln (x * y) /\n        (1 - x * y) *\n        x ^ i *\n        y ^ j) =\n  (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (\\<Sum>(i,j)\\<in>?I1\\<union>?I2. coeff p i * coeff p j * h i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n    (\\<Sum>(i, j)\n           \\<in>(\\<lambda>i. (i, i)) ` {..n} \\<union>\n                Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n                 ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j)", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>(\\<lambda>i. (i, i)) ` {..n} \\<union>\n              Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n               ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>{..n} \\<times> {..n}.\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>(\\<lambda>i. (i, i)) ` {..n} \\<union>\n              Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n               ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (\\<Sum>(i,j)\\<in>?I1. coeff p i * coeff p j * h i j) +\n                  (\\<Sum>(i,j)\\<in>?I2. coeff p i * coeff p j * h i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\n           \\<in>(\\<lambda>i. (i, i)) ` {..n} \\<union>\n                Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n                 ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n    (\\<Sum>(i, j)\\<in>(\\<lambda>i. (i, i)) ` {..n}.\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n                 ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j)", "by (intro sum.union_disjoint) auto"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>(\\<lambda>i. (i, i)) ` {..n} \\<union>\n              Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n               ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\\<in>(\\<lambda>i. (i, i)) ` {..n}.\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n               ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>(\\<lambda>i. (i, i)) ` {..n} \\<union>\n              Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n               ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\\<in>(\\<lambda>i. (i, i)) ` {..n}.\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n               ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<Sum>(i,j)\\<in>?I1. coeff p i * coeff p j * h i j) =\n               (\\<Sum>i\\<le>n. coeff p i ^ 2 * h i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\\<in>(\\<lambda>i. (i, i)) ` {..n}.\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n    (\\<Sum>i\\<le>n. real_of_int ((poly.coeff p i)\\<^sup>2) * h i i)", "by (subst sum.reindex) (auto intro: inj_onI simp: case_prod_unfold power2_eq_square)"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>(\\<lambda>i. (i, i)) ` {..n}.\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>i\\<le>n. real_of_int ((poly.coeff p i)\\<^sup>2) * h i i)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\\<in>(\\<lambda>i. (i, i)) ` {..n}.\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>i\\<le>n. real_of_int ((poly.coeff p i)\\<^sup>2) * h i i)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (\\<Sum>i\\<le>n. coeff p i ^ 2 * 2 * (Re (zeta 3) - (\\<Sum>k=1..i. 1 / k ^ 3)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. real_of_int ((poly.coeff p i)\\<^sup>2) * h i i) =\n    (\\<Sum>i\\<le>n.\n        real_of_int ((poly.coeff p i)\\<^sup>2 * 2) *\n        (Re (zeta 3) - (\\<Sum>k = 1..i. 1 / real (k ^ 3))))", "unfolding h_def D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        real_of_int ((poly.coeff p i)\\<^sup>2) * beukers_integral1 i i) =\n    (\\<Sum>i\\<le>n.\n        real_of_int ((poly.coeff p i)\\<^sup>2 * 2) *\n        (Re (zeta 3) - (\\<Sum>k = 1..i. 1 / real (k ^ 3))))", "by (intro sum.cong refl, subst beukers_integral1_same) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. real_of_int ((poly.coeff p i)\\<^sup>2) * h i i) =\n  (\\<Sum>i\\<le>n.\n      real_of_int ((poly.coeff p i)\\<^sup>2 * 2) *\n      (Re (zeta 3) - (\\<Sum>k = 1..i. 1 / real (k ^ 3))))\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. real_of_int ((poly.coeff p i)\\<^sup>2) * h i i) =\n  (\\<Sum>i\\<le>n.\n      real_of_int ((poly.coeff p i)\\<^sup>2 * 2) *\n      (Re (zeta 3) - (\\<Sum>k = 1..i. 1 / real (k ^ 3))))\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = of_int A * Re (zeta 3) -\n                    (\\<Sum>i\\<le>n. 2 * coeff p i ^ 2 * (\\<Sum>k=1..i. 1 / k ^ 3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        real_of_int ((poly.coeff p i)\\<^sup>2 * 2) *\n        (Re (zeta 3) - (\\<Sum>k = 1..i. 1 / real (k ^ 3)))) =\n    real_of_int A * Re (zeta 3) -\n    (\\<Sum>i\\<le>n.\n        real_of_int (2 * (poly.coeff p i)\\<^sup>2) *\n        (\\<Sum>k = 1..i. 1 / real (k ^ 3)))", "by (simp add: sum_subtractf sum_distrib_left sum_distrib_right algebra_simps A_def)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      real_of_int ((poly.coeff p i)\\<^sup>2 * 2) *\n      (Re (zeta 3) - (\\<Sum>k = 1..i. 1 / real (k ^ 3)))) =\n  real_of_int A * Re (zeta 3) -\n  (\\<Sum>i\\<le>n.\n      real_of_int (2 * (poly.coeff p i)\\<^sup>2) *\n      (\\<Sum>k = 1..i. 1 / real (k ^ 3)))\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      real_of_int ((poly.coeff p i)\\<^sup>2 * 2) *\n      (Re (zeta 3) - (\\<Sum>k = 1..i. 1 / real (k ^ 3)))) =\n  real_of_int A * Re (zeta 3) -\n  (\\<Sum>i\\<le>n.\n      real_of_int (2 * (poly.coeff p i)\\<^sup>2) *\n      (\\<Sum>k = 1..i. 1 / real (k ^ 3)))\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = of_int A * Re (zeta 3) + B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int A * Re (zeta 3) -\n    (\\<Sum>i\\<le>n.\n        real_of_int (2 * (poly.coeff p i)\\<^sup>2) *\n        (\\<Sum>k = 1..i. 1 / real (k ^ 3))) =\n    real_of_int A * Re (zeta 3) + B1", "unfolding I_def B1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int A * Re (zeta 3) -\n    (\\<Sum>i\\<le>n.\n        real_of_int (2 * (poly.coeff p i)\\<^sup>2) *\n        (\\<Sum>k = 1..i. 1 / real (k ^ 3))) =\n    real_of_int A * Re (zeta 3) +\n    (\\<Sum>(i, k)\\<in>Sigma {..n} (atLeastAtMost 1).\n       real_of_int (- 2 * (poly.coeff p i)\\<^sup>2) /\n       real_of_int (int (k ^ 3)))", "by (subst sum.Sigma [symmetric]) (auto simp: sum_distrib_left sum_negf)"], ["proof (state)\nthis:\n  real_of_int A * Re (zeta 3) -\n  (\\<Sum>i\\<le>n.\n      real_of_int (2 * (poly.coeff p i)\\<^sup>2) *\n      (\\<Sum>k = 1..i. 1 / real (k ^ 3))) =\n  real_of_int A * Re (zeta 3) + B1\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  real_of_int A * Re (zeta 3) -\n  (\\<Sum>i\\<le>n.\n      real_of_int (2 * (poly.coeff p i)\\<^sup>2) *\n      (\\<Sum>k = 1..i. 1 / real (k ^ 3))) =\n  real_of_int A * Re (zeta 3) + B1\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<Sum>(i,j)\\<in>?I2. coeff p i * coeff p j * h i j) =\n               (\\<Sum>(i,j)\\<in>?I3\\<union>?I4. coeff p i * coeff p j * h i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n                 ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). i < j)\n                 ({..n} \\<times> {..n}) \\<union>\n                Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j)", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n               ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i < j)\n               ({..n} \\<times> {..n}) \\<union>\n              Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i \\<noteq> j)\n               ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i < j)\n               ({..n} \\<times> {..n}) \\<union>\n              Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (\\<Sum>(i,j)\\<in>?I3. coeff p i * coeff p j * h i j) +\n                  (\\<Sum>(i,j)\\<in>?I4. coeff p i * coeff p j * h i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). i < j)\n                 ({..n} \\<times> {..n}) \\<union>\n                Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). i < j) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j)", "by (intro sum.union_disjoint) auto"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i < j)\n               ({..n} \\<times> {..n}) \\<union>\n              Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i < j) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i < j)\n               ({..n} \\<times> {..n}) \\<union>\n              Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i < j) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<Sum>(i,j)\\<in>?I3. coeff p i * coeff p j * h i j) =\n               (\\<Sum>(i,j)\\<in>?I4. coeff p i * coeff p j * h i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). i < j) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j)", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>(i,j). (j,i)\" \"\\<lambda>(i,j). (j,i)\"]) auto"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i < j) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). i < j) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> + \\<dots> = 2 * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n    2 *\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  2 *\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) +\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  2 *\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (\\<Sum>(i,j)\\<in>?I4. \\<Sum>k\\<in>{j<..i}. 2 * coeff p i * coeff p j / k ^ 2 / (i - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       \\<Sum>k\\<in>{j<..i}.\n         real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n         real (k\\<^sup>2) /\n         real (i - j))", "unfolding sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       2 *\n       (case n of\n        (i, j) \\<Rightarrow>\n          real_of_int (poly.coeff p i * poly.coeff p j) * h i j)) =\n    (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       \\<Sum>k\\<in>{j<..i}.\n         real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n         real (k\\<^sup>2) /\n         real (i - j))", "by (intro sum.cong refl)\n       (auto simp: h_def beukers_integral1_different sum_divide_distrib sum_distrib_left mult_ac)"], ["proof (state)\nthis:\n  2 *\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     \\<Sum>k\\<in>{j<..i}.\n       real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n       real (k\\<^sup>2) /\n       real (i - j))\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  2 *\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     real_of_int (poly.coeff p i * poly.coeff p j) * h i j) =\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     \\<Sum>k\\<in>{j<..i}.\n       real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n       real (k\\<^sup>2) /\n       real (i - j))\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       \\<Sum>k\\<in>{j<..i}.\n         real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n         real (k\\<^sup>2) /\n         real (i - j)) =\n    B2", "unfolding J_def B2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, j)\n           \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n       \\<Sum>k\\<in>{j<..i}.\n         real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n         real (k\\<^sup>2) /\n         real (i - j)) =\n    (\\<Sum>((i, j), k)\n           \\<in>(SIGMA (i,\n                    j):Set.filter (\\<lambda>(i, j). j < i)\n                        ({..n} \\<times> {..n}).\n                    {j<..i}).\n       real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n       real_of_int (int (k\\<^sup>2 * (i - j))))", "by (subst sum.Sigma [symmetric]) (auto simp: case_prod_unfold)"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     \\<Sum>k\\<in>{j<..i}.\n       real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n       real (k\\<^sup>2) /\n       real (i - j)) =\n  B2\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, j)\n         \\<in>Set.filter (\\<lambda>(i, j). j < i) ({..n} \\<times> {..n}).\n     \\<Sum>k\\<in>{j<..i}.\n       real_of_int (2 * poly.coeff p i * poly.coeff p j) /\n       real (k\\<^sup>2) /\n       real (i - j)) =\n  B2\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>B1'. B1 = real_of_int B1' / real_of_int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B1'. B1 = real_of_int B1' / real_of_int (int d)", "unfolding B1_def case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B1'.\n       (\\<Sum>pa\\<in>I.\n          real_of_int (- 2 * (poly.coeff p (fst pa))\\<^sup>2) /\n          real_of_int (int (snd pa ^ 3))) =\n       real_of_int B1' / real_of_int (int d)", "by (rule sum_rationals_common_divisor') (auto simp: d_def I_def)"], ["proof (state)\nthis:\n  \\<exists>B1'. B1 = real_of_int B1' / real_of_int (int d)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>B1'. B1 = real_of_int B1' / real_of_int (int d)", "obtain B1' where \"B1 = real_of_int B1' / real_of_int d\""], ["proof (prove)\nusing this:\n  \\<exists>B1'. B1 = real_of_int B1' / real_of_int (int d)\n\ngoal (1 subgoal):\n 1. (\\<And>B1'.\n        B1 = real_of_int B1' / real_of_int (int d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  B1 = real_of_int B1' / real_of_int (int d)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  B1 = real_of_int B1' / real_of_int (int d)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>B2'. B2 = real_of_int B2' / real_of_int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B2'. B2 = real_of_int B2' / real_of_int (int d)", "unfolding B2_def case_prod_unfold J_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B2'.\n       (\\<Sum>pa\\<in>(SIGMA p:Set.filter (\\<lambda>p. snd p < fst p)\n                               ({..n} \\<times> {..n}).\n                         {snd p<..fst p}).\n          real_of_int\n           (2 * poly.coeff p (fst (fst pa)) * poly.coeff p (snd (fst pa))) /\n          real_of_int\n           (int ((snd pa)\\<^sup>2 * (fst (fst pa) - snd (fst pa))))) =\n       real_of_int B2' / real_of_int (int d)", "proof (rule sum_rationals_common_divisor'; clarsimp?)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>a \\<le> n; b < ba; ba \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (int ba)\\<^sup>2 * int (a - b) dvd int d\n 2. 0 < d", "fix i j k :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>a \\<le> n; b < ba; ba \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (int ba)\\<^sup>2 * int (a - b) dvd int d\n 2. 0 < d", "assume ijk: \"i \\<le> n\" \"j < k\" \"k \\<le> i\""], ["proof (state)\nthis:\n  i \\<le> n\n  j < k\n  k \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>a \\<le> n; b < ba; ba \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (int ba)\\<^sup>2 * int (a - b) dvd int d\n 2. 0 < d", "have \"int (k ^ 2 * (i - j)) dvd int (Lcm {1..n} ^ 2 * Lcm {1..n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (k\\<^sup>2 * (i - j)) dvd int ((Lcm {1..n})\\<^sup>2 * Lcm {1..n})", "unfolding int_dvd_int_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. k\\<^sup>2 * (i - j) dvd (Lcm {1..n})\\<^sup>2 * Lcm {1..n}", "using ijk"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j < k\n  k \\<le> i\n\ngoal (1 subgoal):\n 1. k\\<^sup>2 * (i - j) dvd (Lcm {1..n})\\<^sup>2 * Lcm {1..n}", "by (intro mult_dvd_mono dvd_power_same dvd_Lcm) auto"], ["proof (state)\nthis:\n  int (k\\<^sup>2 * (i - j)) dvd int ((Lcm {1..n})\\<^sup>2 * Lcm {1..n})\n\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>a \\<le> n; b < ba; ba \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (int ba)\\<^sup>2 * int (a - b) dvd int d\n 2. 0 < d", "also"], ["proof (state)\nthis:\n  int (k\\<^sup>2 * (i - j)) dvd int ((Lcm {1..n})\\<^sup>2 * Lcm {1..n})\n\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>a \\<le> n; b < ba; ba \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (int ba)\\<^sup>2 * int (a - b) dvd int d\n 2. 0 < d", "have \"\\<dots> = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((Lcm {1..n})\\<^sup>2 * Lcm {1..n}) = int d", "by (simp add: d_def power_numeral_reduce)"], ["proof (state)\nthis:\n  int ((Lcm {1..n})\\<^sup>2 * Lcm {1..n}) = int d\n\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>a \\<le> n; b < ba; ba \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (int ba)\\<^sup>2 * int (a - b) dvd int d\n 2. 0 < d", "finally"], ["proof (chain)\npicking this:\n  int (k\\<^sup>2 * (i - j)) dvd int d", "show \"int k ^ 2 * int (i - j) dvd int d\""], ["proof (prove)\nusing this:\n  int (k\\<^sup>2 * (i - j)) dvd int d\n\ngoal (1 subgoal):\n 1. (int k)\\<^sup>2 * int (i - j) dvd int d", "by simp"], ["proof (state)\nthis:\n  (int k)\\<^sup>2 * int (i - j) dvd int d\n\ngoal (1 subgoal):\n 1. 0 < d", "qed(auto simp: d_def J_def intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  \\<exists>B2'. B2 = real_of_int B2' / real_of_int (int d)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>B2'. B2 = real_of_int B2' / real_of_int (int d)", "obtain B2' where \"B2 = real_of_int B2' / real_of_int d\""], ["proof (prove)\nusing this:\n  \\<exists>B2'. B2 = real_of_int B2' / real_of_int (int d)\n\ngoal (1 subgoal):\n 1. (\\<And>B2'.\n        B2 = real_of_int B2' / real_of_int (int d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  B2 = real_of_int B2' / real_of_int (int d)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  local.beukers_integral2 =\n  real_of_int A * Re (zeta 3) + real_of_int B1' / real_of_int (int d) +\n  real_of_int B2' / real_of_int (int d)", "have \"beukers_integral2 =\n                  of_int A * Re (zeta 3) + of_int (B1' + B2') / of_nat (Lcm {1..n} ^ 3)\""], ["proof (prove)\nusing this:\n  local.beukers_integral2 =\n  real_of_int A * Re (zeta 3) + real_of_int B1' / real_of_int (int d) +\n  real_of_int B2' / real_of_int (int d)\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 =\n    real_of_int A * Re (zeta 3) +\n    real_of_int (B1' + B2') / real (Lcm {1..n} ^ 3)", "by (simp add: add_divide_distrib d_def)"], ["proof (state)\nthis:\n  local.beukers_integral2 =\n  real_of_int A * Re (zeta 3) +\n  real_of_int (B1' + B2') / real (Lcm {1..n} ^ 3)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  local.beukers_integral2 =\n  real_of_int A * Re (zeta 3) +\n  real_of_int (B1' + B2') / real (Lcm {1..n} ^ 3)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"coeff p 0 = P 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (poly.coeff p 0) = P 0", "unfolding P_def p_def Shleg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (poly.coeff (shleg_poly n) 0) =\n    poly (of_int_poly (shleg_poly n)) 0", "by (simp add: poly_0_coeff_0)"], ["proof (state)\nthis:\n  real_of_int (poly.coeff p 0) = P 0\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"coeff p 0 = 1\""], ["proof (prove)\nusing this:\n  real_of_int (poly.coeff p 0) = P 0\n\ngoal (1 subgoal):\n 1. poly.coeff p 0 = 1", "by (simp add: P_def)"], ["proof (state)\nthis:\n  poly.coeff p 0 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"A > 0\""], ["proof (prove)\nusing this:\n  poly.coeff p 0 = 1\n\ngoal (1 subgoal):\n 1. 0 < A", "unfolding A_def"], ["proof (prove)\nusing this:\n  poly.coeff p 0 = 1\n\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>i\\<le>n. 2 * (poly.coeff p i)\\<^sup>2)", "by (intro sum_pos2[of _ 0]) auto"], ["proof (state)\nthis:\n  0 < A\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         local.beukers_integral2 =\n         real_of_int A * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  local.beukers_integral2 =\n  real_of_int A * Re (zeta 3) +\n  real_of_int (B1' + B2') / real (Lcm {1..n} ^ 3)\n  0 < A", "show ?thesis"], ["proof (prove)\nusing this:\n  local.beukers_integral2 =\n  real_of_int A * Re (zeta 3) +\n  real_of_int (B1' + B2') / real (Lcm {1..n} ^ 3)\n  0 < A\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of A \"B1' + B2'\"]) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beukers_integral2_integrable:\n  \"set_integrable lborel D (\\<lambda>(x,y). -ln (x*y) / (1 - x*y) * P x * P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)", "have \"bounded (P ` {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (P ` {0..1})", "unfolding P_def Shleg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (poly (of_int_poly (shleg_poly n)) ` {0..1})", "by (intro compact_imp_bounded compact_continuous_image continuous_intros) auto"], ["proof (state)\nthis:\n  bounded (P ` {0..1})\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)", "then"], ["proof (chain)\npicking this:\n  bounded (P ` {0..1})", "obtain C where C: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\""], ["proof (prove)\nusing this:\n  bounded (P ` {0..1})\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> {0..1} \\<Longrightarrow>\n            norm (P x) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding bounded_iff"], ["proof (prove)\nusing this:\n  \\<exists>a. \\<forall>x\\<in>P ` {0..1}. norm x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> {0..1} \\<Longrightarrow>\n            norm (P x) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow> norm (P ?x) \\<le> C\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)", "have [measurable]: \"P \\<in> borel_measurable borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> borel_measurable borel", "by (simp add: P_def)"], ["proof (state)\nthis:\n  P \\<in> borel_measurable borel\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)", "from C[of 0]"], ["proof (chain)\npicking this:\n  0 \\<in> {0..1} \\<Longrightarrow> norm (P 0) \\<le> C", "have \"C \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<in> {0..1} \\<Longrightarrow> norm (P 0) \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> C", "by simp"], ["proof (state)\nthis:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)", "proof (rule set_integrable_bound[OF _ _ AE_I2]; clarify?)"], ["proof (state)\ngoal (3 subgoals):\n 1. set_integrable lborel D ?f1\n 2. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 3. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm (?f1 (a, b))", "show \"set_integrable lborel D (\\<lambda>(x,y). C ^ 2 * (-ln (x*y) / (1 - x*y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "using beukers_integral1_integrable[of 0 0]"], ["proof (prove)\nusing this:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n   (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ 0 * y ^ 0)\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "unfolding case_prod_unfold"], ["proof (prove)\nusing this:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n   (\\<lambda>p.\n       - ln (fst p * snd p) / (1 - fst p * snd p) * fst p ^ 0 * snd p ^ 0)\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>p. C\\<^sup>2 * (- ln (fst p * snd p) / (1 - fst p * snd p)))", "by (intro set_integrable_mult_right) (auto simp: D_def)"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>(x, y). C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "fix x y :: real"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "assume xy: \"(x, y) \\<in> D\""], ["proof (state)\nthis:\n  (x, y) \\<in> D\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "from xy"], ["proof (chain)\npicking this:\n  (x, y) \\<in> D", "have \"x * y < 1\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n\ngoal (1 subgoal):\n 1. x * y < 1", "using mult_strict_mono[of x 1 y 1]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. x * y < 1", "by (simp add: D_def)"], ["proof (state)\nthis:\n  x * y < 1\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "have \"norm (-ln (x*y) / (1 - x*y) * P x * P y) = (-ln (x*y)) / (1 - x*y) * norm (P x) * norm (P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (- ln (x * y) / (1 - x * y) * P x * P y) =\n    - ln (x * y) / (1 - x * y) * norm (P x) * norm (P y)", "using xy \\<open>x * y < 1\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n  x * y < 1\n\ngoal (1 subgoal):\n 1. norm (- ln (x * y) / (1 - x * y) * P x * P y) =\n    - ln (x * y) / (1 - x * y) * norm (P x) * norm (P y)", "by (simp add: abs_mult abs_divide D_def)"], ["proof (state)\nthis:\n  norm (- ln (x * y) / (1 - x * y) * P x * P y) =\n  - ln (x * y) / (1 - x * y) * norm (P x) * norm (P y)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "also"], ["proof (state)\nthis:\n  norm (- ln (x * y) / (1 - x * y) * P x * P y) =\n  - ln (x * y) / (1 - x * y) * norm (P x) * norm (P y)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "have \"\\<dots> \\<le> (-ln (x*y)) / (1-x*y) * C * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) * norm (P x) * norm (P y)\n    \\<le> - ln (x * y) / (1 - x * y) * C * C", "using xy C[of x] C[of y] \\<open>x * y < 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n  x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\n  y \\<in> {0..1} \\<Longrightarrow> norm (P y) \\<le> C\n  x * y < 1\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) * norm (P x) * norm (P y)\n    \\<le> - ln (x * y) / (1 - x * y) * C * C", "by (intro mult_mono divide_left_mono)\n         (auto simp: D_def divide_nonpos_nonneg mult_nonpos_nonneg)"], ["proof (state)\nthis:\n  - ln (x * y) / (1 - x * y) * norm (P x) * norm (P y)\n  \\<le> - ln (x * y) / (1 - x * y) * C * C\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "also"], ["proof (state)\nthis:\n  - ln (x * y) / (1 - x * y) * norm (P x) * norm (P y)\n  \\<le> - ln (x * y) / (1 - x * y) * C * C\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "have \"\\<dots> = norm ((-ln (x*y)) / (1-x*y) * C * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) * C * C =\n    norm (- ln (x * y) / (1 - x * y) * C * C)", "using xy \\<open>x * y < 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n  x * y < 1\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) * C * C =\n    norm (- ln (x * y) / (1 - x * y) * C * C)", "by (simp add: abs_divide abs_mult D_def)"], ["proof (state)\nthis:\n  - ln (x * y) / (1 - x * y) * C * C =\n  norm (- ln (x * y) / (1 - x * y) * C * C)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm (- ln (a * b) / (1 - a * b) * P a * P b)\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "finally"], ["proof (chain)\npicking this:\n  norm (- ln (x * y) / (1 - x * y) * P x * P y)\n  \\<le> norm (- ln (x * y) / (1 - x * y) * C * C)", "show \"norm (-ln (x*y) / (1 - x*y) * P x * P y)\n           \\<le> norm (case (x, y) of (x, y) \\<Rightarrow> C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))\""], ["proof (prove)\nusing this:\n  norm (- ln (x * y) / (1 - x * y) * P x * P y)\n  \\<le> norm (- ln (x * y) / (1 - x * y) * C * C)\n\ngoal (1 subgoal):\n 1. norm (- ln (x * y) / (1 - x * y) * P x * P y)\n    \\<le> norm\n           (case (x, y) of\n            (x, y) \\<Rightarrow> C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "by (auto simp: algebra_simps power2_eq_square abs_mult abs_divide)"], ["proof (state)\nthis:\n  norm (- ln (x * y) / (1 - x * y) * P x * P y)\n  \\<le> norm\n         (case (x, y) of\n          (x, y) \\<Rightarrow> C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))\n\ngoal (1 subgoal):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)", "qed (auto simp: D_def set_borel_measurable_def case_prod_unfold simp flip: lborel_prod)"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * P x * P y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The triple integral\\<close>"], ["", "text \\<open>\n  Lastly, we turn to the triple integral\n  \\[I_3 := \\int_0^1 \\int_0^1 \\int_0^1\n      \\frac{(x(1-x)y(1-y)w(1-w))^n}{(1-(1-xy)w)^{n+1}}\\ \\text{d}x\\,\\text{d}y\\,\\text{d}w\\ .\\]\n\\<close>"], ["", "definition beukers_nn_integral3 :: ennreal where\n  \"beukers_nn_integral3 =\n     (\\<integral>\\<^sup>+(w,x,y)\\<in>D'. ((x*(1-x)*y*(1-y)*w*(1-w))^n / (1-(1-x*y)*w)^(n+1)) \\<partial>lborel)\""], ["", "definition beukers_integral3 :: real where\n  \"beukers_integral3 =\n     (\\<integral>(w,x,y)\\<in>D'. ((x*(1-x)*y*(1-y)*w*(1-w))^n / (1-(1-x*y)*w)^(n+1)) \\<partial>lborel)\""], ["", "text \\<open>\n  We first prove the following bound\n  (which is a consequence of the arithmetic--geometric mean inequality)\n  that will help us to bound the triple integral.\n\\<close>"], ["", "lemma beukers_integral3_integrand_bound:\n  fixes x y z :: real\n  assumes xyz: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\" \"z \\<in> {0<..<1}\"\n  shows   \"(x*(1-x)*y*(1-y)*z*(1-z)) / (1-(1-x*y)*z) \\<le> 1 / 27\" (is \"?lhs \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "have ineq1: \"x * (1 - x) \\<le> 1 / 4\" if x: \"x \\<in> {0..1}\" for x :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1 - x) \\<le> 1 / 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * (1 - x) \\<le> 1 / 4", "have \"x * (1 - x) - 1 / 4 = -((x - 1 / 2) ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1 - x) - 1 / 4 = - (x - 1 / 2)\\<^sup>2", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  x * (1 - x) - 1 / 4 = - (x - 1 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. x * (1 - x) \\<le> 1 / 4", "also"], ["proof (state)\nthis:\n  x * (1 - x) - 1 / 4 = - (x - 1 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. x * (1 - x) \\<le> 1 / 4", "have \"\\<dots> \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x - 1 / 2)\\<^sup>2 \\<le> 0", "by simp"], ["proof (state)\nthis:\n  - (x - 1 / 2)\\<^sup>2 \\<le> 0\n\ngoal (1 subgoal):\n 1. x * (1 - x) \\<le> 1 / 4", "finally"], ["proof (chain)\npicking this:\n  x * (1 - x) - 1 / 4 \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x * (1 - x) - 1 / 4 \\<le> 0\n\ngoal (1 subgoal):\n 1. x * (1 - x) \\<le> 1 / 4", "by simp"], ["proof (state)\nthis:\n  x * (1 - x) \\<le> 1 / 4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow> ?x * (1 - ?x) \\<le> 1 / 4\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "have ineq2: \"x * (1 - x) ^ 2 \\<le> 4 / 27\" if x: \"x \\<in> {0..1}\" for x :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1 - x)\\<^sup>2 \\<le> 4 / 27", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * (1 - x)\\<^sup>2 \\<le> 4 / 27", "have \"x * (1 - x) ^ 2 - 4 / 27 = (x - 4 / 3) * (x - 1 / 3) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1 - x)\\<^sup>2 - 4 / 27 = (x - 4 / 3) * (x - 1 / 3)\\<^sup>2", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  x * (1 - x)\\<^sup>2 - 4 / 27 = (x - 4 / 3) * (x - 1 / 3)\\<^sup>2\n\ngoal (1 subgoal):\n 1. x * (1 - x)\\<^sup>2 \\<le> 4 / 27", "also"], ["proof (state)\nthis:\n  x * (1 - x)\\<^sup>2 - 4 / 27 = (x - 4 / 3) * (x - 1 / 3)\\<^sup>2\n\ngoal (1 subgoal):\n 1. x * (1 - x)\\<^sup>2 \\<le> 4 / 27", "have \"\\<dots> \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - 4 / 3) * (x - 1 / 3)\\<^sup>2 \\<le> 0", "by (rule mult_nonpos_nonneg) (use x in auto)"], ["proof (state)\nthis:\n  (x - 4 / 3) * (x - 1 / 3)\\<^sup>2 \\<le> 0\n\ngoal (1 subgoal):\n 1. x * (1 - x)\\<^sup>2 \\<le> 4 / 27", "finally"], ["proof (chain)\npicking this:\n  x * (1 - x)\\<^sup>2 - 4 / 27 \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x * (1 - x)\\<^sup>2 - 4 / 27 \\<le> 0\n\ngoal (1 subgoal):\n 1. x * (1 - x)\\<^sup>2 \\<le> 4 / 27", "by simp"], ["proof (state)\nthis:\n  x * (1 - x)\\<^sup>2 \\<le> 4 / 27\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow> ?x * (1 - ?x)\\<^sup>2 \\<le> 4 / 27\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "have \"1 - (1-x*y)*z = (1 - z) + x * y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (1 - x * y) * z = 1 - z + x * y * z", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  1 - (1 - x * y) * z = 1 - z + x * y * z\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "also"], ["proof (state)\nthis:\n  1 - (1 - x * y) * z = 1 - z + x * y * z\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "have \"\\<dots> \\<ge> 2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z \\<le> 1 - z + x * y * z", "using arith_geo_mean_sqrt[of \"1 - z\" \"x * y * z\"] xyz"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1 - z; 0 \\<le> x * y * z\\<rbrakk>\n  \\<Longrightarrow> sqrt ((1 - z) * (x * y * z))\n                    \\<le> (1 - z + x * y * z) / 2\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z \\<le> 1 - z + x * y * z", "by (auto simp: real_sqrt_mult)"], ["proof (state)\nthis:\n  2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z \\<le> 1 - z + x * y * z\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "finally"], ["proof (chain)\npicking this:\n  2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z \\<le> 1 - (1 - x * y) * z", "have *: \"?lhs \\<le> (x*(1-x)*y*(1-y)*z*(1-z)) / (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z)\""], ["proof (prove)\nusing this:\n  2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z \\<le> 1 - (1 - x * y) * z\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> x * (1 - x) * y * (1 - y) * z * (1 - z) /\n          (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z)", "using xyz beukers_denom_ineq[of x y z]"], ["proof (prove)\nusing this:\n  2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z \\<le> 1 - (1 - x * y) * z\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; z \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * z < 1\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> x * (1 - x) * y * (1 - y) * z * (1 - z) /\n          (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z)", "by (intro divide_left_mono mult_nonneg_nonneg mult_pos_pos) auto"], ["proof (state)\nthis:\n  x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n  \\<le> x * (1 - x) * y * (1 - y) * z * (1 - z) /\n        (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z)\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "have \"(x*(1-x)*y*(1-y)*z*(1-z)) = (sqrt x * sqrt x * (1-x) * sqrt y * sqrt y *\n               (1-y) * sqrt z * sqrt z * sqrt (1-z) * sqrt (1-z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) =\n    sqrt x * sqrt x * (1 - x) * sqrt y * sqrt y * (1 - y) * sqrt z *\n    sqrt z *\n    sqrt (1 - z) *\n    sqrt (1 - z)", "using xyz"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) =\n    sqrt x * sqrt x * (1 - x) * sqrt y * sqrt y * (1 - y) * sqrt z *\n    sqrt z *\n    sqrt (1 - z) *\n    sqrt (1 - z)", "by simp"], ["proof (state)\nthis:\n  x * (1 - x) * y * (1 - y) * z * (1 - z) =\n  sqrt x * sqrt x * (1 - x) * sqrt y * sqrt y * (1 - y) * sqrt z * sqrt z *\n  sqrt (1 - z) *\n  sqrt (1 - z)\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "also"], ["proof (state)\nthis:\n  x * (1 - x) * y * (1 - y) * z * (1 - z) =\n  sqrt x * sqrt x * (1 - x) * sqrt y * sqrt y * (1 - y) * sqrt z * sqrt z *\n  sqrt (1 - z) *\n  sqrt (1 - z)\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "have \"\\<dots> / (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z) =\n               sqrt (x * (1 - x) ^ 2) * sqrt (y * (1 - y) ^ 2) * sqrt (z * (1 - z)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt x * sqrt x * (1 - x) * sqrt y * sqrt y * (1 - y) * sqrt z *\n    sqrt z *\n    sqrt (1 - z) *\n    sqrt (1 - z) /\n    (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z) =\n    sqrt (x * (1 - x)\\<^sup>2) * sqrt (y * (1 - y)\\<^sup>2) *\n    sqrt (z * (1 - z)) /\n    2", "using xyz"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. sqrt x * sqrt x * (1 - x) * sqrt y * sqrt y * (1 - y) * sqrt z *\n    sqrt z *\n    sqrt (1 - z) *\n    sqrt (1 - z) /\n    (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z) =\n    sqrt (x * (1 - x)\\<^sup>2) * sqrt (y * (1 - y)\\<^sup>2) *\n    sqrt (z * (1 - z)) /\n    2", "by (simp add: divide_simps real_sqrt_mult del: real_sqrt_mult_self)"], ["proof (state)\nthis:\n  sqrt x * sqrt x * (1 - x) * sqrt y * sqrt y * (1 - y) * sqrt z * sqrt z *\n  sqrt (1 - z) *\n  sqrt (1 - z) /\n  (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z) =\n  sqrt (x * (1 - x)\\<^sup>2) * sqrt (y * (1 - y)\\<^sup>2) *\n  sqrt (z * (1 - z)) /\n  2\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "also"], ["proof (state)\nthis:\n  sqrt x * sqrt x * (1 - x) * sqrt y * sqrt y * (1 - y) * sqrt z * sqrt z *\n  sqrt (1 - z) *\n  sqrt (1 - z) /\n  (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z) =\n  sqrt (x * (1 - x)\\<^sup>2) * sqrt (y * (1 - y)\\<^sup>2) *\n  sqrt (z * (1 - z)) /\n  2\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "have \"\\<dots> \\<le> sqrt (4 / 27) * sqrt (4 / 27) * sqrt (1 / 4) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (x * (1 - x)\\<^sup>2) * sqrt (y * (1 - y)\\<^sup>2) *\n    sqrt (z * (1 - z)) /\n    2\n    \\<le> sqrt (4 / 27) * sqrt (4 / 27) * sqrt (1 / 4) / 2", "using xyz"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. sqrt (x * (1 - x)\\<^sup>2) * sqrt (y * (1 - y)\\<^sup>2) *\n    sqrt (z * (1 - z)) /\n    2\n    \\<le> sqrt (4 / 27) * sqrt (4 / 27) * sqrt (1 / 4) / 2", "by (intro divide_right_mono mult_mono real_sqrt_le_mono ineq1 ineq2) auto"], ["proof (state)\nthis:\n  sqrt (x * (1 - x)\\<^sup>2) * sqrt (y * (1 - y)\\<^sup>2) *\n  sqrt (z * (1 - z)) /\n  2\n  \\<le> sqrt (4 / 27) * sqrt (4 / 27) * sqrt (1 / 4) / 2\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "also"], ["proof (state)\nthis:\n  sqrt (x * (1 - x)\\<^sup>2) * sqrt (y * (1 - y)\\<^sup>2) *\n  sqrt (z * (1 - z)) /\n  2\n  \\<le> sqrt (4 / 27) * sqrt (4 / 27) * sqrt (1 / 4) / 2\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "have \"\\<dots> = 1 / 27\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (4 / 27) * sqrt (4 / 27) * sqrt (1 / 4) / 2 = 1 / 27", "by (simp add: real_sqrt_divide)"], ["proof (state)\nthis:\n  sqrt (4 / 27) * sqrt (4 / 27) * sqrt (1 / 4) / 2 = 1 / 27\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "finally"], ["proof (chain)\npicking this:\n  x * (1 - x) * y * (1 - y) * z * (1 - z) /\n  (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z)\n  \\<le> 1 / 27", "show ?thesis"], ["proof (prove)\nusing this:\n  x * (1 - x) * y * (1 - y) * z * (1 - z) /\n  (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z)\n  \\<le> 1 / 27\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "using *"], ["proof (prove)\nusing this:\n  x * (1 - x) * y * (1 - y) * z * (1 - z) /\n  (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z)\n  \\<le> 1 / 27\n  x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n  \\<le> x * (1 - x) * y * (1 - y) * z * (1 - z) /\n        (2 * sqrt (1 - z) * sqrt x * sqrt y * sqrt z)\n\ngoal (1 subgoal):\n 1. x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n    \\<le> 1 / 27", "by argo"], ["proof (state)\nthis:\n  x * (1 - x) * y * (1 - y) * z * (1 - z) / (1 - (1 - x * y) * z)\n  \\<le> 1 / 27\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Connecting the above bound with our results of $I_1$, it is easy to see that\n  $I_3 \\leq 2 \\cdot 27^{-n} \\cdot \\zeta(3)$:\n\\<close>"], ["", "lemma beukers_nn_integral3_le:\n  \"beukers_nn_integral3 \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "have D' [measurable]: \"D' \\<in> sets (borel \\<Otimes>\\<^sub>M borel \\<Otimes>\\<^sub>M borel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D' \\<in> sets (borel \\<Otimes>\\<^sub>M borel \\<Otimes>\\<^sub>M borel)", "unfolding D'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}\n    \\<in> sets (borel \\<Otimes>\\<^sub>M borel \\<Otimes>\\<^sub>M borel)", "by (simp flip: borel_prod)"], ["proof (state)\nthis:\n  D' \\<in> sets (borel \\<Otimes>\\<^sub>M borel \\<Otimes>\\<^sub>M borel)\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "have \"beukers_nn_integral3 =\n          (\\<integral>\\<^sup>+(w,x,y)\\<in>D'. ((x*(1-x)*y*(1-y)*w*(1-w))^n / (1-(1-x*y)*w)^(n+1)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3 =\n    \\<integral>\\<^sup>+x\\<in>D'.\n                       ennreal\n                        (case x of\n                         (w, xa, y) \\<Rightarrow>\n                           (xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                           (1 - (1 - xa * y) * w) ^ (n + 1))\n    \\<partial>lborel", "by (simp add: beukers_nn_integral3_def)"], ["proof (state)\nthis:\n  local.beukers_nn_integral3 =\n  \\<integral>\\<^sup>+x\\<in>D'.\n                     ennreal\n                      (case x of\n                       (w, xa, y) \\<Rightarrow>\n                         (xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                         (1 - (1 - xa * y) * w) ^ (n + 1))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "also"], ["proof (state)\nthis:\n  local.beukers_nn_integral3 =\n  \\<integral>\\<^sup>+x\\<in>D'.\n                     ennreal\n                      (case x of\n                       (w, xa, y) \\<Rightarrow>\n                         (xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                         (1 - (1 - xa * y) * w) ^ (n + 1))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "have \"\\<dots> \\<le> (\\<integral>\\<^sup>+(w,x,y)\\<in>D'. ((1 / 27) ^ n / (1-(1-x*y)*w)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>D'.\n                       ennreal\n                        (case x of\n                         (w, xa, y) \\<Rightarrow>\n                           (xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                           (1 - (1 - xa * y) * w) ^ (n + 1))\n    \\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>D'.\n                             ennreal\n                              (case x of\n                               (w, xa, y) \\<Rightarrow>\n                                 (1 / 27) ^ n / (1 - (1 - xa * y) * w))\n          \\<partial>lborel", "proof (intro set_nn_integral_mono ennreal_leI, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; (a, aa, b) \\<in> D'\\<rbrakk>\n       \\<Longrightarrow> (aa * (1 - aa) * b * (1 - b) * a * (1 - a)) ^ n /\n                         (1 - (1 - aa * b) * a) ^ (n + 1)\n                         \\<le> (1 / 27) ^ n / (1 - (1 - aa * b) * a)", "case (1 w x y)"], ["proof (state)\nthis:\n  (w, x, y) \\<in> space lborel\n  (w, x, y) \\<in> D'\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; (a, aa, b) \\<in> D'\\<rbrakk>\n       \\<Longrightarrow> (aa * (1 - aa) * b * (1 - b) * a * (1 - a)) ^ n /\n                         (1 - (1 - aa * b) * a) ^ (n + 1)\n                         \\<le> (1 / 27) ^ n / (1 - (1 - aa * b) * a)", "have \"(x*(1-x)*y*(1-y)*w*(1-w))^n / (1-(1-x*y)*w)^(n+1) =\n            ((x*(1-x)*y*(1-y)*w*(1-w)) / (1-(1-x*y)*w)) ^ n / (1-(1-x*y)*w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n    (1 - (1 - x * y) * w) ^ (n + 1) =\n    (x * (1 - x) * y * (1 - y) * w * (1 - w) / (1 - (1 - x * y) * w)) ^ n /\n    (1 - (1 - x * y) * w)", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n  (1 - (1 - x * y) * w) ^ (n + 1) =\n  (x * (1 - x) * y * (1 - y) * w * (1 - w) / (1 - (1 - x * y) * w)) ^ n /\n  (1 - (1 - x * y) * w)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; (a, aa, b) \\<in> D'\\<rbrakk>\n       \\<Longrightarrow> (aa * (1 - aa) * b * (1 - b) * a * (1 - a)) ^ n /\n                         (1 - (1 - aa * b) * a) ^ (n + 1)\n                         \\<le> (1 / 27) ^ n / (1 - (1 - aa * b) * a)", "also"], ["proof (state)\nthis:\n  (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n  (1 - (1 - x * y) * w) ^ (n + 1) =\n  (x * (1 - x) * y * (1 - y) * w * (1 - w) / (1 - (1 - x * y) * w)) ^ n /\n  (1 - (1 - x * y) * w)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; (a, aa, b) \\<in> D'\\<rbrakk>\n       \\<Longrightarrow> (aa * (1 - aa) * b * (1 - b) * a * (1 - a)) ^ n /\n                         (1 - (1 - aa * b) * a) ^ (n + 1)\n                         \\<le> (1 / 27) ^ n / (1 - (1 - aa * b) * a)", "have \"\\<dots> \\<le> (1 / 27) ^ n / (1 - (1 - x * y) * w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * (1 - x) * y * (1 - y) * w * (1 - w) / (1 - (1 - x * y) * w)) ^ n /\n    (1 - (1 - x * y) * w)\n    \\<le> (1 / 27) ^ n / (1 - (1 - x * y) * w)", "using beukers_denom_ineq[of x y w] 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; w \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * w < 1\n  (w, x, y) \\<in> space lborel\n  (w, x, y) \\<in> D'\n\ngoal (1 subgoal):\n 1. (x * (1 - x) * y * (1 - y) * w * (1 - w) / (1 - (1 - x * y) * w)) ^ n /\n    (1 - (1 - x * y) * w)\n    \\<le> (1 / 27) ^ n / (1 - (1 - x * y) * w)", "by (intro divide_right_mono power_mono beukers_integral3_integrand_bound)\n         (auto simp: D'_def)"], ["proof (state)\nthis:\n  (x * (1 - x) * y * (1 - y) * w * (1 - w) / (1 - (1 - x * y) * w)) ^ n /\n  (1 - (1 - x * y) * w)\n  \\<le> (1 / 27) ^ n / (1 - (1 - x * y) * w)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; (a, aa, b) \\<in> D'\\<rbrakk>\n       \\<Longrightarrow> (aa * (1 - aa) * b * (1 - b) * a * (1 - a)) ^ n /\n                         (1 - (1 - aa * b) * a) ^ (n + 1)\n                         \\<le> (1 / 27) ^ n / (1 - (1 - aa * b) * a)", "finally"], ["proof (chain)\npicking this:\n  (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n  (1 - (1 - x * y) * w) ^ (n + 1)\n  \\<le> (1 / 27) ^ n / (1 - (1 - x * y) * w)", "show ?case"], ["proof (prove)\nusing this:\n  (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n  (1 - (1 - x * y) * w) ^ (n + 1)\n  \\<le> (1 / 27) ^ n / (1 - (1 - x * y) * w)\n\ngoal (1 subgoal):\n 1. (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n    (1 - (1 - x * y) * w) ^ (n + 1)\n    \\<le> (1 / 27) ^ n / (1 - (1 - x * y) * w)", "."], ["proof (state)\nthis:\n  (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n  (1 - (1 - x * y) * w) ^ (n + 1)\n  \\<le> (1 / 27) ^ n / (1 - (1 - x * y) * w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>D'.\n                     ennreal\n                      (case x of\n                       (w, xa, y) \\<Rightarrow>\n                         (xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                         (1 - (1 - xa * y) * w) ^ (n + 1))\n  \\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>D'.\n                           ennreal\n                            (case x of\n                             (w, xa, y) \\<Rightarrow>\n                               (1 / 27) ^ n / (1 - (1 - xa * y) * w))\n        \\<partial>lborel\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>D'.\n                     ennreal\n                      (case x of\n                       (w, xa, y) \\<Rightarrow>\n                         (xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                         (1 - (1 - xa * y) * w) ^ (n + 1))\n  \\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>D'.\n                           ennreal\n                            (case x of\n                             (w, xa, y) \\<Rightarrow>\n                               (1 / 27) ^ n / (1 - (1 - xa * y) * w))\n        \\<partial>lborel\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "have \"\\<dots> = ennreal ((1 / 27) ^ n) * (\\<integral>\\<^sup>+(w,x,y)\\<in>D'. (1 / (1-(1-x*y)*w)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>D'.\n                       ennreal\n                        (case x of\n                         (w, xa, y) \\<Rightarrow>\n                           (1 / 27) ^ n / (1 - (1 - xa * y) * w))\n    \\<partial>lborel =\n    ennreal ((1 / 27) ^ n) *\n    (\\<integral>\\<^sup>+x\\<in>D'.\n                        ennreal\n                         (case x of\n                          (w, xa, y) \\<Rightarrow>\n                            1 / (1 - (1 - xa * y) * w))\n     \\<partial>lborel)", "unfolding lborel_prod [symmetric] case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>D'.\n                       ennreal\n                        ((1 / 27) ^ n /\n                         (1 - (1 - fst (snd x) * snd (snd x)) * fst x))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel \\<Otimes>\\<^sub>M lborel =\n    ennreal ((1 / 27) ^ n) *\n    (\\<integral>\\<^sup>+x\\<in>D'.\n                        ennreal\n                         (1 / (1 - (1 - fst (snd x) * snd (snd x)) * fst x))\n     \\<partial>lborel \\<Otimes>\\<^sub>M lborel \\<Otimes>\\<^sub>M lborel)", "by (subst nn_integral_cmult [symmetric])\n       (auto intro!: nn_integral_cong simp: indicator_def simp flip: ennreal_mult')"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>D'.\n                     ennreal\n                      (case x of\n                       (w, xa, y) \\<Rightarrow>\n                         (1 / 27) ^ n / (1 - (1 - xa * y) * w))\n  \\<partial>lborel =\n  ennreal ((1 / 27) ^ n) *\n  (\\<integral>\\<^sup>+x\\<in>D'.\n                      ennreal\n                       (case x of\n                        (w, xa, y) \\<Rightarrow> 1 / (1 - (1 - xa * y) * w))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>D'.\n                     ennreal\n                      (case x of\n                       (w, xa, y) \\<Rightarrow>\n                         (1 / 27) ^ n / (1 - (1 - xa * y) * w))\n  \\<partial>lborel =\n  ennreal ((1 / 27) ^ n) *\n  (\\<integral>\\<^sup>+x\\<in>D'.\n                      ennreal\n                       (case x of\n                        (w, xa, y) \\<Rightarrow> 1 / (1 - (1 - xa * y) * w))\n   \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "have \"(\\<integral>\\<^sup>+(w,x,y)\\<in>D'. (1 / (1-(1-x*y)*w)) \\<partial>lborel) =\n               (\\<integral>\\<^sup>+(x,y)\\<in>{0<..<1}\\<times>{0<..<1}. ennreal (- (ln (x * y) / (1 - x * y))) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>D'.\n                       ennreal\n                        (case x of\n                         (w, xa, y) \\<Rightarrow>\n                           1 / (1 - (1 - xa * y) * w))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal (- (ln (x * y) / (1 - x * y))))\n    \\<partial>lborel", "using beukers_nn_integral1_altdef[of 0 0]"], ["proof (prove)\nusing this:\n  beukers_nn_integral1 0 0 =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (w, xa, y) \\<Rightarrow>\n                        ennreal\n                         (1 / (1 - (1 - xa * y) * w) * xa ^ 0 * y ^ 0))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>D'.\n                       ennreal\n                        (case x of\n                         (w, xa, y) \\<Rightarrow>\n                           1 / (1 - (1 - xa * y) * w))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal (- (ln (x * y) / (1 - x * y))))\n    \\<partial>lborel", "by (simp add: beukers_nn_integral1_def D'_def case_prod_unfold)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>D'.\n                     ennreal\n                      (case x of\n                       (w, xa, y) \\<Rightarrow> 1 / (1 - (1 - xa * y) * w))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- (ln (x * y) / (1 - x * y))))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>D'.\n                     ennreal\n                      (case x of\n                       (w, xa, y) \\<Rightarrow> 1 / (1 - (1 - xa * y) * w))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- (ln (x * y) / (1 - x * y))))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "have \"\\<dots> = ennreal (2 * Re (zeta 3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal (- (ln (x * y) / (1 - x * y))))\n    \\<partial>lborel =\n    ennreal (2 * Re (zeta 3))", "using beukers_nn_integral1_same[of 0 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0; 0 = 0\\<rbrakk>\n  \\<Longrightarrow> beukers_nn_integral1 0 0 =\n                    ennreal\n                     (2 *\n                      (Re (zeta 3) - (\\<Sum>k = 1..0. 1 / real (k ^ 3))))\n  \\<lbrakk>0 \\<le> 0; 0 = 0\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> 2 *\n                            (Re (zeta 3) -\n                             (\\<Sum>k = 1..0. 1 / real (k ^ 3)))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                       (case x of\n                        (x, y) \\<Rightarrow>\n                          ennreal (- (ln (x * y) / (1 - x * y))))\n    \\<partial>lborel =\n    ennreal (2 * Re (zeta 3))", "by (simp add: D_def beukers_nn_integral1_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- (ln (x * y) / (1 - x * y))))\n  \\<partial>lborel =\n  ennreal (2 * Re (zeta 3))\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0<..<1} \\<times> {0<..<1}.\n                     (case x of\n                      (x, y) \\<Rightarrow>\n                        ennreal (- (ln (x * y) / (1 - x * y))))\n  \\<partial>lborel =\n  ennreal (2 * Re (zeta 3))\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "have \"ennreal ((1 / 27) ^ n) * \\<dots> = ennreal (2 * (1 / 27) ^ n * Re (zeta 3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal ((1 / 27) ^ n) * ennreal (2 * Re (zeta 3)) =\n    ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "by (subst ennreal_mult' [symmetric]) (simp_all add: mult_ac)"], ["proof (state)\nthis:\n  ennreal ((1 / 27) ^ n) * ennreal (2 * Re (zeta 3)) =\n  ennreal (2 * (1 / 27) ^ n * Re (zeta 3))\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "finally"], ["proof (chain)\npicking this:\n  local.beukers_nn_integral3 \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.beukers_nn_integral3 \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))\n\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3\n    \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))", "."], ["proof (state)\nthis:\n  local.beukers_nn_integral3 \\<le> ennreal (2 * (1 / 27) ^ n * Re (zeta 3))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beukers_nn_integral3_finite: \"beukers_nn_integral3 < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_nn_integral3 < \\<infinity>", "by (rule le_less_trans, rule beukers_nn_integral3_le) simp_all"], ["", "lemma beukers_integral3_integrable:\n  \"set_integrable lborel D' (\\<lambda>(w,x,y). (x*(1-x)*y*(1-y)*w*(1-w))^n / (1-(1-x*y)*w)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(w, x, y).\n         (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n         (1 - (1 - x * y) * w) ^ (n + 1))", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>p.\n         (fst (snd p) * (1 - fst (snd p)) * snd (snd p) *\n          (1 - snd (snd p)) *\n          fst p *\n          (1 - fst p)) ^\n         n /\n         (1 - (1 - fst (snd p) * snd (snd p)) * fst p) ^ (n + 1))", "using less_imp_le[OF beukers_denom_ineq] beukers_nn_integral3_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1 \\<in> {0<..<1}; ?y1 \\<in> {0<..<1}; ?z1 \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - ?x1 * ?y1) * ?z1 \\<le> 1\n  local.beukers_nn_integral3 < \\<infinity>\n\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>p.\n         (fst (snd p) * (1 - fst (snd p)) * snd (snd p) *\n          (1 - snd (snd p)) *\n          fst p *\n          (1 - fst p)) ^\n         n /\n         (1 - (1 - fst (snd p) * snd (snd p)) * fst p) ^ (n + 1))", "by (intro set_integrableI_nonneg AE_I2 impI)\n     (auto simp: D'_def set_borel_measurable_def beukers_nn_integral3_def case_prod_unfold\n           simp flip: lborel_prod intro!: divide_nonneg_nonneg mult_nonneg_nonneg)"], ["", "lemma beukers_integral3_conv_nn_integral:\n  \"beukers_integral3 = enn2real beukers_nn_integral3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_integral3 = enn2real local.beukers_nn_integral3", "unfolding beukers_integral3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (w, x, y):D'.\n       (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1) =\n    enn2real local.beukers_nn_integral3", "using beukers_nn_integral3_finite less_imp_le[OF beukers_denom_ineq]"], ["proof (prove)\nusing this:\n  local.beukers_nn_integral3 < \\<infinity>\n  \\<lbrakk>?x1 \\<in> {0<..<1}; ?y1 \\<in> {0<..<1}; ?z1 \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - ?x1 * ?y1) * ?z1 \\<le> 1\n\ngoal (1 subgoal):\n 1. LBINT (w, x, y):D'.\n       (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1) =\n    enn2real local.beukers_nn_integral3", "by (intro set_integral_eq_nn_integral AE_I2 impI)\n     (auto simp: D'_def set_borel_measurable_def beukers_nn_integral3_def case_prod_unfold\n           simp flip: lborel_prod)"], ["", "lemma beukers_integral3_le: \"beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "have \"beukers_integral3 = enn2real beukers_nn_integral3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_integral3 = enn2real local.beukers_nn_integral3", "by (rule beukers_integral3_conv_nn_integral)"], ["proof (state)\nthis:\n  local.beukers_integral3 = enn2real local.beukers_nn_integral3\n\ngoal (1 subgoal):\n 1. local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "also"], ["proof (state)\nthis:\n  local.beukers_integral3 = enn2real local.beukers_nn_integral3\n\ngoal (1 subgoal):\n 1. local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "have \"\\<dots> \\<le> enn2real (ennreal (2 * (1 / 27) ^ n * Re (zeta 3)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real local.beukers_nn_integral3\n    \\<le> enn2real (ennreal (2 * (1 / 27) ^ n * Re (zeta 3)))", "by (intro enn2real_mono beukers_nn_integral3_le) auto"], ["proof (state)\nthis:\n  enn2real local.beukers_nn_integral3\n  \\<le> enn2real (ennreal (2 * (1 / 27) ^ n * Re (zeta 3)))\n\ngoal (1 subgoal):\n 1. local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "also"], ["proof (state)\nthis:\n  enn2real local.beukers_nn_integral3\n  \\<le> enn2real (ennreal (2 * (1 / 27) ^ n * Re (zeta 3)))\n\ngoal (1 subgoal):\n 1. local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "have \"\\<dots> = 2 * (1 / 27) ^ n * Re (zeta 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (ennreal (2 * (1 / 27) ^ n * Re (zeta 3))) =\n    2 * (1 / 27) ^ n * Re (zeta 3)", "using Re_zeta_ge_1[of 3]"], ["proof (prove)\nusing this:\n  1 < 3 \\<Longrightarrow> 1 \\<le> Re (zeta (complex_of_real 3))\n\ngoal (1 subgoal):\n 1. enn2real (ennreal (2 * (1 / 27) ^ n * Re (zeta 3))) =\n    2 * (1 / 27) ^ n * Re (zeta 3)", "by (intro enn2real_ennreal mult_nonneg_nonneg) auto"], ["proof (state)\nthis:\n  enn2real (ennreal (2 * (1 / 27) ^ n * Re (zeta 3))) =\n  2 * (1 / 27) ^ n * Re (zeta 3)\n\ngoal (1 subgoal):\n 1. local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "finally"], ["proof (chain)\npicking this:\n  local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "show ?thesis"], ["proof (prove)\nusing this:\n  local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\n\ngoal (1 subgoal):\n 1. local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "."], ["proof (state)\nthis:\n  local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  It is also easy to see that $I_3 > 0$.\n\\<close>"], ["", "lemma beukers_nn_integral3_pos: \"beukers_nn_integral3 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < local.beukers_nn_integral3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < local.beukers_nn_integral3", "have D' [measurable]: \"D' \\<in> sets (borel \\<Otimes>\\<^sub>M borel \\<Otimes>\\<^sub>M borel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D' \\<in> sets (borel \\<Otimes>\\<^sub>M borel \\<Otimes>\\<^sub>M borel)", "unfolding D'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}\n    \\<in> sets (borel \\<Otimes>\\<^sub>M borel \\<Otimes>\\<^sub>M borel)", "by (simp flip: borel_prod)"], ["proof (state)\nthis:\n  D' \\<in> sets (borel \\<Otimes>\\<^sub>M borel \\<Otimes>\\<^sub>M borel)\n\ngoal (1 subgoal):\n 1. 0 < local.beukers_nn_integral3", "have *: \"\\<not>(AE (w,x,y) in lborel. ennreal ((x*(1-x)*y*(1-y)*w*(1-w))^n /\n             (1-(1-x*y)*w)^(n+1)) * indicator D' (w,x,y) \\<le> 0)\"\n            (is \"\\<not>(AE z in lborel. ?P z)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "fix w x y :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "assume xyw: \"(w,x,y) \\<in> D'\""], ["proof (state)\nthis:\n  (w, x, y) \\<in> D'\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "hence \"(x*(1-x)*y*(1-y)*w*(1-w))^n / (1-(1-x*y)*w)^(n+1) > 0\""], ["proof (prove)\nusing this:\n  (w, x, y) \\<in> D'\n\ngoal (1 subgoal):\n 1. 0 < (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n        (1 - (1 - x * y) * w) ^ (n + 1)", "using beukers_denom_ineq[of x y w]"], ["proof (prove)\nusing this:\n  (w, x, y) \\<in> D'\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; w \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * w < 1\n\ngoal (1 subgoal):\n 1. 0 < (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n        (1 - (1 - x * y) * w) ^ (n + 1)", "by (intro divide_pos_pos mult_pos_pos zero_less_power) (auto simp: D'_def)"], ["proof (state)\nthis:\n  0 < (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n      (1 - (1 - x * y) * w) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "with xyw"], ["proof (chain)\npicking this:\n  (w, x, y) \\<in> D'\n  0 < (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n      (1 - (1 - x * y) * w) ^ (n + 1)", "have \"\\<not>?P (w,x,y)\""], ["proof (prove)\nusing this:\n  (w, x, y) \\<in> D'\n  0 < (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n      (1 - (1 - x * y) * w) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. \\<not> (case (w, x, y) of\n            (w, xa, y) \\<Rightarrow>\n              ennreal\n               ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                (1 - (1 - xa * y) * w) ^ (n + 1)) *\n              indicator D' (w, xa, y)\n              \\<le> 0)", "by (auto simp: indicator_def D'_def)"], ["proof (state)\nthis:\n  \\<not> (case (w, x, y) of\n          (w, xa, y) \\<Rightarrow>\n            ennreal\n             ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n              (1 - (1 - xa * y) * w) ^ (n + 1)) *\n            indicator D' (w, xa, y)\n            \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "}"], ["proof (state)\nthis:\n  (?w2, ?x2, ?y2) \\<in> D' \\<Longrightarrow>\n  \\<not> (case (?w2, ?x2, ?y2) of\n          (w, xa, y) \\<Rightarrow>\n            ennreal\n             ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n              (1 - (1 - xa * y) * w) ^ (n + 1)) *\n            indicator D' (w, xa, y)\n            \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "hence *: \"\\<not>?P z\" if \"z \\<in> D'\" for z"], ["proof (prove)\nusing this:\n  (?w2, ?x2, ?y2) \\<in> D' \\<Longrightarrow>\n  \\<not> (case (?w2, ?x2, ?y2) of\n          (w, xa, y) \\<Rightarrow>\n            ennreal\n             ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n              (1 - (1 - xa * y) * w) ^ (n + 1)) *\n            indicator D' (w, xa, y)\n            \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (case z of\n            (w, xa, y) \\<Rightarrow>\n              ennreal\n               ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                (1 - (1 - xa * y) * w) ^ (n + 1)) *\n              indicator D' (w, xa, y)\n              \\<le> 0)", "using that"], ["proof (prove)\nusing this:\n  (?w2, ?x2, ?y2) \\<in> D' \\<Longrightarrow>\n  \\<not> (case (?w2, ?x2, ?y2) of\n          (w, xa, y) \\<Rightarrow>\n            ennreal\n             ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n              (1 - (1 - xa * y) * w) ^ (n + 1)) *\n            indicator D' (w, xa, y)\n            \\<le> 0)\n  z \\<in> D'\n\ngoal (1 subgoal):\n 1. \\<not> (case z of\n            (w, xa, y) \\<Rightarrow>\n              ennreal\n               ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                (1 - (1 - xa * y) * w) ^ (n + 1)) *\n              indicator D' (w, xa, y)\n              \\<le> 0)", "by blast"], ["proof (state)\nthis:\n  ?z \\<in> D' \\<Longrightarrow>\n  \\<not> (case ?z of\n          (w, xa, y) \\<Rightarrow>\n            ennreal\n             ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n              (1 - (1 - xa * y) * w) ^ (n + 1)) *\n            indicator D' (w, xa, y)\n            \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "hence \"{z\\<in>space lborel. \\<not>?P z} = D'\""], ["proof (prove)\nusing this:\n  ?z \\<in> D' \\<Longrightarrow>\n  \\<not> (case ?z of\n          (w, xa, y) \\<Rightarrow>\n            ennreal\n             ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n              (1 - (1 - xa * y) * w) ^ (n + 1)) *\n            indicator D' (w, xa, y)\n            \\<le> 0)\n\ngoal (1 subgoal):\n 1. {z \\<in> space lborel.\n     \\<not> (case z of\n             (w, xa, y) \\<Rightarrow>\n               ennreal\n                ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n                 (1 - (1 - xa * y) * w) ^ (n + 1)) *\n               indicator D' (w, xa, y)\n               \\<le> 0)} =\n    D'", "by auto"], ["proof (state)\nthis:\n  {z \\<in> space lborel.\n   \\<not> (case z of\n           (w, xa, y) \\<Rightarrow>\n             ennreal\n              ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n               (1 - (1 - xa * y) * w) ^ (n + 1)) *\n             indicator D' (w, xa, y)\n             \\<le> 0)} =\n  D'\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "moreover"], ["proof (state)\nthis:\n  {z \\<in> space lborel.\n   \\<not> (case z of\n           (w, xa, y) \\<Rightarrow>\n             ennreal\n              ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n               (1 - (1 - xa * y) * w) ^ (n + 1)) *\n             indicator D' (w, xa, y)\n             \\<le> 0)} =\n  D'\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "have \"emeasure lborel D' = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lborel D' = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure lborel D' = 1", "have \"D' = box (0,0,0) (1,1,1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D' = box (0, 0, 0) (1, 1, 1)", "by (auto simp: D'_def box_def Basis_prod_def)"], ["proof (state)\nthis:\n  D' = box (0, 0, 0) (1, 1, 1)\n\ngoal (1 subgoal):\n 1. emeasure lborel D' = 1", "also"], ["proof (state)\nthis:\n  D' = box (0, 0, 0) (1, 1, 1)\n\ngoal (1 subgoal):\n 1. emeasure lborel D' = 1", "have \"emeasure lborel \\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lborel (box (0, 0, 0) (1, 1, 1)) = 1", "by (subst emeasure_lborel_box) (auto simp: Basis_prod_def)"], ["proof (state)\nthis:\n  emeasure lborel (box (0, 0, 0) (1, 1, 1)) = 1\n\ngoal (1 subgoal):\n 1. emeasure lborel D' = 1", "finally"], ["proof (chain)\npicking this:\n  emeasure lborel D' = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure lborel D' = 1\n\ngoal (1 subgoal):\n 1. emeasure lborel D' = 1", "by simp"], ["proof (state)\nthis:\n  emeasure lborel D' = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure lborel D' = 1\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "ultimately"], ["proof (chain)\npicking this:\n  {z \\<in> space lborel.\n   \\<not> (case z of\n           (w, xa, y) \\<Rightarrow>\n             ennreal\n              ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n               (1 - (1 - xa * y) * w) ^ (n + 1)) *\n             indicator D' (w, xa, y)\n             \\<le> 0)} =\n  D'\n  emeasure lborel D' = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  {z \\<in> space lborel.\n   \\<not> (case z of\n           (w, xa, y) \\<Rightarrow>\n             ennreal\n              ((xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^ n /\n               (1 - (1 - xa * y) * w) ^ (n + 1)) *\n             indicator D' (w, xa, y)\n             \\<le> 0)} =\n  D'\n  emeasure lborel D' = 1\n\ngoal (1 subgoal):\n 1. \\<not> (AE (w, x,\n            y) in lborel. ennreal\n                           ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                            (1 - (1 - x * y) * w) ^ (n + 1)) *\n                          indicator D' (w, x, y)\n                          \\<le> 0)", "by (subst AE_iff_measurable[of D']) (simp_all flip: borel_prod)"], ["proof (state)\nthis:\n  \\<not> (AE (w, x,\n          y) in lborel. ennreal\n                         ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                          (1 - (1 - x * y) * w) ^ (n + 1)) *\n                        indicator D' (w, x, y)\n                        \\<le> 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (AE (w, x,\n          y) in lborel. ennreal\n                         ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                          (1 - (1 - x * y) * w) ^ (n + 1)) *\n                        indicator D' (w, x, y)\n                        \\<le> 0)\n\ngoal (1 subgoal):\n 1. 0 < local.beukers_nn_integral3", "hence \"nn_integral lborel (\\<lambda>_::real\\<times>real\\<times>real. 0) < beukers_nn_integral3\""], ["proof (prove)\nusing this:\n  \\<not> (AE (w, x,\n          y) in lborel. ennreal\n                         ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                          (1 - (1 - x * y) * w) ^ (n + 1)) *\n                        indicator D' (w, x, y)\n                        \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ _. 0 \\<partial>lborel < local.beukers_nn_integral3", "unfolding beukers_nn_integral3_def"], ["proof (prove)\nusing this:\n  \\<not> (AE (w, x,\n          y) in lborel. ennreal\n                         ((x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n                          (1 - (1 - x * y) * w) ^ (n + 1)) *\n                        indicator D' (w, x, y)\n                        \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ _. 0 \\<partial>lborel\n    < \\<integral>\\<^sup>+x\\<in>D'.\n                         ennreal\n                          (case x of\n                           (w, xa, y) \\<Rightarrow>\n                             (xa * (1 - xa) * y * (1 - y) * w * (1 - w)) ^\n                             n /\n                             (1 - (1 - xa * y) * w) ^ (n + 1))\n      \\<partial>lborel", "by (intro nn_integral_less) (simp_all add: case_prod_unfold flip: lborel_prod)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ _. 0 \\<partial>lborel < local.beukers_nn_integral3\n\ngoal (1 subgoal):\n 1. 0 < local.beukers_nn_integral3", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ _. 0 \\<partial>lborel < local.beukers_nn_integral3\n\ngoal (1 subgoal):\n 1. 0 < local.beukers_nn_integral3", "by simp"], ["proof (state)\nthis:\n  0 < local.beukers_nn_integral3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beukers_integral3_pos: \"beukers_integral3 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < local.beukers_integral3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < local.beukers_integral3", "have \"0 < enn2real beukers_nn_integral3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < enn2real local.beukers_nn_integral3", "using beukers_nn_integral3_pos beukers_nn_integral3_finite"], ["proof (prove)\nusing this:\n  0 < local.beukers_nn_integral3\n  local.beukers_nn_integral3 < \\<infinity>\n\ngoal (1 subgoal):\n 1. 0 < enn2real local.beukers_nn_integral3", "by (subst enn2real_positive_iff) auto"], ["proof (state)\nthis:\n  0 < enn2real local.beukers_nn_integral3\n\ngoal (1 subgoal):\n 1. 0 < local.beukers_integral3", "also"], ["proof (state)\nthis:\n  0 < enn2real local.beukers_nn_integral3\n\ngoal (1 subgoal):\n 1. 0 < local.beukers_integral3", "have \"\\<dots> = beukers_integral3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real local.beukers_nn_integral3 = local.beukers_integral3", "by (rule beukers_integral3_conv_nn_integral [symmetric])"], ["proof (state)\nthis:\n  enn2real local.beukers_nn_integral3 = local.beukers_integral3\n\ngoal (1 subgoal):\n 1. 0 < local.beukers_integral3", "finally"], ["proof (chain)\npicking this:\n  0 < local.beukers_integral3", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < local.beukers_integral3\n\ngoal (1 subgoal):\n 1. 0 < local.beukers_integral3", "."], ["proof (state)\nthis:\n  0 < local.beukers_integral3\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Connecting the double and triple integral\\<close>"], ["", "text \\<open>\n  In this section, we will prove the most technically involved part,\n  namely that $I_2 = I_3$. I will not go into detail about how this works --\n  the reader is advised to simply look at Filaseta's presentation of the proof.\n\n  The basic idea is to integrate by parts \\<open>n\\<close> times with respect to \\<open>y\\<close> to eliminate\n  the factor $P(y)$, then change variables $z = \\frac{1-w}{1-(1-xy)w}$, and then\n  apply the same integration by parts \\<open>n\\<close> times to \\<open>x\\<close> to eliminate $P(x)$.\n\\<close>"], ["", "text \\<open>\n  The first expand \\[-\\frac{\\ln (xy)}{1-xy} = \\int_0^1 \\frac{1}{1-(1-xy)z}\\,\\text{d}z\\ .\\]\n\\<close>"], ["", "lemma beukers_aux_ln_conv_integral:\n  fixes x y :: real\n  assumes xy: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\"\n  shows \"-ln (x*y) / (1-x*y) = (LBINT z=0..1. 1 / (1-(1-x*y)*z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "have \"x * y < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y < 1", "using mult_strict_mono[of x 1 y 1] xy"], ["proof (prove)\nusing this:\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. x * y < 1", "by simp"], ["proof (state)\nthis:\n  x * y < 1\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "have less: \"(1 - x * y) * u < 1\" if u: \"u \\<in> {0..1}\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * u < 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 - x * y) * u < 1", "from u \\<open>x * y < 1\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> {0..1}\n  x * y < 1", "have \"(1 - x * y) * u \\<le> (1 - x * y) * 1\""], ["proof (prove)\nusing this:\n  u \\<in> {0..1}\n  x * y < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * u \\<le> (1 - x * y) * 1", "by (intro mult_left_mono) auto"], ["proof (state)\nthis:\n  (1 - x * y) * u \\<le> (1 - x * y) * 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * u < 1", "also"], ["proof (state)\nthis:\n  (1 - x * y) * u \\<le> (1 - x * y) * 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * u < 1", "have \"\\<dots> < 1 * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * 1 < 1 * 1", "using xy"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (1 - x * y) * 1 < 1 * 1", "by (intro mult_strict_right_mono) auto"], ["proof (state)\nthis:\n  (1 - x * y) * 1 < 1 * 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * u < 1", "finally"], ["proof (chain)\npicking this:\n  (1 - x * y) * u < 1 * 1", "show \"(1 - x * y) * u < 1\""], ["proof (prove)\nusing this:\n  (1 - x * y) * u < 1 * 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * u < 1", "by simp"], ["proof (state)\nthis:\n  (1 - x * y) * u < 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * ?u < 1\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "have neq: \"(1 - x * y) * u \\<noteq> 1\" if \"u \\<in> {0..1}\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * u \\<noteq> 1", "using less[of u] that"], ["proof (prove)\nusing this:\n  u \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * u < 1\n  u \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - x * y) * u \\<noteq> 1", "by simp"], ["proof (state)\nthis:\n  ?u \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * ?u \\<noteq> 1\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "let ?F = \"\\<lambda>z. ln (1-(1-x*y)*z)/(x*y-1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "have \"(LBINT z=ereal 0..ereal 1. 1 / (1-(1-x*y)*z)) = ?F 1 - ?F 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT z=ereal 0..ereal 1. 1 / (1 - (1 - x * y) * z) =\n    ln (1 - (1 - x * y) * 1) / (x * y - 1) -\n    ln (1 - (1 - x * y) * 0) / (x * y - 1)", "proof (rule interval_integral_FTC_finite, goal_cases cont deriv)"], ["proof (state)\ngoal (2 subgoals):\n 1. continuous_on {min 0 1..max 0 1}\n     (\\<lambda>xa. 1 / (1 - (1 - x * y) * xa))\n 2. \\<And>z.\n       \\<lbrakk>min 0 1 \\<le> z; z \\<le> max 0 1\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>a.\n                              ln (1 - (1 - x * y) * a) /\n                              (x * y - 1)) has_vector_derivative\n                          1 / (1 - (1 - x * y) * z))\n                          (at z within {min 0 1..max 0 1})", "case cont"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. continuous_on {min 0 1..max 0 1}\n     (\\<lambda>xa. 1 / (1 - (1 - x * y) * xa))\n 2. \\<And>z.\n       \\<lbrakk>min 0 1 \\<le> z; z \\<le> max 0 1\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>a.\n                              ln (1 - (1 - x * y) * a) /\n                              (x * y - 1)) has_vector_derivative\n                          1 / (1 - (1 - x * y) * z))\n                          (at z within {min 0 1..max 0 1})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {min 0 1..max 0 1}\n     (\\<lambda>xa. 1 / (1 - (1 - x * y) * xa))", "using neq"], ["proof (prove)\nusing this:\n  ?u \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * ?u \\<noteq> 1\n\ngoal (1 subgoal):\n 1. continuous_on {min 0 1..max 0 1}\n     (\\<lambda>xa. 1 / (1 - (1 - x * y) * xa))", "by (intro continuous_intros) auto"], ["proof (state)\nthis:\n  continuous_on {min 0 1..max 0 1} (\\<lambda>xa. 1 / (1 - (1 - x * y) * xa))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>min 0 1 \\<le> z; z \\<le> max 0 1\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>a.\n                              ln (1 - (1 - x * y) * a) /\n                              (x * y - 1)) has_vector_derivative\n                          1 / (1 - (1 - x * y) * z))\n                          (at z within {min 0 1..max 0 1})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>min 0 1 \\<le> z; z \\<le> max 0 1\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>a.\n                              ln (1 - (1 - x * y) * a) /\n                              (x * y - 1)) has_vector_derivative\n                          1 / (1 - (1 - x * y) * z))\n                          (at z within {min 0 1..max 0 1})", "case (deriv z)"], ["proof (state)\nthis:\n  min 0 1 \\<le> z\n  z \\<le> max 0 1\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>min 0 1 \\<le> z; z \\<le> max 0 1\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>a.\n                              ln (1 - (1 - x * y) * a) /\n                              (x * y - 1)) has_vector_derivative\n                          1 / (1 - (1 - x * y) * z))\n                          (at z within {min 0 1..max 0 1})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a.\n         ln (1 - (1 - x * y) * a) / (x * y - 1)) has_vector_derivative\n     1 / (1 - (1 - x * y) * z))\n     (at z within {min 0 1..max 0 1})", "unfolding has_field_derivative_iff_has_vector_derivative [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a.\n         ln (1 - (1 - x * y) * a) / (x * y - 1)) has_real_derivative\n     1 / (1 - (1 - x * y) * z))\n     (at z within {min 0 1..max 0 1})", "by (insert less[of z] xy \\<open>x * y < 1\\<close> deriv)\n         (rule derivative_eq_intros refl | simp)+"], ["proof (state)\nthis:\n  ((\\<lambda>a.\n       ln (1 - (1 - x * y) * a) / (x * y - 1)) has_vector_derivative\n   1 / (1 - (1 - x * y) * z))\n   (at z within {min 0 1..max 0 1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LBINT z=ereal 0..ereal 1. 1 / (1 - (1 - x * y) * z) =\n  ln (1 - (1 - x * y) * 1) / (x * y - 1) -\n  ln (1 - (1 - x * y) * 0) / (x * y - 1)\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "also"], ["proof (state)\nthis:\n  LBINT z=ereal 0..ereal 1. 1 / (1 - (1 - x * y) * z) =\n  ln (1 - (1 - x * y) * 1) / (x * y - 1) -\n  ln (1 - (1 - x * y) * 0) / (x * y - 1)\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "have \"\\<dots> = -ln (x*y) / (1-x*y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (1 - (1 - x * y) * 1) / (x * y - 1) -\n    ln (1 - (1 - x * y) * 0) / (x * y - 1) =\n    - ln (x * y) / (1 - x * y)", "using \\<open>x * y < 1\\<close>"], ["proof (prove)\nusing this:\n  x * y < 1\n\ngoal (1 subgoal):\n 1. ln (1 - (1 - x * y) * 1) / (x * y - 1) -\n    ln (1 - (1 - x * y) * 0) / (x * y - 1) =\n    - ln (x * y) / (1 - x * y)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ln (1 - (1 - x * y) * 1) / (x * y - 1) -\n  ln (1 - (1 - x * y) * 0) / (x * y - 1) =\n  - ln (x * y) / (1 - x * y)\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "finally"], ["proof (chain)\npicking this:\n  LBINT z=ereal 0..ereal 1. 1 / (1 - (1 - x * y) * z) =\n  - ln (x * y) / (1 - x * y)", "show ?thesis"], ["proof (prove)\nusing this:\n  LBINT z=ereal 0..ereal 1. 1 / (1 - (1 - x * y) * z) =\n  - ln (x * y) / (1 - x * y)\n\ngoal (1 subgoal):\n 1. - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)", "by (simp add: zero_ereal_def one_ereal_def)"], ["proof (state)\nthis:\n  - ln (x * y) / (1 - x * y) = LBINT z=0..1. 1 / (1 - (1 - x * y) * z)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The first part we shall show is the integration by parts.\n\\<close>"], ["", "lemma beukers_aux_by_parts_aux:\n  assumes xz: \"x \\<in> {0<..<1}\" \"z \\<in> {0<..<1}\" and \"k \\<le> n\"\n  shows \"(LBINT y=0..1. Q n y * (1/(1-(1-x*y)*z))) =\n         (LBINT y=0..1. Q (n-k) y * (fact k * (x*z)^k / (1-(1-x*y)*z) ^ (k+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - k) y *\n                  (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))", "using assms(3)"], ["proof (prove)\nusing this:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - k) y *\n                  (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "case (Suc k)"], ["proof (state)\nthis:\n  k \\<le> n \\<Longrightarrow>\n  LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n  LBINT y=0..1. Q (n - k) y *\n                (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))\n  Suc k \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "note [derivative_intros] = DERIV_chain2[OF has_field_derivative_Gen_Shleg]"], ["proof (state)\nthis:\n  (?g has_real_derivative ?Db) (at ?x within ?s) \\<Longrightarrow>\n  ((\\<lambda>x. Gen_Shleg ?n1 ?k1 (?g x)) has_real_derivative\n   Gen_Shleg ?n1 (Suc ?k1) (?g ?x) * ?Db)\n   (at ?x within ?s)\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "define G where \"G = (\\<lambda>y. -fact k * (x*z)^k / (1-(1-x*y)*z) ^ (k+1))\""], ["proof (state)\nthis:\n  G = (\\<lambda>y. - fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "define g where \"g = (\\<lambda>y. fact (Suc k) * (x*z)^Suc k / (1-(1-x*y)*z) ^ (k+2))\""], ["proof (state)\nthis:\n  g =\n  (\\<lambda>y.\n      fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (k + 2))\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "have less: \"(1 - x * y) * z < 1\" and neq: \"(1 - x * y) * z \\<noteq> 1\"\n    if y: \"y \\<in> {0..1}\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * z < 1 &&& (1 - x * y) * z \\<noteq> 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "from y xz"], ["proof (chain)\npicking this:\n  y \\<in> {0..1}\n  x \\<in> {0<..<1}\n  z \\<in> {0<..<1}", "have \"x * y \\<le> x * 1\""], ["proof (prove)\nusing this:\n  y \\<in> {0..1}\n  x \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. x * y \\<le> x * 1", "by (intro mult_left_mono) auto"], ["proof (state)\nthis:\n  x * y \\<le> x * 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "also"], ["proof (state)\nthis:\n  x * y \\<le> x * 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "have \"\\<dots> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 1 < 1", "using xz"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. x * 1 < 1", "by simp"], ["proof (state)\nthis:\n  x * 1 < 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "finally"], ["proof (chain)\npicking this:\n  x * y < 1", "have \"(1 - x * y) * z \\<le> 1 * z\""], ["proof (prove)\nusing this:\n  x * y < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * z \\<le> 1 * z", "using xz y"], ["proof (prove)\nusing this:\n  x * y < 1\n  x \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n  y \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - x * y) * z \\<le> 1 * z", "by (intro mult_right_mono) auto"], ["proof (state)\nthis:\n  (1 - x * y) * z \\<le> 1 * z\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "also"], ["proof (state)\nthis:\n  (1 - x * y) * z \\<le> 1 * z\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "have \"\\<dots> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * z < 1", "using xz"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 * z < 1", "by simp"], ["proof (state)\nthis:\n  1 * z < 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * z < 1\n 2. (1 - x * y) * z \\<noteq> 1", "finally"], ["proof (chain)\npicking this:\n  (1 - x * y) * z < 1", "show \"(1 - x * y) * z < 1\""], ["proof (prove)\nusing this:\n  (1 - x * y) * z < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * z < 1", "by simp"], ["proof (state)\nthis:\n  (1 - x * y) * z < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * z \\<noteq> 1", "thus \"(1 - x * y) * z \\<noteq> 1\""], ["proof (prove)\nusing this:\n  (1 - x * y) * z < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * z \\<noteq> 1", "by simp"], ["proof (state)\nthis:\n  (1 - x * y) * z \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> {0..1} \\<Longrightarrow> (1 - x * ?y) * z < 1\n  ?y \\<in> {0..1} \\<Longrightarrow> (1 - x * ?y) * z \\<noteq> 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "have cont: \"continuous_on {0..1} g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} g", "using neq"], ["proof (prove)\nusing this:\n  ?y \\<in> {0..1} \\<Longrightarrow> (1 - x * ?y) * z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} g", "by (auto simp: g_def intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1} g\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "have deriv: \"(G has_real_derivative g y) (at y within {0..1})\" if y: \"y \\<in> {0..1}\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G has_real_derivative g y) (at y within {0..1})", "unfolding G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>y.\n         - fact k * (x * z) ^ k /\n         (1 - (1 - x * y) * z) ^ (k + 1)) has_real_derivative\n     g y)\n     (at y within {0..1})", "by (insert neq xz y, (rule derivative_eq_intros refl power_not_zero)+)\n       (auto simp: divide_simps g_def)"], ["proof (state)\nthis:\n  ?y \\<in> {0..1} \\<Longrightarrow>\n  (G has_real_derivative g ?y) (at ?y within {0..1})\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "have deriv2: \"(Q (n - Suc k) has_real_derivative Q (n - k) y) (at y within {0..1})\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q (n - Suc k) has_real_derivative Q (n - k) y) (at y within {0..1})", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k \\<le> n\n\ngoal (1 subgoal):\n 1. (Q (n - Suc k) has_real_derivative Q (n - k) y) (at y within {0..1})", "by (auto intro!: derivative_eq_intros simp: Suc_diff_Suc Q_def)"], ["proof (state)\nthis:\n  (Q (n - Suc k) has_real_derivative Q (n - k) ?y) (at ?y within {0..1})\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "have \"(LBINT y=0..1. Q (n-Suc k) y * (fact (Suc k) * (x*z)^Suc k / (1-(1-x*y)*z) ^ (k+2))) =\n        (LBINT y=0..1. Q (n-Suc k) y * g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. Q (n - Suc k) y *\n                  (fact (Suc k) * (x * z) ^ Suc k /\n                   (1 - (1 - x * y) * z) ^ (k + 2)) =\n    LBINT y=0..1. Q (n - Suc k) y * g y", "by (simp add: g_def)"], ["proof (state)\nthis:\n  LBINT y=0..1. Q (n - Suc k) y *\n                (fact (Suc k) * (x * z) ^ Suc k /\n                 (1 - (1 - x * y) * z) ^ (k + 2)) =\n  LBINT y=0..1. Q (n - Suc k) y * g y\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "also"], ["proof (state)\nthis:\n  LBINT y=0..1. Q (n - Suc k) y *\n                (fact (Suc k) * (x * z) ^ Suc k /\n                 (1 - (1 - x * y) * z) ^ (k + 2)) =\n  LBINT y=0..1. Q (n - Suc k) y * g y\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "have \"(LBINT y=0..1. Q (n-Suc k) y * g y) = -(LBINT y=0..1. Q (n-k) y * G y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. Q (n - Suc k) y * g y =\n    - (LBINT y=0..1. Q (n - k) y * G y)", "using Suc.prems deriv deriv2 cont"], ["proof (prove)\nusing this:\n  Suc k \\<le> n\n  ?y \\<in> {0..1} \\<Longrightarrow>\n  (G has_real_derivative g ?y) (at ?y within {0..1})\n  (Q (n - Suc k) has_real_derivative Q (n - k) ?y) (at ?y within {0..1})\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. Q (n - Suc k) y * g y =\n    - (LBINT y=0..1. Q (n - k) y * G y)", "by (subst interval_lebesgue_integral_by_parts_01[where f = \"Q (n-k)\" and G = G])\n       (auto intro!: continuous_intros simp: Q_def)"], ["proof (state)\nthis:\n  LBINT y=0..1. Q (n - Suc k) y * g y = - (LBINT y=0..1. Q (n - k) y * G y)\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "also"], ["proof (state)\nthis:\n  LBINT y=0..1. Q (n - Suc k) y * g y = - (LBINT y=0..1. Q (n - k) y * G y)\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "have \"\\<dots> = (LBINT y=0..1. Q (n-k) y * (fact k * (x*z)^k / (1-(1-x*y)*z) ^ (k+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (LBINT y=0..1. Q (n - k) y * G y) =\n    LBINT y=0..1. Q (n - k) y *\n                  (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))", "by (simp add: G_def flip: interval_lebesgue_integral_uminus)"], ["proof (state)\nthis:\n  - (LBINT y=0..1. Q (n - k) y * G y) =\n  LBINT y=0..1. Q (n - k) y *\n                (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                LBINT y=0..1. Q (n - k) y *\n                              (fact k * (x * z) ^ k /\n                               (1 - (1 - x * y) * z) ^ (k + 1));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n                         LBINT y=0..1. Q (n - Suc k) y *\n (fact (Suc k) * (x * z) ^ Suc k / (1 - (1 - x * y) * z) ^ (Suc k + 1))", "finally"], ["proof (chain)\npicking this:\n  LBINT y=0..1. Q (n - Suc k) y *\n                (fact (Suc k) * (x * z) ^ Suc k /\n                 (1 - (1 - x * y) * z) ^ (k + 2)) =\n  LBINT y=0..1. Q (n - k) y *\n                (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))", "show ?case"], ["proof (prove)\nusing this:\n  LBINT y=0..1. Q (n - Suc k) y *\n                (fact (Suc k) * (x * z) ^ Suc k /\n                 (1 - (1 - x * y) * z) ^ (k + 2)) =\n  LBINT y=0..1. Q (n - k) y *\n                (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - Suc k) y *\n                  (fact (Suc k) * (x * z) ^ Suc k /\n                   (1 - (1 - x * y) * z) ^ (Suc k + 1))", "using Suc"], ["proof (prove)\nusing this:\n  LBINT y=0..1. Q (n - Suc k) y *\n                (fact (Suc k) * (x * z) ^ Suc k /\n                 (1 - (1 - x * y) * z) ^ (k + 2)) =\n  LBINT y=0..1. Q (n - k) y *\n                (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))\n  k \\<le> n \\<Longrightarrow>\n  LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n  LBINT y=0..1. Q (n - k) y *\n                (fact k * (x * z) ^ k / (1 - (1 - x * y) * z) ^ (k + 1))\n  Suc k \\<le> n\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - Suc k) y *\n                  (fact (Suc k) * (x * z) ^ Suc k /\n                   (1 - (1 - x * y) * z) ^ (Suc k + 1))", "by simp"], ["proof (state)\nthis:\n  LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n  LBINT y=0..1. Q (n - Suc k) y *\n                (fact (Suc k) * (x * z) ^ Suc k /\n                 (1 - (1 - x * y) * z) ^ (Suc k + 1))\n\ngoal (1 subgoal):\n 1. 0 \\<le> n \\<Longrightarrow>\n    LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT y=0..1. Q (n - 0) y *\n                  (fact 0 * (x * z) ^ 0 / (1 - (1 - x * y) * z) ^ (0 + 1))", "qed auto"], ["", "lemma beukers_aux_by_parts:\n  assumes xz: \"x \\<in> {0<..<1}\" \"z \\<in> {0<..<1}\"\n  shows \"(LBINT y=0..1. P y / (1-(1-x*y)*z)) =\n         (LBINT y=0..1. (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z) ^ (n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. P y / (1 - (1 - x * y) * z) =\n    LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT y=0..1. P y / (1 - (1 - x * y) * z) =\n    LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "have \"(LBINT y=0..1. P y * (1/(1-(1-x*y)*z))) =\n           1 / fact n * (LBINT y=0..1. Q n y * (1/(1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. P y * (1 / (1 - (1 - x * y) * z)) =\n    1 / fact n * (LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)))", "unfolding interval_lebesgue_integral_mult_right [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. P y * (1 / (1 - (1 - x * y) * z)) =\n    LBINT xa=0..1. 1 / fact n * (Q n xa * (1 / (1 - (1 - x * xa) * z)))", "by (simp add: P_def Q_def Shleg_altdef)"], ["proof (state)\nthis:\n  LBINT y=0..1. P y * (1 / (1 - (1 - x * y) * z)) =\n  1 / fact n * (LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)))\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. P y / (1 - (1 - x * y) * z) =\n    LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT y=0..1. P y * (1 / (1 - (1 - x * y) * z)) =\n  1 / fact n * (LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z)))\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. P y / (1 - (1 - x * y) * z) =\n    LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "have \"\\<dots> = (LBINT y=0..1. (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z) ^ (n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / fact n * (LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z))) =\n    LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "by (subst beukers_aux_by_parts_aux[OF assms, of n], simp,\n        subst interval_lebesgue_integral_mult_right [symmetric])\n       (simp add: Q_def mult_ac Gen_Shleg_0_left power_mult_distrib)"], ["proof (state)\nthis:\n  1 / fact n * (LBINT y=0..1. Q n y * (1 / (1 - (1 - x * y) * z))) =\n  LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. P y / (1 - (1 - x * y) * z) =\n    LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "finally"], ["proof (chain)\npicking this:\n  LBINT y=0..1. P y * (1 / (1 - (1 - x * y) * z)) =\n  LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  LBINT y=0..1. P y * (1 / (1 - (1 - x * y) * z)) =\n  LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. P y / (1 - (1 - x * y) * z) =\n    LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "by simp"], ["proof (state)\nthis:\n  LBINT y=0..1. P y / (1 - (1 - x * y) * z) =\n  LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We then get the following by applying the integration by parts to \\<open>y\\<close>:\n\\<close>"], ["", "lemma beukers_aux_integral_transform1:\n  fixes z :: real\n  assumes z: \"z \\<in> {0<..<1}\"\n  shows   \"(LBINT (x,y):D. P x * P y / (1-(1-x*y)*z)) =\n           (LBINT (x,y):D. P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have cbox: \"cbox (0, 0) (1, 1) = ({0..1} \\<times> {0..1} :: (real \\<times> real) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (0, 0) (1, 1) = {0..1} \\<times> {0..1}", "by (auto simp: cbox_def Basis_prod_def inner_prod_def)"], ["proof (state)\nthis:\n  cbox (0, 0) (1, 1) = {0..1} \\<times> {0..1}\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have box: \"box (0, 0) (1, 1) = ({0<..<1} \\<times> {0<..<1} :: (real \\<times> real) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. box (0, 0) (1, 1) = {0<..<1} \\<times> {0<..<1}", "by (auto simp: box_def Basis_prod_def inner_prod_def)"], ["proof (state)\nthis:\n  box (0, 0) (1, 1) = {0<..<1} \\<times> {0<..<1}\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have \"set_integrable lborel (cbox (0,0) (1,1))\n          (\\<lambda>(x, y). P x * P y / (1 - (1 - x * y) * z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox (0, 0) (1, 1))\n     (\\<lambda>(x, y). P x * P y / (1 - (1 - x * y) * z))", "unfolding lborel_prod case_prod_unfold P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox (0, 0) (1, 1))\n     (\\<lambda>p.\n         Shleg n (fst p) * Shleg n (snd p) / (1 - (1 - fst p * snd p) * z))", "proof (intro continuous_on_imp_set_integrable_cbox continuous_intros ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * z \\<noteq> 0", "fix p :: \"real \\<times> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * z \\<noteq> 0", "assume p: \"p \\<in> cbox (0, 0) (1, 1)\""], ["proof (state)\nthis:\n  p \\<in> cbox (0, 0) (1, 1)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * z \\<noteq> 0", "have \"(1 - fst p * snd p) * z \\<le> 1 * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * z \\<le> 1 * z", "using mult_mono[of \"fst p\" 1 \"snd p\" 1] p z cbox"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst p \\<le> 1; snd p \\<le> 1; 0 \\<le> 1; 0 \\<le> snd p\\<rbrakk>\n  \\<Longrightarrow> fst p * snd p \\<le> 1 * 1\n  p \\<in> cbox (0, 0) (1, 1)\n  z \\<in> {0<..<1}\n  cbox (0, 0) (1, 1) = {0..1} \\<times> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * z \\<le> 1 * z", "by (intro mult_right_mono) auto"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * z \\<le> 1 * z\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * z \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * z \\<le> 1 * z\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * z \\<noteq> 0", "have \"\\<dots> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * z < 1", "using z"], ["proof (prove)\nusing this:\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 * z < 1", "by simp"], ["proof (state)\nthis:\n  1 * z < 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * z \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (1 - fst p * snd p) * z < 1", "show \"1 - (1 - fst p * snd p) * z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (1 - fst p * snd p) * z < 1\n\ngoal (1 subgoal):\n 1. 1 - (1 - fst p * snd p) * z \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  1 - (1 - fst p * snd p) * z \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_integrable lborel (cbox (0, 0) (1, 1))\n   (\\<lambda>(x, y). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "hence integrable: \"set_integrable lborel (box (0,0) (1,1))\n          (\\<lambda>(x, y). P x * P y / (1 - (1 - x * y) * z))\""], ["proof (prove)\nusing this:\n  set_integrable lborel (cbox (0, 0) (1, 1))\n   (\\<lambda>(x, y). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. set_integrable lborel (box (0, 0) (1, 1))\n     (\\<lambda>(x, y). P x * P y / (1 - (1 - x * y) * z))", "by (rule set_integrable_subset) (auto simp:  box simp flip: borel_prod)"], ["proof (state)\nthis:\n  set_integrable lborel (box (0, 0) (1, 1))\n   (\\<lambda>(x, y). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have \"set_integrable lborel (cbox (0,0) (1,1))\n          (\\<lambda>(x, y). P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox (0, 0) (1, 1))\n     (\\<lambda>(x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "unfolding lborel_prod case_prod_unfold P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox (0, 0) (1, 1))\n     (\\<lambda>p.\n         Shleg n (fst p) * (fst p * snd p * z) ^ n * (1 - snd p) ^ n /\n         (1 - (1 - fst p * snd p) * z) ^ (n + 1))", "proof (intro continuous_on_imp_set_integrable_cbox continuous_intros ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0", "fix p :: \"real \\<times> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0", "assume p: \"p \\<in> cbox (0, 0) (1, 1)\""], ["proof (state)\nthis:\n  p \\<in> cbox (0, 0) (1, 1)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0", "have \"(1 - fst p * snd p) * z \\<le> 1 * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * z \\<le> 1 * z", "using mult_mono[of \"fst p\" 1 \"snd p\" 1] p z cbox"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst p \\<le> 1; snd p \\<le> 1; 0 \\<le> 1; 0 \\<le> snd p\\<rbrakk>\n  \\<Longrightarrow> fst p * snd p \\<le> 1 * 1\n  p \\<in> cbox (0, 0) (1, 1)\n  z \\<in> {0<..<1}\n  cbox (0, 0) (1, 1) = {0..1} \\<times> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * z \\<le> 1 * z", "by (intro mult_right_mono) auto"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * z \\<le> 1 * z\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * z \\<le> 1 * z\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0", "have \"\\<dots> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * z < 1", "using z"], ["proof (prove)\nusing this:\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 * z < 1", "by simp"], ["proof (state)\nthis:\n  1 * z < 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (1 - fst p * snd p) * z < 1", "show \"(1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (1 - fst p * snd p) * z < 1\n\ngoal (1 subgoal):\n 1. (1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  (1 - (1 - fst p * snd p) * z) ^ (n + 1) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_integrable lborel (cbox (0, 0) (1, 1))\n   (\\<lambda>(x, y).\n       P x * (x * y * z) ^ n * (1 - y) ^ n /\n       (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "hence integrable': \"set_integrable lborel D\n          (\\<lambda>(x, y). P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1))\""], ["proof (prove)\nusing this:\n  set_integrable lborel (cbox (0, 0) (1, 1))\n   (\\<lambda>(x, y).\n       P x * (x * y * z) ^ n * (1 - y) ^ n /\n       (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "by (rule set_integrable_subset) (auto simp: box D_def simp flip: borel_prod)"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>(x, y).\n       P x * (x * y * z) ^ n * (1 - y) ^ n /\n       (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have \"(LBINT (x,y):D. P x * P y / (1-(1-x*y)*z)) =\n          (LBINT x=0..1. (LBINT y=0..1. P x * P y / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT x=0..1. (LBINT y=0..1. P x * P y / (1 - (1 - x * y) * z))", "unfolding D_def lborel_prod [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>(x, y)\\<in>{0<..<1} \\<times> {0<..<1}.\n               (P x * P y / (1 - (1 - x * y) * z))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel =\n    LBINT x=0..1. (LBINT y=0..1. P x * P y / (1 - (1 - x * y) * z))", "using box integrable"], ["proof (prove)\nusing this:\n  box (0, 0) (1, 1) = {0<..<1} \\<times> {0<..<1}\n  set_integrable lborel (box (0, 0) (1, 1))\n   (\\<lambda>(x, y). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. \\<integral>(x, y)\\<in>{0<..<1} \\<times> {0<..<1}.\n               (P x * P y / (1 - (1 - x * y) * z))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel =\n    LBINT x=0..1. (LBINT y=0..1. P x * P y / (1 - (1 - x * y) * z))", "by (subst lborel_pair.set_integral_fst') (simp_all add: interval_integral_Ioo lborel_prod)"], ["proof (state)\nthis:\n  LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n  LBINT x=0..1. (LBINT y=0..1. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n  LBINT x=0..1. (LBINT y=0..1. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have \"\\<dots> = (LBINT x=0..1. P x * (LBINT y=0..1. P y / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. (LBINT y=0..1. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT x=0..1. P x * (LBINT y=0..1. P y / (1 - (1 - x * y) * z))", "by (subst interval_lebesgue_integral_mult_right [symmetric]) (simp add: mult_ac)"], ["proof (state)\nthis:\n  LBINT x=0..1. (LBINT y=0..1. P x * P y / (1 - (1 - x * y) * z)) =\n  LBINT x=0..1. P x * (LBINT y=0..1. P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT x=0..1. (LBINT y=0..1. P x * P y / (1 - (1 - x * y) * z)) =\n  LBINT x=0..1. P x * (LBINT y=0..1. P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have \"\\<dots> = (LBINT x=0..1. P x * (LBINT y=0..1. (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. P x * (LBINT y=0..1. P y / (1 - (1 - x * y) * z)) =\n    LBINT x=0..1. P x *\n                  (LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                                 (1 - (1 - x * y) * z) ^ (n + 1))", "using z"], ["proof (prove)\nusing this:\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. P x * (LBINT y=0..1. P y / (1 - (1 - x * y) * z)) =\n    LBINT x=0..1. P x *\n                  (LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                                 (1 - (1 - x * y) * z) ^ (n + 1))", "by (intro interval_lebesgue_integral_lborel_01_cong, subst beukers_aux_by_parts) auto"], ["proof (state)\nthis:\n  LBINT x=0..1. P x * (LBINT y=0..1. P y / (1 - (1 - x * y) * z)) =\n  LBINT x=0..1. P x *\n                (LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                               (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT x=0..1. P x * (LBINT y=0..1. P y / (1 - (1 - x * y) * z)) =\n  LBINT x=0..1. P x *\n                (LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                               (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have \"\\<dots> = (LBINT x=0..1. (LBINT y=0..1. P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. P x *\n                  (LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                                 (1 - (1 - x * y) * z) ^ (n + 1)) =\n    LBINT x=0..1. (LBINT y=0..1. P x * (x * y * z) ^ n * (1 - y) ^ n /\n                                 (1 - (1 - x * y) * z) ^ (n + 1))", "by (subst interval_lebesgue_integral_mult_right [symmetric]) (simp add: mult_ac)"], ["proof (state)\nthis:\n  LBINT x=0..1. P x *\n                (LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                               (1 - (1 - x * y) * z) ^ (n + 1)) =\n  LBINT x=0..1. (LBINT y=0..1. P x * (x * y * z) ^ n * (1 - y) ^ n /\n                               (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT x=0..1. P x *\n                (LBINT y=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                               (1 - (1 - x * y) * z) ^ (n + 1)) =\n  LBINT x=0..1. (LBINT y=0..1. P x * (x * y * z) ^ n * (1 - y) ^ n /\n                               (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "have \"\\<dots> = (LBINT (x,y):D. P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. (LBINT y=0..1. P x * (x * y * z) ^ n * (1 - y) ^ n /\n                                 (1 - (1 - x * y) * z) ^ (n + 1)) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "unfolding D_def lborel_prod [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. (LBINT y=0..1. P x * (x * y * z) ^ n * (1 - y) ^ n /\n                                 (1 - (1 - x * y) * z) ^ (n + 1)) =\n    \\<integral>(x, y)\\<in>{0<..<1} \\<times> {0<..<1}.\n               (P x * (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel", "using box integrable'"], ["proof (prove)\nusing this:\n  box (0, 0) (1, 1) = {0<..<1} \\<times> {0<..<1}\n  set_integrable lborel D\n   (\\<lambda>(x, y).\n       P x * (x * y * z) ^ n * (1 - y) ^ n /\n       (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (LBINT y=0..1. P x * (x * y * z) ^ n * (1 - y) ^ n /\n                                 (1 - (1 - x * y) * z) ^ (n + 1)) =\n    \\<integral>(x, y)\\<in>{0<..<1} \\<times> {0<..<1}.\n               (P x * (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel", "by (subst lborel_pair.set_integral_fst')\n       (simp_all add: D_def interval_integral_Ioo lborel_prod)"], ["proof (state)\nthis:\n  LBINT x=0..1. (LBINT y=0..1. P x * (x * y * z) ^ n * (1 - y) ^ n /\n                               (1 - (1 - x * y) * z) ^ (n + 1)) =\n  LBINT (x, y):D.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "finally"], ["proof (chain)\npicking this:\n  LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n  LBINT (x, y):D.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "show \"(LBINT (x,y):D. P x * P y / (1-(1-x*y)*z)) = \\<dots>\""], ["proof (prove)\nusing this:\n  LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n  LBINT (x, y):D.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n    LBINT (x, y):D.\n       P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "."], ["proof (state)\nthis:\n  LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z) =\n  LBINT (x, y):D.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We then change variables for \\<open>z\\<close>:\n\\<close>"], ["", "lemma beukers_aux_integral_transform2:\n  assumes xy: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\"\n  shows \"(LBINT z=0..1. (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)) =\n         (LBINT w=0..1. (1-w)^n * (1-y)^n / (1-(1-x*y)*w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "define g where \"g = (\\<lambda>z. (1 - z) / (1-(1-x*y)*z))\""], ["proof (state)\nthis:\n  g = (\\<lambda>z. (1 - z) / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "define g' where \"g' = (\\<lambda>z. -x*y / (1-(1-x*y)*z)^2)\""], ["proof (state)\nthis:\n  g' = (\\<lambda>z. - x * y / (1 - (1 - x * y) * z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have \"x * y < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y < 1", "using mult_strict_mono[of x 1 y 1] xy"], ["proof (prove)\nusing this:\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. x * y < 1", "by simp"], ["proof (state)\nthis:\n  x * y < 1\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have less: \"(1 - (x * y)) * w < 1\" and neq: \"(1 - (x * y)) * w \\<noteq> 1\"\n    if w: \"w \\<in> {0..1}\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * w < 1 &&& (1 - x * y) * w \\<noteq> 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (1 - x * y) * w < 1\n 2. (1 - x * y) * w \\<noteq> 1", "have \"(1 - (x * y)) * w \\<le> (1 - (x * y)) * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * w \\<le> (1 - x * y) * 1", "using w \\<open>x * y < 1\\<close>"], ["proof (prove)\nusing this:\n  w \\<in> {0..1}\n  x * y < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * w \\<le> (1 - x * y) * 1", "by (intro mult_left_mono) auto"], ["proof (state)\nthis:\n  (1 - x * y) * w \\<le> (1 - x * y) * 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * w < 1\n 2. (1 - x * y) * w \\<noteq> 1", "also"], ["proof (state)\nthis:\n  (1 - x * y) * w \\<le> (1 - x * y) * 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * w < 1\n 2. (1 - x * y) * w \\<noteq> 1", "have \"\\<dots> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * 1 < 1", "using xy"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (1 - x * y) * 1 < 1", "by simp"], ["proof (state)\nthis:\n  (1 - x * y) * 1 < 1\n\ngoal (2 subgoals):\n 1. (1 - x * y) * w < 1\n 2. (1 - x * y) * w \\<noteq> 1", "finally"], ["proof (chain)\npicking this:\n  (1 - x * y) * w < 1", "show \"(1 - (x * y)) * w < 1\""], ["proof (prove)\nusing this:\n  (1 - x * y) * w < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * w < 1", "."], ["proof (state)\nthis:\n  (1 - x * y) * w < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * w \\<noteq> 1", "thus \"(1 - (x * y)) * w \\<noteq> 1\""], ["proof (prove)\nusing this:\n  (1 - x * y) * w < 1\n\ngoal (1 subgoal):\n 1. (1 - x * y) * w \\<noteq> 1", "by simp"], ["proof (state)\nthis:\n  (1 - x * y) * w \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?w \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * ?w < 1\n  ?w \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * ?w \\<noteq> 1\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have deriv: \"(g has_real_derivative g' w) (at w within {0..1})\" if \"w \\<in> {0..1}\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative g' w) (at w within {0..1})", "unfolding g_def g'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. (1 - z) / (1 - (1 - x * y) * z)) has_real_derivative\n     - x * y / (1 - (1 - x * y) * w)\\<^sup>2)\n     (at w within {0..1})", "apply (insert that xy neq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> {0..1}; x \\<in> {0<..<1}; y \\<in> {0<..<1};\n     \\<And>w.\n        w \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * w \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>z.\n                           (1 - z) /\n                           (1 - (1 - x * y) * z)) has_real_derivative\n                       - x * y / (1 - (1 - x * y) * w)\\<^sup>2)\n                       (at w within {0..1})", "apply (rule derivative_eq_intros refl)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<in> {0..1}; x \\<in> {0<..<1}; y \\<in> {0<..<1};\n     \\<And>w.\n        w \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * w \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 1 - (1 - x * y) * w \\<noteq> 0\n 2. \\<lbrakk>w \\<in> {0..1}; x \\<in> {0<..<1}; y \\<in> {0<..<1};\n     \\<And>w.\n        w \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * w \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> ((0 - 1) * (1 - (1 - x * y) * w) -\n                       (1 - w) * (0 - (0 * w + 1 * (1 - x * y)))) /\n                      ((1 - (1 - x * y) * w) * (1 - (1 - x * y) * w)) =\n                      - x * y / (1 - (1 - x * y) * w)\\<^sup>2", "apply (simp_all add: divide_simps power2_eq_square)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> w \\<and> w \\<le> 1; 0 < x \\<and> x < 1;\n     0 < y \\<and> y < 1;\n     \\<And>w.\n        0 \\<le> w \\<and> w \\<le> 1 \\<Longrightarrow>\n        (1 - x * y) * w \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> (1 - x * y) * w - 1 - (1 - w) * (x * y - 1) =\n                      - (x * y)", "apply (auto simp: algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?w \\<in> {0..1} \\<Longrightarrow>\n  (g has_real_derivative g' ?w) (at ?w within {0..1})\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have \"continuous_on {0..1} (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))", "using neq"], ["proof (prove)\nusing this:\n  ?w \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * ?w \\<noteq> 1\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "moreover"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have \"g ` {0..1} \\<subseteq> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` {0..1} \\<subseteq> {0..1}", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> {0..1} \\<Longrightarrow> g xa \\<in> {0..1}", "fix w :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> {0..1} \\<Longrightarrow> g xa \\<in> {0..1}", "assume w: \"w \\<in> {0..1}\""], ["proof (state)\nthis:\n  w \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> {0..1} \\<Longrightarrow> g xa \\<in> {0..1}", "have \"(1 - x * y) * w \\<le> 1 * w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - x * y) * w \\<le> 1 * w", "using \\<open>x * y < 1\\<close> xy w"], ["proof (prove)\nusing this:\n  x * y < 1\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  w \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - x * y) * w \\<le> 1 * w", "by (intro mult_right_mono) auto"], ["proof (state)\nthis:\n  (1 - x * y) * w \\<le> 1 * w\n\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> {0..1} \\<Longrightarrow> g xa \\<in> {0..1}", "thus \"g w \\<in> {0..1}\""], ["proof (prove)\nusing this:\n  (1 - x * y) * w \\<le> 1 * w\n\ngoal (1 subgoal):\n 1. g w \\<in> {0..1}", "unfolding g_def"], ["proof (prove)\nusing this:\n  (1 - x * y) * w \\<le> 1 * w\n\ngoal (1 subgoal):\n 1. (1 - w) / (1 - (1 - x * y) * w) \\<in> {0..1}", "using less[of w] w"], ["proof (prove)\nusing this:\n  (1 - x * y) * w \\<le> 1 * w\n  w \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * w < 1\n  w \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - w) / (1 - (1 - x * y) * w) \\<in> {0..1}", "by (auto simp: divide_simps)"], ["proof (state)\nthis:\n  g w \\<in> {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g ` {0..1} \\<subseteq> {0..1}\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "ultimately"], ["proof (chain)\npicking this:\n  continuous_on {0..1} (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))\n  g ` {0..1} \\<subseteq> {0..1}", "have cont: \"continuous_on (g ` {0..1}) (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))\""], ["proof (prove)\nusing this:\n  continuous_on {0..1} (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))\n  g ` {0..1} \\<subseteq> {0..1}\n\ngoal (1 subgoal):\n 1. continuous_on (g ` {0..1})\n     (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))", "by (rule continuous_on_subset)"], ["proof (state)\nthis:\n  continuous_on (g ` {0..1})\n   (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have cont': \"continuous_on {0..1} g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} g'", "using neq"], ["proof (prove)\nusing this:\n  ?w \\<in> {0..1} \\<Longrightarrow> (1 - x * y) * ?w \\<noteq> 1\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} g'", "by (auto simp: g'_def intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1} g'\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have \"(LBINT w=0..1. (1-w)^n * (1-y)^n / (1-(1-x*y)*w)) =\n          (1-y)^n * (LBINT w=0..1. (1 - w)^n / (1-(1-x*y)*w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    (1 - y) ^ n * (LBINT w=0..1. (1 - w) ^ n / (1 - (1 - x * y) * w))", "unfolding interval_lebesgue_integral_mult_right [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT xa=0..1. (1 - y) ^ n * ((1 - xa) ^ n / (1 - (1 - x * y) * xa))", "by (simp add: algebra_simps power_mult_distrib)"], ["proof (state)\nthis:\n  LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  (1 - y) ^ n * (LBINT w=0..1. (1 - w) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "also"], ["proof (state)\nthis:\n  LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  (1 - y) ^ n * (LBINT w=0..1. (1 - w) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have \"(LBINT w=0..1. (1 - w)^n / (1-(1-x*y)*w)) =\n        -(LBINT w=g 0..g 1. (1 - w)^n / (1-(1-x*y)*w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w=0..1. (1 - w) ^ n / (1 - (1 - x * y) * w) =\n    - (LBINT w=ereal\n                (g 0)..ereal (g 1). (1 - w) ^ n / (1 - (1 - x * y) * w))", "by (subst interval_integral_endpoints_reverse)(simp add: g_def zero_ereal_def one_ereal_def)"], ["proof (state)\nthis:\n  LBINT w=0..1. (1 - w) ^ n / (1 - (1 - x * y) * w) =\n  - (LBINT w=ereal (g 0)..ereal (g 1). (1 - w) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "also"], ["proof (state)\nthis:\n  LBINT w=0..1. (1 - w) ^ n / (1 - (1 - x * y) * w) =\n  - (LBINT w=ereal (g 0)..ereal (g 1). (1 - w) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have \"(LBINT w=g 0..g 1. (1 - w)^n / (1-(1-x*y)*w)) =\n             (LBINT w=0..1. g' w * ((1 - g w) ^ n / (1 - (1-x*y) * g w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w=ereal (g 0)..ereal (g 1). (1 - w) ^ n / (1 - (1 - x * y) * w) =\n    LBINT w=0..1. g' w * ((1 - g w) ^ n / (1 - (1 - x * y) * g w))", "using deriv cont cont'"], ["proof (prove)\nusing this:\n  ?w \\<in> {0..1} \\<Longrightarrow>\n  (g has_real_derivative g' ?w) (at ?w within {0..1})\n  continuous_on (g ` {0..1})\n   (\\<lambda>xa. (1 - xa) ^ n / (1 - (1 - x * y) * xa))\n  continuous_on {0..1} g'\n\ngoal (1 subgoal):\n 1. LBINT w=ereal (g 0)..ereal (g 1). (1 - w) ^ n / (1 - (1 - x * y) * w) =\n    LBINT w=0..1. g' w * ((1 - g w) ^ n / (1 - (1 - x * y) * g w))", "by (subst interval_integral_substitution_finite [symmetric, where g = g and g' = g'])\n       (simp_all add: zero_ereal_def one_ereal_def)"], ["proof (state)\nthis:\n  LBINT w=ereal (g 0)..ereal (g 1). (1 - w) ^ n / (1 - (1 - x * y) * w) =\n  LBINT w=0..1. g' w * ((1 - g w) ^ n / (1 - (1 - x * y) * g w))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "also"], ["proof (state)\nthis:\n  LBINT w=ereal (g 0)..ereal (g 1). (1 - w) ^ n / (1 - (1 - x * y) * w) =\n  LBINT w=0..1. g' w * ((1 - g w) ^ n / (1 - (1 - x * y) * g w))\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have \"-\\<dots> = (LBINT z=0..1. ((x*y)^n * z^n / (1-(1-x*y)*z)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (LBINT w=0..1. g' w * ((1 - g w) ^ n / (1 - (1 - x * y) * g w))) =\n    LBINT z=0..1. (x * y) ^ n * z ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "unfolding interval_lebesgue_integral_uminus [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT xa=0..1. - (g' xa * ((1 - g xa) ^ n / (1 - (1 - x * y) * g xa))) =\n    LBINT z=0..1. (x * y) ^ n * z ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "using xy"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. LBINT xa=0..1. - (g' xa * ((1 - g xa) ^ n / (1 - (1 - x * y) * g xa))) =\n    LBINT z=0..1. (x * y) ^ n * z ^ n / (1 - (1 - x * y) * z) ^ (n + 1)", "apply (intro interval_lebesgue_integral_lborel_01_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1};\n        xa \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> - (g' xa *\n                            ((1 - g xa) ^ n / (1 - (1 - x * y) * g xa))) =\n                         (x * y) ^ n * xa ^ n /\n                         (1 - (1 - x * y) * xa) ^ (n + 1)", "apply (simp add: divide_simps g_def g'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>0 < x \\<and> x < 1; 0 < y \\<and> y < 1;\n        0 < xa \\<and> xa < 1\\<rbrakk>\n       \\<Longrightarrow> (1 - (1 - x * y) * xa \\<noteq>\n                          (1 - x * y) * (1 - xa) \\<longrightarrow>\n                          (1 - x * y) * xa \\<noteq> 1 \\<and>\n                          ((1 - x * y) * xa = 1 \\<longrightarrow>\n                           n = 0) \\<longrightarrow>\n                          x *\n                          (y *\n                           ((xa - (1 - x * y) * xa) ^ n *\n                            ((1 - (1 - x * y) * xa) *\n                             (1 - (1 - x * y) * xa)))) =\n                          x ^ n * y ^ n * xa ^ n *\n                          ((1 - (1 - x * y) * xa)\\<^sup>2 *\n                           (1 - (1 - x * y) * xa -\n                            (1 - x * y) * (1 - xa)))) \\<and>\n                         (1 - (1 - x * y) * xa =\n                          (1 - x * y) * (1 - xa) \\<longrightarrow>\n                          (1 - x * y) * xa = 1 \\<or>\n                          (1 - x * y) * xa = 1 \\<and> 0 < n)", "apply (auto simp: algebra_simps power_mult_distrib power2_eq_square)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - (LBINT w=0..1. g' w * ((1 - g w) ^ n / (1 - (1 - x * y) * g w))) =\n  LBINT z=0..1. (x * y) ^ n * z ^ n / (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "also"], ["proof (state)\nthis:\n  - (LBINT w=0..1. g' w * ((1 - g w) ^ n / (1 - (1 - x * y) * g w))) =\n  LBINT z=0..1. (x * y) ^ n * z ^ n / (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "have \"(1-y)^n * \\<dots> = (LBINT z=0..1. (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - y) ^ n *\n    (LBINT z=0..1. (x * y) ^ n * z ^ n / (1 - (1 - x * y) * z) ^ (n + 1)) =\n    LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "unfolding interval_lebesgue_integral_mult_right [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT xa=0..1. (1 - y) ^ n *\n                   ((x * y) ^ n * xa ^ n /\n                    (1 - (1 - x * y) * xa) ^ (n + 1)) =\n    LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1)", "by (simp add: algebra_simps power_mult_distrib)"], ["proof (state)\nthis:\n  (1 - y) ^ n *\n  (LBINT z=0..1. (x * y) ^ n * z ^ n / (1 - (1 - x * y) * z) ^ (n + 1)) =\n  LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "finally"], ["proof (chain)\npicking this:\n  LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1)", "show \"\\<dots> = (LBINT w=0..1. (1-w)^n * (1-y)^n / (1-(1-x*y)*w))\""], ["proof (prove)\nusing this:\n  LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                  (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", ".."], ["proof (state)\nthis:\n  LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                (1 - (1 - x * y) * z) ^ (n + 1) =\n  LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Lastly, we apply the same integration by parts to \\<open>x\\<close>:\n\\<close>"], ["", "lemma beukers_aux_integral_transform3:\n  assumes w: \"w \\<in> {0<..<1}\"\n  shows   \"(LBINT (x,y):D. P x * (1-y)^n / (1-(1-x*y)*w)) =\n           (LBINT (x,y):D. (1-y)^n * (x*y*w)^n * (1-x)^n / (1-(1-x*y)*w)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have cbox: \"cbox (0, 0) (1, 1) = ({0..1} \\<times> {0..1} :: (real \\<times> real) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (0, 0) (1, 1) = {0..1} \\<times> {0..1}", "by (auto simp: cbox_def Basis_prod_def inner_prod_def)"], ["proof (state)\nthis:\n  cbox (0, 0) (1, 1) = {0..1} \\<times> {0..1}\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have box: \"box (0, 0) (1, 1) = ({0<..<1} \\<times> {0<..<1} :: (real \\<times> real) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. box (0, 0) (1, 1) = {0<..<1} \\<times> {0<..<1}", "by (auto simp: box_def Basis_prod_def inner_prod_def)"], ["proof (state)\nthis:\n  box (0, 0) (1, 1) = {0<..<1} \\<times> {0<..<1}\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have \"set_integrable lborel\n          (cbox (0,0) (1,1)) (\\<lambda>(x,y). P x * (1-y)^n/(1-(1-x*y)*w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox (0, 0) (1, 1))\n     (\\<lambda>(x, y). P x * (1 - y) ^ n / (1 - (1 - x * y) * w))", "unfolding lborel_prod case_prod_unfold P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox (0, 0) (1, 1))\n     (\\<lambda>p.\n         Shleg n (fst p) * (1 - snd p) ^ n / (1 - (1 - fst p * snd p) * w))", "proof (intro continuous_on_imp_set_integrable_cbox continuous_intros ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * w \\<noteq> 0", "fix p :: \"real \\<times> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * w \\<noteq> 0", "assume p: \"p \\<in> cbox (0,0) (1,1)\""], ["proof (state)\nthis:\n  p \\<in> cbox (0, 0) (1, 1)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * w \\<noteq> 0", "have \"(1 - fst p * snd p) * w \\<le> 1 * w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * w \\<le> 1 * w", "using p cbox w"], ["proof (prove)\nusing this:\n  p \\<in> cbox (0, 0) (1, 1)\n  cbox (0, 0) (1, 1) = {0..1} \\<times> {0..1}\n  w \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * w \\<le> 1 * w", "by (intro mult_right_mono) auto"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * w \\<le> 1 * w\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * w \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * w \\<le> 1 * w\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * w \\<noteq> 0", "have \"\\<dots> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * w < 1", "using w"], ["proof (prove)\nusing this:\n  w \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 * w < 1", "by simp"], ["proof (state)\nthis:\n  1 * w < 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * w \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (1 - fst p * snd p) * w < 1", "have \"(1 - fst p * snd p) * w < 1\""], ["proof (prove)\nusing this:\n  (1 - fst p * snd p) * w < 1\n\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * w < 1", "by simp"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * w < 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       1 - (1 - fst p * snd p) * w \\<noteq> 0", "thus \"1 - (1 - fst p * snd p) * w \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (1 - fst p * snd p) * w < 1\n\ngoal (1 subgoal):\n 1. 1 - (1 - fst p * snd p) * w \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  1 - (1 - fst p * snd p) * w \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_integrable lborel (cbox (0, 0) (1, 1))\n   (\\<lambda>(x, y). P x * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "hence integrable: \"set_integrable lborel D (\\<lambda>(x,y). P x * (1-y)^n/(1-(1-x*y)*w))\""], ["proof (prove)\nusing this:\n  set_integrable lborel (cbox (0, 0) (1, 1))\n   (\\<lambda>(x, y). P x * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). P x * (1 - y) ^ n / (1 - (1 - x * y) * w))", "by (rule set_integrable_subset) (auto simp: D_def simp flip: borel_prod)"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>(x, y). P x * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have \"set_integrable lborel (cbox (0,0) (1,1))\n          (\\<lambda>(x,y). (1-y)^n * (x*y*w)^n * (1-x)^n / (1-(1-x*y)*w)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox (0, 0) (1, 1))\n     (\\<lambda>(x, y).\n         (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n         (1 - (1 - x * y) * w) ^ (n + 1))", "unfolding lborel_prod case_prod_unfold P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (cbox (0, 0) (1, 1))\n     (\\<lambda>p.\n         (1 - snd p) ^ n * (fst p * snd p * w) ^ n * (1 - fst p) ^ n /\n         (1 - (1 - fst p * snd p) * w) ^ (n + 1))", "proof (intro continuous_on_imp_set_integrable_cbox continuous_intros ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0", "fix p :: \"real \\<times> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0", "assume p: \"p \\<in> cbox (0,0) (1,1)\""], ["proof (state)\nthis:\n  p \\<in> cbox (0, 0) (1, 1)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0", "have \"(1 - fst p * snd p) * w \\<le> 1 * w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * w \\<le> 1 * w", "using p cbox w"], ["proof (prove)\nusing this:\n  p \\<in> cbox (0, 0) (1, 1)\n  cbox (0, 0) (1, 1) = {0..1} \\<times> {0..1}\n  w \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * w \\<le> 1 * w", "by (intro mult_right_mono) auto"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * w \\<le> 1 * w\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * w \\<le> 1 * w\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0", "have \"\\<dots> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * w < 1", "using w"], ["proof (prove)\nusing this:\n  w \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 * w < 1", "by simp"], ["proof (state)\nthis:\n  1 * w < 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (1 - fst p * snd p) * w < 1", "have \"(1 - fst p * snd p) * w < 1\""], ["proof (prove)\nusing this:\n  (1 - fst p * snd p) * w < 1\n\ngoal (1 subgoal):\n 1. (1 - fst p * snd p) * w < 1", "by simp"], ["proof (state)\nthis:\n  (1 - fst p * snd p) * w < 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> cbox (0, 0) (1, 1) \\<Longrightarrow>\n       (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0", "thus \"(1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (1 - fst p * snd p) * w < 1\n\ngoal (1 subgoal):\n 1. (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  (1 - (1 - fst p * snd p) * w) ^ (n + 1) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_integrable lborel (cbox (0, 0) (1, 1))\n   (\\<lambda>(x, y).\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "hence integrable': \"set_integrable lborel D\n                        (\\<lambda>(x,y). (1-y)^n * (x*y*w)^n * (1-x)^n / (1-(1-x*y)*w)^(n+1))\""], ["proof (prove)\nusing this:\n  set_integrable lborel (cbox (0, 0) (1, 1))\n   (\\<lambda>(x, y).\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y).\n         (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n         (1 - (1 - x * y) * w) ^ (n + 1))", "by (rule set_integrable_subset) (auto simp: D_def simp flip: borel_prod)"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>(x, y).\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have \"(LBINT (x,y):D. P x * (1-y)^n / (1-(1-x*y)*w)) =\n          (LBINT y=0..1. (LBINT x=0..1. P x * (1-y)^n / (1-(1-x*y)*w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT y=0..1. (LBINT x=0..1. P x * (1 - y) ^ n / (1 - (1 - x * y) * w))", "using integrable"], ["proof (prove)\nusing this:\n  set_integrable lborel D\n   (\\<lambda>(x, y). P x * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT y=0..1. (LBINT x=0..1. P x * (1 - y) ^ n / (1 - (1 - x * y) * w))", "unfolding case_prod_unfold D_def lborel_prod [symmetric]"], ["proof (prove)\nusing this:\n  set_integrable (lborel \\<Otimes>\\<^sub>M lborel)\n   ({0<..<1} \\<times> {0<..<1})\n   (\\<lambda>p. P (fst p) * (1 - snd p) ^ n / (1 - (1 - fst p * snd p) * w))\n\ngoal (1 subgoal):\n 1. \\<integral>p\\<in>{0<..<1} \\<times> {0<..<1}.\n               (P (fst p) * (1 - snd p) ^ n / (1 - (1 - fst p * snd p) * w))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel =\n    LBINT y=0..1. (LBINT x=0..1. P x * (1 - y) ^ n / (1 - (1 - x * y) * w))", "by (subst lborel_pair.set_integral_snd) (auto simp: interval_integral_Ioo)"], ["proof (state)\nthis:\n  LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  LBINT y=0..1. (LBINT x=0..1. P x * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  LBINT y=0..1. (LBINT x=0..1. P x * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have \"\\<dots> = (LBINT y=0..1. (1-y)^n * (LBINT x=0..1. P x / (1-(1-y*x)*w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. (LBINT x=0..1. P x * (1 - y) ^ n /\n                                 (1 - (1 - x * y) * w)) =\n    LBINT y=0..1. (1 - y) ^ n * (LBINT x=0..1. P x / (1 - (1 - y * x) * w))", "by (subst interval_lebesgue_integral_mult_right [symmetric]) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  LBINT y=0..1. (LBINT x=0..1. P x * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT y=0..1. (1 - y) ^ n * (LBINT x=0..1. P x / (1 - (1 - y * x) * w))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT y=0..1. (LBINT x=0..1. P x * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT y=0..1. (1 - y) ^ n * (LBINT x=0..1. P x / (1 - (1 - y * x) * w))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have \"\\<dots> = (LBINT y=0..1. (1-y)^n * (LBINT x=0..1. (x*y*w)^n * (1-x)^n / (1-(1-x*y)*w)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. (1 - y) ^ n *\n                  (LBINT x=0..1. P x / (1 - (1 - y * x) * w)) =\n    LBINT y=0..1. (1 - y) ^ n *\n                  (LBINT x=0..1. (x * y * w) ^ n * (1 - x) ^ n /\n                                 (1 - (1 - x * y) * w) ^ (n + 1))", "using w"], ["proof (prove)\nusing this:\n  w \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. (1 - y) ^ n *\n                  (LBINT x=0..1. P x / (1 - (1 - y * x) * w)) =\n    LBINT y=0..1. (1 - y) ^ n *\n                  (LBINT x=0..1. (x * y * w) ^ n * (1 - x) ^ n /\n                                 (1 - (1 - x * y) * w) ^ (n + 1))", "by (intro interval_lebesgue_integral_lborel_01_cong, subst beukers_aux_by_parts) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  LBINT y=0..1. (1 - y) ^ n * (LBINT x=0..1. P x / (1 - (1 - y * x) * w)) =\n  LBINT y=0..1. (1 - y) ^ n *\n                (LBINT x=0..1. (x * y * w) ^ n * (1 - x) ^ n /\n                               (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT y=0..1. (1 - y) ^ n * (LBINT x=0..1. P x / (1 - (1 - y * x) * w)) =\n  LBINT y=0..1. (1 - y) ^ n *\n                (LBINT x=0..1. (x * y * w) ^ n * (1 - x) ^ n /\n                               (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have \"\\<dots> = (LBINT y=0..1. (LBINT x=0..1.\n                     (1-y)^n * (x*y*w)^n * (1-x)^n / (1-(1-x*y)*w)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. (1 - y) ^ n *\n                  (LBINT x=0..1. (x * y * w) ^ n * (1 - x) ^ n /\n                                 (1 - (1 - x * y) * w) ^ (n + 1)) =\n    LBINT y=0..1. (LBINT x=0..1. (1 - y) ^ n * (x * y * w) ^ n *\n                                 (1 - x) ^ n /\n                                 (1 - (1 - x * y) * w) ^ (n + 1))", "by (subst interval_lebesgue_integral_mult_right [symmetric]) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  LBINT y=0..1. (1 - y) ^ n *\n                (LBINT x=0..1. (x * y * w) ^ n * (1 - x) ^ n /\n                               (1 - (1 - x * y) * w) ^ (n + 1)) =\n  LBINT y=0..1. (LBINT x=0..1. (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n                               (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  LBINT y=0..1. (1 - y) ^ n *\n                (LBINT x=0..1. (x * y * w) ^ n * (1 - x) ^ n /\n                               (1 - (1 - x * y) * w) ^ (n + 1)) =\n  LBINT y=0..1. (LBINT x=0..1. (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n                               (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "have \"\\<dots> = (LBINT (x,y):D. (1-y)^n * (x*y*w)^n * (1-x)^n / (1-(1-x*y)*w)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y=0..1. (LBINT x=0..1. (1 - y) ^ n * (x * y * w) ^ n *\n                                 (1 - x) ^ n /\n                                 (1 - (1 - x * y) * w) ^ (n + 1)) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "using integrable'"], ["proof (prove)\nusing this:\n  set_integrable lborel D\n   (\\<lambda>(x, y).\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. (LBINT x=0..1. (1 - y) ^ n * (x * y * w) ^ n *\n                                 (1 - x) ^ n /\n                                 (1 - (1 - x * y) * w) ^ (n + 1)) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "unfolding case_prod_unfold D_def lborel_prod [symmetric]"], ["proof (prove)\nusing this:\n  set_integrable (lborel \\<Otimes>\\<^sub>M lborel)\n   ({0<..<1} \\<times> {0<..<1})\n   (\\<lambda>p.\n       (1 - snd p) ^ n * (fst p * snd p * w) ^ n * (1 - fst p) ^ n /\n       (1 - (1 - fst p * snd p) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT y=0..1. (LBINT x=0..1. (1 - y) ^ n * (x * y * w) ^ n *\n                                 (1 - x) ^ n /\n                                 (1 - (1 - x * y) * w) ^ (n + 1)) =\n    \\<integral>p\\<in>{0<..<1} \\<times> {0<..<1}.\n               ((1 - snd p) ^ n * (fst p * snd p * w) ^ n *\n                (1 - fst p) ^ n /\n                (1 - (1 - fst p * snd p) * w) ^ (n + 1))\n    \\<partial>lborel \\<Otimes>\\<^sub>M lborel", "by (subst lborel_pair.set_integral_snd) (auto simp: interval_integral_Ioo)"], ["proof (state)\nthis:\n  LBINT y=0..1. (LBINT x=0..1. (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n                               (1 - (1 - x * y) * w) ^ (n + 1)) =\n  LBINT (x, y):D.\n     (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n     (1 - (1 - x * y) * w) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "finally"], ["proof (chain)\npicking this:\n  LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  LBINT (x, y):D.\n     (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n     (1 - (1 - x * y) * w) ^ (n + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  LBINT (x, y):D.\n     (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n     (1 - (1 - x * y) * w) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n    LBINT (x, y):D.\n       (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "."], ["proof (state)\nthis:\n  LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w) =\n  LBINT (x, y):D.\n     (1 - y) ^ n * (x * y * w) ^ n * (1 - x) ^ n /\n     (1 - (1 - x * y) * w) ^ (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We need to show the existence of some of these triple integrals.\n\\<close>"], ["", "lemma beukers_aux_integrable1:\n  \"set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x,y),z). P x * P y / (1-(1-x*y)*z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))", "have D [measurable]: \"D \\<in> sets (borel \\<Otimes>\\<^sub>M borel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> sets (borel \\<Otimes>\\<^sub>M borel)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..<1} \\<times> {0<..<1} \\<in> sets (borel \\<Otimes>\\<^sub>M borel)", "by (simp flip: borel_prod)"], ["proof (state)\nthis:\n  D \\<in> sets (borel \\<Otimes>\\<^sub>M borel)\n\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))", "have \"bounded (P ` {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (P ` {0..1})", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (Shleg n ` {0..1})", "by (intro compact_imp_bounded compact_continuous_image continuous_intros) auto"], ["proof (state)\nthis:\n  bounded (P ` {0..1})\n\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))", "then"], ["proof (chain)\npicking this:\n  bounded (P ` {0..1})", "obtain C where C: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\""], ["proof (prove)\nusing this:\n  bounded (P ` {0..1})\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> {0..1} \\<Longrightarrow>\n            norm (P x) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding bounded_iff"], ["proof (prove)\nusing this:\n  \\<exists>a. \\<forall>x\\<in>P ` {0..1}. norm x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> {0..1} \\<Longrightarrow>\n            norm (P x) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow> norm (P ?x) \\<le> C\n\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))", "unfolding D'_def case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))", "proof (subst lborel_prod [symmetric],\n         intro lborel_pair.Fubini_set_integrable AE_I2 impI; clarsimp?)"], ["proof (state)\ngoal (3 subgoals):\n 1. set_borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)\n     (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))\n 2. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>x.\n         LBINT y:{0<..<1}.\n            \\<bar>P (fst x) * P (snd x)\\<bar> /\n            \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)\n 3. \\<And>a b.\n       \\<lbrakk>0 < a; a < 1; 0 < b; b < 1\\<rbrakk>\n       \\<Longrightarrow> set_integrable lborel {0<..<1}\n                          (\\<lambda>y. P a * P b / (1 - (1 - a * b) * y))", "fix x y :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. set_borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)\n     (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))\n 2. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>x.\n         LBINT y:{0<..<1}.\n            \\<bar>P (fst x) * P (snd x)\\<bar> /\n            \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)\n 3. \\<And>a b.\n       \\<lbrakk>0 < a; a < 1; 0 < b; b < 1\\<rbrakk>\n       \\<Longrightarrow> set_integrable lborel {0<..<1}\n                          (\\<lambda>y. P a * P b / (1 - (1 - a * b) * y))", "assume xy: \"x > 0\" \"x < 1\" \"y > 0\" \"y < 1\""], ["proof (state)\nthis:\n  0 < x\n  x < 1\n  0 < y\n  y < 1\n\ngoal (3 subgoals):\n 1. set_borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)\n     (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))\n 2. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>x.\n         LBINT y:{0<..<1}.\n            \\<bar>P (fst x) * P (snd x)\\<bar> /\n            \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)\n 3. \\<And>a b.\n       \\<lbrakk>0 < a; a < 1; 0 < b; b < 1\\<rbrakk>\n       \\<Longrightarrow> set_integrable lborel {0<..<1}\n                          (\\<lambda>y. P a * P b / (1 - (1 - a * b) * y))", "have \"x * y < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y < 1", "using xy mult_strict_mono[of x 1 y 1]"], ["proof (prove)\nusing this:\n  0 < x\n  x < 1\n  0 < y\n  y < 1\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. x * y < 1", "by simp"], ["proof (state)\nthis:\n  x * y < 1\n\ngoal (3 subgoals):\n 1. set_borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)\n     (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))\n 2. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>x.\n         LBINT y:{0<..<1}.\n            \\<bar>P (fst x) * P (snd x)\\<bar> /\n            \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)\n 3. \\<And>a b.\n       \\<lbrakk>0 < a; a < 1; 0 < b; b < 1\\<rbrakk>\n       \\<Longrightarrow> set_integrable lborel {0<..<1}\n                          (\\<lambda>y. P a * P b / (1 - (1 - a * b) * y))", "show \"set_integrable lborel {0<..<1} (\\<lambda>z. P x * P y / (1-(1-x*y)*z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel {0<..<1}\n     (\\<lambda>z. P x * P y / (1 - (1 - x * y) * z))", "by (rule set_integrable_subset[of _ \"{0..1}\"], rule borel_integrable_atLeastAtMost')\n         (use \\<open>x*y<1\\<close> beukers_denom_neq[of x y] xy in \\<open>auto intro!: continuous_intros simp: P_def\\<close>)"], ["proof (state)\nthis:\n  set_integrable lborel {0<..<1}\n   (\\<lambda>z. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (2 subgoals):\n 1. set_borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)\n     (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))\n 2. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>x.\n         LBINT y:{0<..<1}.\n            \\<bar>P (fst x) * P (snd x)\\<bar> /\n            \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)\n     (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))\n 2. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>x.\n         LBINT y:{0<..<1}.\n            \\<bar>P (fst x) * P (snd x)\\<bar> /\n            \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)", "have \"set_integrable lborel D\n             (\\<lambda>(x,y). (\\<integral>z\\<in>{0<..<1}. norm (P x * P y / (1-(1-x*y)*z)) \\<partial>lborel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))", "proof (rule set_integrable_bound[OF _ _ AE_I2]; clarify?)"], ["proof (state)\ngoal (3 subgoals):\n 1. set_integrable lborel D ?f1\n 2. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 3. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm (?f1 (a, b))", "show \"set_integrable lborel D (\\<lambda>(x,y). C\\<^sup>2 * (-ln (x*y) / (1 - x*y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "using beukers_integral1_integrable[of 0 0]"], ["proof (prove)\nusing this:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n   (\\<lambda>(x, y). - ln (x * y) / (1 - x * y) * x ^ 0 * y ^ 0)\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>(x, y). C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "unfolding case_prod_unfold"], ["proof (prove)\nusing this:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n   (\\<lambda>p.\n       - ln (fst p * snd p) / (1 - fst p * snd p) * fst p ^ 0 * snd p ^ 0)\n\ngoal (1 subgoal):\n 1. set_integrable lborel D\n     (\\<lambda>p. C\\<^sup>2 * (- ln (fst p * snd p) / (1 - fst p * snd p)))", "by (intro set_integrable_mult_right) (auto simp: D_def)"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>(x, y). C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "assume xy: \"(x, y) \\<in> D\""], ["proof (state)\nthis:\n  (x, y) \\<in> D\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "have \"norm (LBINT z:{0<..<1}. norm (P x * P y / (1-(1-x*y)*z))) =\n              norm (LBINT z:{0<..<1}. \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z))) =\n    norm\n     (LBINT z:{0<..<1}.\n         \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z)))", "proof (intro arg_cong[where f = norm] set_lebesgue_integral_cong allI impI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {0<..<1} \\<in> sets lborel\n 2. \\<And>z.\n       z \\<in> {0<..<1} \\<Longrightarrow>\n       norm (P x * P y / (1 - (1 - x * y) * z)) =\n       \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z))", "case (2 z)"], ["proof (state)\nthis:\n  z \\<in> {0<..<1}\n\ngoal (2 subgoals):\n 1. {0<..<1} \\<in> sets lborel\n 2. \\<And>z.\n       z \\<in> {0<..<1} \\<Longrightarrow>\n       norm (P x * P y / (1 - (1 - x * y) * z)) =\n       \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z))", "with beukers_denom_ineq[of x y z] xy"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; z \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * z < 1\n  (x, y) \\<in> D\n  z \\<in> {0<..<1}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; z \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * z < 1\n  (x, y) \\<in> D\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. norm (P x * P y / (1 - (1 - x * y) * z)) =\n    \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z))", "by (auto simp: abs_mult D_def)"], ["proof (state)\nthis:\n  norm (P x * P y / (1 - (1 - x * y) * z)) =\n  \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. {0<..<1} \\<in> sets lborel", "qed (auto simp: abs_mult D_def)"], ["proof (state)\nthis:\n  norm (LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z))) =\n  norm\n   (LBINT z:{0<..<1}.\n       \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "also"], ["proof (state)\nthis:\n  norm (LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z))) =\n  norm\n   (LBINT z:{0<..<1}.\n       \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "have \"\\<dots> = norm (\\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (LBINT z=0..1. (1 / (1-(1-x*y)*z))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm\n     (LBINT z:{0<..<1}.\n         \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z))) =\n    norm\n     (\\<bar>P x\\<bar> * \\<bar>P y\\<bar> *\n      (LBINT z=0..1. 1 / (1 - (1 - x * y) * z)))", "by (subst set_integral_mult_right) (auto simp: interval_integral_Ioo)"], ["proof (state)\nthis:\n  norm\n   (LBINT z:{0<..<1}.\n       \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z))) =\n  norm\n   (\\<bar>P x\\<bar> * \\<bar>P y\\<bar> *\n    (LBINT z=0..1. 1 / (1 - (1 - x * y) * z)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "also"], ["proof (state)\nthis:\n  norm\n   (LBINT z:{0<..<1}.\n       \\<bar>P x\\<bar> * \\<bar>P y\\<bar> * (1 / (1 - (1 - x * y) * z))) =\n  norm\n   (\\<bar>P x\\<bar> * \\<bar>P y\\<bar> *\n    (LBINT z=0..1. 1 / (1 - (1 - x * y) * z)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "have \"\\<dots> = norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm\n     (\\<bar>P x\\<bar> * \\<bar>P y\\<bar> *\n      (LBINT z=0..1. 1 / (1 - (1 - x * y) * z))) =\n    norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y)))", "using beukers_aux_ln_conv_integral[of x y] xy"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> - ln (x * y) / (1 - x * y) =\n                    LBINT z=0..1. 1 / (1 - (1 - x * y) * z)\n  (x, y) \\<in> D\n\ngoal (1 subgoal):\n 1. norm\n     (\\<bar>P x\\<bar> * \\<bar>P y\\<bar> *\n      (LBINT z=0..1. 1 / (1 - (1 - x * y) * z))) =\n    norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y)))", "by (simp add: D_def)"], ["proof (state)\nthis:\n  norm\n   (\\<bar>P x\\<bar> * \\<bar>P y\\<bar> *\n    (LBINT z=0..1. 1 / (1 - (1 - x * y) * z))) =\n  norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "also"], ["proof (state)\nthis:\n  norm\n   (\\<bar>P x\\<bar> * \\<bar>P y\\<bar> *\n    (LBINT z=0..1. 1 / (1 - (1 - x * y) * z))) =\n  norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "have \"\\<dots> = norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))) =\n    norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))", "using xy mult_strict_mono[of x 1 y 1]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))) =\n    norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))", "by (auto simp: D_def divide_nonpos_nonneg abs_mult)"], ["proof (state)\nthis:\n  norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))) =\n  norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "also"], ["proof (state)\nthis:\n  norm (norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))) =\n  norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "have \"norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y)) \\<le>\n                   norm (C * C * (- ln (x * y) / (1 - x * y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))\n    \\<le> norm (C * C * (- ln (x * y) / (1 - x * y)))", "using xy C[of x] C[of y] mult_strict_mono[of x 1 y 1]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n  x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\n  y \\<in> {0..1} \\<Longrightarrow> norm (P y) \\<le> C\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))\n    \\<le> norm (C * C * (- ln (x * y) / (1 - x * y)))", "unfolding norm_mult norm_divide"], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n  x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\n  y \\<in> {0..1} \\<Longrightarrow> norm (P y) \\<le> C\n  \\<lbrakk>x < 1; y < 1; 0 < 1; 0 \\<le> y\\<rbrakk>\n  \\<Longrightarrow> x * y < 1 * 1\n\ngoal (1 subgoal):\n 1. norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))\n    \\<le> norm C * norm C * (norm (- ln (x * y)) / norm (1 - x * y))", "by (intro mult_mono C) (auto simp: D_def divide_nonpos_nonneg)"], ["proof (state)\nthis:\n  norm (P x) * norm (P y) * (- ln (x * y) / (1 - x * y))\n  \\<le> norm (C * C * (- ln (x * y) / (1 - x * y)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> space lborel; (a, b) \\<in> D\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (LBINT z:{0<..<1}.\n                              norm (P a * P b / (1 - (1 - a * b) * z)))\n                         \\<le> norm\n                                (case (a, b) of\n                                 (x, y) \\<Rightarrow>\n                                   C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "finally"], ["proof (chain)\npicking this:\n  norm (LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n  \\<le> norm (C * C * (- ln (x * y) / (1 - x * y)))", "show \"norm (LBINT z:{0<..<1}. norm (P x * P y / (1-(1-x*y)*z)))\n           \\<le> norm (case (x, y) of (x, y) \\<Rightarrow> C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))\""], ["proof (prove)\nusing this:\n  norm (LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n  \\<le> norm (C * C * (- ln (x * y) / (1 - x * y)))\n\ngoal (1 subgoal):\n 1. norm (LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n    \\<le> norm\n           (case (x, y) of\n            (x, y) \\<Rightarrow> C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))", "by (simp add: power2_eq_square mult_ac)"], ["proof (state)\nthis:\n  norm (LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n  \\<le> norm\n         (case (x, y) of\n          (x, y) \\<Rightarrow> C\\<^sup>2 * (- ln (x * y) / (1 - x * y)))\n\ngoal (1 subgoal):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))", "show \"set_borel_measurable lborel D (\\<lambda>(x, y).\n              LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_borel_measurable lborel D\n     (\\<lambda>(x, y).\n         LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))", "unfolding lborel_prod [symmetric] set_borel_measurable_def\n                  case_prod_unfold set_lebesgue_integral_def P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        indicat_real D x *\\<^sub>R\n        (LBINT xa.\n           indicat_real {0<..<1} xa *\\<^sub>R\n           norm\n            (Shleg n (fst x) * Shleg n (snd x) /\n             (1 - (1 - fst x * snd x) * xa))))\n    \\<in> borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)", "by measurable"], ["proof (state)\nthis:\n  set_borel_measurable lborel D\n   (\\<lambda>(x, y).\n       LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_integrable lborel D\n   (\\<lambda>(x, y).\n       LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)\n     (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))\n 2. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>x.\n         LBINT y:{0<..<1}.\n            \\<bar>P (fst x) * P (snd x)\\<bar> /\n            \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)", "thus \"set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n            (\\<lambda>x. LBINT y:{0<..<1}. \\<bar>P (fst x) * P (snd x)\\<bar> / \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)\""], ["proof (prove)\nusing this:\n  set_integrable lborel D\n   (\\<lambda>(x, y).\n       LBINT z:{0<..<1}. norm (P x * P y / (1 - (1 - x * y) * z)))\n\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n     (\\<lambda>x.\n         LBINT y:{0<..<1}.\n            \\<bar>P (fst x) * P (snd x)\\<bar> /\n            \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)", "by (simp add: case_prod_unfold D_def)"], ["proof (state)\nthis:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1})\n   (\\<lambda>x.\n       LBINT y:{0<..<1}.\n          \\<bar>P (fst x) * P (snd x)\\<bar> /\n          \\<bar>1 - (1 - fst x * snd x) * y\\<bar>)\n\ngoal (1 subgoal):\n 1. set_borel_measurable (lborel \\<Otimes>\\<^sub>M lborel)\n     (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>p.\n         P (fst (fst p)) * P (snd (fst p)) /\n         (1 - (1 - fst (fst p) * snd (fst p)) * snd p))", "qed (auto simp: case_prod_unfold lborel_prod [symmetric] set_borel_measurable_def P_def)"], ["proof (state)\nthis:\n  set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n   (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beukers_aux_integrable2:\n  \"set_integrable lborel D' (\\<lambda>(z,x,y). P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z) ^ (n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "have [measurable]: \"P \\<in> borel_measurable borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> borel_measurable borel", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Shleg n \\<in> borel_measurable borel", "by (intro borel_measurable_continuous_onI continuous_intros)"], ["proof (state)\nthis:\n  P \\<in> borel_measurable borel\n\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "have \"bounded (P ` {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (P ` {0..1})", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (Shleg n ` {0..1})", "by (intro compact_imp_bounded compact_continuous_image continuous_intros) auto"], ["proof (state)\nthis:\n  bounded (P ` {0..1})\n\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "then"], ["proof (chain)\npicking this:\n  bounded (P ` {0..1})", "obtain C where C: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\""], ["proof (prove)\nusing this:\n  bounded (P ` {0..1})\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> {0..1} \\<Longrightarrow>\n            norm (P x) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding bounded_iff"], ["proof (prove)\nusing this:\n  \\<exists>a. \\<forall>x\\<in>P ` {0..1}. norm x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> {0..1} \\<Longrightarrow>\n            norm (P x) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow> norm (P ?x) \\<le> C\n\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "unfolding D'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "proof (rule set_integrable_bound[OF _ _ AE_I2]; clarify?)"], ["proof (state)\ngoal (3 subgoals):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}) ?f1\n 2. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 3. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm (?f1 (a, aa, b))", "show \"set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n            (\\<lambda>(z,x,y). C * (1 / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). C * (1 / (1 - (1 - x * y) * z)))", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>p. C * (1 / (1 - (1 - fst (snd p) * snd (snd p)) * fst p)))", "using beukers_integral1_integrable'[of 0 0]"], ["proof (prove)\nusing this:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n   (\\<lambda>(z, x, y). x ^ 0 * y ^ 0 / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>p. C * (1 / (1 - (1 - fst (snd p) * snd (snd p)) * fst p)))", "by (intro set_integrable_mult_right) (auto simp: lborel_prod case_prod_unfold)"], ["proof (state)\nthis:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n   (\\<lambda>(z, x, y). C * (1 / (1 - (1 - x * y) * z)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "fix x y z :: real"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "assume xyz: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\" \"z \\<in> {0<..<1}\""], ["proof (state)\nthis:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "have \"norm (P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)) =\n            norm (P x) * (1-y)^n * ((x*y*z) / (1-(1-x*y)*z))^n / (1-(1-x*y)*z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm\n     (P x * (x * y * z) ^ n * (1 - y) ^ n /\n      (1 - (1 - x * y) * z) ^ (n + 1)) =\n    norm (P x) * (1 - y) ^ n * (x * y * z / (1 - (1 - x * y) * z)) ^ n /\n    (1 - (1 - x * y) * z)", "using xyz beukers_denom_ineq[of x y z]"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; z \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * z < 1\n\ngoal (1 subgoal):\n 1. norm\n     (P x * (x * y * z) ^ n * (1 - y) ^ n /\n      (1 - (1 - x * y) * z) ^ (n + 1)) =\n    norm (P x) * (1 - y) ^ n * (x * y * z / (1 - (1 - x * y) * z)) ^ n /\n    (1 - (1 - x * y) * z)", "by (simp add: abs_mult power_divide mult_ac)"], ["proof (state)\nthis:\n  norm\n   (P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)) =\n  norm (P x) * (1 - y) ^ n * (x * y * z / (1 - (1 - x * y) * z)) ^ n /\n  (1 - (1 - x * y) * z)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "also"], ["proof (state)\nthis:\n  norm\n   (P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1)) =\n  norm (P x) * (1 - y) ^ n * (x * y * z / (1 - (1 - x * y) * z)) ^ n /\n  (1 - (1 - x * y) * z)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "have \"(x*y*z) / (1-(1-x*y)*z) = 1/((1-z)/(z*x*y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z / (1 - (1 - x * y) * z) = 1 / ((1 - z) / (z * x * y) + 1)", "using xyz"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. x * y * z / (1 - (1 - x * y) * z) = 1 / ((1 - z) / (z * x * y) + 1)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x * y * z / (1 - (1 - x * y) * z) = 1 / ((1 - z) / (z * x * y) + 1)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "also"], ["proof (state)\nthis:\n  x * y * z / (1 - (1 - x * y) * z) = 1 / ((1 - z) / (z * x * y) + 1)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "have \"norm (P x) * (1-y)^n * \\<dots>^n / (1-(1-x*y)*z) \\<le>\n               C * 1^n * 1^n / (1-(1-x*y)*z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (P x) * (1 - y) ^ n * (1 / ((1 - z) / (z * x * y) + 1)) ^ n /\n    (1 - (1 - x * y) * z)\n    \\<le> C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)", "using xyz C[of x] beukers_denom_ineq[of x y z]"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  z \\<in> {0<..<1}\n  x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; z \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * z < 1\n\ngoal (1 subgoal):\n 1. norm (P x) * (1 - y) ^ n * (1 / ((1 - z) / (z * x * y) + 1)) ^ n /\n    (1 - (1 - x * y) * z)\n    \\<le> C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)", "by (intro mult_mono divide_right_mono power_mono zero_le_power mult_nonneg_nonneg divide_nonneg_nonneg)\n         (auto simp: field_simps)"], ["proof (state)\nthis:\n  norm (P x) * (1 - y) ^ n * (1 / ((1 - z) / (z * x * y) + 1)) ^ n /\n  (1 - (1 - x * y) * z)\n  \\<le> C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "also"], ["proof (state)\nthis:\n  norm (P x) * (1 - y) ^ n * (1 / ((1 - z) / (z * x * y) + 1)) ^ n /\n  (1 - (1 - x * y) * z)\n  \\<le> C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "have \"\\<dots> \\<le> \\<bar>C * 1^n * 1^n / (1-(1-x*y)*z)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)\n    \\<le> \\<bar>C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)\\<bar>", "by linarith"], ["proof (state)\nthis:\n  C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)\n  \\<le> \\<bar>C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)\\<bar>\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (aa * b * a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a) ^ (n + 1))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "finally"], ["proof (chain)\npicking this:\n  norm\n   (P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1))\n  \\<le> \\<bar>C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)\\<bar>", "show \"norm (P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)) \\<le>\n                    norm (case (z,x,y) of (z,x,y) \\<Rightarrow> C * (1 / (1-(1-x*y)*z)))\""], ["proof (prove)\nusing this:\n  norm\n   (P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1))\n  \\<le> \\<bar>C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * z)\\<bar>\n\ngoal (1 subgoal):\n 1. norm\n     (P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1))\n    \\<le> norm\n           (case (z, x, y) of\n            (z, x, y) \\<Rightarrow> C * (1 / (1 - (1 - x * y) * z)))", "by (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  norm\n   (P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1))\n  \\<le> norm\n         (case (z, x, y) of\n          (z, x, y) \\<Rightarrow> C * (1 / (1 - (1 - x * y) * z)))\n\ngoal (1 subgoal):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y).\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))", "qed (simp_all add: case_prod_unfold set_borel_measurable_def flip: borel_prod)"], ["proof (state)\nthis:\n  set_integrable lborel D'\n   (\\<lambda>(z, x, y).\n       P x * (x * y * z) ^ n * (1 - y) ^ n /\n       (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beukers_aux_integrable3:\n  \"set_integrable lborel D' (\\<lambda>(w,x,y). P x * (1-w)^n * (1-y)^n / (1-(1-x*y)*w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "have [measurable]: \"P \\<in> borel_measurable borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> borel_measurable borel", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Shleg n \\<in> borel_measurable borel", "by (intro borel_measurable_continuous_onI continuous_intros)"], ["proof (state)\nthis:\n  P \\<in> borel_measurable borel\n\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "have \"bounded (P ` {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (P ` {0..1})", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (Shleg n ` {0..1})", "by (intro compact_imp_bounded compact_continuous_image continuous_intros) auto"], ["proof (state)\nthis:\n  bounded (P ` {0..1})\n\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "then"], ["proof (chain)\npicking this:\n  bounded (P ` {0..1})", "obtain C where C: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\""], ["proof (prove)\nusing this:\n  bounded (P ` {0..1})\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> {0..1} \\<Longrightarrow>\n            norm (P x) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding bounded_iff"], ["proof (prove)\nusing this:\n  \\<exists>a. \\<forall>x\\<in>P ` {0..1}. norm x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> {0..1} \\<Longrightarrow>\n            norm (P x) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow> norm (P ?x) \\<le> C\n\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel D'\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "unfolding D'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "proof (rule set_integrable_bound[OF _ _ AE_I2]; clarify?)"], ["proof (state)\ngoal (3 subgoals):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}) ?f1\n 2. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 3. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm (?f1 (a, aa, b))", "show \"set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n            (\\<lambda>(z,x,y). C * (1 / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(z, x, y). C * (1 / (1 - (1 - x * y) * z)))", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>p. C * (1 / (1 - (1 - fst (snd p) * snd (snd p)) * fst p)))", "using beukers_integral1_integrable'[of 0 0]"], ["proof (prove)\nusing this:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n   (\\<lambda>(z, x, y). x ^ 0 * y ^ 0 / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>p. C * (1 / (1 - (1 - fst (snd p) * snd (snd p)) * fst p)))", "by (intro set_integrable_mult_right) (auto simp: lborel_prod case_prod_unfold)"], ["proof (state)\nthis:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n   (\\<lambda>(z, x, y). C * (1 / (1 - (1 - x * y) * z)))\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "fix x y w :: real"], ["proof (state)\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "assume xyw: \"x \\<in> {0<..<1}\" \"y \\<in> {0<..<1}\" \"w \\<in> {0<..<1}\""], ["proof (state)\nthis:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  w \\<in> {0<..<1}\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "have \"norm (P x * (1-w)^n * (1-y)^n / (1-(1-x*y)*w)) =\n            norm (P x) * (1-w)^n * (1-y)^n / (1-(1-x*y)*w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n    norm (P x) * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "using xyw beukers_denom_ineq[of x y w]"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  w \\<in> {0<..<1}\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; w \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * w < 1\n\ngoal (1 subgoal):\n 1. norm (P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n    norm (P x) * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "by (simp add: abs_mult power_divide mult_ac)"], ["proof (state)\nthis:\n  norm (P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  norm (P x) * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "also"], ["proof (state)\nthis:\n  norm (P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  norm (P x) * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "have \"\\<dots> \\<le> C * 1^n * 1^n / (1-(1-x*y)*w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (P x) * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n    \\<le> C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)", "using xyw C[of x] beukers_denom_ineq[of x y w]"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  y \\<in> {0<..<1}\n  w \\<in> {0<..<1}\n  x \\<in> {0..1} \\<Longrightarrow> norm (P x) \\<le> C\n  \\<lbrakk>x \\<in> {0<..<1}; y \\<in> {0<..<1}; w \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> (1 - x * y) * w < 1\n\ngoal (1 subgoal):\n 1. norm (P x) * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n    \\<le> C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)", "by (intro mult_mono divide_right_mono power_mono zero_le_power mult_nonneg_nonneg divide_nonneg_nonneg)\n         (auto simp: field_simps)"], ["proof (state)\nthis:\n  norm (P x) * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n  \\<le> C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "also"], ["proof (state)\nthis:\n  norm (P x) * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n  \\<le> C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "have \"\\<dots> \\<le> \\<bar>C * 1^n * 1^n / (1-(1-x*y)*w)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)\n    \\<le> \\<bar>C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)\\<bar>", "by linarith"], ["proof (state)\nthis:\n  C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)\n  \\<le> \\<bar>C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)\\<bar>\n\ngoal (2 subgoals):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n 2. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> space lborel; a \\<in> {0<..<1};\n        aa \\<in> {0<..<1}; b \\<in> {0<..<1}\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (P aa * (1 - a) ^ n * (1 - b) ^ n /\n                           (1 - (1 - aa * b) * a))\n                         \\<le> norm\n                                (case (a, aa, b) of\n                                 (z, xa, y) \\<Rightarrow>\n                                   C * (1 / (1 - (1 - xa * y) * z)))", "finally"], ["proof (chain)\npicking this:\n  norm (P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n  \\<le> \\<bar>C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)\\<bar>", "show \"norm (P x * (1-w)^n * (1-y)^n / (1-(1-x*y)*w)) \\<le>\n                    norm (case (w,x,y) of (z,x,y) \\<Rightarrow> C * (1 / (1-(1-x*y)*z)))\""], ["proof (prove)\nusing this:\n  norm (P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n  \\<le> \\<bar>C * 1 ^ n * 1 ^ n / (1 - (1 - x * y) * w)\\<bar>\n\ngoal (1 subgoal):\n 1. norm (P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n    \\<le> norm\n           (case (w, x, y) of\n            (z, x, y) \\<Rightarrow> C * (1 / (1 - (1 - x * y) * z)))", "by (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  norm (P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n  \\<le> norm\n         (case (w, x, y) of\n          (z, x, y) \\<Rightarrow> C * (1 / (1 - (1 - x * y) * z)))\n\ngoal (1 subgoal):\n 1. set_borel_measurable lborel\n     ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n     (\\<lambda>(w, x, y).\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "qed (simp_all add: case_prod_unfold set_borel_measurable_def flip: borel_prod)"], ["proof (state)\nthis:\n  set_integrable lborel D'\n   (\\<lambda>(w, x, y).\n       P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Now we only need to put all of these results together:\n\\<close>"], ["", "lemma beukers_integral2_conv_3: \"beukers_integral2 = beukers_integral3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have cont_P: \"continuous_on {0..1} P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} P", "by (auto simp: P_def intro: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1} P\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have D [measurable]: \"D \\<in> sets borel\" \"D \\<in> sets (borel \\<Otimes>\\<^sub>M borel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> sets borel &&& D \\<in> sets (borel \\<Otimes>\\<^sub>M borel)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..<1} \\<times> {0<..<1} \\<in> sets borel &&&\n    {0<..<1} \\<times> {0<..<1} \\<in> sets (borel \\<Otimes>\\<^sub>M borel)", "by (simp_all flip: borel_prod)"], ["proof (state)\nthis:\n  D \\<in> sets borel\n  D \\<in> sets (borel \\<Otimes>\\<^sub>M borel)\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have [measurable]: \"P \\<in> borel_measurable borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> borel_measurable borel", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Shleg n \\<in> borel_measurable borel", "by (intro borel_measurable_continuous_onI continuous_intros)"], ["proof (state)\nthis:\n  P \\<in> borel_measurable borel\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"beukers_integral2 = (LBINT (x,y):D. P x * P y * (LBINT z=0..1. 1 / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.beukers_integral2 =\n    LBINT (x, y):D. P x * P y * (LBINT z=0..1. 1 / (1 - (1 - x * y) * z))", "unfolding beukers_integral2_def case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT p:D.\n       - ln (fst p * snd p) / (1 - fst p * snd p) * P (fst p) * P (snd p) =\n    LBINT p:D.\n       P (fst p) * P (snd p) *\n       (LBINT z=0..1. 1 / (1 - (1 - fst p * snd p) * z))", "by (intro set_lebesgue_integral_cong allI impI, measurable)\n       (subst beukers_aux_ln_conv_integral, auto simp: D_def)"], ["proof (state)\nthis:\n  local.beukers_integral2 =\n  LBINT (x, y):D. P x * P y * (LBINT z=0..1. 1 / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  local.beukers_integral2 =\n  LBINT (x, y):D. P x * P y * (LBINT z=0..1. 1 / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT (x,y):D. (LBINT z=0..1. P x * P y / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. P x * P y * (LBINT z=0..1. 1 / (1 - (1 - x * y) * z)) =\n    LBINT (x, y):D. (LBINT z=0..1. P x * P y / (1 - (1 - x * y) * z))", "by (subst interval_lebesgue_integral_mult_right [symmetric]) auto"], ["proof (state)\nthis:\n  LBINT (x, y):D. P x * P y * (LBINT z=0..1. 1 / (1 - (1 - x * y) * z)) =\n  LBINT (x, y):D. (LBINT z=0..1. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT (x, y):D. P x * P y * (LBINT z=0..1. 1 / (1 - (1 - x * y) * z)) =\n  LBINT (x, y):D. (LBINT z=0..1. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT (x,y):D. (LBINT z:{0<..<1}. P x * P y / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. (LBINT z=0..1. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z))", "by (simp add: interval_integral_Ioo)"], ["proof (state)\nthis:\n  LBINT (x, y):D. (LBINT z=0..1. P x * P y / (1 - (1 - x * y) * z)) =\n  LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT (x, y):D. (LBINT z=0..1. P x * P y / (1 - (1 - x * y) * z)) =\n  LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT z:{0<..<1}. (LBINT (x,y):D. P x * P y / (1-(1-x*y)*z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT z:{0<..<1}. (LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z))", "proof (subst lborel_pair.Fubini_set_integral [symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n     (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))\n 2. LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT y:D.\n       (LBINT x:{0<..<1}.\n           (case y of\n            (xa, y) \\<Rightarrow> P xa * P y / (1 - (1 - xa * y) * x)))", "have \"set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n            (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))", "using beukers_aux_integrable1"], ["proof (prove)\nusing this:\n  set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n   (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))", "by simp"], ["proof (state)\nthis:\n  set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n   (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (2 subgoals):\n 1. set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n     (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))\n 2. LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT y:D.\n       (LBINT x:{0<..<1}.\n           (case y of\n            (xa, y) \\<Rightarrow> P xa * P y / (1 - (1 - xa * y) * x)))", "also"], ["proof (state)\nthis:\n  set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n   (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (2 subgoals):\n 1. set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n     (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))\n 2. LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT y:D.\n       (LBINT x:{0<..<1}.\n           (case y of\n            (xa, y) \\<Rightarrow> P xa * P y / (1 - (1 - xa * y) * x)))", "have \"?this \\<longleftrightarrow> set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n                           (\\<lambda>(z,x,y). P x * P y / (1 - (1 - x * y) * z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n     (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z)) =\n    set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n     (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))", "unfolding set_integrable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable lborel\n     (\\<lambda>x.\n         indicat_real (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n          x *\\<^sub>R\n         (case x of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (x, y) \\<Rightarrow>\n               \\<lambda>z. P x * P y / (1 - (1 - x * y) * z))\n             xa)) =\n    integrable (lborel \\<Otimes>\\<^sub>M lborel)\n     (\\<lambda>x.\n         indicat_real ({0<..<1} \\<times> D) x *\\<^sub>R\n         (case x of\n          (z, xa, y) \\<Rightarrow> P xa * P y / (1 - (1 - xa * y) * z)))", "by (subst lborel_pair.integrable_product_swap_iff [symmetric], intro integrable_cong)\n         (auto simp: indicator_def case_prod_unfold lborel_prod D_def)"], ["proof (state)\nthis:\n  set_integrable lborel (({0<..<1} \\<times> {0<..<1}) \\<times> {0<..<1})\n   (\\<lambda>((x, y), z). P x * P y / (1 - (1 - x * y) * z)) =\n  set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n   (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (2 subgoals):\n 1. set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n     (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))\n 2. LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT y:D.\n       (LBINT x:{0<..<1}.\n           (case y of\n            (xa, y) \\<Rightarrow> P xa * P y / (1 - (1 - xa * y) * x)))", "finally"], ["proof (chain)\npicking this:\n  set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n   (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))", "show \\<dots>"], ["proof (prove)\nusing this:\n  set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n   (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n     (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))", "."], ["proof (state)\nthis:\n  set_integrable (lborel \\<Otimes>\\<^sub>M lborel) ({0<..<1} \\<times> D)\n   (\\<lambda>(z, x, y). P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT y:D.\n       (LBINT x:{0<..<1}.\n           (case y of\n            (xa, y) \\<Rightarrow> P xa * P y / (1 - (1 - xa * y) * x)))", "qed (auto simp: case_prod_unfold)"], ["proof (state)\nthis:\n  LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z)) =\n  LBINT z:{0<..<1}. (LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT (x, y):D. (LBINT z:{0<..<1}. P x * P y / (1 - (1 - x * y) * z)) =\n  LBINT z:{0<..<1}. (LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT z:{0<..<1}. (LBINT (x,y):D. P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT z:{0<..<1}. (LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z)) =\n    LBINT z:{0<..<1}.\n       (LBINT (x, y):D.\n           P x * (x * y * z) ^ n * (1 - y) ^ n /\n           (1 - (1 - x * y) * z) ^ (n + 1))", "by (rule set_lebesgue_integral_cong) (use beukers_aux_integral_transform1 in simp_all)"], ["proof (state)\nthis:\n  LBINT z:{0<..<1}. (LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z)) =\n  LBINT z:{0<..<1}.\n     (LBINT (x, y):D.\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT z:{0<..<1}. (LBINT (x, y):D. P x * P y / (1 - (1 - x * y) * z)) =\n  LBINT z:{0<..<1}.\n     (LBINT (x, y):D.\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT (x,y):D. (LBINT z:{0<..<1}. P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT z:{0<..<1}.\n       (LBINT (x, y):D.\n           P x * (x * y * z) ^ n * (1 - y) ^ n /\n           (1 - (1 - x * y) * z) ^ (n + 1)) =\n    LBINT (x, y):D.\n       (LBINT z:{0<..<1}.\n           P x * (x * y * z) ^ n * (1 - y) ^ n /\n           (1 - (1 - x * y) * z) ^ (n + 1))", "using beukers_aux_integrable2"], ["proof (prove)\nusing this:\n  set_integrable lborel D'\n   (\\<lambda>(z, x, y).\n       P x * (x * y * z) ^ n * (1 - y) ^ n /\n       (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT z:{0<..<1}.\n       (LBINT (x, y):D.\n           P x * (x * y * z) ^ n * (1 - y) ^ n /\n           (1 - (1 - x * y) * z) ^ (n + 1)) =\n    LBINT (x, y):D.\n       (LBINT z:{0<..<1}.\n           P x * (x * y * z) ^ n * (1 - y) ^ n /\n           (1 - (1 - x * y) * z) ^ (n + 1))", "by (subst lborel_pair.Fubini_set_integral [symmetric])\n       (auto simp: case_prod_unfold lborel_prod D_def D'_def)"], ["proof (state)\nthis:\n  LBINT z:{0<..<1}.\n     (LBINT (x, y):D.\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1)) =\n  LBINT (x, y):D.\n     (LBINT z:{0<..<1}.\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT z:{0<..<1}.\n     (LBINT (x, y):D.\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1)) =\n  LBINT (x, y):D.\n     (LBINT z:{0<..<1}.\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT (x,y):D. (LBINT w:{0<..<1}. P x * (1-w)^n * (1-y)^n / (1-(1-x*y)*w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D.\n       (LBINT z:{0<..<1}.\n           P x * (x * y * z) ^ n * (1 - y) ^ n /\n           (1 - (1 - x * y) * z) ^ (n + 1)) =\n    LBINT (x, y):D.\n       (LBINT w:{0<..<1}.\n           P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "proof (intro set_lebesgue_integral_cong allI impI; clarify?)"], ["proof (state)\ngoal (2 subgoals):\n 1. D \\<in> sets lborel\n 2. \\<And>a b.\n       (a, b) \\<in> D \\<Longrightarrow>\n       LBINT z:{0<..<1}.\n          P a * (a * b * z) ^ n * (1 - b) ^ n /\n          (1 - (1 - a * b) * z) ^ (n + 1) =\n       LBINT w:{0<..<1}.\n          P a * (1 - w) ^ n * (1 - b) ^ n / (1 - (1 - a * b) * w)", "fix x y :: real"], ["proof (state)\ngoal (2 subgoals):\n 1. D \\<in> sets lborel\n 2. \\<And>a b.\n       (a, b) \\<in> D \\<Longrightarrow>\n       LBINT z:{0<..<1}.\n          P a * (a * b * z) ^ n * (1 - b) ^ n /\n          (1 - (1 - a * b) * z) ^ (n + 1) =\n       LBINT w:{0<..<1}.\n          P a * (1 - w) ^ n * (1 - b) ^ n / (1 - (1 - a * b) * w)", "assume xy: \"(x, y) \\<in> D\""], ["proof (state)\nthis:\n  (x, y) \\<in> D\n\ngoal (2 subgoals):\n 1. D \\<in> sets lborel\n 2. \\<And>a b.\n       (a, b) \\<in> D \\<Longrightarrow>\n       LBINT z:{0<..<1}.\n          P a * (a * b * z) ^ n * (1 - b) ^ n /\n          (1 - (1 - a * b) * z) ^ (n + 1) =\n       LBINT w:{0<..<1}.\n          P a * (1 - w) ^ n * (1 - b) ^ n / (1 - (1 - a * b) * w)", "have \"(LBINT z:{0<..<1}. P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)) =\n            P x * (LBINT z=0..1. (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT z:{0<..<1}.\n       P x * (x * y * z) ^ n * (1 - y) ^ n /\n       (1 - (1 - x * y) * z) ^ (n + 1) =\n    P x *\n    (LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                   (1 - (1 - x * y) * z) ^ (n + 1))", "by (subst interval_lebesgue_integral_mult_right [symmetric])\n         (simp add: mult_ac interval_integral_Ioo)"], ["proof (state)\nthis:\n  LBINT z:{0<..<1}.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1) =\n  P x *\n  (LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                 (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (2 subgoals):\n 1. D \\<in> sets lborel\n 2. \\<And>a b.\n       (a, b) \\<in> D \\<Longrightarrow>\n       LBINT z:{0<..<1}.\n          P a * (a * b * z) ^ n * (1 - b) ^ n /\n          (1 - (1 - a * b) * z) ^ (n + 1) =\n       LBINT w:{0<..<1}.\n          P a * (1 - w) ^ n * (1 - b) ^ n / (1 - (1 - a * b) * w)", "also"], ["proof (state)\nthis:\n  LBINT z:{0<..<1}.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1) =\n  P x *\n  (LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                 (1 - (1 - x * y) * z) ^ (n + 1))\n\ngoal (2 subgoals):\n 1. D \\<in> sets lborel\n 2. \\<And>a b.\n       (a, b) \\<in> D \\<Longrightarrow>\n       LBINT z:{0<..<1}.\n          P a * (a * b * z) ^ n * (1 - b) ^ n /\n          (1 - (1 - a * b) * z) ^ (n + 1) =\n       LBINT w:{0<..<1}.\n          P a * (1 - w) ^ n * (1 - b) ^ n / (1 - (1 - a * b) * w)", "have \"\\<dots> = P x * (LBINT w=0..1. (1-w)^n * (1-y)^n / (1-(1-x*y)*w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x *\n    (LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                   (1 - (1 - x * y) * z) ^ (n + 1)) =\n    P x * (LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "using xy"], ["proof (prove)\nusing this:\n  (x, y) \\<in> D\n\ngoal (1 subgoal):\n 1. P x *\n    (LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                   (1 - (1 - x * y) * z) ^ (n + 1)) =\n    P x * (LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "by (subst beukers_aux_integral_transform2) (auto simp: D_def)"], ["proof (state)\nthis:\n  P x *\n  (LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                 (1 - (1 - x * y) * z) ^ (n + 1)) =\n  P x * (LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (2 subgoals):\n 1. D \\<in> sets lborel\n 2. \\<And>a b.\n       (a, b) \\<in> D \\<Longrightarrow>\n       LBINT z:{0<..<1}.\n          P a * (a * b * z) ^ n * (1 - b) ^ n /\n          (1 - (1 - a * b) * z) ^ (n + 1) =\n       LBINT w:{0<..<1}.\n          P a * (1 - w) ^ n * (1 - b) ^ n / (1 - (1 - a * b) * w)", "also"], ["proof (state)\nthis:\n  P x *\n  (LBINT z=0..1. (x * y * z) ^ n * (1 - y) ^ n /\n                 (1 - (1 - x * y) * z) ^ (n + 1)) =\n  P x * (LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (2 subgoals):\n 1. D \\<in> sets lborel\n 2. \\<And>a b.\n       (a, b) \\<in> D \\<Longrightarrow>\n       LBINT z:{0<..<1}.\n          P a * (a * b * z) ^ n * (1 - b) ^ n /\n          (1 - (1 - a * b) * z) ^ (n + 1) =\n       LBINT w:{0<..<1}.\n          P a * (1 - w) ^ n * (1 - b) ^ n / (1 - (1 - a * b) * w)", "have \"\\<dots> = (LBINT w:{0<..<1}. P x * (1-w)^n * (1-y)^n / (1-(1-x*y)*w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x *\n    (LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n    LBINT w:{0<..<1}.\n       P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "by (subst interval_lebesgue_integral_mult_right [symmetric])\n         (simp add: mult_ac interval_integral_Ioo)"], ["proof (state)\nthis:\n  P x * (LBINT w=0..1. (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT w:{0<..<1}. P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n\ngoal (2 subgoals):\n 1. D \\<in> sets lborel\n 2. \\<And>a b.\n       (a, b) \\<in> D \\<Longrightarrow>\n       LBINT z:{0<..<1}.\n          P a * (a * b * z) ^ n * (1 - b) ^ n /\n          (1 - (1 - a * b) * z) ^ (n + 1) =\n       LBINT w:{0<..<1}.\n          P a * (1 - w) ^ n * (1 - b) ^ n / (1 - (1 - a * b) * w)", "finally"], ["proof (chain)\npicking this:\n  LBINT z:{0<..<1}.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1) =\n  LBINT w:{0<..<1}. P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "show \"(LBINT z:{0<..<1}. P x * (x*y*z)^n * (1-y)^n / (1-(1-x*y)*z)^(n+1)) =\n                    (LBINT w:{0<..<1}. P x * (1-w)^n * (1-y)^n / (1-(1-x*y)*w))\""], ["proof (prove)\nusing this:\n  LBINT z:{0<..<1}.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1) =\n  LBINT w:{0<..<1}. P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n\ngoal (1 subgoal):\n 1. LBINT z:{0<..<1}.\n       P x * (x * y * z) ^ n * (1 - y) ^ n /\n       (1 - (1 - x * y) * z) ^ (n + 1) =\n    LBINT w:{0<..<1}.\n       P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)", "."], ["proof (state)\nthis:\n  LBINT z:{0<..<1}.\n     P x * (x * y * z) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * z) ^ (n + 1) =\n  LBINT w:{0<..<1}. P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)\n\ngoal (1 subgoal):\n 1. D \\<in> sets lborel", "qed (auto simp: D_def simp flip: borel_prod)"], ["proof (state)\nthis:\n  LBINT (x, y):D.\n     (LBINT z:{0<..<1}.\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1)) =\n  LBINT (x, y):D.\n     (LBINT w:{0<..<1}.\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT (x, y):D.\n     (LBINT z:{0<..<1}.\n         P x * (x * y * z) ^ n * (1 - y) ^ n /\n         (1 - (1 - x * y) * z) ^ (n + 1)) =\n  LBINT (x, y):D.\n     (LBINT w:{0<..<1}.\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT w:{0<..<1}. (LBINT (x,y):D. P x * (1-w)^n * (1-y)^n / (1-(1-x*y)*w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT (x, y):D.\n       (LBINT w:{0<..<1}.\n           P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n    LBINT w:{0<..<1}.\n       (LBINT (x, y):D.\n           P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "using beukers_aux_integrable3"], ["proof (prove)\nusing this:\n  set_integrable lborel D'\n   (\\<lambda>(w, x, y).\n       P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. LBINT (x, y):D.\n       (LBINT w:{0<..<1}.\n           P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n    LBINT w:{0<..<1}.\n       (LBINT (x, y):D.\n           P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))", "by (subst lborel_pair.Fubini_set_integral [symmetric])\n       (auto simp: case_prod_unfold lborel_prod D_def D'_def)"], ["proof (state)\nthis:\n  LBINT (x, y):D.\n     (LBINT w:{0<..<1}.\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT w:{0<..<1}.\n     (LBINT (x, y):D.\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT (x, y):D.\n     (LBINT w:{0<..<1}.\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT w:{0<..<1}.\n     (LBINT (x, y):D.\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT w=0..1. (1-w)^n * (LBINT (x,y):D. P x * (1-y)^n / (1-(1-x*y)*w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w:{0<..<1}.\n       (LBINT (x, y):D.\n           P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n    LBINT w=0..1. (1 - w) ^ n *\n                  (LBINT (x, y):D.\n                      P x * (1 - y) ^ n / (1 - (1 - x * y) * w))", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w:{0<..<1}.\n       (LBINT p:D.\n           P (fst p) * (1 - w) ^ n * (1 - snd p) ^ n /\n           (1 - (1 - fst p * snd p) * w)) =\n    LBINT w=0..1. (1 - w) ^ n *\n                  (LBINT p:D.\n                      P (fst p) * (1 - snd p) ^ n /\n                      (1 - (1 - fst p * snd p) * w))", "by (subst set_integral_mult_right [symmetric]) (simp add: mult_ac interval_integral_Ioo)"], ["proof (state)\nthis:\n  LBINT w:{0<..<1}.\n     (LBINT (x, y):D.\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT w=0..1. (1 - w) ^ n *\n                (LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT w:{0<..<1}.\n     (LBINT (x, y):D.\n         P x * (1 - w) ^ n * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT w=0..1. (1 - w) ^ n *\n                (LBINT (x, y):D. P x * (1 - y) ^ n / (1 - (1 - x * y) * w))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT w=0..1. (1-w)^n * (LBINT (x,y):D. (x*y*w*(1-x)*(1-y))^n / (1-(1-x*y)*w)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w=0..1. (1 - w) ^ n *\n                  (LBINT (x, y):D.\n                      P x * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n    LBINT w=0..1. (1 - w) ^ n *\n                  (LBINT (x, y):D.\n                      (x * y * w * (1 - x) * (1 - y)) ^ n /\n                      (1 - (1 - x * y) * w) ^ (n + 1))", "by (intro interval_lebesgue_integral_lborel_01_cong, subst beukers_aux_integral_transform3)\n       (auto simp: mult_ac power_mult_distrib)"], ["proof (state)\nthis:\n  LBINT w=0..1. (1 - w) ^ n *\n                (LBINT (x, y):D.\n                    P x * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT w=0..1. (1 - w) ^ n *\n                (LBINT (x, y):D.\n                    (x * y * w * (1 - x) * (1 - y)) ^ n /\n                    (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT w=0..1. (1 - w) ^ n *\n                (LBINT (x, y):D.\n                    P x * (1 - y) ^ n / (1 - (1 - x * y) * w)) =\n  LBINT w=0..1. (1 - w) ^ n *\n                (LBINT (x, y):D.\n                    (x * y * w * (1 - x) * (1 - y)) ^ n /\n                    (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = (LBINT w=0..1. (LBINT (x,y):D. (x*y*w*(1-x)*(1-y)*(1-w))^n / (1-(1-x*y)*w)^(n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w=0..1. (1 - w) ^ n *\n                  (LBINT (x, y):D.\n                      (x * y * w * (1 - x) * (1 - y)) ^ n /\n                      (1 - (1 - x * y) * w) ^ (n + 1)) =\n    LBINT w=0..1. (LBINT (x, y):D.\n                      (x * y * w * (1 - x) * (1 - y) * (1 - w)) ^ n /\n                      (1 - (1 - x * y) * w) ^ (n + 1))", "by (subst set_integral_mult_right [symmetric])\n       (auto simp: case_prod_unfold mult_ac power_mult_distrib)"], ["proof (state)\nthis:\n  LBINT w=0..1. (1 - w) ^ n *\n                (LBINT (x, y):D.\n                    (x * y * w * (1 - x) * (1 - y)) ^ n /\n                    (1 - (1 - x * y) * w) ^ (n + 1)) =\n  LBINT w=0..1. (LBINT (x, y):D.\n                    (x * y * w * (1 - x) * (1 - y) * (1 - w)) ^ n /\n                    (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "also"], ["proof (state)\nthis:\n  LBINT w=0..1. (1 - w) ^ n *\n                (LBINT (x, y):D.\n                    (x * y * w * (1 - x) * (1 - y)) ^ n /\n                    (1 - (1 - x * y) * w) ^ (n + 1)) =\n  LBINT w=0..1. (LBINT (x, y):D.\n                    (x * y * w * (1 - x) * (1 - y) * (1 - w)) ^ n /\n                    (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "have \"\\<dots> = beukers_integral3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT w=0..1. (LBINT (x, y):D.\n                      (x * y * w * (1 - x) * (1 - y) * (1 - w)) ^ n /\n                      (1 - (1 - x * y) * w) ^ (n + 1)) =\n    local.beukers_integral3", "using beukers_integral3_integrable"], ["proof (prove)\nusing this:\n  set_integrable lborel D'\n   (\\<lambda>(w, x, y).\n       (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT w=0..1. (LBINT (x, y):D.\n                      (x * y * w * (1 - x) * (1 - y) * (1 - w)) ^ n /\n                      (1 - (1 - x * y) * w) ^ (n + 1)) =\n    local.beukers_integral3", "unfolding D'_def D_def beukers_integral3_def"], ["proof (prove)\nusing this:\n  set_integrable lborel ({0<..<1} \\<times> {0<..<1} \\<times> {0<..<1})\n   (\\<lambda>(w, x, y).\n       (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1))\n\ngoal (1 subgoal):\n 1. LBINT w=0..1. (LBINT (x, y):{0<..<1} \\<times> {0<..<1}.\n                      (x * y * w * (1 - x) * (1 - y) * (1 - w)) ^ n /\n                      (1 - (1 - x * y) * w) ^ (n + 1)) =\n    LBINT (w, x, y):{0<..<1} \\<times> {0<..<1} \\<times> {0<..<1}.\n       (x * (1 - x) * y * (1 - y) * w * (1 - w)) ^ n /\n       (1 - (1 - x * y) * w) ^ (n + 1)", "by (subst (2) lborel_prod [symmetric], subst lborel_pair.set_integral_fst')\n       (auto simp: case_prod_unfold interval_integral_Ioo lborel_prod algebra_simps)"], ["proof (state)\nthis:\n  LBINT w=0..1. (LBINT (x, y):D.\n                    (x * y * w * (1 - x) * (1 - y) * (1 - w)) ^ n /\n                    (1 - (1 - x * y) * w) ^ (n + 1)) =\n  local.beukers_integral3\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "finally"], ["proof (chain)\npicking this:\n  local.beukers_integral2 = local.beukers_integral3", "show ?thesis"], ["proof (prove)\nusing this:\n  local.beukers_integral2 = local.beukers_integral3\n\ngoal (1 subgoal):\n 1. local.beukers_integral2 = local.beukers_integral3", "."], ["proof (state)\nthis:\n  local.beukers_integral2 = local.beukers_integral3\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The main result\\<close>"], ["", "text \\<open>\n  Combining all of the results so far, we can derive the key inequalities\n  \\[0 < A\\zeta(3) + B < 2 \\zeta(3) \\cdot 27^{-n} \\cdot \\text{lcm}\\{1\\ldots n\\}^3\\]\n  for integers $A$, $B$ with $A > 0$.\n\\<close>"], ["", "lemma zeta_3_linear_combination_bounds:\n  obtains A B :: int\n  where \"A > 0\"\n        \"A * Re (zeta 3) + B \\<in> {0 <.. 2 * Re (zeta 3) * Lcm {1..n} ^ 3 / 27 ^ n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define I where \"I = beukers_integral2\""], ["proof (state)\nthis:\n  I = local.beukers_integral2\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define d where \"d = Lcm {1..n} ^ 3\""], ["proof (state)\nthis:\n  d = Lcm {1..n} ^ 3\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"d > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d", "by (auto simp: d_def intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from beukers_integral2_conv_int_combination"], ["proof (chain)\npicking this:\n  (\\<And>A B.\n      \\<lbrakk>0 < A;\n       local.beukers_integral2 =\n       real_of_int A * Re (zeta 3) +\n       real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain A' B :: int\n    where *: \"A' > 0\" \"I = A' * Re (zeta 3) + B / d\""], ["proof (prove)\nusing this:\n  (\\<And>A B.\n      \\<lbrakk>0 < A;\n       local.beukers_integral2 =\n       real_of_int A * Re (zeta 3) +\n       real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A' B.\n        \\<lbrakk>0 < A';\n         I = real_of_int A' * Re (zeta 3) + real_of_int B / real d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding I_def d_def"], ["proof (prove)\nusing this:\n  (\\<And>A B.\n      \\<lbrakk>0 < A;\n       local.beukers_integral2 =\n       real_of_int A * Re (zeta 3) +\n       real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A' B.\n        \\<lbrakk>0 < A';\n         local.beukers_integral2 =\n         real_of_int A' * Re (zeta 3) +\n         real_of_int B / real (Lcm {1..n} ^ 3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  0 < A'\n  I = real_of_int A' * Re (zeta 3) + real_of_int B / real d\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define A where \"A = A' * d\""], ["proof (state)\nthis:\n  A = A' * int d\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from *"], ["proof (chain)\npicking this:\n  0 < A'\n  I = real_of_int A' * Re (zeta 3) + real_of_int B / real d", "have A: \"A > 0\" \"I = (A * Re (zeta 3) + B) / d\""], ["proof (prove)\nusing this:\n  0 < A'\n  I = real_of_int A' * Re (zeta 3) + real_of_int B / real d\n\ngoal (1 subgoal):\n 1. 0 < A &&& I = (real_of_int A * Re (zeta 3) + real_of_int B) / real d", "using \\<open>d > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < A'\n  I = real_of_int A' * Re (zeta 3) + real_of_int B / real d\n  0 < d\n\ngoal (1 subgoal):\n 1. 0 < A &&& I = (real_of_int A * Re (zeta 3) + real_of_int B) / real d", "by (simp_all add: A_def field_simps)"], ["proof (state)\nthis:\n  0 < A\n  I = (real_of_int A * Re (zeta 3) + real_of_int B) / real d\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"0 < I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < I", "using beukers_integral3_pos"], ["proof (prove)\nusing this:\n  0 < local.beukers_integral3\n\ngoal (1 subgoal):\n 1. 0 < I", "by (simp add: I_def beukers_integral2_conv_3)"], ["proof (state)\nthis:\n  0 < I\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>d > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < d\n  0 < I", "have \"A * Re (zeta 3) + B > 0\""], ["proof (prove)\nusing this:\n  0 < d\n  0 < I\n\ngoal (1 subgoal):\n 1. 0 < real_of_int A * Re (zeta 3) + real_of_int B", "by (simp add: field_simps A)"], ["proof (state)\nthis:\n  0 < real_of_int A * Re (zeta 3) + real_of_int B\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  0 < real_of_int A * Re (zeta 3) + real_of_int B\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"I \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "using beukers_integral2_conv_3 beukers_integral3_le"], ["proof (prove)\nusing this:\n  local.beukers_integral2 = local.beukers_integral3\n  local.beukers_integral3 \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\n\ngoal (1 subgoal):\n 1. I \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)", "by (simp add: I_def)"], ["proof (state)\nthis:\n  I \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"A * Re (zeta 3) + B \\<le> 2 * Re (zeta 3) * d / 27 ^ n\""], ["proof (prove)\nusing this:\n  I \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\n\ngoal (1 subgoal):\n 1. real_of_int A * Re (zeta 3) + real_of_int B\n    \\<le> 2 * Re (zeta 3) * real d / 27 ^ n", "using \\<open>d > 0\\<close>"], ["proof (prove)\nusing this:\n  I \\<le> 2 * (1 / 27) ^ n * Re (zeta 3)\n  0 < d\n\ngoal (1 subgoal):\n 1. real_of_int A * Re (zeta 3) + real_of_int B\n    \\<le> 2 * Re (zeta 3) * real d / 27 ^ n", "by (simp add: A field_simps)"], ["proof (state)\nthis:\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<le> 2 * Re (zeta 3) * real d / 27 ^ n\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  0 < real_of_int A * Re (zeta 3) + real_of_int B\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<le> 2 * Re (zeta 3) * real d / 27 ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < real_of_int A * Re (zeta 3) + real_of_int B\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<le> 2 * Re (zeta 3) * real d / 27 ^ n\n\ngoal (1 subgoal):\n 1. thesis", "using A"], ["proof (prove)\nusing this:\n  0 < real_of_int A * Re (zeta 3) + real_of_int B\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<le> 2 * Re (zeta 3) * real d / 27 ^ n\n  0 < A\n  I = (real_of_int A * Re (zeta 3) + real_of_int B) / real d\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of A B]) (auto simp: d_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If $\\zeta(3) = \\frac{a}{b}$ for some integers $a$ and $b$, we can thus derive\n  the inequality $2b\\zeta(3) \\cdot 27^{-n} \\cdot \\text{lcm}\\{1\\ldots n\\}^3\\geq 1$ for any\n  natural number $n$.\n\\<close>"], ["", "lemma beukers_key_inequality:\n  fixes a :: int and b :: nat\n  assumes \"b > 0\" and ab: \"Re (zeta 3) = a / b\"\n  shows   \"2 * b * Re (zeta 3) * Lcm {1..n} ^ 3 / 27 ^ n \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "from zeta_3_linear_combination_bounds"], ["proof (chain)\npicking this:\n  (\\<And>A B.\n      \\<lbrakk>0 < A;\n       real_of_int A * Re (zeta 3) + real_of_int B\n       \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain A B :: int\n    where AB: \"A > 0\"\n              \"A * Re (zeta 3) + B \\<in> {0 <.. 2 * Re (zeta 3) * Lcm {1..n} ^ 3 / 27 ^ n}\""], ["proof (prove)\nusing this:\n  (\\<And>A B.\n      \\<lbrakk>0 < A;\n       real_of_int A * Re (zeta 3) + real_of_int B\n       \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>0 < A;\n         real_of_int A * Re (zeta 3) + real_of_int B\n         \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) /\n                    27 ^ n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  0 < A\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n}\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "from AB"], ["proof (chain)\npicking this:\n  0 < A\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n}", "have \"0 < (A * Re (zeta 3) + B) * b\""], ["proof (prove)\nusing this:\n  0 < A\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n}\n\ngoal (1 subgoal):\n 1. 0 < (real_of_int A * Re (zeta 3) + real_of_int B) * real b", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < A\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n}\n  0 < b\n\ngoal (1 subgoal):\n 1. 0 < (real_of_int A * Re (zeta 3) + real_of_int B) * real b", "by (intro mult_pos_pos) auto"], ["proof (state)\nthis:\n  0 < (real_of_int A * Re (zeta 3) + real_of_int B) * real b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "also"], ["proof (state)\nthis:\n  0 < (real_of_int A * Re (zeta 3) + real_of_int B) * real b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "have \"\\<dots> = A * (Re (zeta 3) * b) + B * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of_int A * Re (zeta 3) + real_of_int B) * real b =\n    real_of_int A * (Re (zeta 3) * real b) + real_of_int (B * int b)", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. (real_of_int A * Re (zeta 3) + real_of_int B) * real b =\n    real_of_int A * (Re (zeta 3) * real b) + real_of_int (B * int b)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (real_of_int A * Re (zeta 3) + real_of_int B) * real b =\n  real_of_int A * (Re (zeta 3) * real b) + real_of_int (B * int b)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "also"], ["proof (state)\nthis:\n  (real_of_int A * Re (zeta 3) + real_of_int B) * real b =\n  real_of_int A * (Re (zeta 3) * real b) + real_of_int (B * int b)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "have \"Re (zeta 3) * b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (zeta 3) * real b = real_of_int a", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. Re (zeta 3) * real b = real_of_int a", "by (simp add: ab)"], ["proof (state)\nthis:\n  Re (zeta 3) * real b = real_of_int a\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "also"], ["proof (state)\nthis:\n  Re (zeta 3) * real b = real_of_int a\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "have \"of_int A * of_int a + of_int (B * b) = of_int (A * a + B * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int A * of_int a + of_int (B * int b) = of_int (A * a + B * int b)", "by simp"], ["proof (state)\nthis:\n  of_int A * of_int a + of_int (B * int b) = of_int (A * a + B * int b)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "finally"], ["proof (chain)\npicking this:\n  0 < real_of_int (A * a + B * int b)", "have \"1 \\<le> A * a + B * b\""], ["proof (prove)\nusing this:\n  0 < real_of_int (A * a + B * int b)\n\ngoal (1 subgoal):\n 1. 1 \\<le> A * a + B * int b", "by linarith"], ["proof (state)\nthis:\n  1 \\<le> A * a + B * int b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "hence \"1 \\<le> real_of_int (A * a + B * b)\""], ["proof (prove)\nusing this:\n  1 \\<le> A * a + B * int b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real_of_int (A * a + B * int b)", "by linarith"], ["proof (state)\nthis:\n  1 \\<le> real_of_int (A * a + B * int b)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "also"], ["proof (state)\nthis:\n  1 \\<le> real_of_int (A * a + B * int b)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "have \"\\<dots> = (A * (a / b) + B) * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (A * a + B * int b) =\n    (real_of_int A * (real_of_int a / real b) + real_of_int B) * real b", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. real_of_int (A * a + B * int b) =\n    (real_of_int A * (real_of_int a / real b) + real_of_int B) * real b", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  real_of_int (A * a + B * int b) =\n  (real_of_int A * (real_of_int a / real b) + real_of_int B) * real b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "also"], ["proof (state)\nthis:\n  real_of_int (A * a + B * int b) =\n  (real_of_int A * (real_of_int a / real b) + real_of_int B) * real b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "have \"a / b = Re (zeta 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int a / real b = Re (zeta 3)", "by (simp add: ab)"], ["proof (state)\nthis:\n  real_of_int a / real b = Re (zeta 3)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "also"], ["proof (state)\nthis:\n  real_of_int a / real b = Re (zeta 3)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "have \"A * Re (zeta 3) + B \\<le> 2 * Re (zeta 3) * Lcm {1..n} ^ 3 / 27 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int A * Re (zeta 3) + real_of_int B\n    \\<le> 2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "using AB"], ["proof (prove)\nusing this:\n  0 < A\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<in> {0<..2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n}\n\ngoal (1 subgoal):\n 1. real_of_int A * Re (zeta 3) + real_of_int B\n    \\<le> 2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "by simp"], ["proof (state)\nthis:\n  real_of_int A * Re (zeta 3) + real_of_int B\n  \\<le> 2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x * real b \\<le> y * real b) \\<Longrightarrow>\n  1 \\<le> 2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n * real b", "show \"2 * b * Re (zeta 3) * Lcm {1..n} ^ 3 / 27 ^ n \\<ge> 1\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x * real b \\<le> y * real b) \\<Longrightarrow>\n  1 \\<le> 2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n * real b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x * real b \\<le> y * real b) \\<Longrightarrow>\n  1 \\<le> 2 * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n * real b\n  0 < b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* TODO: Move *)"], ["", "lemma smallo_power: \"n > 0 \\<Longrightarrow> f \\<in> o[F](g) \\<Longrightarrow> (\\<lambda>x. f x ^ n) \\<in> o[F](\\<lambda>x. g x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; f \\<in> o[F](g)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. f x ^ n) \\<in> o[F](\\<lambda>x. g x ^ n)", "by (induction n rule: nat_induct_non_zero) (auto intro: landau_o.small.mult)"], ["", "text \\<open>\n  This is now a contradiction, since $\\text{lcm}\\{1\\ldots n\\} \\in o(3^n)$ by the\n  Prime Number Theorem -- hence the main result.\n\\<close>"], ["", "theorem zeta_3_irrational: \"zeta 3 \\<notin> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zeta 3 \\<notin> \\<rat>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "assume \"zeta 3 \\<in> \\<rat>\""], ["proof (state)\nthis:\n  zeta 3 \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "obtain a :: int and b :: nat where \"b > 0\" and ab': \"zeta 3 = a / b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>zeta 3 \\<in> \\<rat>\\<close>"], ["proof (chain)\npicking this:\n  zeta 3 \\<in> \\<rat>", "obtain r where r: \"zeta 3 = of_rat r\""], ["proof (prove)\nusing this:\n  zeta 3 \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. (\\<And>r. zeta 3 = of_rat r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim Rats_cases)"], ["proof (state)\nthis:\n  zeta 3 = of_rat r\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  zeta 3 = of_rat r\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"r = rat_of_int (fst (quotient_of r)) / rat_of_int (snd (quotient_of r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = rat_of_int (fst (quotient_of r)) / rat_of_int (snd (quotient_of r))", "by (intro quotient_of_div) auto"], ["proof (state)\nthis:\n  r = rat_of_int (fst (quotient_of r)) / rat_of_int (snd (quotient_of r))\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  r = rat_of_int (fst (quotient_of r)) / rat_of_int (snd (quotient_of r))\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"of_rat \\<dots> = (of_int (fst (quotient_of r)) / of_int (snd (quotient_of r)) :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat\n     (rat_of_int (fst (quotient_of r)) / rat_of_int (snd (quotient_of r))) =\n    of_int (fst (quotient_of r)) / of_int (snd (quotient_of r))", "by (simp add: of_rat_divide)"], ["proof (state)\nthis:\n  of_rat\n   (rat_of_int (fst (quotient_of r)) / rat_of_int (snd (quotient_of r))) =\n  of_int (fst (quotient_of r)) / of_int (snd (quotient_of r))\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  of_rat\n   (rat_of_int (fst (quotient_of r)) / rat_of_int (snd (quotient_of r))) =\n  of_int (fst (quotient_of r)) / of_int (snd (quotient_of r))\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"of_int (snd (quotient_of r)) = of_nat (nat (snd (quotient_of r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (snd (quotient_of r)) = of_nat (nat (snd (quotient_of r)))", "using quotient_of_denom_pos'[of r]"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of r)\n\ngoal (1 subgoal):\n 1. of_int (snd (quotient_of r)) = of_nat (nat (snd (quotient_of r)))", "by auto"], ["proof (state)\nthis:\n  of_int (snd (quotient_of r)) = of_nat (nat (snd (quotient_of r)))\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  zeta 3 = of_int (fst (quotient_of r)) / of_nat (nat (snd (quotient_of r)))", "have \"zeta 3 = of_int (fst (quotient_of r)) / of_nat (nat (snd (quotient_of r)))\""], ["proof (prove)\nusing this:\n  zeta 3 = of_int (fst (quotient_of r)) / of_nat (nat (snd (quotient_of r)))\n\ngoal (1 subgoal):\n 1. zeta 3 =\n    of_int (fst (quotient_of r)) / of_nat (nat (snd (quotient_of r)))", "."], ["proof (state)\nthis:\n  zeta 3 = of_int (fst (quotient_of r)) / of_nat (nat (snd (quotient_of r)))\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>0 < b;\n         zeta 3 = complex_of_real (real_of_int a / real b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  zeta 3 = of_int (fst (quotient_of r)) / of_nat (nat (snd (quotient_of r)))\n\ngoal (1 subgoal):\n 1. thesis", "using quotient_of_denom_pos'[of r]"], ["proof (prove)\nusing this:\n  zeta 3 = of_int (fst (quotient_of r)) / of_nat (nat (snd (quotient_of r)))\n  0 < snd (quotient_of r)\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of \"nat (snd (quotient_of r))\" \"fst (quotient_of r)\"]) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < b\n  zeta 3 = complex_of_real (real_of_int a / real b)\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "hence ab: \"Re (zeta 3) = a / b\""], ["proof (prove)\nusing this:\n  0 < b\n  zeta 3 = complex_of_real (real_of_int a / real b)\n\ngoal (1 subgoal):\n 1. Re (zeta 3) = real_of_int a / real b", "by simp"], ["proof (state)\nthis:\n  Re (zeta 3) = real_of_int a / real b\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "interpret prime_number_theorem"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_number_theorem", "by standard (rule prime_number_theorem)"], ["proof (state)\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "have Lcm_upto_smallo: \"(\\<lambda>n. real (Lcm {1..n})) \\<in> o(\\<lambda>n. c ^ n)\" if c: \"c > exp 1\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "have \"0 < exp (1::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < exp 1", "by simp"], ["proof (state)\nthis:\n  0 < exp 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "also"], ["proof (state)\nthis:\n  0 < exp 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "note c"], ["proof (state)\nthis:\n  exp 1 < c\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "finally"], ["proof (chain)\npicking this:\n  0 < c", "have \"c > 0\""], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 < c", "."], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "have \"(\\<lambda>n. real (Lcm {1..n})) = (\\<lambda>n. real (Lcm {1..nat \\<lfloor>real n\\<rfloor>}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) =\n    (\\<lambda>n. real (Lcm {1..nat \\<lfloor>real n\\<rfloor>}))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. real (Lcm {1..n})) =\n  (\\<lambda>n. real (Lcm {1..nat \\<lfloor>real n\\<rfloor>}))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. real (Lcm {1..n})) =\n  (\\<lambda>n. real (Lcm {1..nat \\<lfloor>real n\\<rfloor>}))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "have \"\\<dots> \\<in> o(\\<lambda>n. c powr real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..nat \\<lfloor>real n\\<rfloor>}))\n    \\<in> o(\\<lambda>n. c powr real n)", "using Lcm_upto.smallo'"], ["proof (prove)\nusing this:\n  exp 1 < ?c \\<Longrightarrow>\n  (\\<lambda>x. real (Lcm {1..nat \\<lfloor>x\\<rfloor>})) \\<in> o((powr) ?c)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..nat \\<lfloor>real n\\<rfloor>}))\n    \\<in> o(\\<lambda>n. c powr real n)", "by (rule landau_o.small.compose) (simp_all add: c filterlim_real_sequentially)"], ["proof (state)\nthis:\n  (\\<lambda>n. real (Lcm {1..nat \\<lfloor>real n\\<rfloor>}))\n  \\<in> o(\\<lambda>n. c powr real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. real (Lcm {1..nat \\<lfloor>real n\\<rfloor>}))\n  \\<in> o(\\<lambda>n. c powr real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "have \"(\\<lambda>n. c powr real n) = (\\<lambda>n. c ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. c powr real n) = (^) c", "using c \\<open>c > 0\\<close>"], ["proof (prove)\nusing this:\n  exp 1 < c\n  0 < c\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. c powr real n) = (^) c", "by (subst powr_realpow) auto"], ["proof (state)\nthis:\n  (\\<lambda>n. c powr real n) = (^) c\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)", "."], ["proof (state)\nthis:\n  (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exp 1 < ?c \\<Longrightarrow>\n  (\\<lambda>n. real (Lcm {1..n})) \\<in> o((^) ?c)\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "have \"(\\<lambda>n. 2 * b * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n) \\<in>\n          O(\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n    \\<in> O(\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)", "using \\<open>b > 0\\<close> Re_zeta_ge_1[of 3]"], ["proof (prove)\nusing this:\n  0 < b\n  1 < 3 \\<Longrightarrow> 1 \\<le> Re (zeta (complex_of_real 3))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n    \\<in> O(\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<in> O(\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<in> O(\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "have \"exp 1 < (3 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 < 3", "using e_approx_32"], ["proof (prove)\nusing this:\n  \\<bar>exp 1 - 5837465777 / 2147483648\\<bar> \\<le> inverse (2 ^ 32)\n\ngoal (1 subgoal):\n 1. exp 1 < 3", "by (simp add: abs_if split: if_splits)"], ["proof (state)\nthis:\n  exp 1 < 3\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "hence \"(\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n) \\<in> o(\\<lambda>n. (3 ^ n) ^ 3 / 27 ^ n)\""], ["proof (prove)\nusing this:\n  exp 1 < 3\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)\n    \\<in> o(\\<lambda>n. (3 ^ n) ^ 3 / 27 ^ n)", "unfolding of_nat_power"], ["proof (prove)\nusing this:\n  exp 1 < 3\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)\n    \\<in> o(\\<lambda>n. (3 ^ n) ^ 3 / 27 ^ n)", "by (intro landau_o.small.divide_right smallo_power Lcm_upto_smallo) auto"], ["proof (state)\nthis:\n  (\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<in> o(\\<lambda>n. (3 ^ n) ^ 3 / 27 ^ n)\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<in> o(\\<lambda>n. (3 ^ n) ^ 3 / 27 ^ n)\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "have \"(\\<lambda>n. (3 ^ n) ^ 3 / 27 ^ n :: real) = (\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (3 ^ n) ^ 3 / 27 ^ n) = (\\<lambda>_. 1)", "by (simp add: power_mult [of 3, symmetric] mult.commute[of _ 3] power_mult[of _ 3])"], ["proof (state)\nthis:\n  (\\<lambda>n. (3 ^ n) ^ 3 / 27 ^ n) = (\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<in> o(\\<lambda>n. 1)", "have *: \"(\\<lambda>n. 2 * b * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n) \\<in> o(\\<lambda>_. 1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<in> o(\\<lambda>n. 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n    \\<in> o(\\<lambda>_. 1)", "."], ["proof (state)\nthis:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<in> o(\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "have lim: \"(\\<lambda>n. 2 * b * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n    \\<longlonglongrightarrow> 0", "using smalloD_tendsto[OF *]"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      real (2 * b) * Re (zeta 3) * real (Lcm {1..x}) ^ 3 / 27 ^ x / 1)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n    \\<longlonglongrightarrow> 0", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "have \"1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "using beukers_key_inequality[of b a] ab \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < b; Re (zeta 3) = real_of_int a / real b\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> real (2 * b) * Re (zeta 3) *\n                            real (Lcm {1..?n} ^ 3) /\n                            27 ^ ?n\n  Re (zeta 3) = real_of_int a / real b\n  0 < b\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..n} ^ 3) / 27 ^ n", "by simp"], ["proof (state)\nthis:\n  1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..?n} ^ 3) / 27 ^ ?n\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<longlonglongrightarrow> 0\n  1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..?n} ^ 3) / 27 ^ ?n", "have \"1 \\<le> (0 :: real)\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. real (2 * b) * Re (zeta 3) * real (Lcm {1..n}) ^ 3 / 27 ^ n)\n  \\<longlonglongrightarrow> 0\n  1 \\<le> real (2 * b) * Re (zeta 3) * real (Lcm {1..?n} ^ 3) / 27 ^ ?n\n\ngoal (1 subgoal):\n 1. 1 \\<le> 0", "by (intro tendsto_lowerbound[OF lim] always_eventually allI) auto"], ["proof (state)\nthis:\n  1 \\<le> 0\n\ngoal (1 subgoal):\n 1. zeta 3 \\<in> \\<rat> \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  1 \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}