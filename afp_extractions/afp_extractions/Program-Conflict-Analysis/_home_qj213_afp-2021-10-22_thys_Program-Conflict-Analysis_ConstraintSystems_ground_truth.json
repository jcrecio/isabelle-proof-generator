{"file_name": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis/ConstraintSystems.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis", "problem_names": ["lemma (in flowgraph) S_sound: \"!!p v c' P. \n  \\<lbrakk>(([entry fg p],{#}),w,([v],c'))\\<in>trcl (trss fg); \n    size P\\<le>k; (\\<lambda>p. [entry fg p]) `# P \\<subseteq># c' \\<rbrakk>\n  \\<Longrightarrow> (v,mon_w fg w,P)\\<in>S_cs fg k\"", "lemma (in flowgraph) S_precise: \"(v,M,P)\\<in>S_cs fg k \n  \\<Longrightarrow> \\<exists>p c' w. \n        (([entry fg p],{#}),w,([v],c'))\\<in>trcl (trss fg) \\<and> \n        size P\\<le>k \\<and> \n        (\\<lambda>p. [entry fg p]) `# P \\<subseteq># c' \\<and>\n        M=mon_w fg w\"", "theorem (in flowgraph) S_sound_precise: \n  \"(v,M,P)\\<in>S_cs fg k \\<longleftrightarrow> \n  (\\<exists>p c' w. (([entry fg p],{#}),w,([v],c'))\\<in>trcl (trss fg) \\<and> \n    size P\\<le>k \\<and> (\\<lambda>p. [entry fg p]) `# P \\<subseteq># c' \\<and> M=mon_w fg w)\"", "lemma (in flowgraph) S_sound_ntrp: \n  assumes A: \"(([u],{#}),eel,(sh,ch))\\<in>ntrp fg\" and \n  CASE: \"!!p u' v w. \\<lbrakk>\n    eel=LOC (LCall p#w); \n    (u,Call p,u')\\<in>edges fg; \n    sh=[v,u']; \n    proc_of fg v = p; \n    mon_c fg ch = {}; \n    !!s. s \\<in># ch \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> \n                     (u,Spawn p,v)\\<in>edges fg \\<and> \n                     initialproc fg p; \n    !!P. (\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch \\<Longrightarrow>\n                    (v,mon_w fg w,P)\\<in>S_cs fg (size P)\n  \\<rbrakk> \\<Longrightarrow> Q\"\n  shows Q", "lemma (in flowgraph) S_precise_ntrp: \n  assumes ENTRY: \"(v,M,P)\\<in>S_cs fg k\" and \n              P: \"proc_of fg v = p\" and \n           EDGE: \"(u,Call p,u')\\<in>edges fg\"\n  shows \"\\<exists>w ch. \n    (([u],{#}),LOC (LCall p#w),([v,u'],ch))\\<in>ntrp fg \\<and> \n    size P \\<le> k \\<and> \n    M=mon_w fg w \\<and> \n    mon_n fg v = mon fg p \\<and> \n    (\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch \\<and>\n    mon_c fg ch={}\"", "lemma (in flowgraph) ntr_reverse_split_atU: \n  assumes V: \"valid fg c\" and \n          A: \"atU U c'\" and \n          B: \"(c,w,c')\\<in>trcl (ntr fg)\" \n  shows \"\\<exists>s w' c1'. \n           s \\<in># c \\<and> w'\\<preceq>w \\<and> c1' \\<subseteq># c' \\<and>\n           atU U c1' \\<and> ({#s#},w',c1')\\<in>trcl (ntr fg)\"", "lemma (in flowgraph) RU_sound: \n  \"!!u s' c'. \\<lbrakk>(([u],{#}),w,(s',c'))\\<in>trcl (ntrp fg); atU U (add_mset s' c')\\<rbrakk> \n  \\<Longrightarrow> \\<exists>Ml Me h. \n    (u,Ml,Me,h)\\<in>RU_cs fg U \\<and> \n    Ml \\<subseteq> mon_loc fg w \\<and> \n    Me \\<subseteq> mon_env fg w \\<and> \n    h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w)\"\n\\<comment> \\<open>The proof works by induction over the length of the reaching path\\<close>", "lemma (in flowgraph) RU_precise: \"(u,Ml,Me,h)\\<in>RU_cs fg U \n  \\<Longrightarrow> \\<exists>w s' c'. \n    (([u],{#}),w,(s',c'))\\<in>trcl (ntrp fg) \\<and> \n    atU U ({#s'#}+c') \\<and> \n    mon_loc fg w = Ml \\<and> \n    mon_env fg w = Me \\<and> \n    \\<alpha>ah (map (\\<alpha>nl fg) w) = h\"", "lemma (in flowgraph) RUV_sound: \"!!u s' c'. \n  \\<lbrakk> (([u],{#}),w,(s',c'))\\<in>trcl (ntrp fg); atUV U V ({#s'#}+c') \\<rbrakk> \n  \\<Longrightarrow> \\<exists>Ml Me. \n    (u,Ml,Me)\\<in>RUV_cs fg U V \\<and> \n    Ml \\<subseteq> mon_loc fg w \\<and> \n    Me \\<subseteq> mon_env fg w\"\n\\<comment> \\<open>The soundness proof is done by induction over the length of the reaching path\\<close>", "lemma (in flowgraph) RUV_precise: \"(u,Ml,Me)\\<in>RUV_cs fg U V \n  \\<Longrightarrow> \\<exists>w s' c'. \n    (([u],{#}),w,(s',c'))\\<in>trcl (ntrp fg) \\<and> \n    atUV U V ({#s'#}+c') \\<and> \n    mon_loc fg w = Ml \\<and> \n    mon_env fg w = Me\""], "translations": [["", "lemma (in flowgraph) S_sound: \"!!p v c' P. \n  \\<lbrakk>(([entry fg p],{#}),w,([v],c'))\\<in>trcl (trss fg); \n    size P\\<le>k; (\\<lambda>p. [entry fg p]) `# P \\<subseteq># c' \\<rbrakk>\n  \\<Longrightarrow> (v,mon_w fg w,P)\\<in>S_cs fg k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p v c' P.\n       \\<lbrakk>(([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg w, P) \\<in> S_cs fg k", "proof (induct w rule: length_compl_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p v c' P.\n       \\<lbrakk>(([entry fg p], {#}), [], [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg [], P) \\<in> S_cs fg k\n 2. \\<And>l e p v c' P.\n       \\<lbrakk>\\<And>ll p v c' P.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([entry fg p], {#}), ll, [v], c') \\<in> trcl (trss fg);\n                    size P \\<le> k;\n                    {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n                   \\<Longrightarrow> (v, mon_w fg ll, P) \\<in> S_cs fg k;\n        (([entry fg p], {#}), l @ [e], [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (l @ [e]), P) \\<in> S_cs fg k", "case Nil"], ["proof (state)\nthis:\n  (([entry fg p], {#}), [], [v], c') \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n\ngoal (2 subgoals):\n 1. \\<And>p v c' P.\n       \\<lbrakk>(([entry fg p], {#}), [], [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg [], P) \\<in> S_cs fg k\n 2. \\<And>l e p v c' P.\n       \\<lbrakk>\\<And>ll p v c' P.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([entry fg p], {#}), ll, [v], c') \\<in> trcl (trss fg);\n                    size P \\<le> k;\n                    {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n                   \\<Longrightarrow> (v, mon_w fg ll, P) \\<in> S_cs fg k;\n        (([entry fg p], {#}), l @ [e], [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (l @ [e]), P) \\<in> S_cs fg k", "thus ?case"], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), [], [v], c') \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n\ngoal (1 subgoal):\n 1. (v, mon_w fg [], P) \\<in> S_cs fg k", "by (auto intro: S_init)"], ["proof (state)\nthis:\n  (v, mon_w fg [], P) \\<in> S_cs fg k\n\ngoal (1 subgoal):\n 1. \\<And>l e p v c' P.\n       \\<lbrakk>\\<And>ll p v c' P.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([entry fg p], {#}), ll, [v], c') \\<in> trcl (trss fg);\n                    size P \\<le> k;\n                    {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n                   \\<Longrightarrow> (v, mon_w fg ll, P) \\<in> S_cs fg k;\n        (([entry fg p], {#}), l @ [e], [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (l @ [e]), P) \\<in> S_cs fg k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l e p v c' P.\n       \\<lbrakk>\\<And>ll p v c' P.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([entry fg p], {#}), ll, [v], c') \\<in> trcl (trss fg);\n                    size P \\<le> k;\n                    {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n                   \\<Longrightarrow> (v, mon_w fg ll, P) \\<in> S_cs fg k;\n        (([entry fg p], {#}), l @ [e], [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (l @ [e]), P) \\<in> S_cs fg k", "case (snoc w e)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([entry fg ?p], {#}), ?ll, [?v], ?c') \\<in> trcl (trss fg);\n   size ?P \\<le> k; {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ?c'\\<rbrakk>\n  \\<Longrightarrow> (?v, mon_w fg ?ll, ?P) \\<in> S_cs fg k\n  (([entry fg p], {#}), w @ [e], [v], c') \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n\ngoal (1 subgoal):\n 1. \\<And>l e p v c' P.\n       \\<lbrakk>\\<And>ll p v c' P.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([entry fg p], {#}), ll, [v], c') \\<in> trcl (trss fg);\n                    size P \\<le> k;\n                    {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n                   \\<Longrightarrow> (v, mon_w fg ll, P) \\<in> S_cs fg k;\n        (([entry fg p], {#}), l @ [e], [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (l @ [e]), P) \\<in> S_cs fg k", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([entry fg ?p], {#}), ?ll, [?v], ?c') \\<in> trcl (trss fg);\n   size ?P \\<le> k; {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ?c'\\<rbrakk>\n  \\<Longrightarrow> (?v, mon_w fg ?ll, ?P) \\<in> S_cs fg k\n  (([entry fg p], {#}), w @ [e], [v], c') \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'", "obtain sh ch where SPLIT: \"(([entry fg p],{#}),w,(sh,ch))\\<in>trcl (trss fg)\" \"((sh,ch),e,([v],c'))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([entry fg ?p], {#}), ?ll, [?v], ?c') \\<in> trcl (trss fg);\n   size ?P \\<le> k; {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ?c'\\<rbrakk>\n  \\<Longrightarrow> (?v, mon_w fg ?ll, ?P) \\<in> S_cs fg k\n  (([entry fg p], {#}), w @ [e], [v], c') \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>(([entry fg p], {#}), w, sh, ch) \\<in> trcl (trss fg);\n         ((sh, ch), e, [v], c') \\<in> trss fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_rev_uncons)"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w, sh, ch) \\<in> trcl (trss fg)\n  ((sh, ch), e, [v], c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>l e p v c' P.\n       \\<lbrakk>\\<And>ll p v c' P.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([entry fg p], {#}), ll, [v], c') \\<in> trcl (trss fg);\n                    size P \\<le> k;\n                    {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n                   \\<Longrightarrow> (v, mon_w fg ll, P) \\<in> S_cs fg k;\n        (([entry fg p], {#}), l @ [e], [v], c') \\<in> trcl (trss fg);\n        size P \\<le> k;\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (l @ [e]), P) \\<in> S_cs fg k", "from SPLIT(2)"], ["proof (chain)\npicking this:\n  ((sh, ch), e, [v], c') \\<in> trss fg", "show ?case"], ["proof (prove)\nusing this:\n  ((sh, ch), e, [v], c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "proof (cases rule: trss.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u a.\n       \\<lbrakk>sh = [u]; e = LBase a; c' = ch;\n        (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 3. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "case trss_base"], ["proof (state)\nthis:\n  sh = [u_]\n  e = LBase a_\n  c' = ch\n  (u_, Base a_, v) \\<in> edges fg\n\ngoal (3 subgoals):\n 1. \\<And>u a.\n       \\<lbrakk>sh = [u]; e = LBase a; c' = ch;\n        (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 3. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "then"], ["proof (chain)\npicking this:\n  sh = [u_]\n  e = LBase a_\n  c' = ch\n  (u_, Base a_, v) \\<in> edges fg", "obtain u a where CASE: \"e=LBase a\" \"sh=[u]\" \"ch=c'\" \"(u,Base a,v)\\<in>edges fg\""], ["proof (prove)\nusing this:\n  sh = [u_]\n  e = LBase a_\n  c' = ch\n  (u_, Base a_, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. (\\<And>a u.\n        \\<lbrakk>e = LBase a; sh = [u]; ch = c';\n         (u, Base a, v) \\<in> edges fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e = LBase a\n  sh = [u]\n  ch = c'\n  (u, Base a, v) \\<in> edges fg\n\ngoal (3 subgoals):\n 1. \\<And>u a.\n       \\<lbrakk>sh = [u]; e = LBase a; c' = ch;\n        (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 3. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "with snoc.hyps[of w p u c', OF _ _ snoc.prems(2,3)] SPLIT(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length w \\<le> length w;\n   (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> (u, mon_w fg w, P) \\<in> S_cs fg k\n  (([entry fg p], {#}), w, sh, ch) \\<in> trcl (trss fg)\n  e = LBase a\n  sh = [u]\n  ch = c'\n  (u, Base a, v) \\<in> edges fg", "have \"(u,mon_w fg w,P)\\<in>S_cs fg k\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length w \\<le> length w;\n   (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> (u, mon_w fg w, P) \\<in> S_cs fg k\n  (([entry fg p], {#}), w, sh, ch) \\<in> trcl (trss fg)\n  e = LBase a\n  sh = [u]\n  ch = c'\n  (u, Base a, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. (u, mon_w fg w, P) \\<in> S_cs fg k", "by blast"], ["proof (state)\nthis:\n  (u, mon_w fg w, P) \\<in> S_cs fg k\n\ngoal (3 subgoals):\n 1. \\<And>u a.\n       \\<lbrakk>sh = [u]; e = LBase a; c' = ch;\n        (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 3. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "moreover"], ["proof (state)\nthis:\n  (u, mon_w fg w, P) \\<in> S_cs fg k\n\ngoal (3 subgoals):\n 1. \\<And>u a.\n       \\<lbrakk>sh = [u]; e = LBase a; c' = ch;\n        (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 3. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from CASE(1)"], ["proof (chain)\npicking this:\n  e = LBase a", "have \"mon_e fg e = {}\""], ["proof (prove)\nusing this:\n  e = LBase a\n\ngoal (1 subgoal):\n 1. mon_e fg e = {}", "by simp"], ["proof (state)\nthis:\n  mon_e fg e = {}\n\ngoal (3 subgoals):\n 1. \\<And>u a.\n       \\<lbrakk>sh = [u]; e = LBase a; c' = ch;\n        (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 3. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "ultimately"], ["proof (chain)\npicking this:\n  (u, mon_w fg w, P) \\<in> S_cs fg k\n  mon_e fg e = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, mon_w fg w, P) \\<in> S_cs fg k\n  mon_e fg e = {}\n\ngoal (1 subgoal):\n 1. (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "using S_base[OF CASE(4)]"], ["proof (prove)\nusing this:\n  (u, mon_w fg w, P) \\<in> S_cs fg k\n  mon_e fg e = {}\n  (u, ?M, ?P) \\<in> S_cs fg ?k \\<Longrightarrow>\n  (v, ?M, ?P) \\<in> S_cs fg ?k\n\ngoal (1 subgoal):\n 1. (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "by (auto simp add: mon_w_unconc)"], ["proof (state)\nthis:\n  (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "case trss_ret"], ["proof (state)\nthis:\n  sh = [return fg p_, v]\n  e = LRet\n  c' = ch\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "then"], ["proof (chain)\npicking this:\n  sh = [return fg p_, v]\n  e = LRet\n  c' = ch", "obtain q where CASE: \"e=LRet\" \"sh=return fg q#[v]\" \"ch=c'\""], ["proof (prove)\nusing this:\n  sh = [return fg p_, v]\n  e = LRet\n  c' = ch\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>e = LRet; sh = [return fg q, v]; ch = c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e = LRet\n  sh = [return fg q, v]\n  ch = c'\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "with SPLIT(1)"], ["proof (chain)\npicking this:\n  (([entry fg p], {#}), w, sh, ch) \\<in> trcl (trss fg)\n  e = LRet\n  sh = [return fg q, v]\n  ch = c'", "have \"(([entry fg p], {#}), w, [return fg q,v], c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), w, sh, ch) \\<in> trcl (trss fg)\n  e = LRet\n  sh = [return fg q, v]\n  ch = c'\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w, [return fg q, v], c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w, [return fg q, v], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from trss_find_call'[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>uh ch waa wb.\n      \\<lbrakk>w = waa @ LCall q # wb;\n       (([entry fg p], {#}), waa, [uh], ch) \\<in> trcl (trss fg);\n       (([uh], ch), LCall q, [entry fg q, v], ch) \\<in> trss fg;\n       (uh, Call q, v) \\<in> edges fg;\n       (([entry fg q], ch), wb, [return fg q], c')\n       \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain ut ct w1 w2 where FC:\n      \"w=w1@LCall q#w2\" \n      \"(([entry fg p],{#}),w1,([ut],ct))\\<in>trcl (trss fg)\" \n      \"(([ut],ct),LCall q,([entry fg q,v],ct))\\<in>trss fg\"\n      \"(ut,Call q,v)\\<in>edges fg\" \n      \"(([entry fg q],ct),w2,([return fg q],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (\\<And>uh ch waa wb.\n      \\<lbrakk>w = waa @ LCall q # wb;\n       (([entry fg p], {#}), waa, [uh], ch) \\<in> trcl (trss fg);\n       (([uh], ch), LCall q, [entry fg q, v], ch) \\<in> trss fg;\n       (uh, Call q, v) \\<in> edges fg;\n       (([entry fg q], ch), wb, [return fg q], c')\n       \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 ut ct.\n        \\<lbrakk>w = w1 @ LCall q # w2;\n         (([entry fg p], {#}), w1, [ut], ct) \\<in> trcl (trss fg);\n         (([ut], ct), LCall q, [entry fg q, v], ct) \\<in> trss fg;\n         (ut, Call q, v) \\<in> edges fg;\n         (([entry fg q], ct), w2, [return fg q], c')\n         \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  w = w1 @ LCall q # w2\n  (([entry fg p], {#}), w1, [ut], ct) \\<in> trcl (trss fg)\n  (([ut], ct), LCall q, [entry fg q, v], ct) \\<in> trss fg\n  (ut, Call q, v) \\<in> edges fg\n  (([entry fg q], ct), w2, [return fg q], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from trss_drop_all_context[OF FC(5)]"], ["proof (chain)\npicking this:\n  (\\<And>csp.\n      \\<lbrakk>c' = csp + ct;\n       (([entry fg q], {#}), w2, [return fg q], csp)\n       \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain csp' where SLP: \"c'=ct+csp'\" \"(([entry fg q],{#}),w2,([return fg q],csp'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (\\<And>csp.\n      \\<lbrakk>c' = csp + ct;\n       (([entry fg q], {#}), w2, [return fg q], csp)\n       \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csp'.\n        \\<lbrakk>c' = ct + csp';\n         (([entry fg q], {#}), w2, [return fg q], csp')\n         \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  c' = ct + csp'\n  (([entry fg q], {#}), w2, [return fg q], csp') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from FC(1)"], ["proof (chain)\npicking this:\n  w = w1 @ LCall q # w2", "have LEN: \"length w1 \\<le> length w\" \"length w2 \\<le> length w\""], ["proof (prove)\nusing this:\n  w = w1 @ LCall q # w2\n\ngoal (1 subgoal):\n 1. length w1 \\<le> length w &&& length w2 \\<le> length w", "by auto"], ["proof (state)\nthis:\n  length w1 \\<le> length w\n  length w2 \\<le> length w\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from mset_map_split_orig_le SLP(1) snoc.prems(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f `# ?P \\<subseteq># ?M1.0 + ?M2.0;\n   \\<And>P1 P2.\n      \\<lbrakk>?P = P1 + P2; ?f `# P1 \\<subseteq># ?M1.0;\n       ?f `# P2 \\<subseteq># ?M2.0\\<rbrakk>\n      \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?Q\n  c' = ct + csp'\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'", "obtain P1 P2 where PSPLIT: \"P=P1+P2\" \"(\\<lambda>p. [entry fg p]) `# P1 \\<subseteq># ct\" \"(\\<lambda>p. [entry fg p]) `# P2 \\<subseteq># csp'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f `# ?P \\<subseteq># ?M1.0 + ?M2.0;\n   \\<And>P1 P2.\n      \\<lbrakk>?P = P1 + P2; ?f `# P1 \\<subseteq># ?M1.0;\n       ?f `# P2 \\<subseteq># ?M2.0\\<rbrakk>\n      \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?Q\n  c' = ct + csp'\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>P = P1 + P2; {#[entry fg p]. p \\<in># P1#} \\<subseteq># ct;\n         {#[entry fg p]. p \\<in># P2#} \\<subseteq># csp'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P = P1 + P2\n  {#[entry fg p]. p \\<in># P1#} \\<subseteq># ct\n  {#[entry fg p]. p \\<in># P2#} \\<subseteq># csp'\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "with snoc.prems(2)"], ["proof (chain)\npicking this:\n  size P \\<le> k\n  P = P1 + P2\n  {#[entry fg p]. p \\<in># P1#} \\<subseteq># ct\n  {#[entry fg p]. p \\<in># P2#} \\<subseteq># csp'", "have PSIZE: \"size P1 \\<le> k\" \"size P2 \\<le> k\""], ["proof (prove)\nusing this:\n  size P \\<le> k\n  P = P1 + P2\n  {#[entry fg p]. p \\<in># P1#} \\<subseteq># ct\n  {#[entry fg p]. p \\<in># P2#} \\<subseteq># csp'\n\ngoal (1 subgoal):\n 1. size P1 \\<le> k &&& size P2 \\<le> k", "by auto"], ["proof (state)\nthis:\n  size P1 \\<le> k\n  size P2 \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from snoc.hyps[OF LEN(1) FC(2) PSIZE(1) PSPLIT(2)] snoc.hyps[OF LEN(2) SLP(2) PSIZE(2) PSPLIT(3)]"], ["proof (chain)\npicking this:\n  (ut, mon_w fg w1, P1) \\<in> S_cs fg k\n  (return fg q, mon_w fg w2, P2) \\<in> S_cs fg k", "have IHAPP: \"(ut, mon_w fg w1, P1) \\<in> S_cs fg k\" \"(return fg q, mon_w fg w2, P2) \\<in> S_cs fg k\""], ["proof (prove)\nusing this:\n  (ut, mon_w fg w1, P1) \\<in> S_cs fg k\n  (return fg q, mon_w fg w2, P2) \\<in> S_cs fg k\n\ngoal (1 subgoal):\n 1. (ut, mon_w fg w1, P1) \\<in> S_cs fg k &&&\n    (return fg q, mon_w fg w2, P2) \\<in> S_cs fg k", "."], ["proof (state)\nthis:\n  (ut, mon_w fg w1, P1) \\<in> S_cs fg k\n  (return fg q, mon_w fg w2, P2) \\<in> S_cs fg k\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>sh = [return fg p, v]; e = LRet; c' = ch\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n 2. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from S_call[OF FC(4) IHAPP subset_mset.eq_refl[OF PSPLIT(1)] snoc.prems(2)] FC(1) CASE(1)"], ["proof (chain)\npicking this:\n  (v, mon fg q \\<union> mon_w fg w1 \\<union> mon_w fg w2, P) \\<in> S_cs fg k\n  w = w1 @ LCall q # w2\n  e = LRet", "show \"(v, mon_w fg (w@[e]), P) \\<in> S_cs fg k\""], ["proof (prove)\nusing this:\n  (v, mon fg q \\<union> mon_w fg w1 \\<union> mon_w fg w2, P) \\<in> S_cs fg k\n  w = w1 @ LCall q # w2\n  e = LRet\n\ngoal (1 subgoal):\n 1. (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "by (auto simp add: mon_w_unconc Un_ac)"], ["proof (state)\nthis:\n  (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "case trss_spawn"], ["proof (state)\nthis:\n  sh = [u_]\n  e = LSpawn p_\n  c' = add_mset [entry fg p_] ch\n  (u_, Spawn p_, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "then"], ["proof (chain)\npicking this:\n  sh = [u_]\n  e = LSpawn p_\n  c' = add_mset [entry fg p_] ch\n  (u_, Spawn p_, v) \\<in> edges fg", "obtain u q where CASE: \"e=LSpawn q\" \"sh=[u]\" \"c'={#[entry fg q]#}+ch\" \"(u,Spawn q,v)\\<in>edges fg\""], ["proof (prove)\nusing this:\n  sh = [u_]\n  e = LSpawn p_\n  c' = add_mset [entry fg p_] ch\n  (u_, Spawn p_, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. (\\<And>q u.\n        \\<lbrakk>e = LSpawn q; sh = [u]; c' = {#[entry fg q]#} + ch;\n         (u, Spawn q, v) \\<in> edges fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e = LSpawn q\n  sh = [u]\n  c' = {#[entry fg q]#} + ch\n  (u, Spawn q, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from mset_map_split_orig_le CASE(3) snoc.prems(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f `# ?P \\<subseteq># ?M1.0 + ?M2.0;\n   \\<And>P1 P2.\n      \\<lbrakk>?P = P1 + P2; ?f `# P1 \\<subseteq># ?M1.0;\n       ?f `# P2 \\<subseteq># ?M2.0\\<rbrakk>\n      \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?Q\n  c' = {#[entry fg q]#} + ch\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'", "obtain P1 P2 where PSPLIT: \"P=P1+P2\" \"(\\<lambda>p. [entry fg p]) `# P1 \\<subseteq># {#[entry fg q]#}\" \"(\\<lambda>p. [entry fg p]) `# P2 \\<subseteq># ch\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f `# ?P \\<subseteq># ?M1.0 + ?M2.0;\n   \\<And>P1 P2.\n      \\<lbrakk>?P = P1 + P2; ?f `# P1 \\<subseteq># ?M1.0;\n       ?f `# P2 \\<subseteq># ?M2.0\\<rbrakk>\n      \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?Q\n  c' = {#[entry fg q]#} + ch\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>P = P1 + P2;\n         {#[entry fg p]. p \\<in># P1#} \\<subseteq># {#[entry fg q]#};\n         {#[entry fg p]. p \\<in># P2#} \\<subseteq># ch\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P = P1 + P2\n  {#[entry fg p]. p \\<in># P1#} \\<subseteq># {#[entry fg q]#}\n  {#[entry fg p]. p \\<in># P2#} \\<subseteq># ch\n\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "with snoc.prems(2)"], ["proof (chain)\npicking this:\n  size P \\<le> k\n  P = P1 + P2\n  {#[entry fg p]. p \\<in># P1#} \\<subseteq># {#[entry fg q]#}\n  {#[entry fg p]. p \\<in># P2#} \\<subseteq># ch", "have PSIZE: \"size P2 \\<le> k\""], ["proof (prove)\nusing this:\n  size P \\<le> k\n  P = P1 + P2\n  {#[entry fg p]. p \\<in># P1#} \\<subseteq># {#[entry fg q]#}\n  {#[entry fg p]. p \\<in># P2#} \\<subseteq># ch\n\ngoal (1 subgoal):\n 1. size P2 \\<le> k", "by simp"], ["proof (state)\nthis:\n  size P2 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from snoc.hyps[OF _ _ PSIZE PSPLIT(3)] SPLIT(1) CASE(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([entry fg ?p], {#}), ?ll, [?v], ch) \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> (?v, mon_w fg ?ll, P2) \\<in> S_cs fg k\n  (([entry fg p], {#}), w, sh, ch) \\<in> trcl (trss fg)\n  sh = [u]", "have IHAPP: \"(u,mon_w fg w,P2)\\<in>S_cs fg k\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([entry fg ?p], {#}), ?ll, [?v], ch) \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> (?v, mon_w fg ?ll, P2) \\<in> S_cs fg k\n  (([entry fg p], {#}), w, sh, ch) \\<in> trcl (trss fg)\n  sh = [u]\n\ngoal (1 subgoal):\n 1. (u, mon_w fg w, P2) \\<in> S_cs fg k", "by blast"], ["proof (state)\nthis:\n  (u, mon_w fg w, P2) \\<in> S_cs fg k\n\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "have PCOND: \"P \\<subseteq># {#q#}+P2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq># {#q#} + P2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<subseteq># {#q#} + P2", "from PSPLIT(2)"], ["proof (chain)\npicking this:\n  {#[entry fg p]. p \\<in># P1#} \\<subseteq># {#[entry fg q]#}", "have \"P1\\<subseteq>#{#q#}\""], ["proof (prove)\nusing this:\n  {#[entry fg p]. p \\<in># P1#} \\<subseteq># {#[entry fg q]#}\n\ngoal (1 subgoal):\n 1. P1 \\<subseteq># {#q#}", "by (auto elim!: mset_le_single_cases mset_map_single_rightE)"], ["proof (state)\nthis:\n  P1 \\<subseteq># {#q#}\n\ngoal (1 subgoal):\n 1. P \\<subseteq># {#q#} + P2", "with PSPLIT(1)"], ["proof (chain)\npicking this:\n  P = P1 + P2\n  P1 \\<subseteq># {#q#}", "show ?thesis"], ["proof (prove)\nusing this:\n  P = P1 + P2\n  P1 \\<subseteq># {#q#}\n\ngoal (1 subgoal):\n 1. P \\<subseteq># {#q#} + P2", "by simp"], ["proof (state)\nthis:\n  P \\<subseteq># {#q#} + P2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<subseteq># {#q#} + P2\n\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>sh = [u]; e = LSpawn p; c' = add_mset [entry fg p] ch;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "from S_spawn[OF CASE(4) IHAPP PCOND snoc.prems(2)] CASE(1)"], ["proof (chain)\npicking this:\n  (v, mon_w fg w, P) \\<in> S_cs fg k\n  e = LSpawn q", "show \"(v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\""], ["proof (prove)\nusing this:\n  (v, mon_w fg w, P) \\<in> S_cs fg k\n  e = LSpawn q\n\ngoal (1 subgoal):\n 1. (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k", "by (auto simp add: mon_w_unconc)"], ["proof (state)\nthis:\n  (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, mon_w fg (w @ [e]), P) \\<in> S_cs fg k\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Precision means that all entries appearing in the smallest solution of the constraint system are justified by some path in the operational characterization.\n  For proving precision, one usually shows that a family of sets derived as an abstraction from the operational characterization solves all constraints.\n\n  In our formalization of constraint systems as inductive sets this amounts to constructing for each constraint a justifying path for the entries described on the conclusion side of the implication -- under the assumption\n  that corresponding paths exists for the entries mentioned in the antecedent.\n\\<close>"], ["", "lemma (in flowgraph) S_precise: \"(v,M,P)\\<in>S_cs fg k \n  \\<Longrightarrow> \\<exists>p c' w. \n        (([entry fg p],{#}),w,([v],c'))\\<in>trcl (trss fg) \\<and> \n        size P\\<le>k \\<and> \n        (\\<lambda>p. [entry fg p]) `# P \\<subseteq># c' \\<and>\n        M=mon_w fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, M, P) \\<in> S_cs fg k \\<Longrightarrow>\n    \\<exists>p c' w.\n       (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n       size P \\<le> k \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w", "proof (induct rule: S_cs.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>p.\n       \\<exists>pa c' w.\n          (([entry fg pa], {#}), w, [entry fg p], c')\n          \\<in> trcl (trss fg) \\<and>\n          size {#} \\<le> k \\<and>\n          {#[entry fg p]. p \\<in># {#}#} \\<subseteq># c' \\<and>\n          {} = mon_w fg w\n 2. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 3. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 4. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "case (S_init p)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>p.\n       \\<exists>pa c' w.\n          (([entry fg pa], {#}), w, [entry fg p], c')\n          \\<in> trcl (trss fg) \\<and>\n          size {#} \\<le> k \\<and>\n          {#[entry fg p]. p \\<in># {#}#} \\<subseteq># c' \\<and>\n          {} = mon_w fg w\n 2. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 3. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 4. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "have \"(([entry fg p],{#}),[],([entry fg p],{#}))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), [], [entry fg p], {#}) \\<in> trcl (trss fg)", "by simp_all"], ["proof (state)\nthis:\n  (([entry fg p], {#}), [], [entry fg p], {#}) \\<in> trcl (trss fg)\n\ngoal (4 subgoals):\n 1. \\<And>p.\n       \\<exists>pa c' w.\n          (([entry fg pa], {#}), w, [entry fg p], c')\n          \\<in> trcl (trss fg) \\<and>\n          size {#} \\<le> k \\<and>\n          {#[entry fg p]. p \\<in># {#}#} \\<subseteq># c' \\<and>\n          {} = mon_w fg w\n 2. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 3. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 4. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "thus ?case"], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), [], [entry fg p], {#}) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<exists>pa c' w.\n       (([entry fg pa], {#}), w, [entry fg p], c')\n       \\<in> trcl (trss fg) \\<and>\n       size {#} \\<le> k \\<and>\n       {#[entry fg p]. p \\<in># {#}#} \\<subseteq># c' \\<and> {} = mon_w fg w", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>pa c' w.\n     (([entry fg pa], {#}), w, [entry fg p], c') \\<in> trcl (trss fg) \\<and>\n     size {#} \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># {#}#} \\<subseteq># c' \\<and> {} = mon_w fg w\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "case (S_base u a v M P)"], ["proof (state)\nthis:\n  (u, Base a, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "then"], ["proof (chain)\npicking this:\n  (u, Base a, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w", "obtain p c' w where IHAPP: \"(([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\" \"size P \\<le> k\" \"(\\<lambda>p. [entry fg p]) `# P \\<subseteq># c'\" \"M = mon_w fg w\""], ["proof (prove)\nusing this:\n  (u, Base a, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n\ngoal (1 subgoal):\n 1. (\\<And>p w c'.\n        \\<lbrakk>(([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg);\n         size P \\<le> k; {#[entry fg p]. p \\<in># P#} \\<subseteq># c';\n         M = mon_w fg w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n  M = mon_w fg w\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "note IHAPP(1)"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "also"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "from S_base"], ["proof (chain)\npicking this:\n  (u, Base a, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w", "have \"(([u],c'),LBase a,([v],c'))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  (u, Base a, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n\ngoal (1 subgoal):\n 1. (([u], c'), LBase a, [v], c') \\<in> trss fg", "by (auto intro: trss_base)"], ["proof (state)\nthis:\n  (([u], c'), LBase a, [v], c') \\<in> trss fg\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "finally"], ["proof (chain)\npicking this:\n  (([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)", "have \"(([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)", "."], ["proof (state)\nthis:\n  (([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "moreover"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "from IHAPP(4)"], ["proof (chain)\npicking this:\n  M = mon_w fg w", "have \"M=mon_w fg (w @ [LBase a])\""], ["proof (prove)\nusing this:\n  M = mon_w fg w\n\ngoal (1 subgoal):\n 1. M = mon_w fg (w @ [LBase a])", "by (simp add: mon_w_unconc)"], ["proof (state)\nthis:\n  M = mon_w fg (w @ [LBase a])\n\ngoal (3 subgoals):\n 1. \\<And>u a v M P.\n       \\<lbrakk>(u, Base a, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w\n 2. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 3. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "ultimately"], ["proof (chain)\npicking this:\n  (([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)\n  M = mon_w fg (w @ [LBase a])", "show ?case"], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)\n  M = mon_w fg (w @ [LBase a])\n\ngoal (1 subgoal):\n 1. \\<exists>p c' w.\n       (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n       size P \\<le> k \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w", "using IHAPP(2,3,4)"], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), w @ [LBase a], [v], c') \\<in> trcl (trss fg)\n  M = mon_w fg (w @ [LBase a])\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n  M = mon_w fg w\n\ngoal (1 subgoal):\n 1. \\<exists>p c' w.\n       (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n       size P \\<le> k \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w", "by blast"], ["proof (state)\nthis:\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "case (S_call u q v M P Ms Ps P')"], ["proof (state)\nthis:\n  (u, Call q, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (return fg q, Ms, Ps) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [return fg q], c') \\<in> trcl (trss fg) \\<and>\n     size Ps \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and> Ms = mon_w fg w\n  P' \\<subseteq># P + Ps\n  size P' \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "then"], ["proof (chain)\npicking this:\n  (u, Call q, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (return fg q, Ms, Ps) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [return fg q], c') \\<in> trcl (trss fg) \\<and>\n     size Ps \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and> Ms = mon_w fg w\n  P' \\<subseteq># P + Ps\n  size P' \\<le> k", "obtain p csp1 w1 where REACHING_PATH: \"(([entry fg p], {#}), w1, [u], csp1) \\<in> trcl (trss fg)\" \"size P \\<le> k\" \"(\\<lambda>p. [entry fg p]) `# P \\<subseteq># csp1\" \"M = mon_w fg w1\""], ["proof (prove)\nusing this:\n  (u, Call q, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (return fg q, Ms, Ps) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [return fg q], c') \\<in> trcl (trss fg) \\<and>\n     size Ps \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and> Ms = mon_w fg w\n  P' \\<subseteq># P + Ps\n  size P' \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>p w1 csp1.\n        \\<lbrakk>(([entry fg p], {#}), w1, [u], csp1) \\<in> trcl (trss fg);\n         size P \\<le> k; {#[entry fg p]. p \\<in># P#} \\<subseteq># csp1;\n         M = mon_w fg w1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w1, [u], csp1) \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># csp1\n  M = mon_w fg w1\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "from S_call"], ["proof (chain)\npicking this:\n  (u, Call q, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (return fg q, Ms, Ps) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [return fg q], c') \\<in> trcl (trss fg) \\<and>\n     size Ps \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and> Ms = mon_w fg w\n  P' \\<subseteq># P + Ps\n  size P' \\<le> k", "obtain csp2 w2 where SL_PATH: \"(([entry fg q], {#}), w2, [return fg q], csp2) \\<in> trcl (trss fg)\" \"size Ps \\<le> k\" \"(\\<lambda>p. [entry fg p]) `# Ps \\<subseteq># csp2\" \"Ms = mon_w fg w2\""], ["proof (prove)\nusing this:\n  (u, Call q, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (return fg q, Ms, Ps) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [return fg q], c') \\<in> trcl (trss fg) \\<and>\n     size Ps \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and> Ms = mon_w fg w\n  P' \\<subseteq># P + Ps\n  size P' \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>w2 csp2.\n        \\<lbrakk>(([entry fg q], {#}), w2, [return fg q], csp2)\n                 \\<in> trcl (trss fg);\n         size Ps \\<le> k; {#[entry fg p]. p \\<in># Ps#} \\<subseteq># csp2;\n         Ms = mon_w fg w2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: trss_er_path_proc_const)"], ["proof (state)\nthis:\n  (([entry fg q], {#}), w2, [return fg q], csp2) \\<in> trcl (trss fg)\n  size Ps \\<le> k\n  {#[entry fg p]. p \\<in># Ps#} \\<subseteq># csp2\n  Ms = mon_w fg w2\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "from trss_c_no_mon[OF REACHING_PATH(1)] trss_c_no_mon[OF SL_PATH(1)]"], ["proof (chain)\npicking this:\n  mon_c fg csp1 = mon_c fg {#}\n  mon_c fg csp2 = mon_c fg {#}", "have NOMON: \"mon_c fg csp1 = {}\" \"mon_c fg csp2 = {}\""], ["proof (prove)\nusing this:\n  mon_c fg csp1 = mon_c fg {#}\n  mon_c fg csp2 = mon_c fg {#}\n\ngoal (1 subgoal):\n 1. mon_c fg csp1 = {} &&& mon_c fg csp2 = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg csp1 = {}\n  mon_c fg csp2 = {}\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "have \"(([entry fg p], {#}), w1@LCall q#w2@[LRet],([v],csp1+csp2))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "note REACHING_PATH(1)"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w1, [u], csp1) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w1, [u], csp1) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "from trss_call[OF S_call(1)] NOMON"], ["proof (chain)\npicking this:\n  mon fg q \\<inter> mon_c fg ?c = {} \\<Longrightarrow>\n  ((u # ?r, ?c), LCall q, entry fg q # v # ?r, ?c) \\<in> trss fg\n  mon_c fg csp1 = {}\n  mon_c fg csp2 = {}", "have \"(([u],csp1),LCall q,([entry fg q,v],csp1))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  mon fg q \\<inter> mon_c fg ?c = {} \\<Longrightarrow>\n  ((u # ?r, ?c), LCall q, entry fg q # v # ?r, ?c) \\<in> trss fg\n  mon_c fg csp1 = {}\n  mon_c fg csp2 = {}\n\ngoal (1 subgoal):\n 1. (([u], csp1), LCall q, [entry fg q, v], csp1) \\<in> trss fg", "by (auto)"], ["proof (state)\nthis:\n  (([u], csp1), LCall q, [entry fg q, v], csp1) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  (([u], csp1), LCall q, [entry fg q, v], csp1) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "from trss_add_context[OF trss_stack_comp[OF SL_PATH(1)]] NOMON"], ["proof (chain)\npicking this:\n  mon_w fg w2 \\<inter> mon_c fg ?ce = {} \\<Longrightarrow>\n  (([entry fg q] @ ?r1, {#} + ?ce), w2, [return fg q] @ ?r1, csp2 + ?ce)\n  \\<in> trcl (trss fg)\n  mon_c fg csp1 = {}\n  mon_c fg csp2 = {}", "have \"(([entry fg q,v],csp1),w2,([return fg q,v],csp1+csp2))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  mon_w fg w2 \\<inter> mon_c fg ?ce = {} \\<Longrightarrow>\n  (([entry fg q] @ ?r1, {#} + ?ce), w2, [return fg q] @ ?r1, csp2 + ?ce)\n  \\<in> trcl (trss fg)\n  mon_c fg csp1 = {}\n  mon_c fg csp2 = {}\n\ngoal (1 subgoal):\n 1. (([entry fg q, v], csp1), w2, [return fg q, v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  (([entry fg q, v], csp1), w2, [return fg q, v], csp1 + csp2)\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  (([entry fg q, v], csp1), w2, [return fg q, v], csp1 + csp2)\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "have \"(([return fg q,v],csp1+csp2),LRet,([v],csp1+csp2))\\<in>trss fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([return fg q, v], csp1 + csp2), LRet, [v], csp1 + csp2) \\<in> trss fg", "by (rule trss_ret)"], ["proof (state)\nthis:\n  (([return fg q, v], csp1 + csp2), LRet, [v], csp1 + csp2) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "finally"], ["proof (chain)\npicking this:\n  (([entry fg p], {#}), ((w1 @ [LCall q]) @ w2) @ [LRet], [v], csp1 + csp2)\n  \\<in> trcl (trss fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), ((w1 @ [LCall q]) @ w2) @ [LRet], [v], csp1 + csp2)\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n    \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n  \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n  \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "moreover"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n  \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "from REACHING_PATH(4) SL_PATH(4)"], ["proof (chain)\npicking this:\n  M = mon_w fg w1\n  Ms = mon_w fg w2", "have \"mon fg q \\<union> M \\<union> Ms = mon_w fg (w1@LCall q#w2@[LRet])\""], ["proof (prove)\nusing this:\n  M = mon_w fg w1\n  Ms = mon_w fg w2\n\ngoal (1 subgoal):\n 1. mon fg q \\<union> M \\<union> Ms = mon_w fg (w1 @ LCall q # w2 @ [LRet])", "by (auto simp add: mon_w_unconc)"], ["proof (state)\nthis:\n  mon fg q \\<union> M \\<union> Ms = mon_w fg (w1 @ LCall q # w2 @ [LRet])\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "moreover"], ["proof (state)\nthis:\n  mon fg q \\<union> M \\<union> Ms = mon_w fg (w1 @ LCall q # w2 @ [LRet])\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "have \"(\\<lambda>p. [entry fg p]) `# (P') \\<subseteq># csp1+csp2\" (is \"?f `# P' \\<subseteq># _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2", "from image_mset_subseteq_mono[OF S_call(6)]"], ["proof (chain)\npicking this:\n  ?f `# P' \\<subseteq># ?f `# (P + Ps)", "have \"?f `# P' \\<subseteq># ?f `# P + ?f `# Ps\""], ["proof (prove)\nusing this:\n  ?f `# P' \\<subseteq># ?f `# (P + Ps)\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n    {#[entry fg p]. p \\<in># P#} + {#[entry fg p]. p \\<in># Ps#}", "by auto"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n  {#[entry fg p]. p \\<in># P#} + {#[entry fg p]. p \\<in># Ps#}\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2", "also"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n  {#[entry fg p]. p \\<in># P#} + {#[entry fg p]. p \\<in># Ps#}\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2", "from mset_subset_eq_mono_add[OF REACHING_PATH(3) SL_PATH(3)]"], ["proof (chain)\npicking this:\n  {#[entry fg p]. p \\<in># P#} + {#[entry fg p]. p \\<in># Ps#} \\<subseteq>#\n  csp1 + csp2", "have \"\\<dots> \\<subseteq># csp1+csp2\""], ["proof (prove)\nusing this:\n  {#[entry fg p]. p \\<in># P#} + {#[entry fg p]. p \\<in># Ps#} \\<subseteq>#\n  csp1 + csp2\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P#} +\n    {#[entry fg p]. p \\<in># Ps#} \\<subseteq>#\n    csp1 + csp2", "."], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P#} + {#[entry fg p]. p \\<in># Ps#} \\<subseteq>#\n  csp1 + csp2\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2", "finally"], ["proof (chain)\npicking this:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2", "show ?thesis"], ["proof (prove)\nusing this:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2", "."], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "moreover"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "note S_call(7)"], ["proof (state)\nthis:\n  size P' \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>u q v M P Ms Ps P'.\n       \\<lbrakk>(u, Call q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        (return fg q, Ms, Ps) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [return fg q], c')\n           \\<in> trcl (trss fg) \\<and>\n           size Ps \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># Ps#} \\<subseteq># c' \\<and>\n           Ms = mon_w fg w;\n        P' \\<subseteq># P + Ps; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            mon fg q \\<union> M \\<union> Ms = mon_w fg w\n 2. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "ultimately"], ["proof (chain)\npicking this:\n  (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n  \\<in> trcl (trss fg)\n  mon fg q \\<union> M \\<union> Ms = mon_w fg (w1 @ LCall q # w2 @ [LRet])\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2\n  size P' \\<le> k", "show ?case"], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), w1 @ LCall q # w2 @ [LRet], [v], csp1 + csp2)\n  \\<in> trcl (trss fg)\n  mon fg q \\<union> M \\<union> Ms = mon_w fg (w1 @ LCall q # w2 @ [LRet])\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># csp1 + csp2\n  size P' \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>p c' w.\n       (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n       size P' \\<le> k \\<and>\n       {#[entry fg p]. p \\<in># P'#} \\<subseteq># c' \\<and>\n       mon fg q \\<union> M \\<union> Ms = mon_w fg w", "by blast"], ["proof (state)\nthis:\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     size P' \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P'#} \\<subseteq># c' \\<and>\n     mon fg q \\<union> M \\<union> Ms = mon_w fg w\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "case (S_spawn u q v M P P')"], ["proof (state)\nthis:\n  (u, Spawn q, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  P' \\<subseteq># {#q#} + P\n  size P' \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "then"], ["proof (chain)\npicking this:\n  (u, Spawn q, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  P' \\<subseteq># {#q#} + P\n  size P' \\<le> k", "obtain p c' w where IHAPP: \"(([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\" \"size P \\<le> k\" \"(\\<lambda>p. [entry fg p]) `# P \\<subseteq># c'\" \"M = mon_w fg w\""], ["proof (prove)\nusing this:\n  (u, Spawn q, v) \\<in> edges fg\n  (u, M, P) \\<in> S_cs fg k\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  P' \\<subseteq># {#q#} + P\n  size P' \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>p w c'.\n        \\<lbrakk>(([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg);\n         size P \\<le> k; {#[entry fg p]. p \\<in># P#} \\<subseteq># c';\n         M = mon_w fg w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># c'\n  M = mon_w fg w\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "note IHAPP(1)"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "also"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "from S_spawn(1)"], ["proof (chain)\npicking this:\n  (u, Spawn q, v) \\<in> edges fg", "have \"(([u],c'),LSpawn q,([v],add_mset [entry fg q] c'))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  (u, Spawn q, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. (([u], c'), LSpawn q, [v], add_mset [entry fg q] c') \\<in> trss fg", "by (rule trss_spawn)"], ["proof (state)\nthis:\n  (([u], c'), LSpawn q, [v], add_mset [entry fg q] c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "finally"], ["proof (chain)\npicking this:\n  (([entry fg p], {#}), w @ [LSpawn q], [v], add_mset [entry fg q] c')\n  \\<in> trcl (trss fg)", "have \"(([entry fg p], {#}), w @ [LSpawn q], [v], add_mset [entry fg q] c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), w @ [LSpawn q], [v], add_mset [entry fg q] c')\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), w @ [LSpawn q], [v], add_mset [entry fg q] c')\n    \\<in> trcl (trss fg)", "."], ["proof (state)\nthis:\n  (([entry fg p], {#}), w @ [LSpawn q], [v], add_mset [entry fg q] c')\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "moreover"], ["proof (state)\nthis:\n  (([entry fg p], {#}), w @ [LSpawn q], [v], add_mset [entry fg q] c')\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "from IHAPP(4)"], ["proof (chain)\npicking this:\n  M = mon_w fg w", "have \"M=mon_w fg (w @ [LSpawn q])\""], ["proof (prove)\nusing this:\n  M = mon_w fg w\n\ngoal (1 subgoal):\n 1. M = mon_w fg (w @ [LSpawn q])", "by (simp add: mon_w_unconc)"], ["proof (state)\nthis:\n  M = mon_w fg (w @ [LSpawn q])\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "moreover"], ["proof (state)\nthis:\n  M = mon_w fg (w @ [LSpawn q])\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "have \"(\\<lambda>p. [entry fg p]) `# P' \\<subseteq># {#[entry fg q]#} + c'\" (is \"?f `# _ \\<subseteq># _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'", "from image_mset_subseteq_mono[OF S_spawn(4)]"], ["proof (chain)\npicking this:\n  ?f `# P' \\<subseteq># ?f `# ({#q#} + P)", "have \"?f `# P' \\<subseteq># {#[entry fg q]#} + ?f `# P\""], ["proof (prove)\nusing this:\n  ?f `# P' \\<subseteq># ?f `# ({#q#} + P)\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n    {#[entry fg q]#} + {#[entry fg p]. p \\<in># P#}", "by auto"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n  {#[entry fg q]#} + {#[entry fg p]. p \\<in># P#}\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'", "also"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n  {#[entry fg q]#} + {#[entry fg p]. p \\<in># P#}\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'", "from mset_subset_eq_mono_add[OF _ IHAPP(3)]"], ["proof (chain)\npicking this:\n  ?A \\<subseteq># ?B \\<Longrightarrow>\n  ?A + {#[entry fg p]. p \\<in># P#} \\<subseteq># ?B + c'", "have \"\\<dots> \\<subseteq># {#[entry fg q]#} + c'\""], ["proof (prove)\nusing this:\n  ?A \\<subseteq># ?B \\<Longrightarrow>\n  ?A + {#[entry fg p]. p \\<in># P#} \\<subseteq># ?B + c'\n\ngoal (1 subgoal):\n 1. {#[entry fg q]#} + {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n    {#[entry fg q]#} + c'", "by (auto intro: IHAPP(3))"], ["proof (state)\nthis:\n  {#[entry fg q]#} + {#[entry fg p]. p \\<in># P#} \\<subseteq>#\n  {#[entry fg q]#} + c'\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'", "finally"], ["proof (chain)\npicking this:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'", "show ?thesis"], ["proof (prove)\nusing this:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'\n\ngoal (1 subgoal):\n 1. {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'", "."], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "moreover"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "note S_spawn(5)"], ["proof (state)\nthis:\n  size P' \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>u q v M P P'.\n       \\<lbrakk>(u, Spawn q, v) \\<in> edges fg; (u, M, P) \\<in> S_cs fg k;\n        \\<exists>p c' w.\n           (([entry fg p], {#}), w, [u], c') \\<in> trcl (trss fg) \\<and>\n           size P \\<le> k \\<and>\n           {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and>\n           M = mon_w fg w;\n        P' \\<subseteq># {#q#} + P; size P' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p c' w.\n                            (([entry fg p], {#}), w, [v], c')\n                            \\<in> trcl (trss fg) \\<and>\n                            size P' \\<le> k \\<and>\n                            {#[entry fg p]. p \\<in># P'#} \\<subseteq>#\n                            c' \\<and>\n                            M = mon_w fg w", "ultimately"], ["proof (chain)\npicking this:\n  (([entry fg p], {#}), w @ [LSpawn q], [v], add_mset [entry fg q] c')\n  \\<in> trcl (trss fg)\n  M = mon_w fg (w @ [LSpawn q])\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'\n  size P' \\<le> k", "show ?case"], ["proof (prove)\nusing this:\n  (([entry fg p], {#}), w @ [LSpawn q], [v], add_mset [entry fg q] c')\n  \\<in> trcl (trss fg)\n  M = mon_w fg (w @ [LSpawn q])\n  {#[entry fg p]. p \\<in># P'#} \\<subseteq># {#[entry fg q]#} + c'\n  size P' \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>p c' w.\n       (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n       size P' \\<le> k \\<and>\n       {#[entry fg p]. p \\<in># P'#} \\<subseteq># c' \\<and> M = mon_w fg w", "by auto"], ["proof (state)\nthis:\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     size P' \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P'#} \\<subseteq># c' \\<and> M = mon_w fg w\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Finally we can state the soundness and precision as a single theorem\\<close>"], ["", "theorem (in flowgraph) S_sound_precise: \n  \"(v,M,P)\\<in>S_cs fg k \\<longleftrightarrow> \n  (\\<exists>p c' w. (([entry fg p],{#}),w,([v],c'))\\<in>trcl (trss fg) \\<and> \n    size P\\<le>k \\<and> (\\<lambda>p. [entry fg p]) `# P \\<subseteq># c' \\<and> M=mon_w fg w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, M, P) \\<in> S_cs fg k) =\n    (\\<exists>p c' w.\n        (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n        size P \\<le> k \\<and>\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w)", "using S_sound S_precise"], ["proof (prove)\nusing this:\n  \\<lbrakk>(([entry fg ?p], {#}), ?w, [?v], ?c') \\<in> trcl (trss fg);\n   size ?P \\<le> ?k; {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ?c'\\<rbrakk>\n  \\<Longrightarrow> (?v, mon_w fg ?w, ?P) \\<in> S_cs fg ?k\n  (?v, ?M, ?P) \\<in> S_cs fg ?k \\<Longrightarrow>\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [?v], c') \\<in> trcl (trss fg) \\<and>\n     size ?P \\<le> ?k \\<and>\n     {#[entry fg p]. p \\<in># ?P#} \\<subseteq># c' \\<and> ?M = mon_w fg w\n\ngoal (1 subgoal):\n 1. ((v, M, P) \\<in> S_cs fg k) =\n    (\\<exists>p c' w.\n        (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n        size P \\<le> k \\<and>\n        {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w)", "by blast"], ["", "text \\<open>Next, we present specialized soundness and precision lemmas, that reason over a macrostep (@{term \"ntrp fg\"}) rather than a same-level path (@{term \"trcl (trss fg)\"}). They are tailored for the\n  use in the soundness and precision proofs of the other constraint systems.\n\\<close>"], ["", "lemma (in flowgraph) S_sound_ntrp: \n  assumes A: \"(([u],{#}),eel,(sh,ch))\\<in>ntrp fg\" and \n  CASE: \"!!p u' v w. \\<lbrakk>\n    eel=LOC (LCall p#w); \n    (u,Call p,u')\\<in>edges fg; \n    sh=[v,u']; \n    proc_of fg v = p; \n    mon_c fg ch = {}; \n    !!s. s \\<in># ch \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> \n                     (u,Spawn p,v)\\<in>edges fg \\<and> \n                     initialproc fg p; \n    !!P. (\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch \\<Longrightarrow>\n                    (v,mon_w fg w,P)\\<in>S_cs fg (size P)\n  \\<rbrakk> \\<Longrightarrow> Q\"\n  shows Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q", "from A"], ["proof (chain)\npicking this:\n  (([u], {#}), eel, sh, ch) \\<in> ntrp fg", "obtain ee where EE: \"eel=LOC ee\" \"(([u],{#}),ee,(sh,ch))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  (([u], {#}), eel, sh, ch) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. (\\<And>ee.\n        \\<lbrakk>eel = LOC ee;\n         (([u], {#}), ee, sh, ch) \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: gtrp.cases)"], ["proof (state)\nthis:\n  eel = LOC ee\n  (([u], {#}), ee, sh, ch) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. Q", "have CHFMT: \"!!s. s \\<in># ch \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> (u,Spawn p,v)\\<in>edges fg \\<and> initialproc fg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p u v.\n          s = [entry fg p] \\<and>\n          (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "by (auto intro: ntrs_c_cases_s[OF EE(2)])"], ["proof (state)\nthis:\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. Q", "with c_of_initial_no_mon"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "have CHNOMON: \"mon_c fg ch = {}\""], ["proof (prove)\nusing this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. mon_c fg ch = {}", "by blast"], ["proof (state)\nthis:\n  mon_c fg ch = {}\n\ngoal (1 subgoal):\n 1. Q", "from EE(2)"], ["proof (chain)\npicking this:\n  (([u], {#}), ee, sh, ch) \\<in> ntrs fg", "obtain p u' v w where FIRSTSPLIT: \"ee=LCall p#w\" \"(([u],{#}),LCall p,([entry fg p,u'],{#}))\\<in>trss fg\" \"sh=[v,u']\" \"(([entry fg p],{#}),w,([v],ch))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([u], {#}), ee, sh, ch) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>p w u' v.\n        \\<lbrakk>ee = LCall p # w;\n         (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg;\n         sh = [v, u'];\n         (([entry fg p], {#}), w, [v], ch) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: ntrs.cases[simplified])"], ["proof (state)\nthis:\n  ee = LCall p # w\n  (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n  sh = [v, u']\n  (([entry fg p], {#}), w, [v], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. Q", "from FIRSTSPLIT"], ["proof (chain)\npicking this:\n  ee = LCall p # w\n  (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n  sh = [v, u']\n  (([entry fg p], {#}), w, [v], ch) \\<in> trcl (trss fg)", "have EDGE: \"(u,Call p,u')\\<in>edges fg\""], ["proof (prove)\nusing this:\n  ee = LCall p # w\n  (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n  sh = [v, u']\n  (([entry fg p], {#}), w, [v], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (u, Call p, u') \\<in> edges fg", "by (auto elim!: trss.cases)"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n\ngoal (1 subgoal):\n 1. Q", "from trss_bot_proc_const[where s=\"[]\" and s'=\"[]\", simplified, OF FIRSTSPLIT(4)]"], ["proof (chain)\npicking this:\n  proc_of fg (entry fg p) = proc_of fg v", "have PROC_OF_V: \"proc_of fg v = p\""], ["proof (prove)\nusing this:\n  proc_of fg (entry fg p) = proc_of fg v\n\ngoal (1 subgoal):\n 1. proc_of fg v = p", "by simp"], ["proof (state)\nthis:\n  proc_of fg v = p\n\ngoal (1 subgoal):\n 1. Q", "have \"!!P. (\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch \\<Longrightarrow> (v,mon_w fg w,P)\\<in>S_cs fg (size P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<Longrightarrow>\n       (v, mon_w fg w, P) \\<in> S_cs fg (size P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<Longrightarrow>\n       (v, mon_w fg w, P) \\<in> S_cs fg (size P)", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<Longrightarrow>\n       (v, mon_w fg w, P) \\<in> S_cs fg (size P)", "assume \"(\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch\""], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># ch\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<Longrightarrow>\n       (v, mon_w fg w, P) \\<in> S_cs fg (size P)", "from S_sound[OF FIRSTSPLIT(4) _ this, of \"size P\"]"], ["proof (chain)\npicking this:\n  size P \\<le> size P \\<Longrightarrow>\n  (v, mon_w fg w, P) \\<in> S_cs fg (size P)", "show \"?thesis P\""], ["proof (prove)\nusing this:\n  size P \\<le> size P \\<Longrightarrow>\n  (v, mon_w fg w, P) \\<in> S_cs fg (size P)\n\ngoal (1 subgoal):\n 1. (v, mon_w fg w, P) \\<in> S_cs fg (size P)", "by simp"], ["proof (state)\nthis:\n  (v, mon_w fg w, P) \\<in> S_cs fg (size P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ch \\<Longrightarrow>\n  (v, mon_w fg w, ?P) \\<in> S_cs fg (size ?P)\n\ngoal (1 subgoal):\n 1. Q", "with EE(1) FIRSTSPLIT(1,3) EDGE PROC_OF_V CHNOMON CHFMT"], ["proof (chain)\npicking this:\n  eel = LOC ee\n  ee = LCall p # w\n  sh = [v, u']\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  mon_c fg ch = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ch \\<Longrightarrow>\n  (v, mon_w fg w, ?P) \\<in> S_cs fg (size ?P)", "show Q"], ["proof (prove)\nusing this:\n  eel = LOC ee\n  ee = LCall p # w\n  sh = [v, u']\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  mon_c fg ch = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ch \\<Longrightarrow>\n  (v, mon_w fg w, ?P) \\<in> S_cs fg (size ?P)\n\ngoal (1 subgoal):\n 1. Q", "by (rule_tac CASE) auto"], ["proof (state)\nthis:\n  Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) S_precise_ntrp: \n  assumes ENTRY: \"(v,M,P)\\<in>S_cs fg k\" and \n              P: \"proc_of fg v = p\" and \n           EDGE: \"(u,Call p,u')\\<in>edges fg\"\n  shows \"\\<exists>w ch. \n    (([u],{#}),LOC (LCall p#w),([v,u'],ch))\\<in>ntrp fg \\<and> \n    size P \\<le> k \\<and> \n    M=mon_w fg w \\<and> \n    mon_n fg v = mon fg p \\<and> \n    (\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch \\<and>\n    mon_c fg ch={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "from P S_precise[OF ENTRY, simplified] trss_bot_proc_const[where s=\"[]\" and s'=\"[]\", simplified]"], ["proof (chain)\npicking this:\n  proc_of fg v = p\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (([?u], ?c), ?w, [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg ?u = proc_of fg ?u'", "obtain wsl ch where \n    SLPATH: \"(([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)\" \"size P \\<le> k\" \"(\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch\" \"M = mon_w fg wsl\""], ["proof (prove)\nusing this:\n  proc_of fg v = p\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> k \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (([?u], ?c), ?w, [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg ?u = proc_of fg ?u'\n\ngoal (1 subgoal):\n 1. (\\<And>wsl ch.\n        \\<lbrakk>(([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg);\n         size P \\<le> k; {#[entry fg p]. p \\<in># P#} \\<subseteq># ch;\n         M = mon_w fg wsl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># ch\n  M = mon_w fg wsl\n\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "from mon_n_same_proc[OF trss_bot_proc_const[where s=\"[]\" and s'=\"[]\", simplified, OF SLPATH(1)]]"], ["proof (chain)\npicking this:\n  mon_n fg (entry fg p) = mon_n fg v", "have MON_V: \"mon_n fg v = mon fg p\""], ["proof (prove)\nusing this:\n  mon_n fg (entry fg p) = mon_n fg v\n\ngoal (1 subgoal):\n 1. mon_n fg v = mon fg p", "by (simp)"], ["proof (state)\nthis:\n  mon_n fg v = mon fg p\n\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "from trss_c_cases[OF SLPATH(1), simplified]"], ["proof (chain)\npicking this:\n  ((\\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p) \\<Longrightarrow>\n   ?P) \\<Longrightarrow>\n  ?P", "have CHFMT: \"\\<And>s. s \\<in># ch \\<Longrightarrow> \\<exists>p. s = [entry fg p] \\<and> (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\""], ["proof (prove)\nusing this:\n  ((\\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p) \\<Longrightarrow>\n   ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p", "by blast"], ["proof (state)\nthis:\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "with c_of_initial_no_mon"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p", "have CHNOMON: \"mon_c fg ch = {}\""], ["proof (prove)\nusing this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. mon_c fg ch = {}", "by blast\n  \\<comment> \\<open>From the constraints prerequisites, we can construct the first step\\<close>"], ["proof (state)\nthis:\n  mon_c fg ch = {}\n\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "have FS: \"(([u],{#}),LCall p#wsl,([v,u'],ch))\\<in>ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg", "proof (rule ntrs_step[where r=\"[]\", simplified])"], ["proof (state)\ngoal (2 subgoals):\n 1. (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n 2. (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)", "from EDGE"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg", "show \"(([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n\ngoal (1 subgoal):\n 1. (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg", "by (auto intro: trss_call)"], ["proof (state)\nthis:\n  (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)", "qed (rule SLPATH(1))"], ["proof (state)\nthis:\n  (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "hence FSP: \"(([u],{#}),LOC (LCall p#wsl),([v,u'],ch))\\<in>ntrp fg\""], ["proof (prove)\nusing this:\n  (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg", "by (blast intro: gtrp_loc)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "from FSP SLPATH(2,3,4) CHNOMON MON_V"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># ch\n  M = mon_w fg wsl\n  mon_c fg ch = {}\n  mon_n fg v = mon fg p", "show ?thesis"], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg\n  size P \\<le> k\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># ch\n  M = mon_w fg wsl\n  mon_c fg ch = {}\n  mon_n fg v = mon fg p\n\ngoal (1 subgoal):\n 1. \\<exists>w ch.\n       (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n       size P \\<le> k \\<and>\n       M = mon_w fg w \\<and>\n       mon_n fg v = mon fg p \\<and>\n       {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> k \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Single reaching path\""], ["", "text \\<open>\n  In this section we define a constraint system that collects abstract information of paths reaching a control node at @{term U}. \n  The path starts with a single initial thread. The collected information are the monitors used by the steps of the initial thread, \n  the monitors used by steps of other threads and the acquisition history of the path. To distinguish the steps of the initial thread \n  from steps of other threads, we use the loc/env-semantics (cf. Section~\\ref{sec:ThreadTracking:exp_local}).\n\\<close>"], ["", "subsubsection \"Constraint system\""], ["", "text \\<open>\n  An element @{term \"(u,Ml,Me,h)\\<in>RU_cs fg U\"} corresponds to a path from @{term \"{#[u]#}\"} to some configuration at @{term U}, \n  that uses monitors from @{term Ml} in the steps of the initial thread, monitors from @{term Me} in the steps of other threads and\n  has acquisition history @{term h}. \n\n  Here, the correspondence between paths and entries included into the inductively defined set is not perfect but strong enough for our purposes:\n  While each constraint system entry corresponds to a path, not each path corresponds to a constraint system entry. But for each path reaching a configuration at @{term U}, we find\n  an entry with less or equal monitors and an acquisition history less or equal to the acquisition history of the path. \n\\<close>"], ["", "inductive_set\n  RU_cs :: \"('n,'p,'ba,'m,'more) flowgraph_rec_scheme \\<Rightarrow> 'n set \\<Rightarrow> \n              ('n \\<times> 'm set \\<times> 'm set \\<times> ('m \\<Rightarrow> 'm set)) set\"\n  for fg U\n  where\n    RU_init: \"u\\<in>U \\<Longrightarrow> (u,{},{},\\<lambda>x.{})\\<in>RU_cs fg U\"\n  | RU_call: \"\\<lbrakk> (u,Call p,u')\\<in>edges fg; proc_of fg v = p; (v,M,P)\\<in>S_cs fg 0; \n                (v,Ml,Me,h)\\<in>RU_cs fg U; mon_n fg u \\<inter> Me = {} \\<rbrakk> \n    \\<Longrightarrow> ( u, mon fg p \\<union> M \\<union> Ml, Me, ah_update h (mon fg p,M) (Ml\\<union>Me)) \n        \\<in> RU_cs fg U\"\n  | RU_spawn: \"\\<lbrakk> (u,Call p,u')\\<in>edges fg; proc_of fg v = p; (v,M,P)\\<in>S_cs fg 1; \n                 q \\<in># P; (entry fg q,Ml,Me,h)\\<in>RU_cs fg U; \n                 (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me)={} \\<rbrakk> \n    \\<Longrightarrow> (u,mon fg p \\<union> M, Ml \\<union> Me, ah_update h (mon fg p,M) (Ml\\<union>Me))\n        \\<in> RU_cs fg U\""], ["", "text \\<open>\n  The constraint system works by tracking only a single thread. Initially, there is just one thread, and from this thread we reach a configuration at @{term U}. After a macrostep, we have the\n  transformed initial thread and some spawned threads. The key idea is, that the actual node @{term U} is reached by just one of these threads. The steps of the other threads are useless\n  for reaching @{term U}. Because of the nice properties of normalized paths, we can simply prune those steps from the path.\n\n  The @{thm [source] RU_init}-constraint reflects that we can reach a control node from itself with the empty path. \n  The @{thm [source] RU_call}-constraint describes the case that @{term U} is reached from the initial thread, and the \n  @{thm [source] RU_spawn}-constraint describes the case that @{term U} is reached from one of the spawned threads. In the two latter cases, we \n  have to check whether prepending the macrostep to the reaching path is allowed or not due to monitor restrictions. In the call case, the procedure \n  of the initial node must not own monitors that are used in the environment steps of the appended reaching path (\\<open>mon_n fg u \\<inter> Me = {}\\<close>). \n  As we only test disjointness with the set of monitors used by the environment, reentrant monitors can be handled. \n  In the spawn case, we have to check disjointness with both, the monitors of local and environment steps of the\n  reaching path from the spawned thread, because from the perspective of the initial thread, all these steps are environment steps (\\<open>(mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me)={}\\<close>). \n  Note that in the call case, we do not need to explicitly check that the monitors used by the environment are disjoint from the monitors acquired by the called procedure because this already follows from the existence\n  of a reaching path, as the starting point of this path already holds all these monitors. \n\n  However, in the spawn case, we have to check for both the monitors of the start node and of the called procedure to be compatible with\n  the already known reaching path from the entry node of the spawned thread.\n\\<close>"], ["", "subsubsection \"Soundness and precision\""], ["", "text \\<open>The following lemma intuitively states:\n  {\\em If we can reach a configuration that is at @{term U} from some start configuration, then there is a single thread in the start configuration that \n  can reach a configuration at @{term U} with a subword of the original path}. \n\n  The proof follows from Lemma @{thm [source] flowgraph.ntr_reverse_split} rather directly.\n\\<close>"], ["", "lemma (in flowgraph) ntr_reverse_split_atU: \n  assumes V: \"valid fg c\" and \n          A: \"atU U c'\" and \n          B: \"(c,w,c')\\<in>trcl (ntr fg)\" \n  shows \"\\<exists>s w' c1'. \n           s \\<in># c \\<and> w'\\<preceq>w \\<and> c1' \\<subseteq># c' \\<and>\n           atU U c1' \\<and> ({#s#},w',c1')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s w' c1'.\n       s \\<in># c \\<and>\n       w' \\<preceq> w \\<and>\n       c1' \\<subseteq># c' \\<and>\n       atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s w' c1'.\n       s \\<in># c \\<and>\n       w' \\<preceq> w \\<and>\n       c1' \\<subseteq># c' \\<and>\n       atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)", "obtain ui r ce' where C'FMT: \"c'={#ui#r#}+ce'\" \"ui\\<in>U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ui r ce'.\n        \\<lbrakk>c' = {#ui # r#} + ce'; ui \\<in> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule atU_fmt[OF A], simp only: mset_contains_eq) (blast dest: sym)"], ["proof (state)\nthis:\n  c' = {#ui # r#} + ce'\n  ui \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>s w' c1'.\n       s \\<in># c \\<and>\n       w' \\<preceq> w \\<and>\n       c1' \\<subseteq># c' \\<and>\n       atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)", "with ntr_reverse_split[OF _ V] B"], ["proof (chain)\npicking this:\n  (c, ?w, {#?s'#} + ?ce') \\<in> trcl (ntr fg) \\<Longrightarrow>\n  \\<exists>s ce w1 w2 ce1' ce2'.\n     c = {#s#} + ce \\<and>\n     ?ce' = ce1' + ce2' \\<and>\n     ?w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n     mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n     ({#s#}, w1, {#?s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n     (ce, w2, ce2') \\<in> trcl (ntr fg)\n  (c, w, c') \\<in> trcl (ntr fg)\n  c' = {#ui # r#} + ce'\n  ui \\<in> U", "obtain s ce w1 w2 ce1' ce2' where RSPLIT: \"c={#s#}+ce\" \"ce'=ce1'+ce2'\" \"w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>w2\" \"({#s#}, w1, {#ui#r#} + ce1') \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  (c, ?w, {#?s'#} + ?ce') \\<in> trcl (ntr fg) \\<Longrightarrow>\n  \\<exists>s ce w1 w2 ce1' ce2'.\n     c = {#s#} + ce \\<and>\n     ?ce' = ce1' + ce2' \\<and>\n     ?w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n     mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n     ({#s#}, w1, {#?s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n     (ce, w2, ce2') \\<in> trcl (ntr fg)\n  (c, w, c') \\<in> trcl (ntr fg)\n  c' = {#ui # r#} + ce'\n  ui \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>s ce ce1' ce2' w1 w2.\n        \\<lbrakk>c = {#s#} + ce; ce' = ce1' + ce2';\n         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n         ({#s#}, w1, {#ui # r#} + ce1') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c = {#s#} + ce\n  ce' = ce1' + ce2'\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  ({#s#}, w1, {#ui # r#} + ce1') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<exists>s w' c1'.\n       s \\<in># c \\<and>\n       w' \\<preceq> w \\<and>\n       c1' \\<subseteq># c' \\<and>\n       atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)", "with C'FMT"], ["proof (chain)\npicking this:\n  c' = {#ui # r#} + ce'\n  ui \\<in> U\n  c = {#s#} + ce\n  ce' = ce1' + ce2'\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  ({#s#}, w1, {#ui # r#} + ce1') \\<in> trcl (ntr fg)", "have \"s \\<in># c\" \"w1\\<preceq>w\" \"{#ui#r#}+ce1' \\<subseteq># c'\" \"atU U ({#ui#r#}+ce1')\""], ["proof (prove)\nusing this:\n  c' = {#ui # r#} + ce'\n  ui \\<in> U\n  c = {#s#} + ce\n  ce' = ce1' + ce2'\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  ({#s#}, w1, {#ui # r#} + ce1') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (s \\<in># c &&& w1 \\<preceq> w) &&&\n    {#ui # r#} + ce1' \\<subseteq># c' &&& atU U ({#ui # r#} + ce1')", "by (auto dest: cil_ileq)"], ["proof (state)\nthis:\n  s \\<in># c\n  w1 \\<preceq> w\n  {#ui # r#} + ce1' \\<subseteq># c'\n  atU U ({#ui # r#} + ce1')\n\ngoal (1 subgoal):\n 1. \\<exists>s w' c1'.\n       s \\<in># c \\<and>\n       w' \\<preceq> w \\<and>\n       c1' \\<subseteq># c' \\<and>\n       atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)", "with RSPLIT(4)"], ["proof (chain)\npicking this:\n  ({#s#}, w1, {#ui # r#} + ce1') \\<in> trcl (ntr fg)\n  s \\<in># c\n  w1 \\<preceq> w\n  {#ui # r#} + ce1' \\<subseteq># c'\n  atU U ({#ui # r#} + ce1')", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#s#}, w1, {#ui # r#} + ce1') \\<in> trcl (ntr fg)\n  s \\<in># c\n  w1 \\<preceq> w\n  {#ui # r#} + ce1' \\<subseteq># c'\n  atU U ({#ui # r#} + ce1')\n\ngoal (1 subgoal):\n 1. \\<exists>s w' c1'.\n       s \\<in># c \\<and>\n       w' \\<preceq> w \\<and>\n       c1' \\<subseteq># c' \\<and>\n       atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s w' c1'.\n     s \\<in># c \\<and>\n     w' \\<preceq> w \\<and>\n     c1' \\<subseteq># c' \\<and>\n     atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The next lemma shows the soundness of the RU constraint system.\n\n  The proof works by induction over the length of the reaching path. For the empty path, the proposition follows by the @{thm [source] RU_init}-constraint. \n  For a non-empty path, we consider the first step.\n  It has transformed the initial thread and may have spawned some other threads. From the resulting configuration, @{term U} is reached. \n  Due to @{thm [source] \"flowgraph.ntr_split\"} we get two interleavable paths from the rest of the original path, one from the transformed initial thread and one from the spawned threads. \n  We then distinguish two cases: if the first path reaches \\<open>U\\<close>, the proposition follows by the induction hypothesis and the @{thm [source] RU_call} constraint. \n  \n  Otherwise, we use @{thm [source] \"flowgraph.ntr_reverse_split_atU\"} to identify the thread that actually reaches @{term U} among all the spawned threads. Then we \n  apply the induction hypothesis to the path of that thread and prepend the first step using the @{thm [source] RU_spawn}-constraint.\n  \n  The main complexity of the proof script below results from fiddling with the monitors and converting between the multiset-and loc/env-semantics. \n  Also the arguments to show that the acquisition histories are sound approximations require some space.\n\\<close>"], ["", "lemma (in flowgraph) RU_sound: \n  \"!!u s' c'. \\<lbrakk>(([u],{#}),w,(s',c'))\\<in>trcl (ntrp fg); atU U (add_mset s' c')\\<rbrakk> \n  \\<Longrightarrow> \\<exists>Ml Me h. \n    (u,Ml,Me,h)\\<in>RU_cs fg U \\<and> \n    Ml \\<subseteq> mon_loc fg w \\<and> \n    Me \\<subseteq> mon_env fg w \\<and> \n    h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w)\"\n\\<comment> \\<open>The proof works by induction over the length of the reaching path\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s' c'.\n       \\<lbrakk>(([u], {#}), w, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg w \\<and>\n                            Me \\<subseteq> mon_env fg w \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w)", "proof (induct w rule: length_compl_induct) \n  \\<comment> \\<open>For a reaching path of length zero, the proposition follows immediately by the constraint @{thm [source] RU_init}\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u s' c'.\n       \\<lbrakk>(([u], {#}), [], s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg [] \\<and>\n                            Me \\<subseteq> mon_env fg [] \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) [])\n 2. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "case Nil"], ["proof (state)\nthis:\n  (([u], {#}), [], s', c') \\<in> trcl (ntrp fg)\n  atU U (add_mset s' c')\n\ngoal (2 subgoals):\n 1. \\<And>u s' c'.\n       \\<lbrakk>(([u], {#}), [], s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg [] \\<and>\n                            Me \\<subseteq> mon_env fg [] \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) [])\n 2. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "thus ?case"], ["proof (prove)\nusing this:\n  (([u], {#}), [], s', c') \\<in> trcl (ntrp fg)\n  atU U (add_mset s' c')\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg [] \\<and>\n       Me \\<subseteq> mon_env fg [] \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) [])", "by auto (auto intro!: RU_init)"], ["proof (state)\nthis:\n  \\<exists>Ml Me h.\n     (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg [] \\<and>\n     Me \\<subseteq> mon_env fg [] \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) [])\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "case (Cons eel wwl) \n  \\<comment> \\<open>For a non-empty path, we regard the first step and the rest of the path\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length wwl;\n   (([?u], {#}), ?ll, ?s', ?c') \\<in> trcl (ntrp fg);\n   atU U (add_mset ?s' ?c')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ml Me h.\n                       (?u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                       Ml \\<subseteq> mon_loc fg ?ll \\<and>\n                       Me \\<subseteq> mon_env fg ?ll \\<and>\n                       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ?ll)\n  (([u], {#}), eel # wwl, s', c') \\<in> trcl (ntrp fg)\n  atU U (add_mset s' c')\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length wwl;\n   (([?u], {#}), ?ll, ?s', ?c') \\<in> trcl (ntrp fg);\n   atU U (add_mset ?s' ?c')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ml Me h.\n                       (?u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                       Ml \\<subseteq> mon_loc fg ?ll \\<and>\n                       Me \\<subseteq> mon_env fg ?ll \\<and>\n                       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ?ll)\n  (([u], {#}), eel # wwl, s', c') \\<in> trcl (ntrp fg)\n  atU U (add_mset s' c')", "obtain sh ch where SPLIT: \n    \"(([u],{#}),eel,(sh,ch))\\<in>ntrp fg\" \n    \"((sh,ch),wwl,(s',c'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length wwl;\n   (([?u], {#}), ?ll, ?s', ?c') \\<in> trcl (ntrp fg);\n   atU U (add_mset ?s' ?c')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ml Me h.\n                       (?u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                       Ml \\<subseteq> mon_loc fg ?ll \\<and>\n                       Me \\<subseteq> mon_env fg ?ll \\<and>\n                       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ?ll)\n  (([u], {#}), eel # wwl, s', c') \\<in> trcl (ntrp fg)\n  atU U (add_mset s' c')\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>(([u], {#}), eel, sh, ch) \\<in> ntrp fg;\n         ((sh, ch), wwl, s', c') \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  (([u], {#}), eel, sh, ch) \\<in> ntrp fg\n  ((sh, ch), wwl, s', c') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "obtain p u' v w where \n    \\<comment> \\<open>The first step consists of an initial call and a same-level path\\<close>\n    FS_FMT: \"eel = LOC (LCall p # w)\" \"(u, Call p, u') \\<in> edges fg\" \"sh = [v, u']\" \"proc_of fg v = p\" \"mon_c fg ch = {}\" \n    \\<comment> \\<open>The only environment threads after the first step are the threads that where spawned by the first step\\<close>\n    and CHFMT: \"\\<And>s. s \\<in># ch \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> (u,Spawn p,v)\\<in>edges fg \\<and> initialproc fg p\"\n    \\<comment> \\<open>For the same-level path, we find a corresponding entry in the @{text \"S_cs\"}-constraint system\\<close>\n    and S_ENTRY_PAT: \"\\<And>P. (\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch \\<Longrightarrow> (v, mon_w fg w, P) \\<in> S_cs fg (size P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p w u' v.\n        \\<lbrakk>eel = LOC (LCall p # w); (u, Call p, u') \\<in> edges fg;\n         sh = [v, u']; proc_of fg v = p; mon_c fg ch = {};\n         \\<And>s.\n            s \\<in># ch \\<Longrightarrow>\n            \\<exists>p u v.\n               s = [entry fg p] \\<and>\n               (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p;\n         \\<And>P.\n            {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<Longrightarrow>\n            (v, mon_w fg w, P) \\<in> S_cs fg (size P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule S_sound_ntrp[OF SPLIT(1)]) blast"], ["proof (state)\nthis:\n  eel = LOC (LCall p # w)\n  (u, Call p, u') \\<in> edges fg\n  sh = [v, u']\n  proc_of fg v = p\n  mon_c fg ch = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ch \\<Longrightarrow>\n  (v, mon_w fg w, ?P) \\<in> S_cs fg (size ?P)\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "from ntrp_valid_preserve_s[OF SPLIT(1)]"], ["proof (chain)\npicking this:\n  valid fg {#[u]#} \\<Longrightarrow> valid fg (add_mset sh ch)", "have HVALID: \"valid fg ({#sh#} + ch)\""], ["proof (prove)\nusing this:\n  valid fg {#[u]#} \\<Longrightarrow> valid fg (add_mset sh ch)\n\ngoal (1 subgoal):\n 1. valid fg ({#sh#} + ch)", "by simp\n  \\<comment> \\<open>We split the remaining path by the local thread and the spawned threads, getting two interleavable paths, one from the local thread and one from the spawned threads\\<close>"], ["proof (state)\nthis:\n  valid fg ({#sh#} + ch)\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "from ntrp_split[where ?c1.0=\"{#}\", simplified, OF SPLIT(2) ntrp_valid_preserve_s[OF SPLIT(1)], simplified]"], ["proof (chain)\npicking this:\n  \\<exists>w1 w2.\n     wwl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     (\\<exists>c1' c2'.\n         c' = c1' + c2' \\<and>\n         ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n         (ch, w2, c2') \\<in> trcl (ntr fg) \\<and>\n         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {} \\<and>\n         mon_ww fg w2 \\<inter> mon_s fg sh = {})", "obtain w1 w2 c1' c2' where \n    LESPLIT: \n      \"wwl\\<in>w1\\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\" \n      \"c' = c1' + c2'\" \n      \"((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg)\" \n      \"(ch, w2, c2') \\<in> trcl (ntr fg)\" \n      \"mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {}\" \n      \"mon_ww fg w2 \\<inter> mon_s fg sh = {}\""], ["proof (prove)\nusing this:\n  \\<exists>w1 w2.\n     wwl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     (\\<exists>c1' c2'.\n         c' = c1' + c2' \\<and>\n         ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n         (ch, w2, c2') \\<in> trcl (ntr fg) \\<and>\n         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {} \\<and>\n         mon_ww fg w2 \\<inter> mon_s fg sh = {})\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 c1' c2'.\n        \\<lbrakk>wwl\n                 \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2;\n         c' = c1' + c2'; ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg);\n         (ch, w2, c2') \\<in> trcl (ntr fg);\n         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {};\n         mon_ww fg w2 \\<inter> mon_s fg sh = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n  \\<comment> \\<open>We make a case distinction whether @{term U} was reached from the local thread or from the spawned threads\\<close>"], ["proof (state)\nthis:\n  wwl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  c' = c1' + c2'\n  ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg)\n  (ch, w2, c2') \\<in> trcl (ntr fg)\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {}\n  mon_ww fg w2 \\<inter> mon_s fg sh = {}\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "from Cons.prems(2) LESPLIT(2)"], ["proof (chain)\npicking this:\n  atU U (add_mset s' c')\n  c' = c1' + c2'", "have \"atU U (({#s'#}+c1') + c2')\""], ["proof (prove)\nusing this:\n  atU U (add_mset s' c')\n  c' = c1' + c2'\n\ngoal (1 subgoal):\n 1. atU U ({#s'#} + c1' + c2')", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  atU U ({#s'#} + c1' + c2')\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atU U (add_mset s' c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me h.\n  (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and>\n  Me \\<subseteq> mon_env fg ll \\<and>\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ll);\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atU U (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me h.\n                            (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l) \\<and>\n                            h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (e # l))", "thus ?case"], ["proof (prove)\nusing this:\n  atU U ({#s'#} + c1' + c2')\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "proof (cases rule: atU_union_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "case left \\<comment> \\<open>@{term U} was reached from the local thread\\<close>"], ["proof (state)\nthis:\n  atU U ({#s'#} + c1')\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from cil_ileq[OF LESPLIT(1)]"], ["proof (chain)\npicking this:\n  w1 \\<preceq> wwl \\<and> map ENV w2 \\<preceq> wwl", "have ILEQ: \"w1\\<preceq>wwl\" and LEN: \"length w1 \\<le> length wwl\""], ["proof (prove)\nusing this:\n  w1 \\<preceq> wwl \\<and> map ENV w2 \\<preceq> wwl\n\ngoal (1 subgoal):\n 1. w1 \\<preceq> wwl &&& length w1 \\<le> length wwl", "by (auto simp add: le_list_length)\n    \\<comment> \\<open>We can cut off the bottom stack symbol from the reaching path (as always possible for normalized paths)\\<close>"], ["proof (state)\nthis:\n  w1 \\<preceq> wwl\n  length w1 \\<le> length wwl\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from FS_FMT(3) LESPLIT(3) ntrp_stack_decomp[of v \"[]\" \"[u']\" \"{#}\" w1 s' c1' fg, simplified]"], ["proof (chain)\npicking this:\n  sh = [v, u']\n  ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg)\n  \\<lbrakk>(([v, u'], {#}), w1, s', c1') \\<in> trcl (ntrp fg);\n   \\<And>va rr.\n      \\<lbrakk>s' = va # rr @ [u'];\n       (([v], {#}), w1, va # rr, c1') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P", "obtain v' rr where DECOMP: \"s'=v'#rr@[u']\" \"(([v],{#}),w1,(v'#rr,c1'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  sh = [v, u']\n  ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg)\n  \\<lbrakk>(([v, u'], {#}), w1, s', c1') \\<in> trcl (ntrp fg);\n   \\<And>va rr.\n      \\<lbrakk>s' = va # rr @ [u'];\n       (([v], {#}), w1, va # rr, c1') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>v' rr.\n        \\<lbrakk>s' = v' # rr @ [u'];\n         (([v], {#}), w1, v' # rr, c1') \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto\n    \\<comment> \\<open>This does not affect the configuration being at @{term U}\\<close>"], ["proof (state)\nthis:\n  s' = v' # rr @ [u']\n  (([v], {#}), w1, v' # rr, c1') \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from atU_xchange_stack left DECOMP(1)"], ["proof (chain)\npicking this:\n  atU ?U (add_mset (?u # ?r) ?c) \\<Longrightarrow>\n  atU ?U (add_mset (?u # ?r') ?c)\n  atU U ({#s'#} + c1')\n  s' = v' # rr @ [u']", "have ATU: \"atU U (add_mset (v'#rr) c1')\""], ["proof (prove)\nusing this:\n  atU ?U (add_mset (?u # ?r) ?c) \\<Longrightarrow>\n  atU ?U (add_mset (?u # ?r') ?c)\n  atU U ({#s'#} + c1')\n  s' = v' # rr @ [u']\n\ngoal (1 subgoal):\n 1. atU U (add_mset (v' # rr) c1')", "by fastforce \n    \\<comment> \\<open>Then we can apply the induction hypothesis to get a constraint system entry for the path\\<close>"], ["proof (state)\nthis:\n  atU U (add_mset (v' # rr) c1')\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from Cons.hyps[OF LEN DECOMP(2) ATU]"], ["proof (chain)\npicking this:\n  \\<exists>Ml Me h.\n     (v, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg w1 \\<and>\n     Me \\<subseteq> mon_env fg w1 \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)", "obtain Ml Me h where IHAPP: \"(v,Ml,Me,h)\\<in>RU_cs fg U\" \"Ml \\<subseteq> mon_loc fg w1\" \"Me \\<subseteq> mon_env fg w1\" \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\""], ["proof (prove)\nusing this:\n  \\<exists>Ml Me h.\n     (v, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg w1 \\<and>\n     Me \\<subseteq> mon_env fg w1 \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n\ngoal (1 subgoal):\n 1. (\\<And>Ml Me h.\n        \\<lbrakk>(v, Ml, Me, h) \\<in> RU_cs fg U;\n         Ml \\<subseteq> mon_loc fg w1; Me \\<subseteq> mon_env fg w1;\n         h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast \n    \\<comment> \\<open>Next, we have to apply the constraint @{thm [source] RU_call}\\<close>"], ["proof (state)\nthis:\n  (v, Ml, Me, h) \\<in> RU_cs fg U\n  Ml \\<subseteq> mon_loc fg w1\n  Me \\<subseteq> mon_env fg w1\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from S_ENTRY_PAT[of \"{#}\", simplified]"], ["proof (chain)\npicking this:\n  (v, mon_w fg w, {#}) \\<in> S_cs fg 0", "have S_ENTRY: \"(v, mon_w fg w, {#}) \\<in> S_cs fg 0\""], ["proof (prove)\nusing this:\n  (v, mon_w fg w, {#}) \\<in> S_cs fg 0\n\ngoal (1 subgoal):\n 1. (v, mon_w fg w, {#}) \\<in> S_cs fg 0", "."], ["proof (state)\nthis:\n  (v, mon_w fg w, {#}) \\<in> S_cs fg 0\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have MON_U_ME: \"mon_n fg u \\<inter> Me = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_n fg u \\<inter> Me = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mon_n fg u \\<inter> Me = {}", "from ntrp_mon_env_w_no_ctx[OF Cons.prems(1)]"], ["proof (chain)\npicking this:\n  mon_env fg (eel # wwl) \\<inter> mon_s fg [u] = {}", "have \"mon_env fg wwl \\<inter> mon_n fg u = {}\""], ["proof (prove)\nusing this:\n  mon_env fg (eel # wwl) \\<inter> mon_s fg [u] = {}\n\ngoal (1 subgoal):\n 1. mon_env fg wwl \\<inter> mon_n fg u = {}", "by (auto)"], ["proof (state)\nthis:\n  mon_env fg wwl \\<inter> mon_n fg u = {}\n\ngoal (1 subgoal):\n 1. mon_n fg u \\<inter> Me = {}", "with mon_env_ileq[OF ILEQ] IHAPP(3)"], ["proof (chain)\npicking this:\n  mon_env ?fg w1 \\<subseteq> mon_env ?fg wwl\n  Me \\<subseteq> mon_env fg w1\n  mon_env fg wwl \\<inter> mon_n fg u = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  mon_env ?fg w1 \\<subseteq> mon_env ?fg wwl\n  Me \\<subseteq> mon_env fg w1\n  mon_env fg wwl \\<inter> mon_n fg u = {}\n\ngoal (1 subgoal):\n 1. mon_n fg u \\<inter> Me = {}", "by fast"], ["proof (state)\nthis:\n  mon_n fg u \\<inter> Me = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mon_n fg u \\<inter> Me = {}\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from RU_call[OF FS_FMT(2,4) S_ENTRY IHAPP(1) MON_U_ME]"], ["proof (chain)\npicking this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U", "have \"(u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me, ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)) \\<in> RU_cs fg U\""], ["proof (prove)\nusing this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n\ngoal (1 subgoal):\n 1. (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me,\n     ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n    \\<in> RU_cs fg U", ". \n    \\<comment> \\<open>Then we assemble the rest of the proposition, that are the monitor restrictions and the acquisition history restriction\\<close>"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "moreover"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have \"mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (eel#wwl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<union> Ml\n    \\<subseteq> mon_loc fg (eel # wwl)", "using mon_loc_ileq[OF ILEQ] IHAPP(2) FS_FMT(1)"], ["proof (prove)\nusing this:\n  mon_loc ?fg w1 \\<subseteq> mon_loc ?fg wwl\n  Ml \\<subseteq> mon_loc fg w1\n  eel = LOC (LCall p # w)\n\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<union> Ml\n    \\<subseteq> mon_loc fg (eel # wwl)", "by fastforce"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<union> Ml\n  \\<subseteq> mon_loc fg (eel # wwl)\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "moreover"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<union> Ml\n  \\<subseteq> mon_loc fg (eel # wwl)\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have \"Me \\<subseteq> mon_env fg (eel#wwl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Me \\<subseteq> mon_env fg (eel # wwl)", "using mon_env_ileq[OF ILEQ, of fg] IHAPP(3)"], ["proof (prove)\nusing this:\n  mon_env fg w1 \\<subseteq> mon_env fg wwl\n  Me \\<subseteq> mon_env fg w1\n\ngoal (1 subgoal):\n 1. Me \\<subseteq> mon_env fg (eel # wwl)", "by auto"], ["proof (state)\nthis:\n  Me \\<subseteq> mon_env fg (eel # wwl)\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "moreover"], ["proof (state)\nthis:\n  Me \\<subseteq> mon_env fg (eel # wwl)\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have \"ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me) \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel#wwl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n    \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "proof (simp add: ah_update_cons)"], ["proof (state)\ngoal (1 subgoal):\n 1. ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n    \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl))\n           (\\<alpha>nl fg eel) (mon_pl (map (\\<alpha>nl fg) wwl))", "show \"ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me) \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl)) (\\<alpha>nl fg eel) (mon_pl (map (\\<alpha>nl fg) wwl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n    \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl))\n           (\\<alpha>nl fg eel) (mon_pl (map (\\<alpha>nl fg) wwl))", "proof (rule ah_update_mono)"], ["proof (state)\ngoal (3 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n 2. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 3. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "from IHAPP(4)"], ["proof (chain)\npicking this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)", "have \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\""], ["proof (prove)\nusing this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n\ngoal (1 subgoal):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)", "."], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n\ngoal (3 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n 2. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 3. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "also"], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n\ngoal (3 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n 2. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 3. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "from \\<alpha>ah_ileq[OF le_list_map[OF ILEQ]]"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map ?f1 w1) \\<le> \\<alpha>ah (map ?f1 wwl)", "have \"\\<alpha>ah (map (\\<alpha>nl fg) w1) \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map ?f1 w1) \\<le> \\<alpha>ah (map ?f1 wwl)\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) w1)\n    \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)", "."], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1)\n  \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n\ngoal (3 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n 2. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 3. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "finally"], ["proof (chain)\npicking this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)", "show \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\""], ["proof (prove)\nusing this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n\ngoal (1 subgoal):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)", "."], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n\ngoal (2 subgoals):\n 1. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 2. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 2. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "from FS_FMT(1)"], ["proof (chain)\npicking this:\n  eel = LOC (LCall p # w)", "show \"(mon fg p, mon_w fg w) = \\<alpha>nl fg eel\""], ["proof (prove)\nusing this:\n  eel = LOC (LCall p # w)\n\ngoal (1 subgoal):\n 1. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel", "by auto"], ["proof (state)\nthis:\n  (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "from IHAPP(2,3)"], ["proof (chain)\npicking this:\n  Ml \\<subseteq> mon_loc fg w1\n  Me \\<subseteq> mon_env fg w1", "have \"(Ml \\<union> Me) \\<subseteq> mon_pl (map (\\<alpha>nl fg) w1)\""], ["proof (prove)\nusing this:\n  Ml \\<subseteq> mon_loc fg w1\n  Me \\<subseteq> mon_env fg w1\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) w1)", "by (auto simp add: mon_pl_of_\\<alpha>nl)"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) w1)\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "also"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) w1)\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "from mon_pl_ileq[OF le_list_map[OF ILEQ]]"], ["proof (chain)\npicking this:\n  mon_pl (map ?f1 w1) \\<subseteq> mon_pl (map ?f1 wwl)", "have \"\\<dots> \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)\""], ["proof (prove)\nusing this:\n  mon_pl (map ?f1 w1) \\<subseteq> mon_pl (map ?f1 wwl)\n\ngoal (1 subgoal):\n 1. mon_pl (map (\\<alpha>nl fg) w1)\n    \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "."], ["proof (state)\nthis:\n  mon_pl (map (\\<alpha>nl fg) w1)\n  \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "finally"], ["proof (chain)\npicking this:\n  Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "show \"(Ml \\<union> Me) \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)\""], ["proof (prove)\nusing this:\n  Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "."], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n  \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl)) (\\<alpha>nl fg eel)\n         (mon_pl (map (\\<alpha>nl fg) wwl))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n  \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n\ngoal (2 subgoals):\n 1. atU U ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n 2. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "ultimately"], ["proof (chain)\npicking this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n  mon fg p \\<union> mon_w fg w \\<union> Ml\n  \\<subseteq> mon_loc fg (eel # wwl)\n  Me \\<subseteq> mon_env fg (eel # wwl)\n  ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n  \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n  mon fg p \\<union> mon_w fg w \\<union> Ml\n  \\<subseteq> mon_loc fg (eel # wwl)\n  Me \\<subseteq> mon_env fg (eel # wwl)\n  ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n  \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ml Me h.\n     (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n     Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "case right \\<comment> \\<open>@{term U} was reached from the spawned threads\\<close>"], ["proof (state)\nthis:\n  atU U c2'\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from cil_ileq[OF LESPLIT(1)] le_list_length[of \"map ENV w2\" \"wwl\"]"], ["proof (chain)\npicking this:\n  w1 \\<preceq> wwl \\<and> map ENV w2 \\<preceq> wwl\n  map ENV w2 \\<preceq> wwl \\<Longrightarrow>\n  length (map ENV w2) \\<le> length wwl", "have ILEQ: \"map ENV w2\\<preceq>wwl\" and LEN: \"length w2 \\<le> length wwl\""], ["proof (prove)\nusing this:\n  w1 \\<preceq> wwl \\<and> map ENV w2 \\<preceq> wwl\n  map ENV w2 \\<preceq> wwl \\<Longrightarrow>\n  length (map ENV w2) \\<le> length wwl\n\ngoal (1 subgoal):\n 1. map ENV w2 \\<preceq> wwl &&& length w2 \\<le> length wwl", "by (auto)"], ["proof (state)\nthis:\n  map ENV w2 \\<preceq> wwl\n  length w2 \\<le> length wwl\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from HVALID"], ["proof (chain)\npicking this:\n  valid fg ({#sh#} + ch)", "have CHVALID: \"valid fg ch\" \"mon_s fg sh \\<inter> mon_c fg ch = {}\""], ["proof (prove)\nusing this:\n  valid fg ({#sh#} + ch)\n\ngoal (1 subgoal):\n 1. valid fg ch &&& mon_s fg sh \\<inter> mon_c fg ch = {}", "by (auto simp add: valid_unconc)\n      \\<comment> \\<open>We first identify the actual thread from that @{term U} was reached\\<close>"], ["proof (state)\nthis:\n  valid fg ch\n  mon_s fg sh \\<inter> mon_c fg ch = {}\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from ntr_reverse_split_atU[OF CHVALID(1) right LESPLIT(4)]"], ["proof (chain)\npicking this:\n  \\<exists>s w' c1'.\n     s \\<in># ch \\<and>\n     w' \\<preceq> w2 \\<and>\n     c1' \\<subseteq># c2' \\<and>\n     atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)", "obtain q wr cr' where RI: \"[entry fg q] \\<in># ch\" \"wr\\<preceq>w2\" \"cr'\\<subseteq>#c2'\" \"atU U cr'\" \"({#[entry fg q]#},wr,cr')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<exists>s w' c1'.\n     s \\<in># ch \\<and>\n     w' \\<preceq> w2 \\<and>\n     c1' \\<subseteq># c2' \\<and>\n     atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>q wr cr'.\n        \\<lbrakk>[entry fg q] \\<in># ch; wr \\<preceq> w2;\n         cr' \\<subseteq># c2'; atU U cr';\n         ({#[entry fg q]#}, wr, cr') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: CHFMT)\n      \\<comment> \\<open>In order to apply the induction hypothesis, we have to convert the reaching path to loc/env semantics\\<close>"], ["proof (state)\nthis:\n  [entry fg q] \\<in># ch\n  wr \\<preceq> w2\n  cr' \\<subseteq># c2'\n  atU U cr'\n  ({#[entry fg q]#}, wr, cr') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from ntrs.gtr2gtrp[where c=\"{#}\", simplified, OF RI(5)]"], ["proof (chain)\npicking this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>cr' = add_mset s' ce'; wr = map le_rem_s ww;\n       (([entry fg q], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain sr' cre' wwr where RI_NTRP: \"cr'=add_mset sr' cre'\" \"wr=map le_rem_s wwr\" \"(([entry fg q],{#}),wwr,(sr',cre'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>cr' = add_mset s' ce'; wr = map le_rem_s ww;\n       (([entry fg q], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>sr' cre' wwr.\n        \\<lbrakk>cr' = add_mset sr' cre'; wr = map le_rem_s wwr;\n         (([entry fg q], {#}), wwr, sr', cre') \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cr' = add_mset sr' cre'\n  wr = map le_rem_s wwr\n  (([entry fg q], {#}), wwr, sr', cre') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from LEN le_list_length[OF RI(2)] RI_NTRP(2)"], ["proof (chain)\npicking this:\n  length w2 \\<le> length wwl\n  length wr \\<le> length w2\n  wr = map le_rem_s wwr", "have LEN': \"length wwr \\<le> length wwl\""], ["proof (prove)\nusing this:\n  length w2 \\<le> length wwl\n  length wr \\<le> length w2\n  wr = map le_rem_s wwr\n\ngoal (1 subgoal):\n 1. length wwr \\<le> length wwl", "by simp\n    \\<comment> \\<open>The induction hypothesis yields a constraint system entry\\<close>"], ["proof (state)\nthis:\n  length wwr \\<le> length wwl\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from Cons.hyps[OF LEN' RI_NTRP(3)] RI_NTRP(1) RI(4)"], ["proof (chain)\npicking this:\n  atU U (add_mset sr' cre') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (entry fg q, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg wwr \\<and>\n     Me \\<subseteq> mon_env fg wwr \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\n  cr' = add_mset sr' cre'\n  atU U cr'", "obtain Ml Me h where IHAPP: \"(entry fg q, Ml, Me, h)\\<in>RU_cs fg U\" \"Ml \\<subseteq> mon_loc fg wwr\" \"Me \\<subseteq> mon_env fg wwr\" \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\""], ["proof (prove)\nusing this:\n  atU U (add_mset sr' cre') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (entry fg q, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg wwr \\<and>\n     Me \\<subseteq> mon_env fg wwr \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\n  cr' = add_mset sr' cre'\n  atU U cr'\n\ngoal (1 subgoal):\n 1. (\\<And>Ml Me h.\n        \\<lbrakk>(entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n         Ml \\<subseteq> mon_loc fg wwr; Me \\<subseteq> mon_env fg wwr;\n         h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto \n    \\<comment> \\<open>We also have an entry in the same-level path constraint system that contains the thread from that @{term U} was reached\\<close>"], ["proof (state)\nthis:\n  (entry fg q, Ml, Me, h) \\<in> RU_cs fg U\n  Ml \\<subseteq> mon_loc fg wwr\n  Me \\<subseteq> mon_env fg wwr\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from S_ENTRY_PAT[of \"{#q#}\", simplified] RI(1)"], ["proof (chain)\npicking this:\n  [entry fg q] \\<in># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q#}) \\<in> S_cs fg (Suc 0)\n  [entry fg q] \\<in># ch", "have S_ENTRY: \"(v, mon_w fg w, {#q#}) \\<in> S_cs fg 1\""], ["proof (prove)\nusing this:\n  [entry fg q] \\<in># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q#}) \\<in> S_cs fg (Suc 0)\n  [entry fg q] \\<in># ch\n\ngoal (1 subgoal):\n 1. (v, mon_w fg w, {#q#}) \\<in> S_cs fg 1", "by auto \n    \\<comment> \\<open>Before we can apply the  @{thm [source] RU_spawn}-constraint, we have to analyze the monitors\\<close>"], ["proof (state)\nthis:\n  (v, mon_w fg w, {#q#}) \\<in> S_cs fg 1\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have MON_MLE_ENV: \"Ml \\<union> Me \\<subseteq> mon_env fg wwl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg wwl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg wwl", "from IHAPP(2,3)"], ["proof (chain)\npicking this:\n  Ml \\<subseteq> mon_loc fg wwr\n  Me \\<subseteq> mon_env fg wwr", "have \"Ml \\<union> Me \\<subseteq> mon_loc fg wwr \\<union> mon_env fg wwr\""], ["proof (prove)\nusing this:\n  Ml \\<subseteq> mon_loc fg wwr\n  Me \\<subseteq> mon_env fg wwr\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_loc fg wwr \\<union> mon_env fg wwr", "by auto"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_loc fg wwr \\<union> mon_env fg wwr\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg wwl", "also"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_loc fg wwr \\<union> mon_env fg wwr\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg wwl", "from mon_ww_of_le_rem[symmetric] RI_NTRP(2)"], ["proof (chain)\npicking this:\n  mon_loc ?fg ?w \\<union> mon_env ?fg ?w = mon_ww ?fg (map le_rem_s ?w)\n  wr = map le_rem_s wwr", "have \"\\<dots> = mon_ww fg wr\""], ["proof (prove)\nusing this:\n  mon_loc ?fg ?w \\<union> mon_env ?fg ?w = mon_ww ?fg (map le_rem_s ?w)\n  wr = map le_rem_s wwr\n\ngoal (1 subgoal):\n 1. mon_loc fg wwr \\<union> mon_env fg wwr = mon_ww fg wr", "by fastforce"], ["proof (state)\nthis:\n  mon_loc fg wwr \\<union> mon_env fg wwr = mon_ww fg wr\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg wwl", "also"], ["proof (state)\nthis:\n  mon_loc fg wwr \\<union> mon_env fg wwr = mon_ww fg wr\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg wwl", "from mon_env_ileq[OF ILEQ] mon_ww_ileq[OF RI(2)]"], ["proof (chain)\npicking this:\n  mon_env ?fg (map ENV w2) \\<subseteq> mon_env ?fg wwl\n  mon_ww ?fg wr \\<subseteq> mon_ww ?fg w2", "have \"\\<dots> \\<subseteq> mon_env fg wwl\""], ["proof (prove)\nusing this:\n  mon_env ?fg (map ENV w2) \\<subseteq> mon_env ?fg wwl\n  mon_ww ?fg wr \\<subseteq> mon_ww ?fg w2\n\ngoal (1 subgoal):\n 1. mon_ww fg wr \\<subseteq> mon_env fg wwl", "by fastforce"], ["proof (state)\nthis:\n  mon_ww fg wr \\<subseteq> mon_env fg wwl\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg wwl", "finally"], ["proof (chain)\npicking this:\n  Ml \\<union> Me \\<subseteq> mon_env fg wwl", "show ?thesis"], ["proof (prove)\nusing this:\n  Ml \\<union> Me \\<subseteq> mon_env fg wwl\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg wwl", "."], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_env fg wwl\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_env fg wwl\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have MON_UP_MLE: \"(mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "from ntrp_mon_env_w_no_ctx[OF SPLIT(2)] FS_FMT(3,4) edges_part[OF FS_FMT(2)]"], ["proof (chain)\npicking this:\n  mon_env fg wwl \\<inter> mon_s fg sh = {}\n  sh = [v, u']\n  proc_of fg v = p\n  proc_of fg u = proc_of fg u'", "have \"(mon_n fg u \\<union> mon fg p) \\<inter> mon_env fg wwl = {}\""], ["proof (prove)\nusing this:\n  mon_env fg wwl \\<inter> mon_s fg sh = {}\n  sh = [v, u']\n  proc_of fg v = p\n  proc_of fg u = proc_of fg u'\n\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> mon_env fg wwl = {}", "by (auto simp add: mon_n_def)"], ["proof (state)\nthis:\n  (mon_n fg u \\<union> mon fg p) \\<inter> mon_env fg wwl = {}\n\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "with MON_MLE_ENV"], ["proof (chain)\npicking this:\n  Ml \\<union> Me \\<subseteq> mon_env fg wwl\n  (mon_n fg u \\<union> mon fg p) \\<inter> mon_env fg wwl = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Ml \\<union> Me \\<subseteq> mon_env fg wwl\n  (mon_n fg u \\<union> mon fg p) \\<inter> mon_env fg wwl = {}\n\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "by auto"], ["proof (state)\nthis:\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n\ngoal:\nNo subgoals!", "qed\n    \\<comment> \\<open>Finally we can apply the @{thm [source] RU_spawn}-constraint that yields us an entry for the reaching path from @{term u}\\<close>"], ["proof (state)\nthis:\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "from RU_spawn[OF FS_FMT(2,4) S_ENTRY _ IHAPP(1) MON_UP_MLE]"], ["proof (chain)\npicking this:\n  q \\<in># {#q#} \\<Longrightarrow>\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U", "have \"(u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me, ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)) \\<in> RU_cs fg U\""], ["proof (prove)\nusing this:\n  q \\<in># {#q#} \\<Longrightarrow>\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n\ngoal (1 subgoal):\n 1. (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me,\n     ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n    \\<in> RU_cs fg U", "by simp \n    \\<comment> \\<open>Next we have to assemble the rest of the proposition\\<close>"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "moreover"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have \"mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (eel#wwl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (eel # wwl)", "using FS_FMT(1)"], ["proof (prove)\nusing this:\n  eel = LOC (LCall p # w)\n\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (eel # wwl)", "by fastforce"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (eel # wwl)\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "moreover"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (eel # wwl)\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have \"Ml \\<union> Me \\<subseteq> mon_env fg (eel#wwl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg (eel # wwl)", "using MON_MLE_ENV"], ["proof (prove)\nusing this:\n  Ml \\<union> Me \\<subseteq> mon_env fg wwl\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg (eel # wwl)", "by auto"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_env fg (eel # wwl)\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "moreover"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_env fg (eel # wwl)\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "have \"ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me) \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel#wwl))\" \\<comment> \\<open>Only the proposition about the acquisition histories needs some more work\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n    \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "proof (simp add: ah_update_cons)"], ["proof (state)\ngoal (1 subgoal):\n 1. ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n    \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl))\n           (\\<alpha>nl fg eel) (mon_pl (map (\\<alpha>nl fg) wwl))", "have MAP_HELPER: \"map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "from RI_NTRP(2)"], ["proof (chain)\npicking this:\n  wr = map le_rem_s wwr", "have \"map (\\<alpha>nl fg) wwr = map (\\<alpha>n fg) wr\""], ["proof (prove)\nusing this:\n  wr = map le_rem_s wwr\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr = map (\\<alpha>n fg) wr", "by (simp add: \\<alpha>n_\\<alpha>nl)"], ["proof (state)\nthis:\n  map (\\<alpha>nl fg) wwr = map (\\<alpha>n fg) wr\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "also"], ["proof (state)\nthis:\n  map (\\<alpha>nl fg) wwr = map (\\<alpha>n fg) wr\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "from le_list_map[OF RI(2)]"], ["proof (chain)\npicking this:\n  map ?f wr \\<preceq> map ?f w2", "have \"\\<dots> \\<preceq> map (\\<alpha>n fg) w2\""], ["proof (prove)\nusing this:\n  map ?f wr \\<preceq> map ?f w2\n\ngoal (1 subgoal):\n 1. map (\\<alpha>n fg) wr \\<preceq> map (\\<alpha>n fg) w2", "."], ["proof (state)\nthis:\n  map (\\<alpha>n fg) wr \\<preceq> map (\\<alpha>n fg) w2\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "also"], ["proof (state)\nthis:\n  map (\\<alpha>n fg) wr \\<preceq> map (\\<alpha>n fg) w2\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "have \"\\<dots> = map (\\<alpha>nl fg) (map ENV w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<alpha>n fg) w2 = map (\\<alpha>nl fg) (map ENV w2)", "by simp"], ["proof (state)\nthis:\n  map (\\<alpha>n fg) w2 = map (\\<alpha>nl fg) (map ENV w2)\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "also"], ["proof (state)\nthis:\n  map (\\<alpha>n fg) w2 = map (\\<alpha>nl fg) (map ENV w2)\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "from le_list_map[OF ILEQ]"], ["proof (chain)\npicking this:\n  map ?f (map ENV w2) \\<preceq> map ?f wwl", "have \"\\<dots> \\<preceq> map (\\<alpha>nl fg) wwl\""], ["proof (prove)\nusing this:\n  map ?f (map ENV w2) \\<preceq> map ?f wwl\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) (map ENV w2) \\<preceq> map (\\<alpha>nl fg) wwl", "."], ["proof (state)\nthis:\n  map (\\<alpha>nl fg) (map ENV w2) \\<preceq> map (\\<alpha>nl fg) wwl\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "finally"], ["proof (chain)\npicking this:\n  map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "show \"?thesis\""], ["proof (prove)\nusing this:\n  map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl", "."], ["proof (state)\nthis:\n  map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<alpha>nl fg) wwr \\<preceq> map (\\<alpha>nl fg) wwl\n\ngoal (1 subgoal):\n 1. ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n    \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl))\n           (\\<alpha>nl fg eel) (mon_pl (map (\\<alpha>nl fg) wwl))", "show \"ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me) \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl)) (\\<alpha>nl fg eel) (mon_pl (map (\\<alpha>nl fg) wwl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n    \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl))\n           (\\<alpha>nl fg eel) (mon_pl (map (\\<alpha>nl fg) wwl))", "proof (rule ah_update_mono)"], ["proof (state)\ngoal (3 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n 2. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 3. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "from IHAPP(4)"], ["proof (chain)\npicking this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)", "have \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\""], ["proof (prove)\nusing this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\n\ngoal (1 subgoal):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)", "."], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\n\ngoal (3 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n 2. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 3. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "also"], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwr)\n\ngoal (3 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n 2. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 3. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "have \"\\<dots> \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) wwr)\n    \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)", "by (rule \\<alpha>ah_ileq[OF MAP_HELPER])"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) wwr)\n  \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n\ngoal (3 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n 2. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 3. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "finally"], ["proof (chain)\npicking this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)", "show \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\""], ["proof (prove)\nusing this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n\ngoal (1 subgoal):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)", "."], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) wwl)\n\ngoal (2 subgoals):\n 1. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 2. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n 2. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "from FS_FMT(1)"], ["proof (chain)\npicking this:\n  eel = LOC (LCall p # w)", "show \"(mon fg p, mon_w fg w) = \\<alpha>nl fg eel\""], ["proof (prove)\nusing this:\n  eel = LOC (LCall p # w)\n\ngoal (1 subgoal):\n 1. (mon fg p, mon_w fg w) = \\<alpha>nl fg eel", "by simp"], ["proof (state)\nthis:\n  (mon fg p, mon_w fg w) = \\<alpha>nl fg eel\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "from IHAPP(2,3) mon_pl_ileq[OF MAP_HELPER]"], ["proof (chain)\npicking this:\n  Ml \\<subseteq> mon_loc fg wwr\n  Me \\<subseteq> mon_env fg wwr\n  mon_pl (map (\\<alpha>nl fg) wwr)\n  \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "show \"Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)\""], ["proof (prove)\nusing this:\n  Ml \\<subseteq> mon_loc fg wwr\n  Me \\<subseteq> mon_env fg wwr\n  mon_pl (map (\\<alpha>nl fg) wwr)\n  \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)", "by (auto simp add: mon_pl_of_\\<alpha>nl)"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_pl (map (\\<alpha>nl fg) wwl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n  \\<le> ah_update (\\<alpha>ah (map (\\<alpha>nl fg) wwl)) (\\<alpha>nl fg eel)\n         (mon_pl (map (\\<alpha>nl fg) wwl))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n  \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n\ngoal (1 subgoal):\n 1. atU U c2' \\<Longrightarrow>\n    \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "ultimately"], ["proof (chain)\npicking this:\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (eel # wwl)\n  Ml \\<union> Me \\<subseteq> mon_env fg (eel # wwl)\n  ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n  \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me,\n   ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me))\n  \\<in> RU_cs fg U\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (eel # wwl)\n  Ml \\<union> Me \\<subseteq> mon_env fg (eel # wwl)\n  ah_update h (mon fg p, mon_w fg w) (Ml \\<union> Me)\n  \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me h.\n       (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n       Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n       Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n       h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ml Me h.\n     (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n     Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Ml Me h.\n     (u, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg (eel # wwl) \\<and>\n     Me \\<subseteq> mon_env fg (eel # wwl) \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) (eel # wwl))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Now we prove a statement about the precision of the least solution. As in the precision proof of the @{term \"S_cs\"} constraint system, we construct a path for the entry on the conclusion side of each constraint, assuming\n  that there already exists paths for the entries mentioned in the antecedent.\n\n  We show that each entry in the least solution corresponds exactly to some executable path, and is not just an under-approximation of a path; while for the soundness direction, we could only show that every executable path is \n  under-approximated. The reason for this is that in effect, the constraint system prunes the steps of threads that are not needed to reach the control point. However, each pruned path is executable. \n\\<close>"], ["", "lemma (in flowgraph) RU_precise: \"(u,Ml,Me,h)\\<in>RU_cs fg U \n  \\<Longrightarrow> \\<exists>w s' c'. \n    (([u],{#}),w,(s',c'))\\<in>trcl (ntrp fg) \\<and> \n    atU U ({#s'#}+c') \\<and> \n    mon_loc fg w = Ml \\<and> \n    mon_env fg w = Me \\<and> \n    \\<alpha>ah (map (\\<alpha>nl fg) w) = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, Ml, Me, h) \\<in> RU_cs fg U \\<Longrightarrow>\n    \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atU U ({#s'#} + c') \\<and>\n       mon_loc fg w = Ml \\<and>\n       mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h", "proof (induct rule: RU_cs.induct)\n  \\<comment> \\<open>The @{text \"RU_init\"} constraint is trivially covered by the empty path\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<exists>w s' c'.\n          (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n          atU U ({#s'#} + c') \\<and>\n          mon_loc fg w = {} \\<and>\n          mon_env fg w = {} \\<and>\n          \\<alpha>ah (map (\\<alpha>nl fg) w) = (\\<lambda>a. {})\n 2. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 3. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "case (RU_init u)"], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (3 subgoals):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<exists>w s' c'.\n          (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n          atU U ({#s'#} + c') \\<and>\n          mon_loc fg w = {} \\<and>\n          mon_env fg w = {} \\<and>\n          \\<alpha>ah (map (\\<alpha>nl fg) w) = (\\<lambda>a. {})\n 2. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 3. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "thus ?case"], ["proof (prove)\nusing this:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atU U ({#s'#} + c') \\<and>\n       mon_loc fg w = {} \\<and>\n       mon_env fg w = {} \\<and>\n       \\<alpha>ah (map (\\<alpha>nl fg) w) = (\\<lambda>a. {})", "by (auto intro: exI[of _ \"[]\"])"], ["proof (state)\nthis:\n  \\<exists>w s' c'.\n     (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = {} \\<and>\n     mon_env fg w = {} \\<and>\n     \\<alpha>ah (map (\\<alpha>nl fg) w) = (\\<lambda>a. {})\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "next\n  \\<comment> \\<open>Call constraint\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "case (RU_call u p u' v M P Ml Me h)"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 0\n  (v, Ml, Me, h) \\<in> RU_cs fg U\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n  mon_n fg u \\<inter> Me = {}\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "then"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 0\n  (v, Ml, Me, h) \\<in> RU_cs fg U\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n  mon_n fg u \\<inter> Me = {}", "obtain w s' c' where IHAPP: \"(([v], {#}), w, s', c') \\<in> trcl (ntrp fg)\" \"atU U ({#s'#} + c')\" \"mon_loc fg w = Ml\" \"mon_env fg w = Me\" \"\\<alpha>ah (map (\\<alpha>nl fg) w) = h\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 0\n  (v, Ml, Me, h) \\<in> RU_cs fg U\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n  mon_n fg u \\<inter> Me = {}\n\ngoal (1 subgoal):\n 1. (\\<And>w s' c'.\n        \\<lbrakk>(([v], {#}), w, s', c') \\<in> trcl (ntrp fg);\n         atU U ({#s'#} + c'); mon_loc fg w = Ml; mon_env fg w = Me;\n         \\<alpha>ah (map (\\<alpha>nl fg) w) = h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([v], {#}), w, s', c') \\<in> trcl (ntrp fg)\n  atU U ({#s'#} + c')\n  mon_loc fg w = Ml\n  mon_env fg w = Me\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "from RU_call.hyps(2) S_precise[OF RU_call.hyps(3), simplified] trss_bot_proc_const[where s=\"[]\" and s'=\"[]\", simplified]"], ["proof (chain)\npicking this:\n  proc_of fg v = p\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     P = {#} \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (([?u], ?c), ?w, [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg ?u = proc_of fg ?u'", "obtain wsl ch where \n    SLPATH: \"(([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)\" \"M = mon_w fg wsl\""], ["proof (prove)\nusing this:\n  proc_of fg v = p\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     P = {#} \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (([?u], ?c), ?w, [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg ?u = proc_of fg ?u'\n\ngoal (1 subgoal):\n 1. (\\<And>wsl ch.\n        \\<lbrakk>(([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg);\n         M = mon_w fg wsl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)\n  M = mon_w fg wsl\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "from trss_c_cases[OF SLPATH(1), simplified]"], ["proof (chain)\npicking this:\n  ((\\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p) \\<Longrightarrow>\n   ?P) \\<Longrightarrow>\n  ?P", "have CHFMT: \"\\<And>s. s \\<in># ch \\<Longrightarrow> \\<exists>p. s = [entry fg p] \\<and> (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\""], ["proof (prove)\nusing this:\n  ((\\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p) \\<Longrightarrow>\n   ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p", "by blast"], ["proof (state)\nthis:\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "with c_of_initial_no_mon"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p", "have CHNOMON: \"mon_c fg ch = {}\""], ["proof (prove)\nusing this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. mon_c fg ch = {}", "by blast\n    \\<comment> \\<open>From the constraints prerequisites, we can construct the first step\\<close>"], ["proof (state)\nthis:\n  mon_c fg ch = {}\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have FS: \"(([u],{#}),LCall p#wsl,([v,u'],ch))\\<in>ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg", "proof (rule ntrs_step[where r=\"[]\", simplified])"], ["proof (state)\ngoal (2 subgoals):\n 1. (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n 2. (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)", "from RU_call.hyps(1)"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg", "show \"(([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n\ngoal (1 subgoal):\n 1. (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg", "by (auto intro: trss_call)"], ["proof (state)\nthis:\n  (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)", "qed (rule SLPATH(1))"], ["proof (state)\nthis:\n  (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "hence FSP: \"(([u],{#}),LOC (LCall p#wsl),([v,u'],ch))\\<in>ntrp fg\""], ["proof (prove)\nusing this:\n  (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg", "by (blast intro: gtrp_loc)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "also \n    \\<comment> \\<open>The rest of the path comes from the induction hypothesis, after adding the rest of the threads to the context\\<close>"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"(([v, u'], ch), w, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([v, u'], ch), w, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)", "proof (rule ntrp_add_context[OF ntrp_stack_comp[OF IHAPP(1), where r=\"[u']\"], where cn=ch, simplified])"], ["proof (state)\ngoal (2 subgoals):\n 1. mon_n fg u' \\<inter> mon_env fg w = {}\n 2. mon_ww fg (map le_rem_s w) \\<inter> mon_c fg ch = {}", "from RU_call.hyps(1,6) IHAPP(4)"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg\n  mon_n fg u \\<inter> Me = {}\n  mon_env fg w = Me", "show \"mon_n fg u' \\<inter> mon_env fg w = {}\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n  mon_n fg u \\<inter> Me = {}\n  mon_env fg w = Me\n\ngoal (1 subgoal):\n 1. mon_n fg u' \\<inter> mon_env fg w = {}", "by (auto simp add: mon_n_def edges_part)"], ["proof (state)\nthis:\n  mon_n fg u' \\<inter> mon_env fg w = {}\n\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s w) \\<inter> mon_c fg ch = {}", "from CHNOMON"], ["proof (chain)\npicking this:\n  mon_c fg ch = {}", "show \"mon_ww fg (map le_rem_s w) \\<inter> mon_c fg ch = {}\""], ["proof (prove)\nusing this:\n  mon_c fg ch = {}\n\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s w) \\<inter> mon_c fg ch = {}", "by auto"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s w) \\<inter> mon_c fg ch = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (([v, u'], ch), w, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "finally"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # wsl) # w, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)", "have \"(([u], {#}), LOC (LCall p # wsl) # w, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # wsl) # w, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # wsl) # w, s' @ [u'], c' + ch)\n    \\<in> trcl (ntrp fg)", ". \n    \\<comment> \\<open>It is straightforward to show that the new path satisfies the required properties for its monitors and acquisition history\\<close>"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl) # w, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl) # w, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "from IHAPP(2)"], ["proof (chain)\npicking this:\n  atU U ({#s'#} + c')", "have \"atU U ({# s'@[u'] #}+(c'+ch))\""], ["proof (prove)\nusing this:\n  atU U ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. atU U ({#s' @ [u']#} + (c' + ch))", "by auto"], ["proof (state)\nthis:\n  atU U ({#s' @ [u']#} + (c' + ch))\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  atU U ({#s' @ [u']#} + (c' + ch))\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"mon_loc fg (LOC (LCall p # wsl) # w) = mon fg p \\<union> M \\<union> Ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # wsl) # w) = mon fg p \\<union> M \\<union> Ml", "using SLPATH(2) IHAPP(3)"], ["proof (prove)\nusing this:\n  M = mon_w fg wsl\n  mon_loc fg w = Ml\n\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # wsl) # w) = mon fg p \\<union> M \\<union> Ml", "by auto"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # wsl) # w) = mon fg p \\<union> M \\<union> Ml\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # wsl) # w) = mon fg p \\<union> M \\<union> Ml\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"mon_env fg (LOC (LCall p # wsl) # w) = Me\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # wsl) # w) = Me", "using IHAPP(4)"], ["proof (prove)\nusing this:\n  mon_env fg w = Me\n\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # wsl) # w) = Me", "by auto"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # wsl) # w) = Me\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # wsl) # w) = Me\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"\\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) = ah_update h (mon fg p, M) (Ml \\<union> Me)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"\\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) = ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl) (mon_pl (map (\\<alpha>nl fg) w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n    ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w))", "by (auto simp add: ah_update_cons)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n  ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n   (mon_pl (map (\\<alpha>nl fg) w))\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "also"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n  ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n   (mon_pl (map (\\<alpha>nl fg) w))\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"\\<dots> = ah_update h (mon fg p, M) (Ml \\<union> Me)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "from IHAPP(5)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h", "have \"\\<alpha>ah (map (\\<alpha>nl fg) w) = h\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) w) = h", "."], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "from SLPATH(2)"], ["proof (chain)\npicking this:\n  M = mon_w fg wsl", "have \"(mon fg p, mon_w fg wsl) = (mon fg p, M)\""], ["proof (prove)\nusing this:\n  M = mon_w fg wsl\n\ngoal (1 subgoal):\n 1. (mon fg p, mon_w fg wsl) = (mon fg p, M)", "by (simp add: mon_pl_of_\\<alpha>nl)"], ["proof (state)\nthis:\n  (mon fg p, mon_w fg wsl) = (mon fg p, M)\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  (mon fg p, mon_w fg wsl) = (mon fg p, M)\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "from IHAPP(3,4)"], ["proof (chain)\npicking this:\n  mon_loc fg w = Ml\n  mon_env fg w = Me", "have \"mon_pl (map (\\<alpha>nl fg) w) = Ml \\<union> Me\""], ["proof (prove)\nusing this:\n  mon_loc fg w = Ml\n  mon_env fg w = Me\n\ngoal (1 subgoal):\n 1. mon_pl (map (\\<alpha>nl fg) w) = Ml \\<union> Me", "by (auto simp add: mon_pl_of_\\<alpha>nl)"], ["proof (state)\nthis:\n  mon_pl (map (\\<alpha>nl fg) w) = Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n  (mon fg p, mon_w fg wsl) = (mon fg p, M)\n  mon_pl (map (\\<alpha>nl fg) w) = Ml \\<union> Me", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n  (mon fg p, mon_w fg wsl) = (mon fg p, M)\n  mon_pl (map (\\<alpha>nl fg) w) = Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>nl fg) w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "by simp"], ["proof (state)\nthis:\n  ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n   (mon_pl (map (\\<alpha>nl fg) w)) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ah_update (\\<alpha>ah (map (\\<alpha>nl fg) w)) (mon fg p, mon_w fg wsl)\n   (mon_pl (map (\\<alpha>nl fg) w)) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "finally"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "."], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)\n 2. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "ultimately"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # wsl) # w, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n  atU U ({#s' @ [u']#} + (c' + ch))\n  mon_loc fg (LOC (LCall p # wsl) # w) = mon fg p \\<union> M \\<union> Ml\n  mon_env fg (LOC (LCall p # wsl) # w) = Me\n  \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)", "show ?case"], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # wsl) # w, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n  atU U ({#s' @ [u']#} + (c' + ch))\n  mon_loc fg (LOC (LCall p # wsl) # w) = mon fg p \\<union> M \\<union> Ml\n  mon_env fg (LOC (LCall p # wsl) # w) = Me\n  \\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # w)) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (1 subgoal):\n 1. \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atU U ({#s'#} + c') \\<and>\n       mon_loc fg w = mon fg p \\<union> M \\<union> Ml \\<and>\n       mon_env fg w = Me \\<and>\n       \\<alpha>ah (map (\\<alpha>nl fg) w) =\n       ah_update h (mon fg p, M) (Ml \\<union> Me)", "by blast"], ["proof (state)\nthis:\n  \\<exists>w s' c'.\n     (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = mon fg p \\<union> M \\<union> Ml \\<and>\n     mon_env fg w = Me \\<and>\n     \\<alpha>ah (map (\\<alpha>nl fg) w) =\n     ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "next\n  \\<comment> \\<open>Spawn constraint\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "case (RU_spawn u p u' v M P q Ml Me h)"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 1\n  q \\<in># P\n  (entry fg q, Ml, Me, h) \\<in> RU_cs fg U\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "then"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 1\n  q \\<in># P\n  (entry fg q, Ml, Me, h) \\<in> RU_cs fg U\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "obtain w s' c' where IHAPP: \"(([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg)\" \"atU U ({#s'#} + c')\" \"mon_loc fg w = Ml\" \"mon_env fg w = Me\" \"\\<alpha>ah (map (\\<alpha>nl fg) w) = h\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 1\n  q \\<in># P\n  (entry fg q, Ml, Me, h) \\<in> RU_cs fg U\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>w s' c'.\n        \\<lbrakk>(([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg);\n         atU U ({#s'#} + c'); mon_loc fg w = Ml; mon_env fg w = Me;\n         \\<alpha>ah (map (\\<alpha>nl fg) w) = h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg)\n  atU U ({#s'#} + c')\n  mon_loc fg w = Ml\n  mon_env fg w = Me\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "from RU_spawn.hyps(2) S_precise[OF RU_spawn.hyps(3), simplified] trss_bot_proc_const[where s=\"[]\" and s'=\"[]\", simplified]"], ["proof (chain)\npicking this:\n  proc_of fg v = p\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> Suc 0 \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (([?u], ?c), ?w, [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg ?u = proc_of fg ?u'", "obtain wsl ch where \n    SLPATH: \"(([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)\" \"M = mon_w fg wsl\" \"size P \\<le> 1\" \"(\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch\""], ["proof (prove)\nusing this:\n  proc_of fg v = p\n  \\<exists>p c' w.\n     (([entry fg p], {#}), w, [v], c') \\<in> trcl (trss fg) \\<and>\n     size P \\<le> Suc 0 \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># c' \\<and> M = mon_w fg w\n  (([?u], ?c), ?w, [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg ?u = proc_of fg ?u'\n\ngoal (1 subgoal):\n 1. (\\<And>wsl ch.\n        \\<lbrakk>(([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg);\n         M = mon_w fg wsl; size P \\<le> 1;\n         {#[entry fg p]. p \\<in># P#} \\<subseteq># ch\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)\n  M = mon_w fg wsl\n  size P \\<le> 1\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># ch\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "with RU_spawn.hyps(4)"], ["proof (chain)\npicking this:\n  q \\<in># P\n  (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)\n  M = mon_w fg wsl\n  size P \\<le> 1\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># ch", "obtain che where PFMT: \"P={#q#}\" \"ch = {#[entry fg q]#} + che\""], ["proof (prove)\nusing this:\n  q \\<in># P\n  (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)\n  M = mon_w fg wsl\n  size P \\<le> 1\n  {#[entry fg p]. p \\<in># P#} \\<subseteq># ch\n\ngoal (1 subgoal):\n 1. (\\<And>che.\n        \\<lbrakk>P = {#q#}; ch = {#[entry fg q]#} + che\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: mset_size_le1_cases mset_le_addE)"], ["proof (state)\nthis:\n  P = {#q#}\n  ch = {#[entry fg q]#} + che\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "from trss_c_cases[OF SLPATH(1), simplified]"], ["proof (chain)\npicking this:\n  ((\\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p) \\<Longrightarrow>\n   ?P) \\<Longrightarrow>\n  ?P", "have CHFMT: \"\\<And>s. s \\<in># ch \\<Longrightarrow> \\<exists>p. s = [entry fg p] \\<and> (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\""], ["proof (prove)\nusing this:\n  ((\\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p) \\<Longrightarrow>\n   ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in># ch \\<Longrightarrow>\n       \\<exists>p.\n          s = [entry fg p] \\<and>\n          (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n          initialproc fg p", "by blast"], ["proof (state)\nthis:\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "with c_of_initial_no_mon"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p", "have CHNOMON: \"mon_c fg ch = {}\""], ["proof (prove)\nusing this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p.\n     ?s = [entry fg p] \\<and>\n     (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. mon_c fg ch = {}", "by blast"], ["proof (state)\nthis:\n  mon_c fg ch = {}\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have FS: \"(([u],{#}),LCall p#wsl,([v,u'],ch))\\<in>ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg", "proof (rule ntrs_step[where r=\"[]\", simplified])"], ["proof (state)\ngoal (2 subgoals):\n 1. (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n 2. (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)", "from RU_spawn.hyps(1)"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg", "show \"(([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n\ngoal (1 subgoal):\n 1. (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg", "by (auto intro: trss_call)"], ["proof (state)\nthis:\n  (([u], {#}), LCall p, [entry fg p, u'], {#}) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], {#}), wsl, [v], ch) \\<in> trcl (trss fg)", "qed (rule SLPATH(1))"], ["proof (state)\nthis:\n  (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "hence FSP: \"(([u],{#}),LOC (LCall p#wsl),([v,u'],ch))\\<in>ntrp fg\""], ["proof (prove)\nusing this:\n  (([u], {#}), LCall p # wsl, [v, u'], ch) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg", "by (blast intro: gtrp_loc)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "also"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl), [v, u'], ch) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"(([v, u'], ch), map ENV (map le_rem_s w), [v,u'], che+({#s'#}+c')) \\<in> trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([v, u'], ch), map ENV (map le_rem_s w), [v, u'], che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (([v, u'], ch), map ENV (map le_rem_s w), [v, u'], che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "from IHAPP(3,4)"], ["proof (chain)\npicking this:\n  mon_loc fg w = Ml\n  mon_env fg w = Me", "have \"mon_ww fg (map le_rem_s w) \\<subseteq> Ml \\<union> Me\""], ["proof (prove)\nusing this:\n  mon_loc fg w = Ml\n  mon_env fg w = Me\n\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s w) \\<subseteq> Ml \\<union> Me", "by (auto simp add: mon_ww_of_le_rem)"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s w) \\<subseteq> Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. (([v, u'], ch), map ENV (map le_rem_s w), [v, u'], che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "with RU_spawn.hyps(1,2,7)"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n  mon_ww fg (map le_rem_s w) \\<subseteq> Ml \\<union> Me", "have \"(mon_n fg v \\<union> mon_n fg u') \\<inter> mon_ww fg (map le_rem_s w) = {}\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n  mon_ww fg (map le_rem_s w) \\<subseteq> Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. (mon_n fg v \\<union> mon_n fg u') \\<inter> mon_ww fg (map le_rem_s w) =\n    {}", "by (auto simp add: mon_n_def edges_part)"], ["proof (state)\nthis:\n  (mon_n fg v \\<union> mon_n fg u') \\<inter> mon_ww fg (map le_rem_s w) = {}\n\ngoal (1 subgoal):\n 1. (([v, u'], ch), map ENV (map le_rem_s w), [v, u'], che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "with ntr2ntrp[OF gtrp2gtr[OF IHAPP(1)], of \"[v,u']\" che] PFMT(2) CHNOMON"], ["proof (chain)\npicking this:\n  mon_c fg (add_mset [v, u'] che) \\<inter>\n  (mon_c fg {#[entry fg q]#} \\<union> mon_ww fg (map le_rem_s w)) =\n  {} \\<Longrightarrow>\n  (([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s w), [v, u'],\n   che + add_mset s' c')\n  \\<in> trcl (ntrp fg)\n  ch = {#[entry fg q]#} + che\n  mon_c fg ch = {}\n  (mon_n fg v \\<union> mon_n fg u') \\<inter> mon_ww fg (map le_rem_s w) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  mon_c fg (add_mset [v, u'] che) \\<inter>\n  (mon_c fg {#[entry fg q]#} \\<union> mon_ww fg (map le_rem_s w)) =\n  {} \\<Longrightarrow>\n  (([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s w), [v, u'],\n   che + add_mset s' c')\n  \\<in> trcl (ntrp fg)\n  ch = {#[entry fg q]#} + che\n  mon_c fg ch = {}\n  (mon_n fg v \\<union> mon_n fg u') \\<inter> mon_ww fg (map le_rem_s w) = {}\n\ngoal (1 subgoal):\n 1. (([v, u'], ch), map ENV (map le_rem_s w), [v, u'], che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "by (auto simp add: union_ac mon_c_unconc)"], ["proof (state)\nthis:\n  (([v, u'], ch), map ENV (map le_rem_s w), [v, u'], che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (([v, u'], ch), map ENV (map le_rem_s w), [v, u'], che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "finally"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # wsl) # map ENV (map le_rem_s w), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)", "have \"(([u], {#}), LOC (LCall p # wsl) # map ENV (map le_rem_s w), [v, u'], che + ({#s'#} + c')) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # wsl) # map ENV (map le_rem_s w), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # wsl) # map ENV (map le_rem_s w), [v, u'],\n     che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "."], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl) # map ENV (map le_rem_s w), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # wsl) # map ENV (map le_rem_s w), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "from IHAPP(2)"], ["proof (chain)\npicking this:\n  atU U ({#s'#} + c')", "have \"atU U ({#[v,u']#} + (che+({#s'#} + c')))\""], ["proof (prove)\nusing this:\n  atU U ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. atU U ({#[v, u']#} + (che + ({#s'#} + c')))", "by auto"], ["proof (state)\nthis:\n  atU U ({#[v, u']#} + (che + ({#s'#} + c')))\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  atU U ({#[v, u']#} + (che + ({#s'#} + c')))\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"mon_loc fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) = mon fg p \\<union> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n    mon fg p \\<union> M", "using SLPATH(2)"], ["proof (prove)\nusing this:\n  M = mon_w fg wsl\n\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n    mon fg p \\<union> M", "by (auto simp del: map_map)"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n  mon fg p \\<union> M\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n  mon fg p \\<union> M\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"mon_env fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) = Ml \\<union> Me\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n    Ml \\<union> Me", "using IHAPP(3,4)"], ["proof (prove)\nusing this:\n  mon_loc fg w = Ml\n  mon_env fg w = Me\n\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n    Ml \\<union> Me", "by (auto simp add: mon_ww_of_le_rem simp del: map_map)"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n  Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n  Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"\\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) = ah_update h (mon fg p, M) (Ml \\<union> Me)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah\n     (map (\\<alpha>nl fg)\n       (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha>ah\n     (map (\\<alpha>nl fg)\n       (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"\\<alpha>ah (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) = ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w))) (mon fg p, mon_w fg wsl) (mon_pl (map (\\<alpha>n fg) (map le_rem_s w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah\n     (map (\\<alpha>nl fg)\n       (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n    ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl) (mon_pl (map (\\<alpha>n fg) (map le_rem_s w)))", "by (simp add: ah_update_cons o_assoc)"], ["proof (state)\nthis:\n  \\<alpha>ah\n   (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n  ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n   (mon fg p, mon_w fg wsl) (mon_pl (map (\\<alpha>n fg) (map le_rem_s w)))\n\ngoal (1 subgoal):\n 1. \\<alpha>ah\n     (map (\\<alpha>nl fg)\n       (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "also"], ["proof (state)\nthis:\n  \\<alpha>ah\n   (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n  ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n   (mon fg p, mon_w fg wsl) (mon_pl (map (\\<alpha>n fg) (map le_rem_s w)))\n\ngoal (1 subgoal):\n 1. \\<alpha>ah\n     (map (\\<alpha>nl fg)\n       (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "have \"\\<dots> = ah_update h (mon fg p, M) (Ml \\<union> Me)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "from IHAPP(5)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h", "have \"\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)) = h\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)) = h", "by (simp add: \\<alpha>n_\\<alpha>nl)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)) = h\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)) = h\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "from SLPATH(2)"], ["proof (chain)\npicking this:\n  M = mon_w fg wsl", "have \"(mon fg p, mon_w fg wsl) = (mon fg p, M)\""], ["proof (prove)\nusing this:\n  M = mon_w fg wsl\n\ngoal (1 subgoal):\n 1. (mon fg p, mon_w fg wsl) = (mon fg p, M)", "by simp"], ["proof (state)\nthis:\n  (mon fg p, mon_w fg wsl) = (mon fg p, M)\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "moreover"], ["proof (state)\nthis:\n  (mon fg p, mon_w fg wsl) = (mon fg p, M)\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "from IHAPP(3,4)"], ["proof (chain)\npicking this:\n  mon_loc fg w = Ml\n  mon_env fg w = Me", "have \"mon_pl (map (\\<alpha>n fg) (map le_rem_s w)) = Ml \\<union> Me\""], ["proof (prove)\nusing this:\n  mon_loc fg w = Ml\n  mon_env fg w = Me\n\ngoal (1 subgoal):\n 1. mon_pl (map (\\<alpha>n fg) (map le_rem_s w)) = Ml \\<union> Me", "by (auto simp add: mon_pl_of_\\<alpha>nl \\<alpha>n_\\<alpha>nl)"], ["proof (state)\nthis:\n  mon_pl (map (\\<alpha>n fg) (map le_rem_s w)) = Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)) = h\n  (mon fg p, mon_w fg wsl) = (mon fg p, M)\n  mon_pl (map (\\<alpha>n fg) (map le_rem_s w)) = Ml \\<union> Me", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)) = h\n  (mon fg p, mon_w fg wsl) = (mon fg p, M)\n  mon_pl (map (\\<alpha>n fg) (map le_rem_s w)) = Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n     (mon fg p, mon_w fg wsl)\n     (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "by simp"], ["proof (state)\nthis:\n  ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n   (mon fg p, mon_w fg wsl) (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ah_update (\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s w)))\n   (mon fg p, mon_w fg wsl) (mon_pl (map (\\<alpha>n fg) (map le_rem_s w))) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (1 subgoal):\n 1. \\<alpha>ah\n     (map (\\<alpha>nl fg)\n       (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "finally"], ["proof (chain)\npicking this:\n  \\<alpha>ah\n   (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah\n   (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (1 subgoal):\n 1. \\<alpha>ah\n     (map (\\<alpha>nl fg)\n       (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n    ah_update h (mon fg p, M) (Ml \\<union> Me)", "."], ["proof (state)\nthis:\n  \\<alpha>ah\n   (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>ah\n   (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q Ml Me h.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atU U ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and>\n           mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atU U ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me \\<and>\n                            \\<alpha>ah (map (\\<alpha>nl fg) w) =\n                            ah_update h (mon fg p, M) (Ml \\<union> Me)", "ultimately"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # wsl) # map ENV (map le_rem_s w), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n  atU U ({#[v, u']#} + (che + ({#s'#} + c')))\n  mon_loc fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n  mon fg p \\<union> M\n  mon_env fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n  Ml \\<union> Me\n  \\<alpha>ah\n   (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)", "show ?case"], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # wsl) # map ENV (map le_rem_s w), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n  atU U ({#[v, u']#} + (che + ({#s'#} + c')))\n  mon_loc fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n  mon fg p \\<union> M\n  mon_env fg (LOC (LCall p # wsl) # map ENV (map le_rem_s w)) =\n  Ml \\<union> Me\n  \\<alpha>ah\n   (map (\\<alpha>nl fg) (LOC (LCall p # wsl) # map ENV (map le_rem_s w))) =\n  ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal (1 subgoal):\n 1. \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atU U ({#s'#} + c') \\<and>\n       mon_loc fg w = mon fg p \\<union> M \\<and>\n       mon_env fg w = Ml \\<union> Me \\<and>\n       \\<alpha>ah (map (\\<alpha>nl fg) w) =\n       ah_update h (mon fg p, M) (Ml \\<union> Me)", "by blast"], ["proof (state)\nthis:\n  \\<exists>w s' c'.\n     (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = mon fg p \\<union> M \\<and>\n     mon_env fg w = Ml \\<union> Me \\<and>\n     \\<alpha>ah (map (\\<alpha>nl fg) w) =\n     ah_update h (mon fg p, M) (Ml \\<union> Me)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Simultaneously reaching path\""], ["", "text \\<open>\n  In this section, we define a constraint system that collects abstract information for paths starting at a single control node and reaching two program points simultaneously, one from a set @{term U} and one from a set @{term V}.\n\\<close>"], ["", "subsubsection \"Constraint system\""], ["", "text \\<open>\n  An element @{term \"(u,Ml,Me)\\<in>RUV_cs fg U V\"} means, that there is a path from @{term \"{#[u]#}\"} to some configuration that is simultaneously at @{term U} and at @{term V}. \n  That path uses monitors from @{term Ml} in the first thread and monitors from @{term Me} in the other threads.\n\\<close>"], ["", "inductive_set\n  RUV_cs :: \"('n,'p,'ba,'m,'more) flowgraph_rec_scheme \\<Rightarrow> \n             'n set \\<Rightarrow> 'n set \\<Rightarrow> ('n \\<times> 'm set \\<times> 'm set) set\"\n  for fg U V\nwhere\n    RUV_call: \n      \"\\<lbrakk> (u,Call p,u')\\<in>edges fg; proc_of fg v = p; (v,M,P)\\<in>S_cs fg 0; \n         (v,Ml,Me)\\<in>RUV_cs fg U V; mon_n fg u \\<inter> Me = {} \\<rbrakk> \n      \\<Longrightarrow> (u,mon fg p \\<union> M \\<union> Ml,Me)\\<in>RUV_cs fg U V\"\n  | RUV_spawn: \n      \"\\<lbrakk> (u,Call p,u')\\<in>edges fg; proc_of fg v = p; (v,M,P)\\<in>S_cs fg 1; q \\<in># P; \n         (entry fg q,Ml,Me)\\<in>RUV_cs fg U V; \n         (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {} \\<rbrakk> \n      \\<Longrightarrow> (u, mon fg p \\<union> M, Ml\\<union>Me)\\<in>RUV_cs fg U V\"\n  | RUV_split_le: \n      \"\\<lbrakk> (u,Call p,u')\\<in>edges fg; proc_of fg v = p; (v,M,P)\\<in>S_cs fg 1; q \\<in># P; \n         (v,Ml,Me,h)\\<in>RU_cs fg U; (entry fg q,Ml',Me',h')\\<in>RU_cs fg V; \n         (mon_n fg u \\<union> mon fg p) \\<inter> (Me\\<union>Ml'\\<union>Me')={}; h [*] h' \\<rbrakk> \n      \\<Longrightarrow> (u, mon fg p \\<union> M \\<union> Ml, Me \\<union> Ml' \\<union> Me')\\<in>RUV_cs fg U V\"\n  | RUV_split_el: \n      \"\\<lbrakk> (u,Call p,u')\\<in>edges fg; proc_of fg v = p; (v,M,P)\\<in>S_cs fg 1; q \\<in># P; \n         (v,Ml,Me,h)\\<in>RU_cs fg V; (entry fg q,Ml',Me',h')\\<in>RU_cs fg U; \n         (mon_n fg u \\<union> mon fg p) \\<inter> (Me\\<union>Ml'\\<union>Me')={}; h [*] h' \\<rbrakk> \n      \\<Longrightarrow> (u, mon fg p \\<union> M \\<union> Ml, Me \\<union> Ml' \\<union> Me')\\<in>RUV_cs fg U V\"\n  | RUV_split_ee: \n      \"\\<lbrakk> (u,Call p,u')\\<in>edges fg; proc_of fg v = p; (v,M,P)\\<in>S_cs fg 2; \n         {#q#}+{#q'#} \\<subseteq># P;\n         (entry fg q,Ml,Me,h)\\<in>RU_cs fg U; (entry fg q',Ml',Me',h')\\<in>RU_cs fg V; \n         (mon_n fg u \\<union> mon fg p) \\<inter> (Ml\\<union>Me\\<union>Ml'\\<union>Me') = {}; h [*] h' \\<rbrakk> \n      \\<Longrightarrow> (u, mon fg p \\<union> M, Ml\\<union>Me\\<union>Ml'\\<union>Me')\\<in>RUV_cs fg U V\""], ["", "text \\<open>\n  The idea underlying this constraint system is similar to the @{term RU_cs}-constraint system for reaching a single node set. \n  Initially, we just track one thread. After a macrostep, we have a configuration consisting of the transformed initial thread and the spawned threads.\n  From this configuration, we reach two nodes simultaneously, one in @{term U} and one in @{term V}. Each of these nodes is reached by just a single thread. The constraint system\n  contains one constraint for each case how these threads are related to the initial and the spawned threads:\n\n  \\begin{description}\n    \\item[RUV\\_call] Both, @{term U} and @{term V} are reached from the initial thread.\n    \\item[RUV\\_spawn] Both, @{term U} and @{term V} are reached from a single spawned thread.\n    \\item[RUV\\_split\\_le] @{term U} is reached from the initial thread, @{term V} is reached from a spawned thread.\n    \\item[RUV\\_split\\_el] @{term V} is reached from the initial thread, @{term U} is reached from a spawned thread.\n    \\item[RUV\\_split\\_ee] Both, @{term U} and @{term V} are reached from different spawned threads.\n  \\end{description}\n\n  In the latter three cases, we have to analyze the interleaving of two paths each reaching a single control node. This is done via the acquisition history\n  information that we collected in the @{term RU_cs}-constraint system.\n\n  Note that we do not need an initializing constraint for the empty path, as a single configuration cannot simultaneously be at two control nodes.\n\\<close>"], ["", "subsubsection \\<open>Soundness and precision\\<close>"], ["", "lemma (in flowgraph) RUV_sound: \"!!u s' c'. \n  \\<lbrakk> (([u],{#}),w,(s',c'))\\<in>trcl (ntrp fg); atUV U V ({#s'#}+c') \\<rbrakk> \n  \\<Longrightarrow> \\<exists>Ml Me. \n    (u,Ml,Me)\\<in>RUV_cs fg U V \\<and> \n    Ml \\<subseteq> mon_loc fg w \\<and> \n    Me \\<subseteq> mon_env fg w\"\n\\<comment> \\<open>The soundness proof is done by induction over the length of the reaching path\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s' c'.\n       \\<lbrakk>(([u], {#}), w, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg w \\<and>\n                            Me \\<subseteq> mon_env fg w", "proof (induct w rule: length_compl_induct)\n  \\<comment> \\<open>In case of the empty path, a contradiction follows because a single-thread configuration cannot simultaneously be at two control nodes\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u s' c'.\n       \\<lbrakk>(([u], {#}), [], s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg [] \\<and>\n                            Me \\<subseteq> mon_env fg []\n 2. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "case Nil"], ["proof (state)\nthis:\n  (([u], {#}), [], s', c') \\<in> trcl (ntrp fg)\n  atUV U V ({#s'#} + c')\n\ngoal (2 subgoals):\n 1. \\<And>u s' c'.\n       \\<lbrakk>(([u], {#}), [], s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg [] \\<and>\n                            Me \\<subseteq> mon_env fg []\n 2. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "hence False"], ["proof (prove)\nusing this:\n  (([u], {#}), [], s', c') \\<in> trcl (ntrp fg)\n  atUV U V ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>u s' c'.\n       \\<lbrakk>(([u], {#}), [], s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg [] \\<and>\n                            Me \\<subseteq> mon_env fg []\n 2. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg [] \\<and> Me \\<subseteq> mon_env fg []", ".."], ["proof (state)\nthis:\n  \\<exists>Ml Me.\n     (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg [] \\<and> Me \\<subseteq> mon_env fg []\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "case (Cons ee ww)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length ww;\n   (([?u], {#}), ?ll, ?s', ?c') \\<in> trcl (ntrp fg);\n   atUV U V ({#?s'#} + ?c')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ml Me.\n                       (?u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                       Ml \\<subseteq> mon_loc fg ?ll \\<and>\n                       Me \\<subseteq> mon_env fg ?ll\n  (([u], {#}), ee # ww, s', c') \\<in> trcl (ntrp fg)\n  atUV U V ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length ww;\n   (([?u], {#}), ?ll, ?s', ?c') \\<in> trcl (ntrp fg);\n   atUV U V ({#?s'#} + ?c')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ml Me.\n                       (?u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                       Ml \\<subseteq> mon_loc fg ?ll \\<and>\n                       Me \\<subseteq> mon_env fg ?ll\n  (([u], {#}), ee # ww, s', c') \\<in> trcl (ntrp fg)\n  atUV U V ({#s'#} + c')", "obtain sh ch where SPLIT: \"(([u],{#}),ee,(sh,ch))\\<in>ntrp fg\" \"((sh,ch),ww,(s',c'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length ww;\n   (([?u], {#}), ?ll, ?s', ?c') \\<in> trcl (ntrp fg);\n   atUV U V ({#?s'#} + ?c')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ml Me.\n                       (?u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                       Ml \\<subseteq> mon_loc fg ?ll \\<and>\n                       Me \\<subseteq> mon_env fg ?ll\n  (([u], {#}), ee # ww, s', c') \\<in> trcl (ntrp fg)\n  atUV U V ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>(([u], {#}), ee, sh, ch) \\<in> ntrp fg;\n         ((sh, ch), ww, s', c') \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  (([u], {#}), ee, sh, ch) \\<in> ntrp fg\n  ((sh, ch), ww, s', c') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "from ntrp_split[where ?c1.0=\"{#}\", simplified, OF SPLIT(2) ntrp_valid_preserve_s[OF SPLIT(1)], simplified]"], ["proof (chain)\npicking this:\n  \\<exists>w1 w2.\n     ww \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     (\\<exists>c1' c2'.\n         c' = c1' + c2' \\<and>\n         ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n         (ch, w2, c2') \\<in> trcl (ntr fg) \\<and>\n         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {} \\<and>\n         mon_ww fg w2 \\<inter> mon_s fg sh = {})", "obtain w1 w2 c1' c2' where \n    LESPLIT: \"ww \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\" \"c' = c1' + c2'\" \"((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg)\" \"(ch, w2, c2') \\<in> trcl (ntr fg)\" \"mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {}\" \"mon_ww fg w2 \\<inter> mon_s fg sh = {}\""], ["proof (prove)\nusing this:\n  \\<exists>w1 w2.\n     ww \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     (\\<exists>c1' c2'.\n         c' = c1' + c2' \\<and>\n         ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n         (ch, w2, c2') \\<in> trcl (ntr fg) \\<and>\n         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {} \\<and>\n         mon_ww fg w2 \\<inter> mon_s fg sh = {})\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 c1' c2'.\n        \\<lbrakk>ww \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n         fg\\<^esub> map ENV w2;\n         c' = c1' + c2'; ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg);\n         (ch, w2, c2') \\<in> trcl (ntr fg);\n         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {};\n         mon_ww fg w2 \\<inter> mon_s fg sh = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ww \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  c' = c1' + c2'\n  ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg)\n  (ch, w2, c2') \\<in> trcl (ntr fg)\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ch = {}\n  mon_ww fg w2 \\<inter> mon_s fg sh = {}\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "obtain p u' v w where \n    FS_FMT: \"ee = LOC (LCall p # w)\" \"(u, Call p, u') \\<in> edges fg\" \"sh = [v, u']\" \"proc_of fg v = p\" \"mon_c fg ch = {}\" \n    and CHFMT: \"\\<And>s. s \\<in># ch \\<Longrightarrow> \\<exists>p u v. s = [entry fg p] \\<and> (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\"\n    and S_ENTRY_PAT: \"\\<And>P. (\\<lambda>p. [entry fg p]) `# P \\<subseteq># ch \\<Longrightarrow> (v, mon_w fg w, P) \\<in> S_cs fg (size P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p w u' v.\n        \\<lbrakk>ee = LOC (LCall p # w); (u, Call p, u') \\<in> edges fg;\n         sh = [v, u']; proc_of fg v = p; mon_c fg ch = {};\n         \\<And>s.\n            s \\<in># ch \\<Longrightarrow>\n            \\<exists>p u v.\n               s = [entry fg p] \\<and>\n               (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p;\n         \\<And>P.\n            {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<Longrightarrow>\n            (v, mon_w fg w, P) \\<in> S_cs fg (size P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule S_sound_ntrp[OF SPLIT(1)]) blast"], ["proof (state)\nthis:\n  ee = LOC (LCall p # w)\n  (u, Call p, u') \\<in> edges fg\n  sh = [v, u']\n  proc_of fg v = p\n  mon_c fg ch = {}\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  {#[entry fg p]. p \\<in># ?P#} \\<subseteq># ch \\<Longrightarrow>\n  (v, mon_w fg w, ?P) \\<in> S_cs fg (size ?P)\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "from ntrp_mon_env_w_no_ctx[OF SPLIT(2)] FS_FMT(3,4) edges_part[OF FS_FMT(2)]"], ["proof (chain)\npicking this:\n  mon_env fg ww \\<inter> mon_s fg sh = {}\n  sh = [v, u']\n  proc_of fg v = p\n  proc_of fg u = proc_of fg u'", "have MON_PU: \"mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\""], ["proof (prove)\nusing this:\n  mon_env fg ww \\<inter> mon_s fg sh = {}\n  sh = [v, u']\n  proc_of fg v = p\n  proc_of fg u = proc_of fg u'\n\ngoal (1 subgoal):\n 1. mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}", "by (auto simp add: mon_n_def)"], ["proof (state)\nthis:\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "from cil_ileq[OF LESPLIT(1)] mon_loc_ileq[of w1 ww fg] mon_env_ileq[of w1 ww fg]"], ["proof (chain)\npicking this:\n  w1 \\<preceq> ww \\<and> map ENV w2 \\<preceq> ww\n  w1 \\<preceq> ww \\<Longrightarrow> mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  w1 \\<preceq> ww \\<Longrightarrow> mon_env fg w1 \\<subseteq> mon_env fg ww", "have MON1_LEQ: \"mon_loc fg w1 \\<subseteq> mon_loc fg ww\" \"mon_env fg w1 \\<subseteq> mon_env fg ww\""], ["proof (prove)\nusing this:\n  w1 \\<preceq> ww \\<and> map ENV w2 \\<preceq> ww\n  w1 \\<preceq> ww \\<Longrightarrow> mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  w1 \\<preceq> ww \\<Longrightarrow> mon_env fg w1 \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. mon_loc fg w1 \\<subseteq> mon_loc fg ww &&&\n    mon_env fg w1 \\<subseteq> mon_env fg ww", "by auto"], ["proof (state)\nthis:\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "from cil_ileq[OF LESPLIT(1)] mon_env_ileq[of \"map ENV w2\" ww fg]"], ["proof (chain)\npicking this:\n  w1 \\<preceq> ww \\<and> map ENV w2 \\<preceq> ww\n  map ENV w2 \\<preceq> ww \\<Longrightarrow>\n  mon_env fg (map ENV w2) \\<subseteq> mon_env fg ww", "have MON2_LEQ: \"mon_ww fg w2 \\<subseteq> mon_env fg ww\""], ["proof (prove)\nusing this:\n  w1 \\<preceq> ww \\<and> map ENV w2 \\<preceq> ww\n  map ENV w2 \\<preceq> ww \\<Longrightarrow>\n  mon_env fg (map ENV w2) \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_env fg ww", "by simp"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "from LESPLIT(3) FS_FMT(3) ntrp_stack_decomp[of v \"[]\" \"[u']\" \"{#}\" w1 s' c1', simplified]"], ["proof (chain)\npicking this:\n  ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg)\n  sh = [v, u']\n  \\<lbrakk>(([v, u'], {#}), w1, s', c1') \\<in> trcl (ntrp ?fg);\n   \\<And>va rr.\n      \\<lbrakk>s' = va # rr @ [u'];\n       (([v], {#}), w1, va # rr, c1') \\<in> trcl (ntrp ?fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P", "obtain v' rr where DECOMP_LOC: \"s'=v'#rr@[u']\" \"(([v],{#}),w1,(v'#rr,c1'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  ((sh, {#}), w1, s', c1') \\<in> trcl (ntrp fg)\n  sh = [v, u']\n  \\<lbrakk>(([v, u'], {#}), w1, s', c1') \\<in> trcl (ntrp ?fg);\n   \\<And>va rr.\n      \\<lbrakk>s' = va # rr @ [u'];\n       (([v], {#}), w1, va # rr, c1') \\<in> trcl (ntrp ?fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>v' rr.\n        \\<lbrakk>s' = v' # rr @ [u'];\n         (([v], {#}), w1, v' # rr, c1') \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp, blast)"], ["proof (state)\nthis:\n  s' = v' # rr @ [u']\n  (([v], {#}), w1, v' # rr, c1') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "from Cons.prems(2) LESPLIT(2)"], ["proof (chain)\npicking this:\n  atUV U V ({#s'#} + c')\n  c' = c1' + c2'", "have \"atUV U V (({#s'#}+c1') + c2')\""], ["proof (prove)\nusing this:\n  atUV U V ({#s'#} + c')\n  c' = c1' + c2'\n\ngoal (1 subgoal):\n 1. atUV U V ({#s'#} + c1' + c2')", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  atUV U V ({#s'#} + c1' + c2')\n\ngoal (1 subgoal):\n 1. \\<And>e l u s' c'.\n       \\<lbrakk>\\<And>ll u s' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([u], {#}), ll, s', c') \\<in> trcl (ntrp fg);\n                    atUV U V ({#s'#} + c')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Ml Me.\n  (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n  Ml \\<subseteq> mon_loc fg ll \\<and> Me \\<subseteq> mon_env fg ll;\n        (([u], {#}), e # l, s', c') \\<in> trcl (ntrp fg);\n        atUV U V ({#s'#} + c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ml Me.\n                            (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                            Ml \\<subseteq> mon_loc fg (e # l) \\<and>\n                            Me \\<subseteq> mon_env fg (e # l)", "thus ?case"], ["proof (prove)\nusing this:\n  atUV U V ({#s'#} + c1' + c2')\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)", "proof (cases rule: atUV_union_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "case left"], ["proof (state)\nthis:\n  atUV U V ({#s'#} + c1')\n\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "with DECOMP_LOC(1)"], ["proof (chain)\npicking this:\n  s' = v' # rr @ [u']\n  atUV U V ({#s'#} + c1')", "have ATUV: \"atUV U V ({# v'#rr #}+c1')\""], ["proof (prove)\nusing this:\n  s' = v' # rr @ [u']\n  atUV U V ({#s'#} + c1')\n\ngoal (1 subgoal):\n 1. atUV U V ({#v' # rr#} + c1')", "by simp"], ["proof (state)\nthis:\n  atUV U V ({#v' # rr#} + c1')\n\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from Cons.hyps[OF _ DECOMP_LOC(2) ATUV] cil_length[OF LESPLIT(1)]"], ["proof (chain)\npicking this:\n  length w1 \\<le> length ww \\<Longrightarrow>\n  \\<exists>Ml Me.\n     (v, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg w1 \\<and> Me \\<subseteq> mon_env fg w1\n  length ww = length w1 + length (map ENV w2)", "obtain Ml Me where IHAPP: \"(v, Ml, Me) \\<in> RUV_cs fg U V\" \"Ml \\<subseteq> mon_loc fg w1\" \"Me \\<subseteq> mon_env fg w1\""], ["proof (prove)\nusing this:\n  length w1 \\<le> length ww \\<Longrightarrow>\n  \\<exists>Ml Me.\n     (v, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg w1 \\<and> Me \\<subseteq> mon_env fg w1\n  length ww = length w1 + length (map ENV w2)\n\ngoal (1 subgoal):\n 1. (\\<And>Ml Me.\n        \\<lbrakk>(v, Ml, Me) \\<in> RUV_cs fg U V;\n         Ml \\<subseteq> mon_loc fg w1; Me \\<subseteq> mon_env fg w1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, Ml, Me) \\<in> RUV_cs fg U V\n  Ml \\<subseteq> mon_loc fg w1\n  Me \\<subseteq> mon_env fg w1\n\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from RUV_call[OF FS_FMT(2,4) S_ENTRY_PAT[of \"{#}\", simplified] IHAPP(1)]"], ["proof (chain)\npicking this:\n  mon_n fg u \\<inter> Me = {} \\<Longrightarrow>\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V", "have \"(u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V\""], ["proof (prove)\nusing this:\n  mon_n fg u \\<inter> Me = {} \\<Longrightarrow>\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V", "using IHAPP(3) MON_PU MON1_LEQ"], ["proof (prove)\nusing this:\n  mon_n fg u \\<inter> Me = {} \\<Longrightarrow>\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V\n  Me \\<subseteq> mon_env fg w1\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V", "by fastforce"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V\n\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V\n\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee#ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<union> Ml\n    \\<subseteq> mon_loc fg (ee # ww)", "using FS_FMT(1) IHAPP(2) MON1_LEQ"], ["proof (prove)\nusing this:\n  ee = LOC (LCall p # w)\n  Ml \\<subseteq> mon_loc fg w1\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<union> Ml\n    \\<subseteq> mon_loc fg (ee # ww)", "by auto"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"Me \\<subseteq> mon_env fg (ee#ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Me \\<subseteq> mon_env fg (ee # ww)", "using IHAPP(3) MON1_LEQ"], ["proof (prove)\nusing this:\n  Me \\<subseteq> mon_env fg w1\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. Me \\<subseteq> mon_env fg (ee # ww)", "by auto"], ["proof (state)\nthis:\n  Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal (4 subgoals):\n 1. atUV U V ({#s'#} + c1') \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 4. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "ultimately"], ["proof (chain)\npicking this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n  Me \\<subseteq> mon_env fg (ee # ww)", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me) \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n  Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ml Me.\n     (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n     Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal (3 subgoals):\n 1. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "case right \\<comment> \\<open>Both nodes are reached from the spawned threads, we have to further distinguish whether both nodes are reached from the same thread or from different threads\\<close>"], ["proof (state)\nthis:\n  atUV U V c2'\n\ngoal (3 subgoals):\n 1. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "then"], ["proof (chain)\npicking this:\n  atUV U V c2'", "obtain s1' s2' where R_STACKS: \"{#s1'#}+{#s2'#} \\<subseteq># c2'\" \"atU_s U s1'\" \"atU_s V s2'\""], ["proof (prove)\nusing this:\n  atUV U V c2'\n\ngoal (1 subgoal):\n 1. (\\<And>s1' s2'.\n        \\<lbrakk>{#s1'#} + {#s2'#} \\<subseteq># c2'; atU_s U s1';\n         atU_s V s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold atUV_def) auto"], ["proof (state)\nthis:\n  {#s1'#} + {#s2'#} \\<subseteq># c2'\n  atU_s U s1'\n  atU_s V s2'\n\ngoal (3 subgoals):\n 1. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "then"], ["proof (chain)\npicking this:\n  {#s1'#} + {#s2'#} \\<subseteq># c2'\n  atU_s U s1'\n  atU_s V s2'", "obtain ce2' where C2'FMT: \"c2'={#s1'#}+({#s2'#}+ce2')\""], ["proof (prove)\nusing this:\n  {#s1'#} + {#s2'#} \\<subseteq># c2'\n  atU_s U s1'\n  atU_s V s2'\n\ngoal (1 subgoal):\n 1. (\\<And>ce2'.\n        c2' = {#s1'#} + ({#s2'#} + ce2') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: mset_subset_eq_exists_conv union_ac)"], ["proof (state)\nthis:\n  c2' = {#s1'#} + ({#s2'#} + ce2')\n\ngoal (3 subgoals):\n 1. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "obtain q ceh w21 w22 ce21' ce22' where \n      REVSPLIT: \"ch={#[entry fg q]#}+ceh\" \"add_mset s2' ce2' = ce21'+ce22'\" \"w2\\<in>w21\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>w22\" \"mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22)={}\" \"mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {}\"\n      \"({#[entry fg q]#},w21,{#s1'#}+ce21')\\<in>trcl (ntr fg)\" \"(ceh,w22,ce22')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q ceh ce21' ce22' w21 w22.\n        \\<lbrakk>ch = {#[entry fg q]#} + ceh;\n         add_mset s2' ce2' = ce21' + ce22';\n         w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22;\n         mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {};\n         mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {};\n         ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg);\n         (ceh, w22, ce22') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q ceh ce21' ce22' w21 w22.\n        \\<lbrakk>ch = {#[entry fg q]#} + ceh;\n         add_mset s2' ce2' = ce21' + ce22';\n         w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22;\n         mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {};\n         mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {};\n         ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg);\n         (ceh, w22, ce22') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ntr_reverse_split[of ch w2 s1' \"{#s2'#}+ce2'\"] ntrp_valid_preserve_s[OF SPLIT(1), simplified] C2'FMT LESPLIT(4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>(ch, w2, {#s1'#} + ({#s2'#} + ce2')) \\<in> trcl (ntr fg);\n   valid fg ch\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s ce w1 w2a ce1' ce2'a.\n                       ch = {#s#} + ce \\<and>\n                       {#s2'#} + ce2' = ce1' + ce2'a \\<and>\n                       w2 \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> w2a \\<and>\n                       mon_s fg s \\<inter>\n                       (mon_c fg ce \\<union> mon_ww fg w2a) =\n                       {} \\<and>\n                       mon_c fg ce \\<inter>\n                       (mon_s fg s \\<union> mon_ww fg w1) =\n                       {} \\<and>\n                       ({#s#}, w1, {#s1'#} + ce1')\n                       \\<in> trcl (ntr fg) \\<and>\n                       (ce, w2a, ce2'a) \\<in> trcl (ntr fg)\n  valid fg (add_mset sh ch)\n  c2' = {#s1'#} + ({#s2'#} + ce2')\n  (ch, w2, c2') \\<in> trcl (ntr fg)", "obtain seh ceh w21 w22 ce21' ce22' where \n        *: \"ch={#seh#}+ceh\" \"{#s2'#}+ce2' = ce21'+ce22'\" \"w2\\<in>w21\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>w22\" \"mon_s fg seh \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22)={}\" \"mon_c fg ceh \\<inter> (mon_s fg seh \\<union> mon_ww fg w21) = {}\"\n        \"({#seh#},w21,{#s1'#}+ce21')\\<in>trcl (ntr fg)\" \"(ceh,w22,ce22')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(ch, w2, {#s1'#} + ({#s2'#} + ce2')) \\<in> trcl (ntr fg);\n   valid fg ch\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s ce w1 w2a ce1' ce2'a.\n                       ch = {#s#} + ce \\<and>\n                       {#s2'#} + ce2' = ce1' + ce2'a \\<and>\n                       w2 \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> w2a \\<and>\n                       mon_s fg s \\<inter>\n                       (mon_c fg ce \\<union> mon_ww fg w2a) =\n                       {} \\<and>\n                       mon_c fg ce \\<inter>\n                       (mon_s fg s \\<union> mon_ww fg w1) =\n                       {} \\<and>\n                       ({#s#}, w1, {#s1'#} + ce1')\n                       \\<in> trcl (ntr fg) \\<and>\n                       (ce, w2a, ce2'a) \\<in> trcl (ntr fg)\n  valid fg (add_mset sh ch)\n  c2' = {#s1'#} + ({#s2'#} + ce2')\n  (ch, w2, c2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>seh ceh ce21' ce22' w21 w22.\n        \\<lbrakk>ch = {#seh#} + ceh; {#s2'#} + ce2' = ce21' + ce22';\n         w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22;\n         mon_s fg seh \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {};\n         mon_c fg ceh \\<inter> (mon_s fg seh \\<union> mon_ww fg w21) = {};\n         ({#seh#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg);\n         (ceh, w22, ce22') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: valid_unconc)"], ["proof (state)\nthis:\n  ch = {#seh#} + ceh\n  {#s2'#} + ce2' = ce21' + ce22'\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg seh \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {}\n  mon_c fg ceh \\<inter> (mon_s fg seh \\<union> mon_ww fg w21) = {}\n  ({#seh#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg)\n  (ceh, w22, ce22') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>q ceh ce21' ce22' w21 w22.\n        \\<lbrakk>ch = {#[entry fg q]#} + ceh;\n         add_mset s2' ce2' = ce21' + ce22';\n         w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22;\n         mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {};\n         mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {};\n         ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg);\n         (ceh, w22, ce22') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1) CHFMT[of seh]"], ["proof (chain)\npicking this:\n  ch = {#seh#} + ceh\n  seh \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     seh = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "obtain q where \"seh=[entry fg q]\""], ["proof (prove)\nusing this:\n  ch = {#seh#} + ceh\n  seh \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     seh = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. (\\<And>q. seh = [entry fg q] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  seh = [entry fg q]\n\ngoal (1 subgoal):\n 1. (\\<And>q ceh ce21' ce22' w21 w22.\n        \\<lbrakk>ch = {#[entry fg q]#} + ceh;\n         add_mset s2' ce2' = ce21' + ce22';\n         w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22;\n         mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {};\n         mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {};\n         ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg);\n         (ceh, w22, ce22') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with *"], ["proof (chain)\npicking this:\n  ch = {#seh#} + ceh\n  {#s2'#} + ce2' = ce21' + ce22'\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg seh \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {}\n  mon_c fg ceh \\<inter> (mon_s fg seh \\<union> mon_ww fg w21) = {}\n  ({#seh#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg)\n  (ceh, w22, ce22') \\<in> trcl (ntr fg)\n  seh = [entry fg q]", "have \"ch={#[entry fg q]#}+ceh\" \"add_mset s2' ce2' = ce21'+ce22'\" \"w2\\<in>w21\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>w22\" \"mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22)={}\" \"mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {}\"\n        \"({#[entry fg q]#},w21,{#s1'#}+ce21')\\<in>trcl (ntr fg)\" \"(ceh,w22,ce22')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  ch = {#seh#} + ceh\n  {#s2'#} + ce2' = ce21' + ce22'\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg seh \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {}\n  mon_c fg ceh \\<inter> (mon_s fg seh \\<union> mon_ww fg w21) = {}\n  ({#seh#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg)\n  (ceh, w22, ce22') \\<in> trcl (ntr fg)\n  seh = [entry fg q]\n\ngoal (1 subgoal):\n 1. (ch = {#[entry fg q]#} + ceh &&&\n     add_mset s2' ce2' = ce21' + ce22' &&&\n     w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22) &&&\n    (mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {} &&&\n     mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {}) &&&\n    ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg) &&&\n    (ceh, w22, ce22') \\<in> trcl (ntr fg)", "by auto"], ["proof (state)\nthis:\n  ch = {#[entry fg q]#} + ceh\n  add_mset s2' ce2' = ce21' + ce22'\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {}\n  mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {}\n  ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg)\n  (ceh, w22, ce22') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>q ceh ce21' ce22' w21 w22.\n        \\<lbrakk>ch = {#[entry fg q]#} + ceh;\n         add_mset s2' ce2' = ce21' + ce22';\n         w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22;\n         mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {};\n         mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {};\n         ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg);\n         (ceh, w22, ce22') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  ch = {#[entry fg q]#} + ceh\n  add_mset s2' ce2' = ce21' + ce22'\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {}\n  mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {}\n  ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg)\n  (ceh, w22, ce22') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  ch = {#[entry fg q]#} + ceh\n  add_mset s2' ce2' = ce21' + ce22'\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {}\n  mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {}\n  ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg)\n  (ceh, w22, ce22') \\<in> trcl (ntr fg)\n  \\<lbrakk>ch = {#[entry fg ?q]#} + ?ceh;\n   add_mset s2' ce2' = ?ce21' + ?ce22';\n   w2 \\<in> ?w21.0 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> ?w22.0;\n   mon fg ?q \\<inter> (mon_c fg ?ceh \\<union> mon_ww fg ?w22.0) = {};\n   mon_c fg ?ceh \\<inter> (mon fg ?q \\<union> mon_ww fg ?w21.0) = {};\n   ({#[entry fg ?q]#}, ?w21.0, {#s1'#} + ?ce21') \\<in> trcl (ntr fg);\n   (?ceh, ?w22.0, ?ce22') \\<in> trcl (ntr fg)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (blast)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed\n        \\<comment> \\<open>For applying the induction hypothesis, it will be handy to have the reaching path in loc/env format:\\<close>"], ["proof (state)\nthis:\n  ch = {#[entry fg q]#} + ceh\n  add_mset s2' ce2' = ce21' + ce22'\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon fg q \\<inter> (mon_c fg ceh \\<union> mon_ww fg w22) = {}\n  mon_c fg ceh \\<inter> (mon fg q \\<union> mon_ww fg w21) = {}\n  ({#[entry fg q]#}, w21, {#s1'#} + ce21') \\<in> trcl (ntr fg)\n  (ceh, w22, ce22') \\<in> trcl (ntr fg)\n\ngoal (3 subgoals):\n 1. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from ntrs.gtr2gtrp[where c=\"{#}\", simplified, OF REVSPLIT(6)]"], ["proof (chain)\npicking this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>{#s1'#} + ce21' = add_mset s' ce'; w21 = map le_rem_s ww;\n       (([entry fg q], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain sq' csp_q ww21 where \n      R_CONV: \"add_mset s1' ce21' = add_mset sq' csp_q\" \"w21 = map le_rem_s ww21\" \"(([entry fg q], {#}), ww21, sq', csp_q) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>{#s1'#} + ce21' = add_mset s' ce'; w21 = map le_rem_s ww;\n       (([entry fg q], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>sq' csp_q ww21.\n        \\<lbrakk>add_mset s1' ce21' = add_mset sq' csp_q;\n         w21 = map le_rem_s ww21;\n         (([entry fg q], {#}), ww21, sq', csp_q)\n         \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  add_mset s1' ce21' = add_mset sq' csp_q\n  w21 = map le_rem_s ww21\n  (([entry fg q], {#}), ww21, sq', csp_q) \\<in> trcl (ntrp fg)\n\ngoal (3 subgoals):\n 1. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from cil_ileq[OF REVSPLIT(3)] mon_ww_ileq[of w21 w2 fg] mon_ww_ileq[of w22 w2 fg]"], ["proof (chain)\npicking this:\n  w21 \\<preceq> w2 \\<and> w22 \\<preceq> w2\n  w21 \\<preceq> w2 \\<Longrightarrow> mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  w22 \\<preceq> w2 \\<Longrightarrow> mon_ww fg w22 \\<subseteq> mon_ww fg w2", "have MON2N_LEQ: \"mon_ww fg w21 \\<subseteq> mon_ww fg w2\" \"mon_ww fg w22 \\<subseteq> mon_ww fg w2\""], ["proof (prove)\nusing this:\n  w21 \\<preceq> w2 \\<and> w22 \\<preceq> w2\n  w21 \\<preceq> w2 \\<Longrightarrow> mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  w22 \\<preceq> w2 \\<Longrightarrow> mon_ww fg w22 \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. mon_ww fg w21 \\<subseteq> mon_ww fg w2 &&&\n    mon_ww fg w22 \\<subseteq> mon_ww fg w2", "by auto"], ["proof (state)\nthis:\n  mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  mon_ww fg w22 \\<subseteq> mon_ww fg w2\n\ngoal (3 subgoals):\n 1. atUV U V c2' \\<Longrightarrow>\n    \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 3. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from REVSPLIT(2)"], ["proof (chain)\npicking this:\n  add_mset s2' ce2' = ce21' + ce22'", "show ?thesis"], ["proof (prove)\nusing this:\n  add_mset s2' ce2' = ce21' + ce22'\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)", "proof (cases rule: mset_unplusm_dist_cases[case_names left' right'])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "case left' \\<comment> \\<open>Both nodes are reached from the same thread\\<close>"], ["proof (state)\nthis:\n  ce21' = add_mset s2' (ce21' - {#s2'#})\n  ce2' = ce21' - {#s2'#} + ce22'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have ATUV: \"atUV U V ({#sq'#}+csp_q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atUV U V ({#sq'#} + csp_q)", "using right C2'FMT R_STACKS(2,3) left'(1)"], ["proof (prove)\nusing this:\n  atUV U V c2'\n  c2' = {#s1'#} + ({#s2'#} + ce2')\n  atU_s U s1'\n  atU_s V s2'\n  ce21' = add_mset s2' (ce21' - {#s2'#})\n\ngoal (1 subgoal):\n 1. atUV U V ({#sq'#} + csp_q)", "by (metis R_CONV(1) add_mset_add_single atUV_union atU_add_mset union_commute)"], ["proof (state)\nthis:\n  atUV U V ({#sq'#} + csp_q)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from Cons.hyps[OF _ R_CONV(3) ATUV] cil_length[OF REVSPLIT(3)] cil_length[OF LESPLIT(1)] R_CONV(2)"], ["proof (chain)\npicking this:\n  length ww21 \\<le> length ww \\<Longrightarrow>\n  \\<exists>Ml Me.\n     (entry fg q, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg ww21 \\<and> Me \\<subseteq> mon_env fg ww21\n  length w2 = length w21 + length w22\n  length ww = length w1 + length (map ENV w2)\n  w21 = map le_rem_s ww21", "obtain Ml Me where IHAPP: \"(entry fg q, Ml, Me) \\<in> RUV_cs fg U V\" \"Ml \\<subseteq> mon_loc fg ww21\" \"Me \\<subseteq> mon_env fg ww21\""], ["proof (prove)\nusing this:\n  length ww21 \\<le> length ww \\<Longrightarrow>\n  \\<exists>Ml Me.\n     (entry fg q, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg ww21 \\<and> Me \\<subseteq> mon_env fg ww21\n  length w2 = length w21 + length w22\n  length ww = length w1 + length (map ENV w2)\n  w21 = map le_rem_s ww21\n\ngoal (1 subgoal):\n 1. (\\<And>Ml Me.\n        \\<lbrakk>(entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n         Ml \\<subseteq> mon_loc fg ww21;\n         Me \\<subseteq> mon_env fg ww21\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (entry fg q, Ml, Me) \\<in> RUV_cs fg U V\n  Ml \\<subseteq> mon_loc fg ww21\n  Me \\<subseteq> mon_env fg ww21\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from REVSPLIT(1) S_ENTRY_PAT[of \"{#q#}\", simplified]"], ["proof (chain)\npicking this:\n  ch = {#[entry fg q]#} + ceh\n  [entry fg q] \\<in># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q#}) \\<in> S_cs fg (Suc 0)", "have S_ENTRY: \"(v, mon_w fg w, {#q#}) \\<in> S_cs fg 1\""], ["proof (prove)\nusing this:\n  ch = {#[entry fg q]#} + ceh\n  [entry fg q] \\<in># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q#}) \\<in> S_cs fg (Suc 0)\n\ngoal (1 subgoal):\n 1. (v, mon_w fg w, {#q#}) \\<in> S_cs fg 1", "by simp"], ["proof (state)\nthis:\n  (v, mon_w fg w, {#q#}) \\<in> S_cs fg 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have MON_COND: \"(mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "from R_CONV(2)"], ["proof (chain)\npicking this:\n  w21 = map le_rem_s ww21", "have \"mon_ww fg w21 = mon_loc fg ww21 \\<union> mon_env fg ww21\""], ["proof (prove)\nusing this:\n  w21 = map le_rem_s ww21\n\ngoal (1 subgoal):\n 1. mon_ww fg w21 = mon_loc fg ww21 \\<union> mon_env fg ww21", "by (simp add: mon_ww_of_le_rem)"], ["proof (state)\nthis:\n  mon_ww fg w21 = mon_loc fg ww21 \\<union> mon_env fg ww21\n\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "with IHAPP(2,3) MON2N_LEQ(1) MON_PU MON2_LEQ"], ["proof (chain)\npicking this:\n  Ml \\<subseteq> mon_loc fg ww21\n  Me \\<subseteq> mon_env fg ww21\n  mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  mon_ww fg w21 = mon_loc fg ww21 \\<union> mon_env fg ww21", "show ?thesis"], ["proof (prove)\nusing this:\n  Ml \\<subseteq> mon_loc fg ww21\n  Me \\<subseteq> mon_env fg ww21\n  mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  mon_ww fg w21 = mon_loc fg ww21 \\<union> mon_env fg ww21\n\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "by blast"], ["proof (state)\nthis:\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from RUV_spawn[OF FS_FMT(2) FS_FMT(4) S_ENTRY _ IHAPP(1) MON_COND]"], ["proof (chain)\npicking this:\n  q \\<in># {#q#} \\<Longrightarrow>\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me) \\<in> RUV_cs fg U V", "have \"(u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me) \\<in> RUV_cs fg U V\""], ["proof (prove)\nusing this:\n  q \\<in># {#q#} \\<Longrightarrow>\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me) \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me) \\<in> RUV_cs fg U V", "by simp"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me) \\<in> RUV_cs fg U V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me) \\<in> RUV_cs fg U V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee#ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)", "using FS_FMT(1)"], ["proof (prove)\nusing this:\n  ee = LOC (LCall p # w)\n\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)", "by auto"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"Ml \\<union> Me \\<subseteq> mon_env fg (ee#ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg (ee # ww)", "using IHAPP(2,3) R_CONV(2) MON2N_LEQ(1) MON2_LEQ"], ["proof (prove)\nusing this:\n  Ml \\<subseteq> mon_loc fg ww21\n  Me \\<subseteq> mon_env fg ww21\n  w21 = map le_rem_s ww21\n  mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<subseteq> mon_env fg (ee # ww)", "by (auto simp add: mon_ww_of_le_rem)"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce21' = add_mset s2' (ce21' - {#s2'#});\n     ce2' = ce21' - {#s2'#} + ce22'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "ultimately"], ["proof (chain)\npicking this:\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me) \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)\n  Ml \\<union> Me \\<subseteq> mon_env fg (ee # ww)", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me) \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)\n  Ml \\<union> Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ml Me.\n     (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n     Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "(* TODO: Clean up monitor arguments *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "case right' \\<comment> \\<open>The nodes are reached from different threads\\<close>"], ["proof (state)\nthis:\n  ce22' = add_mset s2' (ce22' - {#s2'#})\n  ce2' = ce21' + (ce22' - {#s2'#})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from R_STACKS(2,3)"], ["proof (chain)\npicking this:\n  atU_s U s1'\n  atU_s V s2'", "have ATUV: \"atU U (add_mset sq' csp_q)\" \"atU V ce22'\""], ["proof (prove)\nusing this:\n  atU_s U s1'\n  atU_s V s2'\n\ngoal (1 subgoal):\n 1. atU U (add_mset sq' csp_q) &&& atU V ce22'", "by (-) (subst R_CONV(1)[symmetric], simp, subst right'(1), simp)\n      \\<comment> \\<open>We have to reverse-split the second path again, to extract the second interesting thread\\<close>"], ["proof (state)\nthis:\n  atU U (add_mset sq' csp_q)\n  atU V ce22'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "obtain q' w22' ce22e' where REVSPLIT': \"[entry fg q'] \\<in># ceh\" \"w22'\\<preceq>w22\" \"ce22e' \\<subseteq># ce22'\" \"atU V ce22e'\" \"({#[entry fg q']#},w22',ce22e')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q' w22' ce22e'.\n        \\<lbrakk>[entry fg q'] \\<in># ceh; w22' \\<preceq> w22;\n         ce22e' \\<subseteq># ce22'; atU V ce22e';\n         ({#[entry fg q']#}, w22', ce22e') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q' w22' ce22e'.\n        \\<lbrakk>[entry fg q'] \\<in># ceh; w22' \\<preceq> w22;\n         ce22e' \\<subseteq># ce22'; atU V ce22e';\n         ({#[entry fg q']#}, w22', ce22e') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ntr_reverse_split_atU[OF _ ATUV(2) REVSPLIT(7)] ntrp_valid_preserve_s[OF SPLIT(1), simplified] REVSPLIT(1)"], ["proof (chain)\npicking this:\n  valid fg ceh \\<Longrightarrow>\n  \\<exists>s w' c1'.\n     s \\<in># ceh \\<and>\n     w' \\<preceq> w22 \\<and>\n     c1' \\<subseteq># ce22' \\<and>\n     atU V c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)\n  valid fg (add_mset sh ch)\n  ch = {#[entry fg q]#} + ceh", "obtain sq'' w22' ce22e' where \n          *: \"sq'' \\<in># ceh\" \"w22'\\<preceq>w22\" \"ce22e' \\<subseteq># ce22'\" \"atU V ce22e'\" \"({#sq''#},w22',ce22e')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  valid fg ceh \\<Longrightarrow>\n  \\<exists>s w' c1'.\n     s \\<in># ceh \\<and>\n     w' \\<preceq> w22 \\<and>\n     c1' \\<subseteq># ce22' \\<and>\n     atU V c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)\n  valid fg (add_mset sh ch)\n  ch = {#[entry fg q]#} + ceh\n\ngoal (1 subgoal):\n 1. (\\<And>sq'' w22' ce22e'.\n        \\<lbrakk>sq'' \\<in># ceh; w22' \\<preceq> w22;\n         ce22e' \\<subseteq># ce22'; atU V ce22e';\n         ({#sq''#}, w22', ce22e') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: valid_unconc)"], ["proof (state)\nthis:\n  sq'' \\<in># ceh\n  w22' \\<preceq> w22\n  ce22e' \\<subseteq># ce22'\n  atU V ce22e'\n  ({#sq''#}, w22', ce22e') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>q' w22' ce22e'.\n        \\<lbrakk>[entry fg q'] \\<in># ceh; w22' \\<preceq> w22;\n         ce22e' \\<subseteq># ce22'; atU V ce22e';\n         ({#[entry fg q']#}, w22', ce22e') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from CHFMT[of sq''] REVSPLIT(1) this(1)"], ["proof (chain)\npicking this:\n  sq'' \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     sq'' = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  ch = {#[entry fg q]#} + ceh\n  sq'' \\<in># ceh", "obtain q' where \"sq''=[entry fg q']\""], ["proof (prove)\nusing this:\n  sq'' \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     sq'' = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  ch = {#[entry fg q]#} + ceh\n  sq'' \\<in># ceh\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        sq'' = [entry fg q'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sq'' = [entry fg q']\n\ngoal (1 subgoal):\n 1. (\\<And>q' w22' ce22e'.\n        \\<lbrakk>[entry fg q'] \\<in># ceh; w22' \\<preceq> w22;\n         ce22e' \\<subseteq># ce22'; atU V ce22e';\n         ({#[entry fg q']#}, w22', ce22e') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with *"], ["proof (chain)\npicking this:\n  sq'' \\<in># ceh\n  w22' \\<preceq> w22\n  ce22e' \\<subseteq># ce22'\n  atU V ce22e'\n  ({#sq''#}, w22', ce22e') \\<in> trcl (ntr fg)\n  sq'' = [entry fg q']", "show thesis"], ["proof (prove)\nusing this:\n  sq'' \\<in># ceh\n  w22' \\<preceq> w22\n  ce22e' \\<subseteq># ce22'\n  atU V ce22e'\n  ({#sq''#}, w22', ce22e') \\<in> trcl (ntr fg)\n  sq'' = [entry fg q']\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  sq'' \\<in># ceh\n  w22' \\<preceq> w22\n  ce22e' \\<subseteq># ce22'\n  atU V ce22e'\n  ({#sq''#}, w22', ce22e') \\<in> trcl (ntr fg)\n  sq'' = [entry fg q']\n  \\<lbrakk>[entry fg ?q'] \\<in># ceh; ?w22' \\<preceq> w22;\n   ?ce22e' \\<subseteq># ce22'; atU V ?ce22e';\n   ({#[entry fg ?q']#}, ?w22', ?ce22e') \\<in> trcl (ntr fg)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [entry fg q'] \\<in># ceh\n  w22' \\<preceq> w22\n  ce22e' \\<subseteq># ce22'\n  atU V ce22e'\n  ({#[entry fg q']#}, w22', ce22e') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from ntrs.gtr2gtrp[where c=\"{#}\", simplified, OF REVSPLIT'(5)]"], ["proof (chain)\npicking this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>ce22e' = add_mset s' ce'; w22' = map le_rem_s ww;\n       (([entry fg q'], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain sq'' ce22ee' ww22' where R_CONV': \"ce22e' = add_mset sq'' ce22ee'\" \"w22'=map le_rem_s ww22'\" \"(([entry fg q'],{#}),ww22',(sq'',ce22ee'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>ce22e' = add_mset s' ce'; w22' = map le_rem_s ww;\n       (([entry fg q'], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>sq'' ce22ee' ww22'.\n        \\<lbrakk>ce22e' = add_mset sq'' ce22ee'; w22' = map le_rem_s ww22';\n         (([entry fg q'], {#}), ww22', sq'', ce22ee')\n         \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n      \\<comment> \\<open>From the soundness of the RU-constraint system, we get the corresponding entries\\<close>"], ["proof (state)\nthis:\n  ce22e' = add_mset sq'' ce22ee'\n  w22' = map le_rem_s ww22'\n  (([entry fg q'], {#}), ww22', sq'', ce22ee') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from RU_sound[OF R_CONV(3) ATUV(1)]"], ["proof (chain)\npicking this:\n  \\<exists>Ml Me h.\n     (entry fg q, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg ww21 \\<and>\n     Me \\<subseteq> mon_env fg ww21 \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww21)", "obtain Ml Me h where RU: \"(entry fg q, Ml, Me, h) \\<in> RU_cs fg U\" \"Ml \\<subseteq> mon_loc fg ww21\" \"Me \\<subseteq> mon_env fg ww21\" \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww21)\""], ["proof (prove)\nusing this:\n  \\<exists>Ml Me h.\n     (entry fg q, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg ww21 \\<and>\n     Me \\<subseteq> mon_env fg ww21 \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww21)\n\ngoal (1 subgoal):\n 1. (\\<And>Ml Me h.\n        \\<lbrakk>(entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n         Ml \\<subseteq> mon_loc fg ww21; Me \\<subseteq> mon_env fg ww21;\n         h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww21)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (entry fg q, Ml, Me, h) \\<in> RU_cs fg U\n  Ml \\<subseteq> mon_loc fg ww21\n  Me \\<subseteq> mon_env fg ww21\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww21)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from RU_sound[OF R_CONV'(3), of V] REVSPLIT'(4) R_CONV'(1)"], ["proof (chain)\npicking this:\n  atU V (add_mset sq'' ce22ee') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (entry fg q', Ml, Me, h) \\<in> RU_cs fg V \\<and>\n     Ml \\<subseteq> mon_loc fg ww22' \\<and>\n     Me \\<subseteq> mon_env fg ww22' \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww22')\n  atU V ce22e'\n  ce22e' = add_mset sq'' ce22ee'", "obtain Ml' Me' h' where RV: \"(entry fg q', Ml', Me', h') \\<in> RU_cs fg V\" \"Ml' \\<subseteq> mon_loc fg ww22'\" \"Me' \\<subseteq> mon_env fg ww22'\" \"h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww22')\""], ["proof (prove)\nusing this:\n  atU V (add_mset sq'' ce22ee') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (entry fg q', Ml, Me, h) \\<in> RU_cs fg V \\<and>\n     Ml \\<subseteq> mon_loc fg ww22' \\<and>\n     Me \\<subseteq> mon_env fg ww22' \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww22')\n  atU V ce22e'\n  ce22e' = add_mset sq'' ce22ee'\n\ngoal (1 subgoal):\n 1. (\\<And>Ml' Me' h'.\n        \\<lbrakk>(entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_loc fg ww22'; Me' \\<subseteq> mon_env fg ww22';\n         h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww22')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg V\n  Ml' \\<subseteq> mon_loc fg ww22'\n  Me' \\<subseteq> mon_env fg ww22'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww22')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from S_ENTRY_PAT[of \"{#q#}+{#q'#}\", simplified] REVSPLIT(1) REVSPLIT'(1)"], ["proof (chain)\npicking this:\n  {#[entry fg q'], [entry fg q]#} \\<subseteq># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q', q#}) \\<in> S_cs fg (Suc (Suc 0))\n  ch = {#[entry fg q]#} + ceh\n  [entry fg q'] \\<in># ceh", "have S_ENTRY: \"(v, mon_w fg w, {#q#} + {#q'#}) \\<in> S_cs fg (2::nat)\""], ["proof (prove)\nusing this:\n  {#[entry fg q'], [entry fg q]#} \\<subseteq># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q', q#}) \\<in> S_cs fg (Suc (Suc 0))\n  ch = {#[entry fg q]#} + ceh\n  [entry fg q'] \\<in># ceh\n\ngoal (1 subgoal):\n 1. (v, mon_w fg w, {#q#} + {#q'#}) \\<in> S_cs fg 2", "by (simp add: numerals)"], ["proof (state)\nthis:\n  (v, mon_w fg w, {#q#} + {#q'#}) \\<in> S_cs fg 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"(u, mon fg p \\<union> mon_w fg w, Ml \\<union> Me \\<union> Ml' \\<union> Me') \\<in> RUV_cs fg U V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, mon fg p \\<union> mon_w fg w,\n     Ml \\<union> Me \\<union> Ml' \\<union> Me')\n    \\<in> RUV_cs fg U V", "proof (rule RUV_split_ee[OF FS_FMT(2,4) S_ENTRY _ RU(1) RV(1)])"], ["proof (state)\ngoal (3 subgoals):\n 1. {#q#} + {#q'#} \\<subseteq># {#q#} + {#q'#}\n 2. (mon_n fg u \\<union> mon fg p) \\<inter>\n    (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n    {}\n 3. h [*] h'", "from MON_PU MON2_LEQ MON2N_LEQ R_CONV(2) R_CONV'(2) mon_ww_ileq[OF REVSPLIT'(2), of fg] RU(2,3) RV(2,3)"], ["proof (chain)\npicking this:\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  mon_ww fg w22 \\<subseteq> mon_ww fg w2\n  w21 = map le_rem_s ww21\n  w22' = map le_rem_s ww22'\n  mon_ww fg w22' \\<subseteq> mon_ww fg w22\n  Ml \\<subseteq> mon_loc fg ww21\n  Me \\<subseteq> mon_env fg ww21\n  Ml' \\<subseteq> mon_loc fg ww22'\n  Me' \\<subseteq> mon_env fg ww22'", "show \"(mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me \\<union> Ml' \\<union> Me') = {}\""], ["proof (prove)\nusing this:\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  mon_ww fg w22 \\<subseteq> mon_ww fg w2\n  w21 = map le_rem_s ww21\n  w22' = map le_rem_s ww22'\n  mon_ww fg w22' \\<subseteq> mon_ww fg w22\n  Ml \\<subseteq> mon_loc fg ww21\n  Me \\<subseteq> mon_env fg ww21\n  Ml' \\<subseteq> mon_loc fg ww22'\n  Me' \\<subseteq> mon_env fg ww22'\n\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter>\n    (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n    {}", "by (simp add: mon_ww_of_le_rem) blast"], ["proof (state)\nthis:\n  (mon_n fg u \\<union> mon fg p) \\<inter>\n  (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n  {}\n\ngoal (2 subgoals):\n 1. {#q#} + {#q'#} \\<subseteq># {#q#} + {#q'#}\n 2. h [*] h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {#q#} + {#q'#} \\<subseteq># {#q#} + {#q'#}\n 2. h [*] h'", "from ah_interleavable1[OF REVSPLIT(3)]"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>n fg) w21) [*]\n  \\<alpha>ah (map (\\<alpha>n fg) w22)", "have \"\\<alpha>ah (map (\\<alpha>n fg) w21) [*] \\<alpha>ah (map (\\<alpha>n fg) w22)\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>n fg) w21) [*]\n  \\<alpha>ah (map (\\<alpha>n fg) w22)\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>n fg) w21) [*]\n    \\<alpha>ah (map (\\<alpha>n fg) w22)", "."], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>n fg) w21) [*]\n  \\<alpha>ah (map (\\<alpha>n fg) w22)\n\ngoal (2 subgoals):\n 1. {#q#} + {#q'#} \\<subseteq># {#q#} + {#q'#}\n 2. h [*] h'", "thus \"h [*] h'\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>n fg) w21) [*]\n  \\<alpha>ah (map (\\<alpha>n fg) w22)\n\ngoal (1 subgoal):\n 1. h [*] h'", "proof (erule_tac ah_leq_il)"], ["proof (state)\ngoal (2 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\n 2. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "note RU(4)"], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww21)\n\ngoal (2 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\n 2. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "also"], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww21)\n\ngoal (2 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\n 2. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "have \"map (\\<alpha>nl fg) ww21 \\<preceq> map (\\<alpha>n fg) w21\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) ww21 \\<preceq> map (\\<alpha>n fg) w21", "using R_CONV(2)"], ["proof (prove)\nusing this:\n  w21 = map le_rem_s ww21\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) ww21 \\<preceq> map (\\<alpha>n fg) w21", "by (simp add: \\<alpha>n_\\<alpha>nl)"], ["proof (state)\nthis:\n  map (\\<alpha>nl fg) ww21 \\<preceq> map (\\<alpha>n fg) w21\n\ngoal (2 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\n 2. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "hence \"\\<alpha>ah (map (\\<alpha>nl fg) ww21) \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\""], ["proof (prove)\nusing this:\n  map (\\<alpha>nl fg) ww21 \\<preceq> map (\\<alpha>n fg) w21\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) ww21)\n    \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)", "by (rule \\<alpha>ah_ileq)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww21)\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\n\ngoal (2 subgoals):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\n 2. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "finally"], ["proof (chain)\npicking this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)", "show \"h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\""], ["proof (prove)\nusing this:\n  h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\n\ngoal (1 subgoal):\n 1. h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)", "."], ["proof (state)\nthis:\n  h \\<le> \\<alpha>ah (map (\\<alpha>n fg) w21)\n\ngoal (1 subgoal):\n 1. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "note RV(4)"], ["proof (state)\nthis:\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww22')\n\ngoal (1 subgoal):\n 1. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "also"], ["proof (state)\nthis:\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww22')\n\ngoal (1 subgoal):\n 1. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "have \"map (\\<alpha>nl fg) ww22' \\<preceq> map (\\<alpha>n fg) w22\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) ww22' \\<preceq> map (\\<alpha>n fg) w22", "using R_CONV'(2) REVSPLIT'(2)"], ["proof (prove)\nusing this:\n  w22' = map le_rem_s ww22'\n  w22' \\<preceq> w22\n\ngoal (1 subgoal):\n 1. map (\\<alpha>nl fg) ww22' \\<preceq> map (\\<alpha>n fg) w22", "by (simp add: \\<alpha>n_\\<alpha>nl[symmetric] le_list_map map_map[symmetric] del: map_map)"], ["proof (state)\nthis:\n  map (\\<alpha>nl fg) ww22' \\<preceq> map (\\<alpha>n fg) w22\n\ngoal (1 subgoal):\n 1. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "hence \"\\<alpha>ah (map (\\<alpha>nl fg) ww22') \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)\""], ["proof (prove)\nusing this:\n  map (\\<alpha>nl fg) ww22' \\<preceq> map (\\<alpha>n fg) w22\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) ww22')\n    \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "by (rule \\<alpha>ah_ileq)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww22')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)\n\ngoal (1 subgoal):\n 1. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "finally"], ["proof (chain)\npicking this:\n  h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "show \"h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)\""], ["proof (prove)\nusing this:\n  h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)\n\ngoal (1 subgoal):\n 1. h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)", "."], ["proof (state)\nthis:\n  h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w22)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h [*] h'\n\ngoal (1 subgoal):\n 1. {#q#} + {#q'#} \\<subseteq># {#q#} + {#q'#}", "qed (simp)"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w,\n   Ml \\<union> Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w,\n   Ml \\<union> Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee#ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)", "using FS_FMT(1)"], ["proof (prove)\nusing this:\n  ee = LOC (LCall p # w)\n\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)", "by auto"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"Ml \\<union> Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee#ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<union> Ml' \\<union> Me'\n    \\<subseteq> mon_env fg (ee # ww)", "using RV(2,3) RU(2,3) mon_ww_ileq[OF REVSPLIT'(2), of fg] MON2N_LEQ R_CONV(2) R_CONV'(2) MON2_LEQ"], ["proof (prove)\nusing this:\n  Ml' \\<subseteq> mon_loc fg ww22'\n  Me' \\<subseteq> mon_env fg ww22'\n  Ml \\<subseteq> mon_loc fg ww21\n  Me \\<subseteq> mon_env fg ww21\n  mon_ww fg w22' \\<subseteq> mon_ww fg w22\n  mon_ww fg w21 \\<subseteq> mon_ww fg w2\n  mon_ww fg w22 \\<subseteq> mon_ww fg w2\n  w21 = map le_rem_s ww21\n  w22' = map le_rem_s ww22'\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n\ngoal (1 subgoal):\n 1. Ml \\<union> Me \\<union> Ml' \\<union> Me'\n    \\<subseteq> mon_env fg (ee # ww)", "by (simp add: mon_ww_of_le_rem) blast"], ["proof (state)\nthis:\n  Ml \\<union> Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce22' = add_mset s2' (ce22' - {#s2'#});\n     ce2' = ce21' + (ce22' - {#s2'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "ultimately"], ["proof (chain)\npicking this:\n  (u, mon fg p \\<union> mon_w fg w,\n   Ml \\<union> Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)\n  Ml \\<union> Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, mon fg p \\<union> mon_w fg w,\n   Ml \\<union> Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<subseteq> mon_loc fg (ee # ww)\n  Ml \\<union> Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ml Me.\n     (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n     Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Ml Me.\n     (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n     Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "case lr \\<comment> \\<open>The first node is reached from the local thread, the second one from a spawned thread\\<close>"], ["proof (state)\nthis:\n  atU U ({#s'#} + c1')\n  atU V c2'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from RU_sound[OF DECOMP_LOC(2), of U] lr(1) DECOMP_LOC(1)"], ["proof (chain)\npicking this:\n  atU U (add_mset (v' # rr) c1') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (v, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg w1 \\<and>\n     Me \\<subseteq> mon_env fg w1 \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n  atU U ({#s'#} + c1')\n  s' = v' # rr @ [u']", "obtain Ml Me h where RU: \"(v, Ml, Me, h) \\<in> RU_cs fg U\" \"Ml \\<subseteq> mon_loc fg w1\" \"Me \\<subseteq> mon_env fg w1\" \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\""], ["proof (prove)\nusing this:\n  atU U (add_mset (v' # rr) c1') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (v, Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg w1 \\<and>\n     Me \\<subseteq> mon_env fg w1 \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n  atU U ({#s'#} + c1')\n  s' = v' # rr @ [u']\n\ngoal (1 subgoal):\n 1. (\\<And>Ml Me h.\n        \\<lbrakk>(v, Ml, Me, h) \\<in> RU_cs fg U;\n         Ml \\<subseteq> mon_loc fg w1; Me \\<subseteq> mon_env fg w1;\n         h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, Ml, Me, h) \\<in> RU_cs fg U\n  Ml \\<subseteq> mon_loc fg w1\n  Me \\<subseteq> mon_env fg w1\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "obtain Ml' Me' h' q' where RV: \"[entry fg q'] \\<in># ch\" \"(entry fg q', Ml', Me', h') \\<in> RU_cs fg V\" \"Ml' \\<subseteq> mon_ww fg w2\" \"Me' \\<subseteq> mon_ww fg w2\" \"h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -\n      \\<comment> \\<open>We have to extract the interesting thread from the spawned threads in order to get an entry in @{term \"RU fg V\"}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain q' w2' c2i' where REVSPLIT: \"[entry fg q'] \\<in># ch\" \"w2'\\<preceq>w2\" \"c2i' \\<subseteq># c2'\" \"atU V c2i'\" \"({#[entry fg q']#},w2',c2i')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q' w2' c2i'.\n        \\<lbrakk>[entry fg q'] \\<in># ch; w2' \\<preceq> w2;\n         c2i' \\<subseteq># c2'; atU V c2i';\n         ({#[entry fg q']#}, w2', c2i') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ntr_reverse_split_atU[OF _ lr(2) LESPLIT(4)] ntrp_valid_preserve_s[OF SPLIT(1), simplified] CHFMT"], ["proof (prove)\nusing this:\n  valid fg ch \\<Longrightarrow>\n  \\<exists>s w' c1'.\n     s \\<in># ch \\<and>\n     w' \\<preceq> w2 \\<and>\n     c1' \\<subseteq># c2' \\<and>\n     atU V c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)\n  valid fg (add_mset sh ch)\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. (\\<And>q' w2' c2i'.\n        \\<lbrakk>[entry fg q'] \\<in># ch; w2' \\<preceq> w2;\n         c2i' \\<subseteq># c2'; atU V c2i';\n         ({#[entry fg q']#}, w2', c2i') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: valid_unconc) blast"], ["proof (state)\nthis:\n  [entry fg q'] \\<in># ch\n  w2' \\<preceq> w2\n  c2i' \\<subseteq># c2'\n  atU V c2i'\n  ({#[entry fg q']#}, w2', c2i') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ntrs.gtr2gtrp[where c=\"{#}\", simplified, OF REVSPLIT(5)]"], ["proof (chain)\npicking this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>c2i' = add_mset s' ce'; w2' = map le_rem_s ww;\n       (([entry fg q'], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain s2i' c2ie' ww2' where R_CONV: \"c2i'=add_mset s2i' c2ie'\" \"w2'=map le_rem_s ww2'\" \"(([entry fg q'], {#}), ww2', s2i', c2ie') \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>c2i' = add_mset s' ce'; w2' = map le_rem_s ww;\n       (([entry fg q'], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>s2i' c2ie' ww2'.\n        \\<lbrakk>c2i' = add_mset s2i' c2ie'; w2' = map le_rem_s ww2';\n         (([entry fg q'], {#}), ww2', s2i', c2ie')\n         \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  c2i' = add_mset s2i' c2ie'\n  w2' = map le_rem_s ww2'\n  (([entry fg q'], {#}), ww2', s2i', c2ie') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from RU_sound[OF R_CONV(3), of V] REVSPLIT(4) R_CONV(1)"], ["proof (chain)\npicking this:\n  atU V (add_mset s2i' c2ie') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (entry fg q', Ml, Me, h) \\<in> RU_cs fg V \\<and>\n     Ml \\<subseteq> mon_loc fg ww2' \\<and>\n     Me \\<subseteq> mon_env fg ww2' \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  atU V c2i'\n  c2i' = add_mset s2i' c2ie'", "obtain Ml' Me' h' where RV: \"(entry fg q', Ml', Me', h') \\<in> RU_cs fg V\" \"Ml' \\<subseteq> mon_loc fg ww2'\" \"Me' \\<subseteq> mon_env fg ww2'\" \"h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\""], ["proof (prove)\nusing this:\n  atU V (add_mset s2i' c2ie') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (entry fg q', Ml, Me, h) \\<in> RU_cs fg V \\<and>\n     Ml \\<subseteq> mon_loc fg ww2' \\<and>\n     Me \\<subseteq> mon_env fg ww2' \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  atU V c2i'\n  c2i' = add_mset s2i' c2ie'\n\ngoal (1 subgoal):\n 1. (\\<And>Ml' Me' h'.\n        \\<lbrakk>(entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_loc fg ww2'; Me' \\<subseteq> mon_env fg ww2';\n         h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg V\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg V\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"mon_loc fg ww2' \\<subseteq> mon_ww fg w2\" \"mon_env fg ww2' \\<subseteq> mon_ww fg w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg ww2' \\<subseteq> mon_ww fg w2 &&&\n    mon_env fg ww2' \\<subseteq> mon_ww fg w2", "using mon_ww_ileq[OF REVSPLIT(2), of fg] R_CONV(2)"], ["proof (prove)\nusing this:\n  mon_ww fg w2' \\<subseteq> mon_ww fg w2\n  w2' = map le_rem_s ww2'\n\ngoal (1 subgoal):\n 1. mon_loc fg ww2' \\<subseteq> mon_ww fg w2 &&&\n    mon_env fg ww2' \\<subseteq> mon_ww fg w2", "by (auto simp add: mon_ww_of_le_rem)"], ["proof (state)\nthis:\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<alpha>ah (map (\\<alpha>nl fg) ww2') \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n    \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)", "using REVSPLIT(2) R_CONV(2)"], ["proof (prove)\nusing this:\n  w2' \\<preceq> w2\n  w2' = map le_rem_s ww2'\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n    \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)", "by (auto simp add: \\<alpha>n_\\<alpha>nl[symmetric] le_list_map map_map[symmetric] simp del: map_map intro: \\<alpha>ah_ileq del: predicate2I)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg V\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)", "show thesis"], ["proof (prove)\nusing this:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg V\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. thesis", "using that REVSPLIT(1)"], ["proof (prove)\nusing this:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg V\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n  \\<lbrakk>[entry fg ?q'] \\<in># ch;\n   (entry fg ?q', ?Ml', ?Me', ?h') \\<in> RU_cs fg V;\n   ?Ml' \\<subseteq> mon_ww fg w2; ?Me' \\<subseteq> mon_ww fg w2;\n   ?h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  [entry fg q'] \\<in># ch\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro: order_trans)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [entry fg q'] \\<in># ch\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg V\n  Ml' \\<subseteq> mon_ww fg w2\n  Me' \\<subseteq> mon_ww fg w2\n  h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from S_ENTRY_PAT[of \"{#q'#}\", simplified] RV(1)"], ["proof (chain)\npicking this:\n  [entry fg q'] \\<in># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q'#}) \\<in> S_cs fg (Suc 0)\n  [entry fg q'] \\<in># ch", "have S_ENTRY: \"(v, mon_w fg w, {#q'#}) \\<in> S_cs fg 1\""], ["proof (prove)\nusing this:\n  [entry fg q'] \\<in># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q'#}) \\<in> S_cs fg (Suc 0)\n  [entry fg q'] \\<in># ch\n\ngoal (1 subgoal):\n 1. (v, mon_w fg w, {#q'#}) \\<in> S_cs fg 1", "by simp"], ["proof (state)\nthis:\n  (v, mon_w fg w, {#q'#}) \\<in> S_cs fg 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"(u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me \\<union> Ml' \\<union> Me') \\<in> RUV_cs fg U V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n     Me \\<union> Ml' \\<union> Me')\n    \\<in> RUV_cs fg U V", "proof (rule RUV_split_le[OF FS_FMT(2,4) S_ENTRY _ RU(1) RV(2)])"], ["proof (state)\ngoal (3 subgoals):\n 1. q' \\<in># {#q'#}\n 2. (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n    {}\n 3. h [*] h'", "from MON_PU MON1_LEQ MON2_LEQ RU(3) RV(3,4)"], ["proof (chain)\npicking this:\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  Me \\<subseteq> mon_env fg w1\n  Ml' \\<subseteq> mon_ww fg w2\n  Me' \\<subseteq> mon_ww fg w2", "show \"(mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') = {}\""], ["proof (prove)\nusing this:\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  Me \\<subseteq> mon_env fg w1\n  Ml' \\<subseteq> mon_ww fg w2\n  Me' \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n    {}", "by blast"], ["proof (state)\nthis:\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n  {}\n\ngoal (2 subgoals):\n 1. q' \\<in># {#q'#}\n 2. h [*] h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. q' \\<in># {#q'#}\n 2. h [*] h'", "from ah_interleavable1[OF LESPLIT(1)]"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*]\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV w2))", "have \"\\<alpha>ah (map (\\<alpha>nl fg) w1) [*] \\<alpha>ah (map (\\<alpha>n fg) w2)\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*]\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV w2))\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) w1) [*]\n    \\<alpha>ah (map (\\<alpha>n fg) w2)", "by simp"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*] \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (2 subgoals):\n 1. q' \\<in># {#q'#}\n 2. h [*] h'", "thus \"h [*] h'\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*] \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. h [*] h'", "using RU(4) RV(5)"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*] \\<alpha>ah (map (\\<alpha>n fg) w2)\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n  h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. h [*] h'", "by (auto elim: ah_leq_il)"], ["proof (state)\nthis:\n  h [*] h'\n\ngoal (1 subgoal):\n 1. q' \\<in># {#q'#}", "qed (simp)"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n   Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n   Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<union> Ml\n    \\<subseteq> mon_loc fg (ee # ww)", "using FS_FMT(1) MON1_LEQ RU(2)"], ["proof (prove)\nusing this:\n  ee = LOC (LCall p # w)\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n  Ml \\<subseteq> mon_loc fg w1\n\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<union> Ml\n    \\<subseteq> mon_loc fg (ee # ww)", "by (simp) blast"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)", "using MON1_LEQ MON2_LEQ RU(3) RV(3,4)"], ["proof (prove)\nusing this:\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  Me \\<subseteq> mon_env fg w1\n  Ml' \\<subseteq> mon_ww fg w2\n  Me' \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)", "by (simp) blast"], ["proof (state)\nthis:\n  Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atU U ({#s'#} + c1'); atU V c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)\n 2. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "ultimately"], ["proof (chain)\npicking this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n   Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n  Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n   Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n  Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ml Me.\n     (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n     Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "case rl \\<comment> \\<open>The second node is reached from the local thread, the first one from a spawned thread. This case is symmetric to the previous one\\<close>"], ["proof (state)\nthis:\n  atU V ({#s'#} + c1')\n  atU U c2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from RU_sound[OF DECOMP_LOC(2), of V] rl(1) DECOMP_LOC(1)"], ["proof (chain)\npicking this:\n  atU V (add_mset (v' # rr) c1') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (v, Ml, Me, h) \\<in> RU_cs fg V \\<and>\n     Ml \\<subseteq> mon_loc fg w1 \\<and>\n     Me \\<subseteq> mon_env fg w1 \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n  atU V ({#s'#} + c1')\n  s' = v' # rr @ [u']", "obtain Ml Me h where RV: \"(v, Ml, Me, h) \\<in> RU_cs fg V\" \"Ml \\<subseteq> mon_loc fg w1\" \"Me \\<subseteq> mon_env fg w1\" \"h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\""], ["proof (prove)\nusing this:\n  atU V (add_mset (v' # rr) c1') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (v, Ml, Me, h) \\<in> RU_cs fg V \\<and>\n     Ml \\<subseteq> mon_loc fg w1 \\<and>\n     Me \\<subseteq> mon_env fg w1 \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n  atU V ({#s'#} + c1')\n  s' = v' # rr @ [u']\n\ngoal (1 subgoal):\n 1. (\\<And>Ml Me h.\n        \\<lbrakk>(v, Ml, Me, h) \\<in> RU_cs fg V;\n         Ml \\<subseteq> mon_loc fg w1; Me \\<subseteq> mon_env fg w1;\n         h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, Ml, Me, h) \\<in> RU_cs fg V\n  Ml \\<subseteq> mon_loc fg w1\n  Me \\<subseteq> mon_env fg w1\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "obtain Ml' Me' h' q' where RU: \"[entry fg q'] \\<in># ch\" \"(entry fg q', Ml', Me', h') \\<in> RU_cs fg U\" \"Ml' \\<subseteq> mon_ww fg w2\" \"Me' \\<subseteq> mon_ww fg w2\" \"h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -\n      \\<comment> \\<open>We have to extract the interesting thread from the spawned threads in order to get an entry in @{term \"RU fg V\"}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain q' w2' c2i' where REVSPLIT: \"[entry fg q'] \\<in># ch\" \"w2'\\<preceq>w2\" \"c2i' \\<subseteq># c2'\" \"atU U c2i'\" \"({#[entry fg q']#},w2',c2i')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q' w2' c2i'.\n        \\<lbrakk>[entry fg q'] \\<in># ch; w2' \\<preceq> w2;\n         c2i' \\<subseteq># c2'; atU U c2i';\n         ({#[entry fg q']#}, w2', c2i') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ntr_reverse_split_atU[OF _ rl(2) LESPLIT(4)] ntrp_valid_preserve_s[OF SPLIT(1), simplified] CHFMT"], ["proof (prove)\nusing this:\n  valid fg ch \\<Longrightarrow>\n  \\<exists>s w' c1'.\n     s \\<in># ch \\<and>\n     w' \\<preceq> w2 \\<and>\n     c1' \\<subseteq># c2' \\<and>\n     atU U c1' \\<and> ({#s#}, w', c1') \\<in> trcl (ntr fg)\n  valid fg (add_mset sh ch)\n  ?s \\<in># ch \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. (\\<And>q' w2' c2i'.\n        \\<lbrakk>[entry fg q'] \\<in># ch; w2' \\<preceq> w2;\n         c2i' \\<subseteq># c2'; atU U c2i';\n         ({#[entry fg q']#}, w2', c2i') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: valid_unconc) blast"], ["proof (state)\nthis:\n  [entry fg q'] \\<in># ch\n  w2' \\<preceq> w2\n  c2i' \\<subseteq># c2'\n  atU U c2i'\n  ({#[entry fg q']#}, w2', c2i') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ntrs.gtr2gtrp[where c=\"{#}\", simplified, OF REVSPLIT(5)]"], ["proof (chain)\npicking this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>c2i' = add_mset s' ce'; w2' = map le_rem_s ww;\n       (([entry fg q'], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain s2i' c2ie' ww2' where R_CONV: \"c2i'=add_mset s2i' c2ie'\" \"w2'=map le_rem_s ww2'\" \"(([entry fg q'], {#}), ww2', s2i', c2ie') \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (\\<And>s' ce' ww.\n      \\<lbrakk>c2i' = add_mset s' ce'; w2' = map le_rem_s ww;\n       (([entry fg q'], {#}), ww, s', ce') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>s2i' c2ie' ww2'.\n        \\<lbrakk>c2i' = add_mset s2i' c2ie'; w2' = map le_rem_s ww2';\n         (([entry fg q'], {#}), ww2', s2i', c2ie')\n         \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  c2i' = add_mset s2i' c2ie'\n  w2' = map le_rem_s ww2'\n  (([entry fg q'], {#}), ww2', s2i', c2ie') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from RU_sound[OF R_CONV(3), of U] REVSPLIT(4) R_CONV(1)"], ["proof (chain)\npicking this:\n  atU U (add_mset s2i' c2ie') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (entry fg q', Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg ww2' \\<and>\n     Me \\<subseteq> mon_env fg ww2' \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  atU U c2i'\n  c2i' = add_mset s2i' c2ie'", "obtain Ml' Me' h' where RU: \"(entry fg q', Ml', Me', h') \\<in> RU_cs fg U\" \"Ml' \\<subseteq> mon_loc fg ww2'\" \"Me' \\<subseteq> mon_env fg ww2'\" \"h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\""], ["proof (prove)\nusing this:\n  atU U (add_mset s2i' c2ie') \\<Longrightarrow>\n  \\<exists>Ml Me h.\n     (entry fg q', Ml, Me, h) \\<in> RU_cs fg U \\<and>\n     Ml \\<subseteq> mon_loc fg ww2' \\<and>\n     Me \\<subseteq> mon_env fg ww2' \\<and>\n     h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  atU U c2i'\n  c2i' = add_mset s2i' c2ie'\n\ngoal (1 subgoal):\n 1. (\\<And>Ml' Me' h'.\n        \\<lbrakk>(entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_loc fg ww2'; Me' \\<subseteq> mon_env fg ww2';\n         h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg U\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg U\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"mon_loc fg ww2' \\<subseteq> mon_ww fg w2\" \"mon_env fg ww2' \\<subseteq> mon_ww fg w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg ww2' \\<subseteq> mon_ww fg w2 &&&\n    mon_env fg ww2' \\<subseteq> mon_ww fg w2", "using mon_ww_ileq[OF REVSPLIT(2), of fg] R_CONV(2)"], ["proof (prove)\nusing this:\n  mon_ww fg w2' \\<subseteq> mon_ww fg w2\n  w2' = map le_rem_s ww2'\n\ngoal (1 subgoal):\n 1. mon_loc fg ww2' \\<subseteq> mon_ww fg w2 &&&\n    mon_env fg ww2' \\<subseteq> mon_ww fg w2", "by (auto simp add: mon_ww_of_le_rem)"], ["proof (state)\nthis:\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<alpha>ah (map (\\<alpha>nl fg) ww2') \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n    \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)", "using REVSPLIT(2) R_CONV(2)"], ["proof (prove)\nusing this:\n  w2' \\<preceq> w2\n  w2' = map le_rem_s ww2'\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n    \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)", "by (auto simp add: \\<alpha>n_\\<alpha>nl[symmetric] le_list_map map_map[symmetric] simp del: map_map intro: \\<alpha>ah_ileq del: predicate2I)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. (\\<And>q' Ml' Me' h'.\n        \\<lbrakk>[entry fg q'] \\<in># ch;\n         (entry fg q', Ml', Me', h') \\<in> RU_cs fg U;\n         Ml' \\<subseteq> mon_ww fg w2; Me' \\<subseteq> mon_ww fg w2;\n         h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg U\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)", "show thesis"], ["proof (prove)\nusing this:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg U\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. thesis", "using that REVSPLIT(1)"], ["proof (prove)\nusing this:\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg U\n  Ml' \\<subseteq> mon_loc fg ww2'\n  Me' \\<subseteq> mon_env fg ww2'\n  h' \\<le> \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  mon_loc fg ww2' \\<subseteq> mon_ww fg w2\n  mon_env fg ww2' \\<subseteq> mon_ww fg w2\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2')\n  \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n  \\<lbrakk>[entry fg ?q'] \\<in># ch;\n   (entry fg ?q', ?Ml', ?Me', ?h') \\<in> RU_cs fg U;\n   ?Ml' \\<subseteq> mon_ww fg w2; ?Me' \\<subseteq> mon_ww fg w2;\n   ?h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  [entry fg q'] \\<in># ch\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro: order_trans)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [entry fg q'] \\<in># ch\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg U\n  Ml' \\<subseteq> mon_ww fg w2\n  Me' \\<subseteq> mon_ww fg w2\n  h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "from S_ENTRY_PAT[of \"{#q'#}\", simplified] RU(1)"], ["proof (chain)\npicking this:\n  [entry fg q'] \\<in># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q'#}) \\<in> S_cs fg (Suc 0)\n  [entry fg q'] \\<in># ch", "have S_ENTRY: \"(v, mon_w fg w, {#q'#}) \\<in> S_cs fg 1\""], ["proof (prove)\nusing this:\n  [entry fg q'] \\<in># ch \\<Longrightarrow>\n  (v, mon_w fg w, {#q'#}) \\<in> S_cs fg (Suc 0)\n  [entry fg q'] \\<in># ch\n\ngoal (1 subgoal):\n 1. (v, mon_w fg w, {#q'#}) \\<in> S_cs fg 1", "by simp"], ["proof (state)\nthis:\n  (v, mon_w fg w, {#q'#}) \\<in> S_cs fg 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"(u, mon fg p \\<union> mon_w fg w \\<union> Ml, Me \\<union> Ml' \\<union> Me') \\<in> RUV_cs fg U V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n     Me \\<union> Ml' \\<union> Me')\n    \\<in> RUV_cs fg U V", "proof (rule RUV_split_el[OF FS_FMT(2,4) S_ENTRY _ RV(1) RU(2)])"], ["proof (state)\ngoal (3 subgoals):\n 1. q' \\<in># {#q'#}\n 2. (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n    {}\n 3. h [*] h'", "from MON_PU MON1_LEQ MON2_LEQ RV(3) RU(3,4)"], ["proof (chain)\npicking this:\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  Me \\<subseteq> mon_env fg w1\n  Ml' \\<subseteq> mon_ww fg w2\n  Me' \\<subseteq> mon_ww fg w2", "show \"(mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') = {}\""], ["proof (prove)\nusing this:\n  mon_env fg ww \\<inter> (mon fg p \\<union> mon_n fg u) = {}\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  Me \\<subseteq> mon_env fg w1\n  Ml' \\<subseteq> mon_ww fg w2\n  Me' \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n    {}", "by blast"], ["proof (state)\nthis:\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n  {}\n\ngoal (2 subgoals):\n 1. q' \\<in># {#q'#}\n 2. h [*] h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. q' \\<in># {#q'#}\n 2. h [*] h'", "from ah_interleavable1[OF LESPLIT(1)]"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*]\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV w2))", "have \"\\<alpha>ah (map (\\<alpha>nl fg) w1) [*] \\<alpha>ah (map (\\<alpha>n fg) w2)\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*]\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV w2))\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) w1) [*]\n    \\<alpha>ah (map (\\<alpha>n fg) w2)", "by simp"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*] \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (2 subgoals):\n 1. q' \\<in># {#q'#}\n 2. h [*] h'", "thus \"h [*] h'\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*] \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. h [*] h'", "using RV(4) RU(5)"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) w1) [*] \\<alpha>ah (map (\\<alpha>n fg) w2)\n  h \\<le> \\<alpha>ah (map (\\<alpha>nl fg) w1)\n  h' \\<le> \\<alpha>ah (map (\\<alpha>n fg) w2)\n\ngoal (1 subgoal):\n 1. h [*] h'", "by (auto elim: ah_leq_il)"], ["proof (state)\nthis:\n  h [*] h'\n\ngoal (1 subgoal):\n 1. q' \\<in># {#q'#}", "qed (simp)"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n   Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n   Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<union> Ml\n    \\<subseteq> mon_loc fg (ee # ww)", "using FS_FMT(1) MON1_LEQ RV(2)"], ["proof (prove)\nusing this:\n  ee = LOC (LCall p # w)\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n  Ml \\<subseteq> mon_loc fg w1\n\ngoal (1 subgoal):\n 1. mon fg p \\<union> mon_w fg w \\<union> Ml\n    \\<subseteq> mon_loc fg (ee # ww)", "by (simp) blast"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "moreover"], ["proof (state)\nthis:\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "have \"Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)", "using MON1_LEQ MON2_LEQ RV(3) RU(3,4)"], ["proof (prove)\nusing this:\n  mon_loc fg w1 \\<subseteq> mon_loc fg ww\n  mon_env fg w1 \\<subseteq> mon_env fg ww\n  mon_ww fg w2 \\<subseteq> mon_env fg ww\n  Me \\<subseteq> mon_env fg w1\n  Ml' \\<subseteq> mon_ww fg w2\n  Me' \\<subseteq> mon_ww fg w2\n\ngoal (1 subgoal):\n 1. Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)", "by (simp) blast"], ["proof (state)\nthis:\n  Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atU V ({#s'#} + c1'); atU U c2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ml Me.\n                         (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n                         Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n                         Me \\<subseteq> mon_env fg (ee # ww)", "ultimately"], ["proof (chain)\npicking this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n   Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n  Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, mon fg p \\<union> mon_w fg w \\<union> Ml,\n   Me \\<union> Ml' \\<union> Me')\n  \\<in> RUV_cs fg U V\n  mon fg p \\<union> mon_w fg w \\<union> Ml \\<subseteq> mon_loc fg (ee # ww)\n  Me \\<union> Ml' \\<union> Me' \\<subseteq> mon_env fg (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n       Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n       Me \\<subseteq> mon_env fg (ee # ww)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ml Me.\n     (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n     Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Ml Me.\n     (u, Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg (ee # ww) \\<and>\n     Me \\<subseteq> mon_env fg (ee # ww)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) RUV_precise: \"(u,Ml,Me)\\<in>RUV_cs fg U V \n  \\<Longrightarrow> \\<exists>w s' c'. \n    (([u],{#}),w,(s',c'))\\<in>trcl (ntrp fg) \\<and> \n    atUV U V ({#s'#}+c') \\<and> \n    mon_loc fg w = Ml \\<and> \n    mon_env fg w = Me\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atUV U V ({#s'#} + c') \\<and>\n       mon_loc fg w = Ml \\<and> mon_env fg w = Me", "proof (induct rule: RUV_cs.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "case (RUV_call u p u' v M P Ml Me)"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 0\n  (v, Ml, Me) \\<in> RUV_cs fg U V\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and> mon_env fg w = Me\n  mon_n fg u \\<inter> Me = {}\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "then"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 0\n  (v, Ml, Me) \\<in> RUV_cs fg U V\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and> mon_env fg w = Me\n  mon_n fg u \\<inter> Me = {}", "obtain ww s' c' where IH: \"(([v], {#}), ww, s', c') \\<in> trcl (ntrp fg)\" \"atUV U V ({#s'#} + c')\" \"mon_loc fg ww = Ml\" \"mon_env fg ww = Me\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 0\n  (v, Ml, Me) \\<in> RUV_cs fg U V\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and> mon_env fg w = Me\n  mon_n fg u \\<inter> Me = {}\n\ngoal (1 subgoal):\n 1. (\\<And>ww s' c'.\n        \\<lbrakk>(([v], {#}), ww, s', c') \\<in> trcl (ntrp fg);\n         atUV U V ({#s'#} + c'); mon_loc fg ww = Ml;\n         mon_env fg ww = Me\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([v], {#}), ww, s', c') \\<in> trcl (ntrp fg)\n  atUV U V ({#s'#} + c')\n  mon_loc fg ww = Ml\n  mon_env fg ww = Me\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from S_precise_ntrp[OF RUV_call(3,2,1), simplified]"], ["proof (chain)\npicking this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     P = {#} \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}", "obtain w ch where FS: \"(([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg\" \"P = {#}\" \"M = mon_w fg w\"  \"mon_n fg v = mon fg p\" \"mon_c fg ch = {}\""], ["proof (prove)\nusing this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     P = {#} \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n\ngoal (1 subgoal):\n 1. (\\<And>w ch.\n        \\<lbrakk>(([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg;\n         P = {#}; M = mon_w fg w; mon_n fg v = mon fg p;\n         mon_c fg ch = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg\n  P = {#}\n  M = mon_w fg w\n  mon_n fg v = mon fg p\n  mon_c fg ch = {}\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "note FS(1)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "also"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"(([v, u'], ch), ww, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([v, u'], ch), ww, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)", "using ntrp_add_context[OF ntrp_stack_comp[OF IH(1), of \"[u']\"], of ch, simplified] FS(5) IH(4) RUV_call.hyps(6) mon_n_same_proc[OF edges_part[OF RUV_call.hyps(1)]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_n fg u' \\<inter> mon_env fg ww = {};\n   mon_ww fg (map le_rem_s ww) \\<inter> mon_c fg ch = {}\\<rbrakk>\n  \\<Longrightarrow> (([v, u'], ch), ww, s' @ [u'], c' + ch)\n                    \\<in> trcl (ntrp fg)\n  mon_c fg ch = {}\n  mon_env fg ww = Me\n  mon_n fg u \\<inter> Me = {}\n  mon_n fg u = mon_n fg u'\n\ngoal (1 subgoal):\n 1. (([v, u'], ch), ww, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)", "by simp"], ["proof (state)\nthis:\n  (([v, u'], ch), ww, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "finally"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w) # ww, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)", "have \"(([u], {#}), LOC (LCall p # w) # ww, s' @ [u'], c' + ch) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w) # ww, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # w) # ww, s' @ [u'], c' + ch)\n    \\<in> trcl (ntrp fg)", "."], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # ww, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # ww, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from IH(2)"], ["proof (chain)\npicking this:\n  atUV U V ({#s'#} + c')", "have \"atUV U V ({#s' @ [u']#}+(c'+ch))\""], ["proof (prove)\nusing this:\n  atUV U V ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. atUV U V ({#s' @ [u']#} + (c' + ch))", "by auto"], ["proof (state)\nthis:\n  atUV U V ({#s' @ [u']#} + (c' + ch))\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  atUV U V ({#s' @ [u']#} + (c' + ch))\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml", "using IH(3) FS(3)"], ["proof (prove)\nusing this:\n  mon_loc fg ww = Ml\n  M = mon_w fg w\n\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml", "by auto"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_env fg (LOC (LCall p # w) # ww) = Me\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # ww) = Me", "using IH(4)"], ["proof (prove)\nusing this:\n  mon_env fg ww = Me\n\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # ww) = Me", "by auto"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # w) # ww) = Me\n\ngoal (5 subgoals):\n 1. \\<And>u p u' v M P Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 0; (v, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        mon_n fg u \\<inter> Me = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me\n 2. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 5. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "ultimately"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w) # ww, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#s' @ [u']#} + (c' + ch))\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n  mon_env fg (LOC (LCall p # w) # ww) = Me", "show ?case"], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w) # ww, s' @ [u'], c' + ch)\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#s' @ [u']#} + (c' + ch))\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n  mon_env fg (LOC (LCall p # w) # ww) = Me\n\ngoal (1 subgoal):\n 1. \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atUV U V ({#s'#} + c') \\<and>\n       mon_loc fg w = mon fg p \\<union> M \\<union> Ml \\<and>\n       mon_env fg w = Me", "by blast"], ["proof (state)\nthis:\n  \\<exists>w s' c'.\n     (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = mon fg p \\<union> M \\<union> Ml \\<and> mon_env fg w = Me\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "case (RUV_spawn u p u' v M P q Ml Me)"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 1\n  q \\<in># P\n  (entry fg q, Ml, Me) \\<in> RUV_cs fg U V\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and> mon_env fg w = Me\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "then"], ["proof (chain)\npicking this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 1\n  q \\<in># P\n  (entry fg q, Ml, Me) \\<in> RUV_cs fg U V\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and> mon_env fg w = Me\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}", "obtain ww s' c' where IH: \"(([entry fg q], {#}), ww, s', c') \\<in> trcl (ntrp fg)\" \"atUV U V ({#s'#} + c')\" \"mon_loc fg ww = Ml\" \"mon_env fg ww = Me\""], ["proof (prove)\nusing this:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 1\n  q \\<in># P\n  (entry fg q, Ml, Me) \\<in> RUV_cs fg U V\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and> mon_env fg w = Me\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>ww s' c'.\n        \\<lbrakk>(([entry fg q], {#}), ww, s', c') \\<in> trcl (ntrp fg);\n         atUV U V ({#s'#} + c'); mon_loc fg ww = Ml;\n         mon_env fg ww = Me\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([entry fg q], {#}), ww, s', c') \\<in> trcl (ntrp fg)\n  atUV U V ({#s'#} + c')\n  mon_loc fg ww = Ml\n  mon_env fg ww = Me\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from S_precise_ntrp[OF RUV_spawn(3,2,1), simplified] mset_size1elem[OF _ RUV_spawn(4)]"], ["proof (chain)\npicking this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> Suc 0 \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n  size P \\<le> 1 \\<Longrightarrow> P = {#q#}", "obtain w che where \n    FS: \"(([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che) \\<in> ntrp fg\" \"P={#q#}\" \"M = mon_w fg w\" \"mon_n fg v = mon fg p\" \"mon_c fg ({#[entry fg q]#}+che) = {}\""], ["proof (prove)\nusing this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> Suc 0 \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n  size P \\<le> 1 \\<Longrightarrow> P = {#q#}\n\ngoal (1 subgoal):\n 1. (\\<And>w che.\n        \\<lbrakk>(([u], {#}), LOC (LCall p # w), [v, u'],\n                  {#[entry fg q]#} + che)\n                 \\<in> ntrp fg;\n         P = {#q#}; M = mon_w fg w; mon_n fg v = mon fg p;\n         mon_c fg ({#[entry fg q]#} + che) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: mset_le_addE)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  P = {#q#}\n  M = mon_w fg w\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  P = {#q#}\n  M = mon_w fg w\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"(([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s ww), ([v,u'],che+({#s'#} + c')))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s ww), [v, u'],\n     che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "using ntr2ntrp[OF gtrp2gtr[OF IH(1)], of \"[v,u']\" che] IH(3,4) RUV_spawn(7) FS(4,5) mon_n_same_proc[OF edges_part[OF RUV_spawn(1)]]"], ["proof (prove)\nusing this:\n  mon_c fg (add_mset [v, u'] che) \\<inter>\n  (mon_c fg {#[entry fg q]#} \\<union> mon_ww fg (map le_rem_s ww)) =\n  {} \\<Longrightarrow>\n  (([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s ww), [v, u'],\n   che + add_mset s' c')\n  \\<in> trcl (ntrp fg)\n  mon_loc fg ww = Ml\n  mon_env fg ww = Me\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) = {}\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n  mon_n fg u = mon_n fg u'\n\ngoal (1 subgoal):\n 1. (([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s ww), [v, u'],\n     che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "by (auto simp add: mon_c_unconc mon_ww_of_le_rem)"], ["proof (state)\nthis:\n  (([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s ww), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "ultimately"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  P = {#q#}\n  M = mon_w fg w\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n  (([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s ww), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)", "have \"(([u], {#}), LOC (LCall p # w) # map ENV (map le_rem_s ww), ([v,u'],che+({#s'#} + c'))) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  P = {#q#}\n  M = mon_w fg w\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n  (([v, u'], che + {#[entry fg q]#}), map ENV (map le_rem_s ww), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # w) # map ENV (map le_rem_s ww), [v, u'],\n     che + ({#s'#} + c'))\n    \\<in> trcl (ntrp fg)", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # map ENV (map le_rem_s ww), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # map ENV (map le_rem_s ww), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"atUV U V ({#[v,u']#} + (che+({#s'#} + c')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atUV U V ({#[v, u']#} + (che + ({#s'#} + c')))", "using IH(2)"], ["proof (prove)\nusing this:\n  atUV U V ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. atUV U V ({#[v, u']#} + (che + ({#s'#} + c')))", "by auto"], ["proof (state)\nthis:\n  atUV U V ({#[v, u']#} + (che + ({#s'#} + c')))\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  atUV U V ({#[v, u']#} + (che + ({#s'#} + c')))\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_loc fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) = mon fg p \\<union> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n    mon fg p \\<union> M", "using FS(3)"], ["proof (prove)\nusing this:\n  M = mon_w fg w\n\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n    mon fg p \\<union> M", "by (simp del: map_map)"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n  mon fg p \\<union> M\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n  mon fg p \\<union> M\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_env fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) = Ml \\<union> Me\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n    Ml \\<union> Me", "using IH(3,4)"], ["proof (prove)\nusing this:\n  mon_loc fg ww = Ml\n  mon_env fg ww = Me\n\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n    Ml \\<union> Me", "by (auto simp add: mon_ww_of_le_rem simp del: map_map)"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n  Ml \\<union> Me\n\ngoal (4 subgoals):\n 1. \\<And>u p u' v M P q Ml Me.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (entry fg q, Ml, Me) \\<in> RUV_cs fg U V;\n        \\<exists>w s' c'.\n           (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n           atUV U V ({#s'#} + c') \\<and>\n           mon_loc fg w = Ml \\<and> mon_env fg w = Me;\n        (mon_n fg u \\<union> mon fg p) \\<inter> (Ml \\<union> Me) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w = Ml \\<union> Me\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 4. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "ultimately"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w) # map ENV (map le_rem_s ww), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#[v, u']#} + (che + ({#s'#} + c')))\n  mon_loc fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n  mon fg p \\<union> M\n  mon_env fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n  Ml \\<union> Me", "show ?case"], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w) # map ENV (map le_rem_s ww), [v, u'],\n   che + ({#s'#} + c'))\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#[v, u']#} + (che + ({#s'#} + c')))\n  mon_loc fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n  mon fg p \\<union> M\n  mon_env fg (LOC (LCall p # w) # map ENV (map le_rem_s ww)) =\n  Ml \\<union> Me\n\ngoal (1 subgoal):\n 1. \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atUV U V ({#s'#} + c') \\<and>\n       mon_loc fg w = mon fg p \\<union> M \\<and>\n       mon_env fg w = Ml \\<union> Me", "by blast"], ["proof (state)\nthis:\n  \\<exists>w s' c'.\n     (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = mon fg p \\<union> M \\<and> mon_env fg w = Ml \\<union> Me\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "case (RUV_split_le u p u' v M P q Ml Me h Ml' Me' h')\n  \\<comment> \\<open>Get paths from precision results\\<close>"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 1\n  q \\<in># P\n  (v, Ml, Me, h) \\<in> RU_cs fg U\n  (entry fg q, Ml', Me', h') \\<in> RU_cs fg V\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n  {}\n  h [*] h'\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from S_precise_ntrp[OF RUV_split_le(3,2,1), simplified] mset_size1elem[OF _ RUV_split_le(4)]"], ["proof (chain)\npicking this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> Suc 0 \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n  size P \\<le> 1 \\<Longrightarrow> P = {#q#}", "obtain w che where \n    FS: \"(([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che) \\<in> ntrp fg\" \"P={#q#}\" \"M = mon_w fg w\" \"mon_n fg v = mon fg p\" \"mon_c fg ({#[entry fg q]#}+che) = {}\""], ["proof (prove)\nusing this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> Suc 0 \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n  size P \\<le> 1 \\<Longrightarrow> P = {#q#}\n\ngoal (1 subgoal):\n 1. (\\<And>w che.\n        \\<lbrakk>(([u], {#}), LOC (LCall p # w), [v, u'],\n                  {#[entry fg q]#} + che)\n                 \\<in> ntrp fg;\n         P = {#q#}; M = mon_w fg w; mon_n fg v = mon fg p;\n         mon_c fg ({#[entry fg q]#} + che) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: mset_le_addE)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  P = {#q#}\n  M = mon_w fg w\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from RU_precise[OF RUV_split_le(5)]"], ["proof (chain)\npicking this:\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h", "obtain ww1 s1' c1' where P1: \"(([v], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg)\" \"atU U ({#s1'#} + c1')\" \"mon_loc fg ww1 = Ml\" \"mon_env fg ww1 = Me\" \"\\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\""], ["proof (prove)\nusing this:\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (1 subgoal):\n 1. (\\<And>ww1 s1' c1'.\n        \\<lbrakk>(([v], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg);\n         atU U ({#s1'#} + c1'); mon_loc fg ww1 = Ml; mon_env fg ww1 = Me;\n         \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([v], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg)\n  atU U ({#s1'#} + c1')\n  mon_loc fg ww1 = Ml\n  mon_env fg ww1 = Me\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from RU_precise[OF RUV_split_le(6)]"], ["proof (chain)\npicking this:\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml' \\<and>\n     mon_env fg w = Me' \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h'", "obtain ww2 s2' c2' where P2: \"(([entry fg q], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg)\" \"atU V ({#s2'#} + c2')\" \"mon_loc fg ww2 = Ml'\" \"mon_env fg ww2 = Me'\" \"\\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\""], ["proof (prove)\nusing this:\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml' \\<and>\n     mon_env fg w = Me' \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h'\n\ngoal (1 subgoal):\n 1. (\\<And>ww2 s2' c2'.\n        \\<lbrakk>(([entry fg q], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg);\n         atU V ({#s2'#} + c2'); mon_loc fg ww2 = Ml'; mon_env fg ww2 = Me';\n         \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n  \\<comment> \\<open>Get combined path from the acquisition history interleavability, need to remap loc/env-steps in second path\\<close>"], ["proof (state)\nthis:\n  (([entry fg q], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg)\n  atU V ({#s2'#} + c2')\n  mon_loc fg ww2 = Ml'\n  mon_env fg ww2 = Me'\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from P2(5)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'", "have \"\\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'", "by (simp add: \\<alpha>n_\\<alpha>nl o_assoc)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "with P1(5) RUV_split_le(8)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'", "obtain ww where IL: \"ww\\<in>ww1\\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub>(map ENV (map le_rem_s ww2))\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'\n\ngoal (1 subgoal):\n 1. (\\<And>ww.\n        ww \\<in> ww1 \\<otimes>\\<^bsub>\\<alpha>nl\n fg\\<^esub> map ENV (map le_rem_s ww2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ah_interleavable2"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'\n  \\<alpha>ah (map ?\\<alpha> ?w1.0) [*]\n  \\<alpha>ah (map ?\\<alpha> ?w2.0) \\<Longrightarrow>\n  ?w1.0 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> ?w2.0 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>ww.\n        ww \\<in> ww1 \\<otimes>\\<^bsub>\\<alpha>nl\n fg\\<^esub> map ENV (map le_rem_s ww2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (force)\n  \\<comment> \\<open>Use the @{thm [source] ntrp_unsplit}-theorem to combine the executions\\<close>"], ["proof (state)\nthis:\n  ww \\<in> ww1 \\<otimes>\\<^bsub>\\<alpha>nl\n                                 fg\\<^esub> map ENV (map le_rem_s ww2)\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from ntrp_unsplit[where ca=\"{#}\",OF IL P1(1) gtrp2gtr[OF P2(1)], simplified]"], ["proof (chain)\npicking this:\n  \\<lbrakk>mon_n fg v \\<inter>\n           (mon fg q \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q \\<inter> (mon_n fg v \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> (([v], {#[entry fg q]#}), ww, s1',\n                     add_mset s2' (c1' + c2'))\n                    \\<in> trcl (ntrp fg)", "have \"(([v], {#[entry fg q]#}), ww, s1', c1' + ({#s2'#} + c2')) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_n fg v \\<inter>\n           (mon fg q \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q \\<inter> (mon_n fg v \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> (([v], {#[entry fg q]#}), ww, s1',\n                     add_mset s2' (c1' + c2'))\n                    \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([v], {#[entry fg q]#}), ww, s1', c1' + ({#s2'#} + c2'))\n    \\<in> trcl (ntrp fg)", "using FS(4,5) RUV_split_le(7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_n fg v \\<inter>\n           (mon fg q \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q \\<inter> (mon_n fg v \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> (([v], {#[entry fg q]#}), ww, s1',\n                     add_mset s2' (c1' + c2'))\n                    \\<in> trcl (ntrp fg)\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n  {}\n\ngoal (1 subgoal):\n 1. (([v], {#[entry fg q]#}), ww, s1', c1' + ({#s2'#} + c2'))\n    \\<in> trcl (ntrp fg)", "by (auto simp add: mon_c_unconc mon_ww_of_le_rem P2(3,4))"], ["proof (state)\nthis:\n  (([v], {#[entry fg q]#}), ww, s1', c1' + ({#s2'#} + c2'))\n  \\<in> trcl (ntrp fg)\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from ntrp_add_context[OF ntrp_stack_comp[OF this, of \"[u']\"], of che]"], ["proof (chain)\npicking this:\n  \\<lbrakk>mon_s fg [u'] \\<inter> mon_env fg ww = {};\n   mon_ww fg (map le_rem_s ww) \\<inter> mon_c fg che = {}\\<rbrakk>\n  \\<Longrightarrow> (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n                     c1' + ({#s2'#} + c2') + che)\n                    \\<in> trcl (ntrp fg)", "have \"(([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'], c1' + ({#s2'#} + c2') + che) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_s fg [u'] \\<inter> mon_env fg ww = {};\n   mon_ww fg (map le_rem_s ww) \\<inter> mon_c fg che = {}\\<rbrakk>\n  \\<Longrightarrow> (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n                     c1' + ({#s2'#} + c2') + che)\n                    \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n     c1' + ({#s2'#} + c2') + che)\n    \\<in> trcl (ntrp fg)", "using mon_n_same_proc[OF edges_part[OF RUV_split_le(1)]] mon_loc_cil[OF IL, of fg] mon_env_cil[OF IL, of fg] FS(4,5) RUV_split_le(7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_s fg [u'] \\<inter> mon_env fg ww = {};\n   mon_ww fg (map le_rem_s ww) \\<inter> mon_c fg che = {}\\<rbrakk>\n  \\<Longrightarrow> (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n                     c1' + ({#s2'#} + c2') + che)\n                    \\<in> trcl (ntrp fg)\n  mon_n fg u = mon_n fg u'\n  mon_loc fg ww =\n  mon_loc fg ww1 \\<union> mon_loc fg (map ENV (map le_rem_s ww2))\n  mon_env fg ww =\n  mon_env fg ww1 \\<union> mon_env fg (map ENV (map le_rem_s ww2))\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n  {}\n\ngoal (1 subgoal):\n 1. (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n     c1' + ({#s2'#} + c2') + che)\n    \\<in> trcl (ntrp fg)", "by (auto simp add: mon_c_unconc P1(3,4) P2(3,4) mon_ww_of_le_rem simp del: map_map)"], ["proof (state)\nthis:\n  (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "with FS(1)"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)", "have \"(([u], {#}), LOC (LCall p # w) # ww, (s1' @ [u'], c1' + ({#s2'#} + c2') + che))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n     c1' + ({#s2'#} + c2') + che)\n    \\<in> trcl (ntrp fg)", "by simp"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"atUV U V ({#s1' @ [u']#}+(c1' + ({#s2'#} + c2') + che))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))", "using P1(2) P2(2)"], ["proof (prove)\nusing this:\n  atU U ({#s1'#} + c1')\n  atU V ({#s2'#} + c2')\n\ngoal (1 subgoal):\n 1. atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))", "by auto"], ["proof (state)\nthis:\n  atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml", "using FS(3) P1(3) mon_loc_cil[OF IL, of fg]"], ["proof (prove)\nusing this:\n  M = mon_w fg w\n  mon_loc fg ww1 = Ml\n  mon_loc fg ww =\n  mon_loc fg ww1 \\<union> mon_loc fg (map ENV (map le_rem_s ww2))\n\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml", "by (auto simp del: map_map)"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'", "using P1(4) P2(3,4) mon_env_cil[OF IL, of fg]"], ["proof (prove)\nusing this:\n  mon_env fg ww1 = Me\n  mon_loc fg ww2 = Ml'\n  mon_env fg ww2 = Me'\n  mon_env fg ww =\n  mon_env fg ww1 \\<union> mon_env fg (map ENV (map le_rem_s ww2))\n\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'", "by (auto simp add: mon_ww_of_le_rem simp del: map_map)"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'\n\ngoal (3 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 3. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "ultimately"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n  mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'", "show ?case"], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n  mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'\n\ngoal (1 subgoal):\n 1. \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atUV U V ({#s'#} + c') \\<and>\n       mon_loc fg w = mon fg p \\<union> M \\<union> Ml \\<and>\n       mon_env fg w = Me \\<union> Ml' \\<union> Me'", "by blast"], ["proof (state)\nthis:\n  \\<exists>w s' c'.\n     (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = mon fg p \\<union> M \\<union> Ml \\<and>\n     mon_env fg w = Me \\<union> Ml' \\<union> Me'\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "case (RUV_split_el u p u' v M P q Ml Me h Ml' Me' h') \\<comment> \\<open>This is the symmetric case to @{text \"RUV_split_le\"}, it is proved completely analogously, just need to swap @{text U} and @{text V}.\\<close>\n  \\<comment> \\<open>Get paths from precision results\\<close>"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 1\n  q \\<in># P\n  (v, Ml, Me, h) \\<in> RU_cs fg V\n  (entry fg q, Ml', Me', h') \\<in> RU_cs fg U\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n  {}\n  h [*] h'\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from S_precise_ntrp[OF RUV_split_el(3,2,1), simplified] mset_size1elem[OF _ RUV_split_el(4)]"], ["proof (chain)\npicking this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> Suc 0 \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n  size P \\<le> 1 \\<Longrightarrow> P = {#q#}", "obtain w che where \n    FS: \"(([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che) \\<in> ntrp fg\" \"P={#q#}\" \"M = mon_w fg w\" \"mon_n fg v = mon fg p\" \"mon_c fg ({#[entry fg q]#}+che) = {}\""], ["proof (prove)\nusing this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> Suc 0 \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n  size P \\<le> 1 \\<Longrightarrow> P = {#q#}\n\ngoal (1 subgoal):\n 1. (\\<And>w che.\n        \\<lbrakk>(([u], {#}), LOC (LCall p # w), [v, u'],\n                  {#[entry fg q]#} + che)\n                 \\<in> ntrp fg;\n         P = {#q#}; M = mon_w fg w; mon_n fg v = mon fg p;\n         mon_c fg ({#[entry fg q]#} + che) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: mset_le_addE)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  P = {#q#}\n  M = mon_w fg w\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from RU_precise[OF RUV_split_el(5)]"], ["proof (chain)\npicking this:\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h", "obtain ww1 s1' c1' where P1: \"(([v], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg)\" \"atU V ({#s1'#} + c1')\" \"mon_loc fg ww1 = Ml\" \"mon_env fg ww1 = Me\" \"\\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\""], ["proof (prove)\nusing this:\n  \\<exists>w s' c'.\n     (([v], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (1 subgoal):\n 1. (\\<And>ww1 s1' c1'.\n        \\<lbrakk>(([v], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg);\n         atU V ({#s1'#} + c1'); mon_loc fg ww1 = Ml; mon_env fg ww1 = Me;\n         \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([v], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg)\n  atU V ({#s1'#} + c1')\n  mon_loc fg ww1 = Ml\n  mon_env fg ww1 = Me\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from RU_precise[OF RUV_split_el(6)]"], ["proof (chain)\npicking this:\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml' \\<and>\n     mon_env fg w = Me' \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h'", "obtain ww2 s2' c2' where P2: \"(([entry fg q], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg)\" \"atU U ({#s2'#} + c2')\" \"mon_loc fg ww2 = Ml'\" \"mon_env fg ww2 = Me'\" \"\\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\""], ["proof (prove)\nusing this:\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml' \\<and>\n     mon_env fg w = Me' \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h'\n\ngoal (1 subgoal):\n 1. (\\<And>ww2 s2' c2'.\n        \\<lbrakk>(([entry fg q], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg);\n         atU U ({#s2'#} + c2'); mon_loc fg ww2 = Ml'; mon_env fg ww2 = Me';\n         \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n  \\<comment> \\<open>Get combined path from the acquisition history interleavability, need to remap loc/env-steps in second path\\<close>"], ["proof (state)\nthis:\n  (([entry fg q], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg)\n  atU U ({#s2'#} + c2')\n  mon_loc fg ww2 = Ml'\n  mon_env fg ww2 = Me'\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from P2(5)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'", "have \"\\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'", "by (simp add: \\<alpha>n_\\<alpha>nl o_assoc)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "with P1(5) RUV_split_el(8)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'", "obtain ww where IL: \"ww\\<in>ww1\\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub>(map ENV (map le_rem_s ww2))\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'\n\ngoal (1 subgoal):\n 1. (\\<And>ww.\n        ww \\<in> ww1 \\<otimes>\\<^bsub>\\<alpha>nl\n fg\\<^esub> map ENV (map le_rem_s ww2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ah_interleavable2"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>nl fg) (map ENV (map le_rem_s ww2))) = h'\n  \\<alpha>ah (map ?\\<alpha> ?w1.0) [*]\n  \\<alpha>ah (map ?\\<alpha> ?w2.0) \\<Longrightarrow>\n  ?w1.0 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> ?w2.0 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>ww.\n        ww \\<in> ww1 \\<otimes>\\<^bsub>\\<alpha>nl\n fg\\<^esub> map ENV (map le_rem_s ww2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (force)\n  \\<comment> \\<open>Use the @{thm [source] ntrp_unsplit}-theorem to combine the executions\\<close>"], ["proof (state)\nthis:\n  ww \\<in> ww1 \\<otimes>\\<^bsub>\\<alpha>nl\n                                 fg\\<^esub> map ENV (map le_rem_s ww2)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from ntrp_unsplit[where ca=\"{#}\",OF IL P1(1) gtrp2gtr[OF P2(1)], simplified]"], ["proof (chain)\npicking this:\n  \\<lbrakk>mon_n fg v \\<inter>\n           (mon fg q \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q \\<inter> (mon_n fg v \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> (([v], {#[entry fg q]#}), ww, s1',\n                     add_mset s2' (c1' + c2'))\n                    \\<in> trcl (ntrp fg)", "have \"(([v], {#[entry fg q]#}), ww, s1', c1' + ({#s2'#} + c2')) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_n fg v \\<inter>\n           (mon fg q \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q \\<inter> (mon_n fg v \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> (([v], {#[entry fg q]#}), ww, s1',\n                     add_mset s2' (c1' + c2'))\n                    \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([v], {#[entry fg q]#}), ww, s1', c1' + ({#s2'#} + c2'))\n    \\<in> trcl (ntrp fg)", "using FS(4,5) RUV_split_el(7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_n fg v \\<inter>\n           (mon fg q \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q \\<inter> (mon_n fg v \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> (([v], {#[entry fg q]#}), ww, s1',\n                     add_mset s2' (c1' + c2'))\n                    \\<in> trcl (ntrp fg)\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n  {}\n\ngoal (1 subgoal):\n 1. (([v], {#[entry fg q]#}), ww, s1', c1' + ({#s2'#} + c2'))\n    \\<in> trcl (ntrp fg)", "by (auto simp add: mon_c_unconc mon_ww_of_le_rem P2(3,4))"], ["proof (state)\nthis:\n  (([v], {#[entry fg q]#}), ww, s1', c1' + ({#s2'#} + c2'))\n  \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from ntrp_add_context[OF ntrp_stack_comp[OF this, of \"[u']\"], of che]"], ["proof (chain)\npicking this:\n  \\<lbrakk>mon_s fg [u'] \\<inter> mon_env fg ww = {};\n   mon_ww fg (map le_rem_s ww) \\<inter> mon_c fg che = {}\\<rbrakk>\n  \\<Longrightarrow> (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n                     c1' + ({#s2'#} + c2') + che)\n                    \\<in> trcl (ntrp fg)", "have \"(([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'], c1' + ({#s2'#} + c2') + che) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_s fg [u'] \\<inter> mon_env fg ww = {};\n   mon_ww fg (map le_rem_s ww) \\<inter> mon_c fg che = {}\\<rbrakk>\n  \\<Longrightarrow> (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n                     c1' + ({#s2'#} + c2') + che)\n                    \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n     c1' + ({#s2'#} + c2') + che)\n    \\<in> trcl (ntrp fg)", "using mon_n_same_proc[OF edges_part[OF RUV_split_el(1)]] mon_loc_cil[OF IL, of fg] mon_env_cil[OF IL, of fg] FS(4,5) RUV_split_el(7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>mon_s fg [u'] \\<inter> mon_env fg ww = {};\n   mon_ww fg (map le_rem_s ww) \\<inter> mon_c fg che = {}\\<rbrakk>\n  \\<Longrightarrow> (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n                     c1' + ({#s2'#} + c2') + che)\n                    \\<in> trcl (ntrp fg)\n  mon_n fg u = mon_n fg u'\n  mon_loc fg ww =\n  mon_loc fg ww1 \\<union> mon_loc fg (map ENV (map le_rem_s ww2))\n  mon_env fg ww =\n  mon_env fg ww1 \\<union> mon_env fg (map ENV (map le_rem_s ww2))\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + che) = {}\n  (mon_n fg u \\<union> mon fg p) \\<inter> (Me \\<union> Ml' \\<union> Me') =\n  {}\n\ngoal (1 subgoal):\n 1. (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n     c1' + ({#s2'#} + c2') + che)\n    \\<in> trcl (ntrp fg)", "by (auto simp add: mon_c_unconc P1(3,4) P2(3,4) mon_ww_of_le_rem simp del: map_map)"], ["proof (state)\nthis:\n  (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "with FS(1)"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)", "have \"(([u], {#}), LOC (LCall p # w) # ww, (s1' @ [u'], c1' + ({#s2'#} + c2') + che))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + che)\n  \\<in> ntrp fg\n  (([v] @ [u'], {#[entry fg q]#} + che), ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n     c1' + ({#s2'#} + c2') + che)\n    \\<in> trcl (ntrp fg)", "by simp"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"atUV U V ({#s1' @ [u']#}+(c1' + ({#s2'#} + c2') + che))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))", "using P1(2) P2(2)"], ["proof (prove)\nusing this:\n  atU V ({#s1'#} + c1')\n  atU U ({#s2'#} + c2')\n\ngoal (1 subgoal):\n 1. atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))", "by auto"], ["proof (state)\nthis:\n  atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml", "using FS(3) P1(3) mon_loc_cil[OF IL, of fg]"], ["proof (prove)\nusing this:\n  M = mon_w fg w\n  mon_loc fg ww1 = Ml\n  mon_loc fg ww =\n  mon_loc fg ww1 \\<union> mon_loc fg (map ENV (map le_rem_s ww2))\n\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml", "by (auto simp del: map_map)"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'", "using P1(4) P2(3,4) mon_env_cil[OF IL, of fg]"], ["proof (prove)\nusing this:\n  mon_env fg ww1 = Me\n  mon_loc fg ww2 = Ml'\n  mon_env fg ww2 = Me'\n  mon_env fg ww =\n  mon_env fg ww1 \\<union> mon_env fg (map ENV (map le_rem_s ww2))\n\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'", "by (auto simp add: mon_ww_of_le_rem simp del: map_map)"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'\n\ngoal (2 subgoals):\n 1. \\<And>u p u' v M P q Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 1; q \\<in># P;\n        (v, Ml, Me, h) \\<in> RU_cs fg V;\n        (entry fg q, Ml', Me', h') \\<in> RU_cs fg U;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w =\n                            mon fg p \\<union> M \\<union> Ml \\<and>\n                            mon_env fg w = Me \\<union> Ml' \\<union> Me'\n 2. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "ultimately"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n  mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'", "show ?case"], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w) # ww, s1' @ [u'],\n   c1' + ({#s2'#} + c2') + che)\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#s1' @ [u']#} + (c1' + ({#s2'#} + c2') + che))\n  mon_loc fg (LOC (LCall p # w) # ww) = mon fg p \\<union> M \\<union> Ml\n  mon_env fg (LOC (LCall p # w) # ww) = Me \\<union> Ml' \\<union> Me'\n\ngoal (1 subgoal):\n 1. \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atUV U V ({#s'#} + c') \\<and>\n       mon_loc fg w = mon fg p \\<union> M \\<union> Ml \\<and>\n       mon_env fg w = Me \\<union> Ml' \\<union> Me'", "by blast"], ["proof (state)\nthis:\n  \\<exists>w s' c'.\n     (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = mon fg p \\<union> M \\<union> Ml \\<and>\n     mon_env fg w = Me \\<union> Ml' \\<union> Me'\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "case (RUV_split_ee u p u' v M P q q' Ml Me h Ml' Me' h')\n  \\<comment> \\<open>Get paths from precision results\\<close>"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n  proc_of fg v = p\n  (v, M, P) \\<in> S_cs fg 2\n  {#q#} + {#q'#} \\<subseteq># P\n  (entry fg q, Ml, Me, h) \\<in> RU_cs fg U\n  (entry fg q', Ml', Me', h') \\<in> RU_cs fg V\n  (mon_n fg u \\<union> mon fg p) \\<inter>\n  (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n  {}\n  h [*] h'\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from S_precise_ntrp[OF RUV_split_ee(3,2,1), simplified] mset_size2elem[OF _ RUV_split_ee(4)]"], ["proof (chain)\npicking this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> 2 \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n  size P \\<le> 2 \\<Longrightarrow> P = {#q#} + {#q'#}", "obtain w che where \n    FS: \"(([u], {#}), LOC (LCall p # w), [v, u'], {#[entry fg q]#} + {#[entry fg q']#} + che) \\<in> ntrp fg\" \"P={#q#}+{#q'#}\" \"M = mon_w fg w\" \"mon_n fg v = mon fg p\" \"mon_c fg ({#[entry fg q]#}+{#[entry fg q']#}+che) = {}\""], ["proof (prove)\nusing this:\n  \\<exists>w ch.\n     (([u], {#}), LOC (LCall p # w), [v, u'], ch) \\<in> ntrp fg \\<and>\n     size P \\<le> 2 \\<and>\n     M = mon_w fg w \\<and>\n     mon_n fg v = mon fg p \\<and>\n     {#[entry fg p]. p \\<in># P#} \\<subseteq># ch \\<and> mon_c fg ch = {}\n  size P \\<le> 2 \\<Longrightarrow> P = {#q#} + {#q'#}\n\ngoal (1 subgoal):\n 1. (\\<And>w che.\n        \\<lbrakk>(([u], {#}), LOC (LCall p # w), [v, u'],\n                  {#[entry fg q]#} + {#[entry fg q']#} + che)\n                 \\<in> ntrp fg;\n         P = {#q#} + {#q'#}; M = mon_w fg w; mon_n fg v = mon fg p;\n         mon_c fg ({#[entry fg q]#} + {#[entry fg q']#} + che) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: mset_le_addE)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w), [v, u'],\n   {#[entry fg q]#} + {#[entry fg q']#} + che)\n  \\<in> ntrp fg\n  P = {#q#} + {#q'#}\n  M = mon_w fg w\n  mon_n fg v = mon fg p\n  mon_c fg ({#[entry fg q]#} + {#[entry fg q']#} + che) = {}\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from RU_precise[OF RUV_split_ee(5)]"], ["proof (chain)\npicking this:\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h", "obtain ww1 s1' c1' where P1: \"(([entry fg q], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg)\" \"atU U ({#s1'#} + c1')\" \"mon_loc fg ww1 = Ml\" \"mon_env fg ww1 = Me\" \"\\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\""], ["proof (prove)\nusing this:\n  \\<exists>w s' c'.\n     (([entry fg q], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU U ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and>\n     mon_env fg w = Me \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h\n\ngoal (1 subgoal):\n 1. (\\<And>ww1 s1' c1'.\n        \\<lbrakk>(([entry fg q], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg);\n         atU U ({#s1'#} + c1'); mon_loc fg ww1 = Ml; mon_env fg ww1 = Me;\n         \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([entry fg q], {#}), ww1, s1', c1') \\<in> trcl (ntrp fg)\n  atU U ({#s1'#} + c1')\n  mon_loc fg ww1 = Ml\n  mon_env fg ww1 = Me\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from RU_precise[OF RUV_split_ee(6)]"], ["proof (chain)\npicking this:\n  \\<exists>w s' c'.\n     (([entry fg q'], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml' \\<and>\n     mon_env fg w = Me' \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h'", "obtain ww2 s2' c2' where P2: \"(([entry fg q'], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg)\" \"atU V ({#s2'#} + c2')\" \"mon_loc fg ww2 = Ml'\" \"mon_env fg ww2 = Me'\" \"\\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\""], ["proof (prove)\nusing this:\n  \\<exists>w s' c'.\n     (([entry fg q'], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atU V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml' \\<and>\n     mon_env fg w = Me' \\<and> \\<alpha>ah (map (\\<alpha>nl fg) w) = h'\n\ngoal (1 subgoal):\n 1. (\\<And>ww2 s2' c2'.\n        \\<lbrakk>(([entry fg q'], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg);\n         atU V ({#s2'#} + c2'); mon_loc fg ww2 = Ml'; mon_env fg ww2 = Me';\n         \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n\n  \\<comment> \\<open>Get interleaved paths, project away loc/env information first\\<close>"], ["proof (state)\nthis:\n  (([entry fg q'], {#}), ww2, s2', c2') \\<in> trcl (ntrp fg)\n  atU V ({#s2'#} + c2')\n  mon_loc fg ww2 = Ml'\n  mon_env fg ww2 = Me'\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from P1(5) P2(5)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'", "have \"\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww1)) = h\" \"\\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww2)) = h'\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map (\\<alpha>nl fg) ww1) = h\n  \\<alpha>ah (map (\\<alpha>nl fg) ww2) = h'\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww1)) = h &&&\n    \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww2)) = h'", "by (auto simp add: \\<alpha>n_\\<alpha>nl o_assoc)"], ["proof (state)\nthis:\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww1)) = h\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww2)) = h'\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "with RUV_split_ee(8)"], ["proof (chain)\npicking this:\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww1)) = h\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww2)) = h'", "obtain ww where IL: \"ww \\<in> (map le_rem_s ww1) \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> (map le_rem_s ww2)\""], ["proof (prove)\nusing this:\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww1)) = h\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww2)) = h'\n\ngoal (1 subgoal):\n 1. (\\<And>ww.\n        ww \\<in> map le_rem_s\n                  ww1 \\<otimes>\\<^bsub>\\<alpha>n\n  fg\\<^esub> map le_rem_s ww2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ah_interleavable2"], ["proof (prove)\nusing this:\n  h [*] h'\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww1)) = h\n  \\<alpha>ah (map (\\<alpha>n fg) (map le_rem_s ww2)) = h'\n  \\<alpha>ah (map ?\\<alpha> ?w1.0) [*]\n  \\<alpha>ah (map ?\\<alpha> ?w2.0) \\<Longrightarrow>\n  ?w1.0 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> ?w2.0 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>ww.\n        ww \\<in> map le_rem_s\n                  ww1 \\<otimes>\\<^bsub>\\<alpha>n\n  fg\\<^esub> map le_rem_s ww2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (force simp del: map_map)\n  \\<comment> \\<open>Use the @{thm [source] ntr_unsplit}-theorem to combine the executions\\<close>"], ["proof (state)\nthis:\n  ww \\<in> map le_rem_s\n            ww1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> map le_rem_s ww2\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from ntr_unsplit[OF IL gtrp2gtr[OF P1(1)] gtrp2gtr[OF P2(1)], simplified]"], ["proof (chain)\npicking this:\n  \\<lbrakk>mon fg q \\<inter>\n           (mon fg q' \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q' \\<inter> (mon fg q \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> ({#[entry fg q'], [entry fg q]#}, ww,\n                     add_mset s2' (add_mset s1' (c1' + c2')))\n                    \\<in> trcl (ntr fg)", "have PC: \"({#[entry fg q]#} + {#[entry fg q']#}, ww, {#s1'#} + c1' + ({#s2'#} + c2')) \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mon fg q \\<inter>\n           (mon fg q' \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q' \\<inter> (mon fg q \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> ({#[entry fg q'], [entry fg q]#}, ww,\n                     add_mset s2' (add_mset s1' (c1' + c2')))\n                    \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. ({#[entry fg q]#} + {#[entry fg q']#}, ww,\n     {#s1'#} + c1' + ({#s2'#} + c2'))\n    \\<in> trcl (ntr fg)", "using FS(5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>mon fg q \\<inter>\n           (mon fg q' \\<union> mon_ww fg (map le_rem_s ww2)) =\n           {};\n   mon fg q' \\<inter> (mon fg q \\<union> mon_ww fg (map le_rem_s ww1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> ({#[entry fg q'], [entry fg q]#}, ww,\n                     add_mset s2' (add_mset s1' (c1' + c2')))\n                    \\<in> trcl (ntr fg)\n  mon_c fg ({#[entry fg q]#} + {#[entry fg q']#} + che) = {}\n\ngoal (1 subgoal):\n 1. ({#[entry fg q]#} + {#[entry fg q']#}, ww,\n     {#s1'#} + c1' + ({#s2'#} + c2'))\n    \\<in> trcl (ntr fg)", "by (auto simp add: mon_c_unconc)\n  \\<comment> \\<open>Prepend first step\\<close>"], ["proof (state)\nthis:\n  ({#[entry fg q]#} + {#[entry fg q']#}, ww,\n   {#s1'#} + c1' + ({#s2'#} + c2'))\n  \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "from ntr2ntrp[OF PC(1), of \"[v,u']\" che]"], ["proof (chain)\npicking this:\n  mon_c fg (add_mset [v, u'] che) \\<inter>\n  (mon_c fg ({#[entry fg q]#} + {#[entry fg q']#}) \\<union> mon_ww fg ww) =\n  {} \\<Longrightarrow>\n  (([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww,\n   [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)", "have \"(([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww, [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2'))) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  mon_c fg (add_mset [v, u'] che) \\<inter>\n  (mon_c fg ({#[entry fg q]#} + {#[entry fg q']#}) \\<union> mon_ww fg ww) =\n  {} \\<Longrightarrow>\n  (([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww,\n   [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww,\n     [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n    \\<in> trcl (ntrp fg)", "using RUV_split_ee(7) FS(5) mon_ww_cil[OF IL, of fg] FS(4) mon_n_same_proc[OF edges_part[OF RUV_split_ee(1)]]"], ["proof (prove)\nusing this:\n  mon_c fg (add_mset [v, u'] che) \\<inter>\n  (mon_c fg ({#[entry fg q]#} + {#[entry fg q']#}) \\<union> mon_ww fg ww) =\n  {} \\<Longrightarrow>\n  (([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww,\n   [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)\n  (mon_n fg u \\<union> mon fg p) \\<inter>\n  (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n  {}\n  mon_c fg ({#[entry fg q]#} + {#[entry fg q']#} + che) = {}\n  mon_ww fg ww =\n  mon_ww fg (map le_rem_s ww1) \\<union> mon_ww fg (map le_rem_s ww2)\n  mon_n fg v = mon fg p\n  mon_n fg u = mon_n fg u'\n\ngoal (1 subgoal):\n 1. (([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww,\n     [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n    \\<in> trcl (ntrp fg)", "by (auto simp add: mon_c_unconc mon_ww_of_le_rem P1(3,4) P2(3,4))"], ["proof (state)\nthis:\n  (([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww,\n   [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "with FS(1)"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w), [v, u'],\n   {#[entry fg q]#} + {#[entry fg q']#} + che)\n  \\<in> ntrp fg\n  (([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww,\n   [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)", "have \"(([u], {#}), LOC (LCall p # w) # map ENV ww, ([v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))) \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w), [v, u'],\n   {#[entry fg q]#} + {#[entry fg q']#} + che)\n  \\<in> ntrp fg\n  (([v, u'], che + ({#[entry fg q]#} + {#[entry fg q']#})), map ENV ww,\n   [v, u'], che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (([u], {#}), LOC (LCall p # w) # map ENV ww, [v, u'],\n     che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n    \\<in> trcl (ntrp fg)", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # map ENV ww, [v, u'],\n   che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  (([u], {#}), LOC (LCall p # w) # map ENV ww, [v, u'],\n   che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"atUV U V ({#[v, u']#}+(che + ({#s1'#} + c1' + ({#s2'#} + c2'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atUV U V ({#[v, u']#} + (che + ({#s1'#} + c1' + ({#s2'#} + c2'))))", "using P1(2) P2(2)"], ["proof (prove)\nusing this:\n  atU U ({#s1'#} + c1')\n  atU V ({#s2'#} + c2')\n\ngoal (1 subgoal):\n 1. atUV U V ({#[v, u']#} + (che + ({#s1'#} + c1' + ({#s2'#} + c2'))))", "by auto"], ["proof (state)\nthis:\n  atUV U V ({#[v, u']#} + (che + ({#s1'#} + c1' + ({#s2'#} + c2'))))\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  atUV U V ({#[v, u']#} + (che + ({#s1'#} + c1' + ({#s2'#} + c2'))))\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_loc fg (LOC (LCall p # w) # map ENV ww) = mon fg p \\<union> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # map ENV ww) = mon fg p \\<union> M", "using FS(3)"], ["proof (prove)\nusing this:\n  M = mon_w fg w\n\ngoal (1 subgoal):\n 1. mon_loc fg (LOC (LCall p # w) # map ENV ww) = mon fg p \\<union> M", "by auto"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # map ENV ww) = mon fg p \\<union> M\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "moreover"], ["proof (state)\nthis:\n  mon_loc fg (LOC (LCall p # w) # map ENV ww) = mon fg p \\<union> M\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "have \"mon_env fg (LOC (LCall p # w) # map ENV ww) = Ml \\<union> Me \\<union> Ml' \\<union> Me'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # map ENV ww) =\n    Ml \\<union> Me \\<union> Ml' \\<union> Me'", "using mon_ww_cil[OF IL, of fg]"], ["proof (prove)\nusing this:\n  mon_ww fg ww =\n  mon_ww fg (map le_rem_s ww1) \\<union> mon_ww fg (map le_rem_s ww2)\n\ngoal (1 subgoal):\n 1. mon_env fg (LOC (LCall p # w) # map ENV ww) =\n    Ml \\<union> Me \\<union> Ml' \\<union> Me'", "by (auto simp add: P1(3,4) P2(3,4) mon_ww_of_le_rem)"], ["proof (state)\nthis:\n  mon_env fg (LOC (LCall p # w) # map ENV ww) =\n  Ml \\<union> Me \\<union> Ml' \\<union> Me'\n\ngoal (1 subgoal):\n 1. \\<And>u p u' v M P q q' Ml Me h Ml' Me' h'.\n       \\<lbrakk>(u, Call p, u') \\<in> edges fg; proc_of fg v = p;\n        (v, M, P) \\<in> S_cs fg 2; {#q#} + {#q'#} \\<subseteq># P;\n        (entry fg q, Ml, Me, h) \\<in> RU_cs fg U;\n        (entry fg q', Ml', Me', h') \\<in> RU_cs fg V;\n        (mon_n fg u \\<union> mon fg p) \\<inter>\n        (Ml \\<union> Me \\<union> Ml' \\<union> Me') =\n        {};\n        h [*] h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w s' c'.\n                            (([u], {#}), w, s', c')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            atUV U V ({#s'#} + c') \\<and>\n                            mon_loc fg w = mon fg p \\<union> M \\<and>\n                            mon_env fg w =\n                            Ml \\<union> Me \\<union> Ml' \\<union> Me'", "ultimately"], ["proof (chain)\npicking this:\n  (([u], {#}), LOC (LCall p # w) # map ENV ww, [v, u'],\n   che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#[v, u']#} + (che + ({#s1'#} + c1' + ({#s2'#} + c2'))))\n  mon_loc fg (LOC (LCall p # w) # map ENV ww) = mon fg p \\<union> M\n  mon_env fg (LOC (LCall p # w) # map ENV ww) =\n  Ml \\<union> Me \\<union> Ml' \\<union> Me'", "show ?case"], ["proof (prove)\nusing this:\n  (([u], {#}), LOC (LCall p # w) # map ENV ww, [v, u'],\n   che + ({#s1'#} + c1' + ({#s2'#} + c2')))\n  \\<in> trcl (ntrp fg)\n  atUV U V ({#[v, u']#} + (che + ({#s1'#} + c1' + ({#s2'#} + c2'))))\n  mon_loc fg (LOC (LCall p # w) # map ENV ww) = mon fg p \\<union> M\n  mon_env fg (LOC (LCall p # w) # map ENV ww) =\n  Ml \\<union> Me \\<union> Ml' \\<union> Me'\n\ngoal (1 subgoal):\n 1. \\<exists>w s' c'.\n       (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n       atUV U V ({#s'#} + c') \\<and>\n       mon_loc fg w = mon fg p \\<union> M \\<and>\n       mon_env fg w = Ml \\<union> Me \\<union> Ml' \\<union> Me'", "by blast"], ["proof (state)\nthis:\n  \\<exists>w s' c'.\n     (([u], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = mon fg p \\<union> M \\<and>\n     mon_env fg w = Ml \\<union> Me \\<union> Ml' \\<union> Me'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}