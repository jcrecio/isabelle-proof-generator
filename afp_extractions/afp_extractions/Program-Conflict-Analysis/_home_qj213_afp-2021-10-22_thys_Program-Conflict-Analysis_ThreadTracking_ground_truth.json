{"file_name": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis/ThreadTracking.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis", "problem_names": ["lemma gtrI_s: \"((s,c),e,(s',c'))\\<in>gtrs \\<Longrightarrow> (add_mset s c,e,add_mset s' c')\\<in>gtr gtrs\"", "lemma gtrI: \"((s,c),w,(s',c'))\\<in>trcl gtrs \n  \\<Longrightarrow> (add_mset s c,w,add_mset s' c')\\<in>trcl (gtr gtrs)\"", "lemma gtrE: \"\\<lbrakk>\n    (c,e,c')\\<in>gtr T; \n    !!s ce s' ce'. \\<lbrakk> c=add_mset s ce; c'=add_mset s' ce'; ((s,ce),e,(s',ce'))\\<in>T \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma gtr_empty_conf_s[simp]: \n  \"({#},w,c')\\<notin>gtr S\" \n  \"(c,w,{#})\\<notin>gtr S\"", "lemma gtr_empty_conf1[simp]: \"(({#},w,c')\\<in>trcl (gtr S)) \\<longleftrightarrow> (w=[] \\<and> c'={#})\"", "lemma gtr_empty_conf2[simp]: \"((c,w,{#})\\<in>trcl (gtr S)) \\<longleftrightarrow> (w=[] \\<and> c={#})\"", "lemma gtr_find_thread: \"\\<lbrakk>\n    (c,e,c')\\<in>gtr gtrs; \n    !!s ce s' ce'. \\<lbrakk>c=add_mset s ce; c'=add_mset s' ce'; ((s,ce),e,(s',ce'))\\<in>gtrs\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma gtr_step_cases[cases set, case_names loc other]: \"\\<lbrakk> \n    (add_mset s ce,e,c')\\<in>gtr gtrs; \n    !!s' ce'. \\<lbrakk> c'=add_mset s' ce'; ((s,ce),e,(s',ce'))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P;\n    !!cc ss ss' ce'. \\<lbrakk> ce=add_mset ss cc; c'=add_mset ss' ce'; \n                       ((ss,add_mset s cc),e,(ss',ce'))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma gtr_rev_cases[cases set, case_names loc other]: \"\\<lbrakk> \n    (c,e,add_mset s' ce')\\<in>gtr gtrs; \n    !!s ce. \\<lbrakk> c=add_mset s ce; ((s,ce),e,(s',ce'))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P;\n    !!cc ss ss' ce. \\<lbrakk> c=add_mset ss ce; ce'=add_mset ss' cc; \n                      ((ss,ce),e,(ss',add_mset s' cc))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma gtr_preserve_s: \"\\<lbrakk> \n    (c,e,c')\\<in>gtr T; \n    P c; \n    !!s c s' c' e. \\<lbrakk>P (add_mset s c); ((s,c),e,(s',c'))\\<in>T\\<rbrakk> \\<Longrightarrow> P (add_mset s' c') \n  \\<rbrakk> \\<Longrightarrow> P c'\"", "lemma gtr_preserve: \"\\<lbrakk> \n    (c,w,c')\\<in>trcl (gtr T); \n    P c; \n    !!s c s' c' e. \\<lbrakk>P (add_mset s c); ((s,c),e,(s',c'))\\<in>T\\<rbrakk> \\<Longrightarrow> P (add_mset s' c') \n  \\<rbrakk> \\<Longrightarrow> P c'\"", "lemma (in env_no_step) env_no_step[cases set, case_names csp]: \"\\<lbrakk>\n    ((s,c),w,(s',c'))\\<in>trcl gtrs; \n    !! csp. c'=csp+c \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma (in env_no_step) rev_cases_p[cases set, case_names loc spawn env]: \n  assumes STEP: \"(c,e,add_mset s' ce')\\<in>gtr gtrs\" and\n  LOC: \"!!s ce. \\<lbrakk> c={#s#}+ce; ((s,ce),e,(s',ce'))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P\" and\n  SPAWN: \"!!ss ss' ce csp. \n            \\<lbrakk> c=add_mset ss ce; ce'=add_mset ss' (csp+ce); \n              ((ss,ce),e,(ss',add_mset s' (csp+ce)))\\<in>gtrs \\<rbrakk> \n           \\<Longrightarrow> P\" and\n  ENV: \"!!ss ss' ce csp. \n            \\<lbrakk> c=add_mset ss (add_mset s' ce); ce'=add_mset ss' (csp+ce); \n              ((ss,add_mset s' ce),e,(ss',csp+(add_mset s' ce)))\\<in>gtrs \\<rbrakk> \n           \\<Longrightarrow> P\"\n  shows \"P\"", "lemma loc_env_simps[simp]: \n  \"loc [] = []\" \n  \"env [] = []\"", "lemma loc_single[simp]: \"loc [a] = (case a of LOC e \\<Rightarrow> [a] | ENV e \\<Rightarrow> [])\"", "lemma loc_uncons[simp]: \n  \"loc (a#b) = (case a of LOC e \\<Rightarrow> [a] | ENV e \\<Rightarrow> [])@loc b\"", "lemma loc_unconc[simp]: \"loc (a@b) = loc a @ loc b\"", "lemma env_single[simp]: \"env [a] = (case a of LOC e \\<Rightarrow> [] | ENV e \\<Rightarrow> [a])\"", "lemma env_uncons[simp]: \n  \"env (a#b) = (case a of LOC e \\<Rightarrow> [] | ENV e \\<Rightarrow> [a]) @ env b\"", "lemma env_unconc[simp]: \"env (a@b) = env a @ env b\"", "lemma le_rem_simps [simp]: \n  \"le_rem_s (LOC a) = a\" \n  \"le_rem_s (ENV a) = a\"", "lemma le_rem_id_simps[simp]: \n  \"le_rem_s\\<circ>LOC = id\" \n  \"le_rem_s\\<circ>ENV = id\"", "lemma le_rem_id_map[simp]: \n  \"map le_rem_s (map LOC w) = w\" \n  \"map le_rem_s (map ENV w) = w\"", "lemma env_map_env [simp]: \"env (map ENV w) = map ENV w\"", "lemma env_map_loc [simp]: \"env (map LOC w) = []\"", "lemma loc_map_env [simp]: \"loc (map ENV w) = []\"", "lemma loc_map_loc [simp]: \"loc (map LOC w) = map LOC w\"", "lemma gtrp2gtr_s: \n  \"((s,c),e,(s',c'))\\<in>gtrp T \\<Longrightarrow> (add_mset s c,le_rem_s e,add_mset s' c')\\<in>gtr T\"", "lemma gtrp2gtr: \n  \"((s,c),w,(s',c'))\\<in>trcl (gtrp T) \n  \\<Longrightarrow> (add_mset s c,map le_rem_s w,add_mset s' c')\\<in>trcl (gtr T)\"", "lemma (in env_no_step) gtr2gtrp_s[cases set, case_names gtrp]: \n  assumes A: \"(add_mset s c,e,c')\\<in>gtr gtrs\" \n  and CASE: \"!!s' ce' ee. \\<lbrakk>c'=add_mset s' ce'; e=le_rem_s ee; \n                          ((s,c),ee,(s',ce'))\\<in>gtrp gtrs\\<rbrakk> \n                         \\<Longrightarrow> P\"\n  shows \"P\"", "lemma (in env_no_step) gtr2gtrp[cases set, case_names gtrp]: \n  assumes A: \"(add_mset s c,w,c')\\<in>trcl (gtr gtrs)\" \n  and CASE: \"!!s' ce' ww. \\<lbrakk>c'=add_mset s' ce'; w=map le_rem_s ww; \n                           ((s,c),ww,(s',ce'))\\<in>trcl (gtrp gtrs)\\<rbrakk> \n                          \\<Longrightarrow> P\" \n  shows P", "lemma gtrp_preserve_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>gtrp T\" \n  and INIT: \"P (add_mset s c)\" \n  and PRES: \"!!s c s' c' e. \\<lbrakk>P (add_mset s c); ((s,c),e,(s',c'))\\<in>T\\<rbrakk> \n                            \\<Longrightarrow> P (add_mset s' c')\" \n  shows \"P (add_mset s' c')\"", "lemma gtrp_preserve: \n  assumes A: \"((s,c),w,(s',c'))\\<in>trcl (gtrp T)\" \n  and INIT: \"P (add_mset s c)\" \n  and PRES: \"!!s c s' c' e. \\<lbrakk>P (add_mset s c); ((s,c),e,(s',c'))\\<in>T\\<rbrakk> \n                            \\<Longrightarrow> P (add_mset s' c')\" \n  shows \"P (add_mset s' c')\""], "translations": [["", "lemma gtrI_s: \"((s,c),e,(s',c'))\\<in>gtrs \\<Longrightarrow> (add_mset s c,e,add_mset s' c')\\<in>gtr gtrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> gtrs \\<Longrightarrow>\n    (add_mset s c, e, add_mset s' c') \\<in> gtr gtrs", "by (unfold gtr_def, auto)"], ["", "lemma gtrI: \"((s,c),w,(s',c'))\\<in>trcl gtrs \n  \\<Longrightarrow> (add_mset s c,w,add_mset s' c')\\<in>trcl (gtr gtrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl gtrs \\<Longrightarrow>\n    (add_mset s c, w, add_mset s' c') \\<in> trcl (gtr gtrs)", "by (induct rule: trcl_pair_induct) (auto dest: gtrI_s)"], ["", "lemma gtrE: \"\\<lbrakk>\n    (c,e,c')\\<in>gtr T; \n    !!s ce s' ce'. \\<lbrakk> c=add_mset s ce; c'=add_mset s' ce'; ((s,ce),e,(s',ce'))\\<in>T \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, e, c') \\<in> gtr T;\n     \\<And>s ce s' ce'.\n        \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n         ((s, ce), e, s', ce') \\<in> T\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (unfold gtr_def) auto"], ["", "lemma gtr_empty_conf_s[simp]: \n  \"({#},w,c')\\<notin>gtr S\" \n  \"(c,w,{#})\\<notin>gtr S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#}, w, c') \\<notin> gtr S &&& (c, w, {#}) \\<notin> gtr S", "by (auto elim: gtrE)"], ["", "lemma gtr_empty_conf1[simp]: \"(({#},w,c')\\<in>trcl (gtr S)) \\<longleftrightarrow> (w=[] \\<and> c'={#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (({#}, w, c') \\<in> trcl (gtr S)) = (w = [] \\<and> c' = {#})", "by (induct w) (auto dest: trcl_uncons)"], ["", "lemma gtr_empty_conf2[simp]: \"((c,w,{#})\\<in>trcl (gtr S)) \\<longleftrightarrow> (w=[] \\<and> c={#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c, w, {#}) \\<in> trcl (gtr S)) = (w = [] \\<and> c = {#})", "by (induct w rule: rev_induct) (auto dest: trcl_rev_uncons)"], ["", "lemma gtr_find_thread: \"\\<lbrakk>\n    (c,e,c')\\<in>gtr gtrs; \n    !!s ce s' ce'. \\<lbrakk>c=add_mset s ce; c'=add_mset s' ce'; ((s,ce),e,(s',ce'))\\<in>gtrs\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, e, c') \\<in> gtr gtrs;\n     \\<And>s ce s' ce'.\n        \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n         ((s, ce), e, s', ce') \\<in> gtrs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (unfold gtr_def) auto"], ["", "lemma gtr_step_cases[cases set, case_names loc other]: \"\\<lbrakk> \n    (add_mset s ce,e,c')\\<in>gtr gtrs; \n    !!s' ce'. \\<lbrakk> c'=add_mset s' ce'; ((s,ce),e,(s',ce'))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P;\n    !!cc ss ss' ce'. \\<lbrakk> ce=add_mset ss cc; c'=add_mset ss' ce'; \n                       ((ss,add_mset s cc),e,(ss',ce'))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(add_mset s ce, e, c') \\<in> gtr gtrs;\n     \\<And>s' ce'.\n        \\<lbrakk>c' = add_mset s' ce';\n         ((s, ce), e, s', ce') \\<in> gtrs\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>cc ss ss' ce'.\n        \\<lbrakk>ce = add_mset ss cc; c' = add_mset ss' ce';\n         ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto elim!: gtr_find_thread mset_single_cases)"], ["", "lemma gtr_rev_cases[cases set, case_names loc other]: \"\\<lbrakk> \n    (c,e,add_mset s' ce')\\<in>gtr gtrs; \n    !!s ce. \\<lbrakk> c=add_mset s ce; ((s,ce),e,(s',ce'))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P;\n    !!cc ss ss' ce. \\<lbrakk> c=add_mset ss ce; ce'=add_mset ss' cc; \n                      ((ss,ce),e,(ss',add_mset s' cc))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, e, add_mset s' ce') \\<in> gtr gtrs;\n     \\<And>s ce.\n        \\<lbrakk>c = add_mset s ce;\n         ((s, ce), e, s', ce') \\<in> gtrs\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>cc ss ss' ce.\n        \\<lbrakk>c = add_mset ss ce; ce' = add_mset ss' cc;\n         ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto elim!: gtr_find_thread mset_single_cases)"], ["", "subsection \"Invariants\""], ["", "lemma gtr_preserve_s: \"\\<lbrakk> \n    (c,e,c')\\<in>gtr T; \n    P c; \n    !!s c s' c' e. \\<lbrakk>P (add_mset s c); ((s,c),e,(s',c'))\\<in>T\\<rbrakk> \\<Longrightarrow> P (add_mset s' c') \n  \\<rbrakk> \\<Longrightarrow> P c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, e, c') \\<in> gtr T; P c;\n     \\<And>s c s' c' e.\n        \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n        \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n    \\<Longrightarrow> P c'", "by (unfold gtr_def) blast"], ["", "lemma gtr_preserve: \"\\<lbrakk> \n    (c,w,c')\\<in>trcl (gtr T); \n    P c; \n    !!s c s' c' e. \\<lbrakk>P (add_mset s c); ((s,c),e,(s',c'))\\<in>T\\<rbrakk> \\<Longrightarrow> P (add_mset s' c') \n  \\<rbrakk> \\<Longrightarrow> P c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, w, c') \\<in> trcl (gtr T); P c;\n     \\<And>s c s' c' e.\n        \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n        \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n    \\<Longrightarrow> P c'", "apply (induct rule: trcl.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>P c;\n        \\<And>s c s' c' e.\n           \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n           \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> P c\n 2. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> gtr T; (c', w, c'') \\<in> trcl (gtr T);\n        \\<lbrakk>P c';\n         \\<And>s c s' c' e.\n            \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n            \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n        \\<Longrightarrow> P c'';\n        P c;\n        \\<And>s c s' c' e.\n           \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n           \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> P c''", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> gtr T; (c', w, c'') \\<in> trcl (gtr T);\n        \\<lbrakk>P c';\n         \\<And>s c s' c' e.\n            \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n            \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n        \\<Longrightarrow> P c'';\n        P c;\n        \\<And>s c s' c' e.\n           \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n           \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> P c''", "apply (subgoal_tac \"P c'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> gtr T; (c', w, c'') \\<in> trcl (gtr T);\n        \\<lbrakk>P c';\n         \\<And>s c s' c' e.\n            \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n            \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n        \\<Longrightarrow> P c'';\n        P c;\n        \\<And>s c s' c' e.\n           \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n           \\<Longrightarrow> P (add_mset s' c');\n        P c'\\<rbrakk>\n       \\<Longrightarrow> P c''\n 2. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> gtr T; (c', w, c'') \\<in> trcl (gtr T);\n        \\<lbrakk>P c';\n         \\<And>s c s' c' e.\n            \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n            \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n        \\<Longrightarrow> P c'';\n        P c;\n        \\<And>s c s' c' e.\n           \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n           \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> P c'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> gtr T; (c', w, c'') \\<in> trcl (gtr T);\n        \\<lbrakk>P c';\n         \\<And>s c s' c' e.\n            \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n            \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n        \\<Longrightarrow> P c'';\n        P c;\n        \\<And>s c s' c' e.\n           \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n           \\<Longrightarrow> P (add_mset s' c')\\<rbrakk>\n       \\<Longrightarrow> P c'", "apply (blast intro: gtr_preserve_s)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Context preservation assumption\""], ["", "text \\<open>\n  We now assume that the original semantics does not modify threads in the context, i.e. it may only add new threads to the context and use the context to obtain monitor information, but not change any\n  existing thread in the context. This assumption is valid for our semantics, where the context is just needed to determine the set of allocated monitors. It allows us to generally derive some further properties of\n  such semantics.\n\\<close>"], ["", "locale env_no_step =\n  fixes gtrs :: \"(('s\\<times>'s multiset),'l) LTS\"\n  assumes env_no_step_s[cases set, case_names csp]: \n    \"\\<lbrakk>((s,c),e,(s',c'))\\<in>gtrs; !!csp. c'=csp+c \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"\n\n\\<comment> \\<open>The property of not changing existing threads in the context transfers to paths\\<close>"], ["", "lemma (in env_no_step) env_no_step[cases set, case_names csp]: \"\\<lbrakk>\n    ((s,c),w,(s',c'))\\<in>trcl gtrs; \n    !! csp. c'=csp+c \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl gtrs;\n     \\<And>csp. c' = csp + c \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl gtrs;\n     \\<And>csp. c' = csp + c \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "have \"((s,c),w,(s',c'))\\<in>trcl gtrs \\<Longrightarrow> \\<exists>csp. c'=csp+c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl gtrs \\<Longrightarrow>\n    \\<exists>csp. c' = csp + c", "proof (induct rule: trcl_pair_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. \\<exists>csp. b = csp + b\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a b. \\<exists>csp. b = csp + b\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>csp. b_ = csp + b_", "by (auto intro: exI[of _ \"{#}\"])"], ["proof (state)\nthis:\n  \\<exists>csp. b_ = csp + b_\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "case (cons s c e sh ch w s' c')"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> gtrs\n  ((sh, ch), w, s', c') \\<in> trcl gtrs\n  \\<exists>csp. c' = csp + ch\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "note IHP=this"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> gtrs\n  ((sh, ch), w, s', c') \\<in> trcl gtrs\n  \\<exists>csp. c' = csp + ch\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "from env_no_step_s[OF IHP(1)]"], ["proof (chain)\npicking this:\n  (\\<And>csp. ch = csp + c \\<Longrightarrow> ?P) \\<Longrightarrow> ?P", "obtain csph where \"ch=csph+c\""], ["proof (prove)\nusing this:\n  (\\<And>csp. ch = csp + c \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csph. ch = csph + c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ch = csph + c\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "moreover"], ["proof (state)\nthis:\n  ch = csph + c\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "from IHP(3)"], ["proof (chain)\npicking this:\n  \\<exists>csp. c' = csp + ch", "obtain csp' where \"c'=csp'+ch\""], ["proof (prove)\nusing this:\n  \\<exists>csp. c' = csp + ch\n\ngoal (1 subgoal):\n 1. (\\<And>csp'. c' = csp' + ch \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c' = csp' + ch\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "ultimately"], ["proof (chain)\npicking this:\n  ch = csph + c\n  c' = csp' + ch", "have \"c'=csp'+csph+c\""], ["proof (prove)\nusing this:\n  ch = csph + c\n  c' = csp' + ch\n\ngoal (1 subgoal):\n 1. c' = csp' + csph + c", "by (simp add: union_assoc)"], ["proof (state)\nthis:\n  c' = csp' + csph + c\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> gtrs;\n        ((ab, ba), w, ac, bb) \\<in> trcl gtrs;\n        \\<exists>csp. bb = csp + ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp. bb = csp + b", "thus ?case"], ["proof (prove)\nusing this:\n  c' = csp' + csph + c\n\ngoal (1 subgoal):\n 1. \\<exists>csp. c' = csp + c", "by blast"], ["proof (state)\nthis:\n  \\<exists>csp. c' = csp + c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((s, c), w, s', c') \\<in> trcl gtrs \\<Longrightarrow>\n  \\<exists>csp. c' = csp + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl gtrs;\n     \\<And>csp. c' = csp + c \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  ((s, c), w, s', c') \\<in> trcl gtrs \\<Longrightarrow>\n  \\<exists>csp. c' = csp + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl gtrs;\n     \\<And>csp. c' = csp + c \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "assume \"((s,c),w,(s',c'))\\<in>trcl gtrs\" \"!! csp. c'=csp+c \\<Longrightarrow> P\""], ["proof (state)\nthis:\n  ((s, c), w, s', c') \\<in> trcl gtrs\n  c' = ?csp + c \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl gtrs;\n     \\<And>csp. c' = csp + c \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  ((s, c), w, s', c') \\<in> trcl gtrs \\<Longrightarrow>\n  \\<exists>csp. c' = csp + c\n  ((s, c), w, s', c') \\<in> trcl gtrs\n  c' = ?csp + c \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, c), w, s', c') \\<in> trcl gtrs \\<Longrightarrow>\n  \\<exists>csp. c' = csp + c\n  ((s, c), w, s', c') \\<in> trcl gtrs\n  c' = ?csp + c \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following lemma can be used to make a case distinction how a step operated on a given thread in the end configuration:\n    \\begin{description}\n      \\item[\\<open>loc\\<close>] The thread made the step\n      \\item[\\<open>spawn\\<close>] The thread was spawned by the step\n      \\item[\\<open>env\\<close>] The thread was not involved in the step\n    \\end{description}\n\\<close>"], ["", "lemma (in env_no_step) rev_cases_p[cases set, case_names loc spawn env]: \n  assumes STEP: \"(c,e,add_mset s' ce')\\<in>gtr gtrs\" and\n  LOC: \"!!s ce. \\<lbrakk> c={#s#}+ce; ((s,ce),e,(s',ce'))\\<in>gtrs \\<rbrakk> \\<Longrightarrow> P\" and\n  SPAWN: \"!!ss ss' ce csp. \n            \\<lbrakk> c=add_mset ss ce; ce'=add_mset ss' (csp+ce); \n              ((ss,ce),e,(ss',add_mset s' (csp+ce)))\\<in>gtrs \\<rbrakk> \n           \\<Longrightarrow> P\" and\n  ENV: \"!!ss ss' ce csp. \n            \\<lbrakk> c=add_mset ss (add_mset s' ce); ce'=add_mset ss' (csp+ce); \n              ((ss,add_mset s' ce),e,(ss',csp+(add_mset s' ce)))\\<in>gtrs \\<rbrakk> \n           \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (rule gtr_rev_cases[OF STEP], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s ce.\n       \\<lbrakk>c = add_mset s ce; ((s, ce), e, s', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>cc ss ss' ce.\n       \\<lbrakk>c = add_mset ss ce; ce' = add_mset ss' cc;\n        ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "case 1"], ["proof (state)\nthis:\n  c = add_mset s_ ce_\n  ((s_, ce_), e, s', ce') \\<in> gtrs\n\ngoal (2 subgoals):\n 1. \\<And>s ce.\n       \\<lbrakk>c = add_mset s ce; ((s, ce), e, s', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>cc ss ss' ce.\n       \\<lbrakk>c = add_mset ss ce; ce' = add_mset ss' cc;\n        ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  c = add_mset s_ ce_\n  ((s_, ce_), e, s', ce') \\<in> gtrs\n\ngoal (1 subgoal):\n 1. P", "using LOC"], ["proof (prove)\nusing this:\n  c = add_mset s_ ce_\n  ((s_, ce_), e, s', ce') \\<in> gtrs\n  \\<lbrakk>c = {#?s#} + ?ce; ((?s, ?ce), e, s', ce') \\<in> gtrs\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce.\n       \\<lbrakk>c = add_mset ss ce; ce' = add_mset ss' cc;\n        ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce.\n       \\<lbrakk>c = add_mset ss ce; ce' = add_mset ss' cc;\n        ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "case CASE: (2 cc ss ss' ce)"], ["proof (state)\nthis:\n  c = add_mset ss ce\n  ce' = add_mset ss' cc\n  ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce.\n       \\<lbrakk>c = add_mset ss ce; ce' = add_mset ss' cc;\n        ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "hence CASE': \"c = {#ss#} + ce\" \"ce' = {#ss'#} + cc\" \"((ss, ce), e, ss', {#s'#} + cc) \\<in> gtrs\""], ["proof (prove)\nusing this:\n  c = add_mset ss ce\n  ce' = add_mset ss' cc\n  ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\n\ngoal (1 subgoal):\n 1. c = {#ss#} + ce &&&\n    ce' = {#ss'#} + cc &&& ((ss, ce), e, ss', {#s'#} + cc) \\<in> gtrs", "by simp_all"], ["proof (state)\nthis:\n  c = {#ss#} + ce\n  ce' = {#ss'#} + cc\n  ((ss, ce), e, ss', {#s'#} + cc) \\<in> gtrs\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce.\n       \\<lbrakk>c = add_mset ss ce; ce' = add_mset ss' cc;\n        ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "from env_no_step_s[OF CASE'(3)]"], ["proof (chain)\npicking this:\n  (\\<And>csp. {#s'#} + cc = csp + ce \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain csp where EQ: \"add_mset s' cc = csp + ce\""], ["proof (prove)\nusing this:\n  (\\<And>csp. {#s'#} + cc = csp + ce \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        add_mset s' cc = csp + ce \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  add_mset s' cc = csp + ce\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce.\n       \\<lbrakk>c = add_mset ss ce; ce' = add_mset ss' cc;\n        ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  add_mset s' cc = csp + ce\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: mset_unplusm_dist_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>csp = add_mset s' (csp - {#s'#});\n     cc = csp - {#s'#} + ce\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "case left"], ["proof (state)\nthis:\n  csp = add_mset s' (csp - {#s'#})\n  cc = csp - {#s'#} + ce\n\ngoal (2 subgoals):\n 1. \\<lbrakk>csp = add_mset s' (csp - {#s'#});\n     cc = csp - {#s'#} + ce\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "note CC=this"], ["proof (state)\nthis:\n  csp = add_mset s' (csp - {#s'#})\n  cc = csp - {#s'#} + ce\n\ngoal (2 subgoals):\n 1. \\<lbrakk>csp = add_mset s' (csp - {#s'#});\n     cc = csp - {#s'#} + ce\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "with CASE'"], ["proof (chain)\npicking this:\n  c = {#ss#} + ce\n  ce' = {#ss'#} + cc\n  ((ss, ce), e, ss', {#s'#} + cc) \\<in> gtrs\n  csp = add_mset s' (csp - {#s'#})\n  cc = csp - {#s'#} + ce", "have \"ce'={#ss'#} + (csp-{#s'#}) + ce\""], ["proof (prove)\nusing this:\n  c = {#ss#} + ce\n  ce' = {#ss'#} + cc\n  ((ss, ce), e, ss', {#s'#} + cc) \\<in> gtrs\n  csp = add_mset s' (csp - {#s'#})\n  cc = csp - {#s'#} + ce\n\ngoal (1 subgoal):\n 1. ce' = {#ss'#} + (csp - {#s'#}) + ce", "by (auto simp add: union_assoc)"], ["proof (state)\nthis:\n  ce' = {#ss'#} + (csp - {#s'#}) + ce\n\ngoal (2 subgoals):\n 1. \\<lbrakk>csp = add_mset s' (csp - {#s'#});\n     cc = csp - {#s'#} + ce\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  ce' = {#ss'#} + (csp - {#s'#}) + ce\n\ngoal (2 subgoals):\n 1. \\<lbrakk>csp = add_mset s' (csp - {#s'#});\n     cc = csp - {#s'#} + ce\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "from CC(2)"], ["proof (chain)\npicking this:\n  cc = csp - {#s'#} + ce", "have \"{#s'#}+cc = {#s'#} + (csp-{#s'#}) + ce\""], ["proof (prove)\nusing this:\n  cc = csp - {#s'#} + ce\n\ngoal (1 subgoal):\n 1. {#s'#} + cc = {#s'#} + (csp - {#s'#}) + ce", "by (simp add: union_assoc)"], ["proof (state)\nthis:\n  {#s'#} + cc = {#s'#} + (csp - {#s'#}) + ce\n\ngoal (2 subgoals):\n 1. \\<lbrakk>csp = add_mset s' (csp - {#s'#});\n     cc = csp - {#s'#} + ce\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  ce' = {#ss'#} + (csp - {#s'#}) + ce\n  {#s'#} + cc = {#s'#} + (csp - {#s'#}) + ce", "show ?thesis"], ["proof (prove)\nusing this:\n  ce' = {#ss'#} + (csp - {#s'#}) + ce\n  {#s'#} + cc = {#s'#} + (csp - {#s'#}) + ce\n\ngoal (1 subgoal):\n 1. P", "using CASE'(1,3) CASE(2) SPAWN"], ["proof (prove)\nusing this:\n  ce' = {#ss'#} + (csp - {#s'#}) + ce\n  {#s'#} + cc = {#s'#} + (csp - {#s'#}) + ce\n  c = {#ss#} + ce\n  ((ss, ce), e, ss', {#s'#} + cc) \\<in> gtrs\n  ce' = add_mset ss' cc\n  \\<lbrakk>c = add_mset ?ss ?ce; ce' = add_mset ?ss' (?csp + ?ce);\n   ((?ss, ?ce), e, ?ss', add_mset s' (?csp + ?ce)) \\<in> gtrs\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "case right"], ["proof (state)\nthis:\n  ce = add_mset s' (ce - {#s'#})\n  cc = csp + (ce - {#s'#})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "note CC=this"], ["proof (state)\nthis:\n  ce = add_mset s' (ce - {#s'#})\n  cc = csp + (ce - {#s'#})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "from CC(1) CASE'(1)"], ["proof (chain)\npicking this:\n  ce = add_mset s' (ce - {#s'#})\n  c = {#ss#} + ce", "have \"c=add_mset ss (add_mset s' (ce - {#s'#}))\""], ["proof (prove)\nusing this:\n  ce = add_mset s' (ce - {#s'#})\n  c = {#ss#} + ce\n\ngoal (1 subgoal):\n 1. c = add_mset ss (add_mset s' (ce - {#s'#}))", "by (simp add: union_assoc)"], ["proof (state)\nthis:\n  c = add_mset ss (add_mset s' (ce - {#s'#}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  c = add_mset ss (add_mset s' (ce - {#s'#}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "from CC(2) CASE'(2)"], ["proof (chain)\npicking this:\n  cc = csp + (ce - {#s'#})\n  ce' = {#ss'#} + cc", "have \"ce'=add_mset ss' (csp+(ce-{#s'#}))\""], ["proof (prove)\nusing this:\n  cc = csp + (ce - {#s'#})\n  ce' = {#ss'#} + cc\n\ngoal (1 subgoal):\n 1. ce' = add_mset ss' (csp + (ce - {#s'#}))", "by (simp add: union_assoc)"], ["proof (state)\nthis:\n  ce' = add_mset ss' (csp + (ce - {#s'#}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  ce' = add_mset ss' (csp + (ce - {#s'#}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "from CC(2)"], ["proof (chain)\npicking this:\n  cc = csp + (ce - {#s'#})", "have \"add_mset s' cc = csp+(add_mset s' (ce-{#s'#}))\""], ["proof (prove)\nusing this:\n  cc = csp + (ce - {#s'#})\n\ngoal (1 subgoal):\n 1. add_mset s' cc = csp + add_mset s' (ce - {#s'#})", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  add_mset s' cc = csp + add_mset s' (ce - {#s'#})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce = add_mset s' (ce - {#s'#});\n     cc = csp + (ce - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  c = add_mset ss (add_mset s' (ce - {#s'#}))\n  ce' = add_mset ss' (csp + (ce - {#s'#}))\n  add_mset s' cc = csp + add_mset s' (ce - {#s'#})", "show ?thesis"], ["proof (prove)\nusing this:\n  c = add_mset ss (add_mset s' (ce - {#s'#}))\n  ce' = add_mset ss' (csp + (ce - {#s'#}))\n  add_mset s' cc = csp + add_mset s' (ce - {#s'#})\n\ngoal (1 subgoal):\n 1. P", "using CASE'(3) CASE(3) CC(1) ENV"], ["proof (prove)\nusing this:\n  c = add_mset ss (add_mset s' (ce - {#s'#}))\n  ce' = add_mset ss' (csp + (ce - {#s'#}))\n  add_mset s' cc = csp + add_mset s' (ce - {#s'#})\n  ((ss, ce), e, ss', {#s'#} + cc) \\<in> gtrs\n  ((ss, ce), e, ss', add_mset s' cc) \\<in> gtrs\n  ce = add_mset s' (ce - {#s'#})\n  \\<lbrakk>c = add_mset ?ss (add_mset s' ?ce);\n   ce' = add_mset ?ss' (?csp + ?ce);\n   ((?ss, add_mset s' ?ce), e, ?ss', ?csp + add_mset s' ?ce)\n   \\<in> gtrs\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by metis"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Explicit local context\""], ["", "text_raw \\<open>\\label{sec:ThreadTracking:exp_local}\\<close>"], ["", "text \\<open>\n  In the multiset semantics, a single thread has no identity. This may become a problem when reasoning about a fixed thread during an execution. For example, in our constraint-system-based approach\n  the operational characterization of the least solution of the constraint system requires to state properties of the steps of the initial thread in some execution. With the multiset semantics, we are unable \n  to identify those steps among all steps.\n\n  There are many solutions to this problem, for example, using thread ids either as part of the thread's configuration or as part of the whole configuration by using \n  lists of stacks or maps from ids to stacks as configuration datatype. \n\n  In the following we present a special solution that is strong enough to suit our purposes but not meant as a general solution. \n\n  Instead of identifying every single thread uniquely, we only distinguish one thread as the {\\em local} thread. The other\n  threads are {\\em environment} threads. We then attach to every step the information whether it was on the local or on some environment thread. \n\n  We call this semantics {\\em loc/env}-semantics in contrast to the {\\em multiset}-semantics of the last section.\n\\<close>"], ["", "subsubsection \"Lifted step datatype\""], ["", "datatype 'a el_step = LOC 'a | ENV 'a"], ["", "definition\n  \"loc w == filter (\\<lambda>e. case e of LOC a \\<Rightarrow> True | ENV a \\<Rightarrow> False) w\""], ["", "definition\n  \"env w == filter (\\<lambda>e. case e of LOC a \\<Rightarrow> False | ENV a \\<Rightarrow> True) w\""], ["", "definition\n  \"le_rem_s e == case e of LOC a \\<Rightarrow> a | ENV a \\<Rightarrow> a\""], ["", "text \\<open>Standard simplification lemmas\\<close>"], ["", "lemma loc_env_simps[simp]: \n  \"loc [] = []\" \n  \"env [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc [] = [] &&& env [] = []", "by (unfold loc_def env_def) auto"], ["", "lemma loc_single[simp]: \"loc [a] = (case a of LOC e \\<Rightarrow> [a] | ENV e \\<Rightarrow> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc [a] = (case a of LOC e \\<Rightarrow> [a] | ENV e \\<Rightarrow> [])", "by (unfold loc_def) (auto split: el_step.split)"], ["", "lemma loc_uncons[simp]: \n  \"loc (a#b) = (case a of LOC e \\<Rightarrow> [a] | ENV e \\<Rightarrow> [])@loc b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc (a # b) =\n    (case a of LOC e \\<Rightarrow> [a] | ENV e \\<Rightarrow> []) @ loc b", "by (unfold loc_def) (auto split: el_step.split)"], ["", "lemma loc_unconc[simp]: \"loc (a@b) = loc a @ loc b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc (a @ b) = loc a @ loc b", "by (unfold loc_def, simp)"], ["", "lemma env_single[simp]: \"env [a] = (case a of LOC e \\<Rightarrow> [] | ENV e \\<Rightarrow> [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env [a] = (case a of LOC e \\<Rightarrow> [] | ENV e \\<Rightarrow> [a])", "by (unfold env_def) (auto split: el_step.split)"], ["", "lemma env_uncons[simp]: \n  \"env (a#b) = (case a of LOC e \\<Rightarrow> [] | ENV e \\<Rightarrow> [a]) @ env b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env (a # b) =\n    (case a of LOC e \\<Rightarrow> [] | ENV e \\<Rightarrow> [a]) @ env b", "by (unfold env_def) (auto split: el_step.split)"], ["", "lemma env_unconc[simp]: \"env (a@b) = env a @ env b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env (a @ b) = env a @ env b", "by (unfold env_def, simp)"], ["", "text \\<open>The following simplification lemmas are for converting between paths of the multiset- and loc/env-semantics\\<close>"], ["", "lemma le_rem_simps [simp]: \n  \"le_rem_s (LOC a) = a\" \n  \"le_rem_s (ENV a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_rem_s (LOC a) = a &&& le_rem_s (ENV a) = a", "by (unfold le_rem_s_def, auto)"], ["", "lemma le_rem_id_simps[simp]: \n  \"le_rem_s\\<circ>LOC = id\" \n  \"le_rem_s\\<circ>ENV = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_rem_s \\<circ> LOC = id &&& le_rem_s \\<circ> ENV = id", "by (auto intro: ext)"], ["", "lemma le_rem_id_map[simp]: \n  \"map le_rem_s (map LOC w) = w\" \n  \"map le_rem_s (map ENV w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map le_rem_s (map LOC w) = w &&& map le_rem_s (map ENV w) = w", "by auto"], ["", "lemma env_map_env [simp]: \"env (map ENV w) = map ENV w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env (map ENV w) = map ENV w", "by (unfold env_def) simp"], ["", "lemma env_map_loc [simp]: \"env (map LOC w) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env (map LOC w) = []", "by (unfold env_def) simp"], ["", "lemma loc_map_env [simp]: \"loc (map ENV w) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc (map ENV w) = []", "by (unfold loc_def) simp"], ["", "lemma loc_map_loc [simp]: \"loc (map LOC w) = map LOC w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc (map LOC w) = map LOC w", "by (unfold loc_def) simp"], ["", "subsubsection \"Definition of the loc/env-semantics\""], ["", "type_synonym 's el_conf = \"('s \\<times> 's multiset)\""], ["", "inductive_set\n  gtrp :: \"('s el_conf,'l) LTS \\<Rightarrow> ('s el_conf,'l el_step) LTS\"\n  for S\n  where\n  gtrp_loc: \"((s,c),e,(s',c'))\\<in>S \\<Longrightarrow> ((s,c),LOC e,(s',c'))\\<in>gtrp S\"\n  | gtrp_env: \"((s,add_mset sl c),e,(s',add_mset sl c'))\\<in>S\n               \\<Longrightarrow> ((sl,add_mset s c),ENV e,(sl,add_mset s' c'))\\<in>gtrp S\""], ["", "subsubsection \"Relation between multiset- and loc/env-semantics\""], ["", "lemma gtrp2gtr_s: \n  \"((s,c),e,(s',c'))\\<in>gtrp T \\<Longrightarrow> (add_mset s c,le_rem_s e,add_mset s' c')\\<in>gtr T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> gtrp T \\<Longrightarrow>\n    (add_mset s c, le_rem_s e, add_mset s' c') \\<in> gtr T", "proof (cases rule: gtrp.cases, auto intro: gtrI_s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa ca ea s'a c'a.\n       \\<lbrakk>((s, add_mset sa ca), ENV ea, s, add_mset s'a c'a)\n                \\<in> gtrp T;\n        e = ENV ea; s' = s; c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), ea, s'a, add_mset s c'a) \\<in> T;\n        c = add_mset sa ca\\<rbrakk>\n       \\<Longrightarrow> (add_mset s (add_mset sa ca), ea,\n                          add_mset s (add_mset s'a c'a))\n                         \\<in> gtr T", "fix c c' e ss ss'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa ca ea s'a c'a.\n       \\<lbrakk>((s, add_mset sa ca), ENV ea, s, add_mset s'a c'a)\n                \\<in> gtrp T;\n        e = ENV ea; s' = s; c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), ea, s'a, add_mset s c'a) \\<in> T;\n        c = add_mset sa ca\\<rbrakk>\n       \\<Longrightarrow> (add_mset s (add_mset sa ca), ea,\n                          add_mset s (add_mset s'a c'a))\n                         \\<in> gtr T", "assume \"((ss,add_mset s c),e,(ss',add_mset s c'))\\<in>T\""], ["proof (state)\nthis:\n  ((ss, add_mset s c), e, ss', add_mset s c') \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>sa ca ea s'a c'a.\n       \\<lbrakk>((s, add_mset sa ca), ENV ea, s, add_mset s'a c'a)\n                \\<in> gtrp T;\n        e = ENV ea; s' = s; c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), ea, s'a, add_mset s c'a) \\<in> T;\n        c = add_mset sa ca\\<rbrakk>\n       \\<Longrightarrow> (add_mset s (add_mset sa ca), ea,\n                          add_mset s (add_mset s'a c'a))\n                         \\<in> gtr T", "hence \"(add_mset ss (add_mset s c),e,add_mset ss' (add_mset s c')) \\<in> gtr T\""], ["proof (prove)\nusing this:\n  ((ss, add_mset s c), e, ss', add_mset s c') \\<in> T\n\ngoal (1 subgoal):\n 1. (add_mset ss (add_mset s c), e, add_mset ss' (add_mset s c'))\n    \\<in> gtr T", "by (auto intro!: gtrI_s)"], ["proof (state)\nthis:\n  (add_mset ss (add_mset s c), e, add_mset ss' (add_mset s c')) \\<in> gtr T\n\ngoal (1 subgoal):\n 1. \\<And>sa ca ea s'a c'a.\n       \\<lbrakk>((s, add_mset sa ca), ENV ea, s, add_mset s'a c'a)\n                \\<in> gtrp T;\n        e = ENV ea; s' = s; c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), ea, s'a, add_mset s c'a) \\<in> T;\n        c = add_mset sa ca\\<rbrakk>\n       \\<Longrightarrow> (add_mset s (add_mset sa ca), ea,\n                          add_mset s (add_mset s'a c'a))\n                         \\<in> gtr T", "thus \"(add_mset s (add_mset ss c), e, add_mset s (add_mset ss' c')) \\<in> gtr T\""], ["proof (prove)\nusing this:\n  (add_mset ss (add_mset s c), e, add_mset ss' (add_mset s c')) \\<in> gtr T\n\ngoal (1 subgoal):\n 1. (add_mset s (add_mset ss c), e, add_mset s (add_mset ss' c'))\n    \\<in> gtr T", "by (auto simp add: add_mset_commute)"], ["proof (state)\nthis:\n  (add_mset s (add_mset ss c), e, add_mset s (add_mset ss' c')) \\<in> gtr T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gtrp2gtr: \n  \"((s,c),w,(s',c'))\\<in>trcl (gtrp T) \n  \\<Longrightarrow> (add_mset s c,map le_rem_s w,add_mset s' c')\\<in>trcl (gtr T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (gtrp T) \\<Longrightarrow>\n    (add_mset s c, map le_rem_s w, add_mset s' c') \\<in> trcl (gtr T)", "by (induct rule: trcl_pair_induct) (auto dest: gtrp2gtr_s)"], ["", "lemma (in env_no_step) gtr2gtrp_s[cases set, case_names gtrp]: \n  assumes A: \"(add_mset s c,e,c')\\<in>gtr gtrs\" \n  and CASE: \"!!s' ce' ee. \\<lbrakk>c'=add_mset s' ce'; e=le_rem_s ee; \n                          ((s,c),ee,(s',ce'))\\<in>gtrp gtrs\\<rbrakk> \n                         \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A"], ["proof (prove)\nusing this:\n  (add_mset s c, e, c') \\<in> gtr gtrs\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: gtr_step_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' ce'.\n       \\<lbrakk>c' = add_mset s' ce';\n        ((s, c), e, s', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "case (loc s' ce')"], ["proof (state)\nthis:\n  c' = add_mset s' ce'\n  ((s, c), e, s', ce') \\<in> gtrs\n\ngoal (2 subgoals):\n 1. \\<And>s' ce'.\n       \\<lbrakk>c' = add_mset s' ce';\n        ((s, c), e, s', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "hence \"((s,c),LOC e,(s',ce'))\\<in>gtrp gtrs\""], ["proof (prove)\nusing this:\n  c' = add_mset s' ce'\n  ((s, c), e, s', ce') \\<in> gtrs\n\ngoal (1 subgoal):\n 1. ((s, c), LOC e, s', ce') \\<in> gtrp gtrs", "by (blast intro: gtrp_loc)"], ["proof (state)\nthis:\n  ((s, c), LOC e, s', ce') \\<in> gtrp gtrs\n\ngoal (2 subgoals):\n 1. \\<And>s' ce'.\n       \\<lbrakk>c' = add_mset s' ce';\n        ((s, c), e, s', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "with loc(1)"], ["proof (chain)\npicking this:\n  c' = add_mset s' ce'\n  ((s, c), LOC e, s', ce') \\<in> gtrp gtrs", "show ?thesis"], ["proof (prove)\nusing this:\n  c' = add_mset s' ce'\n  ((s, c), LOC e, s', ce') \\<in> gtrp gtrs\n\ngoal (1 subgoal):\n 1. P", "by (rule_tac CASE) auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "case (other cc ss ss' ce')"], ["proof (state)\nthis:\n  c = add_mset ss cc\n  c' = add_mset ss' ce'\n  ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "from env_no_step_s[OF other(3)]"], ["proof (chain)\npicking this:\n  (\\<And>csp.\n      ce' = csp + add_mset s cc \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain csp where CE'FMT: \"ce'=csp + (add_mset s cc)\""], ["proof (prove)\nusing this:\n  (\\<And>csp.\n      ce' = csp + add_mset s cc \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        ce' = csp + add_mset s cc \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  ce' = csp + add_mset s cc\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "with other(3)"], ["proof (chain)\npicking this:\n  ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\n  ce' = csp + add_mset s cc", "have \"((ss,add_mset s cc),e,(ss',add_mset s (csp+cc)))\\<in>gtrs\""], ["proof (prove)\nusing this:\n  ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\n  ce' = csp + add_mset s cc\n\ngoal (1 subgoal):\n 1. ((ss, add_mset s cc), e, ss', add_mset s (csp + cc)) \\<in> gtrs", "by auto"], ["proof (state)\nthis:\n  ((ss, add_mset s cc), e, ss', add_mset s (csp + cc)) \\<in> gtrs\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "from gtrp_env[OF this] other(1)"], ["proof (chain)\npicking this:\n  ((s, add_mset ss cc), ENV e, s, add_mset ss' (csp + cc)) \\<in> gtrp gtrs\n  c = add_mset ss cc", "have \"((s, c), ENV e, s, {#ss'#} + (csp + cc)) \\<in> gtrp gtrs\""], ["proof (prove)\nusing this:\n  ((s, add_mset ss cc), ENV e, s, add_mset ss' (csp + cc)) \\<in> gtrp gtrs\n  c = add_mset ss cc\n\ngoal (1 subgoal):\n 1. ((s, c), ENV e, s, {#ss'#} + (csp + cc)) \\<in> gtrp gtrs", "by simp"], ["proof (state)\nthis:\n  ((s, c), ENV e, s, {#ss'#} + (csp + cc)) \\<in> gtrp gtrs\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  ((s, c), ENV e, s, {#ss'#} + (csp + cc)) \\<in> gtrp gtrs\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "from other CE'FMT"], ["proof (chain)\npicking this:\n  c = add_mset ss cc\n  c' = add_mset ss' ce'\n  ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\n  ce' = csp + add_mset s cc", "have \"c' = {#s#} + ({#ss'#} + (csp + cc))\""], ["proof (prove)\nusing this:\n  c = add_mset ss cc\n  c' = add_mset ss' ce'\n  ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\n  ce' = csp + add_mset s cc\n\ngoal (1 subgoal):\n 1. c' = {#s#} + ({#ss'#} + (csp + cc))", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  c' = {#s#} + ({#ss'#} + (csp + cc))\n\ngoal (1 subgoal):\n 1. \\<And>cc ss ss' ce'.\n       \\<lbrakk>c = add_mset ss cc; c' = add_mset ss' ce';\n        ((ss, add_mset s cc), e, ss', ce') \\<in> gtrs\\<rbrakk>\n       \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  ((s, c), ENV e, s, {#ss'#} + (csp + cc)) \\<in> gtrp gtrs\n  c' = {#s#} + ({#ss'#} + (csp + cc))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, c), ENV e, s, {#ss'#} + (csp + cc)) \\<in> gtrp gtrs\n  c' = {#s#} + ({#ss'#} + (csp + cc))\n\ngoal (1 subgoal):\n 1. P", "by (rule_tac CASE) auto"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in env_no_step) gtr2gtrp[cases set, case_names gtrp]: \n  assumes A: \"(add_mset s c,w,c')\\<in>trcl (gtr gtrs)\" \n  and CASE: \"!!s' ce' ww. \\<lbrakk>c'=add_mset s' ce'; w=map le_rem_s ww; \n                           ((s,c),ww,(s',ce'))\\<in>trcl (gtrp gtrs)\\<rbrakk> \n                          \\<Longrightarrow> P\" \n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have \"!!s c. (add_mset s c,w,c')\\<in>trcl (gtr gtrs) \\<Longrightarrow> \\<exists>s' ce' ww. c'=add_mset s' ce' \\<and> w=map le_rem_s ww \\<and> ((s,c),ww,(s',ce'))\\<in>trcl (gtrp gtrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c.\n       (add_mset s c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n       \\<exists>s' ce' ww.\n          c' = add_mset s' ce' \\<and>\n          w = map le_rem_s ww \\<and>\n          ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "proof (induct w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s c.\n       (add_mset s c, [], c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n       \\<exists>s' ce' ww.\n          c' = add_mset s' ce' \\<and>\n          [] = map le_rem_s ww \\<and>\n          ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "case Nil"], ["proof (state)\nthis:\n  (add_mset s c, [], c') \\<in> trcl (gtr gtrs)\n\ngoal (2 subgoals):\n 1. \\<And>s c.\n       (add_mset s c, [], c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n       \\<exists>s' ce' ww.\n          c' = add_mset s' ce' \\<and>\n          [] = map le_rem_s ww \\<and>\n          ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "thus ?case"], ["proof (prove)\nusing this:\n  (add_mset s c, [], c') \\<in> trcl (gtr gtrs)\n\ngoal (1 subgoal):\n 1. \\<exists>s' ce' ww.\n       c' = add_mset s' ce' \\<and>\n       [] = map le_rem_s ww \\<and>\n       ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     [] = map le_rem_s ww \\<and>\n     ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "case (Cons e w)"], ["proof (state)\nthis:\n  (add_mset ?s ?c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     w = map le_rem_s ww \\<and>\n     ((?s, ?c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n  (add_mset s c, e # w, c') \\<in> trcl (gtr gtrs)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "then"], ["proof (chain)\npicking this:\n  (add_mset ?s ?c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     w = map le_rem_s ww \\<and>\n     ((?s, ?c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n  (add_mset s c, e # w, c') \\<in> trcl (gtr gtrs)", "obtain ch where SPLIT: \"(add_mset s c,e,ch)\\<in>gtr gtrs\" \"(ch,w,c')\\<in>trcl (gtr gtrs)\""], ["proof (prove)\nusing this:\n  (add_mset ?s ?c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     w = map le_rem_s ww \\<and>\n     ((?s, ?c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n  (add_mset s c, e # w, c') \\<in> trcl (gtr gtrs)\n\ngoal (1 subgoal):\n 1. (\\<And>ch.\n        \\<lbrakk>(add_mset s c, e, ch) \\<in> gtr gtrs;\n         (ch, w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: trcl_uncons)"], ["proof (state)\nthis:\n  (add_mset s c, e, ch) \\<in> gtr gtrs\n  (ch, w, c') \\<in> trcl (gtr gtrs)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "from gtr2gtrp_s[OF SPLIT(1)]"], ["proof (chain)\npicking this:\n  (\\<And>s' ce' ee.\n      \\<lbrakk>ch = add_mset s' ce'; e = le_rem_s ee;\n       ((s, c), ee, s', ce') \\<in> gtrp gtrs\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain sh ceh ee where FS: \"ch = add_mset sh  ceh\" \"e = le_rem_s ee\" \"((s, c), ee, sh, ceh) \\<in> gtrp gtrs\""], ["proof (prove)\nusing this:\n  (\\<And>s' ce' ee.\n      \\<lbrakk>ch = add_mset s' ce'; e = le_rem_s ee;\n       ((s, c), ee, s', ce') \\<in> gtrp gtrs\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>sh ceh ee.\n        \\<lbrakk>ch = add_mset sh ceh; e = le_rem_s ee;\n         ((s, c), ee, sh, ceh) \\<in> gtrp gtrs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ch = add_mset sh ceh\n  e = le_rem_s ee\n  ((s, c), ee, sh, ceh) \\<in> gtrp gtrs\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "moreover"], ["proof (state)\nthis:\n  ch = add_mset sh ceh\n  e = le_rem_s ee\n  ((s, c), ee, sh, ceh) \\<in> gtrp gtrs\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "from FS(1) SPLIT(2) Cons.hyps"], ["proof (chain)\npicking this:\n  ch = add_mset sh ceh\n  (ch, w, c') \\<in> trcl (gtr gtrs)\n  (add_mset ?s ?c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     w = map le_rem_s ww \\<and>\n     ((?s, ?c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "obtain s' ce' ww where IH: \"c'=add_mset s' ce'\" \"w=map le_rem_s ww\" \"((sh,ceh),ww,(s',ce'))\\<in>trcl (gtrp gtrs)\""], ["proof (prove)\nusing this:\n  ch = add_mset sh ceh\n  (ch, w, c') \\<in> trcl (gtr gtrs)\n  (add_mset ?s ?c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     w = map le_rem_s ww \\<and>\n     ((?s, ?c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n\ngoal (1 subgoal):\n 1. (\\<And>s' ce' ww.\n        \\<lbrakk>c' = add_mset s' ce'; w = map le_rem_s ww;\n         ((sh, ceh), ww, s', ce') \\<in> trcl (gtrp gtrs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c' = add_mset s' ce'\n  w = map le_rem_s ww\n  ((sh, ceh), ww, s', ce') \\<in> trcl (gtrp gtrs)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "ultimately"], ["proof (chain)\npicking this:\n  ch = add_mset sh ceh\n  e = le_rem_s ee\n  ((s, c), ee, sh, ceh) \\<in> gtrp gtrs\n  c' = add_mset s' ce'\n  w = map le_rem_s ww\n  ((sh, ceh), ww, s', ce') \\<in> trcl (gtrp gtrs)", "have \"((s,c),ee#ww,(s',ce'))\\<in>trcl (gtrp gtrs)\" \"e#w = map le_rem_s (ee#ww)\""], ["proof (prove)\nusing this:\n  ch = add_mset sh ceh\n  e = le_rem_s ee\n  ((s, c), ee, sh, ceh) \\<in> gtrp gtrs\n  c' = add_mset s' ce'\n  w = map le_rem_s ww\n  ((sh, ceh), ww, s', ce') \\<in> trcl (gtrp gtrs)\n\ngoal (1 subgoal):\n 1. ((s, c), ee # ww, s', ce') \\<in> trcl (gtrp gtrs) &&&\n    e # w = map le_rem_s (ee # ww)", "by auto"], ["proof (state)\nthis:\n  ((s, c), ee # ww, s', ce') \\<in> trcl (gtrp gtrs)\n  e # w = map le_rem_s (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   (add_mset s c, w, c')\n                   \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n                   \\<exists>s' ce' ww.\n                      c' = add_mset s' ce' \\<and>\n                      w = map le_rem_s ww \\<and>\n                      ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs);\n        (add_mset s c, a # w, c') \\<in> trcl (gtr gtrs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' ce' ww.\n                            c' = add_mset s' ce' \\<and>\n                            a # w = map le_rem_s ww \\<and>\n                            ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "with IH(1)"], ["proof (chain)\npicking this:\n  c' = add_mset s' ce'\n  ((s, c), ee # ww, s', ce') \\<in> trcl (gtrp gtrs)\n  e # w = map le_rem_s (ee # ww)", "show ?case"], ["proof (prove)\nusing this:\n  c' = add_mset s' ce'\n  ((s, c), ee # ww, s', ce') \\<in> trcl (gtrp gtrs)\n  e # w = map le_rem_s (ee # ww)\n\ngoal (1 subgoal):\n 1. \\<exists>s' ce' ww.\n       c' = add_mset s' ce' \\<and>\n       e # w = map le_rem_s ww \\<and>\n       ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "by iprover"], ["proof (state)\nthis:\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     e # w = map le_rem_s ww \\<and>\n     ((s, c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (add_mset ?s ?c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     w = map le_rem_s ww \\<and>\n     ((?s, ?c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n\ngoal (1 subgoal):\n 1. P", "with A CASE"], ["proof (chain)\npicking this:\n  (add_mset s c, w, c') \\<in> trcl (gtr gtrs)\n  \\<lbrakk>c' = add_mset ?s' ?ce'; w = map le_rem_s ?ww;\n   ((s, c), ?ww, ?s', ?ce') \\<in> trcl (gtrp gtrs)\\<rbrakk>\n  \\<Longrightarrow> P\n  (add_mset ?s ?c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     w = map le_rem_s ww \\<and>\n     ((?s, ?c), ww, s', ce') \\<in> trcl (gtrp gtrs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (add_mset s c, w, c') \\<in> trcl (gtr gtrs)\n  \\<lbrakk>c' = add_mset ?s' ?ce'; w = map le_rem_s ?ww;\n   ((s, c), ?ww, ?s', ?ce') \\<in> trcl (gtrp gtrs)\\<rbrakk>\n  \\<Longrightarrow> P\n  (add_mset ?s ?c, w, c') \\<in> trcl (gtr gtrs) \\<Longrightarrow>\n  \\<exists>s' ce' ww.\n     c' = add_mset s' ce' \\<and>\n     w = map le_rem_s ww \\<and>\n     ((?s, ?c), ww, s', ce') \\<in> trcl (gtrp gtrs)\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Invariants\""], ["", "lemma gtrp_preserve_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>gtrp T\" \n  and INIT: \"P (add_mset s c)\" \n  and PRES: \"!!s c s' c' e. \\<lbrakk>P (add_mset s c); ((s,c),e,(s',c'))\\<in>T\\<rbrakk> \n                            \\<Longrightarrow> P (add_mset s' c')\" \n  shows \"P (add_mset s' c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (add_mset s' c')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (add_mset s' c')", "from gtr_preserve_s[OF gtrp2gtr_s[OF A], where P=P, OF INIT] PRES"], ["proof (chain)\npicking this:\n  (\\<And>s c s' c' e.\n      \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n      \\<Longrightarrow> P (add_mset s' c')) \\<Longrightarrow>\n  P (add_mset s' c')\n  \\<lbrakk>P (add_mset ?s ?c); ((?s, ?c), ?e, ?s', ?c') \\<in> T\\<rbrakk>\n  \\<Longrightarrow> P (add_mset ?s' ?c')", "show \"P (add_mset s' c')\""], ["proof (prove)\nusing this:\n  (\\<And>s c s' c' e.\n      \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n      \\<Longrightarrow> P (add_mset s' c')) \\<Longrightarrow>\n  P (add_mset s' c')\n  \\<lbrakk>P (add_mset ?s ?c); ((?s, ?c), ?e, ?s', ?c') \\<in> T\\<rbrakk>\n  \\<Longrightarrow> P (add_mset ?s' ?c')\n\ngoal (1 subgoal):\n 1. P (add_mset s' c')", "by blast"], ["proof (state)\nthis:\n  P (add_mset s' c')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gtrp_preserve: \n  assumes A: \"((s,c),w,(s',c'))\\<in>trcl (gtrp T)\" \n  and INIT: \"P (add_mset s c)\" \n  and PRES: \"!!s c s' c' e. \\<lbrakk>P (add_mset s c); ((s,c),e,(s',c'))\\<in>T\\<rbrakk> \n                            \\<Longrightarrow> P (add_mset s' c')\" \n  shows \"P (add_mset s' c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (add_mset s' c')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (add_mset s' c')", "from gtr_preserve[OF gtrp2gtr[OF A], where P=P, OF INIT] PRES"], ["proof (chain)\npicking this:\n  (\\<And>s c s' c' e.\n      \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n      \\<Longrightarrow> P (add_mset s' c')) \\<Longrightarrow>\n  P (add_mset s' c')\n  \\<lbrakk>P (add_mset ?s ?c); ((?s, ?c), ?e, ?s', ?c') \\<in> T\\<rbrakk>\n  \\<Longrightarrow> P (add_mset ?s' ?c')", "show \"P (add_mset s' c')\""], ["proof (prove)\nusing this:\n  (\\<And>s c s' c' e.\n      \\<lbrakk>P (add_mset s c); ((s, c), e, s', c') \\<in> T\\<rbrakk>\n      \\<Longrightarrow> P (add_mset s' c')) \\<Longrightarrow>\n  P (add_mset s' c')\n  \\<lbrakk>P (add_mset ?s ?c); ((?s, ?c), ?e, ?s', ?c') \\<in> T\\<rbrakk>\n  \\<Longrightarrow> P (add_mset ?s' ?c')\n\ngoal (1 subgoal):\n 1. P (add_mset s' c')", "by blast"], ["proof (state)\nthis:\n  P (add_mset s' c')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}