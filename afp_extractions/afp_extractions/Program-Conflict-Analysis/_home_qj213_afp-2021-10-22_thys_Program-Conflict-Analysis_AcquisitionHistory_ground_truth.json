{"file_name": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis/AcquisitionHistory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis", "problem_names": ["lemma ah_cases[cases set]: \"\\<lbrakk>h\\<in>ah; h m = {} \\<Longrightarrow> P ; m \\<in> h m \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma ah_il_lockset_disjoint: \n  \"\\<lbrakk> h1\\<in>ah; h2\\<in>ah; h1 [*] h2 \\<rbrakk> \\<Longrightarrow> h1 m = {} \\<or> h2 m = {}\"", "lemma ah_il_commute: \"h1 [*] h2 \\<Longrightarrow> h2 [*] h1\"", "lemma ah_leq_il: \"\\<lbrakk> h1 [*] h2; h1' \\<le> h1; h2' \\<le> h2 \\<rbrakk> \\<Longrightarrow> h1' [*] h2'\"", "lemma ah_leq_il_left: \"\\<lbrakk> h1 [*] h2; h1' \\<le> h1 \\<rbrakk> \\<Longrightarrow> h1' [*] h2\" and \n      ah_leq_il_right: \"\\<lbrakk> h1 [*] h2; h2' \\<le> h2 \\<rbrakk> \\<Longrightarrow> h1 [*] h2'\"", "lemma \\<alpha>ah_ah: \"\\<alpha>ah w \\<in> ah\"", "lemma \\<alpha>ah_hd: \"\\<lbrakk>m\\<in>fst e; x\\<in>fst e \\<union> snd e \\<union> mon_pl w\\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha>ah (e#w) m\"", "lemma \\<alpha>ah_tl: \"\\<lbrakk>m\\<notin>fst e; x\\<in>\\<alpha>ah w m\\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha>ah (e#w) m\"", "lemma \\<alpha>ah_cases[cases set, case_names hd tl]: \"\\<lbrakk>\n    x\\<in>\\<alpha>ah w m; \n    !!e w'. \\<lbrakk>w=e#w'; m\\<in>fst e; x\\<in>fst e \\<union> snd e \\<union> mon_pl w'\\<rbrakk> \\<Longrightarrow> P; \n    !!e w'. \\<lbrakk>w=e#w'; m\\<notin>fst e; x\\<in>\\<alpha>ah w' m\\<rbrakk> \\<Longrightarrow> P\n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma \\<alpha>ah_cons_cases[cases set, case_names hd tl]: \"\\<lbrakk>\n    x\\<in>\\<alpha>ah (e#w') m;  \n    \\<lbrakk>m\\<in>fst e; x\\<in>fst e \\<union> snd e \\<union> mon_pl w'\\<rbrakk> \\<Longrightarrow> P; \n    \\<lbrakk>m\\<notin>fst e; x\\<in>\\<alpha>ah w' m\\<rbrakk> \\<Longrightarrow> P\n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma mon_ah_subset: \"mon_ah (\\<alpha>ah w) \\<subseteq> mon_pl w\"", "lemma \\<alpha>ah_ileq: \"w1\\<preceq>w2 \\<Longrightarrow> \\<alpha>ah w1 \\<le> \\<alpha>ah w2\"", "lemma ah_interleavable1: \n  \"w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\" \n  \\<comment> \\<open>The lemma is shown by induction on the structure of the monitor consistent interleaving operator\\<close>", "lemma ah_interleavable2: \n  assumes A: \"\\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\" \n  shows \"w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\"\n  \\<comment> \\<open>This lemma is shown by induction on the sum of the word lengths\\<close>", "theorem ah_interleavable: \n  \"(\\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)) \\<longleftrightarrow> (w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2\\<noteq>{})\"", "lemma ah_update_cons: \"\\<alpha>ah (e#w) = ah_update (\\<alpha>ah w) e (mon_pl w)\"", "lemma ah_update_mono: \"\\<lbrakk>h \\<le> h'; F=F'; M\\<subseteq>M'\\<rbrakk> \n  \\<Longrightarrow> ah_update h F M \\<le> ah_update h' F' M'\"", "lemma ah_update_mono2: \"\\<lbrakk>h \\<le> h'; U\\<subseteq>U'; M\\<subseteq>M'\\<rbrakk> \n  \\<Longrightarrow> ah_update h (E,U) M \\<le> ah_update h' (E,U') M'\""], "translations": [["", "lemma ah_cases[cases set]: \"\\<lbrakk>h\\<in>ah; h m = {} \\<Longrightarrow> P ; m \\<in> h m \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<in> ah; h m = {} \\<Longrightarrow> P;\n     m \\<in> h m \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (unfold ah_def) blast"], ["", "subsection \"Interleavability\""], ["", "text \\<open>Two acquisition histories @{term h1} and @{term h2} are considered interleavable, iff there is no conflicting pair of monitors @{term m1} and @{term m2}, \n  where a pair of monitors @{term m1} and @{term m2} is called {\\em conflicting} iff @{term m1} is used in @{term h2} after entering @{term m2} and, vice versa, @{term m2} is used in @{term h1} after entering @{term m1}.\\<close>"], ["", "definition\n  ah_il :: \"('m \\<Rightarrow> 'm set) \\<Rightarrow> ('m \\<Rightarrow> 'm set) \\<Rightarrow> bool\" (infix \"[*]\" 65) \n  where\n  \"h1 [*] h2 == \\<not>(\\<exists>m1 m2. m1\\<in>h2 m2 \\<and> m2 \\<in> h1 m1)\""], ["", "text \\<open>From our convention, it follows (as expected) that the sets of entered monitors (lock-sets) of two interleavable acquisition histories are disjoint\\<close>"], ["", "lemma ah_il_lockset_disjoint: \n  \"\\<lbrakk> h1\\<in>ah; h2\\<in>ah; h1 [*] h2 \\<rbrakk> \\<Longrightarrow> h1 m = {} \\<or> h2 m = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h1 \\<in> ah; h2 \\<in> ah; h1 [*] h2\\<rbrakk>\n    \\<Longrightarrow> h1 m = {} \\<or> h2 m = {}", "by (unfold ah_il_def) (auto elim: ah_cases)"], ["", "text \\<open>Of course, acquisition history interleavability is commutative\\<close>"], ["", "lemma ah_il_commute: \"h1 [*] h2 \\<Longrightarrow> h2 [*] h1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h1 [*] h2 \\<Longrightarrow> h2 [*] h1", "by (unfold ah_il_def) auto"], ["", "subsection \"Used monitors\""], ["", "text \\<open>Let's define the monitors of an acquisition history, as all monitors that occur in the acquisition history\\<close>"], ["", "definition \n  mon_ah :: \"('m \\<Rightarrow> 'm set) \\<Rightarrow> 'm set\"\n  where\n  \"mon_ah h == \\<Union>{ h(m) | m. True}\""], ["", "subsection \"Ordering\""], ["", "text \\<open>The element-wise subset-ordering on acquisition histories intuitively reflects the blocking potential: The bigger the acquisition history, the fewer acquisition histories are interleavable with it.\\<close>"], ["", "text \\<open>Note that the Isabelle standard library automatically lifts the subset ordering to functions, so we need no explicit definition here.\\<close>\n  \n\\<comment> \\<open>The ordering is compatible with interleavability, i.e.\\ smaller acquisition histories are more likely to be interleavable.\\<close>"], ["", "lemma ah_leq_il: \"\\<lbrakk> h1 [*] h2; h1' \\<le> h1; h2' \\<le> h2 \\<rbrakk> \\<Longrightarrow> h1' [*] h2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h1 [*] h2; h1' \\<le> h1; h2' \\<le> h2\\<rbrakk>\n    \\<Longrightarrow> h1' [*] h2'", "by (unfold ah_il_def le_fun_def [where 'b=\"'a set\"]) blast+"], ["", "lemma ah_leq_il_left: \"\\<lbrakk> h1 [*] h2; h1' \\<le> h1 \\<rbrakk> \\<Longrightarrow> h1' [*] h2\" and \n      ah_leq_il_right: \"\\<lbrakk> h1 [*] h2; h2' \\<le> h2 \\<rbrakk> \\<Longrightarrow> h1 [*] h2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>h1 [*] h2; h1' \\<le> h1\\<rbrakk>\n     \\<Longrightarrow> h1' [*] h2) &&&\n    (\\<lbrakk>h1 [*] h2; h2' \\<le> h2\\<rbrakk> \\<Longrightarrow> h1 [*] h2')", "by (unfold ah_il_def le_fun_def [where 'b=\"'a set\"]) blast+"], ["", "subsection \"Acquisition histories of executions\""], ["", "text \\<open>Next we define a function that abstracts from executions (lists of enter/use pairs) to acquisition histories\\<close>"], ["", "primrec \\<alpha>ah :: \"('m set \\<times> 'm set) list \\<Rightarrow> 'm \\<Rightarrow> 'm set\" where\n  \"\\<alpha>ah [] m = {}\"\n| \"\\<alpha>ah (e#w) m = (if m\\<in>fst e then fst e \\<union> snd e \\<union> mon_pl w else \\<alpha>ah w m)\"\n\n\\<comment> \\<open>@{term \\<alpha>ah} generates valid acquisition histories\\<close>"], ["", "lemma \\<alpha>ah_ah: \"\\<alpha>ah w \\<in> ah\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah w \\<in> ah", "apply (induct w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<alpha>ah [] \\<in> ah\n 2. \\<And>a w.\n       \\<alpha>ah w \\<in> ah \\<Longrightarrow> \\<alpha>ah (a # w) \\<in> ah", "apply (unfold ah_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<alpha>ah [] \\<in> {h. \\<forall>m. h m = {} \\<or> m \\<in> h m}\n 2. \\<And>a w.\n       \\<alpha>ah w\n       \\<in> {h. \\<forall>m. h m = {} \\<or> m \\<in> h m} \\<Longrightarrow>\n       \\<alpha>ah (a # w) \\<in> {h. \\<forall>m. h m = {} \\<or> m \\<in> h m}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<alpha>ah w\n       \\<in> {h. \\<forall>m. h m = {} \\<or> m \\<in> h m} \\<Longrightarrow>\n       \\<alpha>ah (a # w) \\<in> {h. \\<forall>m. h m = {} \\<or> m \\<in> h m}", "apply (fastforce split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<alpha>ah_hd: \"\\<lbrakk>m\\<in>fst e; x\\<in>fst e \\<union> snd e \\<union> mon_pl w\\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha>ah (e#w) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> fst e;\n     x \\<in> fst e \\<union> snd e \\<union> mon_pl w\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (e # w) m", "by auto"], ["", "lemma \\<alpha>ah_tl: \"\\<lbrakk>m\\<notin>fst e; x\\<in>\\<alpha>ah w m\\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha>ah (e#w) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<notin> fst e; x \\<in> \\<alpha>ah w m\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (e # w) m", "by auto"], ["", "lemma \\<alpha>ah_cases[cases set, case_names hd tl]: \"\\<lbrakk>\n    x\\<in>\\<alpha>ah w m; \n    !!e w'. \\<lbrakk>w=e#w'; m\\<in>fst e; x\\<in>fst e \\<union> snd e \\<union> mon_pl w'\\<rbrakk> \\<Longrightarrow> P; \n    !!e w'. \\<lbrakk>w=e#w'; m\\<notin>fst e; x\\<in>\\<alpha>ah w' m\\<rbrakk> \\<Longrightarrow> P\n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<alpha>ah w m;\n     \\<And>e w'.\n        \\<lbrakk>w = e # w'; m \\<in> fst e;\n         x \\<in> fst e \\<union> snd e \\<union> mon_pl w'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>e w'.\n        \\<lbrakk>w = e # w'; m \\<notin> fst e;\n         x \\<in> \\<alpha>ah w' m\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases w) (simp_all split: if_split_asm)"], ["", "lemma \\<alpha>ah_cons_cases[cases set, case_names hd tl]: \"\\<lbrakk>\n    x\\<in>\\<alpha>ah (e#w') m;  \n    \\<lbrakk>m\\<in>fst e; x\\<in>fst e \\<union> snd e \\<union> mon_pl w'\\<rbrakk> \\<Longrightarrow> P; \n    \\<lbrakk>m\\<notin>fst e; x\\<in>\\<alpha>ah w' m\\<rbrakk> \\<Longrightarrow> P\n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<alpha>ah (e # w') m;\n     \\<lbrakk>m \\<in> fst e;\n      x \\<in> fst e \\<union> snd e \\<union> mon_pl w'\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>m \\<notin> fst e; x \\<in> \\<alpha>ah w' m\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (simp_all split: if_split_asm)"], ["", "lemma mon_ah_subset: \"mon_ah (\\<alpha>ah w) \\<subseteq> mon_pl w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_ah (\\<alpha>ah w) \\<subseteq> mon_pl w", "by (induct w) (auto simp add: mon_ah_def)\n\n\\<comment> \\<open>Subwords generate smaller acquisition histories\\<close>"], ["", "lemma \\<alpha>ah_ileq: \"w1\\<preceq>w2 \\<Longrightarrow> \\<alpha>ah w1 \\<le> \\<alpha>ah w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<preceq> w2 \\<Longrightarrow> \\<alpha>ah w1 \\<le> \\<alpha>ah w2", "proof (induct rule: less_eq_list_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. \\<alpha>ah [] \\<le> \\<alpha>ah ys\n 2. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys; \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah xs \\<le> \\<alpha>ah (y # ys)\n 3. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (x # xs) \\<le> \\<alpha>ah (y # ys)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>ys. \\<alpha>ah [] \\<le> \\<alpha>ah ys\n 2. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys; \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah xs \\<le> \\<alpha>ah (y # ys)\n 3. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (x # xs) \\<le> \\<alpha>ah (y # ys)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah [] \\<le> \\<alpha>ah ys_", "by (unfold le_fun_def [where 'b=\"'a set\"], simp)"], ["proof (state)\nthis:\n  \\<alpha>ah [] \\<le> \\<alpha>ah ys_\n\ngoal (2 subgoals):\n 1. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys; \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah xs \\<le> \\<alpha>ah (y # ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (x # xs) \\<le> \\<alpha>ah (y # ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys; \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah xs \\<le> \\<alpha>ah (y # ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (x # xs) \\<le> \\<alpha>ah (y # ys)", "case (drop l' l a)"], ["proof (state)\nthis:\n  l' \\<preceq> l\n  \\<alpha>ah l' \\<le> \\<alpha>ah l\n\ngoal (2 subgoals):\n 1. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys; \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah xs \\<le> \\<alpha>ah (y # ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (x # xs) \\<le> \\<alpha>ah (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah l' \\<le> \\<alpha>ah (a # l)", "proof (unfold le_fun_def  [where 'b=\"'a set\"], intro allI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah l' x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (a # l) x", "fix m x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah l' x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (a # l) x", "assume A: \"x \\<in> \\<alpha>ah l' m\""], ["proof (state)\nthis:\n  x \\<in> \\<alpha>ah l' m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah l' x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (a # l) x", "with drop(2)"], ["proof (chain)\npicking this:\n  \\<alpha>ah l' \\<le> \\<alpha>ah l\n  x \\<in> \\<alpha>ah l' m", "have \"x\\<in>\\<alpha>ah l m\""], ["proof (prove)\nusing this:\n  \\<alpha>ah l' \\<le> \\<alpha>ah l\n  x \\<in> \\<alpha>ah l' m\n\ngoal (1 subgoal):\n 1. x \\<in> \\<alpha>ah l m", "by (unfold le_fun_def  [where 'b=\"'a set\"], auto)"], ["proof (state)\nthis:\n  x \\<in> \\<alpha>ah l m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah l' x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (a # l) x", "moreover"], ["proof (state)\nthis:\n  x \\<in> \\<alpha>ah l m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah l' x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (a # l) x", "hence \"x\\<in>mon_pl l\""], ["proof (prove)\nusing this:\n  x \\<in> \\<alpha>ah l m\n\ngoal (1 subgoal):\n 1. x \\<in> mon_pl l", "using mon_ah_subset[unfolded mon_ah_def]"], ["proof (prove)\nusing this:\n  x \\<in> \\<alpha>ah l m\n  \\<Union> {\\<alpha>ah ?w m |m. True} \\<subseteq> mon_pl ?w\n\ngoal (1 subgoal):\n 1. x \\<in> mon_pl l", "by fast"], ["proof (state)\nthis:\n  x \\<in> mon_pl l\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah l' x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (a # l) x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> \\<alpha>ah l m\n  x \\<in> mon_pl l", "show \"x\\<in>\\<alpha>ah (a # l) m\""], ["proof (prove)\nusing this:\n  x \\<in> \\<alpha>ah l m\n  x \\<in> mon_pl l\n\ngoal (1 subgoal):\n 1. x \\<in> \\<alpha>ah (a # l) m", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<alpha>ah (a # l) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>ah l' \\<le> \\<alpha>ah (a # l)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (x # xs) \\<le> \\<alpha>ah (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (x # xs) \\<le> \\<alpha>ah (y # ys)", "case (take a b l' l)"], ["proof (state)\nthis:\n  a = b\n  l' \\<preceq> l\n  \\<alpha>ah l' \\<le> \\<alpha>ah l\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        \\<alpha>ah xs \\<le> \\<alpha>ah ys\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (x # xs) \\<le> \\<alpha>ah (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (a # l') \\<le> \\<alpha>ah (b # l)", "proof (unfold le_fun_def [where 'b=\"'a set\"], intro allI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah (a # l') x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (b # l) x", "fix m x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah (a # l') x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (b # l) x", "assume A: \"x\\<in>\\<alpha>ah (a#l') m\""], ["proof (state)\nthis:\n  x \\<in> \\<alpha>ah (a # l') m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> \\<alpha>ah (a # l') x \\<Longrightarrow>\n       xa \\<in> \\<alpha>ah (b # l) x", "thus \"x \\<in> \\<alpha>ah (b # l) m\""], ["proof (prove)\nusing this:\n  x \\<in> \\<alpha>ah (a # l') m\n\ngoal (1 subgoal):\n 1. x \\<in> \\<alpha>ah (b # l) m", "proof (cases rule: \\<alpha>ah_cons_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<in> fst a;\n     x \\<in> fst a \\<union> snd a \\<union> mon_pl l'\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (b # l) m\n 2. \\<lbrakk>m \\<notin> fst a; x \\<in> \\<alpha>ah l' m\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (b # l) m", "case hd"], ["proof (state)\nthis:\n  m \\<in> fst a\n  x \\<in> fst a \\<union> snd a \\<union> mon_pl l'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<in> fst a;\n     x \\<in> fst a \\<union> snd a \\<union> mon_pl l'\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (b # l) m\n 2. \\<lbrakk>m \\<notin> fst a; x \\<in> \\<alpha>ah l' m\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (b # l) m", "with mon_pl_ileq[OF take.hyps(2)] and \\<open>a = b\\<close>"], ["proof (chain)\npicking this:\n  mon_pl l' \\<subseteq> mon_pl l\n  a = b\n  m \\<in> fst a\n  x \\<in> fst a \\<union> snd a \\<union> mon_pl l'", "show ?thesis"], ["proof (prove)\nusing this:\n  mon_pl l' \\<subseteq> mon_pl l\n  a = b\n  m \\<in> fst a\n  x \\<in> fst a \\<union> snd a \\<union> mon_pl l'\n\ngoal (1 subgoal):\n 1. x \\<in> \\<alpha>ah (b # l) m", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<alpha>ah (b # l) m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<notin> fst a; x \\<in> \\<alpha>ah l' m\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (b # l) m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<notin> fst a; x \\<in> \\<alpha>ah l' m\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (b # l) m", "case tl"], ["proof (state)\nthis:\n  m \\<notin> fst a\n  x \\<in> \\<alpha>ah l' m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<notin> fst a; x \\<in> \\<alpha>ah l' m\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha>ah (b # l) m", "with take.hyps(3)[unfolded le_fun_def [where 'b=\"'a set\"]] and \\<open>a = b\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x. \\<alpha>ah l' x \\<subseteq> \\<alpha>ah l x\n  a = b\n  m \\<notin> fst a\n  x \\<in> \\<alpha>ah l' m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<alpha>ah l' x \\<subseteq> \\<alpha>ah l x\n  a = b\n  m \\<notin> fst a\n  x \\<in> \\<alpha>ah l' m\n\ngoal (1 subgoal):\n 1. x \\<in> \\<alpha>ah (b # l) m", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<alpha>ah (b # l) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<alpha>ah (b # l) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>ah (a # l') \\<le> \\<alpha>ah (b # l)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can now prove the relation of monitor consistent interleavability and interleavability of the acquisition histories.\\<close>"], ["", "lemma ah_interleavable1: \n  \"w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\" \n  \\<comment> \\<open>The lemma is shown by induction on the structure of the monitor consistent interleaving operator\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<Longrightarrow>\n    \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)", "proof (induct w \\<alpha> w1 w2 rule: cil_set_induct_fix\\<alpha>)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<alpha>ah (map \\<alpha> []) [*] \\<alpha>ah (map \\<alpha> [])\n 2. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2;\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w2) = {};\n        \\<alpha>ah (map \\<alpha> w1') [*]\n        \\<alpha>ah (map \\<alpha> w2)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n                         \\<alpha>ah (map \\<alpha> w2)\n 3. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2';\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {};\n        \\<alpha>ah (map \\<alpha> w1) [*]\n        \\<alpha>ah (map \\<alpha> w2')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*]\n                         \\<alpha>ah (map \\<alpha> (e # w2'))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<alpha>ah (map \\<alpha> []) [*] \\<alpha>ah (map \\<alpha> [])\n 2. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2;\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w2) = {};\n        \\<alpha>ah (map \\<alpha> w1') [*]\n        \\<alpha>ah (map \\<alpha> w2)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n                         \\<alpha>ah (map \\<alpha> w2)\n 3. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2';\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {};\n        \\<alpha>ah (map \\<alpha> w1) [*]\n        \\<alpha>ah (map \\<alpha> w2')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*]\n                         \\<alpha>ah (map \\<alpha> (e # w2'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map \\<alpha> []) [*] \\<alpha>ah (map \\<alpha> [])", "by (simp add: ah_il_def) \\<comment> \\<open>The base case is trivial by the definition of @{term \"([*])\"}\\<close>"], ["proof (state)\nthis:\n  \\<alpha>ah (map \\<alpha> []) [*] \\<alpha>ah (map \\<alpha> [])\n\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2;\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w2) = {};\n        \\<alpha>ah (map \\<alpha> w1') [*]\n        \\<alpha>ah (map \\<alpha> w2)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n                         \\<alpha>ah (map \\<alpha> w2)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2';\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {};\n        \\<alpha>ah (map \\<alpha> w1) [*]\n        \\<alpha>ah (map \\<alpha> w2')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*]\n                         \\<alpha>ah (map \\<alpha> (e # w2'))", "next\n  \\<comment> \\<open>Case: First step comes from the left word\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2;\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w2) = {};\n        \\<alpha>ah (map \\<alpha> w1') [*]\n        \\<alpha>ah (map \\<alpha> w2)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n                         \\<alpha>ah (map \\<alpha> w2)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2';\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {};\n        \\<alpha>ah (map \\<alpha> w1) [*]\n        \\<alpha>ah (map \\<alpha> w2')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*]\n                         \\<alpha>ah (map \\<alpha> (e # w2'))", "case (left e w' w1' w2)"], ["proof (state)\nthis:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2\n  fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w2) = {}\n  \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\n\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2;\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w2) = {};\n        \\<alpha>ah (map \\<alpha> w1') [*]\n        \\<alpha>ah (map \\<alpha> w2)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n                         \\<alpha>ah (map \\<alpha> w2)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2';\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {};\n        \\<alpha>ah (map \\<alpha> w1) [*]\n        \\<alpha>ah (map \\<alpha> w2')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*]\n                         \\<alpha>ah (map \\<alpha> (e # w2'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map \\<alpha> (e # w1')) [*] \\<alpha>ah (map \\<alpha> w2)", "proof (rule ccontr) \\<comment> \\<open>We do a proof by contradiction\\<close>\n    \\<comment> \\<open>Assume there is a conflicting pair in the acquisition histories\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "assume \"\\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*] \\<alpha>ah (map \\<alpha> w2)\""], ["proof (state)\nthis:\n  \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n         \\<alpha>ah (map \\<alpha> w2)\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n         \\<alpha>ah (map \\<alpha> w2)", "obtain m1 m2 where CPAIR: \"m1 \\<in> \\<alpha>ah (map \\<alpha> (e#w1')) m2\" \"m2 \\<in> \\<alpha>ah (map \\<alpha> w2) m1\""], ["proof (prove)\nusing this:\n  \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n         \\<alpha>ah (map \\<alpha> w2)\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m2.\n        \\<lbrakk>m1 \\<in> \\<alpha>ah (map \\<alpha> (e # w1')) m2;\n         m2 \\<in> \\<alpha>ah (map \\<alpha> w2) m1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold ah_il_def, blast) \n    \\<comment> \\<open>It comes either from the first step or not\\<close>"], ["proof (state)\nthis:\n  m1 \\<in> \\<alpha>ah (map \\<alpha> (e # w1')) m2\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2) m1\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "from CPAIR(1)"], ["proof (chain)\npicking this:\n  m1 \\<in> \\<alpha>ah (map \\<alpha> (e # w1')) m2", "have \"(m2\\<in>fst (\\<alpha> e) \\<and> m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union> mon_pl (map \\<alpha> w1')) \\<or> (m2\\<notin>fst (\\<alpha> e) \\<and> m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2)\" (is \"?CASE1 \\<or> ?CASE2\")"], ["proof (prove)\nusing this:\n  m1 \\<in> \\<alpha>ah (map \\<alpha> (e # w1')) m2\n\ngoal (1 subgoal):\n 1. m2 \\<in> fst (\\<alpha> e) \\<and>\n    m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n             mon_pl (map \\<alpha> w1') \\<or>\n    m2 \\<notin> fst (\\<alpha> e) \\<and>\n    m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<or>\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<or>\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "{\n      \\<comment> \\<open>Case: One monitor of the conflicting pair is entered in the first step of the left path\\<close>"], ["proof (state)\nthis:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<or>\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "assume ?CASE1"], ["proof (state)\nthis:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1')\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "hence C: \"m2\\<in>fst (\\<alpha> e)\""], ["proof (prove)\nusing this:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1')\n\ngoal (1 subgoal):\n 1. m2 \\<in> fst (\\<alpha> e)", ".. \n      \\<comment> \\<open>Because the paths are consistently interleavable, the monitors entered in the first step must not occur in the other path\\<close>"], ["proof (state)\nthis:\n  m2 \\<in> fst (\\<alpha> e)\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "from left(2) mon_ah_subset[of \"map \\<alpha> w2\"]"], ["proof (chain)\npicking this:\n  fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w2) = {}\n  mon_ah (\\<alpha>ah (map \\<alpha> w2)) \\<subseteq> mon_pl (map \\<alpha> w2)", "have \"fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w2)) = {}\""], ["proof (prove)\nusing this:\n  fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w2) = {}\n  mon_ah (\\<alpha>ah (map \\<alpha> w2)) \\<subseteq> mon_pl (map \\<alpha> w2)\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w2)) = {}", "by auto \n      \\<comment> \\<open>But this is a contradiction to being a conflicting pair\\<close>"], ["proof (state)\nthis:\n  fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w2)) = {}\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "with C CPAIR(2)"], ["proof (chain)\npicking this:\n  m2 \\<in> fst (\\<alpha> e)\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2) m1\n  fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w2)) = {}", "have False"], ["proof (prove)\nusing this:\n  m2 \\<in> fst (\\<alpha> e)\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2) m1\n  fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w2)) = {}\n\ngoal (1 subgoal):\n 1. False", "by (unfold mon_ah_def, blast)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "{\n      \\<comment> \\<open>Case: The first monitor of the conflicting pair is entered after the first step of the left path\\<close>"], ["proof (state)\nthis:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "assume ?CASE2"], ["proof (state)\nthis:\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "hence C: \"m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\""], ["proof (prove)\nusing this:\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n\ngoal (1 subgoal):\n 1. m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2", ".. \n      \\<comment> \\<open>But this is a contradiction to the induction hypothesis, that says that the acquisition histories of the tail of the left path and the \n        right path are interleavable\\<close>"], ["proof (state)\nthis:\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "with left(3) CPAIR(2)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2) m1\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2", "have False"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2) m1\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n\ngoal (1 subgoal):\n 1. False", "by (unfold ah_il_def, blast)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> (e # w1')) [*]\n           \\<alpha>ah (map \\<alpha> w2) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<or>\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<Longrightarrow>\n  False\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2 \\<Longrightarrow>\n  False", "show False"], ["proof (prove)\nusing this:\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<or>\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2\n  m2 \\<in> fst (\\<alpha> e) \\<and>\n  m1 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w1') \\<Longrightarrow>\n  False\n  m2 \\<notin> fst (\\<alpha> e) \\<and>\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1') m2 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>ah (map \\<alpha> (e # w1')) [*] \\<alpha>ah (map \\<alpha> w2)\n\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2';\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {};\n        \\<alpha>ah (map \\<alpha> w1) [*]\n        \\<alpha>ah (map \\<alpha> w2')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*]\n                         \\<alpha>ah (map \\<alpha> (e # w2'))", "next\n  \\<comment> \\<open>Case: First step comes from the right word. This case is shown completely analogous\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2';\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {};\n        \\<alpha>ah (map \\<alpha> w1) [*]\n        \\<alpha>ah (map \\<alpha> w2')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*]\n                         \\<alpha>ah (map \\<alpha> (e # w2'))", "case (right e w' w2' w1)"], ["proof (state)\nthis:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2'\n  fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {}\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\n\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2';\n        fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {};\n        \\<alpha>ah (map \\<alpha> w1) [*]\n        \\<alpha>ah (map \\<alpha> w2')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>ah (map \\<alpha> w1) [*]\n                         \\<alpha>ah (map \\<alpha> (e # w2'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> (e # w2'))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "assume \"\\<not> \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> (e#w2'))\""], ["proof (state)\nthis:\n  \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n         \\<alpha>ah (map \\<alpha> (e # w2'))\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n         \\<alpha>ah (map \\<alpha> (e # w2'))", "obtain m1 m2 where CPAIR: \"m1 \\<in> \\<alpha>ah (map \\<alpha> w1) m2\" \"m2 \\<in> \\<alpha>ah (map \\<alpha> (e#w2')) m1\""], ["proof (prove)\nusing this:\n  \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n         \\<alpha>ah (map \\<alpha> (e # w2'))\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m2.\n        \\<lbrakk>m1 \\<in> \\<alpha>ah (map \\<alpha> w1) m2;\n         m2 \\<in> \\<alpha>ah (map \\<alpha> (e # w2')) m1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold ah_il_def, blast)"], ["proof (state)\nthis:\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1) m2\n  m2 \\<in> \\<alpha>ah (map \\<alpha> (e # w2')) m1\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "from CPAIR(2)"], ["proof (chain)\npicking this:\n  m2 \\<in> \\<alpha>ah (map \\<alpha> (e # w2')) m1", "have \"(m1\\<in>fst (\\<alpha> e) \\<and> m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union> mon_pl (map \\<alpha> w2')) \\<or> (m1\\<notin>fst (\\<alpha> e) \\<and> m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1)\" (is \"?CASE1 \\<or> ?CASE2\")"], ["proof (prove)\nusing this:\n  m2 \\<in> \\<alpha>ah (map \\<alpha> (e # w2')) m1\n\ngoal (1 subgoal):\n 1. m1 \\<in> fst (\\<alpha> e) \\<and>\n    m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n             mon_pl (map \\<alpha> w2') \\<or>\n    m1 \\<notin> fst (\\<alpha> e) \\<and>\n    m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<or>\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<or>\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<or>\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "assume ?CASE1"], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2')\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "hence C: \"m1\\<in>fst (\\<alpha> e)\""], ["proof (prove)\nusing this:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2')\n\ngoal (1 subgoal):\n 1. m1 \\<in> fst (\\<alpha> e)", ".."], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e)\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "from right(2) mon_ah_subset[of \"map \\<alpha> w1\"]"], ["proof (chain)\npicking this:\n  fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {}\n  mon_ah (\\<alpha>ah (map \\<alpha> w1)) \\<subseteq> mon_pl (map \\<alpha> w1)", "have \"fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w1)) = {}\""], ["proof (prove)\nusing this:\n  fst (\\<alpha> e) \\<inter> mon_pl (map \\<alpha> w1) = {}\n  mon_ah (\\<alpha>ah (map \\<alpha> w1)) \\<subseteq> mon_pl (map \\<alpha> w1)\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w1)) = {}", "by auto"], ["proof (state)\nthis:\n  fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w1)) = {}\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "with C CPAIR(1)"], ["proof (chain)\npicking this:\n  m1 \\<in> fst (\\<alpha> e)\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1) m2\n  fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w1)) = {}", "have False"], ["proof (prove)\nusing this:\n  m1 \\<in> fst (\\<alpha> e)\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1) m2\n  fst (\\<alpha> e) \\<inter> mon_ah (\\<alpha>ah (map \\<alpha> w1)) = {}\n\ngoal (1 subgoal):\n 1. False", "by (unfold mon_ah_def, blast)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "assume ?CASE2"], ["proof (state)\nthis:\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "hence C: \"m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\""], ["proof (prove)\nusing this:\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n\ngoal (1 subgoal):\n 1. m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1", ".."], ["proof (state)\nthis:\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "with right(3) CPAIR(1)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1) m2\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1", "have False"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w1) m2\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n\ngoal (1 subgoal):\n 1. False", "by (unfold ah_il_def, blast)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>ah (map \\<alpha> w1) [*]\n           \\<alpha>ah (map \\<alpha> (e # w2')) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<or>\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<Longrightarrow>\n  False\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1 \\<Longrightarrow>\n  False", "show False"], ["proof (prove)\nusing this:\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<or>\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1\n  m1 \\<in> fst (\\<alpha> e) \\<and>\n  m2 \\<in> fst (\\<alpha> e) \\<union> snd (\\<alpha> e) \\<union>\n           mon_pl (map \\<alpha> w2') \\<Longrightarrow>\n  False\n  m1 \\<notin> fst (\\<alpha> e) \\<and>\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w2') m1 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> (e # w2'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ah_interleavable2: \n  assumes A: \"\\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\" \n  shows \"w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\"\n  \\<comment> \\<open>This lemma is shown by induction on the sum of the word lengths\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "proof -\n  \\<comment> \\<open>To apply this induction in Isabelle, we have to rewrite the lemma a bit\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "have \"!!w1 w2. \\<lbrakk>\\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2); n=length w1 + length w2\\<rbrakk> \\<Longrightarrow> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>\\<alpha>ah (map \\<alpha> w1) [*]\n                \\<alpha>ah (map \\<alpha> w2);\n        n = length w1 + length w2\\<rbrakk>\n       \\<Longrightarrow> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "proof (induct n rule: nat_less_induct[case_names I])\n      \\<comment> \\<open>We first rule out the cases that one of the words is empty\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n w1 w2.\n       \\<lbrakk>\\<forall>m<n.\n                   \\<forall>x xa.\n                      \\<alpha>ah (map \\<alpha> x) [*]\n                      \\<alpha>ah (map \\<alpha> xa) \\<longrightarrow>\n                      m = length x + length xa \\<longrightarrow>\n                      x \\<otimes>\\<^bsub>\\<alpha>\\<^esub> xa \\<noteq> {};\n        \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2);\n        n = length w1 + length w2\\<rbrakk>\n       \\<Longrightarrow> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case (I n w1 w2)"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     \\<forall>x xa.\n        \\<alpha>ah (map \\<alpha> x) [*]\n        \\<alpha>ah (map \\<alpha> xa) \\<longrightarrow>\n        m = length x + length xa \\<longrightarrow>\n        x \\<otimes>\\<^bsub>\\<alpha>\\<^esub> xa \\<noteq> {}\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  n = length w1 + length w2\n\ngoal (1 subgoal):\n 1. \\<And>n w1 w2.\n       \\<lbrakk>\\<forall>m<n.\n                   \\<forall>x xa.\n                      \\<alpha>ah (map \\<alpha> x) [*]\n                      \\<alpha>ah (map \\<alpha> xa) \\<longrightarrow>\n                      m = length x + length xa \\<longrightarrow>\n                      x \\<otimes>\\<^bsub>\\<alpha>\\<^esub> xa \\<noteq> {};\n        \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2);\n        n = length w1 + length w2\\<rbrakk>\n       \\<Longrightarrow> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "proof (cases w1) \n        \\<comment> \\<open>If the first word is empty, the lemma is trivial\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. w1 = [] \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. \\<And>a list.\n       w1 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case Nil"], ["proof (state)\nthis:\n  w1 = []\n\ngoal (2 subgoals):\n 1. w1 = [] \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. \\<And>a list.\n       w1 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "with I.prems"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  n = length w1 + length w2\n  w1 = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  n = length w1 + length w2\n  w1 = []\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w1 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w1 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case (Cons e1 w1')"], ["proof (state)\nthis:\n  w1 = e1 # w1'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w1 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "note CONS1=this"], ["proof (state)\nthis:\n  w1 = e1 # w1'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w1 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "proof (cases w2)\n          \\<comment> \\<open>If the second word is empty, the lemma is also trivial\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. w2 = [] \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. \\<And>a list.\n       w2 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case Nil"], ["proof (state)\nthis:\n  w2 = []\n\ngoal (2 subgoals):\n 1. w2 = [] \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. \\<And>a list.\n       w2 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "with I.prems"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  n = length w1 + length w2\n  w2 = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  n = length w1 + length w2\n  w2 = []\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w2 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "next\n          \\<comment> \\<open>The interesting case is if both words are not empty\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w2 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case (Cons e2 w2')"], ["proof (state)\nthis:\n  w2 = e2 # w2'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w2 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "note CONS2=this \n          \\<comment> \\<open>In this case, we check whether the first step of one of the words can safely be executed without blocking any steps of the other word\\<close>"], ["proof (state)\nthis:\n  w2 = e2 # w2'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w2 = a # list \\<Longrightarrow>\n       w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "proof (cases \"fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) =\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case True \\<comment> \\<open>The first step of the first word can safely be executed\\<close>\n            \\<comment> \\<open>From the induction hypothesis, we get that there is a consistent interleaving of the rest of the first word and the second word\\<close>"], ["proof (state)\nthis:\n  fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) = {}\n\ngoal (2 subgoals):\n 1. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) =\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "have \"w1'\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "from I.prems(1) CONS1 ah_leq_il_left[OF _ \\<alpha>ah_ileq[OF le_list_map, OF less_eq_list_drop[OF order_refl]]]"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  w1 = e1 # w1'\n  \\<alpha>ah (map ?f2 (?y3 # ?xs2)) [*] ?h2.0 \\<Longrightarrow>\n  \\<alpha>ah (map ?f2 ?xs2) [*] ?h2.0", "have \"\\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  w1 = e1 # w1'\n  \\<alpha>ah (map ?f2 (?y3 # ?xs2)) [*] ?h2.0 \\<Longrightarrow>\n  \\<alpha>ah (map ?f2 ?xs2) [*] ?h2.0\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)", "by fast"], ["proof (state)\nthis:\n  \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\n\ngoal (1 subgoal):\n 1. w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\n\ngoal (1 subgoal):\n 1. w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "from CONS1 I.prems(2)"], ["proof (chain)\npicking this:\n  w1 = e1 # w1'\n  n = length w1 + length w2", "have \"length w1'+length w2 < n\""], ["proof (prove)\nusing this:\n  w1 = e1 # w1'\n  n = length w1 + length w2\n\ngoal (1 subgoal):\n 1. length w1' + length w2 < n", "by simp"], ["proof (state)\nthis:\n  length w1' + length w2 < n\n\ngoal (1 subgoal):\n 1. w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\n  length w1' + length w2 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\n  length w1' + length w2 < n\n\ngoal (1 subgoal):\n 1. w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "using I.hyps"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1') [*] \\<alpha>ah (map \\<alpha> w2)\n  length w1' + length w2 < n\n  \\<forall>m<n.\n     \\<forall>x xa.\n        \\<alpha>ah (map \\<alpha> x) [*]\n        \\<alpha>ah (map \\<alpha> xa) \\<longrightarrow>\n        m = length x + length xa \\<longrightarrow>\n        x \\<otimes>\\<^bsub>\\<alpha>\\<^esub> xa \\<noteq> {}\n\ngoal (1 subgoal):\n 1. w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed\n            \\<comment> \\<open>And because the first step of the first word can be safely executed, we can prepend it to that consistent interleaving\\<close>"], ["proof (state)\nthis:\n  w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal (2 subgoals):\n 1. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) =\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "with cil_cons1[OF _ True] CONS1"], ["proof (chain)\npicking this:\n  ?w \\<in> ?wa \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<Longrightarrow>\n  e1 # ?w \\<in> e1 # ?wa \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2\n  w1 = e1 # w1'\n  w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?w \\<in> ?wa \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<Longrightarrow>\n  e1 # ?w \\<in> e1 # ?wa \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2\n  w1 = e1 # w1'\n  w1' \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case False"], ["proof (state)\nthis:\n  fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "note C1=this"], ["proof (state)\nthis:\n  fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "proof (cases \"fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) =\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case True \\<comment> \\<open>The first step of the second word can safely be executed\\<close>\n              \\<comment> \\<open>This case is shown analogously to the latter one\\<close>"], ["proof (state)\nthis:\n  fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) = {}\n\ngoal (2 subgoals):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) =\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "have \"w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2' \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}", "from I.prems(1) CONS2 ah_leq_il_right[OF _ \\<alpha>ah_ileq[OF le_list_map, OF less_eq_list_drop[OF order_refl]]]"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  w2 = e2 # w2'\n  ?h1.0 [*] \\<alpha>ah (map ?f2 (?y3 # ?xs2)) \\<Longrightarrow>\n  ?h1.0 [*] \\<alpha>ah (map ?f2 ?xs2)", "have \"\\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\""], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  w2 = e2 # w2'\n  ?h1.0 [*] \\<alpha>ah (map ?f2 (?y3 # ?xs2)) \\<Longrightarrow>\n  ?h1.0 [*] \\<alpha>ah (map ?f2 ?xs2)\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')", "by fast"], ["proof (state)\nthis:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}", "from CONS2 I.prems(2)"], ["proof (chain)\npicking this:\n  w2 = e2 # w2'\n  n = length w1 + length w2", "have \"length w1+length w2' < n\""], ["proof (prove)\nusing this:\n  w2 = e2 # w2'\n  n = length w1 + length w2\n\ngoal (1 subgoal):\n 1. length w1 + length w2' < n", "by simp"], ["proof (state)\nthis:\n  length w1 + length w2' < n\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\n  length w1 + length w2' < n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\n  length w1 + length w2' < n\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}", "using I.hyps"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2')\n  length w1 + length w2' < n\n  \\<forall>m<n.\n     \\<forall>x xa.\n        \\<alpha>ah (map \\<alpha> x) [*]\n        \\<alpha>ah (map \\<alpha> xa) \\<longrightarrow>\n        m = length x + length xa \\<longrightarrow>\n        x \\<otimes>\\<^bsub>\\<alpha>\\<^esub> xa \\<noteq> {}\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}\n\ngoal (2 subgoals):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) =\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n 2. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "with cil_cons2[OF _ True] CONS2"], ["proof (chain)\npicking this:\n  ?w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> ?wb \\<Longrightarrow>\n  e2 # ?w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> e2 # ?wb\n  w2 = e2 # w2'\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> ?wb \\<Longrightarrow>\n  e2 # ?w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> e2 # ?wb\n  w2 = e2 # w2'\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "case False"], ["proof (state)\nthis:\n  fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "note C2=this \\<comment> \\<open>Neither first step can safely be executed. This is exactly the situation from that we can extract a conflicting pair\\<close>"], ["proof (state)\nthis:\n  fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "from C1 C2"], ["proof (chain)\npicking this:\n  fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq> {}\n  fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq> {}", "obtain m1 m2 where \"m1\\<in>fst (\\<alpha> e1)\" \"m1\\<in>mon_pl (map \\<alpha> w2)\" \"m2\\<in>fst (\\<alpha> e2)\" \"m2\\<in>mon_pl (map \\<alpha> w1)\""], ["proof (prove)\nusing this:\n  fst (\\<alpha> e1) \\<inter> mon_pl (map \\<alpha> w2) \\<noteq> {}\n  fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m2.\n        \\<lbrakk>m1 \\<in> fst (\\<alpha> e1);\n         m1 \\<in> mon_pl (map \\<alpha> w2); m2 \\<in> fst (\\<alpha> e2);\n         m2 \\<in> mon_pl (map \\<alpha> w1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m1 \\<in> fst (\\<alpha> e1)\n  m1 \\<in> mon_pl (map \\<alpha> w2)\n  m2 \\<in> fst (\\<alpha> e2)\n  m2 \\<in> mon_pl (map \\<alpha> w1)\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "with CONS1 CONS2"], ["proof (chain)\npicking this:\n  w1 = e1 # w1'\n  w2 = e2 # w2'\n  m1 \\<in> fst (\\<alpha> e1)\n  m1 \\<in> mon_pl (map \\<alpha> w2)\n  m2 \\<in> fst (\\<alpha> e2)\n  m2 \\<in> mon_pl (map \\<alpha> w1)", "have \"m2 \\<in> \\<alpha>ah (map \\<alpha> w1) m1\" \"m1 \\<in> \\<alpha>ah (map \\<alpha> w2) m2\""], ["proof (prove)\nusing this:\n  w1 = e1 # w1'\n  w2 = e2 # w2'\n  m1 \\<in> fst (\\<alpha> e1)\n  m1 \\<in> mon_pl (map \\<alpha> w2)\n  m2 \\<in> fst (\\<alpha> e2)\n  m2 \\<in> mon_pl (map \\<alpha> w1)\n\ngoal (1 subgoal):\n 1. m2 \\<in> \\<alpha>ah (map \\<alpha> w1) m1 &&&\n    m1 \\<in> \\<alpha>ah (map \\<alpha> w2) m2", "by auto\n              \\<comment> \\<open>But by assumption, there are no conflicting pairs, thus we get a contradiction\\<close>"], ["proof (state)\nthis:\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w1) m1\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w2) m2\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "with I.prems(1)"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w1) m1\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w2) m2", "have False"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  m2 \\<in> \\<alpha>ah (map \\<alpha> w1) m1\n  m1 \\<in> \\<alpha>ah (map \\<alpha> w2) m2\n\ngoal (1 subgoal):\n 1. False", "by (unfold ah_il_def) blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. fst (\\<alpha> e2) \\<inter> mon_pl (map \\<alpha> w1) \\<noteq>\n    {} \\<Longrightarrow>\n    w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", ".."], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<alpha>ah (map \\<alpha> ?w1.0) [*]\n           \\<alpha>ah (map \\<alpha> ?w2.0);\n   n = length ?w1.0 + length ?w2.0\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> ?w2.0 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<alpha>ah (map \\<alpha> ?w1.0) [*]\n           \\<alpha>ah (map \\<alpha> ?w2.0);\n   ?n3 = length ?w1.0 + length ?w2.0\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> ?w2.0 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "with A"], ["proof (chain)\npicking this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  \\<lbrakk>\\<alpha>ah (map \\<alpha> ?w1.0) [*]\n           \\<alpha>ah (map \\<alpha> ?w2.0);\n   ?n3 = length ?w1.0 + length ?w2.0\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> ?w2.0 \\<noteq>\n                    {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)\n  \\<lbrakk>\\<alpha>ah (map \\<alpha> ?w1.0) [*]\n           \\<alpha>ah (map \\<alpha> ?w2.0);\n   ?n3 = length ?w1.0 + length ?w2.0\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> ?w2.0 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, we can state the relationship between monitor consistent interleaving and interleaving of acquisition histories\\<close>"], ["", "theorem ah_interleavable: \n  \"(\\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2)) \\<longleftrightarrow> (w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2\\<noteq>{})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2) =\n    (w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {})", "using ah_interleavable1 ah_interleavable2"], ["proof (prove)\nusing this:\n  ?w \\<in> ?w1.0 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> ?w2.0 \\<Longrightarrow>\n  \\<alpha>ah (map ?\\<alpha> ?w1.0) [*] \\<alpha>ah (map ?\\<alpha> ?w2.0)\n  \\<alpha>ah (map ?\\<alpha> ?w1.0) [*]\n  \\<alpha>ah (map ?\\<alpha> ?w2.0) \\<Longrightarrow>\n  ?w1.0 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> ?w2.0 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<alpha>ah (map \\<alpha> w1) [*] \\<alpha>ah (map \\<alpha> w2) =\n    (w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<noteq> {})", "by blast"], ["", "subsection \"Acquisition history backward update\""], ["", "text \\<open>We define a function to update an acquisition history backwards. This function is useful for constructing acquisition histories in backward constraint systems.\\<close>"], ["", "definition\n  ah_update :: \"('m \\<Rightarrow> 'm set) \\<Rightarrow> ('m set * 'm set) \\<Rightarrow> 'm set \\<Rightarrow> ('m \\<Rightarrow> 'm set)\"\n  where\n  \"ah_update h F M m == if m\\<in>fst F then fst F \\<union> snd F \\<union> M else h m\""], ["", "text \\<open>\n  Intuitively, @{term \"ah_update h (E,U) M m\"} means to prepend a step @{term \"(E,U)\"} to the acquisition history @{term h} of a path that uses monitors @{term M}. Note that we need the extra parameter @{term M}, since\n  an acquisition history does not contain information about the monitors that are used on a path before the first monitor that will not be left has been entered. \n\\<close>"], ["", "lemma ah_update_cons: \"\\<alpha>ah (e#w) = ah_update (\\<alpha>ah w) e (mon_pl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>ah (e # w) = ah_update (\\<alpha>ah w) e (mon_pl w)", "by (auto intro!: ext simp add: ah_update_def)"], ["", "text \\<open>The backward-update function is monotonic in the first and third argument as well as in the used monitors of the second argument. \n  Note that it is, in general, not monotonic in the entered monitors of the second argument.\\<close>"], ["", "lemma ah_update_mono: \"\\<lbrakk>h \\<le> h'; F=F'; M\\<subseteq>M'\\<rbrakk> \n  \\<Longrightarrow> ah_update h F M \\<le> ah_update h' F' M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<le> h'; F = F'; M \\<subseteq> M'\\<rbrakk>\n    \\<Longrightarrow> ah_update h F M \\<le> ah_update h' F' M'", "by (auto simp add: ah_update_def le_fun_def [where 'b=\"'a set\"])"], ["", "lemma ah_update_mono2: \"\\<lbrakk>h \\<le> h'; U\\<subseteq>U'; M\\<subseteq>M'\\<rbrakk> \n  \\<Longrightarrow> ah_update h (E,U) M \\<le> ah_update h' (E,U') M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<le> h'; U \\<subseteq> U'; M \\<subseteq> M'\\<rbrakk>\n    \\<Longrightarrow> ah_update h (E, U) M \\<le> ah_update h' (E, U') M'", "by (auto simp add: ah_update_def le_fun_def [where 'b=\"'a set\"])"], ["", "end"]]}