{"file_name": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis/MainResult.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis", "problem_names": ["theorem (in eflowgraph) RUV_is_sim_reach: \n  \"(\\<exists>w c'. ({#[entry fg (main fg)]#},w,c')\\<in>trcl (refpoint fg) \\<and> atUV U V c') \n    \\<longleftrightarrow> (\\<exists>Ml Me. (entry fg (main fg),Ml,Me)\\<in>RUV_cs fg U V)\" \n\\<comment> \\<open>The proof uses the soundness and precision theorems wrt. to normalized paths (@{thm [source] flowgraph.RUV_sound}, @{thm [source] flowgraph.RUV_precise}) as well as the normalization result, \n  i.e. that every reachable configuration is also reachable using a normalized path (@{thm [source] eflowgraph.normalize}) and, vice versa, that every normalized path is also a usual path (@{thm [source] ntr_is_tr}). \n  Finally the conversion between our working semantics and the semantic reference point is exploited (@{thm [source] flowgraph.refpoint_eq}).\\<close>\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], "translations": [["", "theorem (in eflowgraph) RUV_is_sim_reach: \n  \"(\\<exists>w c'. ({#[entry fg (main fg)]#},w,c')\\<in>trcl (refpoint fg) \\<and> atUV U V c') \n    \\<longleftrightarrow> (\\<exists>Ml Me. (entry fg (main fg),Ml,Me)\\<in>RUV_cs fg U V)\" \n\\<comment> \\<open>The proof uses the soundness and precision theorems wrt. to normalized paths (@{thm [source] flowgraph.RUV_sound}, @{thm [source] flowgraph.RUV_precise}) as well as the normalization result, \n  i.e. that every reachable configuration is also reachable using a normalized path (@{thm [source] eflowgraph.normalize}) and, vice versa, that every normalized path is also a usual path (@{thm [source] ntr_is_tr}). \n  Finally the conversion between our working semantics and the semantic reference point is exploited (@{thm [source] flowgraph.refpoint_eq}).\\<close>\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>w c'.\n        ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n        atUV U V c') =\n    (\\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c' \\<Longrightarrow>\n    \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n 2. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "assume ?lhs"], ["proof (state)\nthis:\n  \\<exists>w c'.\n     ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n     atUV U V c'\n\ngoal (2 subgoals):\n 1. \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c' \\<Longrightarrow>\n    \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n 2. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "then"], ["proof (chain)\npicking this:\n  \\<exists>w c'.\n     ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n     atUV U V c'", "obtain w c' where C: \"({#[entry fg (main fg)]#}, w, c') \\<in> trcl (tr fg)\" \"atUV U V c'\""], ["proof (prove)\nusing this:\n  \\<exists>w c'.\n     ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n     atUV U V c'\n\ngoal (1 subgoal):\n 1. (\\<And>w c'.\n        \\<lbrakk>({#[entry fg (main fg)]#}, w, c') \\<in> trcl (tr fg);\n         atUV U V c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: refpoint_eq)"], ["proof (state)\nthis:\n  ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (tr fg)\n  atUV U V c'\n\ngoal (2 subgoals):\n 1. \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c' \\<Longrightarrow>\n    \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n 2. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "from normalize[OF C(1), of \"main fg\", simplified]"], ["proof (chain)\npicking this:\n  \\<exists>w'. ({#[entry fg (main fg)]#}, w', c') \\<in> trcl (ntr fg)", "obtain ww where \"({#[entry fg (main fg)]#}, ww, c') \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<exists>w'. ({#[entry fg (main fg)]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>ww.\n        ({#[entry fg (main fg)]#}, ww, c')\n        \\<in> trcl (ntr fg) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ({#[entry fg (main fg)]#}, ww, c') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c' \\<Longrightarrow>\n    \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n 2. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "from ntrs.gtr2gtrp[where c=\"{#}\", simplified, OF this]"], ["proof (chain)\npicking this:\n  (\\<And>s' ce' wwa.\n      \\<lbrakk>c' = add_mset s' ce'; ww = map le_rem_s wwa;\n       (([entry fg (main fg)], {#}), wwa, s', ce')\n       \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain s' ce' wwl where 1: \"c'=add_mset s' ce'\" \"ww = map le_rem_s wwl\" \"(([entry fg (main fg)], {#}), wwl, s', ce') \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  (\\<And>s' ce' wwa.\n      \\<lbrakk>c' = add_mset s' ce'; ww = map le_rem_s wwa;\n       (([entry fg (main fg)], {#}), wwa, s', ce')\n       \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>s' ce' wwl.\n        \\<lbrakk>c' = add_mset s' ce'; ww = map le_rem_s wwl;\n         (([entry fg (main fg)], {#}), wwl, s', ce')\n         \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c' = add_mset s' ce'\n  ww = map le_rem_s wwl\n  (([entry fg (main fg)], {#}), wwl, s', ce') \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c' \\<Longrightarrow>\n    \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n 2. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "with C(2)"], ["proof (chain)\npicking this:\n  atUV U V c'\n  c' = add_mset s' ce'\n  ww = map le_rem_s wwl\n  (([entry fg (main fg)], {#}), wwl, s', ce') \\<in> trcl (ntrp fg)", "have 2: \"atUV U V ({#s'#}+ce')\""], ["proof (prove)\nusing this:\n  atUV U V c'\n  c' = add_mset s' ce'\n  ww = map le_rem_s wwl\n  (([entry fg (main fg)], {#}), wwl, s', ce') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. atUV U V ({#s'#} + ce')", "by auto"], ["proof (state)\nthis:\n  atUV U V ({#s'#} + ce')\n\ngoal (2 subgoals):\n 1. \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c' \\<Longrightarrow>\n    \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n 2. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "from RUV_sound[OF 1(3) 2]"], ["proof (chain)\npicking this:\n  \\<exists>Ml Me.\n     (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg wwl \\<and> Me \\<subseteq> mon_env fg wwl", "show ?rhs"], ["proof (prove)\nusing this:\n  \\<exists>Ml Me.\n     (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<and>\n     Ml \\<subseteq> mon_loc fg wwl \\<and> Me \\<subseteq> mon_env fg wwl\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "then"], ["proof (chain)\npicking this:\n  \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V", "obtain Ml Me where C: \"(entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\""], ["proof (prove)\nusing this:\n  \\<exists>Ml Me. (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. (\\<And>Ml Me.\n        (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "from RUV_precise[OF C]"], ["proof (chain)\npicking this:\n  \\<exists>w s' c'.\n     (([entry fg (main fg)], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and> mon_env fg w = Me", "obtain wwl s' c' where P: \"(([entry fg (main fg)], {#}), wwl, s', c') \\<in> trcl (ntrp fg)\" \"atUV U V ({#s'#} + c')\""], ["proof (prove)\nusing this:\n  \\<exists>w s' c'.\n     (([entry fg (main fg)], {#}), w, s', c') \\<in> trcl (ntrp fg) \\<and>\n     atUV U V ({#s'#} + c') \\<and>\n     mon_loc fg w = Ml \\<and> mon_env fg w = Me\n\ngoal (1 subgoal):\n 1. (\\<And>wwl s' c'.\n        \\<lbrakk>(([entry fg (main fg)], {#}), wwl, s', c')\n                 \\<in> trcl (ntrp fg);\n         atUV U V ({#s'#} + c')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (([entry fg (main fg)], {#}), wwl, s', c') \\<in> trcl (ntrp fg)\n  atUV U V ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "from gtrp2gtr[OF P(1)]"], ["proof (chain)\npicking this:\n  ({#[entry fg (main fg)]#}, map le_rem_s wwl, add_mset s' c')\n  \\<in> trcl (ntr fg)", "have \"({# [entry fg (main fg)] #}, map le_rem_s wwl, {#s'#}+c') \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  ({#[entry fg (main fg)]#}, map le_rem_s wwl, add_mset s' c')\n  \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. ({#[entry fg (main fg)]#}, map le_rem_s wwl, {#s'#} + c')\n    \\<in> trcl (ntr fg)", "by (auto)"], ["proof (state)\nthis:\n  ({#[entry fg (main fg)]#}, map le_rem_s wwl, {#s'#} + c')\n  \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "from ntr_is_tr[OF this] P(2)"], ["proof (chain)\npicking this:\n  ({#[entry fg (main fg)]#}, foldl (@) [] (map le_rem_s wwl), {#s'#} + c')\n  \\<in> trcl (tr fg)\n  atUV U V ({#s'#} + c')", "have \"\\<exists>w c'. ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (tr fg) \\<and> atUV U V c'\""], ["proof (prove)\nusing this:\n  ({#[entry fg (main fg)]#}, foldl (@) [] (map le_rem_s wwl), {#s'#} + c')\n  \\<in> trcl (tr fg)\n  atUV U V ({#s'#} + c')\n\ngoal (1 subgoal):\n 1. \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (tr fg) \\<and>\n       atUV U V c'", "by blast"], ["proof (state)\nthis:\n  \\<exists>w c'.\n     ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (tr fg) \\<and> atUV U V c'\n\ngoal (1 subgoal):\n 1. \\<exists>Ml Me.\n       (entry fg (main fg), Ml, Me) \\<in> RUV_cs fg U V \\<Longrightarrow>\n    \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "thus ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>w c'.\n     ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (tr fg) \\<and> atUV U V c'\n\ngoal (1 subgoal):\n 1. \\<exists>w c'.\n       ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n       atUV U V c'", "by (simp add: refpoint_eq)"], ["proof (state)\nthis:\n  \\<exists>w c'.\n     ({#[entry fg (main fg)]#}, w, c') \\<in> trcl (refpoint fg) \\<and>\n     atUV U V c'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}