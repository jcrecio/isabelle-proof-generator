{"file_name": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis/Flowgraph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis", "problem_names": ["lemma main_is_initial[simp]: \"initialproc fg (main fg)\"", "lemma (in flowgraph) spawn_no_mon[simp]: \n  \"(u, Spawn p, v) \\<in> edges fg \\<Longrightarrow> mon fg p = {}\"", "lemma (in flowgraph) main_no_mon[simp]: \"mon fg (main fg) = {}\"", "lemma (in flowgraph) entry_return_same_proc[simp]: \n  \"entry fg p = return fg p' \\<Longrightarrow> p=p'\"", "lemma (in flowgraph) entry_entry_same_proc[simp]: \n  \"entry fg p = entry fg p' \\<Longrightarrow> p=p'\"", "lemma (in flowgraph) return_return_same_proc[simp]: \n  \"return fg p = return fg p' \\<Longrightarrow> p=p'\"", "lemma exists_eflowgraph: \"eflowgraph example_fg\""], "translations": [["", "lemma main_is_initial[simp]: \"initialproc fg (main fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initialproc fg (main fg)", "by (unfold initialproc_def) simp"], ["", "locale flowgraph =\n  fixes fg :: \"('n,'p,'ba,'m,'more) flowgraph_rec_scheme\" (structure)\n  (* Type annotation unnecessary, but perhaps makes it more readable\n     for the unaware reader ;) *)\n  \\<comment> \\<open>Edges are inside procedures only\\<close>\n  assumes edges_part: \"(u,a,v)\\<in>edges fg \\<Longrightarrow> proc_of fg u = proc_of fg v\" \n  \\<comment> \\<open>The entry point of a procedure must be in that procedure\\<close>\n  assumes entry_valid[simp]: \"proc_of fg (entry fg p) = p\" \n  \\<comment> \\<open>The return point of a procedure must be in that procedure\\<close>\n  assumes return_valid[simp]: \"proc_of fg (return fg p) = p\" \n  \\<comment> \\<open>Initial procedures do not synchronize on any monitors\\<close>\n  assumes initial_no_mon[simp]: \"initialproc fg p \\<Longrightarrow> mon fg p = {}\""], ["", "subsection \"Basic properties\""], ["", "lemma (in flowgraph) spawn_no_mon[simp]: \n  \"(u, Spawn p, v) \\<in> edges fg \\<Longrightarrow> mon fg p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, Spawn p, v) \\<in> edges fg \\<Longrightarrow> mon fg p = {}", "using initial_no_mon"], ["proof (prove)\nusing this:\n  initialproc fg ?p \\<Longrightarrow> mon fg ?p = {}\n\ngoal (1 subgoal):\n 1. (u, Spawn p, v) \\<in> edges fg \\<Longrightarrow> mon fg p = {}", "by (unfold initialproc_def, blast)"], ["", "lemma (in flowgraph) main_no_mon[simp]: \"mon fg (main fg) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon fg (main fg) = {}", "using initial_no_mon"], ["proof (prove)\nusing this:\n  initialproc fg ?p \\<Longrightarrow> mon fg ?p = {}\n\ngoal (1 subgoal):\n 1. mon fg (main fg) = {}", "by (unfold initialproc_def, blast)"], ["", "lemma (in flowgraph) entry_return_same_proc[simp]: \n  \"entry fg p = return fg p' \\<Longrightarrow> p=p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entry fg p = return fg p' \\<Longrightarrow> p = p'", "apply (subgoal_tac \"proc_of fg (entry fg p) = proc_of fg (return fg p')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>entry fg p = return fg p';\n     proc_of fg (entry fg p) = proc_of fg (return fg p')\\<rbrakk>\n    \\<Longrightarrow> p = p'\n 2. entry fg p = return fg p' \\<Longrightarrow>\n    proc_of fg (entry fg p) = proc_of fg (return fg p')", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. entry fg p = return fg p' \\<Longrightarrow>\n    proc_of fg (entry fg p) = proc_of fg (return fg p')", "by simp"], ["", "lemma (in flowgraph) entry_entry_same_proc[simp]: \n  \"entry fg p = entry fg p' \\<Longrightarrow> p=p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entry fg p = entry fg p' \\<Longrightarrow> p = p'", "apply (subgoal_tac \"proc_of fg (entry fg p) = proc_of fg (entry fg p')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>entry fg p = entry fg p';\n     proc_of fg (entry fg p) = proc_of fg (entry fg p')\\<rbrakk>\n    \\<Longrightarrow> p = p'\n 2. entry fg p = entry fg p' \\<Longrightarrow>\n    proc_of fg (entry fg p) = proc_of fg (entry fg p')", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. entry fg p = entry fg p' \\<Longrightarrow>\n    proc_of fg (entry fg p) = proc_of fg (entry fg p')", "by simp"], ["", "lemma (in flowgraph) return_return_same_proc[simp]: \n  \"return fg p = return fg p' \\<Longrightarrow> p=p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return fg p = return fg p' \\<Longrightarrow> p = p'", "apply (subgoal_tac \"proc_of fg (return fg p) = proc_of fg (entry fg p')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>return fg p = return fg p';\n     proc_of fg (return fg p) = proc_of fg (entry fg p')\\<rbrakk>\n    \\<Longrightarrow> p = p'\n 2. return fg p = return fg p' \\<Longrightarrow>\n    proc_of fg (return fg p) = proc_of fg (entry fg p')", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. return fg p = return fg p' \\<Longrightarrow>\n    proc_of fg (return fg p) = proc_of fg (entry fg p')", "by simp"], ["", "subsection \"Extra assumptions for flowgraphs\""], ["", "text_raw \\<open>\\label{sec:Flowgraph:extra_asm}\\<close>"], ["", "text \\<open>\n  In order to simplify the definition of our restricted schedules (cf. Section~\\ref{thy:Normalization}), we make some extra constraints on flowgraphs. \n  Note that these are no real restrictions, as we can always rewrite flowgraphs to match these constraints, preserving the set of conflicts. We leave it to future work to consider such a rewriting formally. \n\n  The background of this restrictions is that we want to start an execution of a thread with a procedure call that never returns. This will allow easier technical treatment in Section~\\ref{thy:Normalization}. Here we enforce this\n  semantic restrictions by syntactic properties of the flowgraph.\n\\<close>"], ["", "text \\<open>The return node of a procedure is called {\\em isolated}, if it has no incoming edges and is different from the entry node. A procedure with an isolated return node will never return. \n  See Section~\\ref{sec:Normalization:eflowgraph} for a proof of this.\\<close>"], ["", "definition \n  \"isolated_ret fg p == \n    (\\<forall>u l. \\<not>(u,l,return fg p)\\<in>edges fg) \\<and> entry fg p \\<noteq> return fg p\""], ["", "text \\<open>The following syntactic restrictions guarantee that each thread's execution starts with a non-returning call. See Section~\\ref{sec:Normalization:eflowgraph} for a proof of this.\\<close>"], ["", "locale eflowgraph = flowgraph +\n  \\<comment> \\<open>Initial procedure's entry node isn't equal to its return node\\<close>\n  assumes initial_no_ret: \"initialproc fg p \\<Longrightarrow> entry fg p \\<noteq> return fg p\" \n  \\<comment> \\<open>The only outgoing edges of initial procedures' entry nodes are call edges to procedures with isolated return node\\<close>\n  assumes initial_call_no_ret: \"\\<lbrakk>initialproc fg p; (entry fg p,l,v)\\<in>edges fg\\<rbrakk> \n    \\<Longrightarrow> \\<exists>p'. l=Call p' \\<and> isolated_ret fg p'\""], ["", "subsection \\<open>Example Flowgraph\\<close>"], ["", "text_raw \\<open>\\label{sec:Flowgraph:ex_flowgraph}\\<close>"], ["", "text \\<open>This section contains a check that there exists a (non-trivial) flowgraph, i.e. that the assumptions made in the \\<open>flowgraph\\<close> and \\<open>eflowgraph\\<close> \n  locales are consistent and have at least one non-trivial model.\\<close>"], ["", "definition \n  \"example_fg == \\<lparr> \n    edges = {((0::nat,0::nat),Call 1,(0,1)), ((1,0),Spawn 0,(1,0)), \n             ((1,0),Call 0, (1,0))}, \n    main = 0, \n    entry = \\<lambda>p. (p,0), \n    return = \\<lambda>p. (p,1), \n    mon = \\<lambda>p. if p=1 then {0} else {}, \n    proc_of= \\<lambda> (p,x). p \\<rparr>\""], ["", "lemma exists_eflowgraph: \"eflowgraph example_fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eflowgraph example_fg", "apply (unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>u a v.\n       (u, a, v) \\<in> edges example_fg \\<Longrightarrow>\n       proc_of example_fg u = proc_of example_fg v\n 2. \\<And>p. proc_of example_fg (entry example_fg p) = p\n 3. \\<And>p. proc_of example_fg (return example_fg p) = p\n 4. \\<And>p.\n       initialproc example_fg p \\<Longrightarrow> mon example_fg p = {}\n 5. \\<And>p.\n       initialproc example_fg p \\<Longrightarrow>\n       entry example_fg p \\<noteq> return example_fg p\n 6. \\<And>p l v.\n       \\<lbrakk>initialproc example_fg p;\n        (entry example_fg p, l, v) \\<in> edges example_fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            l = Call p' \\<and> isolated_ret example_fg p'", "apply (unfold example_fg_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>u a v.\n       (u, a, v)\n       \\<in> edges\n              \\<lparr>edges =\n                        {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                         ((1, 0), Call 0, 1, 0)},\n                 main = 0, entry = \\<lambda>p. (p, 0),\n                 return = \\<lambda>p. (p, 1),\n                 mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                 proc_of = \\<lambda>(p, x). p\\<rparr> \\<Longrightarrow>\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        u =\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        v\n 2. \\<And>p.\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p) =\n       p\n 3. \\<And>p.\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        (return\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p) =\n       p\n 4. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       mon \\<lparr>edges =\n                     {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                      ((1, 0), Call 0, 1, 0)},\n              main = 0, entry = \\<lambda>p. (p, 0),\n              return = \\<lambda>p. (p, 1),\n              mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n              proc_of = \\<lambda>(p, x). p\\<rparr>\n        p =\n       {}\n 5. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       entry\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<noteq>\n       return\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p\n 6. \\<And>p l v.\n       \\<lbrakk>initialproc\n                 \\<lparr>edges =\n                           {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                            ((1, 0), Call 0, 1, 0)},\n                    main = 0, entry = \\<lambda>p. (p, 0),\n                    return = \\<lambda>p. (p, 1),\n                    mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                    proc_of = \\<lambda>(p, x). p\\<rparr>\n                 p;\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p,\n         l, v)\n        \\<in> edges\n               \\<lparr>edges =\n                         {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                          ((1, 0), Call 0, 1, 0)},\n                  main = 0, entry = \\<lambda>p. (p, 0),\n                  return = \\<lambda>p. (p, 1),\n                  mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                  proc_of = \\<lambda>(p, x). p\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            l = Call p' \\<and>\n                            isolated_ret\n                             \\<lparr>edges =\n {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0), ((1, 0), Call 0, 1, 0)},\n                                main = 0, entry = \\<lambda>p. (p, 0),\n                                return = \\<lambda>p. (p, 1),\n                                mon =\n                                  \\<lambda>p. if p = 1 then {0::'b} else {},\n                                proc_of = \\<lambda>(p, x). p\\<rparr>\n                             p'", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>u a v.\n       u = (0, 0) \\<and> a = Call (Suc 0) \\<and> v = (0, Suc 0) \\<or>\n       u = (Suc 0, 0) \\<and> a = Spawn 0 \\<and> v = (Suc 0, 0) \\<or>\n       u = (Suc 0, 0) \\<and>\n       a = Call 0 \\<and> v = (Suc 0, 0) \\<Longrightarrow>\n       (case u of (p, x) \\<Rightarrow> p) =\n       (case v of (p, x) \\<Rightarrow> p)\n 2. \\<And>p.\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p) =\n       p\n 3. \\<And>p.\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        (return\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p) =\n       p\n 4. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       mon \\<lparr>edges =\n                     {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                      ((1, 0), Call 0, 1, 0)},\n              main = 0, entry = \\<lambda>p. (p, 0),\n              return = \\<lambda>p. (p, 1),\n              mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n              proc_of = \\<lambda>(p, x). p\\<rparr>\n        p =\n       {}\n 5. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       entry\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<noteq>\n       return\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p\n 6. \\<And>p l v.\n       \\<lbrakk>initialproc\n                 \\<lparr>edges =\n                           {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                            ((1, 0), Call 0, 1, 0)},\n                    main = 0, entry = \\<lambda>p. (p, 0),\n                    return = \\<lambda>p. (p, 1),\n                    mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                    proc_of = \\<lambda>(p, x). p\\<rparr>\n                 p;\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p,\n         l, v)\n        \\<in> edges\n               \\<lparr>edges =\n                         {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                          ((1, 0), Call 0, 1, 0)},\n                  main = 0, entry = \\<lambda>p. (p, 0),\n                  return = \\<lambda>p. (p, 1),\n                  mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                  proc_of = \\<lambda>(p, x). p\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            l = Call p' \\<and>\n                            isolated_ret\n                             \\<lparr>edges =\n {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0), ((1, 0), Call 0, 1, 0)},\n                                main = 0, entry = \\<lambda>p. (p, 0),\n                                return = \\<lambda>p. (p, 1),\n                                mon =\n                                  \\<lambda>p. if p = 1 then {0::'b} else {},\n                                proc_of = \\<lambda>(p, x). p\\<rparr>\n                             p'", "apply fast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>p.\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p) =\n       p\n 2. \\<And>p.\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        (return\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p) =\n       p\n 3. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       mon \\<lparr>edges =\n                     {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                      ((1, 0), Call 0, 1, 0)},\n              main = 0, entry = \\<lambda>p. (p, 0),\n              return = \\<lambda>p. (p, 1),\n              mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n              proc_of = \\<lambda>(p, x). p\\<rparr>\n        p =\n       {}\n 4. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       entry\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<noteq>\n       return\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p\n 5. \\<And>p l v.\n       \\<lbrakk>initialproc\n                 \\<lparr>edges =\n                           {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                            ((1, 0), Call 0, 1, 0)},\n                    main = 0, entry = \\<lambda>p. (p, 0),\n                    return = \\<lambda>p. (p, 1),\n                    mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                    proc_of = \\<lambda>(p, x). p\\<rparr>\n                 p;\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p,\n         l, v)\n        \\<in> edges\n               \\<lparr>edges =\n                         {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                          ((1, 0), Call 0, 1, 0)},\n                  main = 0, entry = \\<lambda>p. (p, 0),\n                  return = \\<lambda>p. (p, 1),\n                  mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                  proc_of = \\<lambda>(p, x). p\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            l = Call p' \\<and>\n                            isolated_ret\n                             \\<lparr>edges =\n {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0), ((1, 0), Call 0, 1, 0)},\n                                main = 0, entry = \\<lambda>p. (p, 0),\n                                return = \\<lambda>p. (p, 1),\n                                mon =\n                                  \\<lambda>p. if p = 1 then {0::'b} else {},\n                                proc_of = \\<lambda>(p, x). p\\<rparr>\n                             p'", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>p.\n       proc_of\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        (return\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p) =\n       p\n 2. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       mon \\<lparr>edges =\n                     {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                      ((1, 0), Call 0, 1, 0)},\n              main = 0, entry = \\<lambda>p. (p, 0),\n              return = \\<lambda>p. (p, 1),\n              mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n              proc_of = \\<lambda>(p, x). p\\<rparr>\n        p =\n       {}\n 3. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       entry\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<noteq>\n       return\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p\n 4. \\<And>p l v.\n       \\<lbrakk>initialproc\n                 \\<lparr>edges =\n                           {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                            ((1, 0), Call 0, 1, 0)},\n                    main = 0, entry = \\<lambda>p. (p, 0),\n                    return = \\<lambda>p. (p, 1),\n                    mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                    proc_of = \\<lambda>(p, x). p\\<rparr>\n                 p;\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p,\n         l, v)\n        \\<in> edges\n               \\<lparr>edges =\n                         {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                          ((1, 0), Call 0, 1, 0)},\n                  main = 0, entry = \\<lambda>p. (p, 0),\n                  return = \\<lambda>p. (p, 1),\n                  mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                  proc_of = \\<lambda>(p, x). p\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            l = Call p' \\<and>\n                            isolated_ret\n                             \\<lparr>edges =\n {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0), ((1, 0), Call 0, 1, 0)},\n                                main = 0, entry = \\<lambda>p. (p, 0),\n                                return = \\<lambda>p. (p, 1),\n                                mon =\n                                  \\<lambda>p. if p = 1 then {0::'b} else {},\n                                proc_of = \\<lambda>(p, x). p\\<rparr>\n                             p'", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       mon \\<lparr>edges =\n                     {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                      ((1, 0), Call 0, 1, 0)},\n              main = 0, entry = \\<lambda>p. (p, 0),\n              return = \\<lambda>p. (p, 1),\n              mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n              proc_of = \\<lambda>(p, x). p\\<rparr>\n        p =\n       {}\n 2. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       entry\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<noteq>\n       return\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p\n 3. \\<And>p l v.\n       \\<lbrakk>initialproc\n                 \\<lparr>edges =\n                           {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                            ((1, 0), Call 0, 1, 0)},\n                    main = 0, entry = \\<lambda>p. (p, 0),\n                    return = \\<lambda>p. (p, 1),\n                    mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                    proc_of = \\<lambda>(p, x). p\\<rparr>\n                 p;\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p,\n         l, v)\n        \\<in> edges\n               \\<lparr>edges =\n                         {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                          ((1, 0), Call 0, 1, 0)},\n                  main = 0, entry = \\<lambda>p. (p, 0),\n                  return = \\<lambda>p. (p, 1),\n                  mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                  proc_of = \\<lambda>(p, x). p\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            l = Call p' \\<and>\n                            isolated_ret\n                             \\<lparr>edges =\n {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0), ((1, 0), Call 0, 1, 0)},\n                                main = 0, entry = \\<lambda>p. (p, 0),\n                                return = \\<lambda>p. (p, 1),\n                                mon =\n                                  \\<lambda>p. if p = 1 then {0::'b} else {},\n                                proc_of = \\<lambda>(p, x). p\\<rparr>\n                             p'", "apply (simp add: initialproc_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       initialproc\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<Longrightarrow>\n       entry\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p \\<noteq>\n       return\n        \\<lparr>edges =\n                  {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                   ((1, 0), Call 0, 1, 0)},\n           main = 0, entry = \\<lambda>p. (p, 0),\n           return = \\<lambda>p. (p, 1),\n           mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n           proc_of = \\<lambda>(p, x). p\\<rparr>\n        p\n 2. \\<And>p l v.\n       \\<lbrakk>initialproc\n                 \\<lparr>edges =\n                           {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                            ((1, 0), Call 0, 1, 0)},\n                    main = 0, entry = \\<lambda>p. (p, 0),\n                    return = \\<lambda>p. (p, 1),\n                    mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                    proc_of = \\<lambda>(p, x). p\\<rparr>\n                 p;\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p,\n         l, v)\n        \\<in> edges\n               \\<lparr>edges =\n                         {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                          ((1, 0), Call 0, 1, 0)},\n                  main = 0, entry = \\<lambda>p. (p, 0),\n                  return = \\<lambda>p. (p, 1),\n                  mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                  proc_of = \\<lambda>(p, x). p\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            l = Call p' \\<and>\n                            isolated_ret\n                             \\<lparr>edges =\n {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0), ((1, 0), Call 0, 1, 0)},\n                                main = 0, entry = \\<lambda>p. (p, 0),\n                                return = \\<lambda>p. (p, 1),\n                                mon =\n                                  \\<lambda>p. if p = 1 then {0::'b} else {},\n                                proc_of = \\<lambda>(p, x). p\\<rparr>\n                             p'", "apply (simp add: initialproc_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p l v.\n       \\<lbrakk>initialproc\n                 \\<lparr>edges =\n                           {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                            ((1, 0), Call 0, 1, 0)},\n                    main = 0, entry = \\<lambda>p. (p, 0),\n                    return = \\<lambda>p. (p, 1),\n                    mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                    proc_of = \\<lambda>(p, x). p\\<rparr>\n                 p;\n        (entry\n          \\<lparr>edges =\n                    {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                     ((1, 0), Call 0, 1, 0)},\n             main = 0, entry = \\<lambda>p. (p, 0),\n             return = \\<lambda>p. (p, 1),\n             mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n             proc_of = \\<lambda>(p, x). p\\<rparr>\n          p,\n         l, v)\n        \\<in> edges\n               \\<lparr>edges =\n                         {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0),\n                          ((1, 0), Call 0, 1, 0)},\n                  main = 0, entry = \\<lambda>p. (p, 0),\n                  return = \\<lambda>p. (p, 1),\n                  mon = \\<lambda>p. if p = 1 then {0::'b} else {},\n                  proc_of = \\<lambda>(p, x). p\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            l = Call p' \\<and>\n                            isolated_ret\n                             \\<lparr>edges =\n {((0, 0), Call 1, 0, 1), ((1, 0), Spawn 0, 1, 0), ((1, 0), Call 0, 1, 0)},\n                                main = 0, entry = \\<lambda>p. (p, 0),\n                                return = \\<lambda>p. (p, 1),\n                                mon =\n                                  \\<lambda>p. if p = 1 then {0::'b} else {},\n                                proc_of = \\<lambda>(p, x). p\\<rparr>\n                             p'", "apply (simp add: initialproc_def isolated_ret_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}