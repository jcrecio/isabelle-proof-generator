{"file_name": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis/Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis", "problem_names": ["lemma mon_e_simps [simp]:\n  \"mon_e fg (LBase a) = {}\"\n  \"mon_e fg (LCall p) = mon fg p\"\n  \"mon_e fg (LRet) = {}\"\n  \"mon_e fg (LSpawn p) = {}\"", "lemma mon_s_alt: \"mon_s fg s == \\<Union> (mon fg ` proc_of fg ` set s)\"", "lemma mon_c_alt: \"mon_c fg c == \\<Union> (mon_s fg ` set_mset c)\"", "lemma mon_w_alt: \"mon_w fg w == \\<Union> (mon_e fg ` set w)\"", "lemma mon_sI: \"\\<lbrakk>n\\<in>set s; m\\<in>mon_n fg n\\<rbrakk> \\<Longrightarrow> m\\<in>mon_s fg s\"", "lemma mon_sD: \"m\\<in>mon_s fg s \\<Longrightarrow> \\<exists>n\\<in>set s. m\\<in>mon_n fg n\"", "lemma mon_n_same_proc: \n  \"proc_of fg n = proc_of fg n' \\<Longrightarrow> mon_n fg n = mon_n fg n'\"", "lemma mon_s_same_proc: \n  \"proc_of fg ` set s = proc_of fg ` set s' \\<Longrightarrow> mon_s fg s = mon_s fg s'\"", "lemma (in flowgraph) mon_of_entry[simp]: \"mon_n fg (entry fg p) = mon fg p\"", "lemma (in flowgraph) mon_of_ret[simp]: \"mon_n fg (return fg p) = mon fg p\"", "lemma mon_c_single[simp]: \"mon_c fg {#s#} = mon_s fg s\"", "lemma mon_s_single[simp]: \"mon_s fg [n] = mon_n fg n\"", "lemma mon_s_empty[simp]: \"mon_s fg [] = {}\"", "lemma mon_c_empty[simp]: \"mon_c fg {#} = {}\"", "lemma mon_s_unconc: \"mon_s fg (a@b) = mon_s fg a \\<union> mon_s fg b\"", "lemma mon_s_uncons[simp]: \"mon_s fg (a#as) = mon_n fg a \\<union> mon_s fg as\"", "lemma mon_c_union_conc: \"mon_c fg (a+b) = mon_c fg a \\<union> mon_c fg b\"", "lemma mon_c_add_mset_unconc: \"mon_c fg (add_mset x b) = mon_s fg x \\<union> mon_c fg b\"", "lemmas mon_c_unconc = mon_c_union_conc mon_c_add_mset_unconc", "lemma mon_cI: \"\\<lbrakk>s \\<in># c; m\\<in>mon_s fg s\\<rbrakk> \\<Longrightarrow> m\\<in>mon_c fg c\"", "lemma mon_cD: \"\\<lbrakk>m\\<in>mon_c fg c\\<rbrakk> \\<Longrightarrow> \\<exists>s. s \\<in># c \\<and> m\\<in>mon_s fg s\"", "lemma mon_s_mono: \"set s \\<subseteq> set s' \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s'\"", "lemma mon_c_mono: \"c\\<subseteq>#c' \\<Longrightarrow> mon_c fg c \\<subseteq> mon_c fg c'\"", "lemma mon_w_empty[simp]: \"mon_w fg [] = {}\"", "lemma mon_w_single[simp]: \"mon_w fg [e] = mon_e fg e\"", "lemma mon_w_unconc: \"mon_w fg (wa@wb) = mon_w fg wa \\<union> mon_w fg wb\"", "lemma mon_w_uncons[simp]: \"mon_w fg (e#w) = mon_e fg e \\<union> mon_w fg w\"", "lemma mon_w_ileq: \"w\\<preceq>w' \\<Longrightarrow> mon_w fg w \\<subseteq> mon_w fg w'\"", "lemma valid_empty[simp, intro!]: \"valid fg {#}\"", "lemma valid_single[simp, intro!]: \"valid fg {#s#}\"", "lemma valid_split1: \n  \"valid fg (c+c') \\<Longrightarrow> valid fg c \\<and> valid fg c' \\<and> mon_c fg c \\<inter> mon_c fg c' = {}\"", "lemma valid_split2: \n  \"\\<lbrakk>valid fg c; valid fg c'; mon_c fg c \\<inter> mon_c fg c' = {}\\<rbrakk> \\<Longrightarrow> valid fg (c+c')\"", "lemma valid_union_conc: \n  \"valid fg (c+c') \\<longleftrightarrow> (valid fg c \\<and> valid fg c' \\<and> mon_c fg c \\<inter> mon_c fg c' = {})\"", "lemma valid_add_mset_conc: \n  \"valid fg (add_mset x c') \\<longleftrightarrow> (valid fg c' \\<and> mon_s fg x \\<inter> mon_c fg c' = {})\"", "lemmas valid_unconc = valid_union_conc valid_add_mset_conc", "lemma valid_no_mon: \"mon_c fg c = {} \\<Longrightarrow> valid fg c\"", "lemma atU_s_decomp[simp]: \"atU_s U (s@s') = (atU_s U s \\<or> (s=[] \\<and> atU_s U s'))\"", "lemma atU_fmt: \"\\<lbrakk>atU U c; !!ui r. \\<lbrakk>ui#r \\<in># c; ui\\<in>U\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma atU_union_cases[case_names left right, consumes 1]: \"\\<lbrakk> \n    atU U (c1+c2); \n    atU U c1 \\<Longrightarrow> P; \n    atU U c2 \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma atU_add: \"atU U c \\<Longrightarrow> atU U (c+ce) \\<and> atU U (ce+c)\"", "lemma atU_union[simp]: \"atU U (c1+c2) = (atU U c1 \\<or> atU U c2)\"", "lemma atU_empty[simp]: \"\\<not>atU U {#}\"", "lemma atU_single[simp]: \"atU U {#s#} = atU_s U s\"", "lemma atU_single_top[simp]: \"atU U {#u#r#} = (u\\<in>U)\"", "lemma atU_add_mset[simp]: \"atU U (add_mset c c2) = (atU_s U c \\<or> atU U c2)\"", "lemma atU_xchange_stack: \"atU U (add_mset (u#r) c) \\<Longrightarrow> atU U (add_mset (u#r') c)\"", "lemma atUV_empty[simp]: \"\\<not>atUV U V {#}\"", "lemma atUV_single[simp]: \"\\<not>atUV U V {#s#}\"", "lemma atUV_union[simp]: \"\n  atUV U V (c1+c2) \\<longleftrightarrow> \n  (\n    (atUV U V c1) \\<or> \n    (atUV U V c2) \\<or> \n    (atU U c1 \\<and> atU V c2) \\<or> \n    (atU V c1 \\<and> atU U c2)\n  )\"", "lemma atUV_add_mset[simp]: \"\n  atUV U V (add_mset c c2) \\<longleftrightarrow>\n  (\n    (atUV U V c2) \\<or>\n    (atU U {#c#} \\<and> atU V c2) \\<or>\n    (atU V {#c#} \\<and> atU U c2)\n  )\"", "lemma atUV_union_cases[case_names left right lr rl, consumes 1]: \"\\<lbrakk>\n    atUV U V (c1+c2); \n    atUV U V c1 \\<Longrightarrow> P; \n    atUV U V c2 \\<Longrightarrow> P; \n    \\<lbrakk>atU U c1; atU V c2\\<rbrakk> \\<Longrightarrow> P; \n    \\<lbrakk>atU V c1; atU U c2\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma (in flowgraph) trss_valid_preserve_s: \n  \"\\<lbrakk>valid fg (add_mset s c); ((s,c),e,(s',c'))\\<in>trss fg\\<rbrakk> \\<Longrightarrow> valid fg (add_mset s' c')\"", "lemma (in flowgraph) trss_valid_preserve: \n  \"\\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (trss fg); valid fg ({#s#}+c)\\<rbrakk> \\<Longrightarrow> valid fg ({#s'#}+c')\"", "lemma (in flowgraph) tr_valid_preserve_s: \n  \"\\<lbrakk>(c,e,c')\\<in>tr fg; valid fg c\\<rbrakk> \\<Longrightarrow> valid fg c'\"", "lemma (in flowgraph) tr_valid_preserve: \n  \"\\<lbrakk>(c,w,c')\\<in>trcl (tr fg); valid fg c\\<rbrakk> \\<Longrightarrow> valid fg c'\"", "lemma (in flowgraph) trp_valid_preserve_s: \n  \"\\<lbrakk>((s,c),e,(s',c'))\\<in>trp fg; valid fg (add_mset s c)\\<rbrakk> \\<Longrightarrow> valid fg (add_mset s' c')\"", "lemma (in flowgraph) trp_valid_preserve: \n  \"\\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (trp fg); valid fg ({#s#}+c)\\<rbrakk> \\<Longrightarrow> valid fg (add_mset s' c')\"", "lemma refpoint_eq_s: \"valid fg c \\<Longrightarrow> ((c,e,c')\\<in>refpoint fg) \\<longleftrightarrow> ((c,e,c')\\<in>tr fg)\"", "lemma (in flowgraph) refpoint_eq: \n  \"valid fg c \\<Longrightarrow> ((c,w,c')\\<in>trcl (refpoint fg)) \\<longleftrightarrow> ((c,w,c')\\<in>trcl (tr fg))\"", "lemma trss_c_cases_s[cases set, case_names no_spawn spawn]: \"\\<lbrakk> \n    ((s,c),e,(s',c'))\\<in>trss fg; \n    \\<lbrakk> c'=c \\<rbrakk> \\<Longrightarrow> P; \n    !!p u v. \\<lbrakk> e=LSpawn p; (u,Spawn p,v)\\<in>edges fg; \n               hd s=u; hd s'=v; c'={#[ entry fg p ]#}+c \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma trss_c_fmt_s: \"\\<lbrakk>((s,c),e,(s',c'))\\<in>trss fg\\<rbrakk> \n  \\<Longrightarrow> \\<exists>csp. c'=csp+c \\<and> \n        (csp={#} \\<or> (\\<exists>p. e=LSpawn p \\<and> csp={#[ entry fg p ]#}))\"", "lemma (in flowgraph) trss_c'_split_s: \"\\<lbrakk>\n    ((s,c),e,(s',c'))\\<in>trss fg; \n    !!csp. \\<lbrakk>c'=csp+c; mon_c fg csp={}\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma trss_c_cases[cases set, case_names c_case]: \"!!s c. \\<lbrakk> \n    ((s,c),w,(s',c'))\\<in>trcl (trss fg); \n    !!csp. \\<lbrakk> c'=csp+c; !!s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> \n                                               (u,Spawn p,v)\\<in>edges fg \\<and> \n                                               initialproc fg p\\<rbrakk> \n            \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma (in flowgraph) c_of_initial_no_mon: \n  assumes A: \"!!s. s \\<in># csp \\<Longrightarrow> \\<exists>p. s=[entry fg p] \\<and> initialproc fg p\" \n  shows \"mon_c fg csp = {}\"", "lemma (in flowgraph) trss_c_no_mon_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>trss fg\" \n  shows \"mon_c fg c' = mon_c fg c\"", "lemma (in flowgraph) trss_spawn_no_mon_step[simp]: \n  \"((s,c),LSpawn p, (s',c'))\\<in>trss fg \\<Longrightarrow> mon fg p = {}\"", "lemma trss_no_empty_s[simp]: \"(([],c),e,(s',c'))\\<in>trss fg = False\"", "lemma trss_no_empty[simp]: \n  assumes A: \"(([],c),w,(s',c'))\\<in>trcl (trss fg)\" \n  shows \"w=[] \\<and> s'=[] \\<and> c=c'\"", "lemma trs_step_cases[cases set, case_names NO_SPAWN SPAWN]: \n  assumes A: \"(c,e,c')\\<in>tr fg\" \n  assumes A_NO_SPAWN: \"!!s ce s' csp. \\<lbrakk>\n      ((s,ce),e,(s',ce))\\<in>trss fg; \n      c={#s#}+ce; c'={#s'#}+ce\n    \\<rbrakk> \\<Longrightarrow> P\"\n  assumes A_SPAWN: \"!!s ce s' p. \\<lbrakk>\n      ((s,ce),LSpawn p,(s',{#[entry fg p]#}+ce))\\<in>trss fg; \n      c={#s#}+ce; \n      c'={#s'#}+{#[entry fg p]#}+ce; \n      e=LSpawn p\n    \\<rbrakk> \\<Longrightarrow> P\"\n  shows P", "lemma trss_stack_comp_s: \n  \"((s,c),e,(s',c'))\\<in>trss fg \\<Longrightarrow> ((s@r,c),e,(s'@r,c'))\\<in>trss fg\"", "lemma trss_stack_comp: \n  \"((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<Longrightarrow> ((s@r,c),w,(s'@r,c'))\\<in>trcl (trss fg)\"", "lemma trss_stack_decomp_s: \"\\<lbrakk> ((s@r,c),e,(s',c'))\\<in>trss fg; s\\<noteq>[] \\<rbrakk> \n  \\<Longrightarrow> \\<exists>sp'. s'=sp'@r \\<and> ((s,c),e,(sp',c'))\\<in>trss fg\"", "lemma trss_find_return: \"\\<lbrakk> \n    ((s@r,c),w,(r,c'))\\<in>trcl (trss fg); \n    !!wa wb ch. \\<lbrakk> w=wa@wb; ((s,c),wa,([],ch))\\<in>trcl (trss fg); \n                  ((r,ch),wb,(r,c'))\\<in>trcl (trss fg) \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"\n  \\<comment> \\<open>If @{term \"s=[]\"}, the proposition follows trivially\\<close>", "lemma trss_return_cases[cases set]: \"!!u r c. \\<lbrakk> \n    ((u#r,c),w,(r',c'))\\<in>trcl (trss fg);\n    !! s' u'. \\<lbrakk> r'=s'@u'#r; (([u],c),w,(s'@[u'],c'))\\<in>trcl (trss fg) \\<rbrakk> \\<Longrightarrow> P; \n    !! wa wb ch. \\<lbrakk> w=wa@wb; (([u],c),wa,([],ch))\\<in>trcl (trss fg); \n                   ((r,ch),wb,(r',c'))\\<in>trcl (trss fg) \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma (in flowgraph) trss_find_call: \n  \"!!v r' c'. \\<lbrakk> (([sp],c),w,(v#r',c')) \\<in> trcl (trss fg); r'\\<noteq>[] \\<rbrakk> \n  \\<Longrightarrow> \\<exists>rh ch p wa wb. \n        w=wa@(LCall p)#wb \\<and> \n        proc_of fg v = p \\<and> \n        (([sp],c),wa,(rh,ch))\\<in>trcl (trss fg) \\<and> \n        ((rh,ch),LCall p,((entry fg p)#r',ch))\\<in>trss fg \\<and> \n        (([entry fg p],ch),wb,([v],c'))\\<in>trcl (trss fg)\"", "lemma (in flowgraph) trss_find_call': \n  assumes A: \"(([sp],c),w,(return fg p#[u'],c')) \\<in> trcl (trss fg)\" \n  and EX: \"!!uh ch wa wb. \\<lbrakk>\n      w=wa@(LCall p)#wb; \n      (([sp],c),wa,([uh],ch))\\<in>trcl (trss fg); \n      (([uh],ch),LCall p,((entry fg p)#[u'],ch))\\<in>trss fg;\n      (uh,Call p,u')\\<in>edges fg; \n      (([entry fg p],ch),wb,([return fg p],c'))\\<in>trcl (trss fg)\n    \\<rbrakk> \\<Longrightarrow> P\" \n  shows \"P\"", "lemma (in flowgraph) trss_bot_proc_const: \n  \"!!s' u' c'. ((s@[u],c),w,(s'@[u'],c'))\\<in>trcl (trss fg) \n    \\<Longrightarrow> proc_of fg u = proc_of fg u'\"", "lemma (in flowgraph) trss_er_path_proc_const: \n  \"(([entry fg p],c),w,([return fg q],c'))\\<in>trcl (trss fg) \\<Longrightarrow> p=q\"", "lemma trss_2empty_to_2return: \"\\<lbrakk> ((s,c),w,([],c'))\\<in>trcl (trss fg); s\\<noteq>[] \\<rbrakk> \\<Longrightarrow> \n  \\<exists>w' p. w=w'@[LRet] \\<and> ((s,c),w',([return fg p],c'))\\<in>trcl (trss fg)\"", "lemma trss_2return_to_2empty: \"\\<lbrakk> ((s,c),w,([return fg p],c'))\\<in>trcl (trss fg) \\<rbrakk> \n  \\<Longrightarrow> ((s,c),w@[LRet],([],c'))\\<in>trcl (trss fg)\"", "lemma trss_env_increasing_s: \"((s,c),e,(s',c'))\\<in>trss fg \\<Longrightarrow> c\\<subseteq>#c'\"", "lemma trss_env_increasing: \"((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<Longrightarrow> c\\<subseteq>#c'\"", "lemma trss_mon_e_no_ctx: \n  \"((s,c),e,(s',c'))\\<in>trss fg \\<Longrightarrow> mon_e fg e \\<inter> mon_c fg c = {}\"", "lemma (in flowgraph) trss_mon_w_no_ctx: \n  \"((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<Longrightarrow> mon_w fg w \\<inter> mon_c fg c = {}\"", "lemma (in flowgraph) trss_modify_context_s: \n  \"!!cn. \\<lbrakk>((s,c),e,(s',c'))\\<in>trss fg; mon_e fg e \\<inter> mon_c fg cn = {}\\<rbrakk> \n    \\<Longrightarrow> \\<exists>csp. c'=csp+c \\<and> mon_c fg csp = {} \\<and> ((s,cn),e,(s',csp+cn))\\<in>trss fg\"", "lemma (in flowgraph) trss_modify_context[rule_format]: \n  \"\\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (trss fg)\\<rbrakk> \n  \\<Longrightarrow> \\<forall>cn. mon_w fg w \\<inter> mon_c fg cn = {} \n      \\<longrightarrow> (\\<exists>csp. c'=csp+c \\<and> mon_c fg csp = {} \\<and> \n                 ((s,cn),w,(s',csp+cn))\\<in>trcl (trss fg))\"", "lemma trss_add_context_s: \n  \"\\<lbrakk>((s,c),e,(s',c'))\\<in>trss fg; mon_e fg e \\<inter> mon_c fg ce = {}\\<rbrakk> \n    \\<Longrightarrow> ((s,c+ce),e,(s',c'+ce))\\<in>trss fg\"", "lemma trss_add_context: \n  \"\\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (trss fg); mon_w fg w \\<inter> mon_c fg ce = {}\\<rbrakk> \n    \\<Longrightarrow> ((s,c+ce),w,(s',c'+ce))\\<in>trcl (trss fg)\"", "lemma trss_drop_context_s: \"\\<lbrakk> ((s,c+ce),e,(s',c'+ce))\\<in>trss fg \\<rbrakk> \n  \\<Longrightarrow> ((s,c),e,(s',c'))\\<in>trss fg \\<and> mon_e fg e \\<inter> mon_c fg ce = {}\"", "lemma trss_drop_context: \"!!s c. \\<lbrakk> ((s,c+ce),w,(s',c'+ce))\\<in>trcl (trss fg) \\<rbrakk> \n  \\<Longrightarrow> ((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<and> mon_w fg w \\<inter> mon_c fg ce = {}\"", "lemma trss_xchange_context_s: \n  assumes A: \"((s,c),e,(s',csp+c))\\<in>trss fg\" \n  and M:\"mon_c fg cn \\<subseteq> mon_c fg c\" \n  shows \"((s,cn),e,(s',csp+cn))\\<in>trss fg\"", "lemma trss_xchange_context: \n  assumes A: \"((s,c),w,(s',csp+c))\\<in>trcl (trss fg)\" \n  and M:\"mon_c fg cn \\<subseteq> mon_c fg c\" \n  shows \"((s,cn),w,(s',csp+cn))\\<in>trcl (trss fg)\"", "lemma trss_drop_all_context_s[cases set, case_names dropped]: \n  assumes A: \"((s,c),e,(s',c'))\\<in>trss fg\" \n  and C: \"!!csp. \\<lbrakk> c'=csp+c; ((s,{#}),e,(s',csp))\\<in>trss fg \\<rbrakk> \\<Longrightarrow> P\" \n  shows P", "lemma trss_drop_all_context[cases set, case_names dropped]: \n  assumes A: \"((s,c),w,(s',c'))\\<in>trcl (trss fg)\" \n  and C: \"!!csp. \\<lbrakk> c'=csp+c; ((s,{#}),w,(s',csp))\\<in>trcl (trss fg)\\<rbrakk> \\<Longrightarrow> P\" \n  shows P", "lemma tr_add_context_s: \n  \"\\<lbrakk> (c,e,c')\\<in>tr fg; mon_e fg e \\<inter> mon_c fg ce = {} \\<rbrakk> \\<Longrightarrow> (c+ce,e,c'+ce)\\<in>tr fg\"", "lemma tr_add_context: \n  \"\\<lbrakk> (c,w,c')\\<in>trcl (tr fg); mon_w fg w \\<inter> mon_c fg ce = {} \\<rbrakk> \n    \\<Longrightarrow> (c+ce,w,c'+ce)\\<in>trcl (tr fg)\""], "translations": [["", "lemma mon_e_simps [simp]:\n  \"mon_e fg (LBase a) = {}\"\n  \"mon_e fg (LCall p) = mon fg p\"\n  \"mon_e fg (LRet) = {}\"\n  \"mon_e fg (LSpawn p) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mon_e fg (LBase a) = {} &&& mon_e fg (LCall p) = mon fg p) &&&\n    mon_e fg LRet = {} &&& mon_e fg (LSpawn p) = {}", "by (simp_all add: mon_e_def)\n\n\\<comment> \\<open>The monitors of a path are the monitors of all procedures that are called on the path\\<close>"], ["", "definition\n  \"mon_w fg w == \\<Union> { mon_e fg e | e. e \\<in> set w}\""], ["", "lemma mon_s_alt: \"mon_s fg s == \\<Union> (mon fg ` proc_of fg ` set s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_s fg s \\<equiv> \\<Union> (mon fg ` proc_of fg ` set s)", "by (unfold mon_s_def mon_n_def) (auto intro!: eq_reflection)"], ["", "lemma mon_c_alt: \"mon_c fg c == \\<Union> (mon_s fg ` set_mset c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg c \\<equiv> \\<Union> (mon_s fg ` set_mset c)", "by (unfold mon_c_def set_mset_def) (auto intro!: eq_reflection)"], ["", "lemma mon_w_alt: \"mon_w fg w == \\<Union> (mon_e fg ` set w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_w fg w \\<equiv> \\<Union> (mon_e fg ` set w)", "by (unfold mon_w_def) (auto intro!: eq_reflection)"], ["", "lemma mon_sI: \"\\<lbrakk>n\\<in>set s; m\\<in>mon_n fg n\\<rbrakk> \\<Longrightarrow> m\\<in>mon_s fg s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set s; m \\<in> mon_n fg n\\<rbrakk>\n    \\<Longrightarrow> m \\<in> mon_s fg s", "by (unfold mon_s_def, auto)"], ["", "lemma mon_sD: \"m\\<in>mon_s fg s \\<Longrightarrow> \\<exists>n\\<in>set s. m\\<in>mon_n fg n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> mon_s fg s \\<Longrightarrow>\n    \\<exists>n\\<in>set s. m \\<in> mon_n fg n", "by (unfold mon_s_def, auto)"], ["", "lemma mon_n_same_proc: \n  \"proc_of fg n = proc_of fg n' \\<Longrightarrow> mon_n fg n = mon_n fg n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proc_of fg n = proc_of fg n' \\<Longrightarrow> mon_n fg n = mon_n fg n'", "by (unfold mon_n_def, simp)"], ["", "lemma mon_s_same_proc: \n  \"proc_of fg ` set s = proc_of fg ` set s' \\<Longrightarrow> mon_s fg s = mon_s fg s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proc_of fg ` set s = proc_of fg ` set s' \\<Longrightarrow>\n    mon_s fg s = mon_s fg s'", "by (unfold mon_s_alt, simp)"], ["", "lemma (in flowgraph) mon_of_entry[simp]: \"mon_n fg (entry fg p) = mon fg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_n fg (entry fg p) = mon fg p", "by (unfold mon_n_def, simp add: entry_valid)"], ["", "lemma (in flowgraph) mon_of_ret[simp]: \"mon_n fg (return fg p) = mon fg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_n fg (return fg p) = mon fg p", "by (unfold mon_n_def, simp add: return_valid)"], ["", "lemma mon_c_single[simp]: \"mon_c fg {#s#} = mon_s fg s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg {#s#} = mon_s fg s", "by (unfold mon_c_def) auto"], ["", "lemma mon_s_single[simp]: \"mon_s fg [n] = mon_n fg n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_s fg [n] = mon_n fg n", "by (unfold mon_s_def) auto"], ["", "lemma mon_s_empty[simp]: \"mon_s fg [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_s fg [] = {}", "by (unfold mon_s_def) auto"], ["", "lemma mon_c_empty[simp]: \"mon_c fg {#} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg {#} = {}", "by (unfold mon_c_def) auto"], ["", "lemma mon_s_unconc: \"mon_s fg (a@b) = mon_s fg a \\<union> mon_s fg b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_s fg (a @ b) = mon_s fg a \\<union> mon_s fg b", "by (unfold mon_s_def) auto"], ["", "lemma mon_s_uncons[simp]: \"mon_s fg (a#as) = mon_n fg a \\<union> mon_s fg as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_s fg (a # as) = mon_n fg a \\<union> mon_s fg as", "by (rule mon_s_unconc[where a=\"[a]\", simplified])"], ["", "lemma mon_c_union_conc: \"mon_c fg (a+b) = mon_c fg a \\<union> mon_c fg b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg (a + b) = mon_c fg a \\<union> mon_c fg b", "by (unfold mon_c_def) auto"], ["", "lemma mon_c_add_mset_unconc: \"mon_c fg (add_mset x b) = mon_s fg x \\<union> mon_c fg b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg (add_mset x b) = mon_s fg x \\<union> mon_c fg b", "by (unfold mon_c_def) auto"], ["", "lemmas mon_c_unconc = mon_c_union_conc mon_c_add_mset_unconc"], ["", "lemma mon_cI: \"\\<lbrakk>s \\<in># c; m\\<in>mon_s fg s\\<rbrakk> \\<Longrightarrow> m\\<in>mon_c fg c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in># c; m \\<in> mon_s fg s\\<rbrakk>\n    \\<Longrightarrow> m \\<in> mon_c fg c", "by (unfold mon_c_def, auto)"], ["", "lemma mon_cD: \"\\<lbrakk>m\\<in>mon_c fg c\\<rbrakk> \\<Longrightarrow> \\<exists>s. s \\<in># c \\<and> m\\<in>mon_s fg s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> mon_c fg c \\<Longrightarrow>\n    \\<exists>s. s \\<in># c \\<and> m \\<in> mon_s fg s", "by (unfold mon_c_def, auto)"], ["", "lemma mon_s_mono: \"set s \\<subseteq> set s' \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set s \\<subseteq> set s' \\<Longrightarrow>\n    mon_s fg s \\<subseteq> mon_s fg s'", "by (unfold mon_s_def) auto"], ["", "lemma mon_c_mono: \"c\\<subseteq>#c' \\<Longrightarrow> mon_c fg c \\<subseteq> mon_c fg c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<subseteq># c' \\<Longrightarrow> mon_c fg c \\<subseteq> mon_c fg c'", "by (unfold mon_c_def) (auto dest: mset_subset_eqD)"], ["", "lemma mon_w_empty[simp]: \"mon_w fg [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_w fg [] = {}", "by (unfold mon_w_def, auto)"], ["", "lemma mon_w_single[simp]: \"mon_w fg [e] = mon_e fg e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_w fg [e] = mon_e fg e", "by (unfold mon_w_def, auto)"], ["", "lemma mon_w_unconc: \"mon_w fg (wa@wb) = mon_w fg wa \\<union> mon_w fg wb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_w fg (wa @ wb) = mon_w fg wa \\<union> mon_w fg wb", "by (unfold mon_w_def) auto"], ["", "lemma mon_w_uncons[simp]: \"mon_w fg (e#w) = mon_e fg e \\<union> mon_w fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_w fg (e # w) = mon_e fg e \\<union> mon_w fg w", "by (rule mon_w_unconc[where wa=\"[e]\", simplified])"], ["", "lemma mon_w_ileq: \"w\\<preceq>w' \\<Longrightarrow> mon_w fg w \\<subseteq> mon_w fg w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<preceq> w' \\<Longrightarrow> mon_w fg w \\<subseteq> mon_w fg w'", "by (induct rule: less_eq_list_induct) auto"], ["", "subsection \\<open>Valid configurations\\<close>"], ["", "text_raw \\<open>\\label{sec:Semantics:validity}\\<close>"], ["", "text \\<open>We call a configuration {\\em valid} if each monitor is owned by at most one thread.\\<close>"], ["", "definition\n  \"valid fg c == \\<forall>s s'. {#s, s'#} \\<subseteq># c \\<longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}\""], ["", "lemma valid_empty[simp, intro!]: \"valid fg {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg {#}", "by (unfold valid_def, auto)"], ["", "lemma valid_single[simp, intro!]: \"valid fg {#s#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg {#s#}", "by (unfold valid_def subset_mset_def) auto"], ["", "lemma valid_split1: \n  \"valid fg (c+c') \\<Longrightarrow> valid fg c \\<and> valid fg c' \\<and> mon_c fg c \\<inter> mon_c fg c' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg (c + c') \\<Longrightarrow>\n    valid fg c \\<and>\n    valid fg c' \\<and> mon_c fg c \\<inter> mon_c fg c' = {}", "apply (unfold valid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       {#s, s'#} \\<subseteq># c + c' \\<longrightarrow>\n       mon_s fg s \\<inter> mon_s fg s' = {} \\<Longrightarrow>\n    (\\<forall>s s'.\n        {#s, s'#} \\<subseteq># c \\<longrightarrow>\n        mon_s fg s \\<inter> mon_s fg s' = {}) \\<and>\n    (\\<forall>s s'.\n        {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n        mon_s fg s \\<inter> mon_s fg s' = {}) \\<and>\n    mon_c fg c \\<inter> mon_c fg c' = {}", "apply (auto simp add: mset_le_incr_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c + c' \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        x \\<in> mon_c fg c; x \\<in> mon_c fg c'\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule mon_cD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c + c' \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        \\<exists>s. s \\<in># c \\<and> x \\<in> mon_s fg s;\n        \\<exists>s. s \\<in># c' \\<and> x \\<in> mon_s fg s\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x s sa.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c + c' \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        s \\<in># c; x \\<in> mon_s fg s; sa \\<in># c';\n        x \\<in> mon_s fg sa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"{#s#}+{#sa#} \\<subseteq># c+c'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s sa.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c + c' \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        s \\<in># c; x \\<in> mon_s fg s; sa \\<in># c'; x \\<in> mon_s fg sa;\n        {#s#} + {#sa#} \\<subseteq># c + c'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x s sa.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c + c' \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        s \\<in># c; x \\<in> mon_s fg s; sa \\<in># c';\n        x \\<in> mon_s fg sa\\<rbrakk>\n       \\<Longrightarrow> {#s#} + {#sa#} \\<subseteq># c + c'", "apply (auto dest!: multi_member_split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_split2: \n  \"\\<lbrakk>valid fg c; valid fg c'; mon_c fg c \\<inter> mon_c fg c' = {}\\<rbrakk> \\<Longrightarrow> valid fg (c+c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid fg c; valid fg c';\n     mon_c fg c \\<inter> mon_c fg c' = {}\\<rbrakk>\n    \\<Longrightarrow> valid fg (c + c')", "apply (unfold valid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s s'.\n                {#s, s'#} \\<subseteq># c \\<longrightarrow>\n                mon_s fg s \\<inter> mon_s fg s' = {};\n     \\<forall>s s'.\n        {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n        mon_s fg s \\<inter> mon_s fg s' = {};\n     mon_c fg c \\<inter> mon_c fg c' = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s s'.\n                         {#s, s'#} \\<subseteq># c + c' \\<longrightarrow>\n                         mon_s fg s \\<inter> mon_s fg s' = {}", "apply (intro impI allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        \\<forall>s s'.\n           {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n           mon_s fg s \\<inter> mon_s fg s' = {};\n        mon_c fg c \\<inter> mon_c fg c' = {};\n        {#s, s'#} \\<subseteq># c + c'\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}", "apply (erule mset_2dist2_cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        \\<forall>s s'.\n           {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n           mon_s fg s \\<inter> mon_s fg s' = {};\n        mon_c fg c \\<inter> mon_c fg c' = {};\n        {#s, s'#} \\<subseteq># c\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        \\<forall>s s'.\n           {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n           mon_s fg s \\<inter> mon_s fg s' = {};\n        mon_c fg c \\<inter> mon_c fg c' = {};\n        {#s, s'#} \\<subseteq># c'\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        \\<forall>s s'.\n           {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n           mon_s fg s \\<inter> mon_s fg s' = {};\n        mon_c fg c \\<inter> mon_c fg c' = {}; s \\<in># c;\n        s' \\<in># c'\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        \\<forall>s s'.\n           {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n           mon_s fg s \\<inter> mon_s fg s' = {};\n        mon_c fg c \\<inter> mon_c fg c' = {}; s \\<in># c';\n        s' \\<in># c\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        \\<forall>s s'.\n           {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n           mon_s fg s \\<inter> mon_s fg s' = {};\n        mon_c fg c \\<inter> mon_c fg c' = {}; s \\<in># c;\n        s' \\<in># c'\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>s s'.\n                   {#s, s'#} \\<subseteq># c \\<longrightarrow>\n                   mon_s fg s \\<inter> mon_s fg s' = {};\n        \\<forall>s s'.\n           {#s, s'#} \\<subseteq># c' \\<longrightarrow>\n           mon_s fg s \\<inter> mon_s fg s' = {};\n        mon_c fg c \\<inter> mon_c fg c' = {}; s \\<in># c';\n        s' \\<in># c\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}", "apply (blast intro: mon_cI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_union_conc: \n  \"valid fg (c+c') \\<longleftrightarrow> (valid fg c \\<and> valid fg c' \\<and> mon_c fg c \\<inter> mon_c fg c' = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg (c + c') =\n    (valid fg c \\<and>\n     valid fg c' \\<and> mon_c fg c \\<inter> mon_c fg c' = {})", "by (blast dest: valid_split1 valid_split2)"], ["", "lemma valid_add_mset_conc: \n  \"valid fg (add_mset x c') \\<longleftrightarrow> (valid fg c' \\<and> mon_s fg x \\<inter> mon_c fg c' = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg (add_mset x c') =\n    (valid fg c' \\<and> mon_s fg x \\<inter> mon_c fg c' = {})", "unfolding add_mset_add_single[of x c'] valid_union_conc"], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid fg c' \\<and>\n     valid fg {#x#} \\<and> mon_c fg c' \\<inter> mon_c fg {#x#} = {}) =\n    (valid fg c' \\<and> mon_s fg x \\<inter> mon_c fg c' = {})", "by (auto simp: mon_s_def)"], ["", "lemmas valid_unconc = valid_union_conc valid_add_mset_conc"], ["", "lemma valid_no_mon: \"mon_c fg c = {} \\<Longrightarrow> valid fg c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg c = {} \\<Longrightarrow> valid fg c", "proof (unfold valid_def, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mon_c fg c = {}; {#s, s'#} \\<subseteq># c\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mon_c fg c = {}; {#s, s'#} \\<subseteq># c\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}", "assume A: \"mon_c fg c = {}\" and B: \"{#s, s'#} \\<subseteq># c\""], ["proof (state)\nthis:\n  mon_c fg c = {}\n  {#s, s'#} \\<subseteq># c\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mon_c fg c = {}; {#s, s'#} \\<subseteq># c\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}", "from mon_c_mono[OF B, of fg] A"], ["proof (chain)\npicking this:\n  mon_c fg {#s, s'#} \\<subseteq> mon_c fg c\n  mon_c fg c = {}", "have \"mon_s fg s = {}\" \"mon_s fg s' = {}\""], ["proof (prove)\nusing this:\n  mon_c fg {#s, s'#} \\<subseteq> mon_c fg c\n  mon_c fg c = {}\n\ngoal (1 subgoal):\n 1. mon_s fg s = {} &&& mon_s fg s' = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_s fg s = {}\n  mon_s fg s' = {}\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mon_c fg c = {}; {#s, s'#} \\<subseteq># c\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<inter> mon_s fg s' = {}", "thus \"mon_s fg s \\<inter> mon_s fg s' = {}\""], ["proof (prove)\nusing this:\n  mon_s fg s = {}\n  mon_s fg s' = {}\n\ngoal (1 subgoal):\n 1. mon_s fg s \\<inter> mon_s fg s' = {}", "by blast"], ["proof (state)\nthis:\n  mon_s fg s \\<inter> mon_s fg s' = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Configurations at control points\\<close>\n\n\\<comment> \\<open>A stack is {\\em at} @{term U} if its top node is from the set @{term U}\\<close>"], ["", "primrec atU_s :: \"'n set \\<Rightarrow> 'n list \\<Rightarrow> bool\" where\n  \"atU_s U [] = False\"\n| \"atU_s U (u#r) = (u\\<in>U)\""], ["", "lemma atU_s_decomp[simp]: \"atU_s U (s@s') = (atU_s U s \\<or> (s=[] \\<and> atU_s U s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atU_s U (s @ s') = (atU_s U s \\<or> s = [] \\<and> atU_s U s')", "by (induct s) auto\n\n\\<comment> \\<open>A configuration is {\\em at} @{term U} if it contains a stack that is at @{term U}\\<close>"], ["", "definition\n  \"atU U c == \\<exists>s. s \\<in># c \\<and> atU_s U s\""], ["", "lemma atU_fmt: \"\\<lbrakk>atU U c; !!ui r. \\<lbrakk>ui#r \\<in># c; ui\\<in>U\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atU U c;\n     \\<And>ui r.\n        \\<lbrakk>ui # r \\<in># c; ui \\<in> U\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (unfold atU_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>s. s \\<in># c \\<and> atU_s U s;\n     \\<And>ui r.\n        \\<lbrakk>ui # r \\<in># c; ui \\<in> U\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>ui r.\n                   \\<lbrakk>ui # r \\<in># c; ui \\<in> U\\<rbrakk>\n                   \\<Longrightarrow> P;\n        s \\<in># c; atU_s U s\\<rbrakk>\n       \\<Longrightarrow> P", "apply (case_tac s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>ui r.\n                   \\<lbrakk>ui # r \\<in># c; ui \\<in> U\\<rbrakk>\n                   \\<Longrightarrow> P;\n        s \\<in># c; atU_s U s; s = []\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>s a list.\n       \\<lbrakk>\\<And>ui r.\n                   \\<lbrakk>ui # r \\<in># c; ui \\<in> U\\<rbrakk>\n                   \\<Longrightarrow> P;\n        s \\<in># c; atU_s U s; s = a # list\\<rbrakk>\n       \\<Longrightarrow> P", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atU_union_cases[case_names left right, consumes 1]: \"\\<lbrakk> \n    atU U (c1+c2); \n    atU U c1 \\<Longrightarrow> P; \n    atU U c2 \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atU U (c1 + c2); atU U c1 \\<Longrightarrow> P;\n     atU U c2 \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (unfold atU_def) (blast elim: mset_un_cases)"], ["", "lemma atU_add: \"atU U c \\<Longrightarrow> atU U (c+ce) \\<and> atU U (ce+c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atU U c \\<Longrightarrow> atU U (c + ce) \\<and> atU U (ce + c)", "by (unfold atU_def) (auto simp add: union_ac)"], ["", "lemma atU_union[simp]: \"atU U (c1+c2) = (atU U c1 \\<or> atU U c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atU U (c1 + c2) = (atU U c1 \\<or> atU U c2)", "by (auto simp add: atU_add elim: atU_union_cases)"], ["", "lemma atU_empty[simp]: \"\\<not>atU U {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> atU U {#}", "by (unfold atU_def, auto)"], ["", "lemma atU_single[simp]: \"atU U {#s#} = atU_s U s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atU U {#s#} = atU_s U s", "by (unfold atU_def, auto)"], ["", "lemma atU_single_top[simp]: \"atU U {#u#r#} = (u\\<in>U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atU U {#u # r#} = (u \\<in> U)", "by (auto)"], ["", "(* This is also done by atU_single, atU_s.simps *)"], ["", "lemma atU_add_mset[simp]: \"atU U (add_mset c c2) = (atU_s U c \\<or> atU U c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atU U (add_mset c c2) = (atU_s U c \\<or> atU U c2)", "unfolding add_mset_add_single[of c c2] atU_union"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atU U c2 \\<or> atU U {#c#}) = (atU_s U c \\<or> atU U c2)", "by auto"], ["", "lemma atU_xchange_stack: \"atU U (add_mset (u#r) c) \\<Longrightarrow> atU U (add_mset (u#r') c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atU U (add_mset (u # r) c) \\<Longrightarrow> atU U (add_mset (u # r') c)", "by (simp)\n\n\\<comment> \\<open>A configuration is {\\em simultaneously at} @{term U} and @{term V} if it contains a stack at @{term U} and another one at @{term V}\\<close>"], ["", "definition \n  \"atUV U V c == \\<exists>su sv. {#su#}+{#sv#} \\<subseteq># c \\<and> atU_s U su \\<and> atU_s V sv\""], ["", "lemma atUV_empty[simp]: \"\\<not>atUV U V {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> atUV U V {#}", "by (unfold atUV_def) auto"], ["", "lemma atUV_single[simp]: \"\\<not>atUV U V {#s#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> atUV U V {#s#}", "by (unfold atUV_def) auto"], ["", "lemma atUV_union[simp]: \"\n  atUV U V (c1+c2) \\<longleftrightarrow> \n  (\n    (atUV U V c1) \\<or> \n    (atUV U V c2) \\<or> \n    (atU U c1 \\<and> atU V c2) \\<or> \n    (atU V c1 \\<and> atU U c2)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atUV U V (c1 + c2) =\n    (atUV U V c1 \\<or>\n     atUV U V c2 \\<or>\n     atU U c1 \\<and> atU V c2 \\<or> atU V c1 \\<and> atU U c2)", "apply (unfold atUV_def atU_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>su sv.\n        {#su#} + {#sv#} \\<subseteq># c1 + c2 \\<and>\n        atU_s U su \\<and> atU_s V sv) =\n    ((\\<exists>su sv.\n         {#su#} + {#sv#} \\<subseteq># c1 \\<and>\n         atU_s U su \\<and> atU_s V sv) \\<or>\n     (\\<exists>su sv.\n         {#su#} + {#sv#} \\<subseteq># c2 \\<and>\n         atU_s U su \\<and> atU_s V sv) \\<or>\n     (\\<exists>s. s \\<in># c1 \\<and> atU_s U s) \\<and>\n     (\\<exists>s. s \\<in># c2 \\<and> atU_s V s) \\<or>\n     (\\<exists>s. s \\<in># c1 \\<and> atU_s V s) \\<and>\n     (\\<exists>s. s \\<in># c2 \\<and> atU_s U s))", "apply (auto elim!: mset_2dist2_cases intro: mset_le_incr_right iff add: mset_le_mono_add_single)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s sa.\n       \\<lbrakk>s \\<in># c1; atU_s U s; sa \\<in># c2; atU_s V sa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>su sv.\n                            {#sv, su#} \\<subseteq># c1 + c2 \\<and>\n                            atU_s U su \\<and> atU_s V sv", "apply (subst union_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s sa.\n       \\<lbrakk>s \\<in># c1; atU_s U s; sa \\<in># c2; atU_s V sa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>su sv.\n                            {#sv, su#} \\<subseteq># c2 + c1 \\<and>\n                            atU_s U su \\<and> atU_s V sv", "apply (auto iff add: mset_le_mono_add_single)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atUV_add_mset[simp]: \"\n  atUV U V (add_mset c c2) \\<longleftrightarrow>\n  (\n    (atUV U V c2) \\<or>\n    (atU U {#c#} \\<and> atU V c2) \\<or>\n    (atU V {#c#} \\<and> atU U c2)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atUV U V (add_mset c c2) =\n    (atUV U V c2 \\<or>\n     atU U {#c#} \\<and> atU V c2 \\<or> atU V {#c#} \\<and> atU U c2)", "unfolding add_mset_add_single[of c c2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. atUV U V (c2 + {#c#}) =\n    (atUV U V c2 \\<or>\n     atU U {#c#} \\<and> atU V c2 \\<or> atU V {#c#} \\<and> atU U c2)", "unfolding atUV_union"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atUV U V c2 \\<or>\n     atUV U V {#c#} \\<or>\n     atU U c2 \\<and> atU V {#c#} \\<or> atU V c2 \\<and> atU U {#c#}) =\n    (atUV U V c2 \\<or>\n     atU U {#c#} \\<and> atU V c2 \\<or> atU V {#c#} \\<and> atU U c2)", "by auto"], ["", "lemma atUV_union_cases[case_names left right lr rl, consumes 1]: \"\\<lbrakk>\n    atUV U V (c1+c2); \n    atUV U V c1 \\<Longrightarrow> P; \n    atUV U V c2 \\<Longrightarrow> P; \n    \\<lbrakk>atU U c1; atU V c2\\<rbrakk> \\<Longrightarrow> P; \n    \\<lbrakk>atU V c1; atU U c2\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atUV U V (c1 + c2); atUV U V c1 \\<Longrightarrow> P;\n     atUV U V c2 \\<Longrightarrow> P;\n     \\<lbrakk>atU U c1; atU V c2\\<rbrakk> \\<Longrightarrow> P;\n     \\<lbrakk>atU V c1; atU U c2\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by auto"], ["", "subsection \\<open>Operational semantics\\<close>"], ["", "subsubsection \"Semantic reference point\""], ["", "text \\<open>We now define our semantic reference point. We assess correctness and completeness of analyses relative to this reference point.\\<close>"], ["", "inductive_set \n  refpoint :: \"('n,'p,'ba,'m,'more) flowgraph_rec_scheme \\<Rightarrow> \n                 ('n conf \\<times> ('p,'ba) label \\<times> 'n conf) set\"\n  for fg\nwhere\n  \\<comment> \\<open>A base edge transforms the top node of one stack and leaves the other stacks untouched.\\<close>\n  refpoint_base: \"\\<lbrakk> (u,Base a,v)\\<in>edges fg; valid fg ({#u#r#}+c) \\<rbrakk> \n    \\<Longrightarrow> (add_mset (u#r) c,LBase a,add_mset (v#r) c)\\<in>refpoint fg\" |\n  \\<comment> \\<open>A call edge transforms the top node of a stack and then pushes the entry node of the called procedure onto that stack. \n      It can only be executed if all monitors the called procedure synchronizes on are available. Reentrant monitors are modeled here by\n      checking availability of monitors just against the other stacks, not against the stack of the thread that executes the call. The other stacks are left untouched.\\<close>\n  refpoint_call: \"\\<lbrakk> (u,Call p,v)\\<in>edges fg; valid fg ({#u#r#}+c); \n                    mon fg p \\<inter> mon_c fg c = {} \\<rbrakk> \n    \\<Longrightarrow> (add_mset (u#r) c,LCall p, add_mset (entry fg p#v#r) c)\\<in>refpoint fg\" |\n  \\<comment> \\<open>A return step pops a return node from a stack. There is no corresponding flowgraph edge for a return step. The other stacks are left untouched.\\<close>\n  refpoint_ret: \"\\<lbrakk> valid fg ({#return fg p#r#}+c) \\<rbrakk> \n    \\<Longrightarrow> (add_mset (return fg p#r) c,LRet,(add_mset r c))\\<in>refpoint fg\" |\n  \\<comment> \\<open>A spawn edge transforms the top node of a stack and adds a new stack to the environment, with the entry node of the spawned procedure at the top and no stored return addresses. The other stacks are also left untouched.\\<close>\n  refpoint_spawn: \"\\<lbrakk> (u,Spawn p,v)\\<in>edges fg; valid fg (add_mset (u#r) c) \\<rbrakk> \n    \\<Longrightarrow> (add_mset (u#r) c,LSpawn p, add_mset (v#r) (add_mset [entry fg p] c))\\<in>refpoint fg\""], ["", "text \\<open>\n  Instead of working directly with the reference point semantics, we define the operational semantics of flowgraphs by describing how a single stack is transformed in a context of environment threads, \n  and then use the theory developed in Section~\\ref{thy:ThreadTracking} to derive an interleaving semantics. \n  Note that this semantics is also defined for invalid configurations (cf. Section~\\ref{sec:Semantics:validity}). In Section~\\ref{sec:Semantics:valid_preserve} we will show that it preserves validity\n  of a configuration, and in Section~\\ref{sec:Semantics: refpoint_eq} we show that it is equivalent \n  to the reference point semantics on valid configurations.\n\\<close>"], ["", "inductive_set\n  trss :: \"('n,'p,'ba,'m,'more) flowgraph_rec_scheme \\<Rightarrow> \n             (('n list * 'n conf) * ('p,'ba) label * ('n list * 'n conf)) set\"\n  for fg\n  where\n    trss_base: \"\\<lbrakk>(u,Base a,v)\\<in>edges fg\\<rbrakk> \\<Longrightarrow> \n      ((u#r,c), LBase a, (v#r,c) ) \\<in> trss fg\"\n  | trss_call: \"\\<lbrakk>(u,Call p,v)\\<in>edges fg; mon fg p \\<inter> mon_c fg c = {} \\<rbrakk> \\<Longrightarrow> \n    ((u#r,c),LCall p, ((entry fg p)#v#r,c)) \\<in> trss fg\"\n  | trss_ret: \"((((return fg p)#r),c),LRet,(r,c)) \\<in> trss fg\"\n  | trss_spawn: \"\\<lbrakk> (u,Spawn p,v)\\<in>edges fg \\<rbrakk> \\<Longrightarrow> \n    ((u#r,c),LSpawn p,(v#r,add_mset [entry fg p] c)) \\<in> trss fg\"\n\n(* Not needed\nlemma trss_base': \"\\<lbrakk>(u,Base a,v)\\<in>edges fg; s=u#r; s'=v#r; e=LBase a\\<rbrakk> \\<Longrightarrow> ((s,c), e, (s',c) ) \\<in> trss fg\"\n  by (simp add: trss_base)\nlemma trss_call': \"\\<lbrakk>(u,Call p,v)\\<in>edges fg; mon fg p \\<inter> mon_c fg c = {}; s=u#r; e=LCall p; s'=(entry fg p)#v#r\\<rbrakk> \\<Longrightarrow> ((s,c),e, (s',c)) \\<in> trss fg\"\n  by (simp add: trss_call)\nlemma trss_ret': \"\\<lbrakk> s=(return fg p)#r; e=LRet \\<rbrakk> \\<Longrightarrow> ((s,c),e,(r,c)) \\<in> trss fg\"\n  by (simp add: trss_ret)\nlemma trss_spawn': \"\\<lbrakk> (u,Spawn p,v)\\<in>edges fg; s=u#r; e=LSpawn p; s'=v#r; c'={#[entry fg p]#}+c\\<rbrakk> \\<Longrightarrow> ((s,c),e,(s',c')) \\<in> trss fg\"\n  by (simp add: trss_spawn)\n*)\n\n\\<comment> \\<open>The interleaving semantics is generated using the general techniques from Section~\\ref{thy:ThreadTracking}\\<close>"], ["", "abbreviation tr where \"tr fg == gtr (trss fg)\"\n\\<comment> \\<open>We also generate the loc/env-semantics\\<close>"], ["", "abbreviation trp where \"trp fg == gtrp (trss fg)\""], ["", "subsection \"Basic properties\""], ["", "subsubsection \"Validity\""], ["", "text_raw\\<open>\\label{sec:Semantics:valid_preserve}\\<close>"], ["", "lemma (in flowgraph) trss_valid_preserve_s: \n  \"\\<lbrakk>valid fg (add_mset s c); ((s,c),e,(s',c'))\\<in>trss fg\\<rbrakk> \\<Longrightarrow> valid fg (add_mset s' c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid fg (add_mset s c);\n     ((s, c), e, s', c') \\<in> trss fg\\<rbrakk>\n    \\<Longrightarrow> valid fg (add_mset s' c')", "apply (erule trss.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u a v r ca.\n       \\<lbrakk>valid fg (add_mset s c); s = u # r; c = ca; e = LBase a;\n        s' = v # r; c' = ca; (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> valid fg (add_mset s' c')\n 2. \\<And>u p v ca r.\n       \\<lbrakk>valid fg (add_mset s c); s = u # r; c = ca; e = LCall p;\n        s' = entry fg p # v # r; c' = ca; (u, Call p, v) \\<in> edges fg;\n        mon fg p \\<inter> mon_c fg ca = {}\\<rbrakk>\n       \\<Longrightarrow> valid fg (add_mset s' c')\n 3. \\<And>p r ca.\n       \\<lbrakk>valid fg (add_mset s c); s = return fg p # r; c = ca;\n        e = LRet; s' = r; c' = ca\\<rbrakk>\n       \\<Longrightarrow> valid fg (add_mset s' c')\n 4. \\<And>u p v r ca.\n       \\<lbrakk>valid fg (add_mset s c); s = u # r; c = ca; e = LSpawn p;\n        s' = v # r; c' = add_mset [entry fg p] ca;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> valid fg (add_mset s' c')", "apply (simp_all add: valid_unconc mon_c_unconc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u a v r ca.\n       \\<lbrakk>valid fg ca \\<and>\n                (mon_n fg u \\<union> mon_s fg r) \\<inter> mon_c fg ca = {};\n        s = u # r; c = ca; e = LBase a; s' = v # r; c' = ca;\n        (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (mon_n fg v \\<union> mon_s fg r) \\<inter>\n                         mon_c fg ca =\n                         {}\n 2. \\<And>u p v ca r.\n       \\<lbrakk>valid fg ca \\<and>\n                (mon_n fg u \\<union> mon_s fg r) \\<inter> mon_c fg ca = {};\n        s = u # r; c = ca; e = LCall p; s' = entry fg p # v # r; c' = ca;\n        (u, Call p, v) \\<in> edges fg;\n        mon fg p \\<inter> mon_c fg ca = {}\\<rbrakk>\n       \\<Longrightarrow> (mon fg p \\<union>\n                          (mon_n fg v \\<union> mon_s fg r)) \\<inter>\n                         mon_c fg ca =\n                         {}\n 3. \\<And>p r ca.\n       \\<lbrakk>valid fg ca \\<and>\n                (mon fg p \\<union> mon_s fg r) \\<inter> mon_c fg ca = {};\n        s = return fg p # r; c = ca; e = LRet; s' = r; c' = ca\\<rbrakk>\n       \\<Longrightarrow> mon_s fg r \\<inter> mon_c fg ca = {}\n 4. \\<And>u p v r ca.\n       \\<lbrakk>valid fg ca \\<and>\n                (mon_n fg u \\<union> mon_s fg r) \\<inter> mon_c fg ca = {};\n        s = u # r; c = ca; e = LSpawn p; s' = v # r;\n        c' = add_mset [entry fg p] ca;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (mon_n fg v \\<union> mon_s fg r) \\<inter>\n                         mon_c fg ca =\n                         {}", "by (blast dest: mon_n_same_proc edges_part)+"], ["", "lemma (in flowgraph) trss_valid_preserve: \n  \"\\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (trss fg); valid fg ({#s#}+c)\\<rbrakk> \\<Longrightarrow> valid fg ({#s'#}+c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n     valid fg ({#s#} + c)\\<rbrakk>\n    \\<Longrightarrow> valid fg ({#s'#} + c')", "by (induct rule: trcl_pair_induct) (auto intro: trss_valid_preserve_s)"], ["", "lemma (in flowgraph) tr_valid_preserve_s: \n  \"\\<lbrakk>(c,e,c')\\<in>tr fg; valid fg c\\<rbrakk> \\<Longrightarrow> valid fg c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, e, c') \\<in> tr fg; valid fg c\\<rbrakk>\n    \\<Longrightarrow> valid fg c'", "by (rule gtr_preserve_s[where P=\"valid fg\"]) (auto dest: trss_valid_preserve_s)"], ["", "lemma (in flowgraph) tr_valid_preserve: \n  \"\\<lbrakk>(c,w,c')\\<in>trcl (tr fg); valid fg c\\<rbrakk> \\<Longrightarrow> valid fg c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); valid fg c\\<rbrakk>\n    \\<Longrightarrow> valid fg c'", "by (rule gtr_preserve[where P=\"valid fg\"]) (auto dest: trss_valid_preserve_s)"], ["", "lemma (in flowgraph) trp_valid_preserve_s: \n  \"\\<lbrakk>((s,c),e,(s',c'))\\<in>trp fg; valid fg (add_mset s c)\\<rbrakk> \\<Longrightarrow> valid fg (add_mset s' c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), e, s', c') \\<in> trp fg;\n     valid fg (add_mset s c)\\<rbrakk>\n    \\<Longrightarrow> valid fg (add_mset s' c')", "by (rule gtrp_preserve_s[where P=\"valid fg\"]) (auto dest: trss_valid_preserve_s)"], ["", "lemma (in flowgraph) trp_valid_preserve: \n  \"\\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (trp fg); valid fg ({#s#}+c)\\<rbrakk> \\<Longrightarrow> valid fg (add_mset s' c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trp fg);\n     valid fg ({#s#} + c)\\<rbrakk>\n    \\<Longrightarrow> valid fg (add_mset s' c')", "by (rule gtrp_preserve[where P=\"valid fg\"]) (auto dest: trss_valid_preserve_s)"], ["", "subsubsection \"Equivalence to reference point\""], ["", "text_raw \\<open>\\label{sec:Semantics: refpoint_eq}\\<close>\n\\<comment> \\<open>The equivalence between the semantics that we derived using the techniques from Section~\\ref{thy:ThreadTracking} and the semantic reference point is shown nearly automatically.\\<close>"], ["", "lemma refpoint_eq_s: \"valid fg c \\<Longrightarrow> ((c,e,c')\\<in>refpoint fg) \\<longleftrightarrow> ((c,e,c')\\<in>tr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg c \\<Longrightarrow>\n    ((c, e, c') \\<in> refpoint fg) = ((c, e, c') \\<in> tr fg)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid fg c; (c, e, c') \\<in> refpoint fg\\<rbrakk>\n    \\<Longrightarrow> (c, e, c') \\<in> tr fg\n 2. \\<lbrakk>valid fg c; (c, e, c') \\<in> tr fg\\<rbrakk>\n    \\<Longrightarrow> (c, e, c') \\<in> refpoint fg", "apply (erule refpoint.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>u a v r ca.\n       \\<lbrakk>valid fg c; c = add_mset (u # r) ca; e = LBase a;\n        c' = add_mset (v # r) ca; (u, Base a, v) \\<in> edges fg;\n        valid fg ({#u # r#} + ca)\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> tr fg\n 2. \\<And>u p v r ca.\n       \\<lbrakk>valid fg c; c = add_mset (u # r) ca; e = LCall p;\n        c' = add_mset (entry fg p # v # r) ca;\n        (u, Call p, v) \\<in> edges fg; valid fg ({#u # r#} + ca);\n        mon fg p \\<inter> mon_c fg ca = {}\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> tr fg\n 3. \\<And>p r ca.\n       \\<lbrakk>valid fg c; c = add_mset (return fg p # r) ca; e = LRet;\n        c' = add_mset r ca; valid fg ({#return fg p # r#} + ca)\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> tr fg\n 4. \\<And>u p v r ca.\n       \\<lbrakk>valid fg c; c = add_mset (u # r) ca; e = LSpawn p;\n        c' = add_mset (v # r) (add_mset [entry fg p] ca);\n        (u, Spawn p, v) \\<in> edges fg;\n        valid fg (add_mset (u # r) ca)\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> tr fg\n 5. \\<lbrakk>valid fg c; (c, e, c') \\<in> tr fg\\<rbrakk>\n    \\<Longrightarrow> (c, e, c') \\<in> refpoint fg", "apply (auto intro: gtrI_s trss.intros simp add: union_assoc add_mset_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid fg c; (c, e, c') \\<in> tr fg\\<rbrakk>\n    \\<Longrightarrow> (c, e, c') \\<in> refpoint fg", "apply (erule gtrE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ce s' ce'.\n       \\<lbrakk>valid fg c; c = add_mset s ce; c' = add_mset s' ce';\n        ((s, ce), e, s', ce') \\<in> trss fg\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> refpoint fg", "apply (erule trss.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s ce s' ce' u a v r ca.\n       \\<lbrakk>valid fg c; c = add_mset s ce; c' = add_mset s' ce';\n        s = u # r; ce = ca; e = LBase a; s' = v # r; ce' = ca;\n        (u, Base a, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> refpoint fg\n 2. \\<And>s ce s' ce' u p v ca r.\n       \\<lbrakk>valid fg c; c = add_mset s ce; c' = add_mset s' ce';\n        s = u # r; ce = ca; e = LCall p; s' = entry fg p # v # r; ce' = ca;\n        (u, Call p, v) \\<in> edges fg;\n        mon fg p \\<inter> mon_c fg ca = {}\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> refpoint fg\n 3. \\<And>s ce s' ce' p r ca.\n       \\<lbrakk>valid fg c; c = add_mset s ce; c' = add_mset s' ce';\n        s = return fg p # r; ce = ca; e = LRet; s' = r; ce' = ca\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> refpoint fg\n 4. \\<And>s ce s' ce' u p v r ca.\n       \\<lbrakk>valid fg c; c = add_mset s ce; c' = add_mset s' ce';\n        s = u # r; ce = ca; e = LSpawn p; s' = v # r;\n        ce' = add_mset [entry fg p] ca;\n        (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (c, e, c') \\<in> refpoint fg", "apply (auto intro: refpoint.intros simp add: union_assoc[symmetric] add_mset_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in flowgraph) refpoint_eq: \n  \"valid fg c \\<Longrightarrow> ((c,w,c')\\<in>trcl (refpoint fg)) \\<longleftrightarrow> ((c,w,c')\\<in>trcl (tr fg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg c \\<Longrightarrow>\n    ((c, w, c') \\<in> trcl (refpoint fg)) = ((c, w, c') \\<in> trcl (tr fg))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid fg c \\<Longrightarrow>\n    ((c, w, c') \\<in> trcl (refpoint fg)) = ((c, w, c') \\<in> trcl (tr fg))", "have \"((c,w,c')\\<in>trcl (refpoint fg)) \\<Longrightarrow> valid fg c \\<Longrightarrow> ((c,w,c')\\<in>trcl (tr fg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, w, c') \\<in> trcl (refpoint fg); valid fg c\\<rbrakk>\n    \\<Longrightarrow> (c, w, c') \\<in> trcl (tr fg)", "by (induct rule: trcl.induct) (auto simp add: refpoint_eq_s tr_valid_preserve_s)"], ["proof (state)\nthis:\n  \\<lbrakk>(c, w, c') \\<in> trcl (refpoint fg); valid fg c\\<rbrakk>\n  \\<Longrightarrow> (c, w, c') \\<in> trcl (tr fg)\n\ngoal (1 subgoal):\n 1. valid fg c \\<Longrightarrow>\n    ((c, w, c') \\<in> trcl (refpoint fg)) = ((c, w, c') \\<in> trcl (tr fg))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(c, w, c') \\<in> trcl (refpoint fg); valid fg c\\<rbrakk>\n  \\<Longrightarrow> (c, w, c') \\<in> trcl (tr fg)\n\ngoal (1 subgoal):\n 1. valid fg c \\<Longrightarrow>\n    ((c, w, c') \\<in> trcl (refpoint fg)) = ((c, w, c') \\<in> trcl (tr fg))", "have \"((c,w,c')\\<in>trcl (tr fg)) \\<Longrightarrow> valid fg c \\<Longrightarrow> ((c,w,c')\\<in>trcl (refpoint fg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); valid fg c\\<rbrakk>\n    \\<Longrightarrow> (c, w, c') \\<in> trcl (refpoint fg)", "by (induct rule: trcl.induct) (auto simp add: refpoint_eq_s tr_valid_preserve_s)"], ["proof (state)\nthis:\n  \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); valid fg c\\<rbrakk>\n  \\<Longrightarrow> (c, w, c') \\<in> trcl (refpoint fg)\n\ngoal (1 subgoal):\n 1. valid fg c \\<Longrightarrow>\n    ((c, w, c') \\<in> trcl (refpoint fg)) = ((c, w, c') \\<in> trcl (tr fg))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(c, w, c') \\<in> trcl (refpoint fg); valid fg c\\<rbrakk>\n  \\<Longrightarrow> (c, w, c') \\<in> trcl (tr fg)\n  \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); valid fg c\\<rbrakk>\n  \\<Longrightarrow> (c, w, c') \\<in> trcl (refpoint fg)", "show \"valid fg c \\<Longrightarrow> ((c,w,c')\\<in>trcl (refpoint fg)) = ((c,w,c')\\<in>trcl (tr fg))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(c, w, c') \\<in> trcl (refpoint fg); valid fg c\\<rbrakk>\n  \\<Longrightarrow> (c, w, c') \\<in> trcl (tr fg)\n  \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); valid fg c\\<rbrakk>\n  \\<Longrightarrow> (c, w, c') \\<in> trcl (refpoint fg)\n\ngoal (1 subgoal):\n 1. valid fg c \\<Longrightarrow>\n    ((c, w, c') \\<in> trcl (refpoint fg)) = ((c, w, c') \\<in> trcl (tr fg))", ".."], ["proof (state)\nthis:\n  valid fg c \\<Longrightarrow>\n  ((c, w, c') \\<in> trcl (refpoint fg)) = ((c, w, c') \\<in> trcl (tr fg))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Case distinctions\\<close>"], ["", "lemma trss_c_cases_s[cases set, case_names no_spawn spawn]: \"\\<lbrakk> \n    ((s,c),e,(s',c'))\\<in>trss fg; \n    \\<lbrakk> c'=c \\<rbrakk> \\<Longrightarrow> P; \n    !!p u v. \\<lbrakk> e=LSpawn p; (u,Spawn p,v)\\<in>edges fg; \n               hd s=u; hd s'=v; c'={#[ entry fg p ]#}+c \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), e, s', c') \\<in> trss fg; c' = c \\<Longrightarrow> P;\n     \\<And>p u v.\n        \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n         hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto elim!: trss.cases)"], ["", "lemma trss_c_fmt_s: \"\\<lbrakk>((s,c),e,(s',c'))\\<in>trss fg\\<rbrakk> \n  \\<Longrightarrow> \\<exists>csp. c'=csp+c \\<and> \n        (csp={#} \\<or> (\\<exists>p. e=LSpawn p \\<and> csp={#[ entry fg p ]#}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> trss fg \\<Longrightarrow>\n    \\<exists>csp.\n       c' = csp + c \\<and>\n       (csp = {#} \\<or>\n        (\\<exists>p. e = LSpawn p \\<and> csp = {#[entry fg p]#}))", "by (force elim!: trss_c_cases_s)"], ["", "lemma (in flowgraph) trss_c'_split_s: \"\\<lbrakk>\n    ((s,c),e,(s',c'))\\<in>trss fg; \n    !!csp. \\<lbrakk>c'=csp+c; mon_c fg csp={}\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), e, s', c') \\<in> trss fg;\n     \\<And>csp.\n        \\<lbrakk>c' = csp + c; mon_c fg csp = {}\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (erule trss_c_cases_s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>csp.\n                \\<lbrakk>c' = csp + c; mon_c fg csp = {}\\<rbrakk>\n                \\<Longrightarrow> P;\n     c' = c\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<And>p u v.\n       \\<lbrakk>\\<And>csp.\n                   \\<lbrakk>c' = csp + c; mon_c fg csp = {}\\<rbrakk>\n                   \\<Longrightarrow> P;\n        e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u; hd s' = v;\n        c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "apply (subgoal_tac \"c'={#}+c\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>csp.\n                \\<lbrakk>c' = csp + c; mon_c fg csp = {}\\<rbrakk>\n                \\<Longrightarrow> P;\n     c' = c; c' = {#} + c\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>\\<And>csp.\n                \\<lbrakk>c' = csp + c; mon_c fg csp = {}\\<rbrakk>\n                \\<Longrightarrow> P;\n     c' = c\\<rbrakk>\n    \\<Longrightarrow> c' = {#} + c\n 3. \\<And>p u v.\n       \\<lbrakk>\\<And>csp.\n                   \\<lbrakk>c' = csp + c; mon_c fg csp = {}\\<rbrakk>\n                   \\<Longrightarrow> P;\n        e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u; hd s' = v;\n        c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "apply (fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>csp.\n                \\<lbrakk>c' = csp + c; mon_c fg csp = {}\\<rbrakk>\n                \\<Longrightarrow> P;\n     c' = c\\<rbrakk>\n    \\<Longrightarrow> c' = {#} + c\n 2. \\<And>p u v.\n       \\<lbrakk>\\<And>csp.\n                   \\<lbrakk>c' = csp + c; mon_c fg csp = {}\\<rbrakk>\n                   \\<Longrightarrow> P;\n        e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u; hd s' = v;\n        c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trss_c_cases[cases set, case_names c_case]: \"!!s c. \\<lbrakk> \n    ((s,c),w,(s',c'))\\<in>trcl (trss fg); \n    !!csp. \\<lbrakk> c'=csp+c; !!s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> \n                                               (u,Spawn p,v)\\<in>edges fg \\<and> \n                                               initialproc fg p\\<rbrakk> \n            \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c.\n       \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "proof (induct w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s c.\n       \\<lbrakk>((s, c), [], s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case Nil"], ["proof (state)\nthis:\n  ((s, c), [], s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<And>s c.\n       \\<lbrakk>((s, c), [], s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "note A=this"], ["proof (state)\nthis:\n  ((s, c), [], s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<And>s c.\n       \\<lbrakk>((s, c), [], s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "hence \"s'=s\" \"c'=c\""], ["proof (prove)\nusing this:\n  ((s, c), [], s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. s' = s &&& c' = c", "by simp_all"], ["proof (state)\nthis:\n  s' = s\n  c' = c\n\ngoal (2 subgoals):\n 1. \\<And>s c.\n       \\<lbrakk>((s, c), [], s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "hence \"c'={#}+c\""], ["proof (prove)\nusing this:\n  s' = s\n  c' = c\n\ngoal (1 subgoal):\n 1. c' = {#} + c", "by simp"], ["proof (state)\nthis:\n  c' = {#} + c\n\ngoal (2 subgoals):\n 1. \\<And>s c.\n       \\<lbrakk>((s, c), [], s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "from A(2)[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      s \\<in># {#} \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and>\n         initialproc fg p) \\<Longrightarrow>\n  P", "show P"], ["proof (prove)\nusing this:\n  (\\<And>s.\n      s \\<in># {#} \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and>\n         initialproc fg p) \\<Longrightarrow>\n  P\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (Cons e w)"], ["proof (state)\nthis:\n  \\<lbrakk>((?s, ?c), w, s', c') \\<in> trcl (trss fg);\n   \\<And>csp.\n      \\<lbrakk>c' = csp + ?c;\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  ((s, c), e # w, s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "note IHP=this"], ["proof (state)\nthis:\n  \\<lbrakk>((?s, ?c), w, s', c') \\<in> trcl (trss fg);\n   \\<And>csp.\n      \\<lbrakk>c' = csp + ?c;\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  ((s, c), e # w, s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?s, ?c), w, s', c') \\<in> trcl (trss fg);\n   \\<And>csp.\n      \\<lbrakk>c' = csp + ?c;\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  ((s, c), e # w, s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P", "obtain sh ch where SPLIT1: \"((s,c),e,(sh,ch))\\<in>trss fg\" and SPLIT2: \"((sh,ch),w,(s',c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((?s, ?c), w, s', c') \\<in> trcl (trss fg);\n   \\<And>csp.\n      \\<lbrakk>c' = csp + ?c;\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  ((s, c), e # w, s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>((s, c), e, sh, ch) \\<in> trss fg;\n         ((sh, ch), w, s', c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: trcl_uncons)"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n                    \\<And>csp.\n                       \\<lbrakk>c' = csp + c;\n                        \\<And>s.\n                           s \\<in># csp \\<Longrightarrow>\n                           \\<exists>p u v.\n                              s = [entry fg p] \\<and>\n                              (u, Spawn p, v) \\<in> edges fg \\<and>\n                              initialproc fg p\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((s, c), a # w, s', c') \\<in> trcl (trss fg);\n        \\<And>csp.\n           \\<lbrakk>c' = csp + c;\n            \\<And>s.\n               s \\<in># csp \\<Longrightarrow>\n               \\<exists>p u v.\n                  s = [entry fg p] \\<and>\n                  (u, Spawn p, v) \\<in> edges fg \\<and>\n                  initialproc fg p\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "from SPLIT2"], ["proof (chain)\npicking this:\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)", "show ?case"], ["proof (prove)\nusing this:\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. P", "proof (rule IHP(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>csp.\n       \\<lbrakk>c' = csp + ch;\n        \\<And>s.\n           s \\<in># csp \\<Longrightarrow>\n           \\<exists>p u v.\n              s = [entry fg p] \\<and>\n              (u, Spawn p, v) \\<in> edges fg \\<and>\n              initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> P", "fix csp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>csp.\n       \\<lbrakk>c' = csp + ch;\n        \\<And>s.\n           s \\<in># csp \\<Longrightarrow>\n           \\<exists>p u v.\n              s = [entry fg p] \\<and>\n              (u, Spawn p, v) \\<in> edges fg \\<and>\n              initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> P", "assume C'FMT: \"c'=csp+ch\" and CSPFMT: \"!!s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> (u,Spawn p, v)\\<in>edges fg \\<and> initialproc fg p\""], ["proof (state)\nthis:\n  c' = csp + ch\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>csp.\n       \\<lbrakk>c' = csp + ch;\n        \\<And>s.\n           s \\<in># csp \\<Longrightarrow>\n           \\<exists>p u v.\n              s = [entry fg p] \\<and>\n              (u, Spawn p, v) \\<in> edges fg \\<and>\n              initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> P", "from SPLIT1"], ["proof (chain)\npicking this:\n  ((s, c), e, sh, ch) \\<in> trss fg", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, c), e, sh, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. P", "proof (rule trss_c_cases_s)"], ["proof (state)\ngoal (2 subgoals):\n 1. ch = c \\<Longrightarrow> P\n 2. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "assume \"ch=c\""], ["proof (state)\nthis:\n  ch = c\n\ngoal (2 subgoals):\n 1. ch = c \\<Longrightarrow> P\n 2. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "with C'FMT CSPFMT IHP(3)"], ["proof (chain)\npicking this:\n  c' = csp + ch\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n  ch = c", "show ?case"], ["proof (prove)\nusing this:\n  c' = csp + ch\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n  ch = c\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "assume EFMT: \"e=LSpawn p\" and CHFMT: \"ch={#[entry fg p]#}+c\""], ["proof (state)\nthis:\n  e = LSpawn p\n  ch = {#[entry fg p]#} + c\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "with C'FMT"], ["proof (chain)\npicking this:\n  c' = csp + ch\n  e = LSpawn p\n  ch = {#[entry fg p]#} + c", "have \"c'=({#[entry fg p]#}+csp)+c\""], ["proof (prove)\nusing this:\n  c' = csp + ch\n  e = LSpawn p\n  ch = {#[entry fg p]#} + c\n\ngoal (1 subgoal):\n 1. c' = {#[entry fg p]#} + csp + c", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  c' = {#[entry fg p]#} + csp + c\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  c' = {#[entry fg p]#} + csp + c\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "from EFMT SPLIT1"], ["proof (chain)\npicking this:\n  e = LSpawn p\n  ((s, c), e, sh, ch) \\<in> trss fg", "have \"\\<exists>u v. (u,Spawn p, v)\\<in>edges fg\""], ["proof (prove)\nusing this:\n  e = LSpawn p\n  ((s, c), e, sh, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<exists>u v. (u, Spawn p, v) \\<in> edges fg", "by (blast elim!: trss.cases)"], ["proof (state)\nthis:\n  \\<exists>u v. (u, Spawn p, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "hence \"!!s. s \\<in># {#[entry fg p]#} + csp \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> (u,Spawn p, v)\\<in>edges fg \\<and> initialproc fg p\""], ["proof (prove)\nusing this:\n  \\<exists>u v. (u, Spawn p, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in># {#[entry fg p]#} + csp \\<Longrightarrow>\n       \\<exists>p u v.\n          s = [entry fg p] \\<and>\n          (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "using CSPFMT"], ["proof (prove)\nusing this:\n  \\<exists>u v. (u, Spawn p, v) \\<in> edges fg\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in># {#[entry fg p]#} + csp \\<Longrightarrow>\n       \\<exists>p u v.\n          s = [entry fg p] \\<and>\n          (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "by (unfold initialproc_def, erule_tac mset_un_cases) (auto)"], ["proof (state)\nthis:\n  ?s \\<in># {#[entry fg p]#} + csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd sh = v; ch = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  c' = {#[entry fg p]#} + csp + c\n  ?s \\<in># {#[entry fg p]#} + csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "show ?case"], ["proof (prove)\nusing this:\n  c' = {#[entry fg p]#} + csp + c\n  ?s \\<in># {#[entry fg p]#} + csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. P", "using IHP(3)"], ["proof (prove)\nusing this:\n  c' = {#[entry fg p]#} + csp + c\n  ?s \\<in># {#[entry fg p]#} + csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  \\<lbrakk>c' = ?csp + c;\n   \\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p u v.\n         s = [entry fg p] \\<and>\n         (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) c_of_initial_no_mon: \n  assumes A: \"!!s. s \\<in># csp \\<Longrightarrow> \\<exists>p. s=[entry fg p] \\<and> initialproc fg p\" \n  shows \"mon_c fg csp = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg csp = {}", "by (unfold mon_c_def) (auto dest: A initial_no_mon)"], ["", "(* WARNING: Don't declare this [simp], as c=c' will cause a simplifier loop *)"], ["", "lemma (in flowgraph) trss_c_no_mon_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>trss fg\" \n  shows \"mon_c fg c' = mon_c fg c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg c' = mon_c fg c", "using A"], ["proof (prove)\nusing this:\n  ((s, c), e, s', c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. mon_c fg c' = mon_c fg c", "proof (erule_tac trss_c_cases_s)"], ["proof (state)\ngoal (2 subgoals):\n 1. c' = c \\<Longrightarrow> mon_c fg c' = mon_c fg c\n 2. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c' = mon_c fg c", "assume \"c'=c\""], ["proof (state)\nthis:\n  c' = c\n\ngoal (2 subgoals):\n 1. c' = c \\<Longrightarrow> mon_c fg c' = mon_c fg c\n 2. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c' = mon_c fg c", "thus ?thesis"], ["proof (prove)\nusing this:\n  c' = c\n\ngoal (1 subgoal):\n 1. mon_c fg c' = mon_c fg c", "by simp"], ["proof (state)\nthis:\n  mon_c fg c' = mon_c fg c\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c' = mon_c fg c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c' = mon_c fg c", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c' = mon_c fg c", "assume EFMT: \"e=LSpawn p\" and C'FMT: \"c'={#[entry fg p]#} + c\""], ["proof (state)\nthis:\n  e = LSpawn p\n  c' = {#[entry fg p]#} + c\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c' = mon_c fg c", "from EFMT"], ["proof (chain)\npicking this:\n  e = LSpawn p", "obtain u v where \"(u,Spawn p,v)\\<in>edges fg\""], ["proof (prove)\nusing this:\n  e = LSpawn p\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        (u, Spawn p, v) \\<in> edges fg \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using A"], ["proof (prove)\nusing this:\n  e = LSpawn p\n  ((s, c), e, s', c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        (u, Spawn p, v) \\<in> edges fg \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: trss.cases)"], ["proof (state)\nthis:\n  (u, Spawn p, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c' = mon_c fg c", "with spawn_no_mon"], ["proof (chain)\npicking this:\n  (?u, Spawn ?p, ?v) \\<in> edges fg \\<Longrightarrow> mon fg ?p = {}\n  (u, Spawn p, v) \\<in> edges fg", "have \"mon_c fg {#[entry fg p]#} = {}\""], ["proof (prove)\nusing this:\n  (?u, Spawn ?p, ?v) \\<in> edges fg \\<Longrightarrow> mon fg ?p = {}\n  (u, Spawn p, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. mon_c fg {#[entry fg p]#} = {}", "by simp"], ["proof (state)\nthis:\n  mon_c fg {#[entry fg p]#} = {}\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c' = mon_c fg c", "with C'FMT"], ["proof (chain)\npicking this:\n  c' = {#[entry fg p]#} + c\n  mon_c fg {#[entry fg p]#} = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  c' = {#[entry fg p]#} + c\n  mon_c fg {#[entry fg p]#} = {}\n\ngoal (1 subgoal):\n 1. mon_c fg c' = mon_c fg c", "by (simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg c' = mon_c fg c\n\ngoal:\nNo subgoals!", "qed"], ["", "(* WARNING: Don't declare this [simp], as c=c' will cause a simplifier loop *)\n  (* FIXME: Dirty proof, not very robust *)"], ["", "corollary (in flowgraph) trss_c_no_mon: \n  \"((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<Longrightarrow> mon_c fg c' = mon_c fg c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (trss fg) \\<Longrightarrow>\n    mon_c fg c' = mon_c fg c", "apply (auto elim!: trss_c_cases simp add: mon_c_unconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "fix csp x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "assume \"x\\<in>mon_c fg csp\""], ["proof (state)\nthis:\n  x \\<in> mon_c fg csp\n\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "then"], ["proof (chain)\npicking this:\n  x \\<in> mon_c fg csp", "obtain s where \"s \\<in># csp\" and M: \"x\\<in>mon_s fg s\""], ["proof (prove)\nusing this:\n  x \\<in> mon_c fg csp\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in># csp; x \\<in> mon_s fg s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold mon_c_def, auto)"], ["proof (state)\nthis:\n  s \\<in># csp\n  x \\<in> mon_s fg s\n\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "moreover"], ["proof (state)\nthis:\n  s \\<in># csp\n  x \\<in> mon_s fg s\n\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "assume \"\\<forall>s. s \\<in># csp \\<longrightarrow> (\\<exists>p. s = [entry fg p] \\<and> (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and> initialproc fg p)\""], ["proof (state)\nthis:\n  \\<forall>s.\n     s \\<in># csp \\<longrightarrow>\n     (\\<exists>p.\n         s = [entry fg p] \\<and>\n         (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n         initialproc fg p)\n\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in># csp\n  x \\<in> mon_s fg s\n  \\<forall>s.\n     s \\<in># csp \\<longrightarrow>\n     (\\<exists>p.\n         s = [entry fg p] \\<and>\n         (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n         initialproc fg p)", "obtain p u v where \"s=[entry fg p]\" and \"(u,Spawn p,v)\\<in>edges fg\""], ["proof (prove)\nusing this:\n  s \\<in># csp\n  x \\<in> mon_s fg s\n  \\<forall>s.\n     s \\<in># csp \\<longrightarrow>\n     (\\<exists>p.\n         s = [entry fg p] \\<and>\n         (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n         initialproc fg p)\n\ngoal (1 subgoal):\n 1. (\\<And>p u v.\n        \\<lbrakk>s = [entry fg p]; (u, Spawn p, v) \\<in> edges fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s = [entry fg p]\n  (u, Spawn p, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "hence \"mon_s fg s = {}\""], ["proof (prove)\nusing this:\n  s = [entry fg p]\n  (u, Spawn p, v) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. mon_s fg s = {}", "by (simp)"], ["proof (state)\nthis:\n  mon_s fg s = {}\n\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "with M"], ["proof (chain)\npicking this:\n  x \\<in> mon_s fg s\n  mon_s fg s = {}", "have False"], ["proof (prove)\nusing this:\n  x \\<in> mon_s fg s\n  mon_s fg s = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>csp x.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in># csp \\<longrightarrow>\n                   (\\<exists>p.\n                       s = [entry fg p] \\<and>\n                       (\\<exists>u v. (u, Spawn p, v) \\<in> edges fg) \\<and>\n                       initialproc fg p);\n        c' = csp + c; x \\<in> mon_c fg csp\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_c fg c", "thus \"x\\<in>mon_c fg c\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x \\<in> mon_c fg c", ".."], ["proof (state)\nthis:\n  x \\<in> mon_c fg c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) trss_spawn_no_mon_step[simp]: \n  \"((s,c),LSpawn p, (s',c'))\\<in>trss fg \\<Longrightarrow> mon fg p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), LSpawn p, s', c') \\<in> trss fg \\<Longrightarrow> mon fg p = {}", "by (auto elim: trss.cases)"], ["", "lemma trss_no_empty_s[simp]: \"(([],c),e,(s',c'))\\<in>trss fg = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((([], c), e, s', c') \\<in> trss fg) = False", "by (auto elim!: trss.cases)"], ["", "lemma trss_no_empty[simp]: \n  assumes A: \"(([],c),w,(s',c'))\\<in>trcl (trss fg)\" \n  shows \"w=[] \\<and> s'=[] \\<and> c=c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "note A"], ["proof (state)\nthis:\n  (([], c), w, s', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "moreover"], ["proof (state)\nthis:\n  (([], c), w, s', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "{"], ["proof (state)\nthis:\n  (([], c), w, s', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "have \"((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<Longrightarrow> s=[] \\<Longrightarrow> w=[] \\<and> s'=[] \\<and> c=c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg); s = []\\<rbrakk>\n    \\<Longrightarrow> w = [] \\<and> s' = [] \\<and> c = c'", "by (induct rule: trcl_pair_induct) auto"], ["proof (state)\nthis:\n  \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg); s = []\\<rbrakk>\n  \\<Longrightarrow> w = [] \\<and> s' = [] \\<and> c = c'\n\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>((?s2, c), w, s', c') \\<in> trcl (trss fg); ?s2 = []\\<rbrakk>\n  \\<Longrightarrow> w = [] \\<and> s' = [] \\<and> c = c'\n\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "ultimately"], ["proof (chain)\npicking this:\n  (([], c), w, s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>((?s2, c), w, s', c') \\<in> trcl (trss fg); ?s2 = []\\<rbrakk>\n  \\<Longrightarrow> w = [] \\<and> s' = [] \\<and> c = c'", "show ?thesis"], ["proof (prove)\nusing this:\n  (([], c), w, s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>((?s2, c), w, s', c') \\<in> trcl (trss fg); ?s2 = []\\<rbrakk>\n  \\<Longrightarrow> w = [] \\<and> s' = [] \\<and> c = c'\n\ngoal (1 subgoal):\n 1. w = [] \\<and> s' = [] \\<and> c = c'", "by blast"], ["proof (state)\nthis:\n  w = [] \\<and> s' = [] \\<and> c = c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trs_step_cases[cases set, case_names NO_SPAWN SPAWN]: \n  assumes A: \"(c,e,c')\\<in>tr fg\" \n  assumes A_NO_SPAWN: \"!!s ce s' csp. \\<lbrakk>\n      ((s,ce),e,(s',ce))\\<in>trss fg; \n      c={#s#}+ce; c'={#s'#}+ce\n    \\<rbrakk> \\<Longrightarrow> P\"\n  assumes A_SPAWN: \"!!s ce s' p. \\<lbrakk>\n      ((s,ce),LSpawn p,(s',{#[entry fg p]#}+ce))\\<in>trss fg; \n      c={#s#}+ce; \n      c'={#s'#}+{#[entry fg p]#}+ce; \n      e=LSpawn p\n    \\<rbrakk> \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from A"], ["proof (chain)\npicking this:\n  (c, e, c') \\<in> tr fg", "show ?thesis"], ["proof (prove)\nusing this:\n  (c, e, c') \\<in> tr fg\n\ngoal (1 subgoal):\n 1. P", "proof (erule_tac gtr_find_thread)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ce s' ce'.\n       \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n        ((s, ce), e, s', ce') \\<in> trss fg\\<rbrakk>\n       \\<Longrightarrow> P", "fix s ce s' ce'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ce s' ce'.\n       \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n        ((s, ce), e, s', ce') \\<in> trss fg\\<rbrakk>\n       \\<Longrightarrow> P", "assume FMT: \"c = add_mset s ce\" \"c' = add_mset s' ce'\""], ["proof (state)\nthis:\n  c = add_mset s ce\n  c' = add_mset s' ce'\n\ngoal (1 subgoal):\n 1. \\<And>s ce s' ce'.\n       \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n        ((s, ce), e, s', ce') \\<in> trss fg\\<rbrakk>\n       \\<Longrightarrow> P", "assume B: \"((s, ce), e, s', ce') \\<in> trss fg\""], ["proof (state)\nthis:\n  ((s, ce), e, s', ce') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>s ce s' ce'.\n       \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n        ((s, ce), e, s', ce') \\<in> trss fg\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((s, ce), e, s', ce') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: trss_c_cases_s)"], ["proof (state)\ngoal (2 subgoals):\n 1. ce' = ce \\<Longrightarrow> P\n 2. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; ce' = {#[entry fg p]#} + ce\\<rbrakk>\n       \\<Longrightarrow> P", "case no_spawn"], ["proof (state)\nthis:\n  ce' = ce\n\ngoal (2 subgoals):\n 1. ce' = ce \\<Longrightarrow> P\n 2. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; ce' = {#[entry fg p]#} + ce\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  ce' = ce\n\ngoal (1 subgoal):\n 1. P", "using FMT B"], ["proof (prove)\nusing this:\n  ce' = ce\n  c = add_mset s ce\n  c' = add_mset s' ce'\n  ((s, ce), e, s', ce') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. P", "by (-) (rule A_NO_SPAWN, auto)"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; ce' = {#[entry fg p]#} + ce\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; ce' = {#[entry fg p]#} + ce\\<rbrakk>\n       \\<Longrightarrow> P", "case (spawn p)"], ["proof (state)\nthis:\n  e = LSpawn p\n  (u_, Spawn p, v_) \\<in> edges fg\n  hd s = u_\n  hd s' = v_\n  ce' = {#[entry fg p]#} + ce\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; ce' = {#[entry fg p]#} + ce\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = LSpawn p\n  (u_, Spawn p, v_) \\<in> edges fg\n  hd s = u_\n  hd s' = v_\n  ce' = {#[entry fg p]#} + ce\n\ngoal (1 subgoal):\n 1. P", "using FMT B"], ["proof (prove)\nusing this:\n  e = LSpawn p\n  (u_, Spawn p, v_) \\<in> edges fg\n  hd s = u_\n  hd s' = v_\n  ce' = {#[entry fg p]#} + ce\n  c = add_mset s ce\n  c' = add_mset s' ce'\n  ((s, ce), e, s', ce') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. P", "by (-) (rule A_SPAWN, auto simp add: union_assoc)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Advanced properties\""], ["", "subsubsection \"Stack composition / decomposition\""], ["", "lemma trss_stack_comp_s: \n  \"((s,c),e,(s',c'))\\<in>trss fg \\<Longrightarrow> ((s@r,c),e,(s'@r,c'))\\<in>trss fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> trss fg \\<Longrightarrow>\n    ((s @ r, c), e, s' @ r, c') \\<in> trss fg", "by (auto elim!: trss.cases intro: trss.intros)"], ["", "lemma trss_stack_comp: \n  \"((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<Longrightarrow> ((s@r,c),w,(s'@r,c'))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (trss fg) \\<Longrightarrow>\n    ((s @ r, c), w, s' @ r, c') \\<in> trcl (trss fg)", "proof (induct rule: trcl_pair_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. ((a @ r, b), [], a @ r, b) \\<in> trcl (trss fg)\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a b. ((a @ r, b), [], a @ r, b) \\<in> trcl (trss fg)\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a_ @ r, b_), [], a_ @ r, b_) \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  ((a_ @ r, b_), [], a_ @ r, b_) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "case (cons s c e sh ch w s' c')"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)\n  ((sh @ r, ch), w, s' @ r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "note IHP=this"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)\n  ((sh @ r, ch), w, s' @ r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "from trss_stack_comp_s[OF IHP(1)]"], ["proof (chain)\npicking this:\n  ((s @ ?r, c), e, sh @ ?r, ch) \\<in> trss fg", "have \"((s @ r, c), e, sh @ r, ch) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  ((s @ ?r, c), e, sh @ ?r, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ((s @ r, c), e, sh @ r, ch) \\<in> trss fg", "."], ["proof (state)\nthis:\n  ((s @ r, c), e, sh @ r, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  ((s @ r, c), e, sh @ r, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "note IHP(3)"], ["proof (state)\nthis:\n  ((sh @ r, ch), w, s' @ r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        ((ab @ r, ba), w, ac @ r, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a @ r, b), aa # w, ac @ r, bb)\n                         \\<in> trcl (trss fg)", "finally"], ["proof (chain)\npicking this:\n  ((s @ r, c), e # w, s' @ r, c') \\<in> trcl (trss fg)", "show ?case"], ["proof (prove)\nusing this:\n  ((s @ r, c), e # w, s' @ r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((s @ r, c), e # w, s' @ r, c') \\<in> trcl (trss fg)", "."], ["proof (state)\nthis:\n  ((s @ r, c), e # w, s' @ r, c') \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trss_stack_decomp_s: \"\\<lbrakk> ((s@r,c),e,(s',c'))\\<in>trss fg; s\\<noteq>[] \\<rbrakk> \n  \\<Longrightarrow> \\<exists>sp'. s'=sp'@r \\<and> ((s,c),e,(sp',c'))\\<in>trss fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s @ r, c), e, s', c') \\<in> trss fg; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sp'.\n                         s' = sp' @ r \\<and>\n                         ((s, c), e, sp', c') \\<in> trss fg", "by (cases s, simp) (auto intro: trss.intros elim!: trss.cases)"], ["", "lemma trss_find_return: \"\\<lbrakk> \n    ((s@r,c),w,(r,c'))\\<in>trcl (trss fg); \n    !!wa wb ch. \\<lbrakk> w=wa@wb; ((s,c),wa,([],ch))\\<in>trcl (trss fg); \n                  ((r,ch),wb,(r,c'))\\<in>trcl (trss fg) \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"\n  \\<comment> \\<open>If @{term \"s=[]\"}, the proposition follows trivially\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n     \\<And>wa wb ch.\n        \\<lbrakk>w = wa @ wb; ((s, c), wa, [], ch) \\<in> trcl (trss fg);\n         ((r, ch), wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (cases \"s=[]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n     \\<And>wa wb ch.\n        \\<lbrakk>w = wa @ wb; ((s, c), wa, [], ch) \\<in> trcl (trss fg);\n         ((r, ch), wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> P;\n     s = []\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n     \\<And>wa wb ch.\n        \\<lbrakk>w = wa @ wb; ((s, c), wa, [], ch) \\<in> trcl (trss fg);\n         ((r, ch), wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> P;\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> P", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n     \\<And>wa wb ch.\n        \\<lbrakk>w = wa @ wb; ((s, c), wa, [], ch) \\<in> trcl (trss fg);\n         ((r, ch), wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> P;\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> P", "proof -\n  \\<comment> \\<open>For @{term \"s\\<noteq>[]\"}, we use induction by @{term w}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n     \\<And>wa wb ch.\n        \\<lbrakk>w = wa @ wb; ((s, c), wa, [], ch) \\<in> trcl (trss fg);\n         ((r, ch), wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> P;\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> P", "have IM: \"!!s c. \\<lbrakk> ((s@r,c),w,(r,c'))\\<in>trcl (trss fg); s\\<noteq>[] \\<rbrakk> \\<Longrightarrow> \\<exists>wa wb ch. w=wa@wb \\<and> ((s,c),wa,([],ch))\\<in>trcl (trss fg) \\<and> ((r,ch),wb,(r,c'))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c.\n       \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "proof (induct w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s c.\n       \\<lbrakk>((s @ r, c), [], r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            [] = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "case Nil"], ["proof (state)\nthis:\n  ((s @ r, c), [], r, c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>s c.\n       \\<lbrakk>((s @ r, c), [], r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            [] = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "thus ?case"], ["proof (prove)\nusing this:\n  ((s @ r, c), [], r, c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>wa wb ch.\n       [] = wa @ wb \\<and>\n       ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n       ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>wa wb ch.\n     [] = wa @ wb \\<and>\n     ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "case (Cons e w)"], ["proof (state)\nthis:\n  \\<lbrakk>((?s @ r, ?c), w, r, c') \\<in> trcl (trss fg);\n   ?s \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>waa wb ch.\n                       w = waa @ wb \\<and>\n                       ((?s, ?c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n                       ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n  ((s @ r, c), e # w, r, c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "note IHP=this"], ["proof (state)\nthis:\n  \\<lbrakk>((?s @ r, ?c), w, r, c') \\<in> trcl (trss fg);\n   ?s \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>waa wb ch.\n                       w = waa @ wb \\<and>\n                       ((?s, ?c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n                       ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n  ((s @ r, c), e # w, r, c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?s @ r, ?c), w, r, c') \\<in> trcl (trss fg);\n   ?s \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>waa wb ch.\n                       w = waa @ wb \\<and>\n                       ((?s, ?c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n                       ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n  ((s @ r, c), e # w, r, c') \\<in> trcl (trss fg)\n  s \\<noteq> []", "obtain sh ch where SPLIT1: \"((s@r,c),e,(sh,ch))\\<in>trss fg\" and SPLIT2: \"((sh,ch),w,(r,c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((?s @ r, ?c), w, r, c') \\<in> trcl (trss fg);\n   ?s \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>waa wb ch.\n                       w = waa @ wb \\<and>\n                       ((?s, ?c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n                       ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n  ((s @ r, c), e # w, r, c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>((s @ r, c), e, sh, ch) \\<in> trss fg;\n         ((sh, ch), w, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  ((s @ r, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "{"], ["proof (state)\nthis:\n  ((s @ r, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "assume CASE: \"e=LRet\""], ["proof (state)\nthis:\n  e = LRet\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "with SPLIT1"], ["proof (chain)\npicking this:\n  ((s @ r, c), e, sh, ch) \\<in> trss fg\n  e = LRet", "obtain p where EDGE: \"s@r=return fg p # sh\" \"c=ch\""], ["proof (prove)\nusing this:\n  ((s @ r, c), e, sh, ch) \\<in> trss fg\n  e = LRet\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>s @ r = return fg p # sh; c = ch\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: trss.cases)"], ["proof (state)\nthis:\n  s @ r = return fg p # sh\n  c = ch\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "with IHP(3)"], ["proof (chain)\npicking this:\n  s \\<noteq> []\n  s @ r = return fg p # sh\n  c = ch", "obtain ss where SHFMT: \"s=return fg p # ss\" \"sh=ss@r\""], ["proof (prove)\nusing this:\n  s \\<noteq> []\n  s @ r = return fg p # sh\n  c = ch\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>s = return fg p # ss; sh = ss @ r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s, auto)"], ["proof (state)\nthis:\n  s = return fg p # ss\n  sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "{"], ["proof (state)\nthis:\n  s = return fg p # ss\n  sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "assume CC: \"ss\\<noteq>[]\""], ["proof (state)\nthis:\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "with SHFMT"], ["proof (chain)\npicking this:\n  s = return fg p # ss\n  sh = ss @ r\n  ss \\<noteq> []", "have \"\\<exists>ss. ss\\<noteq>[] \\<and> sh=ss@r\""], ["proof (prove)\nusing this:\n  s = return fg p # ss\n  sh = ss @ r\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r", "by blast"], ["proof (state)\nthis:\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "}"], ["proof (state)\nthis:\n  ss \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  ss \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "{"], ["proof (state)\nthis:\n  ss \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "assume CC: \"ss=[]\""], ["proof (state)\nthis:\n  ss = []\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "with CASE SHFMT EDGE"], ["proof (chain)\npicking this:\n  e = LRet\n  s = return fg p # ss\n  sh = ss @ r\n  s @ r = return fg p # sh\n  c = ch\n  ss = []", "have \"((s,c),[e],([],ch))\\<in>trcl (trss fg)\" \"e#w=[e]@w\""], ["proof (prove)\nusing this:\n  e = LRet\n  s = return fg p # ss\n  sh = ss @ r\n  s @ r = return fg p # sh\n  c = ch\n  ss = []\n\ngoal (1 subgoal):\n 1. ((s, c), [e], [], ch) \\<in> trcl (trss fg) &&& e # w = [e] @ w", "by (auto intro: trss_ret)"], ["proof (state)\nthis:\n  ((s, c), [e], [], ch) \\<in> trcl (trss fg)\n  e # w = [e] @ w\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  ((s, c), [e], [], ch) \\<in> trcl (trss fg)\n  e # w = [e] @ w\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "from SPLIT2 SHFMT CC"], ["proof (chain)\npicking this:\n  ((sh, ch), w, r, c') \\<in> trcl (trss fg)\n  s = return fg p # ss\n  sh = ss @ r\n  ss = []", "have \"((r,ch),w,(r,c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((sh, ch), w, r, c') \\<in> trcl (trss fg)\n  s = return fg p # ss\n  sh = ss @ r\n  ss = []\n\ngoal (1 subgoal):\n 1. ((r, ch), w, r, c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  ((r, ch), w, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "ultimately"], ["proof (chain)\npicking this:\n  ((s, c), [e], [], ch) \\<in> trcl (trss fg)\n  e # w = [e] @ w\n  ((r, ch), w, r, c') \\<in> trcl (trss fg)", "have ?case"], ["proof (prove)\nusing this:\n  ((s, c), [e], [], ch) \\<in> trcl (trss fg)\n  e # w = [e] @ w\n  ((r, ch), w, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<exists>waa wb ch.\n       e # w = waa @ wb \\<and>\n       ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n       ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "}"], ["proof (state)\nthis:\n  ss = [] \\<Longrightarrow>\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "ultimately"], ["proof (chain)\npicking this:\n  ss \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n  ss = [] \\<Longrightarrow>\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "have \"?case \\<or> (\\<exists>ss. ss\\<noteq>[] \\<and> sh=ss@r)\""], ["proof (prove)\nusing this:\n  ss \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n  ss = [] \\<Longrightarrow>\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<exists>waa wb ch.\n        e # w = waa @ wb \\<and>\n        ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n        ((r, ch), wb, r, c') \\<in> trcl (trss fg)) \\<or>\n    (\\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>waa wb ch.\n      e # w = waa @ wb \\<and>\n      ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n      ((r, ch), wb, r, c') \\<in> trcl (trss fg)) \\<or>\n  (\\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "}"], ["proof (state)\nthis:\n  e = LRet \\<Longrightarrow>\n  (\\<exists>waa wb ch.\n      e # w = waa @ wb \\<and>\n      ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n      ((r, ch), wb, r, c') \\<in> trcl (trss fg)) \\<or>\n  (\\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  e = LRet \\<Longrightarrow>\n  (\\<exists>waa wb ch.\n      e # w = waa @ wb \\<and>\n      ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n      ((r, ch), wb, r, c') \\<in> trcl (trss fg)) \\<or>\n  (\\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "{"], ["proof (state)\nthis:\n  e = LRet \\<Longrightarrow>\n  (\\<exists>waa wb ch.\n      e # w = waa @ wb \\<and>\n      ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n      ((r, ch), wb, r, c') \\<in> trcl (trss fg)) \\<or>\n  (\\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "assume \"e\\<noteq>LRet\""], ["proof (state)\nthis:\n  e \\<noteq> LRet\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "with SPLIT1 IHP(3)"], ["proof (chain)\npicking this:\n  ((s @ r, c), e, sh, ch) \\<in> trss fg\n  s \\<noteq> []\n  e \\<noteq> LRet", "have \"(\\<exists>ss. ss\\<noteq>[] \\<and> sh=ss@r)\""], ["proof (prove)\nusing this:\n  ((s @ r, c), e, sh, ch) \\<in> trss fg\n  s \\<noteq> []\n  e \\<noteq> LRet\n\ngoal (1 subgoal):\n 1. \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r", "by (force elim!: trss.cases simp add: append_eq_Cons_conv)"], ["proof (state)\nthis:\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "}"], ["proof (state)\nthis:\n  e \\<noteq> LRet \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  e \\<noteq> LRet \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "{"], ["proof (state)\nthis:\n  e \\<noteq> LRet \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "assume \"(\\<exists>ss. ss\\<noteq>[] \\<and> sh=ss@r)\""], ["proof (state)\nthis:\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r", "obtain ss where CASE: \"ss\\<noteq>[]\" \"sh=ss@r\""], ["proof (prove)\nusing this:\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>ss \\<noteq> []; sh = ss @ r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ss \\<noteq> []\n  sh = ss @ r\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "with SPLIT2"], ["proof (chain)\npicking this:\n  ((sh, ch), w, r, c') \\<in> trcl (trss fg)\n  ss \\<noteq> []\n  sh = ss @ r", "have \"((ss@r, ch), w, r, c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((sh, ch), w, r, c') \\<in> trcl (trss fg)\n  ss \\<noteq> []\n  sh = ss @ r\n\ngoal (1 subgoal):\n 1. ((ss @ r, ch), w, r, c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  ((ss @ r, ch), w, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "from IHP(1)[OF this CASE(1)]"], ["proof (chain)\npicking this:\n  \\<exists>waa wb cha.\n     w = waa @ wb \\<and>\n     ((ss, ch), waa, [], cha) \\<in> trcl (trss fg) \\<and>\n     ((r, cha), wb, r, c') \\<in> trcl (trss fg)", "obtain wa wb ch' where IHAPP: \"w=wa@wb\" \"((ss,ch),wa,([],ch'))\\<in>trcl (trss fg)\" \"((r,ch'),wb,(r,c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<exists>waa wb cha.\n     w = waa @ wb \\<and>\n     ((ss, ch), waa, [], cha) \\<in> trcl (trss fg) \\<and>\n     ((r, cha), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>waa wb ch'.\n        \\<lbrakk>w = waa @ wb;\n         ((ss, ch), waa, [], ch') \\<in> trcl (trss fg);\n         ((r, ch'), wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w = wa @ wb\n  ((ss, ch), wa, [], ch') \\<in> trcl (trss fg)\n  ((r, ch'), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  w = wa @ wb\n  ((ss, ch), wa, [], ch') \\<in> trcl (trss fg)\n  ((r, ch'), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "from CASE SPLIT1"], ["proof (chain)\npicking this:\n  ss \\<noteq> []\n  sh = ss @ r\n  ((s @ r, c), e, sh, ch) \\<in> trss fg", "have \"((s @ r, c), e, ss@r, ch) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n  sh = ss @ r\n  ((s @ r, c), e, sh, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ((s @ r, c), e, ss @ r, ch) \\<in> trss fg", "by simp"], ["proof (state)\nthis:\n  ((s @ r, c), e, ss @ r, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "from trss_stack_decomp_s[OF this IHP(3)]"], ["proof (chain)\npicking this:\n  \\<exists>sp'. ss @ r = sp' @ r \\<and> ((s, c), e, sp', ch) \\<in> trss fg", "have \"((s, c), e, ss, ch) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  \\<exists>sp'. ss @ r = sp' @ r \\<and> ((s, c), e, sp', ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ((s, c), e, ss, ch) \\<in> trss fg", "by auto"], ["proof (state)\nthis:\n  ((s, c), e, ss, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "with IHAPP"], ["proof (chain)\npicking this:\n  w = wa @ wb\n  ((ss, ch), wa, [], ch') \\<in> trcl (trss fg)\n  ((r, ch'), wb, r, c') \\<in> trcl (trss fg)\n  ((s, c), e, ss, ch) \\<in> trss fg", "have \"((s, c), e#wa, ([],ch')) \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  w = wa @ wb\n  ((ss, ch), wa, [], ch') \\<in> trcl (trss fg)\n  ((r, ch'), wb, r, c') \\<in> trcl (trss fg)\n  ((s, c), e, ss, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ((s, c), e # wa, [], ch') \\<in> trcl (trss fg)", "by (rule_tac trcl.cons)"], ["proof (state)\nthis:\n  ((s, c), e # wa, [], ch') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  ((s, c), e # wa, [], ch') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "from IHAPP"], ["proof (chain)\npicking this:\n  w = wa @ wb\n  ((ss, ch), wa, [], ch') \\<in> trcl (trss fg)\n  ((r, ch'), wb, r, c') \\<in> trcl (trss fg)", "have \"e#w=(e#wa)@wb\""], ["proof (prove)\nusing this:\n  w = wa @ wb\n  ((ss, ch), wa, [], ch') \\<in> trcl (trss fg)\n  ((r, ch'), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. e # w = (e # wa) @ wb", "by auto"], ["proof (state)\nthis:\n  e # w = (e # wa) @ wb\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "ultimately"], ["proof (chain)\npicking this:\n  w = wa @ wb\n  ((ss, ch), wa, [], ch') \\<in> trcl (trss fg)\n  ((r, ch'), wb, r, c') \\<in> trcl (trss fg)\n  ((s, c), e # wa, [], ch') \\<in> trcl (trss fg)\n  e # w = (e # wa) @ wb", "have ?case"], ["proof (prove)\nusing this:\n  w = wa @ wb\n  ((ss, ch), wa, [], ch') \\<in> trcl (trss fg)\n  ((r, ch'), wb, r, c') \\<in> trcl (trss fg)\n  ((s, c), e # wa, [], ch') \\<in> trcl (trss fg)\n  e # w = (e # wa) @ wb\n\ngoal (1 subgoal):\n 1. \\<exists>waa wb ch.\n       e # w = waa @ wb \\<and>\n       ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n       ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "}"], ["proof (state)\nthis:\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r \\<Longrightarrow>\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n                    s \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>wa wb ch.\n  w = wa @ wb \\<and>\n  ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n  ((r, ch), wb, r, c') \\<in> trcl (trss fg);\n        ((s @ r, c), a # w, r, c') \\<in> trcl (trss fg);\n        s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa wb ch.\n                            a # w = wa @ wb \\<and>\n                            ((s, c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                            ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "ultimately"], ["proof (chain)\npicking this:\n  e = LRet \\<Longrightarrow>\n  (\\<exists>waa wb ch.\n      e # w = waa @ wb \\<and>\n      ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n      ((r, ch), wb, r, c') \\<in> trcl (trss fg)) \\<or>\n  (\\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r)\n  e \\<noteq> LRet \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r \\<Longrightarrow>\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "show ?case"], ["proof (prove)\nusing this:\n  e = LRet \\<Longrightarrow>\n  (\\<exists>waa wb ch.\n      e # w = waa @ wb \\<and>\n      ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n      ((r, ch), wb, r, c') \\<in> trcl (trss fg)) \\<or>\n  (\\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r)\n  e \\<noteq> LRet \\<Longrightarrow>\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r\n  \\<exists>ss. ss \\<noteq> [] \\<and> sh = ss @ r \\<Longrightarrow>\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<exists>waa wb ch.\n       e # w = waa @ wb \\<and>\n       ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n       ((r, ch), wb, r, c') \\<in> trcl (trss fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>waa wb ch.\n     e # w = waa @ wb \\<and>\n     ((s, c), waa, [], ch) \\<in> trcl (trss fg) \\<and>\n     ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>((?s @ r, ?c), w, r, c') \\<in> trcl (trss fg);\n   ?s \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>wa wb ch.\n                       w = wa @ wb \\<and>\n                       ((?s, ?c), wa, [], ch) \\<in> trcl (trss fg) \\<and>\n                       ((r, ch), wb, r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n     \\<And>wa wb ch.\n        \\<lbrakk>w = wa @ wb; ((s, c), wa, [], ch) \\<in> trcl (trss fg);\n         ((r, ch), wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> P;\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> P", "assume \"((s @ r, c), w, r, c') \\<in> trcl (trss fg)\" \"s \\<noteq> []\" \"!!wa wb ch. \\<lbrakk> w=wa@wb; ((s,c),wa,([],ch))\\<in>trcl (trss fg); ((r,ch),wb,(r,c'))\\<in>trcl (trss fg) \\<rbrakk> \\<Longrightarrow> P\""], ["proof (state)\nthis:\n  ((s @ r, c), w, r, c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n  \\<lbrakk>w = ?wa @ ?wb; ((s, c), ?wa, [], ?ch) \\<in> trcl (trss fg);\n   ((r, ?ch), ?wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s @ r, c), w, r, c') \\<in> trcl (trss fg);\n     \\<And>wa wb ch.\n        \\<lbrakk>w = wa @ wb; ((s, c), wa, [], ch) \\<in> trcl (trss fg);\n         ((r, ch), wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> P;\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> P", "thus P"], ["proof (prove)\nusing this:\n  ((s @ r, c), w, r, c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n  \\<lbrakk>w = ?wa @ ?wb; ((s, c), ?wa, [], ?ch) \\<in> trcl (trss fg);\n   ((r, ?ch), ?wb, r, c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (blast dest: IM)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Try backward induction proof \\<dots> is this simpler ? *)"], ["", "lemma trss_return_cases[cases set]: \"!!u r c. \\<lbrakk> \n    ((u#r,c),w,(r',c'))\\<in>trcl (trss fg);\n    !! s' u'. \\<lbrakk> r'=s'@u'#r; (([u],c),w,(s'@[u'],c'))\\<in>trcl (trss fg) \\<rbrakk> \\<Longrightarrow> P; \n    !! wa wb ch. \\<lbrakk> w=wa@wb; (([u],c),wa,([],ch))\\<in>trcl (trss fg); \n                   ((r,ch),wb,(r',c'))\\<in>trcl (trss fg) \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u r c.\n       \\<lbrakk>((u # r, c), w, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), w, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>w = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "proof (induct w rule: length_compl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u r c.\n       \\<lbrakk>((u # r, c), [], r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), [], s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>[] = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case Nil"], ["proof (state)\nthis:\n  ((u # r, c), [], r', c') \\<in> trcl (trss fg)\n  \\<lbrakk>r' = ?s' @ ?u' # r;\n   (([u], c), [], ?s' @ [?u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>[] = ?wa @ ?wb; (([u], c), ?wa, [], ?ch) \\<in> trcl (trss fg);\n   ((r, ?ch), ?wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<And>u r c.\n       \\<lbrakk>((u # r, c), [], r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), [], s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>[] = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?case"], ["proof (prove)\nusing this:\n  ((u # r, c), [], r', c') \\<in> trcl (trss fg)\n  \\<lbrakk>r' = ?s' @ ?u' # r;\n   (([u], c), [], ?s' @ [?u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>[] = ?wa @ ?wb; (([u], c), ?wa, [], ?ch) \\<in> trcl (trss fg);\n   ((r, ?ch), ?wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (Cons e w)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length w;\n   ((?u # ?r, ?c), ?ll, r', c') \\<in> trcl (trss fg);\n   \\<And>s' u'.\n      \\<lbrakk>r' = s' @ u' # ?r;\n       (([?u], ?c), ?ll, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> P;\n   \\<And>wa wb ch.\n      \\<lbrakk>?ll = wa @ wb; (([?u], ?c), wa, [], ch) \\<in> trcl (trss fg);\n       ((?r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  ((u # r, c), e # w, r', c') \\<in> trcl (trss fg)\n  \\<lbrakk>r' = ?s' @ ?u' # r;\n   (([u], c), e # w, ?s' @ [?u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>e # w = ?wa @ ?wb; (([u], c), ?wa, [], ?ch) \\<in> trcl (trss fg);\n   ((r, ?ch), ?wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "note IHP=this"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length w;\n   ((?u # ?r, ?c), ?ll, r', c') \\<in> trcl (trss fg);\n   \\<And>s' u'.\n      \\<lbrakk>r' = s' @ u' # ?r;\n       (([?u], ?c), ?ll, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> P;\n   \\<And>wa wb ch.\n      \\<lbrakk>?ll = wa @ wb; (([?u], ?c), wa, [], ch) \\<in> trcl (trss fg);\n       ((?r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  ((u # r, c), e # w, r', c') \\<in> trcl (trss fg)\n  \\<lbrakk>r' = ?s' @ ?u' # r;\n   (([u], c), e # w, ?s' @ [?u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>e # w = ?wa @ ?wb; (([u], c), ?wa, [], ?ch) \\<in> trcl (trss fg);\n   ((r, ?ch), ?wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length w;\n   ((?u # ?r, ?c), ?ll, r', c') \\<in> trcl (trss fg);\n   \\<And>s' u'.\n      \\<lbrakk>r' = s' @ u' # ?r;\n       (([?u], ?c), ?ll, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> P;\n   \\<And>wa wb ch.\n      \\<lbrakk>?ll = wa @ wb; (([?u], ?c), wa, [], ch) \\<in> trcl (trss fg);\n       ((?r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  ((u # r, c), e # w, r', c') \\<in> trcl (trss fg)\n  \\<lbrakk>r' = ?s' @ ?u' # r;\n   (([u], c), e # w, ?s' @ [?u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>e # w = ?wa @ ?wb; (([u], c), ?wa, [], ?ch) \\<in> trcl (trss fg);\n   ((r, ?ch), ?wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P", "obtain sh ch where SPLIT1: \"((u#r,c),e,(sh,ch))\\<in>trss fg\" and SPLIT2: \"((sh,ch),w,(r',c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length w;\n   ((?u # ?r, ?c), ?ll, r', c') \\<in> trcl (trss fg);\n   \\<And>s' u'.\n      \\<lbrakk>r' = s' @ u' # ?r;\n       (([?u], ?c), ?ll, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> P;\n   \\<And>wa wb ch.\n      \\<lbrakk>?ll = wa @ wb; (([?u], ?c), wa, [], ch) \\<in> trcl (trss fg);\n       ((?r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\n  ((u # r, c), e # w, r', c') \\<in> trcl (trss fg)\n  \\<lbrakk>r' = ?s' @ ?u' # r;\n   (([u], c), e # w, ?s' @ [?u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>e # w = ?wa @ ?wb; (([u], c), ?wa, [], ?ch) \\<in> trcl (trss fg);\n   ((r, ?ch), ?wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>((u # r, c), e, sh, ch) \\<in> trss fg;\n         ((sh, ch), w, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  ((u # r, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "{"], ["proof (state)\nthis:\n  ((u # r, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "fix ba q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "assume CASE: \"e=LBase ba \\<or> e=LSpawn q\""], ["proof (state)\nthis:\n  e = LBase ba \\<or> e = LSpawn q\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "with SPLIT1"], ["proof (chain)\npicking this:\n  ((u # r, c), e, sh, ch) \\<in> trss fg\n  e = LBase ba \\<or> e = LSpawn q", "obtain v where E: \"sh=v#r\" \"(([u],c),e,([v],ch))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  ((u # r, c), e, sh, ch) \\<in> trss fg\n  e = LBase ba \\<or> e = LSpawn q\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>sh = v # r; (([u], c), e, [v], ch) \\<in> trss fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: trss.cases intro: trss.intros)"], ["proof (state)\nthis:\n  sh = v # r\n  (([u], c), e, [v], ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "with SPLIT2"], ["proof (chain)\npicking this:\n  ((sh, ch), w, r', c') \\<in> trcl (trss fg)\n  sh = v # r\n  (([u], c), e, [v], ch) \\<in> trss fg", "have \"((v#r,ch),w,(r',c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((sh, ch), w, r', c') \\<in> trcl (trss fg)\n  sh = v # r\n  (([u], c), e, [v], ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ((v # r, ch), w, r', c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  ((v # r, ch), w, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "hence ?case"], ["proof (prove)\nusing this:\n  ((v # r, ch), w, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: IHP(1)[of w, simplified, cases set])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' u'.\n       \\<lbrakk>r' = s' @ u' # r;\n        (([v], ch), w, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case (1 s' u')"], ["proof (state)\nthis:\n  r' = s' @ u' # r\n  (([v], ch), w, s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'.\n       \\<lbrakk>r' = s' @ u' # r;\n        (([v], ch), w, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "note CC=this"], ["proof (state)\nthis:\n  r' = s' @ u' # r\n  (([v], ch), w, s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'.\n       \\<lbrakk>r' = s' @ u' # r;\n        (([v], ch), w, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "with E(2)"], ["proof (chain)\npicking this:\n  (([u], c), e, [v], ch) \\<in> trss fg\n  r' = s' @ u' # r\n  (([v], ch), w, s' @ [u'], c') \\<in> trcl (trss fg)", "have \"(([u],c),e#w,(s'@[u'],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([u], c), e, [v], ch) \\<in> trss fg\n  r' = s' @ u' # r\n  (([v], ch), w, s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([u], c), e # w, s' @ [u'], c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([u], c), e # w, s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'.\n       \\<lbrakk>r' = s' @ u' # r;\n        (([v], ch), w, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from IHP(3)[OF CC(1) this]"], ["proof (chain)\npicking this:\n  P", "show ?thesis"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case (2 wa wb ct)"], ["proof (state)\nthis:\n  w = wa @ wb\n  (([v], ch), wa, [], ct) \\<in> trcl (trss fg)\n  ((r, ct), wb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "note CC=this"], ["proof (state)\nthis:\n  w = wa @ wb\n  (([v], ch), wa, [], ct) \\<in> trcl (trss fg)\n  ((r, ct), wb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "with E(2)"], ["proof (chain)\npicking this:\n  (([u], c), e, [v], ch) \\<in> trss fg\n  w = wa @ wb\n  (([v], ch), wa, [], ct) \\<in> trcl (trss fg)\n  ((r, ct), wb, r', c') \\<in> trcl (trss fg)", "have \"(([u],c),e#wa,([],ct))\\<in>trcl (trss fg)\" \"e#w = (e#wa)@wb\""], ["proof (prove)\nusing this:\n  (([u], c), e, [v], ch) \\<in> trss fg\n  w = wa @ wb\n  (([v], ch), wa, [], ct) \\<in> trcl (trss fg)\n  ((r, ct), wb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([u], c), e # wa, [], ct) \\<in> trcl (trss fg) &&&\n    e # w = (e # wa) @ wb", "by simp_all"], ["proof (state)\nthis:\n  (([u], c), e # wa, [], ct) \\<in> trcl (trss fg)\n  e # w = (e # wa) @ wb\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([v], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from IHP(4)[OF this(2,1) CC(3)]"], ["proof (chain)\npicking this:\n  P", "show ?thesis"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "}"], ["proof (state)\nthis:\n  e = LBase ?ba2 \\<or> e = LSpawn ?q2 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  e = LBase ?ba2 \\<or> e = LSpawn ?q2 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "{"], ["proof (state)\nthis:\n  e = LBase ?ba2 \\<or> e = LSpawn ?q2 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "assume CASE: \"e=LRet\""], ["proof (state)\nthis:\n  e = LRet\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "with SPLIT1"], ["proof (chain)\npicking this:\n  ((u # r, c), e, sh, ch) \\<in> trss fg\n  e = LRet", "have \"sh=r\" \"(([u],c),[e],([],ch))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((u # r, c), e, sh, ch) \\<in> trss fg\n  e = LRet\n\ngoal (1 subgoal):\n 1. sh = r &&& (([u], c), [e], [], ch) \\<in> trcl (trss fg)", "by (auto elim!: trss.cases intro: trss.intros)"], ["proof (state)\nthis:\n  sh = r\n  (([u], c), [e], [], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "with IHP(4)[OF _ this(2)] SPLIT2"], ["proof (chain)\npicking this:\n  \\<lbrakk>e # w = [e] @ ?wb;\n   ((r, ch), ?wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  ((sh, ch), w, r', c') \\<in> trcl (trss fg)\n  sh = r\n  (([u], c), [e], [], ch) \\<in> trcl (trss fg)", "have ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>e # w = [e] @ ?wb;\n   ((r, ch), ?wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  ((sh, ch), w, r', c') \\<in> trcl (trss fg)\n  sh = r\n  (([u], c), [e], [], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "}"], ["proof (state)\nthis:\n  e = LRet \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  e = LRet \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "{"], ["proof (state)\nthis:\n  e = LRet \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "assume CASE: \"e=LCall q\""], ["proof (state)\nthis:\n  e = LCall q\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "with SPLIT1"], ["proof (chain)\npicking this:\n  ((u # r, c), e, sh, ch) \\<in> trss fg\n  e = LCall q", "obtain u' where SHFMT: \"sh=entry fg q # u' # r\" \"(([u],c),e,(entry fg q # [u'],ch))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  ((u # r, c), e, sh, ch) \\<in> trss fg\n  e = LCall q\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>sh = entry fg q # u' # r;\n         (([u], c), e, [entry fg q, u'], ch) \\<in> trss fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: trss.cases intro: trss.intros)"], ["proof (state)\nthis:\n  sh = entry fg q # u' # r\n  (([u], c), e, [entry fg q, u'], ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "with SPLIT2"], ["proof (chain)\npicking this:\n  ((sh, ch), w, r', c') \\<in> trcl (trss fg)\n  sh = entry fg q # u' # r\n  (([u], c), e, [entry fg q, u'], ch) \\<in> trss fg", "have \"((entry fg q # u' # r,ch),w,(r',c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((sh, ch), w, r', c') \\<in> trcl (trss fg)\n  sh = entry fg q # u' # r\n  (([u], c), e, [entry fg q, u'], ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ((entry fg q # u' # r, ch), w, r', c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  ((entry fg q # u' # r, ch), w, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "hence ?case"], ["proof (prove)\nusing this:\n  ((entry fg q # u' # r, ch), w, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: IHP(1)[of w, simplified, cases set])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # u' # r;\n        (([entry fg q], ch), w, s' @ [u'a], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case (1 st ut)"], ["proof (state)\nthis:\n  r' = st @ ut # u' # r\n  (([entry fg q], ch), w, st @ [ut], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # u' # r;\n        (([entry fg q], ch), w, s' @ [u'a], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "note CC=this"], ["proof (state)\nthis:\n  r' = st @ ut # u' # r\n  (([entry fg q], ch), w, st @ [ut], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # u' # r;\n        (([entry fg q], ch), w, s' @ [u'a], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from trss_stack_comp[OF CC(2), where r=\"[u']\"]"], ["proof (chain)\npicking this:\n  (([entry fg q] @ [u'], ch), w, (st @ [ut]) @ [u'], c')\n  \\<in> trcl (trss fg)", "have \"((entry fg q#[u'], ch), w, (st @ [ut]) @ [u'], c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg q] @ [u'], ch), w, (st @ [ut]) @ [u'], c')\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg q, u'], ch), w, (st @ [ut]) @ [u'], c') \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  (([entry fg q, u'], ch), w, (st @ [ut]) @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # u' # r;\n        (([entry fg q], ch), w, s' @ [u'a], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "with SHFMT(2)"], ["proof (chain)\npicking this:\n  (([u], c), e, [entry fg q, u'], ch) \\<in> trss fg\n  (([entry fg q, u'], ch), w, (st @ [ut]) @ [u'], c') \\<in> trcl (trss fg)", "have \"(([u],c),e#w, (st @ [ut]) @ [u'], c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([u], c), e, [entry fg q, u'], ch) \\<in> trss fg\n  (([entry fg q, u'], ch), w, (st @ [ut]) @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([u], c), e # w, (st @ [ut]) @ [u'], c') \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  (([u], c), e # w, (st @ [ut]) @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # u' # r;\n        (([entry fg q], ch), w, s' @ [u'a], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from IHP(3)[OF _ this] CC(1)"], ["proof (chain)\npicking this:\n  r' = (st @ [ut]) @ u' # r \\<Longrightarrow> P\n  r' = st @ ut # u' # r", "show ?thesis"], ["proof (prove)\nusing this:\n  r' = (st @ [ut]) @ u' # r \\<Longrightarrow> P\n  r' = st @ ut # u' # r\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case (2 wa wb ct)"], ["proof (state)\nthis:\n  w = wa @ wb\n  (([entry fg q], ch), wa, [], ct) \\<in> trcl (trss fg)\n  ((u' # r, ct), wb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "note CC=this"], ["proof (state)\nthis:\n  w = wa @ wb\n  (([entry fg q], ch), wa, [], ct) \\<in> trcl (trss fg)\n  ((u' # r, ct), wb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from trss_stack_comp[OF CC(2), where r=\"[u']\"]"], ["proof (chain)\npicking this:\n  (([entry fg q] @ [u'], ch), wa, [] @ [u'], ct) \\<in> trcl (trss fg)", "have \"((entry fg q # [u'], ch), wa, [u'], ct) \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg q] @ [u'], ch), wa, [] @ [u'], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg q, u'], ch), wa, [u'], ct) \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([entry fg q, u'], ch), wa, [u'], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "with SHFMT"], ["proof (chain)\npicking this:\n  sh = entry fg q # u' # r\n  (([u], c), e, [entry fg q, u'], ch) \\<in> trss fg\n  (([entry fg q, u'], ch), wa, [u'], ct) \\<in> trcl (trss fg)", "have PREPATH: \"(([u],c),e#wa, [u'], ct) \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  sh = entry fg q # u' # r\n  (([u], c), e, [entry fg q, u'], ch) \\<in> trss fg\n  (([entry fg q, u'], ch), wa, [u'], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([u], c), e # wa, [u'], ct) \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([u], c), e # wa, [u'], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from CC"], ["proof (chain)\npicking this:\n  w = wa @ wb\n  (([entry fg q], ch), wa, [], ct) \\<in> trcl (trss fg)\n  ((u' # r, ct), wb, r', c') \\<in> trcl (trss fg)", "have L: \"length wb\\<le>length w\""], ["proof (prove)\nusing this:\n  w = wa @ wb\n  (([entry fg q], ch), wa, [], ct) \\<in> trcl (trss fg)\n  ((u' # r, ct), wb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. length wb \\<le> length w", "by simp"], ["proof (state)\nthis:\n  length wb \\<le> length w\n\ngoal (1 subgoal):\n 1. \\<And>waa wb cha.\n       \\<lbrakk>w = waa @ wb;\n        (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n        ((u' # r, cha), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from CC(3)"], ["proof (chain)\npicking this:\n  ((u' # r, ct), wb, r', c') \\<in> trcl (trss fg)", "show ?case"], ["proof (prove)\nusing this:\n  ((u' # r, ct), wb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: IHP(1)[OF L, cases set])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # r;\n        (([u'], ct), wb, s' @ [u'a], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case (1 s'' u'')"], ["proof (state)\nthis:\n  r' = s'' @ u'' # r\n  (([u'], ct), wb, s'' @ [u''], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # r;\n        (([u'], ct), wb, s' @ [u'a], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "note CCC=this"], ["proof (state)\nthis:\n  r' = s'' @ u'' # r\n  (([u'], ct), wb, s'' @ [u''], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # r;\n        (([u'], ct), wb, s' @ [u'a], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from trcl_concat[OF PREPATH CCC(2)] CC(1)"], ["proof (chain)\npicking this:\n  (([u], c), (e # wa) @ wb, s'' @ [u''], c') \\<in> trcl (trss fg)\n  w = wa @ wb", "have \"(([u],c),e#w,(s''@[u''],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([u], c), (e # wa) @ wb, s'' @ [u''], c') \\<in> trcl (trss fg)\n  w = wa @ wb\n\ngoal (1 subgoal):\n 1. (([u], c), e # w, s'' @ [u''], c') \\<in> trcl (trss fg)", "by (simp)"], ["proof (state)\nthis:\n  (([u], c), e # w, s'' @ [u''], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u'a.\n       \\<lbrakk>r' = s' @ u'a # r;\n        (([u'], ct), wb, s' @ [u'a], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from IHP(3)[OF CCC(1) this]"], ["proof (chain)\npicking this:\n  P", "show ?thesis"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case (2 wba wbb c'')"], ["proof (state)\nthis:\n  wb = wba @ wbb\n  (([u'], ct), wba, [], c'') \\<in> trcl (trss fg)\n  ((r, c''), wbb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "note CCC=this"], ["proof (state)\nthis:\n  wb = wba @ wbb\n  (([u'], ct), wba, [], c'') \\<in> trcl (trss fg)\n  ((r, c''), wbb, r', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from trcl_concat[OF PREPATH CCC(2)] CC(1) CCC(1)"], ["proof (chain)\npicking this:\n  (([u], c), (e # wa) @ wba, [], c'') \\<in> trcl (trss fg)\n  w = wa @ wb\n  wb = wba @ wbb", "have \"e#w = (e#wa@wba)@wbb\" \"(([u], c), e # wa @ wba, [], c'') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([u], c), (e # wa) @ wba, [], c'') \\<in> trcl (trss fg)\n  w = wa @ wb\n  wb = wba @ wbb\n\ngoal (1 subgoal):\n 1. e # w = (e # wa @ wba) @ wbb &&&\n    (([u], c), e # wa @ wba, [], c'') \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  e # w = (e # wa @ wba) @ wbb\n  (([u], c), e # wa @ wba, [], c'') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>wa wba ch.\n       \\<lbrakk>wb = wa @ wba;\n        (([u'], ct), wa, [], ch) \\<in> trcl (trss fg);\n        ((r, ch), wba, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from IHP(4)[OF this CCC(3)]"], ["proof (chain)\npicking this:\n  P", "show ?thesis"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "}"], ["proof (state)\nthis:\n  e = LCall ?q2 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>e l u r c.\n       \\<lbrakk>\\<And>ll u r c.\n                   \\<lbrakk>length ll \\<le> length l;\n                    ((u # r, c), ll, r', c') \\<in> trcl (trss fg);\n                    \\<And>s' u'.\n                       \\<lbrakk>r' = s' @ u' # r;\n                        (([u], c), ll, s' @ [u'], c')\n                        \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P;\n                    \\<And>wa wb ch.\n                       \\<lbrakk>ll = wa @ wb;\n                        (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n                        ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # r, c), e # l, r', c') \\<in> trcl (trss fg);\n        \\<And>s' u'.\n           \\<lbrakk>r' = s' @ u' # r;\n            (([u], c), e # l, s' @ [u'], c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>wa wb ch.\n           \\<lbrakk>e # l = wa @ wb;\n            (([u], c), wa, [], ch) \\<in> trcl (trss fg);\n            ((r, ch), wb, r', c') \\<in> trcl (trss fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  e = LBase ?ba2 \\<or> e = LSpawn ?q2 \\<Longrightarrow> P\n  e = LRet \\<Longrightarrow> P\n  e = LCall ?q2 \\<Longrightarrow> P", "show ?case"], ["proof (prove)\nusing this:\n  e = LBase ?ba2 \\<or> e = LSpawn ?q2 \\<Longrightarrow> P\n  e = LRet \\<Longrightarrow> P\n  e = LCall ?q2 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (cases e, auto)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) trss_find_call: \n  \"!!v r' c'. \\<lbrakk> (([sp],c),w,(v#r',c')) \\<in> trcl (trss fg); r'\\<noteq>[] \\<rbrakk> \n  \\<Longrightarrow> \\<exists>rh ch p wa wb. \n        w=wa@(LCall p)#wb \\<and> \n        proc_of fg v = p \\<and> \n        (([sp],c),wa,(rh,ch))\\<in>trcl (trss fg) \\<and> \n        ((rh,ch),LCall p,((entry fg p)#r',ch))\\<in>trss fg \\<and> \n        (([entry fg p],ch),wb,([v],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v r' c'.\n       \\<lbrakk>(([sp], c), w, v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            w = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "proof (induct w rule: length_compl_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v r' c'.\n       \\<lbrakk>(([sp], c), [], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            [] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)\n 2. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "case Nil"], ["proof (state)\nthis:\n  (([sp], c), [], v # r', c') \\<in> trcl (trss fg)\n  r' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>v r' c'.\n       \\<lbrakk>(([sp], c), [], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            [] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)\n 2. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "thus ?case"], ["proof (prove)\nusing this:\n  (([sp], c), [], v # r', c') \\<in> trcl (trss fg)\n  r' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>rh ch p wa wb.\n       [] = wa @ LCall p # wb \\<and>\n       proc_of fg v = p \\<and>\n       (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n       ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n       (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>rh ch p wa wb.\n     [] = wa @ LCall p # wb \\<and>\n     proc_of fg v = p \\<and>\n     (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "case (snoc w e)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([sp], c), ?ll, ?v # ?r', ?c') \\<in> trcl (trss fg);\n   ?r' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                       ?ll = wa @ LCall p # wb \\<and>\n                       proc_of fg ?v = p \\<and>\n                       (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n                       ((rh, ch), LCall p, entry fg p # ?r', ch)\n                       \\<in> trss fg \\<and>\n                       (([entry fg p], ch), wb, [?v], ?c')\n                       \\<in> trcl (trss fg)\n  (([sp], c), w @ [e], v # r', c') \\<in> trcl (trss fg)\n  r' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "note IHP=this"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([sp], c), ?ll, ?v # ?r', ?c') \\<in> trcl (trss fg);\n   ?r' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                       ?ll = wa @ LCall p # wb \\<and>\n                       proc_of fg ?v = p \\<and>\n                       (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n                       ((rh, ch), LCall p, entry fg p # ?r', ch)\n                       \\<in> trss fg \\<and>\n                       (([entry fg p], ch), wb, [?v], ?c')\n                       \\<in> trcl (trss fg)\n  (([sp], c), w @ [e], v # r', c') \\<in> trcl (trss fg)\n  r' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([sp], c), ?ll, ?v # ?r', ?c') \\<in> trcl (trss fg);\n   ?r' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                       ?ll = wa @ LCall p # wb \\<and>\n                       proc_of fg ?v = p \\<and>\n                       (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n                       ((rh, ch), LCall p, entry fg p # ?r', ch)\n                       \\<in> trss fg \\<and>\n                       (([entry fg p], ch), wb, [?v], ?c')\n                       \\<in> trcl (trss fg)\n  (([sp], c), w @ [e], v # r', c') \\<in> trcl (trss fg)\n  r' \\<noteq> []", "obtain rh ch where SPLIT1: \"(([sp],c),w,(rh,ch))\\<in>trcl (trss fg)\" and SPLIT2: \"((rh,ch),e,(v#r',c'))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length w;\n   (([sp], c), ?ll, ?v # ?r', ?c') \\<in> trcl (trss fg);\n   ?r' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                       ?ll = wa @ LCall p # wb \\<and>\n                       proc_of fg ?v = p \\<and>\n                       (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n                       ((rh, ch), LCall p, entry fg p # ?r', ch)\n                       \\<in> trss fg \\<and>\n                       (([entry fg p], ch), wb, [?v], ?c')\n                       \\<in> trcl (trss fg)\n  (([sp], c), w @ [e], v # r', c') \\<in> trcl (trss fg)\n  r' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>rh ch.\n        \\<lbrakk>(([sp], c), w, rh, ch) \\<in> trcl (trss fg);\n         ((rh, ch), e, v # r', c') \\<in> trss fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_rev_uncons)"], ["proof (state)\nthis:\n  (([sp], c), w, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), e, v # r', c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "{"], ["proof (state)\nthis:\n  (([sp], c), w, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), e, v # r', c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "assume \"\\<exists>u. rh=u#r'\""], ["proof (state)\nthis:\n  \\<exists>u. rh = u # r'\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. rh = u # r'", "obtain u where RHFMT[simp]: \"rh=u#r'\""], ["proof (prove)\nusing this:\n  \\<exists>u. rh = u # r'\n\ngoal (1 subgoal):\n 1. (\\<And>u. rh = u # r' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  rh = u # r'\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "with SPLIT2"], ["proof (chain)\npicking this:\n  ((rh, ch), e, v # r', c') \\<in> trss fg\n  rh = u # r'", "have \"proc_of fg u = proc_of fg v\""], ["proof (prove)\nusing this:\n  ((rh, ch), e, v # r', c') \\<in> trss fg\n  rh = u # r'\n\ngoal (1 subgoal):\n 1. proc_of fg u = proc_of fg v", "by (auto elim: trss.cases intro: edges_part)"], ["proof (state)\nthis:\n  proc_of fg u = proc_of fg v\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  proc_of fg u = proc_of fg v\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "from IHP(1)[of w u r' ch, OF _ SPLIT1[simplified] IHP(3)]"], ["proof (chain)\npicking this:\n  length w \\<le> length w \\<Longrightarrow>\n  \\<exists>rh cha p waa wb.\n     w = waa @ LCall p # wb \\<and>\n     proc_of fg u = p \\<and>\n     (([sp], c), waa, rh, cha) \\<in> trcl (trss fg) \\<and>\n     ((rh, cha), LCall p, entry fg p # r', cha) \\<in> trss fg \\<and>\n     (([entry fg p], cha), wb, [u], ch) \\<in> trcl (trss fg)", "obtain rt ct p wa wb where \n      IHAPP: \"w = wa @ LCall p # wb\" \"proc_of fg u = p\" \"(([sp], c), wa, (rt, ct)) \\<in> trcl (trss fg)\" \"((rt, ct), LCall p, entry fg p # r', ct) \\<in> trss fg\"  \n          \"(([entry fg p], ct), wb, ([u], ch)) \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  length w \\<le> length w \\<Longrightarrow>\n  \\<exists>rh cha p waa wb.\n     w = waa @ LCall p # wb \\<and>\n     proc_of fg u = p \\<and>\n     (([sp], c), waa, rh, cha) \\<in> trcl (trss fg) \\<and>\n     ((rh, cha), LCall p, entry fg p # r', cha) \\<in> trss fg \\<and>\n     (([entry fg p], cha), wb, [u], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>waa p wb rt ct.\n        \\<lbrakk>w = waa @ LCall p # wb; proc_of fg u = p;\n         (([sp], c), waa, rt, ct) \\<in> trcl (trss fg);\n         ((rt, ct), LCall p, entry fg p # r', ct) \\<in> trss fg;\n         (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast)"], ["proof (state)\nthis:\n  w = wa @ LCall p # wb\n  proc_of fg u = p\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall p, entry fg p # r', ct) \\<in> trss fg\n  (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  w = wa @ LCall p # wb\n  proc_of fg u = p\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall p, entry fg p # r', ct) \\<in> trss fg\n  (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "have \"(([entry fg p], ct), wb@[e], ([v], c')) \\<in> trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)", "note IHAPP(5)"], ["proof (state)\nthis:\n  (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)", "from SPLIT2"], ["proof (chain)\npicking this:\n  ((rh, ch), e, v # r', c') \\<in> trss fg", "have \"(([u],ch),e,([v],c')) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  ((rh, ch), e, v # r', c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([u], ch), e, [v], c') \\<in> trss fg", "by (auto elim!: trss.cases intro!: trss.intros)"], ["proof (state)\nthis:\n  (([u], ch), e, [v], c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)", "finally"], ["proof (chain)\npicking this:\n  (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)", "."], ["proof (state)\nthis:\n  (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "from IHAPP"], ["proof (chain)\npicking this:\n  w = wa @ LCall p # wb\n  proc_of fg u = p\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall p, entry fg p # r', ct) \\<in> trss fg\n  (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)", "have \"w@[e] = wa @ LCall p # (wb@[e])\""], ["proof (prove)\nusing this:\n  w = wa @ LCall p # wb\n  proc_of fg u = p\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall p, entry fg p # r', ct) \\<in> trss fg\n  (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. w @ [e] = wa @ LCall p # wb @ [e]", "by auto"], ["proof (state)\nthis:\n  w @ [e] = wa @ LCall p # wb @ [e]\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "ultimately"], ["proof (chain)\npicking this:\n  proc_of fg u = proc_of fg v\n  w = wa @ LCall p # wb\n  proc_of fg u = p\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall p, entry fg p # r', ct) \\<in> trss fg\n  (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)\n  (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)\n  w @ [e] = wa @ LCall p # wb @ [e]", "have ?case"], ["proof (prove)\nusing this:\n  proc_of fg u = proc_of fg v\n  w = wa @ LCall p # wb\n  proc_of fg u = p\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall p, entry fg p # r', ct) \\<in> trss fg\n  (([entry fg p], ct), wb, [u], ch) \\<in> trcl (trss fg)\n  (([entry fg p], ct), wb @ [e], [v], c') \\<in> trcl (trss fg)\n  w @ [e] = wa @ LCall p # wb @ [e]\n\ngoal (1 subgoal):\n 1. \\<exists>rh ch p waa wb.\n       w @ [e] = waa @ LCall p # wb \\<and>\n       proc_of fg v = p \\<and>\n       (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n       ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n       (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  \\<exists>rh ch p waa wb.\n     w @ [e] = waa @ LCall p # wb \\<and>\n     proc_of fg v = p \\<and>\n     (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "}"], ["proof (state)\nthis:\n  \\<exists>u. rh = u # r' \\<Longrightarrow>\n  \\<exists>rh ch p waa wb.\n     w @ [e] = waa @ LCall p # wb \\<and>\n     proc_of fg v = p \\<and>\n     (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "moreover"], ["proof (state)\nthis:\n  \\<exists>u. rh = u # r' \\<Longrightarrow>\n  \\<exists>rh ch p waa wb.\n     w @ [e] = waa @ LCall p # wb \\<and>\n     proc_of fg v = p \\<and>\n     (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "have \"(\\<exists>u. rh=u#r') \\<or> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u. rh = u # r') \\<or>\n    (\\<exists>rh ch p waa wb.\n        w @ [e] = waa @ LCall p # wb \\<and>\n        proc_of fg v = p \\<and>\n        (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n        ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n        (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg))", "proof (rule trss.cases[OF SPLIT2], simp_all, goal_cases) \\<comment> \\<open>Cases for base- and spawn edge are discharged automatically\\<close>\n      \\<comment> \\<open>Case: call-edge\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u p va ca r.\n       \\<lbrakk>rh = u # r; ch = ca; e = LCall p;\n        v = entry fg p \\<and> r' = va # r; c' = ca;\n        (u, Call p, va) \\<in> edges fg;\n        mon fg p \\<inter> mon_c fg ca = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch waa wb.\n                            w @ [LCall p] = waa @ LCall p # wb \\<and>\n                            (([sp], c), waa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # va # r, ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [entry fg p], ca)\n                            \\<in> trcl (trss fg)\n 2. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "case (1 ca p r u vv)"], ["proof (state)\nthis:\n  rh = ca # vv\n  ch = u\n  e = LCall p\n  v = entry fg p \\<and> r' = r # vv\n  c' = u\n  (ca, Call p, r) \\<in> edges fg\n  mon fg p \\<inter> mon_c fg u = {}\n\ngoal (2 subgoals):\n 1. \\<And>u p va ca r.\n       \\<lbrakk>rh = u # r; ch = ca; e = LCall p;\n        v = entry fg p \\<and> r' = va # r; c' = ca;\n        (u, Call p, va) \\<in> edges fg;\n        mon fg p \\<inter> mon_c fg ca = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch waa wb.\n                            w @ [LCall p] = waa @ LCall p # wb \\<and>\n                            (([sp], c), waa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # va # r, ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [entry fg p], ca)\n                            \\<in> trcl (trss fg)\n 2. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "with SPLIT1 SPLIT2"], ["proof (chain)\npicking this:\n  (([sp], c), w, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), e, v # r', c') \\<in> trss fg\n  rh = ca # vv\n  ch = u\n  e = LCall p\n  v = entry fg p \\<and> r' = r # vv\n  c' = u\n  (ca, Call p, r) \\<in> edges fg\n  mon fg p \\<inter> mon_c fg u = {}", "show ?case"], ["proof (prove)\nusing this:\n  (([sp], c), w, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), e, v # r', c') \\<in> trss fg\n  rh = ca # vv\n  ch = u\n  e = LCall p\n  v = entry fg p \\<and> r' = r # vv\n  c' = u\n  (ca, Call p, r) \\<in> edges fg\n  mon fg p \\<inter> mon_c fg u = {}\n\ngoal (1 subgoal):\n 1. \\<exists>rh ch waa wb.\n       w @ [LCall p] = waa @ LCall p # wb \\<and>\n       (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n       ((rh, ch), LCall p, entry fg p # r # vv, ch) \\<in> trss fg \\<and>\n       (([entry fg p], ch), wb, [entry fg p], u) \\<in> trcl (trss fg)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>rh ch waa wb.\n     w @ [LCall p] = waa @ LCall p # wb \\<and>\n     (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r # vv, ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [entry fg p], u) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "next\n      \\<comment> \\<open>Case: return edge\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "case CC: (2 q r ca)"], ["proof (state)\nthis:\n  rh = return fg q # r\n  ch = ca\n  e = LRet\n  v # r' = r\n  c' = ca\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "hence [simp]: \"rh=(return fg q)#v#r'\""], ["proof (prove)\nusing this:\n  rh = return fg q # r\n  ch = ca\n  e = LRet\n  v # r' = r\n  c' = ca\n\ngoal (1 subgoal):\n 1. rh = return fg q # v # r'", "by simp"], ["proof (state)\nthis:\n  rh = return fg q # v # r'\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "with IHP(1)[of w \"(return fg q)\" \"v#r'\" ch, OF _ SPLIT1[simplified]]"], ["proof (chain)\npicking this:\n  \\<lbrakk>length w \\<le> length w; v # r' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rh cha p waa wb.\n                       w = waa @ LCall p # wb \\<and>\n                       proc_of fg (return fg q) = p \\<and>\n                       (([sp], c), waa, rh, cha) \\<in> trcl (trss fg) \\<and>\n                       ((rh, cha), LCall p, entry fg p # v # r', cha)\n                       \\<in> trss fg \\<and>\n                       (([entry fg p], cha), wb, [return fg q], ch)\n                       \\<in> trcl (trss fg)\n  rh = return fg q # v # r'", "obtain rt ct wa wb where \n      IHAPP: \"w = wa @ LCall q # wb\" \"(([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\" \"((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg\"\n          \"(([entry fg q], ct), wb, [return fg q], ch) \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length w \\<le> length w; v # r' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rh cha p waa wb.\n                       w = waa @ LCall p # wb \\<and>\n                       proc_of fg (return fg q) = p \\<and>\n                       (([sp], c), waa, rh, cha) \\<in> trcl (trss fg) \\<and>\n                       ((rh, cha), LCall p, entry fg p # v # r', cha)\n                       \\<in> trss fg \\<and>\n                       (([entry fg p], cha), wb, [return fg q], ch)\n                       \\<in> trcl (trss fg)\n  rh = return fg q # v # r'\n\ngoal (1 subgoal):\n 1. (\\<And>waa wb rt ct.\n        \\<lbrakk>w = waa @ LCall q # wb;\n         (([sp], c), waa, rt, ct) \\<in> trcl (trss fg);\n         ((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg;\n         (([entry fg q], ct), wb, [return fg q], ch)\n         \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  w = wa @ LCall q # wb\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg\n  (([entry fg q], ct), wb, [return fg q], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "then"], ["proof (chain)\npicking this:\n  w = wa @ LCall q # wb\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg\n  (([entry fg q], ct), wb, [return fg q], ch) \\<in> trcl (trss fg)", "obtain u where RTFMT [simp]: \"rt=u#r'\" and PROC_OF_U: \"proc_of fg u = proc_of fg v\""], ["proof (prove)\nusing this:\n  w = wa @ LCall q # wb\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg\n  (([entry fg q], ct), wb, [return fg q], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>rt = u # r'; proc_of fg u = proc_of fg v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: trss.cases intro: edges_part)"], ["proof (state)\nthis:\n  rt = u # r'\n  proc_of fg u = proc_of fg v\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "from IHAPP(1)"], ["proof (chain)\npicking this:\n  w = wa @ LCall q # wb", "have LENWA: \"length wa \\<le> length w\""], ["proof (prove)\nusing this:\n  w = wa @ LCall q # wb\n\ngoal (1 subgoal):\n 1. length wa \\<le> length w", "by auto"], ["proof (state)\nthis:\n  length wa \\<le> length w\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "from IHP(1)[OF LENWA IHAPP(2)[simplified] IHP(3)]"], ["proof (chain)\npicking this:\n  \\<exists>rh ch p wa wb.\n     wa = wa @ LCall p # wb \\<and>\n     proc_of fg u = p \\<and>\n     (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [u], ct) \\<in> trcl (trss fg)", "obtain rhh chh p waa wab where \n      IHAPP': \"wa=waa@LCall p # wab\" \"proc_of fg u = p\" \"(([sp],c),waa,(rhh,chh))\\<in>trcl (trss fg)\" \"((rhh,chh),LCall p, (entry fg p#r',chh))\\<in>trss fg\" \n          \"(([entry fg p],chh),wab,([u],ct))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<exists>rh ch p wa wb.\n     wa = wa @ LCall p # wb \\<and>\n     proc_of fg u = p \\<and>\n     (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [u], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>waaa p wab rhh chh.\n        \\<lbrakk>wa = waaa @ LCall p # wab; proc_of fg u = p;\n         (([sp], c), waaa, rhh, chh) \\<in> trcl (trss fg);\n         ((rhh, chh), LCall p, entry fg p # r', chh) \\<in> trss fg;\n         (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  wa = waa @ LCall p # wab\n  proc_of fg u = p\n  (([sp], c), waa, rhh, chh) \\<in> trcl (trss fg)\n  ((rhh, chh), LCall p, entry fg p # r', chh) \\<in> trss fg\n  (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "from IHAPP IHAPP' PROC_OF_U"], ["proof (chain)\npicking this:\n  w = wa @ LCall q # wb\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg\n  (([entry fg q], ct), wb, [return fg q], ch) \\<in> trcl (trss fg)\n  wa = waa @ LCall p # wab\n  proc_of fg u = p\n  (([sp], c), waa, rhh, chh) \\<in> trcl (trss fg)\n  ((rhh, chh), LCall p, entry fg p # r', chh) \\<in> trss fg\n  (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\n  proc_of fg u = proc_of fg v", "have \"w@[e]=waa@LCall p#(wab@LCall q#wb@[e]) \\<and> proc_of fg v = p\""], ["proof (prove)\nusing this:\n  w = wa @ LCall q # wb\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg\n  (([entry fg q], ct), wb, [return fg q], ch) \\<in> trcl (trss fg)\n  wa = waa @ LCall p # wab\n  proc_of fg u = p\n  (([sp], c), waa, rhh, chh) \\<in> trcl (trss fg)\n  ((rhh, chh), LCall p, entry fg p # r', chh) \\<in> trss fg\n  (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\n  proc_of fg u = proc_of fg v\n\ngoal (1 subgoal):\n 1. w @ [e] = waa @ LCall p # wab @ LCall q # wb @ [e] \\<and>\n    proc_of fg v = p", "by auto"], ["proof (state)\nthis:\n  w @ [e] = waa @ LCall p # wab @ LCall q # wb @ [e] \\<and> proc_of fg v = p\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "moreover"], ["proof (state)\nthis:\n  w @ [e] = waa @ LCall p # wab @ LCall q # wb @ [e] \\<and> proc_of fg v = p\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "have \"(([entry fg p],chh),wab@(LCall q)#wb@[e],([v],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "note IHAPP'(5)"], ["proof (state)\nthis:\n  (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "from IHAPP"], ["proof (chain)\npicking this:\n  w = wa @ LCall q # wb\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg\n  (([entry fg q], ct), wb, [return fg q], ch) \\<in> trcl (trss fg)", "have \"(([u], ct), LCall q, entry fg q # [v], ct) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  w = wa @ LCall q # wb\n  (([sp], c), wa, rt, ct) \\<in> trcl (trss fg)\n  ((rt, ct), LCall q, entry fg q # v # r', ct) \\<in> trss fg\n  (([entry fg q], ct), wb, [return fg q], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([u], ct), LCall q, [entry fg q, v], ct) \\<in> trss fg", "by (auto elim!: trss.cases intro!: trss.intros)"], ["proof (state)\nthis:\n  (([u], ct), LCall q, [entry fg q, v], ct) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  (([u], ct), LCall q, [entry fg q, v], ct) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "from trss_stack_comp[OF IHAPP(4)]"], ["proof (chain)\npicking this:\n  (([entry fg q] @ ?r, ct), wb, [return fg q] @ ?r, ch) \\<in> trcl (trss fg)", "have \"((entry fg q#[v],ct),wb,(return fg q#[v],ch))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg q] @ ?r, ct), wb, [return fg q] @ ?r, ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg q, v], ct), wb, [return fg q, v], ch) \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([entry fg q, v], ct), wb, [return fg q, v], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  (([entry fg q, v], ct), wb, [return fg q, v], ch) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "from CC"], ["proof (chain)\npicking this:\n  rh = return fg q # r\n  ch = ca\n  e = LRet\n  v # r' = r\n  c' = ca", "have \"((return fg q#[v],ch),e,([v],c'))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  rh = return fg q # r\n  ch = ca\n  e = LRet\n  v # r' = r\n  c' = ca\n\ngoal (1 subgoal):\n 1. (([return fg q, v], ch), e, [v], c') \\<in> trss fg", "by (auto intro: trss_ret)"], ["proof (state)\nthis:\n  (([return fg q, v], ch), e, [v], c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "finally"], ["proof (chain)\npicking this:\n  (([entry fg p], chh), ((wab @ [LCall q]) @ wb) @ [e], [v], c')\n  \\<in> trcl (trss fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  (([entry fg p], chh), ((wab @ [LCall q]) @ wb) @ [e], [v], c')\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n    \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n  \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "moreover"], ["proof (state)\nthis:\n  (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "note IHAPP' CC"], ["proof (state)\nthis:\n  wa = waa @ LCall p # wab\n  proc_of fg u = p\n  (([sp], c), waa, rhh, chh) \\<in> trcl (trss fg)\n  ((rhh, chh), LCall p, entry fg p # r', chh) \\<in> trss fg\n  (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\n  rh = return fg q # r\n  ch = ca\n  e = LRet\n  v # r' = r\n  c' = ca\n\ngoal (1 subgoal):\n 1. \\<And>p r ca.\n       \\<lbrakk>rh = return fg p # r; ch = ca; e = LRet; v # r' = r;\n        c' = ca\\<rbrakk>\n       \\<Longrightarrow> r = r' \\<or>\n                         (\\<exists>rh ch waa wb.\n                             w @ [LRet] =\n                             waa @ LCall (proc_of fg v) # wb \\<and>\n                             (([sp], c), waa, rh, ch)\n                             \\<in> trcl (trss fg) \\<and>\n                             ((rh, ch), LCall (proc_of fg v),\n                              entry fg (proc_of fg v) # r', ch)\n                             \\<in> trss fg \\<and>\n                             (([entry fg (proc_of fg v)], ch), wb, [v], ca)\n                             \\<in> trcl (trss fg))", "ultimately"], ["proof (chain)\npicking this:\n  w @ [e] = waa @ LCall p # wab @ LCall q # wb @ [e] \\<and> proc_of fg v = p\n  (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n  \\<in> trcl (trss fg)\n  wa = waa @ LCall p # wab\n  proc_of fg u = p\n  (([sp], c), waa, rhh, chh) \\<in> trcl (trss fg)\n  ((rhh, chh), LCall p, entry fg p # r', chh) \\<in> trss fg\n  (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\n  rh = return fg q # r\n  ch = ca\n  e = LRet\n  v # r' = r\n  c' = ca", "show ?case"], ["proof (prove)\nusing this:\n  w @ [e] = waa @ LCall p # wab @ LCall q # wb @ [e] \\<and> proc_of fg v = p\n  (([entry fg p], chh), wab @ LCall q # wb @ [e], [v], c')\n  \\<in> trcl (trss fg)\n  wa = waa @ LCall p # wab\n  proc_of fg u = p\n  (([sp], c), waa, rhh, chh) \\<in> trcl (trss fg)\n  ((rhh, chh), LCall p, entry fg p # r', chh) \\<in> trss fg\n  (([entry fg p], chh), wab, [u], ct) \\<in> trcl (trss fg)\n  rh = return fg q # r\n  ch = ca\n  e = LRet\n  v # r' = r\n  c' = ca\n\ngoal (1 subgoal):\n 1. r = r' \\<or>\n    (\\<exists>rh ch waa wb.\n        w @ [LRet] = waa @ LCall (proc_of fg v) # wb \\<and>\n        (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n        ((rh, ch), LCall (proc_of fg v), entry fg (proc_of fg v) # r', ch)\n        \\<in> trss fg \\<and>\n        (([entry fg (proc_of fg v)], ch), wb, [v], ca) \\<in> trcl (trss fg))", "by auto"], ["proof (state)\nthis:\n  r = r' \\<or>\n  (\\<exists>rh ch waa wb.\n      w @ [LRet] = waa @ LCall (proc_of fg v) # wb \\<and>\n      (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n      ((rh, ch), LCall (proc_of fg v), entry fg (proc_of fg v) # r', ch)\n      \\<in> trss fg \\<and>\n      (([entry fg (proc_of fg v)], ch), wb, [v], ca) \\<in> trcl (trss fg))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>u. rh = u # r') \\<or>\n  (\\<exists>rh ch p waa wb.\n      w @ [e] = waa @ LCall p # wb \\<and>\n      proc_of fg v = p \\<and>\n      (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n      ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n      (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg))\n\ngoal (1 subgoal):\n 1. \\<And>l e v r' c'.\n       \\<lbrakk>\\<And>ll v r' c'.\n                   \\<lbrakk>length ll \\<le> length l;\n                    (([sp], c), ll, v # r', c') \\<in> trcl (trss fg);\n                    r' \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>rh ch p wa wb.\n  ll = wa @ LCall p # wb \\<and>\n  proc_of fg v = p \\<and>\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n  ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n  (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg);\n        (([sp], c), l @ [e], v # r', c') \\<in> trcl (trss fg);\n        r' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rh ch p wa wb.\n                            l @ [e] = wa @ LCall p # wb \\<and>\n                            proc_of fg v = p \\<and>\n                            (([sp], c), wa, rh, ch)\n                            \\<in> trcl (trss fg) \\<and>\n                            ((rh, ch), LCall p, entry fg p # r', ch)\n                            \\<in> trss fg \\<and>\n                            (([entry fg p], ch), wb, [v], c')\n                            \\<in> trcl (trss fg)", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>u. rh = u # r' \\<Longrightarrow>\n  \\<exists>rh ch p waa wb.\n     w @ [e] = waa @ LCall p # wb \\<and>\n     proc_of fg v = p \\<and>\n     (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)\n  (\\<exists>u. rh = u # r') \\<or>\n  (\\<exists>rh ch p waa wb.\n      w @ [e] = waa @ LCall p # wb \\<and>\n      proc_of fg v = p \\<and>\n      (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n      ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n      (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg))", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>u. rh = u # r' \\<Longrightarrow>\n  \\<exists>rh ch p waa wb.\n     w @ [e] = waa @ LCall p # wb \\<and>\n     proc_of fg v = p \\<and>\n     (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)\n  (\\<exists>u. rh = u # r') \\<or>\n  (\\<exists>rh ch p waa wb.\n      w @ [e] = waa @ LCall p # wb \\<and>\n      proc_of fg v = p \\<and>\n      (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n      ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n      (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg))\n\ngoal (1 subgoal):\n 1. \\<exists>rh ch p waa wb.\n       w @ [e] = waa @ LCall p # wb \\<and>\n       proc_of fg v = p \\<and>\n       (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n       ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n       (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>rh ch p waa wb.\n     w @ [e] = waa @ LCall p # wb \\<and>\n     proc_of fg v = p \\<and>\n     (([sp], c), waa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall p, entry fg p # r', ch) \\<in> trss fg \\<and>\n     (([entry fg p], ch), wb, [v], c') \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>This lemma is better suited for application in soundness proofs of constraint systems than @{thm [source] flowgraph.trss_find_call}\\<close>"], ["", "lemma (in flowgraph) trss_find_call': \n  assumes A: \"(([sp],c),w,(return fg p#[u'],c')) \\<in> trcl (trss fg)\" \n  and EX: \"!!uh ch wa wb. \\<lbrakk>\n      w=wa@(LCall p)#wb; \n      (([sp],c),wa,([uh],ch))\\<in>trcl (trss fg); \n      (([uh],ch),LCall p,((entry fg p)#[u'],ch))\\<in>trss fg;\n      (uh,Call p,u')\\<in>edges fg; \n      (([entry fg p],ch),wb,([return fg p],c'))\\<in>trcl (trss fg)\n    \\<rbrakk> \\<Longrightarrow> P\" \n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from trss_find_call[OF A]"], ["proof (chain)\npicking this:\n  [u'] \\<noteq> [] \\<Longrightarrow>\n  \\<exists>rh ch pa wa wb.\n     w = wa @ LCall pa # wb \\<and>\n     proc_of fg (return fg p) = pa \\<and>\n     (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall pa, [entry fg pa, u'], ch) \\<in> trss fg \\<and>\n     (([entry fg pa], ch), wb, [return fg p], c') \\<in> trcl (trss fg)", "obtain rh ch wa wb where FC: \n    \"w = wa @ LCall p # wb\" \n    \"(([sp], c), wa, rh, ch) \\<in> trcl (trss fg)\" \n    \"((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg\" \n    \"(([entry fg p], ch), wb, [return fg p], c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  [u'] \\<noteq> [] \\<Longrightarrow>\n  \\<exists>rh ch pa wa wb.\n     w = wa @ LCall pa # wb \\<and>\n     proc_of fg (return fg p) = pa \\<and>\n     (([sp], c), wa, rh, ch) \\<in> trcl (trss fg) \\<and>\n     ((rh, ch), LCall pa, [entry fg pa, u'], ch) \\<in> trss fg \\<and>\n     (([entry fg pa], ch), wb, [return fg p], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>wa wb rh ch.\n        \\<lbrakk>w = wa @ LCall p # wb;\n         (([sp], c), wa, rh, ch) \\<in> trcl (trss fg);\n         ((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg;\n         (([entry fg p], ch), wb, [return fg p], c')\n         \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = wa @ LCall p # wb\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg\n  (([entry fg p], ch), wb, [return fg p], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  w = wa @ LCall p # wb\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg\n  (([entry fg p], ch), wb, [return fg p], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. P", "from FC(3)"], ["proof (chain)\npicking this:\n  ((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg", "obtain uh where ADD: \"rh=[uh]\" \"(uh,Call p,u')\\<in>edges fg\""], ["proof (prove)\nusing this:\n  ((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (\\<And>uh.\n        \\<lbrakk>rh = [uh]; (uh, Call p, u') \\<in> edges fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: trss.cases)"], ["proof (state)\nthis:\n  rh = [uh]\n  (uh, Call p, u') \\<in> edges fg\n\ngoal (1 subgoal):\n 1. P", "ultimately"], ["proof (chain)\npicking this:\n  w = wa @ LCall p # wb\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg\n  (([entry fg p], ch), wb, [return fg p], c') \\<in> trcl (trss fg)\n  rh = [uh]\n  (uh, Call p, u') \\<in> edges fg", "show ?thesis"], ["proof (prove)\nusing this:\n  w = wa @ LCall p # wb\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg\n  (([entry fg p], ch), wb, [return fg p], c') \\<in> trcl (trss fg)\n  rh = [uh]\n  (uh, Call p, u') \\<in> edges fg\n\ngoal (1 subgoal):\n 1. P", "using EX"], ["proof (prove)\nusing this:\n  w = wa @ LCall p # wb\n  (([sp], c), wa, rh, ch) \\<in> trcl (trss fg)\n  ((rh, ch), LCall p, [entry fg p, u'], ch) \\<in> trss fg\n  (([entry fg p], ch), wb, [return fg p], c') \\<in> trcl (trss fg)\n  rh = [uh]\n  (uh, Call p, u') \\<in> edges fg\n  \\<lbrakk>w = ?wa @ LCall p # ?wb;\n   (([sp], c), ?wa, [?uh], ?ch) \\<in> trcl (trss fg);\n   (([?uh], ?ch), LCall p, [entry fg p, u'], ?ch) \\<in> trss fg;\n   (?uh, Call p, u') \\<in> edges fg;\n   (([entry fg p], ?ch), ?wb, [return fg p], c')\n   \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) trss_bot_proc_const: \n  \"!!s' u' c'. ((s@[u],c),w,(s'@[u'],c'))\\<in>trcl (trss fg) \n    \\<Longrightarrow> proc_of fg u = proc_of fg u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' u' c'.\n       ((s @ [u], c), w, s' @ [u'], c')\n       \\<in> trcl (trss fg) \\<Longrightarrow>\n       proc_of fg u = proc_of fg u'", "proof (induct w rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' u' c'.\n       ((s @ [u], c), [], s' @ [u'], c')\n       \\<in> trcl (trss fg) \\<Longrightarrow>\n       proc_of fg u = proc_of fg u'\n 2. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "case Nil"], ["proof (state)\nthis:\n  ((s @ [u], c), [], s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s' u' c'.\n       ((s @ [u], c), [], s' @ [u'], c')\n       \\<in> trcl (trss fg) \\<Longrightarrow>\n       proc_of fg u = proc_of fg u'\n 2. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "thus ?case"], ["proof (prove)\nusing this:\n  ((s @ [u], c), [], s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. proc_of fg u = proc_of fg u'", "by auto"], ["proof (state)\nthis:\n  proc_of fg u = proc_of fg u'\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "case (snoc e w)"], ["proof (state)\nthis:\n  ((s @ [u], c), w, ?s' @ [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg u = proc_of fg ?u'\n  ((s @ [u], c), w @ [e], s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "note IHP=this"], ["proof (state)\nthis:\n  ((s @ [u], c), w, ?s' @ [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg u = proc_of fg ?u'\n  ((s @ [u], c), w @ [e], s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "then"], ["proof (chain)\npicking this:\n  ((s @ [u], c), w, ?s' @ [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg u = proc_of fg ?u'\n  ((s @ [u], c), w @ [e], s' @ [u'], c') \\<in> trcl (trss fg)", "obtain sh ch where SPLIT1: \"((s@[u],c),w,(sh,ch))\\<in>trcl (trss fg)\" and SPLIT2: \"((sh,ch),e,(s'@[u'],c'))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  ((s @ [u], c), w, ?s' @ [?u'], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg u = proc_of fg ?u'\n  ((s @ [u], c), w @ [e], s' @ [u'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>((s @ [u], c), w, sh, ch) \\<in> trcl (trss fg);\n         ((sh, ch), e, s' @ [u'], c') \\<in> trss fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_rev_uncons)"], ["proof (state)\nthis:\n  ((s @ [u], c), w, sh, ch) \\<in> trcl (trss fg)\n  ((sh, ch), e, s' @ [u'], c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "from SPLIT2"], ["proof (chain)\npicking this:\n  ((sh, ch), e, s' @ [u'], c') \\<in> trss fg", "have \"sh\\<noteq>[]\""], ["proof (prove)\nusing this:\n  ((sh, ch), e, s' @ [u'], c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. sh \\<noteq> []", "by (auto elim!: trss.cases)"], ["proof (state)\nthis:\n  sh \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "then"], ["proof (chain)\npicking this:\n  sh \\<noteq> []", "obtain ssh uh where SHFMT: \"sh=ssh@[uh]\""], ["proof (prove)\nusing this:\n  sh \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ssh uh.\n        sh = ssh @ [uh] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: list_rev_decomp)"], ["proof (state)\nthis:\n  sh = ssh @ [uh]\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "with IHP(1)[of ssh uh ch] SPLIT1"], ["proof (chain)\npicking this:\n  ((s @ [u], c), w, ssh @ [uh], ch) \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg u = proc_of fg uh\n  ((s @ [u], c), w, sh, ch) \\<in> trcl (trss fg)\n  sh = ssh @ [uh]", "have \"proc_of fg u = proc_of fg uh\""], ["proof (prove)\nusing this:\n  ((s @ [u], c), w, ssh @ [uh], ch) \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg u = proc_of fg uh\n  ((s @ [u], c), w, sh, ch) \\<in> trcl (trss fg)\n  sh = ssh @ [uh]\n\ngoal (1 subgoal):\n 1. proc_of fg u = proc_of fg uh", "by auto"], ["proof (state)\nthis:\n  proc_of fg u = proc_of fg uh\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "also"], ["proof (state)\nthis:\n  proc_of fg u = proc_of fg uh\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "from SPLIT2 SHFMT"], ["proof (chain)\npicking this:\n  ((sh, ch), e, s' @ [u'], c') \\<in> trss fg\n  sh = ssh @ [uh]", "have \"proc_of fg uh = proc_of fg u'\""], ["proof (prove)\nusing this:\n  ((sh, ch), e, s' @ [u'], c') \\<in> trss fg\n  sh = ssh @ [uh]\n\ngoal (1 subgoal):\n 1. proc_of fg uh = proc_of fg u'", "by (cases rule: trss.cases) (cases ssh, auto simp add: edges_part)+"], ["proof (state)\nthis:\n  proc_of fg uh = proc_of fg u'\n\ngoal (1 subgoal):\n 1. \\<And>x xs s' u' c'.\n       \\<lbrakk>\\<And>s' u' c'.\n                   ((s @ [u], c), xs, s' @ [u'], c')\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   proc_of fg u = proc_of fg u';\n        ((s @ [u], c), xs @ [x], s' @ [u'], c')\n        \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> proc_of fg u = proc_of fg u'", "finally"], ["proof (chain)\npicking this:\n  proc_of fg u = proc_of fg u'", "show ?case"], ["proof (prove)\nusing this:\n  proc_of fg u = proc_of fg u'\n\ngoal (1 subgoal):\n 1. proc_of fg u = proc_of fg u'", "."], ["proof (state)\nthis:\n  proc_of fg u = proc_of fg u'\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Specialized version of @{thm [source] flowgraph.trss_bot_proc_const}that comes in handy for precision proofs of constraint systems\\<close>"], ["", "lemma (in flowgraph) trss_er_path_proc_const: \n  \"(([entry fg p],c),w,([return fg q],c'))\\<in>trcl (trss fg) \\<Longrightarrow> p=q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([entry fg p], c), w, [return fg q], c')\n    \\<in> trcl (trss fg) \\<Longrightarrow>\n    p = q", "using trss_bot_proc_const[of \"[]\" \"entry fg p\" _ _ \"[]\" \"return fg q\", simplified]"], ["proof (prove)\nusing this:\n  (([entry fg p], ?c), ?w, [return fg q], ?c')\n  \\<in> trcl (trss fg) \\<Longrightarrow>\n  p = q\n\ngoal (1 subgoal):\n 1. (([entry fg p], c), w, [return fg q], c')\n    \\<in> trcl (trss fg) \\<Longrightarrow>\n    p = q", "."], ["", "lemma trss_2empty_to_2return: \"\\<lbrakk> ((s,c),w,([],c'))\\<in>trcl (trss fg); s\\<noteq>[] \\<rbrakk> \\<Longrightarrow> \n  \\<exists>w' p. w=w'@[LRet] \\<and> ((s,c),w',([return fg p],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, [], c') \\<in> trcl (trss fg);\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w' p.\n                         w = w' @ [LRet] \\<and>\n                         ((s, c), w', [return fg p], c')\n                         \\<in> trcl (trss fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, [], c') \\<in> trcl (trss fg);\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w' p.\n                         w = w' @ [LRet] \\<and>\n                         ((s, c), w', [return fg p], c')\n                         \\<in> trcl (trss fg)", "assume A: \"((s,c),w,([],c'))\\<in>trcl (trss fg)\" \"s\\<noteq>[]\""], ["proof (state)\nthis:\n  ((s, c), w, [], c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, [], c') \\<in> trcl (trss fg);\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w' p.\n                         w = w' @ [LRet] \\<and>\n                         ((s, c), w', [return fg p], c')\n                         \\<in> trcl (trss fg)", "hence \"w\\<noteq>[]\""], ["proof (prove)\nusing this:\n  ((s, c), w, [], c') \\<in> trcl (trss fg)\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. w \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, [], c') \\<in> trcl (trss fg);\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w' p.\n                         w = w' @ [LRet] \\<and>\n                         ((s, c), w', [return fg p], c')\n                         \\<in> trcl (trss fg)", "then"], ["proof (chain)\npicking this:\n  w \\<noteq> []", "obtain w' e where WD: \"w=w'@[e]\""], ["proof (prove)\nusing this:\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>w' e. w = w' @ [e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: list_rev_decomp)"], ["proof (state)\nthis:\n  w = w' @ [e]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, [], c') \\<in> trcl (trss fg);\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w' p.\n                         w = w' @ [LRet] \\<and>\n                         ((s, c), w', [return fg p], c')\n                         \\<in> trcl (trss fg)", "with A(1)"], ["proof (chain)\npicking this:\n  ((s, c), w, [], c') \\<in> trcl (trss fg)\n  w = w' @ [e]", "obtain sh ch where SPLIT: \"((s,c),w',(sh,ch))\\<in>trcl (trss fg)\" \"((sh,ch),e,([],c'))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  ((s, c), w, [], c') \\<in> trcl (trss fg)\n  w = w' @ [e]\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>((s, c), w', sh, ch) \\<in> trcl (trss fg);\n         ((sh, ch), e, [], c') \\<in> trss fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_rev_uncons)"], ["proof (state)\nthis:\n  ((s, c), w', sh, ch) \\<in> trcl (trss fg)\n  ((sh, ch), e, [], c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, [], c') \\<in> trcl (trss fg);\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w' p.\n                         w = w' @ [LRet] \\<and>\n                         ((s, c), w', [return fg p], c')\n                         \\<in> trcl (trss fg)", "from SPLIT(2)"], ["proof (chain)\npicking this:\n  ((sh, ch), e, [], c') \\<in> trss fg", "obtain p where \"e=LRet\" \"sh=[return fg p]\" \"ch=c'\""], ["proof (prove)\nusing this:\n  ((sh, ch), e, [], c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>e = LRet; sh = [return fg p]; ch = c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: trss.cases, auto)"], ["proof (state)\nthis:\n  e = LRet\n  sh = [return fg p]\n  ch = c'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, [], c') \\<in> trcl (trss fg);\n     s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w' p.\n                         w = w' @ [LRet] \\<and>\n                         ((s, c), w', [return fg p], c')\n                         \\<in> trcl (trss fg)", "with SPLIT(1) WD"], ["proof (chain)\npicking this:\n  ((s, c), w', sh, ch) \\<in> trcl (trss fg)\n  w = w' @ [e]\n  e = LRet\n  sh = [return fg p]\n  ch = c'", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, c), w', sh, ch) \\<in> trcl (trss fg)\n  w = w' @ [e]\n  e = LRet\n  sh = [return fg p]\n  ch = c'\n\ngoal (1 subgoal):\n 1. \\<exists>w' p.\n       w = w' @ [LRet] \\<and>\n       ((s, c), w', [return fg p], c') \\<in> trcl (trss fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>w' p.\n     w = w' @ [LRet] \\<and>\n     ((s, c), w', [return fg p], c') \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trss_2return_to_2empty: \"\\<lbrakk> ((s,c),w,([return fg p],c'))\\<in>trcl (trss fg) \\<rbrakk> \n  \\<Longrightarrow> ((s,c),w@[LRet],([],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, [return fg p], c') \\<in> trcl (trss fg) \\<Longrightarrow>\n    ((s, c), w @ [LRet], [], c') \\<in> trcl (trss fg)", "apply (subgoal_tac \"(([return fg p],c'),LRet,([],c'))\\<in>trss fg\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((s, c), w, [return fg p], c') \\<in> trcl (trss fg);\n     (([return fg p], c'), LRet, [], c') \\<in> trss fg\\<rbrakk>\n    \\<Longrightarrow> ((s, c), w @ [LRet], [], c') \\<in> trcl (trss fg)\n 2. ((s, c), w, [return fg p], c') \\<in> trcl (trss fg) \\<Longrightarrow>\n    (([return fg p], c'), LRet, [], c') \\<in> trss fg", "by (auto dest: trcl_rev_cons intro: trss.intros)"], ["", "subsubsection \"Adding threads\""], ["", "lemma trss_env_increasing_s: \"((s,c),e,(s',c'))\\<in>trss fg \\<Longrightarrow> c\\<subseteq>#c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> trss fg \\<Longrightarrow> c \\<subseteq># c'", "by (auto elim!: trss.cases)"], ["", "lemma trss_env_increasing: \"((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<Longrightarrow> c\\<subseteq>#c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (trss fg) \\<Longrightarrow>\n    c \\<subseteq># c'", "by (induct rule: trcl_pair_induct) (auto dest: trss_env_increasing_s order_trans)"], ["", "subsubsection \"Conversion between environment and monitor restrictions\""], ["", "lemma trss_mon_e_no_ctx: \n  \"((s,c),e,(s',c'))\\<in>trss fg \\<Longrightarrow> mon_e fg e \\<inter> mon_c fg c = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> trss fg \\<Longrightarrow>\n    mon_e fg e \\<inter> mon_c fg c = {}", "by (erule trss.cases) auto"], ["", "lemma (in flowgraph) trss_mon_w_no_ctx: \n  \"((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<Longrightarrow> mon_w fg w \\<inter> mon_c fg c = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (trss fg) \\<Longrightarrow>\n    mon_w fg w \\<inter> mon_c fg c = {}", "by (induct rule: trcl_pair_induct) (auto dest: trss_mon_e_no_ctx simp add: trss_c_no_mon_s)"], ["", "lemma (in flowgraph) trss_modify_context_s: \n  \"!!cn. \\<lbrakk>((s,c),e,(s',c'))\\<in>trss fg; mon_e fg e \\<inter> mon_c fg cn = {}\\<rbrakk> \n    \\<Longrightarrow> \\<exists>csp. c'=csp+c \\<and> mon_c fg csp = {} \\<and> ((s,cn),e,(s',csp+cn))\\<in>trss fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cn.\n       \\<lbrakk>((s, c), e, s', c') \\<in> trss fg;\n        mon_e fg e \\<inter> mon_c fg cn = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            mon_c fg csp = {} \\<and>\n                            ((s, cn), e, s', csp + cn) \\<in> trss fg", "by (erule trss.cases) (auto intro!: trss.intros)"], ["", "lemma (in flowgraph) trss_modify_context[rule_format]: \n  \"\\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (trss fg)\\<rbrakk> \n  \\<Longrightarrow> \\<forall>cn. mon_w fg w \\<inter> mon_c fg cn = {} \n      \\<longrightarrow> (\\<exists>csp. c'=csp+c \\<and> mon_c fg csp = {} \\<and> \n                 ((s,cn),w,(s',csp+cn))\\<in>trcl (trss fg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (trss fg) \\<Longrightarrow>\n    \\<forall>cn.\n       mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n       (\\<exists>csp.\n           c' = csp + c \\<and>\n           mon_c fg csp = {} \\<and>\n           ((s, cn), w, s', csp + cn) \\<in> trcl (trss fg))", "proof (induct rule: trcl_pair_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<forall>cn.\n          mon_w fg [] \\<inter> mon_c fg cn = {} \\<longrightarrow>\n          (\\<exists>csp.\n              b = csp + b \\<and>\n              mon_c fg csp = {} \\<and>\n              ((a, cn), [], a, csp + cn) \\<in> trcl (trss fg))\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        \\<forall>cn.\n           mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (trss fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_w fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (trss fg))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<forall>cn.\n          mon_w fg [] \\<inter> mon_c fg cn = {} \\<longrightarrow>\n          (\\<exists>csp.\n              b = csp + b \\<and>\n              mon_c fg csp = {} \\<and>\n              ((a, cn), [], a, csp + cn) \\<in> trcl (trss fg))\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        \\<forall>cn.\n           mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (trss fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_w fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (trss fg))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cn.\n       mon_w fg [] \\<inter> mon_c fg cn = {} \\<longrightarrow>\n       (\\<exists>csp.\n           b_ = csp + b_ \\<and>\n           mon_c fg csp = {} \\<and>\n           ((a_, cn), [], a_, csp + cn) \\<in> trcl (trss fg))", "by simp"], ["proof (state)\nthis:\n  \\<forall>cn.\n     mon_w fg [] \\<inter> mon_c fg cn = {} \\<longrightarrow>\n     (\\<exists>csp.\n         b_ = csp + b_ \\<and>\n         mon_c fg csp = {} \\<and>\n         ((a_, cn), [], a_, csp + cn) \\<in> trcl (trss fg))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        \\<forall>cn.\n           mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (trss fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_w fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (trss fg))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        \\<forall>cn.\n           mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (trss fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_w fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (trss fg))", "case (cons s c e sh ch w s' c')"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)\n  \\<forall>cn.\n     mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n     (\\<exists>csp.\n         c' = csp + ch \\<and>\n         mon_c fg csp = {} \\<and>\n         ((sh, cn), w, s', csp + cn) \\<in> trcl (trss fg))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        \\<forall>cn.\n           mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (trss fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_w fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (trss fg))", "note IHP=this"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)\n  \\<forall>cn.\n     mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n     (\\<exists>csp.\n         c' = csp + ch \\<and>\n         mon_c fg csp = {} \\<and>\n         ((sh, cn), w, s', csp + cn) \\<in> trcl (trss fg))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        \\<forall>cn.\n           mon_w fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (trss fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_w fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (trss fg))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cn.\n       mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<longrightarrow>\n       (\\<exists>csp.\n           c' = csp + c \\<and>\n           mon_c fg csp = {} \\<and>\n           ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg))", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)", "fix cn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)", "assume MON: \"mon_w fg (e # w) \\<inter> mon_c fg cn = {}\""], ["proof (state)\nthis:\n  mon_w fg (e # w) \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)", "from trss_modify_context_s[OF IHP(1)] MON"], ["proof (chain)\npicking this:\n  mon_e fg e \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     ch = csp + c \\<and>\n     mon_c fg csp = {} \\<and> ((s, ?cn), e, sh, csp + ?cn) \\<in> trss fg\n  mon_w fg (e # w) \\<inter> mon_c fg cn = {}", "obtain csph where S1: \"ch = csph + c\" \"mon_c fg csph={}\" \"((s, cn), e, sh, csph + cn) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  mon_e fg e \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     ch = csp + c \\<and>\n     mon_c fg csp = {} \\<and> ((s, ?cn), e, sh, csp + ?cn) \\<in> trss fg\n  mon_w fg (e # w) \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. (\\<And>csph.\n        \\<lbrakk>ch = csph + c; mon_c fg csph = {};\n         ((s, cn), e, sh, csph + cn) \\<in> trss fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)", "with MON"], ["proof (chain)\npicking this:\n  mon_w fg (e # w) \\<inter> mon_c fg cn = {}\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> trss fg", "have \"mon_w fg w \\<inter> mon_c fg (csph+cn) = {}\""], ["proof (prove)\nusing this:\n  mon_w fg (e # w) \\<inter> mon_c fg cn = {}\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. mon_w fg w \\<inter> mon_c fg (csph + cn) = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_w fg w \\<inter> mon_c fg (csph + cn) = {}\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)", "with IHP(3)[rule_format]"], ["proof (chain)\npicking this:\n  mon_w fg w \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c' = csp + ch \\<and>\n     mon_c fg csp = {} \\<and>\n     ((sh, ?cn), w, s', csp + ?cn) \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg (csph + cn) = {}", "obtain csp where S2: \"c'=csp+ch\" \"mon_c fg csp={}\" \"((sh,csph+cn),w,(s',csp+(csph+cn)))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  mon_w fg w \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c' = csp + ch \\<and>\n     mon_c fg csp = {} \\<and>\n     ((sh, ?cn), w, s', csp + ?cn) \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg (csph + cn) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        \\<lbrakk>c' = csp + ch; mon_c fg csp = {};\n         ((sh, csph + cn), w, s', csp + (csph + cn))\n         \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c' = csp + ch\n  mon_c fg csp = {}\n  ((sh, csph + cn), w, s', csp + (csph + cn)) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)", "from S1 S2"], ["proof (chain)\npicking this:\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> trss fg\n  c' = csp + ch\n  mon_c fg csp = {}\n  ((sh, csph + cn), w, s', csp + (csph + cn)) \\<in> trcl (trss fg)", "have \"c'=(csp+csph)+c\" \"mon_c fg (csp+csph)={}\" \"((s,cn),e#w,(s',(csp+csph)+cn))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> trss fg\n  c' = csp + ch\n  mon_c fg csp = {}\n  ((sh, csph + cn), w, s', csp + (csph + cn)) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. c' = csp + csph + c &&&\n    mon_c fg (csp + csph) = {} &&&\n    ((s, cn), e # w, s', csp + csph + cn) \\<in> trcl (trss fg)", "by (auto simp add: union_assoc mon_c_unconc)"], ["proof (state)\nthis:\n  c' = csp + csph + c\n  mon_c fg (csp + csph) = {}\n  ((s, cn), e # w, s', csp + csph + cn) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)", "thus \"\\<exists>csp. c' = csp + c \\<and> mon_c fg csp = {} \\<and> ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  c' = csp + csph + c\n  mon_c fg (csp + csph) = {}\n  ((s, cn), e # w, s', csp + csph + cn) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and>\n       ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>csp.\n     c' = csp + c \\<and>\n     mon_c fg csp = {} \\<and>\n     ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>cn.\n     mon_w fg (e # w) \\<inter> mon_c fg cn = {} \\<longrightarrow>\n     (\\<exists>csp.\n         c' = csp + c \\<and>\n         mon_c fg csp = {} \\<and>\n         ((s, cn), e # w, s', csp + cn) \\<in> trcl (trss fg))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trss_add_context_s: \n  \"\\<lbrakk>((s,c),e,(s',c'))\\<in>trss fg; mon_e fg e \\<inter> mon_c fg ce = {}\\<rbrakk> \n    \\<Longrightarrow> ((s,c+ce),e,(s',c'+ce))\\<in>trss fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), e, s', c') \\<in> trss fg;\n     mon_e fg e \\<inter> mon_c fg ce = {}\\<rbrakk>\n    \\<Longrightarrow> ((s, c + ce), e, s', c' + ce) \\<in> trss fg", "by (auto elim!: trss.cases intro!: trss.intros simp add: union_assoc mon_c_unconc)"], ["", "lemma trss_add_context: \n  \"\\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (trss fg); mon_w fg w \\<inter> mon_c fg ce = {}\\<rbrakk> \n    \\<Longrightarrow> ((s,c+ce),w,(s',c'+ce))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl (trss fg);\n     mon_w fg w \\<inter> mon_c fg ce = {}\\<rbrakk>\n    \\<Longrightarrow> ((s, c + ce), w, s', c' + ce) \\<in> trcl (trss fg)", "proof (induct rule: trcl_pair_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       mon_w fg [] \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n       ((a, b + ce), [], a, b + ce) \\<in> trcl (trss fg)\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        ((ab, ba + ce), w, ac, bb + ce) \\<in> trcl (trss fg);\n        mon_w fg (aa # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> ((a, b + ce), aa # w, ac, bb + ce)\n                         \\<in> trcl (trss fg)", "case empty"], ["proof (state)\nthis:\n  mon_w fg [] \\<inter> mon_c fg ce = {}\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       mon_w fg [] \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n       ((a, b + ce), [], a, b + ce) \\<in> trcl (trss fg)\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        ((ab, ba + ce), w, ac, bb + ce) \\<in> trcl (trss fg);\n        mon_w fg (aa # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> ((a, b + ce), aa # w, ac, bb + ce)\n                         \\<in> trcl (trss fg)", "thus ?case"], ["proof (prove)\nusing this:\n  mon_w fg [] \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. ((a_, b_ + ce), [], a_, b_ + ce) \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  ((a_, b_ + ce), [], a_, b_ + ce) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        ((ab, ba + ce), w, ac, bb + ce) \\<in> trcl (trss fg);\n        mon_w fg (aa # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> ((a, b + ce), aa # w, ac, bb + ce)\n                         \\<in> trcl (trss fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        ((ab, ba + ce), w, ac, bb + ce) \\<in> trcl (trss fg);\n        mon_w fg (aa # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> ((a, b + ce), aa # w, ac, bb + ce)\n                         \\<in> trcl (trss fg)", "case (cons s c e sh ch w s' c')"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n  ((sh, ch + ce), w, s', c' + ce) \\<in> trcl (trss fg)\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        ((ab, ba + ce), w, ac, bb + ce) \\<in> trcl (trss fg);\n        mon_w fg (aa # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> ((a, b + ce), aa # w, ac, bb + ce)\n                         \\<in> trcl (trss fg)", "note IHP=this"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, s', c') \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n  ((sh, ch + ce), w, s', c' + ce) \\<in> trcl (trss fg)\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        ((ab, ba + ce), w, ac, bb + ce) \\<in> trcl (trss fg);\n        mon_w fg (aa # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> ((a, b + ce), aa # w, ac, bb + ce)\n                         \\<in> trcl (trss fg)", "from IHP(4)"], ["proof (chain)\npicking this:\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}", "have MM: \"mon_e fg e \\<inter> mon_c fg ce = {}\" \"mon_w fg w \\<inter> mon_c fg ce = {}\""], ["proof (prove)\nusing this:\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. mon_e fg e \\<inter> mon_c fg ce = {} &&&\n    mon_w fg w \\<inter> mon_c fg ce = {}", "by auto"], ["proof (state)\nthis:\n  mon_e fg e \\<inter> mon_c fg ce = {}\n  mon_w fg w \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> trss fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (trss fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        ((ab, ba + ce), w, ac, bb + ce) \\<in> trcl (trss fg);\n        mon_w fg (aa # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> ((a, b + ce), aa # w, ac, bb + ce)\n                         \\<in> trcl (trss fg)", "from trcl.cons[OF trss_add_context_s[OF IHP(1) MM(1)] IHP(3)[OF MM(2)]]"], ["proof (chain)\npicking this:\n  ((s, c + ce), e # w, s', c' + ce) \\<in> trcl (trss fg)", "show ?case"], ["proof (prove)\nusing this:\n  ((s, c + ce), e # w, s', c' + ce) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((s, c + ce), e # w, s', c' + ce) \\<in> trcl (trss fg)", "."], ["proof (state)\nthis:\n  ((s, c + ce), e # w, s', c' + ce) \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trss_drop_context_s: \"\\<lbrakk> ((s,c+ce),e,(s',c'+ce))\\<in>trss fg \\<rbrakk> \n  \\<Longrightarrow> ((s,c),e,(s',c'))\\<in>trss fg \\<and> mon_e fg e \\<inter> mon_c fg ce = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c + ce), e, s', c' + ce) \\<in> trss fg \\<Longrightarrow>\n    ((s, c), e, s', c') \\<in> trss fg \\<and>\n    mon_e fg e \\<inter> mon_c fg ce = {}", "by (erule trss.cases) (auto intro!: trss.intros simp add: mon_c_unconc union_assoc[of _ c ce, symmetric])"], ["", "lemma trss_drop_context: \"!!s c. \\<lbrakk> ((s,c+ce),w,(s',c'+ce))\\<in>trcl (trss fg) \\<rbrakk> \n  \\<Longrightarrow> ((s,c),w,(s',c'))\\<in>trcl (trss fg) \\<and> mon_w fg w \\<inter> mon_c fg ce = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c.\n       ((s, c + ce), w, s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n       ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n       mon_w fg w \\<inter> mon_c fg ce = {}", "proof (induct w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s c.\n       ((s, c + ce), [], s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n       ((s, c), [], s', c') \\<in> trcl (trss fg) \\<and>\n       mon_w fg [] \\<inter> mon_c fg ce = {}\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "case Nil"], ["proof (state)\nthis:\n  ((s, c + ce), [], s', c' + ce) \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>s c.\n       ((s, c + ce), [], s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n       ((s, c), [], s', c') \\<in> trcl (trss fg) \\<and>\n       mon_w fg [] \\<inter> mon_c fg ce = {}\n 2. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "thus ?case"], ["proof (prove)\nusing this:\n  ((s, c + ce), [], s', c' + ce) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((s, c), [], s', c') \\<in> trcl (trss fg) \\<and>\n    mon_w fg [] \\<inter> mon_c fg ce = {}", "by auto"], ["proof (state)\nthis:\n  ((s, c), [], s', c') \\<in> trcl (trss fg) \\<and>\n  mon_w fg [] \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "case (Cons e w)"], ["proof (state)\nthis:\n  ((?s, ?c + ce), w, s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n  ((?s, ?c), w, s', c') \\<in> trcl (trss fg) \\<and>\n  mon_w fg w \\<inter> mon_c fg ce = {}\n  ((s, c + ce), e # w, s', c' + ce) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "note IHP=this"], ["proof (state)\nthis:\n  ((?s, ?c + ce), w, s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n  ((?s, ?c), w, s', c') \\<in> trcl (trss fg) \\<and>\n  mon_w fg w \\<inter> mon_c fg ce = {}\n  ((s, c + ce), e # w, s', c' + ce) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "then"], ["proof (chain)\npicking this:\n  ((?s, ?c + ce), w, s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n  ((?s, ?c), w, s', c') \\<in> trcl (trss fg) \\<and>\n  mon_w fg w \\<inter> mon_c fg ce = {}\n  ((s, c + ce), e # w, s', c' + ce) \\<in> trcl (trss fg)", "obtain sh ch where SPLIT: \"((s,c+ce),e,(sh,ch))\\<in>trss fg\" \"((sh,ch),w,(s',c'+ce))\\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((?s, ?c + ce), w, s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n  ((?s, ?c), w, s', c') \\<in> trcl (trss fg) \\<and>\n  mon_w fg w \\<inter> mon_c fg ce = {}\n  ((s, c + ce), e # w, s', c' + ce) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>((s, c + ce), e, sh, ch) \\<in> trss fg;\n         ((sh, ch), w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  ((s, c + ce), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, s', c' + ce) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "from trss_c_fmt_s[OF SPLIT(1)]"], ["proof (chain)\npicking this:\n  \\<exists>csp.\n     ch = csp + (c + ce) \\<and>\n     (csp = {#} \\<or>\n      (\\<exists>p. e = LSpawn p \\<and> csp = {#[entry fg p]#}))", "obtain csp where CHFMT: \"ch = (csp + c) + ce\""], ["proof (prove)\nusing this:\n  \\<exists>csp.\n     ch = csp + (c + ce) \\<and>\n     (csp = {#} \\<or>\n      (\\<exists>p. e = LSpawn p \\<and> csp = {#[entry fg p]#}))\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        ch = csp + c + ce \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: union_assoc)"], ["proof (state)\nthis:\n  ch = csp + c + ce\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "from CHFMT trss_drop_context_s SPLIT(1)"], ["proof (chain)\npicking this:\n  ch = csp + c + ce\n  ((?s, ?c + ?ce), ?e, ?s', ?c' + ?ce) \\<in> trss ?fg \\<Longrightarrow>\n  ((?s, ?c), ?e, ?s', ?c') \\<in> trss ?fg \\<and>\n  mon_e ?fg ?e \\<inter> mon_c ?fg ?ce = {}\n  ((s, c + ce), e, sh, ch) \\<in> trss fg", "have \"((s,c),e,(sh,csp+c))\\<in>trss fg\" \"mon_e fg e \\<inter> mon_c fg ce = {}\""], ["proof (prove)\nusing this:\n  ch = csp + c + ce\n  ((?s, ?c + ?ce), ?e, ?s', ?c' + ?ce) \\<in> trss ?fg \\<Longrightarrow>\n  ((?s, ?c), ?e, ?s', ?c') \\<in> trss ?fg \\<and>\n  mon_e ?fg ?e \\<inter> mon_c ?fg ?ce = {}\n  ((s, c + ce), e, sh, ch) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ((s, c), e, sh, csp + c) \\<in> trss fg &&&\n    mon_e fg e \\<inter> mon_c fg ce = {}", "by blast+"], ["proof (state)\nthis:\n  ((s, c), e, sh, csp + c) \\<in> trss fg\n  mon_e fg e \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "moreover"], ["proof (state)\nthis:\n  ((s, c), e, sh, csp + c) \\<in> trss fg\n  mon_e fg e \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "from CHFMT IHP(1) SPLIT(2)"], ["proof (chain)\npicking this:\n  ch = csp + c + ce\n  ((?s, ?c + ce), w, s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n  ((?s, ?c), w, s', c') \\<in> trcl (trss fg) \\<and>\n  mon_w fg w \\<inter> mon_c fg ce = {}\n  ((sh, ch), w, s', c' + ce) \\<in> trcl (trss fg)", "have \"((sh,csp+c),w,(s',c'))\\<in>trcl (trss fg)\" \"mon_w fg w \\<inter> mon_c fg ce = {}\""], ["proof (prove)\nusing this:\n  ch = csp + c + ce\n  ((?s, ?c + ce), w, s', c' + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n  ((?s, ?c), w, s', c') \\<in> trcl (trss fg) \\<and>\n  mon_w fg w \\<inter> mon_c fg ce = {}\n  ((sh, ch), w, s', c' + ce) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((sh, csp + c), w, s', c') \\<in> trcl (trss fg) &&&\n    mon_w fg w \\<inter> mon_c fg ce = {}", "by blast+"], ["proof (state)\nthis:\n  ((sh, csp + c), w, s', c') \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>a w s c.\n       \\<lbrakk>\\<And>s c.\n                   ((s, c + ce), w, s', c' + ce)\n                   \\<in> trcl (trss fg) \\<Longrightarrow>\n                   ((s, c), w, s', c') \\<in> trcl (trss fg) \\<and>\n                   mon_w fg w \\<inter> mon_c fg ce = {};\n        ((s, c + ce), a # w, s', c' + ce) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((s, c), a # w, s', c') \\<in> trcl (trss fg) \\<and>\n                         mon_w fg (a # w) \\<inter> mon_c fg ce = {}", "ultimately"], ["proof (chain)\npicking this:\n  ((s, c), e, sh, csp + c) \\<in> trss fg\n  mon_e fg e \\<inter> mon_c fg ce = {}\n  ((sh, csp + c), w, s', c') \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg ce = {}", "show ?case"], ["proof (prove)\nusing this:\n  ((s, c), e, sh, csp + c) \\<in> trss fg\n  mon_e fg e \\<inter> mon_c fg ce = {}\n  ((sh, csp + c), w, s', c') \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. ((s, c), e # w, s', c') \\<in> trcl (trss fg) \\<and>\n    mon_w fg (e # w) \\<inter> mon_c fg ce = {}", "by auto"], ["proof (state)\nthis:\n  ((s, c), e # w, s', c') \\<in> trcl (trss fg) \\<and>\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trss_xchange_context_s: \n  assumes A: \"((s,c),e,(s',csp+c))\\<in>trss fg\" \n  and M:\"mon_c fg cn \\<subseteq> mon_c fg c\" \n  shows \"((s,cn),e,(s',csp+cn))\\<in>trss fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, cn), e, s', csp + cn) \\<in> trss fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, cn), e, s', csp + cn) \\<in> trss fg", "from trss_drop_context_s[of _ \"{#}\", simplified, OF A]"], ["proof (chain)\npicking this:\n  ((s, {#}), e, s', csp) \\<in> trss fg \\<and>\n  mon_e fg e \\<inter> mon_c fg c = {}", "have DC: \"((s, {#}), e, s', csp) \\<in> trss fg\" \"mon_e fg e \\<inter> mon_c fg c = {}\""], ["proof (prove)\nusing this:\n  ((s, {#}), e, s', csp) \\<in> trss fg \\<and>\n  mon_e fg e \\<inter> mon_c fg c = {}\n\ngoal (1 subgoal):\n 1. ((s, {#}), e, s', csp) \\<in> trss fg &&&\n    mon_e fg e \\<inter> mon_c fg c = {}", "by simp_all"], ["proof (state)\nthis:\n  ((s, {#}), e, s', csp) \\<in> trss fg\n  mon_e fg e \\<inter> mon_c fg c = {}\n\ngoal (1 subgoal):\n 1. ((s, cn), e, s', csp + cn) \\<in> trss fg", "with M"], ["proof (chain)\npicking this:\n  mon_c fg cn \\<subseteq> mon_c fg c\n  ((s, {#}), e, s', csp) \\<in> trss fg\n  mon_e fg e \\<inter> mon_c fg c = {}", "have \"mon_e fg e \\<inter> mon_c fg cn = {}\""], ["proof (prove)\nusing this:\n  mon_c fg cn \\<subseteq> mon_c fg c\n  ((s, {#}), e, s', csp) \\<in> trss fg\n  mon_e fg e \\<inter> mon_c fg c = {}\n\ngoal (1 subgoal):\n 1. mon_e fg e \\<inter> mon_c fg cn = {}", "by auto"], ["proof (state)\nthis:\n  mon_e fg e \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. ((s, cn), e, s', csp + cn) \\<in> trss fg", "from trss_add_context_s[OF DC(1) this]"], ["proof (chain)\npicking this:\n  ((s, {#} + cn), e, s', csp + cn) \\<in> trss fg", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, {#} + cn), e, s', csp + cn) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ((s, cn), e, s', csp + cn) \\<in> trss fg", "by auto"], ["proof (state)\nthis:\n  ((s, cn), e, s', csp + cn) \\<in> trss fg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trss_xchange_context: \n  assumes A: \"((s,c),w,(s',csp+c))\\<in>trcl (trss fg)\" \n  and M:\"mon_c fg cn \\<subseteq> mon_c fg c\" \n  shows \"((s,cn),w,(s',csp+cn))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, cn), w, s', csp + cn) \\<in> trcl (trss fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, cn), w, s', csp + cn) \\<in> trcl (trss fg)", "from trss_drop_context[of _ \"{#}\", simplified, OF A]"], ["proof (chain)\npicking this:\n  ((s, {#}), w, s', csp) \\<in> trcl (trss fg) \\<and>\n  mon_w fg w \\<inter> mon_c fg c = {}", "have DC: \"((s, {#}), w, s', csp) \\<in> trcl (trss fg)\" \"mon_w fg w \\<inter> mon_c fg c = {}\""], ["proof (prove)\nusing this:\n  ((s, {#}), w, s', csp) \\<in> trcl (trss fg) \\<and>\n  mon_w fg w \\<inter> mon_c fg c = {}\n\ngoal (1 subgoal):\n 1. ((s, {#}), w, s', csp) \\<in> trcl (trss fg) &&&\n    mon_w fg w \\<inter> mon_c fg c = {}", "by simp_all"], ["proof (state)\nthis:\n  ((s, {#}), w, s', csp) \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg c = {}\n\ngoal (1 subgoal):\n 1. ((s, cn), w, s', csp + cn) \\<in> trcl (trss fg)", "with M"], ["proof (chain)\npicking this:\n  mon_c fg cn \\<subseteq> mon_c fg c\n  ((s, {#}), w, s', csp) \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg c = {}", "have \"mon_w fg w \\<inter> mon_c fg cn = {}\""], ["proof (prove)\nusing this:\n  mon_c fg cn \\<subseteq> mon_c fg c\n  ((s, {#}), w, s', csp) \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg c = {}\n\ngoal (1 subgoal):\n 1. mon_w fg w \\<inter> mon_c fg cn = {}", "by auto"], ["proof (state)\nthis:\n  mon_w fg w \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. ((s, cn), w, s', csp + cn) \\<in> trcl (trss fg)", "from trss_add_context[OF DC(1) this]"], ["proof (chain)\npicking this:\n  ((s, {#} + cn), w, s', csp + cn) \\<in> trcl (trss fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, {#} + cn), w, s', csp + cn) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((s, cn), w, s', csp + cn) \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  ((s, cn), w, s', csp + cn) \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trss_drop_all_context_s[cases set, case_names dropped]: \n  assumes A: \"((s,c),e,(s',c'))\\<in>trss fg\" \n  and C: \"!!csp. \\<lbrakk> c'=csp+c; ((s,{#}),e,(s',csp))\\<in>trss fg \\<rbrakk> \\<Longrightarrow> P\" \n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A"], ["proof (prove)\nusing this:\n  ((s, c), e, s', c') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: trss_c_cases_s)"], ["proof (state)\ngoal (2 subgoals):\n 1. c' = c \\<Longrightarrow> P\n 2. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "case no_spawn"], ["proof (state)\nthis:\n  c' = c\n\ngoal (2 subgoals):\n 1. c' = c \\<Longrightarrow> P\n 2. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "with trss_xchange_context_s[of s c e s' \"{#}\" fg \"{#}\"] A C"], ["proof (chain)\npicking this:\n  \\<lbrakk>((s, c), e, s', {#} + c) \\<in> trss fg;\n   mon_c fg {#} \\<subseteq> mon_c fg c\\<rbrakk>\n  \\<Longrightarrow> ((s, {#}), e, s', {#} + {#}) \\<in> trss fg\n  ((s, c), e, s', c') \\<in> trss fg\n  \\<lbrakk>c' = ?csp + c; ((s, {#}), e, s', ?csp) \\<in> trss fg\\<rbrakk>\n  \\<Longrightarrow> P\n  c' = c", "show P"], ["proof (prove)\nusing this:\n  \\<lbrakk>((s, c), e, s', {#} + c) \\<in> trss fg;\n   mon_c fg {#} \\<subseteq> mon_c fg c\\<rbrakk>\n  \\<Longrightarrow> ((s, {#}), e, s', {#} + {#}) \\<in> trss fg\n  ((s, c), e, s', c') \\<in> trss fg\n  \\<lbrakk>c' = ?csp + c; ((s, {#}), e, s', ?csp) \\<in> trss fg\\<rbrakk>\n  \\<Longrightarrow> P\n  c' = c\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "case (spawn p u v)"], ["proof (state)\nthis:\n  e = LSpawn p\n  (u, Spawn p, v) \\<in> edges fg\n  hd s = u\n  hd s' = v\n  c' = {#[entry fg p]#} + c\n\ngoal (1 subgoal):\n 1. \\<And>p u v.\n       \\<lbrakk>e = LSpawn p; (u, Spawn p, v) \\<in> edges fg; hd s = u;\n        hd s' = v; c' = {#[entry fg p]#} + c\\<rbrakk>\n       \\<Longrightarrow> P", "with trss_xchange_context_s[of s c e s' \"{#[entry fg p]#}\" fg \"{#}\"] A C"], ["proof (chain)\npicking this:\n  \\<lbrakk>((s, c), e, s', {#[entry fg p]#} + c) \\<in> trss fg;\n   mon_c fg {#} \\<subseteq> mon_c fg c\\<rbrakk>\n  \\<Longrightarrow> ((s, {#}), e, s', {#[entry fg p]#} + {#}) \\<in> trss fg\n  ((s, c), e, s', c') \\<in> trss fg\n  \\<lbrakk>c' = ?csp + c; ((s, {#}), e, s', ?csp) \\<in> trss fg\\<rbrakk>\n  \\<Longrightarrow> P\n  e = LSpawn p\n  (u, Spawn p, v) \\<in> edges fg\n  hd s = u\n  hd s' = v\n  c' = {#[entry fg p]#} + c", "show P"], ["proof (prove)\nusing this:\n  \\<lbrakk>((s, c), e, s', {#[entry fg p]#} + c) \\<in> trss fg;\n   mon_c fg {#} \\<subseteq> mon_c fg c\\<rbrakk>\n  \\<Longrightarrow> ((s, {#}), e, s', {#[entry fg p]#} + {#}) \\<in> trss fg\n  ((s, c), e, s', c') \\<in> trss fg\n  \\<lbrakk>c' = ?csp + c; ((s, {#}), e, s', ?csp) \\<in> trss fg\\<rbrakk>\n  \\<Longrightarrow> P\n  e = LSpawn p\n  (u, Spawn p, v) \\<in> edges fg\n  hd s = u\n  hd s' = v\n  c' = {#[entry fg p]#} + c\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trss_drop_all_context[cases set, case_names dropped]: \n  assumes A: \"((s,c),w,(s',c'))\\<in>trcl (trss fg)\" \n  and C: \"!!csp. \\<lbrakk> c'=csp+c; ((s,{#}),w,(s',csp))\\<in>trcl (trss fg)\\<rbrakk> \\<Longrightarrow> P\" \n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A"], ["proof (prove)\nusing this:\n  ((s, c), w, s', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: trss_c_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>csp.\n       \\<lbrakk>c' = csp + c;\n        \\<And>s.\n           s \\<in># csp \\<Longrightarrow>\n           \\<exists>p u v.\n              s = [entry fg p] \\<and>\n              (u, Spawn p, v) \\<in> edges fg \\<and>\n              initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> P", "case (c_case csp)"], ["proof (state)\nthis:\n  c' = csp + c\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>csp.\n       \\<lbrakk>c' = csp + c;\n        \\<And>s.\n           s \\<in># csp \\<Longrightarrow>\n           \\<exists>p u v.\n              s = [entry fg p] \\<and>\n              (u, Spawn p, v) \\<in> edges fg \\<and>\n              initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> P", "with trss_xchange_context[of s c w s' csp fg \"{#}\"] A C"], ["proof (chain)\npicking this:\n  \\<lbrakk>((s, c), w, s', csp + c) \\<in> trcl (trss fg);\n   mon_c fg {#} \\<subseteq> mon_c fg c\\<rbrakk>\n  \\<Longrightarrow> ((s, {#}), w, s', csp + {#}) \\<in> trcl (trss fg)\n  ((s, c), w, s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   ((s, {#}), w, s', ?csp) \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  c' = csp + c\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "show P"], ["proof (prove)\nusing this:\n  \\<lbrakk>((s, c), w, s', csp + c) \\<in> trcl (trss fg);\n   mon_c fg {#} \\<subseteq> mon_c fg c\\<rbrakk>\n  \\<Longrightarrow> ((s, {#}), w, s', csp + {#}) \\<in> trcl (trss fg)\n  ((s, c), w, s', c') \\<in> trcl (trss fg)\n  \\<lbrakk>c' = ?csp + c;\n   ((s, {#}), w, s', ?csp) \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> P\n  c' = csp + c\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tr_add_context_s: \n  \"\\<lbrakk> (c,e,c')\\<in>tr fg; mon_e fg e \\<inter> mon_c fg ce = {} \\<rbrakk> \\<Longrightarrow> (c+ce,e,c'+ce)\\<in>tr fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, e, c') \\<in> tr fg;\n     mon_e fg e \\<inter> mon_c fg ce = {}\\<rbrakk>\n    \\<Longrightarrow> (c + ce, e, c' + ce) \\<in> tr fg", "by (erule gtrE) (auto simp add: mon_c_unconc union_assoc intro: gtrI_s dest: trss_add_context_s)"], ["", "lemma tr_add_context: \n  \"\\<lbrakk> (c,w,c')\\<in>trcl (tr fg); mon_w fg w \\<inter> mon_c fg ce = {} \\<rbrakk> \n    \\<Longrightarrow> (c+ce,w,c'+ce)\\<in>trcl (tr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, w, c') \\<in> trcl (tr fg);\n     mon_w fg w \\<inter> mon_c fg ce = {}\\<rbrakk>\n    \\<Longrightarrow> (c + ce, w, c' + ce) \\<in> trcl (tr fg)", "proof (induct rule: trcl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       mon_w fg [] \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n       (c + ce, [], c + ce) \\<in> trcl (tr fg)\n 2. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "case empty"], ["proof (state)\nthis:\n  mon_w fg [] \\<inter> mon_c fg ce = {}\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       mon_w fg [] \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n       (c + ce, [], c + ce) \\<in> trcl (tr fg)\n 2. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "thus ?case"], ["proof (prove)\nusing this:\n  mon_w fg [] \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. (c_ + ce, [], c_ + ce) \\<in> trcl (tr fg)", "by auto"], ["proof (state)\nthis:\n  (c_ + ce, [], c_ + ce) \\<in> trcl (tr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "case (cons c e c' w c'')"], ["proof (state)\nthis:\n  (c, e, c') \\<in> tr fg\n  (c', w, c'') \\<in> trcl (tr fg)\n  mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n  (c' + ce, w, c'' + ce) \\<in> trcl (tr fg)\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "note IHP=this"], ["proof (state)\nthis:\n  (c, e, c') \\<in> tr fg\n  (c', w, c'') \\<in> trcl (tr fg)\n  mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n  (c' + ce, w, c'' + ce) \\<in> trcl (tr fg)\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "from tr_add_context_s[OF IHP(1), of ce] IHP(4)"], ["proof (chain)\npicking this:\n  mon_e fg e \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n  (c + ce, e, c' + ce) \\<in> tr fg\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}", "have \"(c + ce, e, c' + ce) \\<in> tr fg\""], ["proof (prove)\nusing this:\n  mon_e fg e \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n  (c + ce, e, c' + ce) \\<in> tr fg\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. (c + ce, e, c' + ce) \\<in> tr fg", "by auto"], ["proof (state)\nthis:\n  (c + ce, e, c' + ce) \\<in> tr fg\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "also"], ["proof (state)\nthis:\n  (c + ce, e, c' + ce) \\<in> tr fg\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "from IHP(3,4)"], ["proof (chain)\npicking this:\n  mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n  (c' + ce, w, c'' + ce) \\<in> trcl (tr fg)\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}", "have \"(c' + ce, w, c'' + ce) \\<in> trcl (tr fg)\""], ["proof (prove)\nusing this:\n  mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n  (c' + ce, w, c'' + ce) \\<in> trcl (tr fg)\n  mon_w fg (e # w) \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. (c' + ce, w, c'' + ce) \\<in> trcl (tr fg)", "by auto"], ["proof (state)\nthis:\n  (c' + ce, w, c'' + ce) \\<in> trcl (tr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> tr fg; (c', w, c'') \\<in> trcl (tr fg);\n        mon_w fg w \\<inter> mon_c fg ce = {} \\<Longrightarrow>\n        (c' + ce, w, c'' + ce) \\<in> trcl (tr fg);\n        mon_w fg (a # w) \\<inter> mon_c fg ce = {}\\<rbrakk>\n       \\<Longrightarrow> (c + ce, a # w, c'' + ce) \\<in> trcl (tr fg)", "finally"], ["proof (chain)\npicking this:\n  (c + ce, e # w, c'' + ce) \\<in> trcl (tr fg)", "show ?case"], ["proof (prove)\nusing this:\n  (c + ce, e # w, c'' + ce) \\<in> trcl (tr fg)\n\ngoal (1 subgoal):\n 1. (c + ce, e # w, c'' + ce) \\<in> trcl (tr fg)", "."], ["proof (state)\nthis:\n  (c + ce, e # w, c'' + ce) \\<in> trcl (tr fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}