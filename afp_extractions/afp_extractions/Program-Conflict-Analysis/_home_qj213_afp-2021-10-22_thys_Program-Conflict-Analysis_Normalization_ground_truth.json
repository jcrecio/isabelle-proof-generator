{"file_name": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis/Normalization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis", "problem_names": ["lemma (in eflowgraph) iso_ret_no_ret: \"!!u c. \\<lbrakk> \n    isolated_ret fg p; \n    proc_of fg u = p; \n    u \\<noteq> return fg p; \n    (([u],c),w,([return fg p'],c'))\\<in>trcl (trss fg) \n  \\<rbrakk> \\<Longrightarrow> False\"", "lemma (in eflowgraph) initial_starts_with_call: \"\n  \\<lbrakk> (([entry fg p],c),e,(s',c'))\\<in>trss fg; initialproc fg p \\<rbrakk> \n    \\<Longrightarrow> \\<exists>p'. e=LCall p' \\<and> isolated_ret fg p'\"", "lemma (in eflowgraph) no_sl_from_initial: \n  assumes A: \"w\\<noteq>[]\" \"initialproc fg p\" \n             \"(([entry fg p],c),w,([v],c'))\\<in>trcl (trss fg)\" \n  shows False", "lemma (in eflowgraph) no_retsl_from_initial: \n  assumes A: \"w\\<noteq>[]\" \n             \"initialproc fg p\" \n             \"(([entry fg p],c),w,(r',c'))\\<in>trcl (trss fg)\" \n             \"length r' \\<le> 1\" \n  shows False", "lemma ntrs_is_trss_s: \"((s,c),w,(s',c'))\\<in>ntrs fg \\<Longrightarrow> ((s,c),w,(s',c'))\\<in>trcl (trss fg)\"", "lemma ntrs_is_trss: \"((s,c),w,(s',c'))\\<in>trcl (ntrs fg) \n  \\<Longrightarrow> ((s,c),foldl (@) [] w,(s',c'))\\<in>trcl (trss fg)\"", "lemma ntr_is_tr_s: \"(c,w,c')\\<in>ntr fg \\<Longrightarrow> (c,w,c')\\<in>trcl (tr fg)\"", "lemma ntr_is_tr: \"(c,ww,c')\\<in>trcl (ntr fg) \\<Longrightarrow> (c,foldl (@) [] ww,c')\\<in>trcl (tr fg)\"", "lemma (in eflowgraph) ntr_sl_move_left: \"!!ce u r w r' ce'.  \n  \\<lbrakk> ({#[entry fg p]#},ww,{# u#r #}+ce)\\<in>trcl (ntr fg); \n    (([u],ce),w,(r',ce'))\\<in>trcl (trss fg); \n    initialproc fg p; \n    length r' \\<le> 1; w\\<noteq>[] \n  \\<rbrakk> \\<Longrightarrow> \\<exists>ww'. ({#[entry fg p]#}, ww',{# r'@r #}+ce')\\<in>trcl (ntr fg)\"", "lemma (in eflowgraph) normalize: \"\\<lbrakk> \n    (cstart,w,c')\\<in>trcl (tr fg); \n    cstart={# [entry fg p] #}; \n    initialproc fg p \\<rbrakk> \n  \\<Longrightarrow> \\<exists>w'. ({# [entry fg p] #},w',c')\\<in>trcl (ntr fg)\"\n\\<comment> \\<open>The lemma is shown by induction on the reaching path\\<close>", "theorem (in eflowgraph) ntr_repr:\n  \"    (\\<exists>w. ({#[entry fg (main fg)]#},w,c)\\<in>trcl (tr fg)) \n   \\<longleftrightarrow> (\\<exists>w. ({#[entry fg (main fg)]#},w,c)\\<in>trcl (ntr fg))\"", "lemma ntrs_c_cases_s[cases set]: \"\\<lbrakk> \n    ((s,c),w,(s',c'))\\<in>ntrs fg; \n    !!csp. \\<lbrakk> c'=csp+c; !!s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> \n                                         (u,Spawn p,v)\\<in>edges fg \\<and> \n                                         initialproc fg p \n           \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma ntrs_c_cases[cases set]: \"\\<lbrakk> \n    ((s,c),ww,(s',c'))\\<in>trcl (ntrs fg); \n    !!csp. \\<lbrakk> c'=csp+c; !!s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> \n                                         (u,Spawn p,v)\\<in>edges fg \\<and> \n                                         initialproc fg p \n           \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemmas (in flowgraph) ntrs_valid_preserve_s = trss_valid_preserve[OF ntrs_is_trss_s]", "lemmas (in flowgraph) ntr_valid_preserve_s = tr_valid_preserve[OF ntr_is_tr_s]", "lemmas (in flowgraph) ntrs_valid_preserve = trss_valid_preserve[OF ntrs_is_trss]", "lemmas (in flowgraph) ntr_valid_preserve = tr_valid_preserve[OF ntr_is_tr]", "lemma (in flowgraph) ntrp_valid_preserve_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrp fg\" \n  and V: \"valid fg (add_mset s c)\" \n  shows \"valid fg (add_mset s' c')\"", "lemma (in flowgraph) ntrp_valid_preserve: \n  assumes A: \"((s,c),e,(s',c'))\\<in>trcl (ntrp fg)\" \n  and V: \"valid fg (add_mset s c)\" \n  shows \"valid fg (add_mset s' c')\"", "lemma mon_ww_empty[simp]: \"mon_ww fg [] = {}\"", "lemma mon_ww_uncons[simp]: \n  \"mon_ww fg (ee#ww) = mon_w fg ee \\<union> mon_ww fg ww\"", "lemma mon_ww_unconc: \n  \"mon_ww fg (ww1@ww2) = mon_ww fg ww1 \\<union> mon_ww fg ww2\"", "lemma mon_env_empty[simp]: \"mon_env fg [] = {}\"", "lemma mon_env_single[simp]: \n  \"mon_env fg [e] = (case e of LOC a \\<Rightarrow> {} | ENV a \\<Rightarrow> mon_w fg a)\"", "lemma mon_env_uncons[simp]: \n  \"mon_env fg (e#w) \n   = (case e of LOC a \\<Rightarrow> {} | ENV a \\<Rightarrow> mon_w fg a) \\<union> mon_env fg w\"", "lemma mon_env_unconc: \n  \"mon_env fg (w1@w2) = mon_env fg w1 \\<union> mon_env fg w2\"", "lemma mon_loc_empty[simp]: \"mon_loc fg [] = {}\"", "lemma mon_loc_single[simp]: \n  \"mon_loc fg [e] = (case e of ENV a \\<Rightarrow> {} | LOC a \\<Rightarrow> mon_w fg a)\"", "lemma mon_loc_uncons[simp]: \n  \"mon_loc fg (e#w) \n  = (case e of ENV a \\<Rightarrow> {} | LOC a \\<Rightarrow> mon_w fg a) \\<union> mon_loc fg w\"", "lemma mon_loc_unconc: \n  \"mon_loc fg (w1@w2) = mon_loc fg w1 \\<union> mon_loc fg w2\"", "lemma mon_ww_of_foldl[simp]: \"mon_w fg (foldl (@) [] ww) = mon_ww fg ww\"", "lemma mon_ww_ileq: \"w\\<preceq>w' \\<Longrightarrow> mon_ww fg w \\<subseteq> mon_ww fg w'\"", "lemma mon_ww_cil: \n  \"w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2 \\<Longrightarrow> mon_ww fg w = mon_ww fg w1 \\<union> mon_ww fg w2\"", "lemma mon_loc_cil: \n  \"w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2 \\<Longrightarrow> mon_loc fg w = mon_loc fg w1 \\<union> mon_loc fg w2\"", "lemma mon_env_cil: \n  \"w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2 \\<Longrightarrow> mon_env fg w = mon_env fg w1 \\<union> mon_env fg w2\"", "lemma mon_ww_of_le_rem: \n  \"mon_ww fg (map le_rem_s w) = mon_loc fg w \\<union> mon_env fg w\"", "lemma mon_env_ileq: \"w\\<preceq>w' \\<Longrightarrow> mon_env fg w \\<subseteq> mon_env fg w'\"", "lemma mon_loc_ileq: \"w\\<preceq>w' \\<Longrightarrow> mon_loc fg w \\<subseteq> mon_loc fg w'\"", "lemma mon_loc_map_loc[simp]: \"mon_loc fg (map LOC w) = mon_ww fg w\"", "lemma mon_env_map_env[simp]: \"mon_env fg (map ENV w) = mon_ww fg w\"", "lemma mon_loc_map_env[simp]: \"mon_loc fg (map ENV w) = {}\"", "lemma mon_env_map_loc[simp]: \"mon_env fg (map LOC w) = {}\"", "lemma (in flowgraph) ntrs_mon_increasing_s: \"((s,c),e,(s',c'))\\<in>ntrs fg \n  \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and> mon_c fg c = mon_c fg c'\"", "lemma (in flowgraph) ntr_mon_increasing_s: \n  \"(c,ee,c')\\<in>ntr fg \\<Longrightarrow> mon_c fg c \\<subseteq> mon_c fg c'\"", "lemma (in flowgraph) ntrp_mon_increasing_s: \"((s,c),e,(s',c'))\\<in>ntrp fg \n  \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and> mon_c fg c \\<subseteq> mon_c fg c'\"", "lemma (in flowgraph) ntrp_mon_increasing: \"((s,c),e,(s',c'))\\<in>trcl (ntrp fg) \n  \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and> mon_c fg c \\<subseteq> mon_c fg c'\"", "lemmas (in flowgraph) ntrs_c_no_mon_s = trss_c_no_mon[OF ntrs_is_trss_s]", "lemmas (in flowgraph) ntrs_c_no_mon = trss_c_no_mon[OF ntrs_is_trss]", "lemmas (in flowgraph) ntrs_mon_e_no_ctx = trss_mon_w_no_ctx[OF ntrs_is_trss_s]", "lemma (in flowgraph) ntrs_mon_w_no_ctx: \n  assumes A: \"((s,c),w,(s',c'))\\<in>trcl (ntrs fg)\" \n  shows \"mon_ww fg w \\<inter> mon_c fg c = {}\"", "lemma (in flowgraph) ntrp_mon_env_e_no_ctx: \n  \"((s,c),ENV e,(s',c'))\\<in>ntrp fg \\<Longrightarrow> mon_w fg e \\<inter> mon_s fg s = {}\"", "lemma (in flowgraph) ntrp_mon_loc_e_no_ctx: \n  \"((s,c),LOC e,(s',c'))\\<in>ntrp fg \\<Longrightarrow> mon_w fg e \\<inter> mon_c fg c = {}\"", "lemma (in flowgraph) ntrp_mon_env_w_no_ctx: \n  \"((s,c),w,(s',c'))\\<in>trcl (ntrp fg) \\<Longrightarrow> mon_env fg w \\<inter> mon_s fg s = {}\"", "lemma (in flowgraph) ntrp_mon_loc_w_no_ctx: \n  \"((s,c),w,(s',c'))\\<in>trcl (ntrp fg) \\<Longrightarrow> mon_loc fg w \\<inter> mon_c fg c = {}\"", "lemma (in flowgraph) ntrs_modify_context_s: \n  assumes A: \"((s,c),ee,(s',c'))\\<in>ntrs fg\" \n  and B: \"mon_w fg ee \\<inter> mon_c fg cn = {}\" \n  shows \"\\<exists>csp. c'=csp+c \\<and> mon_c fg csp={} \\<and> ((s,cn),ee,(s',csp+cn))\\<in>ntrs fg\"", "lemma (in flowgraph) ntrs_modify_context[rule_format]: \"\n  \\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (ntrs fg)\\<rbrakk> \n    \\<Longrightarrow> \\<forall>cn. mon_ww fg w \\<inter> mon_c fg cn = {} \n        \\<longrightarrow> (\\<exists>csp. c'=csp+c \\<and> mon_c fg csp = {} \\<and> \n              ((s,cn),w,(s',csp+cn))\\<in>trcl (ntrs fg))\"", "lemma ntrs_xchange_context_s: \n  assumes A: \"((s,c),ee,(s',csp+c))\\<in>ntrs fg\" \n  and B: \"mon_c fg cn \\<subseteq> mon_c fg c\" \n  shows \"((s,cn),ee,(s',csp+cn))\\<in>ntrs fg\"", "lemma ntrs_replace_context_s: \n  assumes A: \"((s,c+cr),ee,(s',c'+cr))\\<in>ntrs fg\" \n  and B: \"mon_c fg crn \\<subseteq> mon_c fg cr\" \n  shows \"((s,c+crn),ee,(s',c'+crn))\\<in>ntrs fg\"", "lemma (in flowgraph) ntrs_xchange_context: \"!!s c c' cn. \\<lbrakk>\n    ((s,c),ww,(s',c'))\\<in>trcl (ntrs fg); \n    mon_c fg cn \\<subseteq> mon_c fg c\n  \\<rbrakk> \\<Longrightarrow> \\<exists>csp. \n    c'=csp+c \\<and> ((s,cn),ww,(s',csp+cn))\\<in>trcl (ntrs fg)\"", "lemma (in flowgraph) ntrs_replace_context: \n  assumes A: \"((s,c+cr),ww,(s',c'+cr))\\<in>trcl (ntrs fg)\" \n  and B: \"mon_c fg crn \\<subseteq> mon_c fg cr\" \n  shows \"((s,c+crn),ww,(s',c'+crn))\\<in>trcl (ntrs fg)\"", "lemma (in flowgraph) ntr_add_context_s: \n  assumes A: \"(c,e,c')\\<in>ntr fg\" \n  and B: \"mon_w fg e \\<inter> mon_c fg cn = {}\" \n  shows \"(c+cn,e,c'+cn)\\<in>ntr fg\"", "lemma (in flowgraph) ntr_add_context: \n  \"\\<lbrakk>(c,w,c')\\<in>trcl (ntr fg); mon_ww fg w \\<inter> mon_c fg cn = {}\\<rbrakk> \n    \\<Longrightarrow> (c+cn,w,c'+cn)\\<in>trcl (ntr fg)\"", "lemma (in flowgraph) ntrs_add_context_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrs fg\" \n  and B: \"mon_w fg e \\<inter> mon_c fg cn = {}\" \n  shows \"((s,c+cn),e,(s',c'+cn))\\<in>ntrs fg\"", "lemma (in flowgraph) ntrp_add_context_s: \n  \"\\<lbrakk> ((s,c),e,(s',c'))\\<in>ntrp fg; mon_w fg (le_rem_s e) \\<inter> mon_c fg cn = {} \\<rbrakk> \n  \\<Longrightarrow> ((s,c+cn),e,(s',c'+cn))\\<in>ntrp fg\"", "lemma (in flowgraph) ntrp_add_context: \"\\<lbrakk> \n    ((s,c),w,(s',c'))\\<in>trcl (ntrp fg); \n    mon_ww fg (map le_rem_s w) \\<inter> mon_c fg cn = {} \n  \\<rbrakk> \\<Longrightarrow> ((s,c+cn),w,(s',c'+cn))\\<in>trcl (ntrp fg)\"", "lemma ntrs_stack_comp_s: \n  assumes A: \"((s,c),ee,(s',c'))\\<in>ntrs fg\" \n  shows \"((s@r,c),ee,(s'@r,c'))\\<in>ntrs fg\"", "lemma ntrs_stack_comp: \"((s,c),ww,(s',c'))\\<in>trcl (ntrs fg) \n  \\<Longrightarrow> ((s@r,c),ww,(s'@r,c'))\\<in>trcl (ntrs fg)\"", "lemma (in flowgraph) ntrp_stack_comp_s: \n  assumes A: \"((s,c),ee,(s',c'))\\<in>ntrp fg\" \n  and B: \"mon_s fg r \\<inter> mon_env fg [ee] = {}\" \n  shows \"((s@r,c),ee,(s'@r,c'))\\<in>ntrp fg\"", "lemma (in flowgraph) ntrp_stack_comp: \n  \"\\<lbrakk> ((s,c),ww,(s',c'))\\<in>trcl (ntrp fg); mon_s fg r \\<inter> mon_env fg ww = {} \\<rbrakk> \n    \\<Longrightarrow> ((s@r,c),ww,(s'@r,c'))\\<in>trcl (ntrp fg)\"", "lemma ntrs_stack_top_decomp_s: \n  assumes A: \"((u#r,c),ee,(s',c'))\\<in>ntrs fg\" \n  and EX: \"!!v u' p. \\<lbrakk> \n      s'=v#u'#r; \n      (([u],c),ee,([v,u'],c'))\\<in>ntrs fg; \n      (u,Call p,u')\\<in>edges fg \n    \\<rbrakk> \\<Longrightarrow> P\" \n  shows \"P\"", "lemma ntrs_stack_decomp_s: \n  assumes A: \"((u#s@r,c),ee,(s',c'))\\<in>ntrs fg\" \n  and EX: \"!!v u' p. \\<lbrakk> \n      s'=v#u'#s@r; \n      ((u#s,c),ee,(v#u'#s,c'))\\<in>ntrs fg; \n      (u,Call p,u')\\<in>edges fg\n    \\<rbrakk> \\<Longrightarrow> P\" \n  shows P", "lemma ntrs_stack_decomp: \"!!u s r c P. \\<lbrakk>\n    ((u#s@r,c),ww,(s',c'))\\<in>trcl (ntrs fg); \n    !!v rr. \\<lbrakk>s'=v#rr@r; ((u#s,c),ww,(v#rr,c'))\\<in>trcl (ntrs fg)\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma ntrp_stack_decomp_s: \n  assumes A: \"((u#s@r,c),ee,(s',c'))\\<in>ntrp fg\" \n  and EX: \"!!v rr. \\<lbrakk> s'=v#rr@r; ((u#s,c),ee,(v#rr,c'))\\<in>ntrp fg \\<rbrakk> \\<Longrightarrow> P\" \n  shows \"P\"", "lemma ntrp_stack_decomp: \"!!u s r c P. \\<lbrakk>\n    ((u#s@r,c),ww,(s',c'))\\<in>trcl (ntrp fg); \n    !!v rr. \\<lbrakk>s'=v#rr@r; ((u#s,c),ww,(v#rr,c'))\\<in>trcl (ntrp fg)\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma \\<alpha>n_simps[simp]: \n  \"\\<alpha>n fg [] = ({},{})\" \n  \"\\<alpha>n fg (e#w) = (mon_e fg e, mon_w fg w)\"", "lemma \\<alpha>nl_def': \"\\<alpha>nl fg == \\<alpha>n fg \\<circ> le_rem_s\"", "lemma \\<alpha>nl_simps[simp]: \n  \"\\<alpha>nl fg (ENV x) = \\<alpha>n fg x\" \n  \"\\<alpha>nl fg (LOC x) = \\<alpha>n fg x\"", "lemma \\<alpha>nl_simps1[simp]:\n  \"(\\<alpha>nl fg) \\<circ> ENV = \\<alpha>n fg\"\n  \"(\\<alpha>nl fg) \\<circ> LOC = \\<alpha>n fg\"", "lemma \\<alpha>n_\\<alpha>nl: \"(\\<alpha>n fg) \\<circ> le_rem_s = \\<alpha>nl fg\"", "lemma \\<alpha>n_fst_snd[simp]: \"fst (\\<alpha>n fg w) \\<union> snd (\\<alpha>n fg w) = mon_w fg w\"", "lemma mon_pl_of_\\<alpha>nl: \"mon_pl (map (\\<alpha>nl fg) w) = mon_loc fg w \\<union> mon_env fg w\"", "lemma cil_\\<alpha>n_cons_helper: \"mon_pl (map (\\<alpha>n fg) wb) = mon_ww fg wb\"", "lemma cil_\\<alpha>nl_cons_helper: \n  \"mon_pl (map (\\<alpha>nl fg) wb) = mon_ww fg (map le_rem_s wb)\"", "lemma cil_\\<alpha>n_cons1: \"\\<lbrakk>w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb; fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\\<rbrakk> \n  \\<Longrightarrow> e#w \\<in> e#wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\"", "lemma cil_\\<alpha>n_cons2: \"\\<lbrakk>w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb; fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\\<rbrakk> \n  \\<Longrightarrow> e#w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e#wb\"", "lemma (in flowgraph) ntrs_mon_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrs fg\" \n  shows \"mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)\"", "lemma (in flowgraph) ntr_mon_s: \n  \"(c,e,c')\\<in>ntr fg \\<Longrightarrow> mon_c fg c' = mon_c fg c \\<union> fst (\\<alpha>n fg e)\"", "lemma (in flowgraph) ntrp_mon_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrp fg\" \n  shows \"mon_c fg (add_mset s' c') = mon_c fg (add_mset s c) \\<union> fst (\\<alpha>nl fg e)\"", "lemma (in flowgraph) ntr_split: \n  \"!!ca cb. \\<lbrakk>(ca+cb,w,c')\\<in>trcl (ntr fg); valid fg (ca+cb)\\<rbrakk> \\<Longrightarrow> \n  \\<exists>ca' cb' wa wb. \n  c'=ca'+cb' \\<and> \n  w\\<in>(wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb) \\<and> \n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and> \n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and> \n  (ca,wa,ca')\\<in>trcl (ntr fg) \\<and> (cb,wb,cb')\\<in>trcl (ntr fg)\"", "lemma (in flowgraph) ntrp_split: \"\n  !!s c1 c2 s' c'. \n  \\<lbrakk>((s,c1+c2),w,(s',c'))\\<in>trcl (ntrp fg); valid fg ({#s#}+c1+c2)\\<rbrakk> \n  \\<Longrightarrow> \\<exists>w1 w2 c1' c2'. \n        w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> (map ENV w2) \\<and> \n        c'=c1'+c2' \\<and> \n        ((s,c1),w1,(s',c1'))\\<in>trcl (ntrp fg) \\<and> \n        (c2,w2,c2')\\<in>trcl (ntr fg) \\<and> \n        mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and> \n        mon_ww fg w2 \\<inter> mon_c fg ({#s#}+c1) = {}\"", "lemma (in flowgraph) ntr_split': \n  assumes A: \"(ca+cb,w,c')\\<in>trcl (ntr fg)\" \n  and VALID: \"valid fg (ca+cb)\" \n  shows \"\\<exists>ca' cb' wa wb. \n    c'=ca'+cb' \\<and> \n    w\\<in>(wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb) \\<and> \n    mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and> \n    mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and> \n    (ca,wa,ca')\\<in>trcl (ntr fg) \\<and> \n    (cb,wb,cb')\\<in>trcl (ntr fg)\"", "lemma (in flowgraph) ntr_unsplit: \n  assumes A: \"w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb\" and \n  B: \"(ca,wa,ca')\\<in>trcl (ntr fg)\" \n  \"(cb,wb,cb')\\<in>trcl (ntr fg)\" \n  \"mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb)={}\" \n  \"mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa)={}\"\n  shows \"(ca+cb,w,ca'+cb')\\<in>trcl (ntr fg)\"", "lemma (in flowgraph) ntrp_unsplit: \n  assumes A: \"w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> (map ENV wb)\" and\n  B: \"((s,ca),wa,(s',ca'))\\<in>trcl (ntrp fg)\" \n  \"(cb,wb,cb')\\<in>trcl (ntr fg)\" \n  \"mon_c fg ({#s#}+ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb)={}\" \n  \"mon_c fg cb \\<inter> (mon_c fg ({#s#}+ca) \\<union> mon_ww fg (map le_rem_s wa))={}\"\n  shows \"((s,ca+cb),w,(s',ca'+cb'))\\<in>trcl (ntrp fg)\"", "theorem (in flowgraph) ntr_interleave: \"valid fg (ca+cb) \\<Longrightarrow> \n  (ca+cb,w,c')\\<in>trcl (ntr fg) \\<longleftrightarrow> \n  (\\<exists>ca' cb' wa wb. \n    c'=ca'+cb' \\<and> \n    w\\<in>(wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb) \\<and> \n    mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and> \n    mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and> \n    (ca,wa,ca')\\<in>trcl (ntr fg) \\<and> (cb,wb,cb')\\<in>trcl (ntr fg))\"", "theorem (in flowgraph) ntrp_interleave: \n  \"valid fg ({#s#}+c1+c2) \\<Longrightarrow> \n  ((s,c1+c2),w,(s',c'))\\<in>trcl (ntrp fg) \\<longleftrightarrow> \n  (\\<exists>w1 w2 c1' c2'. \n    w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> (map ENV w2) \\<and> \n    c'=c1'+c2' \\<and> \n    ((s,c1),w1,(s',c1'))\\<in>trcl (ntrp fg) \\<and> \n    (c2,w2,c2')\\<in>trcl (ntr fg) \\<and> \n    mon_ww fg (map le_rem_s w1) \\<inter> \n    mon_c fg c2 = {} \\<and> \n    mon_ww fg w2 \\<inter> mon_c fg ({#s#}+c1) = {})\"", "lemma (in flowgraph) ntr_reverse_split: \"!!w s' ce'. \\<lbrakk> \n  (c,w,{#s'#}+ce')\\<in>trcl (ntr fg); \n  valid fg c \\<rbrakk> \\<Longrightarrow> \n  \\<exists>s ce w1 w2 ce1' ce2'. \n    c={#s#}+ce \\<and> \n    ce'=ce1'+ce2' \\<and> \n    w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and> \n    mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and> \n    mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and> \n    ({#s#},w1,{#s'#}+ce1')\\<in>trcl (ntr fg) \\<and> \n    (ce,w2,ce2')\\<in>trcl (ntr fg)\" \n\\<comment> \\<open>The proof works by induction on the initial configuration. Note that configurations consist of finitely many threads only\\<close>\n\\<comment> \\<open>FIXME: An induction over the size (rather then over the adding of some fixed element) may lead to a smoother proof here\\<close>"], "translations": [["", "lemma (in eflowgraph) iso_ret_no_ret: \"!!u c. \\<lbrakk> \n    isolated_ret fg p; \n    proc_of fg u = p; \n    u \\<noteq> return fg p; \n    (([u],c),w,([return fg p'],c'))\\<in>trcl (trss fg) \n  \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u c.\n       \\<lbrakk>isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), w, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False", "proof (induct w rule: length_compl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u c.\n       \\<lbrakk>isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), [], [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>e l u c.\n       \\<lbrakk>\\<And>ll u c.\n                   \\<lbrakk>length ll \\<le> length l; isolated_ret fg p;\n                    proc_of fg u = p; u \\<noteq> return fg p;\n                    (([u], c), ll, [return fg p'], c')\n                    \\<in> trcl (trss fg)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), e # l, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), [], [return fg p'], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<And>u c.\n       \\<lbrakk>isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), [], [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>e l u c.\n       \\<lbrakk>\\<And>ll u c.\n                   \\<lbrakk>length ll \\<le> length l; isolated_ret fg p;\n                    proc_of fg u = p; u \\<noteq> return fg p;\n                    (([u], c), ll, [return fg p'], c')\n                    \\<in> trcl (trss fg)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), e # l, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), [], [return fg p'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>e l u c.\n       \\<lbrakk>\\<And>ll u c.\n                   \\<lbrakk>length ll \\<le> length l; isolated_ret fg p;\n                    proc_of fg u = p; u \\<noteq> return fg p;\n                    (([u], c), ll, [return fg p'], c')\n                    \\<in> trcl (trss fg)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), e # l, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e l u c.\n       \\<lbrakk>\\<And>ll u c.\n                   \\<lbrakk>length ll \\<le> length l; isolated_ret fg p;\n                    proc_of fg u = p; u \\<noteq> return fg p;\n                    (([u], c), ll, [return fg p'], c')\n                    \\<in> trcl (trss fg)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), e # l, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False", "case (Cons e w)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length w; isolated_ret fg p; proc_of fg ?u = p;\n   ?u \\<noteq> return fg p;\n   (([?u], ?c), ?ll, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> False\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), e # w, [return fg p'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u c.\n       \\<lbrakk>\\<And>ll u c.\n                   \\<lbrakk>length ll \\<le> length l; isolated_ret fg p;\n                    proc_of fg u = p; u \\<noteq> return fg p;\n                    (([u], c), ll, [return fg p'], c')\n                    \\<in> trcl (trss fg)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), e # l, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False", "note IHP=this"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ll \\<le> length w; isolated_ret fg p; proc_of fg ?u = p;\n   ?u \\<noteq> return fg p;\n   (([?u], ?c), ?ll, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> False\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), e # w, [return fg p'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u c.\n       \\<lbrakk>\\<And>ll u c.\n                   \\<lbrakk>length ll \\<le> length l; isolated_ret fg p;\n                    proc_of fg u = p; u \\<noteq> return fg p;\n                    (([u], c), ll, [return fg p'], c')\n                    \\<in> trcl (trss fg)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), e # l, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length w; isolated_ret fg p; proc_of fg ?u = p;\n   ?u \\<noteq> return fg p;\n   (([?u], ?c), ?ll, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> False\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), e # w, [return fg p'], c') \\<in> trcl (trss fg)", "obtain sh ch where SPLIT1: \"(([u],c),e,(sh,ch))\\<in>trss fg\" and SPLIT2: \"((sh,ch),w,([return fg p'],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length w; isolated_ret fg p; proc_of fg ?u = p;\n   ?u \\<noteq> return fg p;\n   (([?u], ?c), ?ll, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> False\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), e # w, [return fg p'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>(([u], c), e, sh, ch) \\<in> trss fg;\n         ((sh, ch), w, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w, [return fg p'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>e l u c.\n       \\<lbrakk>\\<And>ll u c.\n                   \\<lbrakk>length ll \\<le> length l; isolated_ret fg p;\n                    proc_of fg u = p; u \\<noteq> return fg p;\n                    (([u], c), ll, [return fg p'], c')\n                    \\<in> trcl (trss fg)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        isolated_ret fg p; proc_of fg u = p; u \\<noteq> return fg p;\n        (([u], c), e # l, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> False", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases e)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1. e = LBase x1 \\<Longrightarrow> False\n 2. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 3. e = LRet \\<Longrightarrow> False\n 4. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "case LRet"], ["proof (state)\nthis:\n  e = LRet\n\ngoal (4 subgoals):\n 1. \\<And>x1. e = LBase x1 \\<Longrightarrow> False\n 2. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 3. e = LRet \\<Longrightarrow> False\n 4. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "with SPLIT1 IHP(3,4)"], ["proof (chain)\npicking this:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  e = LRet", "show False"], ["proof (prove)\nusing this:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  e = LRet\n\ngoal (1 subgoal):\n 1. False", "by (auto elim!: trss.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>x1. e = LBase x1 \\<Longrightarrow> False\n 2. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 3. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1. e = LBase x1 \\<Longrightarrow> False\n 2. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 3. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "case LBase"], ["proof (state)\nthis:\n  e = LBase x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1. e = LBase x1 \\<Longrightarrow> False\n 2. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 3. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "with SPLIT1 IHP(2,3)"], ["proof (chain)\npicking this:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  isolated_ret fg p\n  proc_of fg u = p\n  e = LBase x1_", "obtain v where A: \"sh=[v]\" \"proc_of fg v = p\" \"v\\<noteq>return fg p\""], ["proof (prove)\nusing this:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  isolated_ret fg p\n  proc_of fg u = p\n  e = LBase x1_\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>sh = [v]; proc_of fg v = p; v \\<noteq> return fg p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force elim!: trss.cases simp add: edges_part isolated_ret_def)"], ["proof (state)\nthis:\n  sh = [v]\n  proc_of fg v = p\n  v \\<noteq> return fg p\n\ngoal (3 subgoals):\n 1. \\<And>x1. e = LBase x1 \\<Longrightarrow> False\n 2. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 3. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "with IHP SPLIT2"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length w; isolated_ret fg p; proc_of fg ?u = p;\n   ?u \\<noteq> return fg p;\n   (([?u], ?c), ?ll, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> False\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), e # w, [return fg p'], c') \\<in> trcl (trss fg)\n  ((sh, ch), w, [return fg p'], c') \\<in> trcl (trss fg)\n  sh = [v]\n  proc_of fg v = p\n  v \\<noteq> return fg p", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length w; isolated_ret fg p; proc_of fg ?u = p;\n   ?u \\<noteq> return fg p;\n   (([?u], ?c), ?ll, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> False\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), e # w, [return fg p'], c') \\<in> trcl (trss fg)\n  ((sh, ch), w, [return fg p'], c') \\<in> trcl (trss fg)\n  sh = [v]\n  proc_of fg v = p\n  v \\<noteq> return fg p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 2. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 2. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "case (LSpawn q)"], ["proof (state)\nthis:\n  e = LSpawn q\n\ngoal (2 subgoals):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 2. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "with SPLIT1 IHP(2,3)"], ["proof (chain)\npicking this:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  isolated_ret fg p\n  proc_of fg u = p\n  e = LSpawn q", "obtain v where A: \"sh=[v]\" \"proc_of fg v = p\" \"v\\<noteq>return fg p\""], ["proof (prove)\nusing this:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  isolated_ret fg p\n  proc_of fg u = p\n  e = LSpawn q\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>sh = [v]; proc_of fg v = p; v \\<noteq> return fg p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force elim!: trss.cases simp add: edges_part isolated_ret_def)"], ["proof (state)\nthis:\n  sh = [v]\n  proc_of fg v = p\n  v \\<noteq> return fg p\n\ngoal (2 subgoals):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False\n 2. \\<And>x4. e = LSpawn x4 \\<Longrightarrow> False", "with IHP SPLIT2"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?ll \\<le> length w; isolated_ret fg p; proc_of fg ?u = p;\n   ?u \\<noteq> return fg p;\n   (([?u], ?c), ?ll, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> False\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), e # w, [return fg p'], c') \\<in> trcl (trss fg)\n  ((sh, ch), w, [return fg p'], c') \\<in> trcl (trss fg)\n  sh = [v]\n  proc_of fg v = p\n  v \\<noteq> return fg p", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ll \\<le> length w; isolated_ret fg p; proc_of fg ?u = p;\n   ?u \\<noteq> return fg p;\n   (([?u], ?c), ?ll, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n  \\<Longrightarrow> False\n  isolated_ret fg p\n  proc_of fg u = p\n  u \\<noteq> return fg p\n  (([u], c), e # w, [return fg p'], c') \\<in> trcl (trss fg)\n  ((sh, ch), w, [return fg p'], c') \\<in> trcl (trss fg)\n  sh = [v]\n  proc_of fg v = p\n  v \\<noteq> return fg p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False", "case (LCall q)"], ["proof (state)\nthis:\n  e = LCall q\n\ngoal (1 subgoal):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False", "with SPLIT1 IHP(2,3)"], ["proof (chain)\npicking this:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  isolated_ret fg p\n  proc_of fg u = p\n  e = LCall q", "obtain uh where A: \"sh=entry fg q#[uh]\" \"proc_of fg uh = p\" \"uh\\<noteq>return fg p\""], ["proof (prove)\nusing this:\n  (([u], c), e, sh, ch) \\<in> trss fg\n  isolated_ret fg p\n  proc_of fg u = p\n  e = LCall q\n\ngoal (1 subgoal):\n 1. (\\<And>uh.\n        \\<lbrakk>sh = [entry fg q, uh]; proc_of fg uh = p;\n         uh \\<noteq> return fg p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force elim!: trss.cases simp add: edges_part isolated_ret_def)"], ["proof (state)\nthis:\n  sh = [entry fg q, uh]\n  proc_of fg uh = p\n  uh \\<noteq> return fg p\n\ngoal (1 subgoal):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False", "with SPLIT2"], ["proof (chain)\npicking this:\n  ((sh, ch), w, [return fg p'], c') \\<in> trcl (trss fg)\n  sh = [entry fg q, uh]\n  proc_of fg uh = p\n  uh \\<noteq> return fg p", "have B: \"((entry fg q#[uh],ch),w,([return fg p'],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((sh, ch), w, [return fg p'], c') \\<in> trcl (trss fg)\n  sh = [entry fg q, uh]\n  proc_of fg uh = p\n  uh \\<noteq> return fg p\n\ngoal (1 subgoal):\n 1. (([entry fg q, uh], ch), w, [return fg p'], c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([entry fg q, uh], ch), w, [return fg p'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False", "from trss_return_cases[OF B]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>s' u'.\n              \\<lbrakk>[return fg p'] = s' @ [u', uh];\n               (([entry fg q], ch), w, s' @ [u'], c')\n               \\<in> trcl (trss fg)\\<rbrakk>\n              \\<Longrightarrow> ?P;\n   \\<And>waa wb cha.\n      \\<lbrakk>w = waa @ wb;\n       (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n       (([uh], cha), wb, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P", "obtain w1 w2 ct where C: \"w=w1@w2\" \"length w2 \\<le> length w\" \"(([entry fg q],ch),w1,([],ct))\\<in>trcl (trss fg)\" \"(([uh],ct),w2,([return fg p'],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>s' u'.\n              \\<lbrakk>[return fg p'] = s' @ [u', uh];\n               (([entry fg q], ch), w, s' @ [u'], c')\n               \\<in> trcl (trss fg)\\<rbrakk>\n              \\<Longrightarrow> ?P;\n   \\<And>waa wb cha.\n      \\<lbrakk>w = waa @ wb;\n       (([entry fg q], ch), waa, [], cha) \\<in> trcl (trss fg);\n       (([uh], cha), wb, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 ct.\n        \\<lbrakk>w = w1 @ w2; length w2 \\<le> length w;\n         (([entry fg q], ch), w1, [], ct) \\<in> trcl (trss fg);\n         (([uh], ct), w2, [return fg p'], c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto)"], ["proof (state)\nthis:\n  w = w1 @ w2\n  length w2 \\<le> length w\n  (([entry fg q], ch), w1, [], ct) \\<in> trcl (trss fg)\n  (([uh], ct), w2, [return fg p'], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>x2. e = LCall x2 \\<Longrightarrow> False", "from IHP(1)[OF C(2) IHP(2) A(2,3) C(4)]"], ["proof (chain)\npicking this:\n  False", "show False"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>The first step of an initial procedure is a call\\<close>"], ["", "lemma (in eflowgraph) initial_starts_with_call: \"\n  \\<lbrakk> (([entry fg p],c),e,(s',c'))\\<in>trss fg; initialproc fg p \\<rbrakk> \n    \\<Longrightarrow> \\<exists>p'. e=LCall p' \\<and> isolated_ret fg p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(([entry fg p], c), e, s', c') \\<in> trss fg;\n     initialproc fg p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'. e = LCall p' \\<and> isolated_ret fg p'", "by (auto elim!: trss.cases dest: initial_call_no_ret initial_no_ret entry_return_same_proc)\n\n\\<comment> \\<open>There are no same-level paths starting from the entry node of an initial procedure\\<close>"], ["", "lemma (in eflowgraph) no_sl_from_initial: \n  assumes A: \"w\\<noteq>[]\" \"initialproc fg p\" \n             \"(([entry fg p],c),w,([v],c'))\\<in>trcl (trss fg)\" \n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from A"], ["proof (chain)\npicking this:\n  w \\<noteq> []\n  initialproc fg p\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)", "obtain sh ch e w' where SPLIT: \"(([entry fg p],c),e,(sh,ch))\\<in>trss fg\" \"((sh,ch),w',([v],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  w \\<noteq> []\n  initialproc fg p\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>e sh ch w'.\n        \\<lbrakk>(([entry fg p], c), e, sh, ch) \\<in> trss fg;\n         ((sh, ch), w', [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases w, simp, fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  (([entry fg p], c), e, sh, ch) \\<in> trss fg\n  ((sh, ch), w', [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. False", "from initial_starts_with_call[OF SPLIT(1) A(2)]"], ["proof (chain)\npicking this:\n  \\<exists>p'. e = LCall p' \\<and> isolated_ret fg p'", "obtain p' where CE: \"e=LCall p'\" \"isolated_ret fg p'\""], ["proof (prove)\nusing this:\n  \\<exists>p'. e = LCall p' \\<and> isolated_ret fg p'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>e = LCall p'; isolated_ret fg p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e = LCall p'\n  isolated_ret fg p'\n\ngoal (1 subgoal):\n 1. False", "with SPLIT(1)"], ["proof (chain)\npicking this:\n  (([entry fg p], c), e, sh, ch) \\<in> trss fg\n  e = LCall p'\n  isolated_ret fg p'", "obtain u' where \"sh=entry fg p'#[u']\""], ["proof (prove)\nusing this:\n  (([entry fg p], c), e, sh, ch) \\<in> trss fg\n  e = LCall p'\n  isolated_ret fg p'\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        sh = [entry fg p', u'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: trss.cases)"], ["proof (state)\nthis:\n  sh = [entry fg p', u']\n\ngoal (1 subgoal):\n 1. False", "with SPLIT(2)"], ["proof (chain)\npicking this:\n  ((sh, ch), w', [v], c') \\<in> trcl (trss fg)\n  sh = [entry fg p', u']", "have \"((entry fg p'#[u'],ch),w',([v],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((sh, ch), w', [v], c') \\<in> trcl (trss fg)\n  sh = [entry fg p', u']\n\ngoal (1 subgoal):\n 1. (([entry fg p', u'], ch), w', [v], c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([entry fg p', u'], ch), w', [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  (([entry fg p', u'], ch), w', [v], c') \\<in> trcl (trss fg)", "obtain wa ct where \"(([entry fg p'],ch),wa,([],ct))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg p', u'], ch), w', [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>wa ct.\n        (([entry fg p'], ch), wa, [], ct)\n        \\<in> trcl (trss fg) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule_tac trss_return_cases, auto)"], ["proof (state)\nthis:\n  (([entry fg p'], ch), wa, [], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  (([entry fg p'], ch), wa, [], ct) \\<in> trcl (trss fg)", "obtain wa' p'' where \"(([entry fg p'],ch),wa',([return fg p''],ct))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg p'], ch), wa, [], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>wa' p''.\n        (([entry fg p'], ch), wa', [return fg p''], ct)\n        \\<in> trcl (trss fg) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: trss_2empty_to_2return)"], ["proof (state)\nthis:\n  (([entry fg p'], ch), wa', [return fg p''], ct) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. False", "from iso_ret_no_ret[OF CE(2) _ _ this] CE(2)[unfolded isolated_ret_def]"], ["proof (chain)\npicking this:\n  \\<lbrakk>proc_of fg (entry fg p') = p';\n   entry fg p' \\<noteq> return fg p'\\<rbrakk>\n  \\<Longrightarrow> False\n  (\\<forall>u l. (u, l, return fg p') \\<notin> edges fg) \\<and>\n  entry fg p' \\<noteq> return fg p'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>proc_of fg (entry fg p') = p';\n   entry fg p' \\<noteq> return fg p'\\<rbrakk>\n  \\<Longrightarrow> False\n  (\\<forall>u l. (u, l, return fg p') \\<notin> edges fg) \\<and>\n  entry fg p' \\<noteq> return fg p'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed\n  \n\\<comment> \\<open>There are no same-level or returning paths starting from the entry node of an initial procedure\\<close>"], ["", "lemma (in eflowgraph) no_retsl_from_initial: \n  assumes A: \"w\\<noteq>[]\" \n             \"initialproc fg p\" \n             \"(([entry fg p],c),w,(r',c'))\\<in>trcl (trss fg)\" \n             \"length r' \\<le> 1\" \n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases r')"], ["proof (state)\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow> False\n 2. \\<And>a list. r' = a # list \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  r' = []\n\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow> False\n 2. \\<And>a list. r' = a # list \\<Longrightarrow> False", "with A(3)"], ["proof (chain)\npicking this:\n  (([entry fg p], c), w, r', c') \\<in> trcl (trss fg)\n  r' = []", "have \"(([entry fg p],c),w,([],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg p], c), w, r', c') \\<in> trcl (trss fg)\n  r' = []\n\ngoal (1 subgoal):\n 1. (([entry fg p], c), w, [], c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  (([entry fg p], c), w, [], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow> False\n 2. \\<And>a list. r' = a # list \\<Longrightarrow> False", "from trss_2empty_to_2return[OF this, simplified]"], ["proof (chain)\npicking this:\n  \\<exists>w'.\n     w = w' @ [LRet] \\<and>\n     (\\<exists>pa.\n         (([entry fg p], c), w', [return fg pa], c') \\<in> trcl (trss fg))", "obtain w' q where B: \"w=w'@[LRet]\" \"(([entry fg p], c), w', [return fg q], c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  \\<exists>w'.\n     w = w' @ [LRet] \\<and>\n     (\\<exists>pa.\n         (([entry fg p], c), w', [return fg pa], c') \\<in> trcl (trss fg))\n\ngoal (1 subgoal):\n 1. (\\<And>w' q.\n        \\<lbrakk>w = w' @ [LRet];\n         (([entry fg p], c), w', [return fg q], c')\n         \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast)"], ["proof (state)\nthis:\n  w = w' @ [LRet]\n  (([entry fg p], c), w', [return fg q], c') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow> False\n 2. \\<And>a list. r' = a # list \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases w')"], ["proof (state)\ngoal (2 subgoals):\n 1. w' = [] \\<Longrightarrow> False\n 2. \\<And>a list. w' = a # list \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  w' = []\n\ngoal (2 subgoals):\n 1. w' = [] \\<Longrightarrow> False\n 2. \\<And>a list. w' = a # list \\<Longrightarrow> False", "with B"], ["proof (chain)\npicking this:\n  w = w' @ [LRet]\n  (([entry fg p], c), w', [return fg q], c') \\<in> trcl (trss fg)\n  w' = []", "have \"p=q\" \"entry fg p = return fg p\""], ["proof (prove)\nusing this:\n  w = w' @ [LRet]\n  (([entry fg p], c), w', [return fg q], c') \\<in> trcl (trss fg)\n  w' = []\n\ngoal (1 subgoal):\n 1. p = q &&& entry fg p = return fg p", "by (auto dest: trcl_empty_cons entry_return_same_proc)"], ["proof (state)\nthis:\n  p = q\n  entry fg p = return fg p\n\ngoal (2 subgoals):\n 1. w' = [] \\<Longrightarrow> False\n 2. \\<And>a list. w' = a # list \\<Longrightarrow> False", "with A(2) initial_no_ret"], ["proof (chain)\npicking this:\n  initialproc fg p\n  initialproc fg ?p \\<Longrightarrow> entry fg ?p \\<noteq> return fg ?p\n  p = q\n  entry fg p = return fg p", "show False"], ["proof (prove)\nusing this:\n  initialproc fg p\n  initialproc fg ?p \\<Longrightarrow> entry fg ?p \\<noteq> return fg ?p\n  p = q\n  entry fg p = return fg p\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list. w' = a # list \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. w' = a # list \\<Longrightarrow> False", "case Cons"], ["proof (state)\nthis:\n  w' = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list. w' = a # list \\<Longrightarrow> False", "hence \"w'\\<noteq>[]\""], ["proof (prove)\nusing this:\n  w' = a_ # list_\n\ngoal (1 subgoal):\n 1. w' \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  w' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a list. w' = a # list \\<Longrightarrow> False", "from no_sl_from_initial[OF this A(2) B(2)]"], ["proof (chain)\npicking this:\n  False", "show False"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list. r' = a # list \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. r' = a # list \\<Longrightarrow> False", "case (Cons u rr)"], ["proof (state)\nthis:\n  r' = u # rr\n\ngoal (1 subgoal):\n 1. \\<And>a list. r' = a # list \\<Longrightarrow> False", "with A(4)"], ["proof (chain)\npicking this:\n  length r' \\<le> 1\n  r' = u # rr", "have \"r'=[u]\""], ["proof (prove)\nusing this:\n  length r' \\<le> 1\n  r' = u # rr\n\ngoal (1 subgoal):\n 1. r' = [u]", "by auto"], ["proof (state)\nthis:\n  r' = [u]\n\ngoal (1 subgoal):\n 1. \\<And>a list. r' = a # list \\<Longrightarrow> False", "with no_sl_from_initial[OF A(1,2)] A(3)"], ["proof (chain)\npicking this:\n  (([entry fg p], ?c), w, [?v], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  False\n  (([entry fg p], c), w, r', c') \\<in> trcl (trss fg)\n  r' = [u]", "show False"], ["proof (prove)\nusing this:\n  (([entry fg p], ?c), w, [?v], ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  False\n  (([entry fg p], c), w, r', c') \\<in> trcl (trss fg)\n  r' = [u]\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Definition of normalized paths\""], ["", "text \\<open>\n  In order to describe the restricted schedules, we define an operational semantics that performs an atomically scheduled sequence of steps in one step, called a {\\em macrostep}. \n  Context switches may occur after macrosteps only. We call this the {\\em normalized semantics} and a sequence of macrosteps a {\\em normalized path}.  \n\n  Since we ensured that every path starts with a non-returning call, we can define a macrostep as an initial call followed by a same-level path\\footnote{Same-level paths are paths with balanced calls and returns. \n  The stack-level at the beginning of their execution is the same as at the end, and during the execution, the stack never falls below the initial level.} of the called procedure. This has the effect that context switches are\n  either performed before a non-returning call (if the thread makes a further macrostep in the future) or after the thread has reached its final configuration. \n\n  As for the original semantics, we first define the normalized semantics on a single thread with a context and then use the theory developed in Section~\\ref{thy:ThreadTracking} to derive interleaving semantics on multisets and \n  configurations with an explicit local thread (loc/env-semantics, cf. Section~\\ref{sec:ThreadTracking:exp_local}). \n\\<close>"], ["", "inductive_set\n  ntrs :: \"('n,'p,'ba,'m,'more) flowgraph_rec_scheme \\<Rightarrow> \n             (('n list \\<times> 'n conf) \\<times> ('p,'ba) label list \\<times> ('n list \\<times> 'n conf)) set\"\n  for fg\n  where\n  \\<comment> \\<open>A macrostep transforms one thread by first calling a procedure and then doing a same-level path\\<close>\n  ntrs_step: \"\\<lbrakk>((u#r,ce),LCall p, (entry fg p # u' # r,ce))\\<in>trss fg; \n               (([entry fg p],ce),w,([v],ce'))\\<in>trcl (trss fg)\\<rbrakk> \\<Longrightarrow> \n             ((u#r,ce),LCall p#w,(v#u'#r,ce'))\\<in>ntrs fg\""], ["", "abbreviation ntr where \"ntr fg == gtr (ntrs fg)\""], ["", "abbreviation ntrp where \"ntrp fg == gtrp (ntrs fg)\""], ["", "interpretation ntrs: env_no_step \"ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env_no_step (ntrs fg)", "apply (rule env_no_step.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c e s' c' P.\n       \\<lbrakk>((s, c), e, s', c') \\<in> ntrs fg;\n        \\<And>csp. c' = csp + c \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "apply (erule ntrs.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c e s' c' P u r ce p u' w v ce'.\n       \\<lbrakk>\\<And>csp. c' = csp + c \\<Longrightarrow> P; s = u # r;\n        c = ce; e = LCall p # w; s' = v # u' # r; c' = ce';\n        ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg;\n        (([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P u r ce p u' w v ce'.\n       \\<lbrakk>\\<And>csp. ce' = csp + ce \\<Longrightarrow> P;\n        ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg;\n        (([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "apply (erule trss_c_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P u r ce p u' w v ce' csp.\n       \\<lbrakk>\\<And>csp. ce' = csp + ce \\<Longrightarrow> P;\n        ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg;\n        ce' = csp + ce;\n        \\<And>s.\n           s \\<in># csp \\<Longrightarrow>\n           \\<exists>p u v.\n              s = [entry fg p] \\<and>\n              (u, Spawn p, v) \\<in> edges fg \\<and>\n              initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> P", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Representation property for reachable configurations\""], ["", "text \\<open>\n  In this section, we show that a configuration is reachable if and only if it is reachable via a normalized path.\n\\<close>"], ["", "text \\<open>The first direction is to show that a normalized path is also a path. This follows from the definitions. Note that we first show that a single macrostep corresponds to a path and then\n  generalize the result to sequences of macrosteps\\<close>"], ["", "lemma ntrs_is_trss_s: \"((s,c),w,(s',c'))\\<in>ntrs fg \\<Longrightarrow> ((s,c),w,(s',c'))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> ntrs fg \\<Longrightarrow>\n    ((s, c), w, s', c') \\<in> trcl (trss fg)", "proof (erule ntrs.cases, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u r p u' wa v.\n       \\<lbrakk>s = u # r; w = LCall p # wa; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), wa, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((u # r, c), LCall p # wa, v # u' # r, c')\n                         \\<in> trcl (trss fg)", "fix p r u u' v w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u r p u' wa v.\n       \\<lbrakk>s = u # r; w = LCall p # wa; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), wa, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((u # r, c), LCall p # wa, v # u' # r, c')\n                         \\<in> trcl (trss fg)", "assume A: \"((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\" \"(([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\""], ["proof (state)\nthis:\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>u r p u' wa v.\n       \\<lbrakk>s = u # r; w = LCall p # wa; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), wa, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((u # r, c), LCall p # wa, v # u' # r, c')\n                         \\<in> trcl (trss fg)", "from trss_stack_comp[OF A(2), of \"u'#r\"]"], ["proof (chain)\npicking this:\n  (([entry fg p] @ u' # r, c), w, [v] @ u' # r, c') \\<in> trcl (trss fg)", "have \"((entry fg p # u' # r, c), w, v # u' # r, c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg p] @ u' # r, c), w, [v] @ u' # r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((entry fg p # u' # r, c), w, v # u' # r, c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  ((entry fg p # u' # r, c), w, v # u' # r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>u r p u' wa v.\n       \\<lbrakk>s = u # r; w = LCall p # wa; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), wa, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((u # r, c), LCall p # wa, v # u' # r, c')\n                         \\<in> trcl (trss fg)", "with A(1)"], ["proof (chain)\npicking this:\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  ((entry fg p # u' # r, c), w, v # u' # r, c') \\<in> trcl (trss fg)", "show \"((u # r, c), LCall p # w, v # u' # r, c') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  ((entry fg p # u' # r, c), w, v # u' # r, c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((u # r, c), LCall p # w, v # u' # r, c') \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  ((u # r, c), LCall p # w, v # u' # r, c') \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ntrs_is_trss: \"((s,c),w,(s',c'))\\<in>trcl (ntrs fg) \n  \\<Longrightarrow> ((s,c),foldl (@) [] w,(s',c'))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (ntrs fg) \\<Longrightarrow>\n    ((s, c), foldl (@) [] w, s', c') \\<in> trcl (trss fg)", "proof (induct rule: trcl_pair_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. ((a, b), foldl (@) [] [], a, b) \\<in> trcl (trss fg)\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        ((ab, ba), foldl (@) [] w, ac, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a, b), foldl (@) [] (aa # w), ac, bb)\n                         \\<in> trcl (trss fg)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a b. ((a, b), foldl (@) [] [], a, b) \\<in> trcl (trss fg)\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        ((ab, ba), foldl (@) [] w, ac, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a, b), foldl (@) [] (aa # w), ac, bb)\n                         \\<in> trcl (trss fg)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a_, b_), foldl (@) [] [], a_, b_) \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  ((a_, b_), foldl (@) [] [], a_, b_) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        ((ab, ba), foldl (@) [] w, ac, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a, b), foldl (@) [] (aa # w), ac, bb)\n                         \\<in> trcl (trss fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        ((ab, ba), foldl (@) [] w, ac, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a, b), foldl (@) [] (aa # w), ac, bb)\n                         \\<in> trcl (trss fg)", "case (cons s c e sh ch w s' c')"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> ntrs fg\n  ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\n  ((sh, ch), foldl (@) [] w, s', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        ((ab, ba), foldl (@) [] w, ac, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a, b), foldl (@) [] (aa # w), ac, bb)\n                         \\<in> trcl (trss fg)", "note IHP=this"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> ntrs fg\n  ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\n  ((sh, ch), foldl (@) [] w, s', c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        ((ab, ba), foldl (@) [] w, ac, bb) \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> ((a, b), foldl (@) [] (aa # w), ac, bb)\n                         \\<in> trcl (trss fg)", "from trcl_concat[OF ntrs_is_trss_s[OF IHP(1)] IHP(3)] foldl_conc_empty_eq[of e w]"], ["proof (chain)\npicking this:\n  ((s, c), e @ foldl (@) [] w, s', c') \\<in> trcl (trss fg)\n  foldl (@) e w = e @ foldl (@) [] w", "show ?case"], ["proof (prove)\nusing this:\n  ((s, c), e @ foldl (@) [] w, s', c') \\<in> trcl (trss fg)\n  foldl (@) e w = e @ foldl (@) [] w\n\ngoal (1 subgoal):\n 1. ((s, c), foldl (@) [] (e # w), s', c') \\<in> trcl (trss fg)", "by simp"], ["proof (state)\nthis:\n  ((s, c), foldl (@) [] (e # w), s', c') \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ntr_is_tr_s: \"(c,w,c')\\<in>ntr fg \\<Longrightarrow> (c,w,c')\\<in>trcl (tr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, w, c') \\<in> ntr fg \\<Longrightarrow> (c, w, c') \\<in> trcl (tr fg)", "by (erule gtrE) (auto dest: ntrs_is_trss_s intro: gtrI)"], ["", "lemma ntr_is_tr: \"(c,ww,c')\\<in>trcl (ntr fg) \\<Longrightarrow> (c,foldl (@) [] ww,c')\\<in>trcl (tr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, ww, c') \\<in> trcl (ntr fg) \\<Longrightarrow>\n    (c, foldl (@) [] ww, c') \\<in> trcl (tr fg)", "proof (induct rule: trcl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c. (c, foldl (@) [] [], c) \\<in> trcl (tr fg)\n 2. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> ntr fg; (c', w, c'') \\<in> trcl (ntr fg);\n        (c', foldl (@) [] w, c'') \\<in> trcl (tr fg)\\<rbrakk>\n       \\<Longrightarrow> (c, foldl (@) [] (a # w), c'') \\<in> trcl (tr fg)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>c. (c, foldl (@) [] [], c) \\<in> trcl (tr fg)\n 2. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> ntr fg; (c', w, c'') \\<in> trcl (ntr fg);\n        (c', foldl (@) [] w, c'') \\<in> trcl (tr fg)\\<rbrakk>\n       \\<Longrightarrow> (c, foldl (@) [] (a # w), c'') \\<in> trcl (tr fg)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_, foldl (@) [] [], c_) \\<in> trcl (tr fg)", "by auto"], ["proof (state)\nthis:\n  (c_, foldl (@) [] [], c_) \\<in> trcl (tr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> ntr fg; (c', w, c'') \\<in> trcl (ntr fg);\n        (c', foldl (@) [] w, c'') \\<in> trcl (tr fg)\\<rbrakk>\n       \\<Longrightarrow> (c, foldl (@) [] (a # w), c'') \\<in> trcl (tr fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> ntr fg; (c', w, c'') \\<in> trcl (ntr fg);\n        (c', foldl (@) [] w, c'') \\<in> trcl (tr fg)\\<rbrakk>\n       \\<Longrightarrow> (c, foldl (@) [] (a # w), c'') \\<in> trcl (tr fg)", "case (cons c ee c' ww c'')"], ["proof (state)\nthis:\n  (c, ee, c') \\<in> ntr fg\n  (c', ww, c'') \\<in> trcl (ntr fg)\n  (c', foldl (@) [] ww, c'') \\<in> trcl (tr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> ntr fg; (c', w, c'') \\<in> trcl (ntr fg);\n        (c', foldl (@) [] w, c'') \\<in> trcl (tr fg)\\<rbrakk>\n       \\<Longrightarrow> (c, foldl (@) [] (a # w), c'') \\<in> trcl (tr fg)", "note IHP=this"], ["proof (state)\nthis:\n  (c, ee, c') \\<in> ntr fg\n  (c', ww, c'') \\<in> trcl (ntr fg)\n  (c', foldl (@) [] ww, c'') \\<in> trcl (tr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> ntr fg; (c', w, c'') \\<in> trcl (ntr fg);\n        (c', foldl (@) [] w, c'') \\<in> trcl (tr fg)\\<rbrakk>\n       \\<Longrightarrow> (c, foldl (@) [] (a # w), c'') \\<in> trcl (tr fg)", "from trcl_concat[OF ntr_is_tr_s[OF IHP(1)] IHP(3)] foldl_conc_empty_eq[of ee ww]"], ["proof (chain)\npicking this:\n  (c, ee @ foldl (@) [] ww, c'') \\<in> trcl (tr fg)\n  foldl (@) ee ww = ee @ foldl (@) [] ww", "show ?case"], ["proof (prove)\nusing this:\n  (c, ee @ foldl (@) [] ww, c'') \\<in> trcl (tr fg)\n  foldl (@) ee ww = ee @ foldl (@) [] ww\n\ngoal (1 subgoal):\n 1. (c, foldl (@) [] (ee # ww), c'') \\<in> trcl (tr fg)", "by (auto)"], ["proof (state)\nthis:\n  (c, foldl (@) [] (ee # ww), c'') \\<in> trcl (tr fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The other direction requires to prove that for each path reaching a configuration there is also a normalized path reaching the same configuration. \n  We need an auxiliary lemma for this proof, that is a kind of append rule: {\\em Given a normalized path reaching some configuration @{term c}, and a same level or returning path from some \n  stack in @{term c}, we can derive a normalized path to @{term c} modified according to the same-level path}. We cannot simply append the same-level or returning path\n  as a macrostep, because it does not start with a non-returning call. Instead, we will have to append it to some macrostep in the normalized path, i.e. move it ,,left'' into the normalized\n  path.\n\\<close>"], ["", "text \\<open>\n  Intuitively, we can describe the concept of the proof as follows:\n  Due to the restrictions we made on flowgraphs, a same-level or returning path cannot be the first steps on a thread. \n  Hence there is a last macrostep that was executed on the thread. When this macrostep was executed, all threads held less monitors then they do at the end of the execution, because\n  the set of monitors held by every single thread is increasing during the execution of a normalized path. Thus we can append the same-level or returning path to the last macrostep\n  on that thread. As a same-level or returning path does not allocate any monitors, the following macrosteps remain executable. If we have a same-level path, appending it to a macrostep\n  yields a valid macrostep again and we are done. Appending a returning path to a macrostep yields a same-level path. In this case we inductively repeat our argument. \n\n  The actual proof is strictly inductive; it either appends the same-level path to the {\\em last} macrostep or inductively repeats the argument.\n\\<close>"], ["", "lemma (in eflowgraph) ntr_sl_move_left: \"!!ce u r w r' ce'.  \n  \\<lbrakk> ({#[entry fg p]#},ww,{# u#r #}+ce)\\<in>trcl (ntr fg); \n    (([u],ce),w,(r',ce'))\\<in>trcl (trss fg); \n    initialproc fg p; \n    length r' \\<le> 1; w\\<noteq>[] \n  \\<rbrakk> \\<Longrightarrow> \\<exists>ww'. ({#[entry fg p]#}, ww',{# r'@r #}+ce')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ce u r w r' ce'.\n       \\<lbrakk>({#[entry fg p]#}, ww, {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "proof (induct ww rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ce u r w r' ce'.\n       \\<lbrakk>({#[entry fg p]#}, [], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)\n 2. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "case Nil"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, [], {#u # r#} + ce) \\<in> trcl (ntr fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  initialproc fg p\n  length r' \\<le> 1\n  w \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>ce u r w r' ce'.\n       \\<lbrakk>({#[entry fg p]#}, [], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)\n 2. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "note CC=this"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, [], {#u # r#} + ce) \\<in> trcl (ntr fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  initialproc fg p\n  length r' \\<le> 1\n  w \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>ce u r w r' ce'.\n       \\<lbrakk>({#[entry fg p]#}, [], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)\n 2. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "hence \"u=entry fg p\""], ["proof (prove)\nusing this:\n  ({#[entry fg p]#}, [], {#u # r#} + ce) \\<in> trcl (ntr fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  initialproc fg p\n  length r' \\<le> 1\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. u = entry fg p", "by auto\n  \\<comment> \\<open>If the normalized path is empty, we get a contradiction, because there is no same-level path from the initial configuration of a thread\\<close>"], ["proof (state)\nthis:\n  u = entry fg p\n\ngoal (2 subgoals):\n 1. \\<And>ce u r w r' ce'.\n       \\<lbrakk>({#[entry fg p]#}, [], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)\n 2. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "with CC(2) no_retsl_from_initial[OF CC(5,3) _ CC(4)]"], ["proof (chain)\npicking this:\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  (([entry fg p], ?c), w, r', ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  False\n  u = entry fg p", "have False"], ["proof (prove)\nusing this:\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  (([entry fg p], ?c), w, r', ?c') \\<in> trcl (trss fg) \\<Longrightarrow>\n  False\n  u = entry fg p\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>ce u r w r' ce'.\n       \\<lbrakk>({#[entry fg p]#}, [], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)\n 2. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", ".."], ["proof (state)\nthis:\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "case (snoc ee ww)"], ["proof (state)\nthis:\n  \\<lbrakk>({#[entry fg p]#}, ww, {#?u # ?r#} + ?ce) \\<in> trcl (ntr fg);\n   (([?u], ?ce), ?w, ?r', ?ce') \\<in> trcl (trss fg); initialproc fg p;\n   length ?r' \\<le> 1; ?w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ww'.\n                       ({#[entry fg p]#}, ww', {#?r' @ ?r#} + ?ce')\n                       \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, ww @ [ee], {#u # r#} + ce) \\<in> trcl (ntr fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  initialproc fg p\n  length r' \\<le> 1\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "note IHP=this \n  \\<comment> \\<open>In the induction step, we extract the last macrostep\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>({#[entry fg p]#}, ww, {#?u # ?r#} + ?ce) \\<in> trcl (ntr fg);\n   (([?u], ?ce), ?w, ?r', ?ce') \\<in> trcl (trss fg); initialproc fg p;\n   length ?r' \\<le> 1; ?w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ww'.\n                       ({#[entry fg p]#}, ww', {#?r' @ ?r#} + ?ce')\n                       \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, ww @ [ee], {#u # r#} + ce) \\<in> trcl (ntr fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  initialproc fg p\n  length r' \\<le> 1\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>({#[entry fg p]#}, ww, {#?u # ?r#} + ?ce) \\<in> trcl (ntr fg);\n   (([?u], ?ce), ?w, ?r', ?ce') \\<in> trcl (trss fg); initialproc fg p;\n   length ?r' \\<le> 1; ?w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ww'.\n                       ({#[entry fg p]#}, ww', {#?r' @ ?r#} + ?ce')\n                       \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, ww @ [ee], {#u # r#} + ce) \\<in> trcl (ntr fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  initialproc fg p\n  length r' \\<le> 1\n  w \\<noteq> []", "obtain ch where SPLIT: \"({#[entry fg p]#},ww,ch)\\<in>trcl (ntr fg)\" \"(ch,ee,{# u#r #}+ce)\\<in>ntr fg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>({#[entry fg p]#}, ww, {#?u # ?r#} + ?ce) \\<in> trcl (ntr fg);\n   (([?u], ?ce), ?w, ?r', ?ce') \\<in> trcl (trss fg); initialproc fg p;\n   length ?r' \\<le> 1; ?w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ww'.\n                       ({#[entry fg p]#}, ww', {#?r' @ ?r#} + ?ce')\n                       \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, ww @ [ee], {#u # r#} + ce) \\<in> trcl (ntr fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  initialproc fg p\n  length r' \\<le> 1\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ch.\n        \\<lbrakk>({#[entry fg p]#}, ww, ch) \\<in> trcl (ntr fg);\n         (ch, ee, {#u # r#} + ce) \\<in> ntr fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_rev_uncons) \n  \\<comment> \\<open>The last macrostep first executes a call and then a same-level path\\<close>"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, ww, ch) \\<in> trcl (ntr fg)\n  (ch, ee, {#u # r#} + ce) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "from SPLIT(2)"], ["proof (chain)\npicking this:\n  (ch, ee, {#u # r#} + ce) \\<in> ntr fg", "obtain q wws uh rh ceh uh' vt cet where \n    STEPFMT: \"ee=LCall q#wws\" \"ch=add_mset (uh#rh) ceh\" \"add_mset (u#r) ce = add_mset (vt#uh'#rh) cet\" \"((uh#rh,ceh),LCall q,(entry fg q#uh'#rh,ceh))\\<in>trss fg\" \"(([entry fg q],ceh),wws,([vt],cet))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (ch, ee, {#u # r#} + ce) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. (\\<And>q wws uh rh ceh vt uh' cet.\n        \\<lbrakk>ee = LCall q # wws; ch = add_mset (uh # rh) ceh;\n         add_mset (u # r) ce = add_mset (vt # uh' # rh) cet;\n         ((uh # rh, ceh), LCall q, entry fg q # uh' # rh, ceh)\n         \\<in> trss fg;\n         (([entry fg q], ceh), wws, [vt], cet) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: gtrE ntrs.cases[simplified])\n  \\<comment> \\<open>Make a case distinction whether the last step was executed on the same thread as the sl/ret-path or not\\<close>"], ["proof (state)\nthis:\n  ee = LCall q # wws\n  ch = add_mset (uh # rh) ceh\n  add_mset (u # r) ce = add_mset (vt # uh' # rh) cet\n  ((uh # rh, ceh), LCall q, entry fg q # uh' # rh, ceh) \\<in> trss fg\n  (([entry fg q], ceh), wws, [vt], cet) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ce u r w r' ce'.\n       \\<lbrakk>\\<And>ce u r w r' ce'.\n                   \\<lbrakk>({#[entry fg p]#}, xs, {#u # r#} + ce)\n                            \\<in> trcl (ntr fg);\n                    (([u], ce), w, r', ce') \\<in> trcl (trss fg);\n                    initialproc fg p; length r' \\<le> 1;\n                    w \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ww'.\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg);\n        ({#[entry fg p]#}, xs @ [x], {#u # r#} + ce) \\<in> trcl (ntr fg);\n        (([u], ce), w, r', ce') \\<in> trcl (trss fg); initialproc fg p;\n        length r' \\<le> 1; w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "from STEPFMT(3)"], ["proof (chain)\npicking this:\n  add_mset (u # r) ce = add_mset (vt # uh' # rh) cet", "show ?case"], ["proof (prove)\nusing this:\n  add_mset (u # r) ce = add_mset (vt # uh' # rh) cet\n\ngoal (1 subgoal):\n 1. \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "proof (cases rule: mset_single_cases') \n    \\<comment> \\<open>If the sl/ret path was executed on the same thread as the last macrostep\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>u # r = vt # uh' # rh; ce = cet\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ww'.\n                         ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                         \\<in> trcl (ntr fg)\n 2. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "case loc"], ["proof (state)\nthis:\n  u # r = vt # uh' # rh\n  ce = cet\n\ngoal (2 subgoals):\n 1. \\<lbrakk>u # r = vt # uh' # rh; ce = cet\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ww'.\n                         ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                         \\<in> trcl (ntr fg)\n 2. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "note CASE=this"], ["proof (state)\nthis:\n  u # r = vt # uh' # rh\n  ce = cet\n\ngoal (2 subgoals):\n 1. \\<lbrakk>u # r = vt # uh' # rh; ce = cet\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ww'.\n                         ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                         \\<in> trcl (ntr fg)\n 2. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "hence C': \"u=vt\" \"r=uh'#rh\" \"ce=cet\""], ["proof (prove)\nusing this:\n  u # r = vt # uh' # rh\n  ce = cet\n\ngoal (1 subgoal):\n 1. u = vt &&& r = uh' # rh &&& ce = cet", "by auto\n    \\<comment> \\<open>we append it to the last macrostep.\\<close>"], ["proof (state)\nthis:\n  u = vt\n  r = uh' # rh\n  ce = cet\n\ngoal (2 subgoals):\n 1. \\<lbrakk>u # r = vt # uh' # rh; ce = cet\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ww'.\n                         ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                         \\<in> trcl (ntr fg)\n 2. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "with STEPFMT(5) IHP(3)"], ["proof (chain)\npicking this:\n  (([entry fg q], ceh), wws, [vt], cet) \\<in> trcl (trss fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  u = vt\n  r = uh' # rh\n  ce = cet", "have NEWPATH: \"(([entry fg q],ceh),wws@w,(r',ce'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg q], ceh), wws, [vt], cet) \\<in> trcl (trss fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  u = vt\n  r = uh' # rh\n  ce = cet\n\ngoal (1 subgoal):\n 1. (([entry fg q], ceh), wws @ w, r', ce') \\<in> trcl (trss fg)", "by (simp add: trcl_concat)\n    \\<comment> \\<open>We then distinguish whether we appended a same-level or a returning path\\<close>"], ["proof (state)\nthis:\n  (([entry fg q], ceh), wws @ w, r', ce') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>u # r = vt # uh' # rh; ce = cet\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ww'.\n                         ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                         \\<in> trcl (ntr fg)\n 2. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "proof (cases r')\n      \\<comment> \\<open>If we appended a same-level path\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. \\<And>a list.\n       r' = a # list \\<Longrightarrow>\n       \\<exists>ww'.\n          ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "case (Cons v') \\<comment> \\<open>Same-level path\\<close>"], ["proof (state)\nthis:\n  r' = v' # list_\n\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. \\<And>a list.\n       r' = a # list \\<Longrightarrow>\n       \\<exists>ww'.\n          ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "with IHP(5)"], ["proof (chain)\npicking this:\n  length r' \\<le> 1\n  r' = v' # list_", "have CC: \"r'=[v']\""], ["proof (prove)\nusing this:\n  length r' \\<le> 1\n  r' = v' # list_\n\ngoal (1 subgoal):\n 1. r' = [v']", "by auto\n      \\<comment> \\<open>The macrostep still ends with a same-level path\\<close>"], ["proof (state)\nthis:\n  r' = [v']\n\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. \\<And>a list.\n       r' = a # list \\<Longrightarrow>\n       \\<exists>ww'.\n          ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "with NEWPATH"], ["proof (chain)\npicking this:\n  (([entry fg q], ceh), wws @ w, r', ce') \\<in> trcl (trss fg)\n  r' = [v']", "have \"(([entry fg q],ceh),wws@w,([v'],ce'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg q], ceh), wws @ w, r', ce') \\<in> trcl (trss fg)\n  r' = [v']\n\ngoal (1 subgoal):\n 1. (([entry fg q], ceh), wws @ w, [v'], ce') \\<in> trcl (trss fg)", "by simp\n      \\<comment> \\<open>and thus remains a valid macrostep\\<close>"], ["proof (state)\nthis:\n  (([entry fg q], ceh), wws @ w, [v'], ce') \\<in> trcl (trss fg)\n\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. \\<And>a list.\n       r' = a # list \\<Longrightarrow>\n       \\<exists>ww'.\n          ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "from gtrI_s[OF ntrs_step[OF STEPFMT(4), simplified, OF this]]"], ["proof (chain)\npicking this:\n  (add_mset (uh # rh) ceh, LCall q # wws @ w, add_mset (v' # uh' # rh) ce')\n  \\<in> ntr fg", "have \"(add_mset (uh # rh) ceh, LCall q # wws@w, add_mset (v' # uh' # rh) ce') \\<in> ntr fg\""], ["proof (prove)\nusing this:\n  (add_mset (uh # rh) ceh, LCall q # wws @ w, add_mset (v' # uh' # rh) ce')\n  \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. (add_mset (uh # rh) ceh, LCall q # wws @ w,\n     add_mset (v' # uh' # rh) ce')\n    \\<in> ntr fg", ".\n      \\<comment> \\<open>that we can append to the prefix of the normalized path to get our proposition\\<close>"], ["proof (state)\nthis:\n  (add_mset (uh # rh) ceh, LCall q # wws @ w, add_mset (v' # uh' # rh) ce')\n  \\<in> ntr fg\n\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. \\<And>a list.\n       r' = a # list \\<Longrightarrow>\n       \\<exists>ww'.\n          ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "with STEPFMT(2) SPLIT(1) CC C'(2)"], ["proof (chain)\npicking this:\n  ch = add_mset (uh # rh) ceh\n  ({#[entry fg p]#}, ww, ch) \\<in> trcl (ntr fg)\n  r' = [v']\n  r = uh' # rh\n  (add_mset (uh # rh) ceh, LCall q # wws @ w, add_mset (v' # uh' # rh) ce')\n  \\<in> ntr fg", "have \"({#[entry fg p]#},ww@[LCall q#wws@w],{# r'@r #} + ce')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  ch = add_mset (uh # rh) ceh\n  ({#[entry fg p]#}, ww, ch) \\<in> trcl (ntr fg)\n  r' = [v']\n  r = uh' # rh\n  (add_mset (uh # rh) ceh, LCall q # wws @ w, add_mset (v' # uh' # rh) ce')\n  \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. ({#[entry fg p]#}, ww @ [LCall q # wws @ w], {#r' @ r#} + ce')\n    \\<in> trcl (ntr fg)", "by (auto simp add: trcl_rev_cons)"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, ww @ [LCall q # wws @ w], {#r' @ r#} + ce')\n  \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. \\<And>a list.\n       r' = a # list \\<Longrightarrow>\n       \\<exists>ww'.\n          ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ({#[entry fg p]#}, ww @ [LCall q # wws @ w], {#r' @ r#} + ce')\n  \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "next\n      \\<comment> \\<open>If we appended a returning path\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "case Nil"], ["proof (state)\nthis:\n  r' = []\n\ngoal (1 subgoal):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "note CC=this\n      \\<comment> \\<open>The macrostep now ends with a returning path, and thus gets a same-level path\\<close>"], ["proof (state)\nthis:\n  r' = []\n\ngoal (1 subgoal):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "have NEWSL: \"(([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)", "from STEPFMT(4)"], ["proof (chain)\npicking this:\n  ((uh # rh, ceh), LCall q, entry fg q # uh' # rh, ceh) \\<in> trss fg", "have \"(([uh],ceh),LCall q,(entry fg q#[uh'],ceh))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  ((uh # rh, ceh), LCall q, entry fg q # uh' # rh, ceh) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([uh], ceh), LCall q, [entry fg q, uh'], ceh) \\<in> trss fg", "by (auto elim!: trss.cases intro: trss.intros)"], ["proof (state)\nthis:\n  (([uh], ceh), LCall q, [entry fg q, uh'], ceh) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)", "also"], ["proof (state)\nthis:\n  (([uh], ceh), LCall q, [entry fg q, uh'], ceh) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)", "from trss_stack_comp[OF NEWPATH] CC"], ["proof (chain)\npicking this:\n  (([entry fg q] @ ?r, ceh), wws @ w, r' @ ?r, ce') \\<in> trcl (trss fg)\n  r' = []", "have \"((entry fg q#[uh'],ceh),wws@w,([uh'],ce'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg q] @ ?r, ceh), wws @ w, r' @ ?r, ce') \\<in> trcl (trss fg)\n  r' = []\n\ngoal (1 subgoal):\n 1. (([entry fg q, uh'], ceh), wws @ w, [uh'], ce') \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  (([entry fg q, uh'], ceh), wws @ w, [uh'], ce') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)", "finally"], ["proof (chain)\npicking this:\n  (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)", "."], ["proof (state)\nthis:\n  (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)\n\ngoal:\nNo subgoals!", "qed\n      \\<comment> \\<open>Hence we can apply the induction hypothesis and get the proposition\\<close>"], ["proof (state)\nthis:\n  (([uh], ceh), LCall q # wws @ w, [uh'], ce') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. r' = [] \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "from IHP(1)[OF _ NEWSL] SPLIT STEPFMT(2) IHP(4) CC C'(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>({#[entry fg p]#}, ww, {#uh # ?r#} + ceh) \\<in> trcl (ntr fg);\n   initialproc fg p; length [uh'] \\<le> 1;\n   LCall q # wws @ w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ww'.\n                       ({#[entry fg p]#}, ww', {#[uh'] @ ?r#} + ce')\n                       \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, ww, ch) \\<in> trcl (ntr fg)\n  (ch, ee, {#u # r#} + ce) \\<in> ntr fg\n  ch = add_mset (uh # rh) ceh\n  initialproc fg p\n  r' = []\n  r = uh' # rh", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>({#[entry fg p]#}, ww, {#uh # ?r#} + ceh) \\<in> trcl (ntr fg);\n   initialproc fg p; length [uh'] \\<le> 1;\n   LCall q # wws @ w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ww'.\n                       ({#[entry fg p]#}, ww', {#[uh'] @ ?r#} + ce')\n                       \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, ww, ch) \\<in> trcl (ntr fg)\n  (ch, ee, {#u # r#} + ce) \\<in> ntr fg\n  ch = add_mset (uh # rh) ceh\n  initialproc fg p\n  r' = []\n  r = uh' # rh\n\ngoal (1 subgoal):\n 1. \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "next\n    \\<comment> \\<open>If the sl/ret path was executed on a different thread than the last macrostep\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "case (env cc)"], ["proof (state)\nthis:\n  cet = {#u # r#} + cc\n  ce = {#vt # uh' # rh#} + cc\n  cet - {#u # r#} = cc\n  ce - {#vt # uh' # rh#} = cc\n\ngoal (1 subgoal):\n 1. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "note CASE=this\n    \\<comment> \\<open>we first look at the context after the last macrostep. It consists of the threads that already have been there and the threads that have been spawned by the last macrostep\\<close>"], ["proof (state)\nthis:\n  cet = {#u # r#} + cc\n  ce = {#vt # uh' # rh#} + cc\n  cet - {#u # r#} = cc\n  ce - {#vt # uh' # rh#} = cc\n\ngoal (1 subgoal):\n 1. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "from STEPFMT(5)"], ["proof (chain)\npicking this:\n  (([entry fg q], ceh), wws, [vt], cet) \\<in> trcl (trss fg)", "obtain cspt where CETFMT: \"cet=cspt+ceh\" \"!!s. s \\<in># cspt \\<Longrightarrow> \\<exists>p. s=[entry fg p] \\<and> initialproc fg p\""], ["proof (prove)\nusing this:\n  (([entry fg q], ceh), wws, [vt], cet) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>cspt.\n        \\<lbrakk>cet = cspt + ceh;\n         \\<And>s.\n            s \\<in># cspt \\<Longrightarrow>\n            \\<exists>p. s = [entry fg p] \\<and> initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold initialproc_def) (erule trss_c_cases, blast)\n    \\<comment> \\<open>The spawned threads do not hold any monitors yet\\<close>"], ["proof (state)\nthis:\n  cet = cspt + ceh\n  ?s \\<in># cspt \\<Longrightarrow>\n  \\<exists>p. ?s = [entry fg p] \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "hence CSPT_NO_MON: \"mon_c fg cspt = {}\""], ["proof (prove)\nusing this:\n  cet = cspt + ceh\n  ?s \\<in># cspt \\<Longrightarrow>\n  \\<exists>p. ?s = [entry fg p] \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. mon_c fg cspt = {}", "by (simp add: c_of_initial_no_mon)\n    \\<comment> \\<open>We now distinguish whether the sl/ret path is executed on a thread that was just spawned or on a thread that was already there\\<close>"], ["proof (state)\nthis:\n  mon_c fg cspt = {}\n\ngoal (1 subgoal):\n 1. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "from CASE(1) CETFMT(1)"], ["proof (chain)\npicking this:\n  cet = {#u # r#} + cc\n  cet = cspt + ceh", "have \"u#r \\<in># cspt+ceh\""], ["proof (prove)\nusing this:\n  cet = {#u # r#} + cc\n  cet = cspt + ceh\n\ngoal (1 subgoal):\n 1. u # r \\<in># cspt + ceh", "by auto"], ["proof (state)\nthis:\n  u # r \\<in># cspt + ceh\n\ngoal (1 subgoal):\n 1. \\<And>cc.\n       \\<lbrakk>cet = {#u # r#} + cc; ce = {#vt # uh' # rh#} + cc;\n        cet - {#u # r#} = cc; ce - {#vt # uh' # rh#} = cc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ww'.\n                            ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n                            \\<in> trcl (ntr fg)", "thus ?thesis"], ["proof (prove)\nusing this:\n  u # r \\<in># cspt + ceh\n\ngoal (1 subgoal):\n 1. \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "proof (cases rule: mset_un_cases[cases set]) \n      \\<comment> \\<open>The sl/ret path cannot have been executed on a freshly spawned thread due to the restrictions we made on the flowgraph\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. u # r \\<in># cspt \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "case left \\<comment> \\<open>Thread was spawned\\<close>"], ["proof (state)\nthis:\n  u # r \\<in># cspt\n\ngoal (2 subgoals):\n 1. u # r \\<in># cspt \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "with CETFMT"], ["proof (chain)\npicking this:\n  cet = cspt + ceh\n  ?s \\<in># cspt \\<Longrightarrow>\n  \\<exists>p. ?s = [entry fg p] \\<and> initialproc fg p\n  u # r \\<in># cspt", "obtain q where \"u=entry fg q\" \"r=[]\" \"initialproc fg q\""], ["proof (prove)\nusing this:\n  cet = cspt + ceh\n  ?s \\<in># cspt \\<Longrightarrow>\n  \\<exists>p. ?s = [entry fg p] \\<and> initialproc fg p\n  u # r \\<in># cspt\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>u = entry fg q; r = []; initialproc fg q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u = entry fg q\n  r = []\n  initialproc fg q\n\ngoal (2 subgoals):\n 1. u # r \\<in># cspt \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "with IHP(3,5,6) no_retsl_from_initial"], ["proof (chain)\npicking this:\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  length r' \\<le> 1\n  w \\<noteq> []\n  \\<lbrakk>?w \\<noteq> []; initialproc fg ?p;\n   (([entry fg ?p], ?c), ?w, ?r', ?c') \\<in> trcl (trss fg);\n   length ?r' \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> False\n  u = entry fg q\n  r = []\n  initialproc fg q", "have False"], ["proof (prove)\nusing this:\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  length r' \\<le> 1\n  w \\<noteq> []\n  \\<lbrakk>?w \\<noteq> []; initialproc fg ?p;\n   (([entry fg ?p], ?c), ?w, ?r', ?c') \\<in> trcl (trss fg);\n   length ?r' \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> False\n  u = entry fg q\n  r = []\n  initialproc fg q\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. u # r \\<in># cspt \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n 2. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", ".."], ["proof (state)\nthis:\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "next\n      \\<comment> \\<open>Hence let's assume the sl/ret path is executed on a thread that was already there before the last macrostep\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "case right"], ["proof (state)\nthis:\n  u # r \\<in># ceh\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "note CC=this \n      \\<comment> \\<open>We can write the configuration before the last macrostep in a way that one sees the thread that executed the sl/ret path\\<close>"], ["proof (state)\nthis:\n  u # r \\<in># ceh\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "hence CEHFMT: \"ceh={# u#r #}+(ceh-{# u#r #})\""], ["proof (prove)\nusing this:\n  u # r \\<in># ceh\n\ngoal (1 subgoal):\n 1. ceh = {#u # r#} + (ceh - {#u # r#})", "by auto"], ["proof (state)\nthis:\n  ceh = {#u # r#} + (ceh - {#u # r#})\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "have CHFMT: \"ch = {# u#r #} + ({# uh#rh #}+(ceh-{# u#r #}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ch = {#u # r#} + ({#uh # rh#} + (ceh - {#u # r#}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ch = {#u # r#} + ({#uh # rh#} + (ceh - {#u # r#}))", "from CEHFMT STEPFMT(2)"], ["proof (chain)\npicking this:\n  ceh = {#u # r#} + (ceh - {#u # r#})\n  ch = add_mset (uh # rh) ceh", "have \"ch = {# uh#rh #} + ({# u#r #}+(ceh-{# u#r #}))\""], ["proof (prove)\nusing this:\n  ceh = {#u # r#} + (ceh - {#u # r#})\n  ch = add_mset (uh # rh) ceh\n\ngoal (1 subgoal):\n 1. ch = {#uh # rh#} + ({#u # r#} + (ceh - {#u # r#}))", "by simp"], ["proof (state)\nthis:\n  ch = {#uh # rh#} + ({#u # r#} + (ceh - {#u # r#}))\n\ngoal (1 subgoal):\n 1. ch = {#u # r#} + ({#uh # rh#} + (ceh - {#u # r#}))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ch = {#uh # rh#} + ({#u # r#} + (ceh - {#u # r#}))\n\ngoal (1 subgoal):\n 1. ch = {#u # r#} + ({#uh # rh#} + (ceh - {#u # r#}))", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  ch = {#u # r#} + ({#uh # rh#} + (ceh - {#u # r#}))\n\ngoal:\nNo subgoals!", "qed\n      \\<comment> \\<open>There are not more monitors than after the last macrostep\\<close>"], ["proof (state)\nthis:\n  ch = {#u # r#} + ({#uh # rh#} + (ceh - {#u # r#}))\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "have MON_CE: \"mon_c fg ({# uh#rh #}+(ceh-{# u#r #})) \\<subseteq> mon_c fg ce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce", "have \"mon_n fg uh \\<subseteq> mon_n fg uh'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_n fg uh \\<subseteq> mon_n fg uh'", "using STEPFMT(4)"], ["proof (prove)\nusing this:\n  ((uh # rh, ceh), LCall q, entry fg q # uh' # rh, ceh) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. mon_n fg uh \\<subseteq> mon_n fg uh'", "by (auto elim!: trss.cases dest: mon_n_same_proc edges_part)"], ["proof (state)\nthis:\n  mon_n fg uh \\<subseteq> mon_n fg uh'\n\ngoal (1 subgoal):\n 1. mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce", "moreover"], ["proof (state)\nthis:\n  mon_n fg uh \\<subseteq> mon_n fg uh'\n\ngoal (1 subgoal):\n 1. mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce", "have \"mon_c fg (ceh-{#u#r#}) \\<subseteq> mon_c fg cc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc", "from CASE(3) CETFMT"], ["proof (chain)\npicking this:\n  cet - {#u # r#} = cc\n  cet = cspt + ceh\n  ?s \\<in># cspt \\<Longrightarrow>\n  \\<exists>p. ?s = [entry fg p] \\<and> initialproc fg p", "have \"cc=(cspt+ceh)-{#u#r#}\""], ["proof (prove)\nusing this:\n  cet - {#u # r#} = cc\n  cet = cspt + ceh\n  ?s \\<in># cspt \\<Longrightarrow>\n  \\<exists>p. ?s = [entry fg p] \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. cc = cspt + ceh - {#u # r#}", "by simp"], ["proof (state)\nthis:\n  cc = cspt + ceh - {#u # r#}\n\ngoal (1 subgoal):\n 1. mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc", "with CC"], ["proof (chain)\npicking this:\n  u # r \\<in># ceh\n  cc = cspt + ceh - {#u # r#}", "have \"cc = cspt+(ceh-{#u#r#})\""], ["proof (prove)\nusing this:\n  u # r \\<in># ceh\n  cc = cspt + ceh - {#u # r#}\n\ngoal (1 subgoal):\n 1. cc = cspt + (ceh - {#u # r#})", "by auto"], ["proof (state)\nthis:\n  cc = cspt + (ceh - {#u # r#})\n\ngoal (1 subgoal):\n 1. mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc", "with CSPT_NO_MON"], ["proof (chain)\npicking this:\n  mon_c fg cspt = {}\n  cc = cspt + (ceh - {#u # r#})", "show ?thesis"], ["proof (prove)\nusing this:\n  mon_c fg cspt = {}\n  cc = cspt + (ceh - {#u # r#})\n\ngoal (1 subgoal):\n 1. mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc\n\ngoal (1 subgoal):\n 1. mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce", "ultimately"], ["proof (chain)\npicking this:\n  mon_n fg uh \\<subseteq> mon_n fg uh'\n  mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc", "show ?thesis"], ["proof (prove)\nusing this:\n  mon_n fg uh \\<subseteq> mon_n fg uh'\n  mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc\n\ngoal (1 subgoal):\n 1. mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce", "using CASE(2)"], ["proof (prove)\nusing this:\n  mon_n fg uh \\<subseteq> mon_n fg uh'\n  mon_c fg (ceh - {#u # r#}) \\<subseteq> mon_c fg cc\n  ce = {#vt # uh' # rh#} + cc\n\ngoal (1 subgoal):\n 1. mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce\n\ngoal:\nNo subgoals!", "qed\n      \\<comment> \\<open>The same-level path preserves the threads in its environment and the threads that it creates hold no monitors\\<close>"], ["proof (state)\nthis:\n  mon_c fg ({#uh # rh#} + (ceh - {#u # r#})) \\<subseteq> mon_c fg ce\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "from IHP(3)"], ["proof (chain)\npicking this:\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)", "obtain csp' where CE'FMT: \"ce'=csp'+ce\" \"mon_c fg csp' = {}\""], ["proof (prove)\nusing this:\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>csp'.\n        \\<lbrakk>ce' = csp' + ce; mon_c fg csp' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (-) (erule trss_c_cases, blast intro!: c_of_initial_no_mon)\n      \\<comment> \\<open>We can execute the sl/ret-path also from the configuration before the last step\\<close>"], ["proof (state)\nthis:\n  ce' = csp' + ce\n  mon_c fg csp' = {}\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "from trss_xchange_context[OF _ MON_CE] IHP(3) CE'FMT"], ["proof (chain)\npicking this:\n  ((?s, ce), ?w, ?s', ?csp + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n  ((?s, {#uh # rh#} + (ceh - {#u # r#})), ?w, ?s',\n   ?csp + ({#uh # rh#} + (ceh - {#u # r#})))\n  \\<in> trcl (trss fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  ce' = csp' + ce\n  mon_c fg csp' = {}", "have NSL: \"(([u], {#uh # rh#} + (ceh - {#u # r#})), w, r', csp' + ({#uh # rh#} + (ceh - {#u # r#}))) \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((?s, ce), ?w, ?s', ?csp + ce) \\<in> trcl (trss fg) \\<Longrightarrow>\n  ((?s, {#uh # rh#} + (ceh - {#u # r#})), ?w, ?s',\n   ?csp + ({#uh # rh#} + (ceh - {#u # r#})))\n  \\<in> trcl (trss fg)\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  ce' = csp' + ce\n  mon_c fg csp' = {}\n\ngoal (1 subgoal):\n 1. (([u], {#uh # rh#} + (ceh - {#u # r#})), w, r',\n     csp' + ({#uh # rh#} + (ceh - {#u # r#})))\n    \\<in> trcl (trss fg)", "by auto \n      \\<comment> \\<open>And with the induction hypothesis we get a normalized path\\<close>"], ["proof (state)\nthis:\n  (([u], {#uh # rh#} + (ceh - {#u # r#})), w, r',\n   csp' + ({#uh # rh#} + (ceh - {#u # r#})))\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "from IHP(1)[OF _ NSL IHP(4,5,6)] SPLIT(1) CHFMT"], ["proof (chain)\npicking this:\n  ({#[entry fg p]#}, ww, {#u # ?r#} + ({#uh # rh#} + (ceh - {#u # r#})))\n  \\<in> trcl (ntr fg) \\<Longrightarrow>\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww',\n      {#r' @ ?r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))))\n     \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, ww, ch) \\<in> trcl (ntr fg)\n  ch = {#u # r#} + ({#uh # rh#} + (ceh - {#u # r#}))", "obtain ww' where NNPATH: \"({#[entry fg p]#}, ww', {#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#})))) \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  ({#[entry fg p]#}, ww, {#u # ?r#} + ({#uh # rh#} + (ceh - {#u # r#})))\n  \\<in> trcl (ntr fg) \\<Longrightarrow>\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww',\n      {#r' @ ?r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))))\n     \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, ww, ch) \\<in> trcl (ntr fg)\n  ch = {#u # r#} + ({#uh # rh#} + (ceh - {#u # r#}))\n\ngoal (1 subgoal):\n 1. (\\<And>ww'.\n        ({#[entry fg p]#}, ww',\n         {#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))))\n        \\<in> trcl (ntr fg) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast\n      \\<comment> \\<open>We now show that the last macrostep can also be executed from the new configuration, after the sl/ret path has been executed (on another thread)\\<close>"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, ww',\n   {#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))))\n  \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "have \"({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee, {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))) \\<in> ntr fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "proof -\n        \\<comment> \\<open>This is because the sl/ret path has not allocated any monitors\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "have MON_CEH: \"mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#}))) \\<subseteq> mon_c fg ceh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n    \\<subseteq> mon_c fg ceh", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n    \\<subseteq> mon_c fg ceh", "from IHP(3,5) trss_bot_proc_const[of \"[]\" u ce w \"[]\" _ ce'] mon_n_same_proc"], ["proof (chain)\npicking this:\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  length r' \\<le> 1\n  (([] @ [u], ce), w, [] @ [?u'], ce')\n  \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg u = proc_of fg ?u'\n  proc_of ?fg ?n = proc_of ?fg ?n' \\<Longrightarrow>\n  mon_n ?fg ?n = mon_n ?fg ?n'", "have \"mon_s fg r' \\<subseteq> mon_n fg u\""], ["proof (prove)\nusing this:\n  (([u], ce), w, r', ce') \\<in> trcl (trss fg)\n  length r' \\<le> 1\n  (([] @ [u], ce), w, [] @ [?u'], ce')\n  \\<in> trcl (trss fg) \\<Longrightarrow>\n  proc_of fg u = proc_of fg ?u'\n  proc_of ?fg ?n = proc_of ?fg ?n' \\<Longrightarrow>\n  mon_n ?fg ?n = mon_n ?fg ?n'\n\ngoal (1 subgoal):\n 1. mon_s fg r' \\<subseteq> mon_n fg u", "by (cases r') (simp, force)"], ["proof (state)\nthis:\n  mon_s fg r' \\<subseteq> mon_n fg u\n\ngoal (1 subgoal):\n 1. mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n    \\<subseteq> mon_c fg ceh", "moreover"], ["proof (state)\nthis:\n  mon_s fg r' \\<subseteq> mon_n fg u\n\ngoal (1 subgoal):\n 1. mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n    \\<subseteq> mon_c fg ceh", "from CEHFMT"], ["proof (chain)\npicking this:\n  ceh = {#u # r#} + (ceh - {#u # r#})", "have \"mon_c fg ceh = mon_c fg ({#u # r#} + (ceh - {#u # r#}))\""], ["proof (prove)\nusing this:\n  ceh = {#u # r#} + (ceh - {#u # r#})\n\ngoal (1 subgoal):\n 1. mon_c fg ceh = mon_c fg ({#u # r#} + (ceh - {#u # r#}))", "by simp \\<comment> \\<open>Need to state this explicitly because of recursive simp rule @{thm CEHFMT}\\<close>"], ["proof (state)\nthis:\n  mon_c fg ceh = mon_c fg ({#u # r#} + (ceh - {#u # r#}))\n\ngoal (1 subgoal):\n 1. mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n    \\<subseteq> mon_c fg ceh", "ultimately"], ["proof (chain)\npicking this:\n  mon_s fg r' \\<subseteq> mon_n fg u\n  mon_c fg ceh = mon_c fg ({#u # r#} + (ceh - {#u # r#}))", "show ?thesis"], ["proof (prove)\nusing this:\n  mon_s fg r' \\<subseteq> mon_n fg u\n  mon_c fg ceh = mon_c fg ({#u # r#} + (ceh - {#u # r#}))\n\ngoal (1 subgoal):\n 1. mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n    \\<subseteq> mon_c fg ceh", "using CE'FMT(2)"], ["proof (prove)\nusing this:\n  mon_s fg r' \\<subseteq> mon_n fg u\n  mon_c fg ceh = mon_c fg ({#u # r#} + (ceh - {#u # r#}))\n  mon_c fg csp' = {}\n\ngoal (1 subgoal):\n 1. mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n    \\<subseteq> mon_c fg ceh", "by (auto simp add: mon_c_unconc mon_s_unconc)"], ["proof (state)\nthis:\n  mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n  \\<subseteq> mon_c fg ceh\n\ngoal:\nNo subgoals!", "qed\n        \\<comment> \\<open>And we can reassemble the macrostep within the new context\\<close>"], ["proof (state)\nthis:\n  mon_c fg ({#r' @ r#} + (csp' + (ceh - {#u # r#})))\n  \\<subseteq> mon_c fg ceh\n\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "note trss_xchange_context_s[OF _ MON_CEH, where csp=\"{#}\", simplified, OF STEPFMT(4)]"], ["proof (state)\nthis:\n  ((uh # rh, add_mset (r' @ r) (csp' + (ceh - {#u # r#}))), LCall q,\n   entry fg q # uh' # rh, add_mset (r' @ r) (csp' + (ceh - {#u # r#})))\n  \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "moreover"], ["proof (state)\nthis:\n  ((uh # rh, add_mset (r' @ r) (csp' + (ceh - {#u # r#}))), LCall q,\n   entry fg q # uh' # rh, add_mset (r' @ r) (csp' + (ceh - {#u # r#})))\n  \\<in> trss fg\n\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "from trss_xchange_context[OF _ MON_CEH, of \"[entry fg q]\" wws \"[vt]\" cspt] STEPFMT(5) CETFMT(1)"], ["proof (chain)\npicking this:\n  (([entry fg q], ceh), wws, [vt], cspt + ceh)\n  \\<in> trcl (trss fg) \\<Longrightarrow>\n  (([entry fg q], {#r' @ r#} + (csp' + (ceh - {#u # r#}))), wws, [vt],\n   cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n  \\<in> trcl (trss fg)\n  (([entry fg q], ceh), wws, [vt], cet) \\<in> trcl (trss fg)\n  cet = cspt + ceh", "have \n          \"(([entry fg q], {#r' @ r#} + (csp' + (ceh - {#u # r#}))), wws, [vt], cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))) \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (([entry fg q], ceh), wws, [vt], cspt + ceh)\n  \\<in> trcl (trss fg) \\<Longrightarrow>\n  (([entry fg q], {#r' @ r#} + (csp' + (ceh - {#u # r#}))), wws, [vt],\n   cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n  \\<in> trcl (trss fg)\n  (([entry fg q], ceh), wws, [vt], cet) \\<in> trcl (trss fg)\n  cet = cspt + ceh\n\ngoal (1 subgoal):\n 1. (([entry fg q], {#r' @ r#} + (csp' + (ceh - {#u # r#}))), wws, [vt],\n     cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n    \\<in> trcl (trss fg)", "by blast"], ["proof (state)\nthis:\n  (([entry fg q], {#r' @ r#} + (csp' + (ceh - {#u # r#}))), wws, [vt],\n   cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "moreover"], ["proof (state)\nthis:\n  (([entry fg q], {#r' @ r#} + (csp' + (ceh - {#u # r#}))), wws, [vt],\n   cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n  \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "note STEPFMT(1)"], ["proof (state)\nthis:\n  ee = LCall q # wws\n\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "ultimately"], ["proof (chain)\npicking this:\n  ((uh # rh, add_mset (r' @ r) (csp' + (ceh - {#u # r#}))), LCall q,\n   entry fg q # uh' # rh, add_mset (r' @ r) (csp' + (ceh - {#u # r#})))\n  \\<in> trss fg\n  (([entry fg q], {#r' @ r#} + (csp' + (ceh - {#u # r#}))), wws, [vt],\n   cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n  \\<in> trcl (trss fg)\n  ee = LCall q # wws", "have \"((uh#rh,({#r' @ r#} + (csp' + (ceh - {#u # r#})))),ee,(vt#uh'#rh,cspt+({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  ((uh # rh, add_mset (r' @ r) (csp' + (ceh - {#u # r#}))), LCall q,\n   entry fg q # uh' # rh, add_mset (r' @ r) (csp' + (ceh - {#u # r#})))\n  \\<in> trss fg\n  (([entry fg q], {#r' @ r#} + (csp' + (ceh - {#u # r#}))), wws, [vt],\n   cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n  \\<in> trcl (trss fg)\n  ee = LCall q # wws\n\ngoal (1 subgoal):\n 1. ((uh # rh, {#r' @ r#} + (csp' + (ceh - {#u # r#}))), ee, vt # uh' # rh,\n     cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n    \\<in> ntrs fg", "by (auto intro: ntrs.intros)"], ["proof (state)\nthis:\n  ((uh # rh, {#r' @ r#} + (csp' + (ceh - {#u # r#}))), ee, vt # uh' # rh,\n   cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))\n  \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "from gtrI_s[OF this]"], ["proof (chain)\npicking this:\n  (add_mset (uh # rh) ({#r' @ r#} + (csp' + (ceh - {#u # r#}))), ee,\n   add_mset (vt # uh' # rh)\n    (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> ntr fg", "show ?thesis"], ["proof (prove)\nusing this:\n  (add_mset (uh # rh) ({#r' @ r#} + (csp' + (ceh - {#u # r#}))), ee,\n   add_mset (vt # uh' # rh)\n    (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> ntr fg", "by (simp add: add_mset_commute)"], ["proof (state)\nthis:\n  ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n   {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> ntr fg\n\ngoal:\nNo subgoals!", "qed\n      \\<comment> \\<open>Finally we append the last macrostep to the normalized paths we obtained by the induction hypothesis\\<close>"], ["proof (state)\nthis:\n  ({#r' @ r#} + (csp' + ({#uh # rh#} + (ceh - {#u # r#}))), ee,\n   {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "from trcl_rev_cons[OF NNPATH this]"], ["proof (chain)\npicking this:\n  ({#[entry fg p]#}, ww' @ [ee],\n   {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> trcl (ntr fg)", "have \"({#[entry fg p]#}, ww' @ [ee], {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#}))))) \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  ({#[entry fg p]#}, ww' @ [ee],\n   {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. ({#[entry fg p]#}, ww' @ [ee],\n     {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n    \\<in> trcl (ntr fg)", ".\n      \\<comment> \\<open>And show that we got the right configuration\\<close>"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, ww' @ [ee],\n   {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "moreover"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, ww' @ [ee],\n   {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "from CC CETFMT CASE(3)[symmetric] CASE(2) CE'FMT(1)"], ["proof (chain)\npicking this:\n  u # r \\<in># ceh\n  cet = cspt + ceh\n  ?s \\<in># cspt \\<Longrightarrow>\n  \\<exists>p. ?s = [entry fg p] \\<and> initialproc fg p\n  cc = cet - {#u # r#}\n  ce = {#vt # uh' # rh#} + cc\n  ce' = csp' + ce", "have \"{#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))) = {# r'@r #}+ce'\""], ["proof (prove)\nusing this:\n  u # r \\<in># ceh\n  cet = cspt + ceh\n  ?s \\<in># cspt \\<Longrightarrow>\n  \\<exists>p. ?s = [entry fg p] \\<and> initialproc fg p\n  cc = cet - {#u # r#}\n  ce = {#vt # uh' # rh#} + cc\n  ce' = csp' + ce\n\ngoal (1 subgoal):\n 1. {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))) =\n    {#r' @ r#} + ce'", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))) =\n  {#r' @ r#} + ce'\n\ngoal (1 subgoal):\n 1. u # r \\<in># ceh \\<Longrightarrow>\n    \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "ultimately"], ["proof (chain)\npicking this:\n  ({#[entry fg p]#}, ww' @ [ee],\n   {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> trcl (ntr fg)\n  {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))) =\n  {#r' @ r#} + ce'", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#[entry fg p]#}, ww' @ [ee],\n   {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))))\n  \\<in> trcl (ntr fg)\n  {#vt # uh' # rh#} + (cspt + ({#r' @ r#} + (csp' + (ceh - {#u # r#})))) =\n  {#r' @ r#} + ce'\n\ngoal (1 subgoal):\n 1. \\<exists>ww'.\n       ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ww'.\n     ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally we can prove: {\\em Any reachable configuration can also be reached by a normalized path}.\n  With @{thm [source] eflowgraph.ntr_sl_move_left} we can easily show this lemma\n  With @{thm [source] eflowgraph.ntr_sl_move_left} we can easily show this   by induction on the reaching path. For the empty path, the proposition follows trivially.\n  Else we consider the last step. If it is a call, we can execute it as a macrostep and get the proposition. Otherwise the last step is a same-level (Base, Spawn) or returning (Ret) path of length 1, and\n  we can append it to the normalized path using @{thm [source] eflowgraph.ntr_sl_move_left}.\n\\<close>"], ["", "lemma (in eflowgraph) normalize: \"\\<lbrakk> \n    (cstart,w,c')\\<in>trcl (tr fg); \n    cstart={# [entry fg p] #}; \n    initialproc fg p \\<rbrakk> \n  \\<Longrightarrow> \\<exists>w'. ({# [entry fg p] #},w',c')\\<in>trcl (ntr fg)\"\n\\<comment> \\<open>The lemma is shown by induction on the reaching path\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cstart, w, c') \\<in> trcl (tr fg); cstart = {#[entry fg p]#};\n     initialproc fg p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w'.\n                         ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)", "proof (induct rule: trcl_rev_induct) \n  \\<comment> \\<open>The empty case is trivial, as the empty path is also a valid normalized path\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n 2. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "case empty"], ["proof (state)\nthis:\n  c_ = {#[entry fg p]#}\n  initialproc fg p\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n 2. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "thus ?case"], ["proof (prove)\nusing this:\n  c_ = {#[entry fg p]#}\n  initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<exists>w'. ({#[entry fg p]#}, w', c_) \\<in> trcl (ntr fg)", "by (auto intro: exI[of _ \"[]\"] )"], ["proof (state)\nthis:\n  \\<exists>w'. ({#[entry fg p]#}, w', c_) \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "case (snoc cstart w c e c')"], ["proof (state)\nthis:\n  (cstart, w, c) \\<in> trcl (tr fg)\n  (c, e, c') \\<in> tr fg\n  \\<lbrakk>cstart = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w'.\n                       ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n  cstart = {#[entry fg p]#}\n  initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "note IHP=this\n  \\<comment> \\<open>In the inductive case, we can assume that we have an already normalized path and need to append a last step\\<close>"], ["proof (state)\nthis:\n  (cstart, w, c) \\<in> trcl (tr fg)\n  (c, e, c') \\<in> tr fg\n  \\<lbrakk>cstart = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w'.\n                       ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n  cstart = {#[entry fg p]#}\n  initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "then"], ["proof (chain)\npicking this:\n  (cstart, w, c) \\<in> trcl (tr fg)\n  (c, e, c') \\<in> tr fg\n  \\<lbrakk>cstart = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w'.\n                       ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n  cstart = {#[entry fg p]#}\n  initialproc fg p", "obtain w' where IHP': \"({# [entry fg p] #},w',c)\\<in>trcl (ntr fg)\" \"(c,e,c')\\<in>tr fg\""], ["proof (prove)\nusing this:\n  (cstart, w, c) \\<in> trcl (tr fg)\n  (c, e, c') \\<in> tr fg\n  \\<lbrakk>cstart = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w'.\n                       ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n  cstart = {#[entry fg p]#}\n  initialproc fg p\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        \\<lbrakk>({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg);\n         (c, e, c') \\<in> tr fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n  \\<comment> \\<open>We make explicit the thread on that this last step was executed\\<close>"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n  (c, e, c') \\<in> tr fg\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "from gtr_find_thread[OF IHP'(2)]"], ["proof (chain)\npicking this:\n  (\\<And>s ce s' ce'.\n      \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n       ((s, ce), e, s', ce') \\<in> trss fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain s ce s' ce' where TSTEP: \"c = add_mset s ce\" \"c' = add_mset s' ce'\" \"((s, ce), e, (s', ce')) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  (\\<And>s ce s' ce'.\n      \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n       ((s, ce), e, s', ce') \\<in> trss fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>s ce s' ce'.\n        \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n         ((s, ce), e, s', ce') \\<in> trss fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast \n  \\<comment> \\<open>The proof is done by a case distinction whether the last step was a call or not\\<close>"], ["proof (state)\nthis:\n  c = add_mset s ce\n  c' = add_mset s' ce'\n  ((s, ce), e, s', ce') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "{\n    \\<comment> \\<open>Last step was a procedure call\\<close>"], ["proof (state)\nthis:\n  c = add_mset s ce\n  c' = add_mset s' ce'\n  ((s, ce), e, s', ce') \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "assume CASE: \"e=LCall q\" \n    \\<comment> \\<open>As it is the last step, the procedure call will not return and thus is a valid macrostep\\<close>"], ["proof (state)\nthis:\n  e = LCall q\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "have \"(c,LCall q # [], c')\\<in>ntr fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, [LCall q], c') \\<in> ntr fg", "using TSTEP CASE"], ["proof (prove)\nusing this:\n  c = add_mset s ce\n  c' = add_mset s' ce'\n  ((s, ce), e, s', ce') \\<in> trss fg\n  e = LCall q\n\ngoal (1 subgoal):\n 1. (c, [LCall q], c') \\<in> ntr fg", "by (auto elim!: trss.cases intro!: ntrs.intros gtrI_s trss.intros)\n    \\<comment> \\<open>That can be appended to the initial normalized path\\<close>"], ["proof (state)\nthis:\n  (c, [LCall q], c') \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "from trcl_rev_cons[OF IHP'(1) this]"], ["proof (chain)\npicking this:\n  ({#[entry fg p]#}, w' @ [[LCall q]], c') \\<in> trcl (ntr fg)", "have ?case"], ["proof (prove)\nusing this:\n  ({#[entry fg p]#}, w' @ [[LCall q]], c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "}"], ["proof (state)\nthis:\n  e = LCall ?q2 \\<Longrightarrow>\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "moreover"], ["proof (state)\nthis:\n  e = LCall ?q2 \\<Longrightarrow>\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "{\n    \\<comment> \\<open>Last step was no procedure call\\<close>"], ["proof (state)\nthis:\n  e = LCall ?q2 \\<Longrightarrow>\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "fix q a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "assume CASE: \"e=LBase a \\<or> e=LSpawn q \\<or> e=LRet\" \n    \\<comment> \\<open>Then it is a same-level or returning path\\<close>"], ["proof (state)\nthis:\n  e = LBase a \\<or> e = LSpawn q \\<or> e = LRet\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "with TSTEP(3)"], ["proof (chain)\npicking this:\n  ((s, ce), e, s', ce') \\<in> trss fg\n  e = LBase a \\<or> e = LSpawn q \\<or> e = LRet", "obtain u r r' where SLR: \"s=u#r\" \"s'=r'@r\" \"length r'\\<le>1\" \"(([u],ce),[e],(r',ce'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((s, ce), e, s', ce') \\<in> trss fg\n  e = LBase a \\<or> e = LSpawn q \\<or> e = LRet\n\ngoal (1 subgoal):\n 1. (\\<And>u r r'.\n        \\<lbrakk>s = u # r; s' = r' @ r; length r' \\<le> 1;\n         (([u], ce), [e], r', ce') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force elim!: trss.cases intro!: trss.intros) \n     \\<comment> \\<open>That can be appended to the normalized path using the @{thm ntr_sl_move_left} - lemma\\<close>"], ["proof (state)\nthis:\n  s = u # r\n  s' = r' @ r\n  length r' \\<le> 1\n  (([u], ce), [e], r', ce') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "from ntr_sl_move_left[OF _ SLR(4) IHP(5) SLR(3)] IHP'(1) TSTEP(1) SLR(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>({#[entry fg p]#}, ?ww, {#u # ?r#} + ce) \\<in> trcl (ntr fg);\n   [e] \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ww'.\n                       ({#[entry fg p]#}, ww', {#r' @ ?r#} + ce')\n                       \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n  c = add_mset s ce\n  s = u # r", "obtain ww' where \"({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>({#[entry fg p]#}, ?ww, {#u # ?r#} + ce) \\<in> trcl (ntr fg);\n   [e] \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ww'.\n                       ({#[entry fg p]#}, ww', {#r' @ ?r#} + ce')\n                       \\<in> trcl (ntr fg)\n  ({#[entry fg p]#}, w', c) \\<in> trcl (ntr fg)\n  c = add_mset s ce\n  s = u # r\n\ngoal (1 subgoal):\n 1. (\\<And>ww'.\n        ({#[entry fg p]#}, ww', {#r' @ r#} + ce')\n        \\<in> trcl (ntr fg) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "with SLR(2) TSTEP(2)"], ["proof (chain)\npicking this:\n  s' = r' @ r\n  c' = add_mset s' ce'\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)", "have ?case"], ["proof (prove)\nusing this:\n  s' = r' @ r\n  c' = add_mset s' ce'\n  ({#[entry fg p]#}, ww', {#r' @ r#} + ce') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)", "by auto"], ["proof (state)\nthis:\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "}"], ["proof (state)\nthis:\n  e = LBase ?a2 \\<or> e = LSpawn ?q2 \\<or> e = LRet \\<Longrightarrow>\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>c w c' e c''.\n       \\<lbrakk>(c, w, c') \\<in> trcl (tr fg); (c', e, c'') \\<in> tr fg;\n        \\<lbrakk>c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w'.\n                             ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg);\n        c = {#[entry fg p]#}; initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w'.\n                            ({#[entry fg p]#}, w', c'') \\<in> trcl (ntr fg)", "ultimately"], ["proof (chain)\npicking this:\n  e = LCall ?q2 \\<Longrightarrow>\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n  e = LBase ?a2 \\<or> e = LSpawn ?q2 \\<or> e = LRet \\<Longrightarrow>\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)", "show ?case"], ["proof (prove)\nusing this:\n  e = LCall ?q2 \\<Longrightarrow>\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n  e = LBase ?a2 \\<or> e = LSpawn ?q2 \\<or> e = LRet \\<Longrightarrow>\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)", "by (cases e, auto)"], ["proof (state)\nthis:\n  \\<exists>w'. ({#[entry fg p]#}, w', c') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As the main result of this section we get: {\\em A configuration is reachable if and only if it is also reachable via a normalized path}:\\<close>"], ["", "theorem (in eflowgraph) ntr_repr:\n  \"    (\\<exists>w. ({#[entry fg (main fg)]#},w,c)\\<in>trcl (tr fg)) \n   \\<longleftrightarrow> (\\<exists>w. ({#[entry fg (main fg)]#},w,c)\\<in>trcl (ntr fg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>w. ({#[entry fg (main fg)]#}, w, c) \\<in> trcl (tr fg)) =\n    (\\<exists>w. ({#[entry fg (main fg)]#}, w, c) \\<in> trcl (ntr fg))", "by (auto simp add: initialproc_def intro!: normalize ntr_is_tr)"], ["", "subsection \\<open>Properties of normalized path\\<close>"], ["", "text \\<open>Like a usual path, also a macrostep modifies one thread, spawns some threads and preserves the state of all the other threads. The spawned threads do not make any steps, thus they stay in their initial configurations.\\<close>"], ["", "lemma ntrs_c_cases_s[cases set]: \"\\<lbrakk> \n    ((s,c),w,(s',c'))\\<in>ntrs fg; \n    !!csp. \\<lbrakk> c'=csp+c; !!s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> \n                                         (u,Spawn p,v)\\<in>edges fg \\<and> \n                                         initialproc fg p \n           \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> ntrs fg;\n     \\<And>csp.\n        \\<lbrakk>c' = csp + c;\n         \\<And>s.\n            s \\<in># csp \\<Longrightarrow>\n            \\<exists>p u v.\n               s = [entry fg p] \\<and>\n               (u, Spawn p, v) \\<in> edges fg \\<and>\n               initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto dest!: ntrs_is_trss_s elim!: trss_c_cases)"], ["", "lemma ntrs_c_cases[cases set]: \"\\<lbrakk> \n    ((s,c),ww,(s',c'))\\<in>trcl (ntrs fg); \n    !!csp. \\<lbrakk> c'=csp+c; !!s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> \n                                         (u,Spawn p,v)\\<in>edges fg \\<and> \n                                         initialproc fg p \n           \\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n     \\<And>csp.\n        \\<lbrakk>c' = csp + c;\n         \\<And>s.\n            s \\<in># csp \\<Longrightarrow>\n            \\<exists>p u v.\n               s = [entry fg p] \\<and>\n               (u, Spawn p, v) \\<in> edges fg \\<and>\n               initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto dest!: ntrs_is_trss elim!: trss_c_cases)"], ["", "subsubsection \\<open>Validity\\<close>"], ["", "text \\<open>Like usual paths, also normalized paths preserve validity of the configurations.\\<close>"], ["", "lemmas (in flowgraph) ntrs_valid_preserve_s = trss_valid_preserve[OF ntrs_is_trss_s]"], ["", "lemmas (in flowgraph) ntr_valid_preserve_s = tr_valid_preserve[OF ntr_is_tr_s]"], ["", "lemmas (in flowgraph) ntrs_valid_preserve = trss_valid_preserve[OF ntrs_is_trss]"], ["", "lemmas (in flowgraph) ntr_valid_preserve = tr_valid_preserve[OF ntr_is_tr]"], ["", "lemma (in flowgraph) ntrp_valid_preserve_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrp fg\" \n  and V: \"valid fg (add_mset s c)\" \n  shows \"valid fg (add_mset s' c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg (add_mset s' c')", "using ntr_valid_preserve_s[OF gtrp2gtr_s[OF A] V]"], ["proof (prove)\nusing this:\n  valid fg (add_mset s' c')\n\ngoal (1 subgoal):\n 1. valid fg (add_mset s' c')", "by assumption"], ["", "lemma (in flowgraph) ntrp_valid_preserve: \n  assumes A: \"((s,c),e,(s',c'))\\<in>trcl (ntrp fg)\" \n  and V: \"valid fg (add_mset s c)\" \n  shows \"valid fg (add_mset s' c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg (add_mset s' c')", "using ntr_valid_preserve[OF gtrp2gtr[OF A] V]"], ["proof (prove)\nusing this:\n  valid fg (add_mset s' c')\n\ngoal (1 subgoal):\n 1. valid fg (add_mset s' c')", "by assumption"], ["", "subsubsection \\<open>Monitors\\<close>"], ["", "text \\<open>The following defines the set of monitors used by a normalized path and shows its basic properties:\\<close>"], ["", "definition \n  \"mon_ww fg ww == foldl (\\<union>) {} (map (mon_w fg) ww)\""], ["", "definition \n  \"mon_loc fg ww == mon_ww fg (map le_rem_s (loc ww))\""], ["", "definition \n  \"mon_env fg ww == mon_ww fg (map le_rem_s (env ww))\""], ["", "lemma mon_ww_empty[simp]: \"mon_ww fg [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_ww fg [] = {}", "by (unfold mon_ww_def, auto)"], ["", "lemma mon_ww_uncons[simp]: \n  \"mon_ww fg (ee#ww) = mon_w fg ee \\<union> mon_ww fg ww\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_ww fg (ee # ww) = mon_w fg ee \\<union> mon_ww fg ww", "by (unfold mon_ww_def, auto simp add: foldl_un_empty_eq[of \"mon_w fg ee\"])"], ["", "lemma mon_ww_unconc: \n  \"mon_ww fg (ww1@ww2) = mon_ww fg ww1 \\<union> mon_ww fg ww2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_ww fg (ww1 @ ww2) = mon_ww fg ww1 \\<union> mon_ww fg ww2", "by (induct ww1) auto"], ["", "lemma mon_env_empty[simp]: \"mon_env fg [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg [] = {}", "by (unfold mon_env_def) auto"], ["", "lemma mon_env_single[simp]: \n  \"mon_env fg [e] = (case e of LOC a \\<Rightarrow> {} | ENV a \\<Rightarrow> mon_w fg a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg [e] =\n    (case e of LOC a \\<Rightarrow> {} | ENV a \\<Rightarrow> mon_w fg a)", "by (unfold mon_env_def) (auto split: el_step.split)"], ["", "lemma mon_env_uncons[simp]: \n  \"mon_env fg (e#w) \n   = (case e of LOC a \\<Rightarrow> {} | ENV a \\<Rightarrow> mon_w fg a) \\<union> mon_env fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (e # w) =\n    (case e of LOC a \\<Rightarrow> {}\n     | ENV a \\<Rightarrow> mon_w fg a) \\<union>\n    mon_env fg w", "by (unfold mon_env_def) (auto split: el_step.split)"], ["", "lemma mon_env_unconc: \n  \"mon_env fg (w1@w2) = mon_env fg w1 \\<union> mon_env fg w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (w1 @ w2) = mon_env fg w1 \\<union> mon_env fg w2", "by (unfold mon_env_def) (auto simp add: mon_ww_unconc)"], ["", "lemma mon_loc_empty[simp]: \"mon_loc fg [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg [] = {}", "by (unfold mon_loc_def) auto"], ["", "lemma mon_loc_single[simp]: \n  \"mon_loc fg [e] = (case e of ENV a \\<Rightarrow> {} | LOC a \\<Rightarrow> mon_w fg a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg [e] =\n    (case e of LOC a \\<Rightarrow> mon_w fg a | ENV a \\<Rightarrow> {})", "by (unfold mon_loc_def) (auto split: el_step.split)"], ["", "lemma mon_loc_uncons[simp]: \n  \"mon_loc fg (e#w) \n  = (case e of ENV a \\<Rightarrow> {} | LOC a \\<Rightarrow> mon_w fg a) \\<union> mon_loc fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (e # w) =\n    (case e of LOC a \\<Rightarrow> mon_w fg a\n     | ENV a \\<Rightarrow> {}) \\<union>\n    mon_loc fg w", "by (unfold mon_loc_def) (auto split: el_step.split)"], ["", "lemma mon_loc_unconc: \n  \"mon_loc fg (w1@w2) = mon_loc fg w1 \\<union> mon_loc fg w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (w1 @ w2) = mon_loc fg w1 \\<union> mon_loc fg w2", "by (unfold mon_loc_def) (auto simp add: mon_ww_unconc)"], ["", "lemma mon_ww_of_foldl[simp]: \"mon_w fg (foldl (@) [] ww) = mon_ww fg ww\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_w fg (foldl (@) [] ww) = mon_ww fg ww", "apply (induct ww)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mon_w fg (foldl (@) [] []) = mon_ww fg []\n 2. \\<And>a ww.\n       mon_w fg (foldl (@) [] ww) = mon_ww fg ww \\<Longrightarrow>\n       mon_w fg (foldl (@) [] (a # ww)) = mon_ww fg (a # ww)", "apply (unfold mon_ww_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mon_w fg (foldl (@) [] []) = foldl (\\<union>) {} (map (mon_w fg) [])\n 2. \\<And>a ww.\n       mon_w fg (foldl (@) [] ww) =\n       foldl (\\<union>) {} (map (mon_w fg) ww) \\<Longrightarrow>\n       mon_w fg (foldl (@) [] (a # ww)) =\n       foldl (\\<union>) {} (map (mon_w fg) (a # ww))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ww.\n       mon_w fg (foldl (@) [] ww) =\n       foldl (\\<union>) {} (map (mon_w fg) ww) \\<Longrightarrow>\n       mon_w fg (foldl (@) [] (a # ww)) =\n       foldl (\\<union>) {} (map (mon_w fg) (a # ww))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ww.\n       mon_w fg (foldl (@) [] ww) =\n       foldl (\\<union>) {} (map (mon_w fg) ww) \\<Longrightarrow>\n       mon_w fg (foldl (@) a ww) =\n       foldl (\\<union>) (mon_w fg a) (map (mon_w fg) ww)", "apply (subst foldl_conc_empty_eq, subst foldl_un_empty_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ww.\n       mon_w fg (foldl (@) [] ww) =\n       foldl (\\<union>) {} (map (mon_w fg) ww) \\<Longrightarrow>\n       mon_w fg (a @ foldl (@) [] ww) =\n       mon_w fg a \\<union> foldl (\\<union>) {} (map (mon_w fg) ww)", "apply (simp add: mon_w_unconc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mon_ww_ileq: \"w\\<preceq>w' \\<Longrightarrow> mon_ww fg w \\<subseteq> mon_ww fg w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<preceq> w' \\<Longrightarrow> mon_ww fg w \\<subseteq> mon_ww fg w'", "by (induct rule: less_eq_list_induct) auto"], ["", "(* TODO: Find some general statement about the property that monitors are computed element-wise and pslit this lemma and move the essential part to ConsInterleave.thy. Maybe the essential part is cil_set ?*)"], ["", "lemma mon_ww_cil: \n  \"w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2 \\<Longrightarrow> mon_ww fg w = mon_ww fg w1 \\<union> mon_ww fg w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<Longrightarrow>\n    mon_ww fg w = mon_ww fg w1 \\<union> mon_ww fg w2", "by (induct rule: cil_set_induct_fix\\<alpha>) auto"], ["", "lemma mon_loc_cil: \n  \"w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2 \\<Longrightarrow> mon_loc fg w = mon_loc fg w1 \\<union> mon_loc fg w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<Longrightarrow>\n    mon_loc fg w = mon_loc fg w1 \\<union> mon_loc fg w2", "by (induct rule: cil_set_induct_fix\\<alpha>) auto"], ["", "lemma mon_env_cil: \n  \"w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>\\<^esub>w2 \\<Longrightarrow> mon_env fg w = mon_env fg w1 \\<union> mon_env fg w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>\\<^esub> w2 \\<Longrightarrow>\n    mon_env fg w = mon_env fg w1 \\<union> mon_env fg w2", "by (induct rule: cil_set_induct_fix\\<alpha>) auto"], ["", "lemma mon_ww_of_le_rem: \n  \"mon_ww fg (map le_rem_s w) = mon_loc fg w \\<union> mon_env fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s w) = mon_loc fg w \\<union> mon_env fg w", "by (induct w) (auto split: el_step.split)"], ["", "lemma mon_env_ileq: \"w\\<preceq>w' \\<Longrightarrow> mon_env fg w \\<subseteq> mon_env fg w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<preceq> w' \\<Longrightarrow> mon_env fg w \\<subseteq> mon_env fg w'", "by (induct rule: less_eq_list_induct) auto"], ["", "lemma mon_loc_ileq: \"w\\<preceq>w' \\<Longrightarrow> mon_loc fg w \\<subseteq> mon_loc fg w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<preceq> w' \\<Longrightarrow> mon_loc fg w \\<subseteq> mon_loc fg w'", "by (induct rule: less_eq_list_induct) auto"], ["", "lemma mon_loc_map_loc[simp]: \"mon_loc fg (map LOC w) = mon_ww fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (map LOC w) = mon_ww fg w", "by (unfold mon_loc_def) simp"], ["", "lemma mon_env_map_env[simp]: \"mon_env fg (map ENV w) = mon_ww fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (map ENV w) = mon_ww fg w", "by (unfold mon_env_def) simp"], ["", "lemma mon_loc_map_env[simp]: \"mon_loc fg (map ENV w) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_loc fg (map ENV w) = {}", "by (induct w) auto"], ["", "lemma mon_env_map_loc[simp]: \"mon_env fg (map LOC w) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_env fg (map LOC w) = {}", "by (induct w) auto\n\n\\<comment> \\<open>As monitors are syntactically bound to procedures, and each macrostep starts with a non-returning call, the set of monitors allocated during the execution of a normalized path is monotonically increasing\\<close>"], ["", "lemma (in flowgraph) ntrs_mon_increasing_s: \"((s,c),e,(s',c'))\\<in>ntrs fg \n  \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and> mon_c fg c = mon_c fg c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> ntrs fg \\<Longrightarrow>\n    mon_s fg s \\<subseteq> mon_s fg s' \\<and> mon_c fg c = mon_c fg c'", "apply (erule ntrs.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u r ce p u' w v ce'.\n       \\<lbrakk>s = u # r; c = ce; e = LCall p # w; s' = v # u' # r;\n        c' = ce';\n        ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg;\n        (([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and>\n                         mon_c fg c = mon_c fg c'", "apply (auto simp add: trss_c_no_mon)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u r p u' w v x.\n       \\<lbrakk>s = u # r; e = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg);\n        x \\<in> mon_n fg u; x \\<notin> mon_n fg v;\n        x \\<notin> mon_s fg r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_n fg u'", "apply (subgoal_tac \"mon_n fg u = mon_n fg u'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u r p u' w v x.\n       \\<lbrakk>s = u # r; e = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg);\n        x \\<in> mon_n fg u; x \\<notin> mon_n fg v; x \\<notin> mon_s fg r;\n        mon_n fg u = mon_n fg u'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_n fg u'\n 2. \\<And>u r p u' w v x.\n       \\<lbrakk>s = u # r; e = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg);\n        x \\<in> mon_n fg u; x \\<notin> mon_n fg v;\n        x \\<notin> mon_s fg r\\<rbrakk>\n       \\<Longrightarrow> mon_n fg u = mon_n fg u'", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u r p u' w v x.\n       \\<lbrakk>s = u # r; e = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg);\n        x \\<in> mon_n fg u; x \\<notin> mon_n fg v;\n        x \\<notin> mon_s fg r\\<rbrakk>\n       \\<Longrightarrow> mon_n fg u = mon_n fg u'", "apply (auto elim!: trss.cases dest!: mon_n_same_proc edges_part)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in flowgraph) ntr_mon_increasing_s: \n  \"(c,ee,c')\\<in>ntr fg \\<Longrightarrow> mon_c fg c \\<subseteq> mon_c fg c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, ee, c') \\<in> ntr fg \\<Longrightarrow>\n    mon_c fg c \\<subseteq> mon_c fg c'", "by (erule gtrE) (auto dest: ntrs_mon_increasing_s simp add: mon_c_unconc)"], ["", "(* FIXME: Quick&dirty proof *)"], ["", "lemma (in flowgraph) ntrp_mon_increasing_s: \"((s,c),e,(s',c'))\\<in>ntrp fg \n  \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and> mon_c fg c \\<subseteq> mon_c fg c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> ntrp fg \\<Longrightarrow>\n    mon_s fg s \\<subseteq> mon_s fg s' \\<and>\n    mon_c fg c \\<subseteq> mon_c fg c'", "apply (erule gtrp.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa ca ea s'a c'a.\n       \\<lbrakk>s = sa; c = ca; e = LOC ea; s' = s'a; c' = c'a;\n        ((sa, ca), ea, s'a, c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and>\n                         mon_c fg c \\<subseteq> mon_c fg c'\n 2. \\<And>sa sl ca ea s'a c'a.\n       \\<lbrakk>s = sl; c = add_mset sa ca; e = ENV ea; s' = sl;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset sl ca), ea, s'a, add_mset sl c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and>\n                         mon_c fg c \\<subseteq> mon_c fg c'", "apply (auto dest: ntrs_mon_increasing_s simp add: mon_c_unconc)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa sl ca ea s'a c'a.\n       \\<lbrakk>s = sl; c = add_mset sa ca; e = ENV ea; s' = sl;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset sl ca), ea, s'a, add_mset sl c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and>\n                         mon_c fg c \\<subseteq> mon_c fg c'", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa sl ca ea s'a c'a.\n       \\<lbrakk>s = sl; c = add_mset sa ca; e = ENV ea; s' = sl;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset sl ca), ea, s'a, add_mset sl c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s'\n 2. \\<And>sa sl ca ea s'a c'a.\n       \\<lbrakk>s = sl; c = add_mset sa ca; e = ENV ea; s' = sl;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset sl ca), ea, s'a, add_mset sl c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c \\<subseteq> mon_c fg c'", "apply (auto dest: ntrs_mon_increasing_s simp add: mon_c_unconc)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa sl ca ea s'a c'a.\n       \\<lbrakk>s = sl; c = add_mset sa ca; e = ENV ea; s' = sl;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset sl ca), ea, s'a, add_mset sl c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> mon_c fg c \\<subseteq> mon_c fg c'", "apply (auto dest: ntrs_mon_increasing_s simp add: mon_c_unconc)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa ca ea s'a c'a x.\n       \\<lbrakk>c = add_mset sa ca; e = ENV ea; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), ea, s'a, add_mset s c'a) \\<in> ntrs fg;\n        x \\<in> mon_c fg ca; x \\<notin> mon_c fg c'a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_s fg s'a", "apply (erule ntrs_c_cases_s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa ca ea s'a c'a x csp.\n       \\<lbrakk>c = add_mset sa ca; e = ENV ea; s' = s;\n        c' = add_mset s'a c'a; x \\<in> mon_c fg ca; x \\<notin> mon_c fg c'a;\n        add_mset s c'a = csp + add_mset s ca;\n        \\<And>s.\n           s \\<in># csp \\<Longrightarrow>\n           \\<exists>p u v.\n              s = [entry fg p] \\<and>\n              (u, Spawn p, v) \\<in> edges fg \\<and>\n              initialproc fg p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mon_s fg s'a", "apply (auto simp: mon_c_unconc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in flowgraph) ntrp_mon_increasing: \"((s,c),e,(s',c'))\\<in>trcl (ntrp fg) \n  \\<Longrightarrow> mon_s fg s \\<subseteq> mon_s fg s' \\<and> mon_c fg c \\<subseteq> mon_c fg c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), e, s', c') \\<in> trcl (ntrp fg) \\<Longrightarrow>\n    mon_s fg s \\<subseteq> mon_s fg s' \\<and>\n    mon_c fg c \\<subseteq> mon_c fg c'", "by (induct rule: trcl_rev_pair_induct) (auto dest!: ntrp_mon_increasing_s)"], ["", "subsubsection \\<open>Modifying the context\\<close>"], ["", "lemmas (in flowgraph) ntrs_c_no_mon_s = trss_c_no_mon[OF ntrs_is_trss_s]"], ["", "lemmas (in flowgraph) ntrs_c_no_mon = trss_c_no_mon[OF ntrs_is_trss]"], ["", "text \\<open>Also like a usual path, a normalized step must not use any monitors that are allocated by other threads\\<close>"], ["", "lemmas (in flowgraph) ntrs_mon_e_no_ctx = trss_mon_w_no_ctx[OF ntrs_is_trss_s]"], ["", "lemma (in flowgraph) ntrs_mon_w_no_ctx: \n  assumes A: \"((s,c),w,(s',c'))\\<in>trcl (ntrs fg)\" \n  shows \"mon_ww fg w \\<inter> mon_c fg c = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_ww fg w \\<inter> mon_c fg c = {}", "using trss_mon_w_no_ctx[OF ntrs_is_trss[OF A]]"], ["proof (prove)\nusing this:\n  mon_w fg (foldl (@) [] w) \\<inter> mon_c fg c = {}\n\ngoal (1 subgoal):\n 1. mon_ww fg w \\<inter> mon_c fg c = {}", "by simp"], ["", "lemma (in flowgraph) ntrp_mon_env_e_no_ctx: \n  \"((s,c),ENV e,(s',c'))\\<in>ntrp fg \\<Longrightarrow> mon_w fg e \\<inter> mon_s fg s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), ENV e, s', c') \\<in> ntrp fg \\<Longrightarrow>\n    mon_w fg e \\<inter> mon_s fg s = {}", "by (auto elim!: gtrp.cases dest!: ntrs_mon_e_no_ctx simp add: mon_c_unconc)"], ["", "lemma (in flowgraph) ntrp_mon_loc_e_no_ctx: \n  \"((s,c),LOC e,(s',c'))\\<in>ntrp fg \\<Longrightarrow> mon_w fg e \\<inter> mon_c fg c = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), LOC e, s', c') \\<in> ntrp fg \\<Longrightarrow>\n    mon_w fg e \\<inter> mon_c fg c = {}", "by (auto elim!: gtrp.cases dest!: ntrs_mon_e_no_ctx)"], ["", "lemma (in flowgraph) ntrp_mon_env_w_no_ctx: \n  \"((s,c),w,(s',c'))\\<in>trcl (ntrp fg) \\<Longrightarrow> mon_env fg w \\<inter> mon_s fg s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (ntrp fg) \\<Longrightarrow>\n    mon_env fg w \\<inter> mon_s fg s = {}", "by (induct rule: trcl_rev_pair_induct) (unfold mon_env_def, auto split: el_step.split dest!: ntrp_mon_env_e_no_ctx ntrp_mon_increasing simp add: mon_ww_unconc)"], ["", "lemma (in flowgraph) ntrp_mon_loc_w_no_ctx: \n  \"((s,c),w,(s',c'))\\<in>trcl (ntrp fg) \\<Longrightarrow> mon_loc fg w \\<inter> mon_c fg c = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (ntrp fg) \\<Longrightarrow>\n    mon_loc fg w \\<inter> mon_c fg c = {}", "by (induct rule: trcl_rev_pair_induct) (unfold mon_loc_def, auto split: el_step.split dest!: ntrp_mon_loc_e_no_ctx ntrp_mon_increasing simp add: mon_ww_unconc)"], ["", "text \\<open>\n  The next lemmas are rules how to add or remove threads while preserving the executability of a path\n\\<close>"], ["", "(* TODO: There are far too many {ntrs,ntrp}_{add,drop,replace,modify,xchange}_context - lemmas, try to give them a good sructure, find the most general cases and derive the other ones from these cases *)"], ["", "lemma (in flowgraph) ntrs_modify_context_s: \n  assumes A: \"((s,c),ee,(s',c'))\\<in>ntrs fg\" \n  and B: \"mon_w fg ee \\<inter> mon_c fg cn = {}\" \n  shows \"\\<exists>csp. c'=csp+c \\<and> mon_c fg csp={} \\<and> ((s,cn),ee,(s',csp+cn))\\<in>ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "from A"], ["proof (chain)\npicking this:\n  ((s, c), ee, s', c') \\<in> ntrs fg", "obtain p r u u' v w where S: \"s=u#r\" \"ee=LCall p#w\" \"s'=v#u'#r\" \"((u#r,c),LCall p,(entry fg p#u'#r,c))\\<in>trss fg\" \"(([entry fg p],c),w,([v],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ((s, c), ee, s', c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>u r p w v u'.\n        \\<lbrakk>s = u # r; ee = LCall p # w; s' = v # u' # r;\n         ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n         (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim!: ntrs.cases[simplified])"], ["proof (state)\nthis:\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "with trss_modify_context_s[OF S(4)] B"], ["proof (chain)\npicking this:\n  mon_e fg (LCall p) \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c = csp + c \\<and>\n     mon_c fg csp = {} \\<and>\n     ((u # r, ?cn), LCall p, entry fg p # u' # r, csp + ?cn) \\<in> trss fg\n  mon_w fg ee \\<inter> mon_c fg cn = {}\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)", "have \"((u#r,cn),LCall p,(entry fg p#u'#r,cn))\\<in>trss fg\""], ["proof (prove)\nusing this:\n  mon_e fg (LCall p) \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c = csp + c \\<and>\n     mon_c fg csp = {} \\<and>\n     ((u # r, ?cn), LCall p, entry fg p # u' # r, csp + ?cn) \\<in> trss fg\n  mon_w fg ee \\<inter> mon_c fg cn = {}\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((u # r, cn), LCall p, entry fg p # u' # r, cn) \\<in> trss fg", "by auto"], ["proof (state)\nthis:\n  ((u # r, cn), LCall p, entry fg p # u' # r, cn) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "moreover"], ["proof (state)\nthis:\n  ((u # r, cn), LCall p, entry fg p # u' # r, cn) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "from S trss_modify_context[OF S(5)] B"], ["proof (chain)\npicking this:\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c' = csp + c \\<and>\n     mon_c fg csp = {} \\<and>\n     (([entry fg p], ?cn), w, [v], csp + ?cn) \\<in> trcl (trss fg)\n  mon_w fg ee \\<inter> mon_c fg cn = {}", "obtain csp where \"c'=csp+c\" \"mon_c fg csp = {}\" \"(([entry fg p],cn),w,([v],csp+cn))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n  mon_w fg w \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c' = csp + c \\<and>\n     mon_c fg csp = {} \\<and>\n     (([entry fg p], ?cn), w, [v], csp + ?cn) \\<in> trcl (trss fg)\n  mon_w fg ee \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        \\<lbrakk>c' = csp + c; mon_c fg csp = {};\n         (([entry fg p], cn), w, [v], csp + cn)\n         \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c' = csp + c\n  mon_c fg csp = {}\n  (([entry fg p], cn), w, [v], csp + cn) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "ultimately"], ["proof (chain)\npicking this:\n  ((u # r, cn), LCall p, entry fg p # u' # r, cn) \\<in> trss fg\n  c' = csp + c\n  mon_c fg csp = {}\n  (([entry fg p], cn), w, [v], csp + cn) \\<in> trcl (trss fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((u # r, cn), LCall p, entry fg p # u' # r, cn) \\<in> trss fg\n  c' = csp + c\n  mon_c fg csp = {}\n  (([entry fg p], cn), w, [v], csp + cn) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "using S"], ["proof (prove)\nusing this:\n  ((u # r, cn), LCall p, entry fg p # u' # r, cn) \\<in> trss fg\n  c' = csp + c\n  mon_c fg csp = {}\n  (([entry fg p], cn), w, [v], csp + cn) \\<in> trcl (trss fg)\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "by (auto intro!: ntrs_step)"], ["proof (state)\nthis:\n  \\<exists>csp.\n     c' = csp + c \\<and>\n     mon_c fg csp = {} \\<and> ((s, cn), ee, s', csp + cn) \\<in> ntrs fg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) ntrs_modify_context[rule_format]: \"\n  \\<lbrakk>((s,c),w,(s',c'))\\<in>trcl (ntrs fg)\\<rbrakk> \n    \\<Longrightarrow> \\<forall>cn. mon_ww fg w \\<inter> mon_c fg cn = {} \n        \\<longrightarrow> (\\<exists>csp. c'=csp+c \\<and> mon_c fg csp = {} \\<and> \n              ((s,cn),w,(s',csp+cn))\\<in>trcl (ntrs fg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), w, s', c') \\<in> trcl (ntrs fg) \\<Longrightarrow>\n    \\<forall>cn.\n       mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n       (\\<exists>csp.\n           c' = csp + c \\<and>\n           mon_c fg csp = {} \\<and>\n           ((s, cn), w, s', csp + cn) \\<in> trcl (ntrs fg))", "proof (induct rule: trcl_pair_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<forall>cn.\n          mon_ww fg [] \\<inter> mon_c fg cn = {} \\<longrightarrow>\n          (\\<exists>csp.\n              b = csp + b \\<and>\n              mon_c fg csp = {} \\<and>\n              ((a, cn), [], a, csp + cn) \\<in> trcl (ntrs fg))\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        \\<forall>cn.\n           mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (ntrs fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_ww fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (ntrs fg))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<forall>cn.\n          mon_ww fg [] \\<inter> mon_c fg cn = {} \\<longrightarrow>\n          (\\<exists>csp.\n              b = csp + b \\<and>\n              mon_c fg csp = {} \\<and>\n              ((a, cn), [], a, csp + cn) \\<in> trcl (ntrs fg))\n 2. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        \\<forall>cn.\n           mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (ntrs fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_ww fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (ntrs fg))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cn.\n       mon_ww fg [] \\<inter> mon_c fg cn = {} \\<longrightarrow>\n       (\\<exists>csp.\n           b_ = csp + b_ \\<and>\n           mon_c fg csp = {} \\<and>\n           ((a_, cn), [], a_, csp + cn) \\<in> trcl (ntrs fg))", "by simp"], ["proof (state)\nthis:\n  \\<forall>cn.\n     mon_ww fg [] \\<inter> mon_c fg cn = {} \\<longrightarrow>\n     (\\<exists>csp.\n         b_ = csp + b_ \\<and>\n         mon_c fg csp = {} \\<and>\n         ((a_, cn), [], a_, csp + cn) \\<in> trcl (ntrs fg))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        \\<forall>cn.\n           mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (ntrs fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_ww fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (ntrs fg))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        \\<forall>cn.\n           mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (ntrs fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_ww fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (ntrs fg))", "case (cons s c e sh ch w s' c')"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> ntrs fg\n  ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\n  \\<forall>cn.\n     mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n     (\\<exists>csp.\n         c' = csp + ch \\<and>\n         mon_c fg csp = {} \\<and>\n         ((sh, cn), w, s', csp + cn) \\<in> trcl (ntrs fg))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        \\<forall>cn.\n           mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (ntrs fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_ww fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (ntrs fg))", "note IHP=this"], ["proof (state)\nthis:\n  ((s, c), e, sh, ch) \\<in> ntrs fg\n  ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\n  \\<forall>cn.\n     mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n     (\\<exists>csp.\n         c' = csp + ch \\<and>\n         mon_c fg csp = {} \\<and>\n         ((sh, cn), w, s', csp + cn) \\<in> trcl (ntrs fg))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba w ac bb.\n       \\<lbrakk>((a, b), aa, ab, ba) \\<in> ntrs fg;\n        ((ab, ba), w, ac, bb) \\<in> trcl (ntrs fg);\n        \\<forall>cn.\n           mon_ww fg w \\<inter> mon_c fg cn = {} \\<longrightarrow>\n           (\\<exists>csp.\n               bb = csp + ba \\<and>\n               mon_c fg csp = {} \\<and>\n               ((ab, cn), w, ac, csp + cn) \\<in> trcl (ntrs fg))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>cn.\n                            mon_ww fg (aa # w) \\<inter> mon_c fg cn =\n                            {} \\<longrightarrow>\n                            (\\<exists>csp.\n                                bb = csp + b \\<and>\n                                mon_c fg csp = {} \\<and>\n                                ((a, cn), aa # w, ac, csp + cn)\n                                \\<in> trcl (ntrs fg))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cn.\n       mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<longrightarrow>\n       (\\<exists>csp.\n           c' = csp + c \\<and>\n           mon_c fg csp = {} \\<and>\n           ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg))", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)", "fix cn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)", "assume MON: \"mon_ww fg (e # w) \\<inter> mon_c fg cn = {}\""], ["proof (state)\nthis:\n  mon_ww fg (e # w) \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)", "from ntrs_modify_context_s[OF IHP(1)] MON"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     ch = csp + c \\<and>\n     mon_c fg csp = {} \\<and> ((s, ?cn), e, sh, csp + ?cn) \\<in> ntrs fg\n  mon_ww fg (e # w) \\<inter> mon_c fg cn = {}", "obtain csph where S1: \"ch = csph + c\" \"mon_c fg csph={}\" \"((s, cn), e, sh, csph + cn) \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     ch = csp + c \\<and>\n     mon_c fg csp = {} \\<and> ((s, ?cn), e, sh, csp + ?cn) \\<in> ntrs fg\n  mon_ww fg (e # w) \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. (\\<And>csph.\n        \\<lbrakk>ch = csph + c; mon_c fg csph = {};\n         ((s, cn), e, sh, csph + cn) \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)", "with MON"], ["proof (chain)\npicking this:\n  mon_ww fg (e # w) \\<inter> mon_c fg cn = {}\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> ntrs fg", "have \"mon_ww fg w \\<inter> mon_c fg (csph+cn) = {}\""], ["proof (prove)\nusing this:\n  mon_ww fg (e # w) \\<inter> mon_c fg cn = {}\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. mon_ww fg w \\<inter> mon_c fg (csph + cn) = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg w \\<inter> mon_c fg (csph + cn) = {}\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)", "with IHP(3)[rule_format]"], ["proof (chain)\npicking this:\n  mon_ww fg w \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c' = csp + ch \\<and>\n     mon_c fg csp = {} \\<and>\n     ((sh, ?cn), w, s', csp + ?cn) \\<in> trcl (ntrs fg)\n  mon_ww fg w \\<inter> mon_c fg (csph + cn) = {}", "obtain csp where S2: \"c'=csp+ch\" \"mon_c fg csp={}\" \"((sh,csph+cn),w,(s',csp+(csph+cn)))\\<in>trcl (ntrs fg)\""], ["proof (prove)\nusing this:\n  mon_ww fg w \\<inter> mon_c fg ?cn = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c' = csp + ch \\<and>\n     mon_c fg csp = {} \\<and>\n     ((sh, ?cn), w, s', csp + ?cn) \\<in> trcl (ntrs fg)\n  mon_ww fg w \\<inter> mon_c fg (csph + cn) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        \\<lbrakk>c' = csp + ch; mon_c fg csp = {};\n         ((sh, csph + cn), w, s', csp + (csph + cn))\n         \\<in> trcl (ntrs fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c' = csp + ch\n  mon_c fg csp = {}\n  ((sh, csph + cn), w, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)", "from S1 S2"], ["proof (chain)\npicking this:\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> ntrs fg\n  c' = csp + ch\n  mon_c fg csp = {}\n  ((sh, csph + cn), w, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)", "have \"c'=(csp+csph)+c\" \"mon_c fg (csp+csph)={}\" \"((s,cn),e#w,(s',(csp+csph)+cn))\\<in>trcl (ntrs fg)\""], ["proof (prove)\nusing this:\n  ch = csph + c\n  mon_c fg csph = {}\n  ((s, cn), e, sh, csph + cn) \\<in> ntrs fg\n  c' = csp + ch\n  mon_c fg csp = {}\n  ((sh, csph + cn), w, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. c' = csp + csph + c &&&\n    mon_c fg (csp + csph) = {} &&&\n    ((s, cn), e # w, s', csp + csph + cn) \\<in> trcl (ntrs fg)", "by (auto simp add: union_assoc mon_c_unconc)"], ["proof (state)\nthis:\n  c' = csp + csph + c\n  mon_c fg (csp + csph) = {}\n  ((s, cn), e # w, s', csp + csph + cn) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>cn.\n       mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<Longrightarrow>\n       \\<exists>csp.\n          c' = csp + c \\<and>\n          mon_c fg csp = {} \\<and>\n          ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)", "thus \"\\<exists>csp. c' = csp + c \\<and> mon_c fg csp = {} \\<and> ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)\""], ["proof (prove)\nusing this:\n  c' = csp + csph + c\n  mon_c fg (csp + csph) = {}\n  ((s, cn), e # w, s', csp + csph + cn) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       mon_c fg csp = {} \\<and>\n       ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>csp.\n     c' = csp + c \\<and>\n     mon_c fg csp = {} \\<and>\n     ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>cn.\n     mon_ww fg (e # w) \\<inter> mon_c fg cn = {} \\<longrightarrow>\n     (\\<exists>csp.\n         c' = csp + c \\<and>\n         mon_c fg csp = {} \\<and>\n         ((s, cn), e # w, s', csp + cn) \\<in> trcl (ntrs fg))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ntrs_xchange_context_s: \n  assumes A: \"((s,c),ee,(s',csp+c))\\<in>ntrs fg\" \n  and B: \"mon_c fg cn \\<subseteq> mon_c fg c\" \n  shows \"((s,cn),ee,(s',csp+cn))\\<in>ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "obtain p r u u' v w where S: \"s=u#r\" \"ee=LCall p#w\" \"s'=v#u'#r\" \"((u#r,c),LCall p,(entry fg p#u'#r,c))\\<in>trss fg\" \"(([entry fg p],c),w,([v],csp+c))\\<in>trcl (trss fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u r p w v u'.\n        \\<lbrakk>s = u # r; ee = LCall p # w; s' = v # u' # r;\n         ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n         (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u r p w v u'.\n        \\<lbrakk>s = u # r; ee = LCall p # w; s' = v # u' # r;\n         ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n         (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ntrs.cases[OF A, simplified]"], ["proof (chain)\npicking this:\n  (\\<And>u r ce p u' w v ce'.\n      \\<lbrakk>s = u # r; c = ce; ee = LCall p # w; s' = v # u' # r;\n       csp + ce = ce';\n       ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg;\n       (([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain ce ce' p r u u' v w where \"s = u # r\" \"c = ce\" \"ee = LCall p # w\" \"s' = v # u' # r\" \"csp + ce = ce'\" \"((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg\" \n      \"(([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\""], ["proof (prove)\nusing this:\n  (\\<And>u r ce p u' w v ce'.\n      \\<lbrakk>s = u # r; c = ce; ee = LCall p # w; s' = v # u' # r;\n       csp + ce = ce';\n       ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg;\n       (([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>u r ce p w v u' ce'.\n        \\<lbrakk>s = u # r; c = ce; ee = LCall p # w; s' = v # u' # r;\n         csp + ce = ce';\n         ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg;\n         (([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  s = u # r\n  c = ce\n  ee = LCall p # w\n  s' = v # u' # r\n  csp + ce = ce'\n  ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg\n  (([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>u r p w v u'.\n        \\<lbrakk>s = u # r; ee = LCall p # w; s' = v # u' # r;\n         ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n         (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"s=u#r\" \"ee=LCall p#w\" \"s'=v#u'#r\" \"((u#r,c),LCall p,(entry fg p#u'#r,c))\\<in>trss fg\" \"(([entry fg p],c),w,([v],csp+c))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  s = u # r\n  c = ce\n  ee = LCall p # w\n  s' = v # u' # r\n  csp + ce = ce'\n  ((u # r, ce), LCall p, entry fg p # u' # r, ce) \\<in> trss fg\n  (([entry fg p], ce), w, [v], ce') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (s = u # r &&& ee = LCall p # w) &&&\n    s' = v # u' # r &&&\n    ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg &&&\n    (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)", "by auto"], ["proof (state)\nthis:\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>u r p w v u'.\n        \\<lbrakk>s = u # r; ee = LCall p # w; s' = v # u' # r;\n         ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n         (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "from ntrs_step[simplified, OF trss_xchange_context_s[where csp=\"{#}\", simplified, OF S(4) B] trss_xchange_context[OF S(5) B]] S"], ["proof (chain)\npicking this:\n  ((u # r, cn), LCall p # w, v # u' # r, csp + cn) \\<in> ntrs fg\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((u # r, cn), LCall p # w, v # u' # r, csp + cn) \\<in> ntrs fg\n  s = u # r\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], csp + c) \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. ((s, cn), ee, s', csp + cn) \\<in> ntrs fg", "by simp"], ["proof (state)\nthis:\n  ((s, cn), ee, s', csp + cn) \\<in> ntrs fg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ntrs_replace_context_s: \n  assumes A: \"((s,c+cr),ee,(s',c'+cr))\\<in>ntrs fg\" \n  and B: \"mon_c fg crn \\<subseteq> mon_c fg cr\" \n  shows \"((s,c+crn),ee,(s',c'+crn))\\<in>ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c + crn), ee, s', c' + crn) \\<in> ntrs fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, c + crn), ee, s', c' + crn) \\<in> ntrs fg", "from ntrs_c_cases_s[OF A]"], ["proof (chain)\npicking this:\n  (\\<And>csp.\n      \\<lbrakk>c' + cr = csp + (c + cr);\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain csp where G: \"c'+cr = csp+(c+cr)\""], ["proof (prove)\nusing this:\n  (\\<And>csp.\n      \\<lbrakk>c' + cr = csp + (c + cr);\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        c' + cr = csp + (c + cr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  c' + cr = csp + (c + cr)\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ee, s', c' + crn) \\<in> ntrs fg", "hence F: \"c'=csp+c\""], ["proof (prove)\nusing this:\n  c' + cr = csp + (c + cr)\n\ngoal (1 subgoal):\n 1. c' = csp + c", "by (auto simp add: union_assoc[symmetric])"], ["proof (state)\nthis:\n  c' = csp + c\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ee, s', c' + crn) \\<in> ntrs fg", "from B"], ["proof (chain)\npicking this:\n  mon_c fg crn \\<subseteq> mon_c fg cr", "have MON: \"mon_c fg (c+crn) \\<subseteq> mon_c fg (c+cr)\""], ["proof (prove)\nusing this:\n  mon_c fg crn \\<subseteq> mon_c fg cr\n\ngoal (1 subgoal):\n 1. mon_c fg (c + crn) \\<subseteq> mon_c fg (c + cr)", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg (c + crn) \\<subseteq> mon_c fg (c + cr)\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ee, s', c' + crn) \\<in> ntrs fg", "from ntrs_xchange_context_s[OF _ MON] A G"], ["proof (chain)\npicking this:\n  ((?s, c + cr), ?ee, ?s', ?csp + (c + cr)) \\<in> ntrs fg \\<Longrightarrow>\n  ((?s, c + crn), ?ee, ?s', ?csp + (c + crn)) \\<in> ntrs fg\n  ((s, c + cr), ee, s', c' + cr) \\<in> ntrs fg\n  c' + cr = csp + (c + cr)", "have \"((s,c+crn),ee,(s',csp+(c+crn)))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  ((?s, c + cr), ?ee, ?s', ?csp + (c + cr)) \\<in> ntrs fg \\<Longrightarrow>\n  ((?s, c + crn), ?ee, ?s', ?csp + (c + crn)) \\<in> ntrs fg\n  ((s, c + cr), ee, s', c' + cr) \\<in> ntrs fg\n  c' + cr = csp + (c + cr)\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ee, s', csp + (c + crn)) \\<in> ntrs fg", "by auto"], ["proof (state)\nthis:\n  ((s, c + crn), ee, s', csp + (c + crn)) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ee, s', c' + crn) \\<in> ntrs fg", "with F"], ["proof (chain)\npicking this:\n  c' = csp + c\n  ((s, c + crn), ee, s', csp + (c + crn)) \\<in> ntrs fg", "show ?thesis"], ["proof (prove)\nusing this:\n  c' = csp + c\n  ((s, c + crn), ee, s', csp + (c + crn)) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ee, s', c' + crn) \\<in> ntrs fg", "by (simp add: union_assoc)"], ["proof (state)\nthis:\n  ((s, c + crn), ee, s', c' + crn) \\<in> ntrs fg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) ntrs_xchange_context: \"!!s c c' cn. \\<lbrakk>\n    ((s,c),ww,(s',c'))\\<in>trcl (ntrs fg); \n    mon_c fg cn \\<subseteq> mon_c fg c\n  \\<rbrakk> \\<Longrightarrow> \\<exists>csp. \n    c'=csp+c \\<and> ((s,cn),ww,(s',csp+cn))\\<in>trcl (ntrs fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c c' cn.\n       \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg)", "proof (induct ww)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s c c' cn.\n       \\<lbrakk>((s, c), [], s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), [], s', csp + cn) \\<in> trcl (ntrs fg)\n 2. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "case Nil"], ["proof (state)\nthis:\n  ((s, c), [], s', c') \\<in> trcl (ntrs fg)\n  mon_c fg cn \\<subseteq> mon_c fg c\n\ngoal (2 subgoals):\n 1. \\<And>s c c' cn.\n       \\<lbrakk>((s, c), [], s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), [], s', csp + cn) \\<in> trcl (ntrs fg)\n 2. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "note CASE=this"], ["proof (state)\nthis:\n  ((s, c), [], s', c') \\<in> trcl (ntrs fg)\n  mon_c fg cn \\<subseteq> mon_c fg c\n\ngoal (2 subgoals):\n 1. \\<And>s c c' cn.\n       \\<lbrakk>((s, c), [], s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), [], s', csp + cn) \\<in> trcl (ntrs fg)\n 2. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "thus ?case"], ["proof (prove)\nusing this:\n  ((s, c), [], s', c') \\<in> trcl (ntrs fg)\n  mon_c fg cn \\<subseteq> mon_c fg c\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and> ((s, cn), [], s', csp + cn) \\<in> trcl (ntrs fg)", "by (auto intro!: exI[of _ \"{#}\"])"], ["proof (state)\nthis:\n  \\<exists>csp.\n     c' = csp + c \\<and> ((s, cn), [], s', csp + cn) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "case (Cons ee ww)"], ["proof (state)\nthis:\n  \\<lbrakk>((?s, ?c), ww, s', ?c') \\<in> trcl (ntrs fg);\n   mon_c fg ?cn \\<subseteq> mon_c fg ?c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>csp.\n                       ?c' = csp + ?c \\<and>\n                       ((?s, ?cn), ww, s', csp + ?cn) \\<in> trcl (ntrs fg)\n  ((s, c), ee # ww, s', c') \\<in> trcl (ntrs fg)\n  mon_c fg cn \\<subseteq> mon_c fg c\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "note IHP=this"], ["proof (state)\nthis:\n  \\<lbrakk>((?s, ?c), ww, s', ?c') \\<in> trcl (ntrs fg);\n   mon_c fg ?cn \\<subseteq> mon_c fg ?c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>csp.\n                       ?c' = csp + ?c \\<and>\n                       ((?s, ?cn), ww, s', csp + ?cn) \\<in> trcl (ntrs fg)\n  ((s, c), ee # ww, s', c') \\<in> trcl (ntrs fg)\n  mon_c fg cn \\<subseteq> mon_c fg c\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?s, ?c), ww, s', ?c') \\<in> trcl (ntrs fg);\n   mon_c fg ?cn \\<subseteq> mon_c fg ?c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>csp.\n                       ?c' = csp + ?c \\<and>\n                       ((?s, ?cn), ww, s', csp + ?cn) \\<in> trcl (ntrs fg)\n  ((s, c), ee # ww, s', c') \\<in> trcl (ntrs fg)\n  mon_c fg cn \\<subseteq> mon_c fg c", "obtain sh ch where SPLIT: \"((s,c),ee,(sh,ch))\\<in>ntrs fg\" \"((sh,ch),ww,(s',c'))\\<in>trcl (ntrs fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((?s, ?c), ww, s', ?c') \\<in> trcl (ntrs fg);\n   mon_c fg ?cn \\<subseteq> mon_c fg ?c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>csp.\n                       ?c' = csp + ?c \\<and>\n                       ((?s, ?cn), ww, s', csp + ?cn) \\<in> trcl (ntrs fg)\n  ((s, c), ee # ww, s', c') \\<in> trcl (ntrs fg)\n  mon_c fg cn \\<subseteq> mon_c fg c\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>((s, c), ee, sh, ch) \\<in> ntrs fg;\n         ((sh, ch), ww, s', c') \\<in> trcl (ntrs fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  ((s, c), ee, sh, ch) \\<in> ntrs fg\n  ((sh, ch), ww, s', c') \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "from ntrs_c_cases_s[OF SPLIT(1)]"], ["proof (chain)\npicking this:\n  (\\<And>csp.\n      \\<lbrakk>ch = csp + c;\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain csph where CHFMT: \"ch=csph+c\" \"!!s. s \\<in># csph \\<Longrightarrow> \\<exists>p u v. s=[entry fg p] \\<and> (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\""], ["proof (prove)\nusing this:\n  (\\<And>csp.\n      \\<lbrakk>ch = csp + c;\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csph.\n        \\<lbrakk>ch = csph + c;\n         \\<And>s.\n            s \\<in># csph \\<Longrightarrow>\n            \\<exists>p u v.\n               s = [entry fg p] \\<and>\n               (u, Spawn p, v) \\<in> edges fg \\<and>\n               initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ch = csph + c\n  ?s \\<in># csph \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "with ntrs_xchange_context_s SPLIT(1) IHP(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?s, ?c), ?ee, ?s', ?csp + ?c) \\<in> ntrs ?fg;\n   mon_c ?fg ?cn \\<subseteq> mon_c ?fg ?c\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?cn), ?ee, ?s', ?csp + ?cn) \\<in> ntrs ?fg\n  ((s, c), ee, sh, ch) \\<in> ntrs fg\n  mon_c fg cn \\<subseteq> mon_c fg c\n  ch = csph + c\n  ?s \\<in># csph \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "have \"((s,cn),ee,(sh,csph+cn))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((?s, ?c), ?ee, ?s', ?csp + ?c) \\<in> ntrs ?fg;\n   mon_c ?fg ?cn \\<subseteq> mon_c ?fg ?c\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?cn), ?ee, ?s', ?csp + ?cn) \\<in> ntrs ?fg\n  ((s, c), ee, sh, ch) \\<in> ntrs fg\n  mon_c fg cn \\<subseteq> mon_c fg c\n  ch = csph + c\n  ?s \\<in># csph \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. ((s, cn), ee, sh, csph + cn) \\<in> ntrs fg", "by blast"], ["proof (state)\nthis:\n  ((s, cn), ee, sh, csph + cn) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "also"], ["proof (state)\nthis:\n  ((s, cn), ee, sh, csph + cn) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "from c_of_initial_no_mon CHFMT(2)"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># csph \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "have CSPH_NO_MON: \"mon_c fg csph = {}\""], ["proof (prove)\nusing this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ?s \\<in># csph \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. mon_c fg csph = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg csph = {}\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "with IHP(3) CHFMT"], ["proof (chain)\npicking this:\n  mon_c fg cn \\<subseteq> mon_c fg c\n  ch = csph + c\n  ?s \\<in># csph \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  mon_c fg csph = {}", "have 1: \"mon_c fg (csph+cn) \\<subseteq> mon_c fg ch\""], ["proof (prove)\nusing this:\n  mon_c fg cn \\<subseteq> mon_c fg c\n  ch = csph + c\n  ?s \\<in># csph \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n  mon_c fg csph = {}\n\ngoal (1 subgoal):\n 1. mon_c fg (csph + cn) \\<subseteq> mon_c fg ch", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg (csph + cn) \\<subseteq> mon_c fg ch\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "from IHP(1)[OF SPLIT(2) this]"], ["proof (chain)\npicking this:\n  \\<exists>csp.\n     c' = csp + ch \\<and>\n     ((sh, csph + cn), ww, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)", "obtain csp where C'FMT: \"c'=csp+ch\" and SND: \"((sh,csph+cn),ww,(s',csp+(csph+cn)))\\<in>trcl (ntrs fg)\""], ["proof (prove)\nusing this:\n  \\<exists>csp.\n     c' = csp + ch \\<and>\n     ((sh, csph + cn), ww, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        \\<lbrakk>c' = csp + ch;\n         ((sh, csph + cn), ww, s', csp + (csph + cn))\n         \\<in> trcl (ntrs fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c' = csp + ch\n  ((sh, csph + cn), ww, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "note SND"], ["proof (state)\nthis:\n  ((sh, csph + cn), ww, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "finally"], ["proof (chain)\npicking this:\n  ((s, cn), ee # ww, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)", "have \"((s, cn), ee # ww, s', (csp + csph) + cn) \\<in> trcl (ntrs fg)\""], ["proof (prove)\nusing this:\n  ((s, cn), ee # ww, s', csp + (csph + cn)) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. ((s, cn), ee # ww, s', csp + csph + cn) \\<in> trcl (ntrs fg)", "by (simp add: union_assoc)"], ["proof (state)\nthis:\n  ((s, cn), ee # ww, s', csp + csph + cn) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "moreover"], ["proof (state)\nthis:\n  ((s, cn), ee # ww, s', csp + csph + cn) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "from CHFMT(1) C'FMT"], ["proof (chain)\npicking this:\n  ch = csph + c\n  c' = csp + ch", "have \"c'=(csp+csph)+c\""], ["proof (prove)\nusing this:\n  ch = csph + c\n  c' = csp + ch\n\ngoal (1 subgoal):\n 1. c' = csp + csph + c", "by (simp add: union_assoc)"], ["proof (state)\nthis:\n  c' = csp + csph + c\n\ngoal (1 subgoal):\n 1. \\<And>a ww s c c' cn.\n       \\<lbrakk>\\<And>s c c' cn.\n                   \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrs fg);\n                    mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>csp.\n  c' = csp + c \\<and> ((s, cn), ww, s', csp + cn) \\<in> trcl (ntrs fg);\n        ((s, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        mon_c fg cn \\<subseteq> mon_c fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>csp.\n                            c' = csp + c \\<and>\n                            ((s, cn), a # ww, s', csp + cn)\n                            \\<in> trcl (ntrs fg)", "ultimately"], ["proof (chain)\npicking this:\n  ((s, cn), ee # ww, s', csp + csph + cn) \\<in> trcl (ntrs fg)\n  c' = csp + csph + c", "show ?case"], ["proof (prove)\nusing this:\n  ((s, cn), ee # ww, s', csp + csph + cn) \\<in> trcl (ntrs fg)\n  c' = csp + csph + c\n\ngoal (1 subgoal):\n 1. \\<exists>csp.\n       c' = csp + c \\<and>\n       ((s, cn), ee # ww, s', csp + cn) \\<in> trcl (ntrs fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>csp.\n     c' = csp + c \\<and>\n     ((s, cn), ee # ww, s', csp + cn) \\<in> trcl (ntrs fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) ntrs_replace_context: \n  assumes A: \"((s,c+cr),ww,(s',c'+cr))\\<in>trcl (ntrs fg)\" \n  and B: \"mon_c fg crn \\<subseteq> mon_c fg cr\" \n  shows \"((s,c+crn),ww,(s',c'+crn))\\<in>trcl (ntrs fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c + crn), ww, s', c' + crn) \\<in> trcl (ntrs fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, c + crn), ww, s', c' + crn) \\<in> trcl (ntrs fg)", "from ntrs_c_cases[OF A]"], ["proof (chain)\npicking this:\n  (\\<And>csp.\n      \\<lbrakk>c' + cr = csp + (c + cr);\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain csp where G: \"c'+cr = csp+(c+cr)\""], ["proof (prove)\nusing this:\n  (\\<And>csp.\n      \\<lbrakk>c' + cr = csp + (c + cr);\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        c' + cr = csp + (c + cr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  c' + cr = csp + (c + cr)\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ww, s', c' + crn) \\<in> trcl (ntrs fg)", "hence F: \"c'=csp+c\""], ["proof (prove)\nusing this:\n  c' + cr = csp + (c + cr)\n\ngoal (1 subgoal):\n 1. c' = csp + c", "by (auto simp add: union_assoc[symmetric])"], ["proof (state)\nthis:\n  c' = csp + c\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ww, s', c' + crn) \\<in> trcl (ntrs fg)", "from B"], ["proof (chain)\npicking this:\n  mon_c fg crn \\<subseteq> mon_c fg cr", "have MON: \"mon_c fg (c+crn) \\<subseteq> mon_c fg (c+cr)\""], ["proof (prove)\nusing this:\n  mon_c fg crn \\<subseteq> mon_c fg cr\n\ngoal (1 subgoal):\n 1. mon_c fg (c + crn) \\<subseteq> mon_c fg (c + cr)", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg (c + crn) \\<subseteq> mon_c fg (c + cr)\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ww, s', c' + crn) \\<in> trcl (ntrs fg)", "from ntrs_xchange_context[OF A MON] G"], ["proof (chain)\npicking this:\n  \\<exists>csp.\n     c' + cr = csp + (c + cr) \\<and>\n     ((s, c + crn), ww, s', csp + (c + crn)) \\<in> trcl (ntrs fg)\n  c' + cr = csp + (c + cr)", "have \"((s,c+crn),ww,(s',csp+(c+crn)))\\<in>trcl (ntrs fg)\""], ["proof (prove)\nusing this:\n  \\<exists>csp.\n     c' + cr = csp + (c + cr) \\<and>\n     ((s, c + crn), ww, s', csp + (c + crn)) \\<in> trcl (ntrs fg)\n  c' + cr = csp + (c + cr)\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ww, s', csp + (c + crn)) \\<in> trcl (ntrs fg)", "by auto"], ["proof (state)\nthis:\n  ((s, c + crn), ww, s', csp + (c + crn)) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ww, s', c' + crn) \\<in> trcl (ntrs fg)", "with F"], ["proof (chain)\npicking this:\n  c' = csp + c\n  ((s, c + crn), ww, s', csp + (c + crn)) \\<in> trcl (ntrs fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  c' = csp + c\n  ((s, c + crn), ww, s', csp + (c + crn)) \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. ((s, c + crn), ww, s', c' + crn) \\<in> trcl (ntrs fg)", "by (simp add: union_assoc)"], ["proof (state)\nthis:\n  ((s, c + crn), ww, s', c' + crn) \\<in> trcl (ntrs fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) ntr_add_context_s: \n  assumes A: \"(c,e,c')\\<in>ntr fg\" \n  and B: \"mon_w fg e \\<inter> mon_c fg cn = {}\" \n  shows \"(c+cn,e,c'+cn)\\<in>ntr fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c + cn, e, c' + cn) \\<in> ntr fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (c + cn, e, c' + cn) \\<in> ntr fg", "from gtrE[OF A]"], ["proof (chain)\npicking this:\n  (\\<And>s ce s' ce'.\n      \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n       ((s, ce), e, s', ce') \\<in> ntrs fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain s ce s' ce' where NTRS: \"c = add_mset s ce\" \"c' = add_mset s' ce'\" \"((s, ce), e, s', ce') \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  (\\<And>s ce s' ce'.\n      \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n       ((s, ce), e, s', ce') \\<in> ntrs fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>s ce s' ce'.\n        \\<lbrakk>c = add_mset s ce; c' = add_mset s' ce';\n         ((s, ce), e, s', ce') \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  c = add_mset s ce\n  c' = add_mset s' ce'\n  ((s, ce), e, s', ce') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (c + cn, e, c' + cn) \\<in> ntr fg", "from ntrs_mon_e_no_ctx[OF NTRS(3)] B"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg ce = {}\n  mon_w fg e \\<inter> mon_c fg cn = {}", "have M: \"mon_w fg e \\<inter> (mon_c fg (ce+cn)) = {}\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg ce = {}\n  mon_w fg e \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. mon_w fg e \\<inter> mon_c fg (ce + cn) = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_w fg e \\<inter> mon_c fg (ce + cn) = {}\n\ngoal (1 subgoal):\n 1. (c + cn, e, c' + cn) \\<in> ntr fg", "from ntrs_modify_context_s[OF NTRS(3) M]"], ["proof (chain)\npicking this:\n  \\<exists>csp.\n     ce' = csp + ce \\<and>\n     mon_c fg csp = {} \\<and>\n     ((s, ce + cn), e, s', csp + (ce + cn)) \\<in> ntrs fg", "have \"((s,ce+cn),e,(s',ce'+cn))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  \\<exists>csp.\n     ce' = csp + ce \\<and>\n     mon_c fg csp = {} \\<and>\n     ((s, ce + cn), e, s', csp + (ce + cn)) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s, ce + cn), e, s', ce' + cn) \\<in> ntrs fg", "by (auto simp add: union_assoc)"], ["proof (state)\nthis:\n  ((s, ce + cn), e, s', ce' + cn) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (c + cn, e, c' + cn) \\<in> ntr fg", "with NTRS"], ["proof (chain)\npicking this:\n  c = add_mset s ce\n  c' = add_mset s' ce'\n  ((s, ce), e, s', ce') \\<in> ntrs fg\n  ((s, ce + cn), e, s', ce' + cn) \\<in> ntrs fg", "show ?thesis"], ["proof (prove)\nusing this:\n  c = add_mset s ce\n  c' = add_mset s' ce'\n  ((s, ce), e, s', ce') \\<in> ntrs fg\n  ((s, ce + cn), e, s', ce' + cn) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (c + cn, e, c' + cn) \\<in> ntr fg", "by (auto simp add: union_assoc intro: gtrI_s)"], ["proof (state)\nthis:\n  (c + cn, e, c' + cn) \\<in> ntr fg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) ntr_add_context: \n  \"\\<lbrakk>(c,w,c')\\<in>trcl (ntr fg); mon_ww fg w \\<inter> mon_c fg cn = {}\\<rbrakk> \n    \\<Longrightarrow> (c+cn,w,c'+cn)\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, w, c') \\<in> trcl (ntr fg);\n     mon_ww fg w \\<inter> mon_c fg cn = {}\\<rbrakk>\n    \\<Longrightarrow> (c + cn, w, c' + cn) \\<in> trcl (ntr fg)", "by (induct rule: trcl.induct) (simp, force dest: ntr_add_context_s)"], ["", "lemma (in flowgraph) ntrs_add_context_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrs fg\" \n  and B: \"mon_w fg e \\<inter> mon_c fg cn = {}\" \n  shows \"((s,c+cn),e,(s',c'+cn))\\<in>ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c + cn), e, s', c' + cn) \\<in> ntrs fg", "using ntrs_mon_e_no_ctx[OF A] ntrs_modify_context_s[OF A, of \"c+cn\"] B"], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg c = {}\n  mon_w fg e \\<inter> mon_c fg (c + cn) = {} \\<Longrightarrow>\n  \\<exists>csp.\n     c' = csp + c \\<and>\n     mon_c fg csp = {} \\<and>\n     ((s, c + cn), e, s', csp + (c + cn)) \\<in> ntrs fg\n  mon_w fg e \\<inter> mon_c fg cn = {}\n\ngoal (1 subgoal):\n 1. ((s, c + cn), e, s', c' + cn) \\<in> ntrs fg", "by (force simp add: mon_c_unconc union_ac)"], ["", "lemma (in flowgraph) ntrp_add_context_s: \n  \"\\<lbrakk> ((s,c),e,(s',c'))\\<in>ntrp fg; mon_w fg (le_rem_s e) \\<inter> mon_c fg cn = {} \\<rbrakk> \n  \\<Longrightarrow> ((s,c+cn),e,(s',c'+cn))\\<in>ntrp fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), e, s', c') \\<in> ntrp fg;\n     mon_w fg (le_rem_s e) \\<inter> mon_c fg cn = {}\\<rbrakk>\n    \\<Longrightarrow> ((s, c + cn), e, s', c' + cn) \\<in> ntrp fg", "apply (erule gtrp.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa ca ea s'a c'a.\n       \\<lbrakk>mon_w fg (le_rem_s e) \\<inter> mon_c fg cn = {}; s = sa;\n        c = ca; e = LOC ea; s' = s'a; c' = c'a;\n        ((sa, ca), ea, s'a, c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s, c + cn), e, s', c' + cn) \\<in> ntrp fg\n 2. \\<And>sa sl ca ea s'a c'a.\n       \\<lbrakk>mon_w fg (le_rem_s e) \\<inter> mon_c fg cn = {}; s = sl;\n        c = add_mset sa ca; e = ENV ea; s' = sl; c' = add_mset s'a c'a;\n        ((sa, add_mset sl ca), ea, s'a, add_mset sl c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s, c + cn), e, s', c' + cn) \\<in> ntrp fg", "by (auto dest: ntrs_add_context_s intro!: gtrp.intros)"], ["", "lemma (in flowgraph) ntrp_add_context: \"\\<lbrakk> \n    ((s,c),w,(s',c'))\\<in>trcl (ntrp fg); \n    mon_ww fg (map le_rem_s w) \\<inter> mon_c fg cn = {} \n  \\<rbrakk> \\<Longrightarrow> ((s,c+cn),w,(s',c'+cn))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), w, s', c') \\<in> trcl (ntrp fg);\n     mon_ww fg (map le_rem_s w) \\<inter> mon_c fg cn = {}\\<rbrakk>\n    \\<Longrightarrow> ((s, c + cn), w, s', c' + cn) \\<in> trcl (ntrp fg)", "by (induct rule: trcl_pair_induct) (simp, force dest: ntrp_add_context_s)"], ["", "subsubsection \\<open>Altering the local stack\\<close>"], ["", "lemma ntrs_stack_comp_s: \n  assumes A: \"((s,c),ee,(s',c'))\\<in>ntrs fg\" \n  shows \"((s@r,c),ee,(s'@r,c'))\\<in>ntrs fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s @ r, c), ee, s' @ r, c') \\<in> ntrs fg", "using A"], ["proof (prove)\nusing this:\n  ((s, c), ee, s', c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s @ r, c), ee, s' @ r, c') \\<in> ntrs fg", "by (auto dest: trss_stack_comp trss_stack_comp_s elim!: ntrs.cases intro!: ntrs_step[simplified])"], ["", "lemma ntrs_stack_comp: \"((s,c),ww,(s',c'))\\<in>trcl (ntrs fg) \n  \\<Longrightarrow> ((s@r,c),ww,(s'@r,c'))\\<in>trcl (ntrs fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c), ww, s', c') \\<in> trcl (ntrs fg) \\<Longrightarrow>\n    ((s @ r, c), ww, s' @ r, c') \\<in> trcl (ntrs fg)", "by (induct rule: trcl_pair_induct) (auto intro!: trcl.cons[OF ntrs_stack_comp_s])"], ["", "lemma (in flowgraph) ntrp_stack_comp_s: \n  assumes A: \"((s,c),ee,(s',c'))\\<in>ntrp fg\" \n  and B: \"mon_s fg r \\<inter> mon_env fg [ee] = {}\" \n  shows \"((s@r,c),ee,(s'@r,c'))\\<in>ntrp fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "using A"], ["proof (prove)\nusing this:\n  ((s, c), ee, s', c') \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "proof (cases rule: gtrp.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c), e, s', c') \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg\n 2. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "case gtrp_loc"], ["proof (state)\nthis:\n  ee = LOC e_\n  ((s, c), e_, s', c') \\<in> ntrs fg\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c), e, s', c') \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg\n 2. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "then"], ["proof (chain)\npicking this:\n  ee = LOC e_\n  ((s, c), e_, s', c') \\<in> ntrs fg", "obtain e where CASE: \"ee=LOC e\" \"((s,c),e,(s',c'))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  ee = LOC e_\n  ((s, c), e_, s', c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>ee = LOC e; ((s, c), e, s', c') \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ee = LOC e\n  ((s, c), e, s', c') \\<in> ntrs fg\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c), e, s', c') \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg\n 2. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "hence \"((s@r,c),e,(s'@r,c'))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  ee = LOC e\n  ((s, c), e, s', c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s @ r, c), e, s' @ r, c') \\<in> ntrs fg", "by (blast dest: ntrs_stack_comp_s)"], ["proof (state)\nthis:\n  ((s @ r, c), e, s' @ r, c') \\<in> ntrs fg\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c), e, s', c') \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg\n 2. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "with CASE(1)"], ["proof (chain)\npicking this:\n  ee = LOC e\n  ((s @ r, c), e, s' @ r, c') \\<in> ntrs fg", "show ?thesis"], ["proof (prove)\nusing this:\n  ee = LOC e\n  ((s @ r, c), e, s' @ r, c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "by (auto intro: gtrp.gtrp_loc)"], ["proof (state)\nthis:\n  ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "case gtrp_env"], ["proof (state)\nthis:\n  c = add_mset s_ c_\n  ee = ENV e_\n  s' = s\n  c' = add_mset s'_ c'_\n  ((s_, add_mset s c_), e_, s'_, add_mset s c'_) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "then"], ["proof (chain)\npicking this:\n  c = add_mset s_ c_\n  ee = ENV e_\n  s' = s\n  c' = add_mset s'_ c'_\n  ((s_, add_mset s c_), e_, s'_, add_mset s c'_) \\<in> ntrs fg", "obtain sm ce sm' ce' e where CASE: \"s'=s\" \"c={#sm#}+ce\" \"c'={#sm'#}+ce'\" \"ee=ENV e\" \"((sm,{#s#}+ce),e,(sm',{#s#}+ce'))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  c = add_mset s_ c_\n  ee = ENV e_\n  s' = s\n  c' = add_mset s'_ c'_\n  ((s_, add_mset s c_), e_, s'_, add_mset s c'_) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>sm ce sm' ce' e.\n        \\<lbrakk>s' = s; c = {#sm#} + ce; c' = {#sm'#} + ce'; ee = ENV e;\n         ((sm, {#s#} + ce), e, sm', {#s#} + ce') \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' = s\n  c = {#sm#} + ce\n  c' = {#sm'#} + ce'\n  ee = ENV e\n  ((sm, {#s#} + ce), e, sm', {#s#} + ce') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "from ntrs_modify_context_s[OF CASE(5), where cn=\"{#s@r#}+ce\"] ntrs_mon_e_no_ctx[OF CASE(5)] B CASE(4)"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg ({#s @ r#} + ce) = {} \\<Longrightarrow>\n  \\<exists>csp.\n     {#s#} + ce' = csp + ({#s#} + ce) \\<and>\n     mon_c fg csp = {} \\<and>\n     ((sm, {#s @ r#} + ce), e, sm', csp + ({#s @ r#} + ce)) \\<in> ntrs fg\n  mon_w fg e \\<inter> mon_c fg ({#s#} + ce) = {}\n  mon_s fg r \\<inter> mon_env fg [ee] = {}\n  ee = ENV e", "obtain csp where \n    ADD: \"{#s#} + ce' = csp + ({#s#} + ce)\" \"mon_c fg csp = {}\" \"((sm, {#s @ r#} + ce), e, sm', csp + ({#s @ r#} + ce)) \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg ({#s @ r#} + ce) = {} \\<Longrightarrow>\n  \\<exists>csp.\n     {#s#} + ce' = csp + ({#s#} + ce) \\<and>\n     mon_c fg csp = {} \\<and>\n     ((sm, {#s @ r#} + ce), e, sm', csp + ({#s @ r#} + ce)) \\<in> ntrs fg\n  mon_w fg e \\<inter> mon_c fg ({#s#} + ce) = {}\n  mon_s fg r \\<inter> mon_env fg [ee] = {}\n  ee = ENV e\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        \\<lbrakk>{#s#} + ce' = csp + ({#s#} + ce); mon_c fg csp = {};\n         ((sm, {#s @ r#} + ce), e, sm', csp + ({#s @ r#} + ce))\n         \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: mon_c_unconc mon_s_unconc)"], ["proof (state)\nthis:\n  {#s#} + ce' = csp + ({#s#} + ce)\n  mon_c fg csp = {}\n  ((sm, {#s @ r#} + ce), e, sm', csp + ({#s @ r#} + ce)) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "moreover"], ["proof (state)\nthis:\n  {#s#} + ce' = csp + ({#s#} + ce)\n  mon_c fg csp = {}\n  ((sm, {#s @ r#} + ce), e, sm', csp + ({#s @ r#} + ce)) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "from ADD(1)"], ["proof (chain)\npicking this:\n  {#s#} + ce' = csp + ({#s#} + ce)", "have \"{#s#}+ce'={#s#}+(csp+ce)\""], ["proof (prove)\nusing this:\n  {#s#} + ce' = csp + ({#s#} + ce)\n\ngoal (1 subgoal):\n 1. {#s#} + ce' = {#s#} + (csp + ce)", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  {#s#} + ce' = {#s#} + (csp + ce)\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "hence \"ce'=csp+ce\""], ["proof (prove)\nusing this:\n  {#s#} + ce' = {#s#} + (csp + ce)\n\ngoal (1 subgoal):\n 1. ce' = csp + ce", "by simp"], ["proof (state)\nthis:\n  ce' = csp + ce\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "ultimately"], ["proof (chain)\npicking this:\n  {#s#} + ce' = csp + ({#s#} + ce)\n  mon_c fg csp = {}\n  ((sm, {#s @ r#} + ce), e, sm', csp + ({#s @ r#} + ce)) \\<in> ntrs fg\n  ce' = csp + ce", "have \"((sm, {#s @ r#} + ce), e, sm', ({#s @ r#} + ce')) \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  {#s#} + ce' = csp + ({#s#} + ce)\n  mon_c fg csp = {}\n  ((sm, {#s @ r#} + ce), e, sm', csp + ({#s @ r#} + ce)) \\<in> ntrs fg\n  ce' = csp + ce\n\ngoal (1 subgoal):\n 1. ((sm, {#s @ r#} + ce), e, sm', {#s @ r#} + ce') \\<in> ntrs fg", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  ((sm, {#s @ r#} + ce), e, sm', {#s @ r#} + ce') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = s;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset s ca), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "with CASE(1,2,3,4)"], ["proof (chain)\npicking this:\n  s' = s\n  c = {#sm#} + ce\n  c' = {#sm'#} + ce'\n  ee = ENV e\n  ((sm, {#s @ r#} + ce), e, sm', {#s @ r#} + ce') \\<in> ntrs fg", "show ?thesis"], ["proof (prove)\nusing this:\n  s' = s\n  c = {#sm#} + ce\n  c' = {#sm'#} + ce'\n  ee = ENV e\n  ((sm, {#s @ r#} + ce), e, sm', {#s @ r#} + ce') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg", "by (auto intro: gtrp.gtrp_env)"], ["proof (state)\nthis:\n  ((s @ r, c), ee, s' @ r, c') \\<in> ntrp fg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) ntrp_stack_comp: \n  \"\\<lbrakk> ((s,c),ww,(s',c'))\\<in>trcl (ntrp fg); mon_s fg r \\<inter> mon_env fg ww = {} \\<rbrakk> \n    \\<Longrightarrow> ((s@r,c),ww,(s'@r,c'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, c), ww, s', c') \\<in> trcl (ntrp fg);\n     mon_s fg r \\<inter> mon_env fg ww = {}\\<rbrakk>\n    \\<Longrightarrow> ((s @ r, c), ww, s' @ r, c') \\<in> trcl (ntrp fg)", "by (induct rule: trcl_pair_induct) (auto intro!: trcl.cons[OF ntrp_stack_comp_s])"], ["", "lemma ntrs_stack_top_decomp_s: \n  assumes A: \"((u#r,c),ee,(s',c'))\\<in>ntrs fg\" \n  and EX: \"!!v u' p. \\<lbrakk> \n      s'=v#u'#r; \n      (([u],c),ee,([v,u'],c'))\\<in>ntrs fg; \n      (u,Call p,u')\\<in>edges fg \n    \\<rbrakk> \\<Longrightarrow> P\" \n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A"], ["proof (prove)\nusing this:\n  ((u # r, c), ee, s', c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: ntrs.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p u' w v.\n       \\<lbrakk>ee = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case ntrs_step"], ["proof (state)\nthis:\n  ee = LCall p_ # w_\n  s' = v_ # u'_ # r\n  ((u # r, c), LCall p_, entry fg p_ # u'_ # r, c) \\<in> trss fg\n  (([entry fg p_], c), w_, [v_], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>p u' w v.\n       \\<lbrakk>ee = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  ee = LCall p_ # w_\n  s' = v_ # u'_ # r\n  ((u # r, c), LCall p_, entry fg p_ # u'_ # r, c) \\<in> trss fg\n  (([entry fg p_], c), w_, [v_], c') \\<in> trcl (trss fg)", "obtain u' v p w where CASE: \"ee=LCall p#w\" \"s'=v#u'#r\" \"((u#r,c),LCall p,(entry fg p#u'#r,c))\\<in>trss fg\" \"(([entry fg p],c),w,([v],c'))\\<in>trcl (trss fg)\""], ["proof (prove)\nusing this:\n  ee = LCall p_ # w_\n  s' = v_ # u'_ # r\n  ((u # r, c), LCall p_, entry fg p_ # u'_ # r, c) \\<in> trss fg\n  (([entry fg p_], c), w_, [v_], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. (\\<And>p w v u'.\n        \\<lbrakk>ee = LCall p # w; s' = v # u' # r;\n         ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n         (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp)"], ["proof (state)\nthis:\n  ee = LCall p # w\n  s' = v # u' # r\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n\ngoal (1 subgoal):\n 1. \\<And>p u' w v.\n       \\<lbrakk>ee = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from trss_stack_decomp_s[where s=\"[u]\", simplified, OF CASE(3)]"], ["proof (chain)\npicking this:\n  \\<exists>sp'.\n     entry fg p # u' # r = sp' @ r \\<and>\n     (([u], c), LCall p, sp', c) \\<in> trss fg", "have SDC: \"(([u], c), LCall p, ([entry fg p, u'], c)) \\<in> trss fg\""], ["proof (prove)\nusing this:\n  \\<exists>sp'.\n     entry fg p # u' # r = sp' @ r \\<and>\n     (([u], c), LCall p, sp', c) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([u], c), LCall p, [entry fg p, u'], c) \\<in> trss fg", "by auto"], ["proof (state)\nthis:\n  (([u], c), LCall p, [entry fg p, u'], c) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. \\<And>p u' w v.\n       \\<lbrakk>ee = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "with CASE(1,4)"], ["proof (chain)\npicking this:\n  ee = LCall p # w\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n  (([u], c), LCall p, [entry fg p, u'], c) \\<in> trss fg", "have \"(([u],c),ee,([v,u'],c'))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  ee = LCall p # w\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n  (([u], c), LCall p, [entry fg p, u'], c) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (([u], c), ee, [v, u'], c') \\<in> ntrs fg", "by (auto intro!: ntrs.ntrs_step)"], ["proof (state)\nthis:\n  (([u], c), ee, [v, u'], c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>p u' w v.\n       \\<lbrakk>ee = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  (([u], c), ee, [v, u'], c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>p u' w v.\n       \\<lbrakk>ee = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from SDC"], ["proof (chain)\npicking this:\n  (([u], c), LCall p, [entry fg p, u'], c) \\<in> trss fg", "have \"(u,Call p,u')\\<in>edges fg\""], ["proof (prove)\nusing this:\n  (([u], c), LCall p, [entry fg p, u'], c) \\<in> trss fg\n\ngoal (1 subgoal):\n 1. (u, Call p, u') \\<in> edges fg", "by (auto elim!: trss.cases)"], ["proof (state)\nthis:\n  (u, Call p, u') \\<in> edges fg\n\ngoal (1 subgoal):\n 1. \\<And>p u' w v.\n       \\<lbrakk>ee = LCall p # w; s' = v # u' # r;\n        ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n        (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\\<rbrakk>\n       \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  (([u], c), ee, [v, u'], c') \\<in> ntrs fg\n  (u, Call p, u') \\<in> edges fg", "show ?thesis"], ["proof (prove)\nusing this:\n  (([u], c), ee, [v, u'], c') \\<in> ntrs fg\n  (u, Call p, u') \\<in> edges fg\n\ngoal (1 subgoal):\n 1. P", "using CASE(2)"], ["proof (prove)\nusing this:\n  (([u], c), ee, [v, u'], c') \\<in> ntrs fg\n  (u, Call p, u') \\<in> edges fg\n  s' = v # u' # r\n\ngoal (1 subgoal):\n 1. P", "by (blast intro!: EX)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ntrs_stack_decomp_s: \n  assumes A: \"((u#s@r,c),ee,(s',c'))\\<in>ntrs fg\" \n  and EX: \"!!v u' p. \\<lbrakk> \n      s'=v#u'#s@r; \n      ((u#s,c),ee,(v#u'#s,c'))\\<in>ntrs fg; \n      (u,Call p,u')\\<in>edges fg\n    \\<rbrakk> \\<Longrightarrow> P\" \n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "apply (rule ntrs_stack_top_decomp_s[OF A])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v u' p.\n       \\<lbrakk>s' = v # u' # s @ r;\n        (([u], c), ee, [v, u'], c') \\<in> ntrs fg;\n        (u, Call p, u') \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> P", "apply (rule EX)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v u' p.\n       \\<lbrakk>s' = v # u' # s @ r;\n        (([u], c), ee, [v, u'], c') \\<in> ntrs fg;\n        (u, Call p, u') \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> s' = ?v2 v u' p # ?u'2 v u' p # s @ r\n 2. \\<And>v u' p.\n       \\<lbrakk>s' = v # u' # s @ r;\n        (([u], c), ee, [v, u'], c') \\<in> ntrs fg;\n        (u, Call p, u') \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> ((u # s, c), ee, ?v2 v u' p # ?u'2 v u' p # s, c')\n                         \\<in> ntrs fg\n 3. \\<And>v u' p.\n       \\<lbrakk>s' = v # u' # s @ r;\n        (([u], c), ee, [v, u'], c') \\<in> ntrs fg;\n        (u, Call p, u') \\<in> edges fg\\<rbrakk>\n       \\<Longrightarrow> (u, Call (?p2 v u' p), ?u'2 v u' p) \\<in> edges fg", "apply (auto dest: ntrs_stack_comp_s)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ntrs_stack_decomp: \"!!u s r c P. \\<lbrakk>\n    ((u#s@r,c),ww,(s',c'))\\<in>trcl (ntrs fg); \n    !!v rr. \\<lbrakk>s'=v#rr@r; ((u#s,c),ww,(v#rr,c'))\\<in>trcl (ntrs fg)\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s r c P.\n       \\<lbrakk>((u # s @ r, c), ww, s', c') \\<in> trcl (ntrs fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), ww, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "proof (induct ww)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u s r c P.\n       \\<lbrakk>((u # s @ r, c), [], s', c') \\<in> trcl (ntrs fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), [], v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrs fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrs fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case Nil"], ["proof (state)\nthis:\n  ((u # s @ r, c), [], s', c') \\<in> trcl (ntrs fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), [], ?v # ?rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<And>u s r c P.\n       \\<lbrakk>((u # s @ r, c), [], s', c') \\<in> trcl (ntrs fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), [], v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrs fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrs fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?case"], ["proof (prove)\nusing this:\n  ((u # s @ r, c), [], s', c') \\<in> trcl (ntrs fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), [], ?v # ?rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by fastforce"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrs fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrs fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrs fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrs fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (Cons e w)"], ["proof (state)\nthis:\n  \\<lbrakk>((?u # ?s @ ?r, ?c), w, s', c') \\<in> trcl (ntrs fg);\n   \\<And>v rr.\n      \\<lbrakk>s' = v # rr @ ?r;\n       ((?u # ?s, ?c), w, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  ((u # s @ r, c), e # w, s', c') \\<in> trcl (ntrs fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrs fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrs fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrs fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "from Cons.prems"], ["proof (chain)\npicking this:\n  ((u # s @ r, c), e # w, s', c') \\<in> trcl (ntrs fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n  \\<Longrightarrow> P", "show ?case"], ["proof (prove)\nusing this:\n  ((u # s @ r, c), e # w, s', c') \\<in> trcl (ntrs fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: trcl_pair_unconsE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sh ch.\n       \\<lbrakk>\\<And>v rr.\n                   \\<lbrakk>s' = v # rr @ r;\n                    ((u # s, c), e # w, v # rr, c')\n                    \\<in> trcl (ntrs fg)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), e, sh, ch) \\<in> ntrs fg;\n        ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case (split sh ch)"], ["proof (state)\nthis:\n  ((u # s @ r, c), e, sh, ch) \\<in> ntrs fg\n  ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>sh ch.\n       \\<lbrakk>\\<And>v rr.\n                   \\<lbrakk>s' = v # rr @ r;\n                    ((u # s, c), e # w, v # rr, c')\n                    \\<in> trcl (ntrs fg)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), e, sh, ch) \\<in> ntrs fg;\n        ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from ntrs_stack_decomp_s[OF split(1)]"], ["proof (chain)\npicking this:\n  (\\<And>v u' p.\n      \\<lbrakk>sh = v # u' # s @ r;\n       ((u # s, c), e, v # u' # s, ch) \\<in> ntrs fg;\n       (u, Call p, u') \\<in> edges fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain vh uh p where F: \"sh = vh#uh#s@r\" \"((u#s, c), e, vh#uh#s, ch) \\<in> ntrs fg\" \"(u, Call p, uh) \\<in> edges fg\""], ["proof (prove)\nusing this:\n  (\\<And>v u' p.\n      \\<lbrakk>sh = v # u' # s @ r;\n       ((u # s, c), e, v # u' # s, ch) \\<in> ntrs fg;\n       (u, Call p, u') \\<in> edges fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>vh uh p.\n        \\<lbrakk>sh = vh # uh # s @ r;\n         ((u # s, c), e, vh # uh # s, ch) \\<in> ntrs fg;\n         (u, Call p, uh) \\<in> edges fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sh = vh # uh # s @ r\n  ((u # s, c), e, vh # uh # s, ch) \\<in> ntrs fg\n  (u, Call p, uh) \\<in> edges fg\n\ngoal (1 subgoal):\n 1. \\<And>sh ch.\n       \\<lbrakk>\\<And>v rr.\n                   \\<lbrakk>s' = v # rr @ r;\n                    ((u # s, c), e # w, v # rr, c')\n                    \\<in> trcl (ntrs fg)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), e, sh, ch) \\<in> ntrs fg;\n        ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from F(1) split(2) Cons.hyps[of vh \"uh#s\" r ch]"], ["proof (chain)\npicking this:\n  sh = vh # uh # s @ r\n  ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\n  \\<lbrakk>((vh # (uh # s) @ r, ch), w, s', c') \\<in> trcl (ntrs fg);\n   \\<And>v rr.\n      \\<lbrakk>s' = v # rr @ r;\n       ((vh # uh # s, ch), w, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P", "obtain v' rr where S: \"s'=v'#rr@r\" \"((vh#uh#s,ch),w,(v'#rr,c'))\\<in>trcl (ntrs fg)\""], ["proof (prove)\nusing this:\n  sh = vh # uh # s @ r\n  ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\n  \\<lbrakk>((vh # (uh # s) @ r, ch), w, s', c') \\<in> trcl (ntrs fg);\n   \\<And>v rr.\n      \\<lbrakk>s' = v # rr @ r;\n       ((vh # uh # s, ch), w, v # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>v' rr.\n        \\<lbrakk>s' = v' # rr @ r;\n         ((vh # uh # s, ch), w, v' # rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' = v' # rr @ r\n  ((vh # uh # s, ch), w, v' # rr, c') \\<in> trcl (ntrs fg)\n\ngoal (1 subgoal):\n 1. \\<And>sh ch.\n       \\<lbrakk>\\<And>v rr.\n                   \\<lbrakk>s' = v # rr @ r;\n                    ((u # s, c), e # w, v # rr, c')\n                    \\<in> trcl (ntrs fg)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), e, sh, ch) \\<in> ntrs fg;\n        ((sh, ch), w, s', c') \\<in> trcl (ntrs fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from trcl.cons[OF F(2) S(2)] S(1) Cons.prems(2)"], ["proof (chain)\npicking this:\n  ((u # s, c), e # w, v' # rr, c') \\<in> trcl (ntrs fg)\n  s' = v' # rr @ r\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n  \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\nusing this:\n  ((u # s, c), e # w, v' # rr, c') \\<in> trcl (ntrs fg)\n  s' = v' # rr @ r\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrs fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ntrp_stack_decomp_s: \n  assumes A: \"((u#s@r,c),ee,(s',c'))\\<in>ntrp fg\" \n  and EX: \"!!v rr. \\<lbrakk> s'=v#rr@r; ((u#s,c),ee,(v#rr,c'))\\<in>ntrp fg \\<rbrakk> \\<Longrightarrow> P\" \n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A"], ["proof (prove)\nusing this:\n  ((u # s @ r, c), ee, s', c') \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: gtrp.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e;\n        ((u # s @ r, c), e, s', c') \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = u # s @ r;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset (u # s @ r) ca), e, s'a, add_mset (u # s @ r) c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P", "case gtrp_loc"], ["proof (state)\nthis:\n  ee = LOC e_\n  ((u # s @ r, c), e_, s', c') \\<in> ntrs fg\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e;\n        ((u # s @ r, c), e, s', c') \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = u # s @ r;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset (u # s @ r) ca), e, s'a, add_mset (u # s @ r) c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  ee = LOC e_\n  ((u # s @ r, c), e_, s', c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. P", "using EX"], ["proof (prove)\nusing this:\n  ee = LOC e_\n  ((u # s @ r, c), e_, s', c') \\<in> ntrs fg\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), ee, ?v # ?rr, c') \\<in> ntrp fg\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (force elim!: ntrs_stack_decomp_s intro!: gtrp.intros)"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = u # s @ r;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset (u # s @ r) ca), e, s'a, add_mset (u # s @ r) c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = u # s @ r;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset (u # s @ r) ca), e, s'a, add_mset (u # s @ r) c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P", "case gtrp_env"], ["proof (state)\nthis:\n  c = add_mset s_ c_\n  ee = ENV e_\n  s' = u # s @ r\n  c' = add_mset s'_ c'_\n  ((s_, add_mset (u # s @ r) c_), e_, s'_, add_mset (u # s @ r) c'_)\n  \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = u # s @ r;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset (u # s @ r) ca), e, s'a, add_mset (u # s @ r) c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  c = add_mset s_ c_\n  ee = ENV e_\n  s' = u # s @ r\n  c' = add_mset s'_ c'_\n  ((s_, add_mset (u # s @ r) c_), e_, s'_, add_mset (u # s @ r) c'_)\n  \\<in> ntrs fg", "obtain e ss ss' ce ce' where S: \"ee=ENV e\" \"s'=u#s@r\" \"c={#ss#}+ce\" \"c'={#ss'#}+ce'\" \"((ss,ce+{#u#s@r#}),e,(ss',ce'+{#u#s@r#}))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  c = add_mset s_ c_\n  ee = ENV e_\n  s' = u # s @ r\n  c' = add_mset s'_ c'_\n  ((s_, add_mset (u # s @ r) c_), e_, s'_, add_mset (u # s @ r) c'_)\n  \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>e ss ce ss' ce'.\n        \\<lbrakk>ee = ENV e; s' = u # s @ r; c = {#ss#} + ce;\n         c' = {#ss'#} + ce';\n         ((ss, ce + {#u # s @ r#}), e, ss', ce' + {#u # s @ r#})\n         \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  ee = ENV e\n  s' = u # s @ r\n  c = {#ss#} + ce\n  c' = {#ss'#} + ce'\n  ((ss, ce + {#u # s @ r#}), e, ss', ce' + {#u # s @ r#}) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = u # s @ r;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset (u # s @ r) ca), e, s'a, add_mset (u # s @ r) c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P", "from ntrs_replace_context_s[OF S(5), where crn=\"{#u#s#}\"]"], ["proof (chain)\npicking this:\n  mon_c fg {#u # s#} \\<subseteq> mon_c fg {#u # s @ r#} \\<Longrightarrow>\n  ((ss, ce + {#u # s#}), e, ss', ce' + {#u # s#}) \\<in> ntrs fg", "have \"((ss, {#u # s#} + ce), e, ss', {#u # s#} + ce') \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  mon_c fg {#u # s#} \\<subseteq> mon_c fg {#u # s @ r#} \\<Longrightarrow>\n  ((ss, ce + {#u # s#}), e, ss', ce' + {#u # s#}) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((ss, {#u # s#} + ce), e, ss', {#u # s#} + ce') \\<in> ntrs fg", "by (auto simp add: mon_s_unconc union_ac)"], ["proof (state)\nthis:\n  ((ss, {#u # s#} + ce), e, ss', {#u # s#} + ce') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa ca e s'a c'a.\n       \\<lbrakk>c = add_mset sa ca; ee = ENV e; s' = u # s @ r;\n        c' = add_mset s'a c'a;\n        ((sa, add_mset (u # s @ r) ca), e, s'a, add_mset (u # s @ r) c'a)\n        \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> P", "with S"], ["proof (chain)\npicking this:\n  ee = ENV e\n  s' = u # s @ r\n  c = {#ss#} + ce\n  c' = {#ss'#} + ce'\n  ((ss, ce + {#u # s @ r#}), e, ss', ce' + {#u # s @ r#}) \\<in> ntrs fg\n  ((ss, {#u # s#} + ce), e, ss', {#u # s#} + ce') \\<in> ntrs fg", "show P"], ["proof (prove)\nusing this:\n  ee = ENV e\n  s' = u # s @ r\n  c = {#ss#} + ce\n  c' = {#ss'#} + ce'\n  ((ss, ce + {#u # s @ r#}), e, ss', ce' + {#u # s @ r#}) \\<in> ntrs fg\n  ((ss, {#u # s#} + ce), e, ss', {#u # s#} + ce') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. P", "by (rule_tac EX) (auto intro: gtrp.gtrp_env)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ntrp_stack_decomp: \"!!u s r c P. \\<lbrakk>\n    ((u#s@r,c),ww,(s',c'))\\<in>trcl (ntrp fg); \n    !!v rr. \\<lbrakk>s'=v#rr@r; ((u#s,c),ww,(v#rr,c'))\\<in>trcl (ntrp fg)\\<rbrakk> \\<Longrightarrow> P \n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s r c P.\n       \\<lbrakk>((u # s @ r, c), ww, s', c') \\<in> trcl (ntrp fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), ww, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "proof (induct ww)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u s r c P.\n       \\<lbrakk>((u # s @ r, c), [], s', c') \\<in> trcl (ntrp fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), [], v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrp fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrp fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrp fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case Nil"], ["proof (state)\nthis:\n  ((u # s @ r, c), [], s', c') \\<in> trcl (ntrp fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), [], ?v # ?rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (2 subgoals):\n 1. \\<And>u s r c P.\n       \\<lbrakk>((u # s @ r, c), [], s', c') \\<in> trcl (ntrp fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), [], v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrp fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrp fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrp fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "thus ?case"], ["proof (prove)\nusing this:\n  ((u # s @ r, c), [], s', c') \\<in> trcl (ntrp fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), [], ?v # ?rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by fastforce"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrp fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrp fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrp fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrp fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrp fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrp fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (Cons e w)"], ["proof (state)\nthis:\n  \\<lbrakk>((?u # ?s @ ?r, ?c), w, s', c') \\<in> trcl (ntrp fg);\n   \\<And>v rr.\n      \\<lbrakk>s' = v # rr @ ?r;\n       ((?u # ?s, ?c), w, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  ((u # s @ r, c), e # w, s', c') \\<in> trcl (ntrp fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>a ww u s r c P.\n       \\<lbrakk>\\<And>u s r c P.\n                   \\<lbrakk>((u # s @ r, c), ww, s', c')\n                            \\<in> trcl (ntrp fg);\n                    \\<And>v rr.\n                       \\<lbrakk>s' = v # rr @ r;\n                        ((u # s, c), ww, v # rr, c')\n                        \\<in> trcl (ntrp fg)\\<rbrakk>\n                       \\<Longrightarrow> P\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), a # ww, s', c') \\<in> trcl (ntrp fg);\n        \\<And>v rr.\n           \\<lbrakk>s' = v # rr @ r;\n            ((u # s, c), a # ww, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "from Cons.prems"], ["proof (chain)\npicking this:\n  ((u # s @ r, c), e # w, s', c') \\<in> trcl (ntrp fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n  \\<Longrightarrow> P", "show ?case"], ["proof (prove)\nusing this:\n  ((u # s @ r, c), e # w, s', c') \\<in> trcl (ntrp fg)\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: trcl_pair_unconsE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sh ch.\n       \\<lbrakk>\\<And>v rr.\n                   \\<lbrakk>s' = v # rr @ r;\n                    ((u # s, c), e # w, v # rr, c')\n                    \\<in> trcl (ntrp fg)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), e, sh, ch) \\<in> ntrp fg;\n        ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> P", "case (split sh ch)"], ["proof (state)\nthis:\n  ((u # s @ r, c), e, sh, ch) \\<in> ntrp fg\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>sh ch.\n       \\<lbrakk>\\<And>v rr.\n                   \\<lbrakk>s' = v # rr @ r;\n                    ((u # s, c), e # w, v # rr, c')\n                    \\<in> trcl (ntrp fg)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), e, sh, ch) \\<in> ntrp fg;\n        ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from ntrp_stack_decomp_s[OF split(1)]"], ["proof (chain)\npicking this:\n  (\\<And>v rr.\n      \\<lbrakk>sh = v # rr @ r;\n       ((u # s, c), e, v # rr, ch) \\<in> ntrp fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain vh rrh where F: \"sh = vh#rrh@r\" \"((u#s, c), e, vh#rrh, ch) \\<in> ntrp fg\""], ["proof (prove)\nusing this:\n  (\\<And>v rr.\n      \\<lbrakk>sh = v # rr @ r;\n       ((u # s, c), e, v # rr, ch) \\<in> ntrp fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>vh rrh.\n        \\<lbrakk>sh = vh # rrh @ r;\n         ((u # s, c), e, vh # rrh, ch) \\<in> ntrp fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sh = vh # rrh @ r\n  ((u # s, c), e, vh # rrh, ch) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<And>sh ch.\n       \\<lbrakk>\\<And>v rr.\n                   \\<lbrakk>s' = v # rr @ r;\n                    ((u # s, c), e # w, v # rr, c')\n                    \\<in> trcl (ntrp fg)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), e, sh, ch) \\<in> ntrp fg;\n        ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from F(1) split(2) Cons.hyps[of vh \"rrh\" r ch]"], ["proof (chain)\npicking this:\n  sh = vh # rrh @ r\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n  \\<lbrakk>((vh # rrh @ r, ch), w, s', c') \\<in> trcl (ntrp fg);\n   \\<And>v rr.\n      \\<lbrakk>s' = v # rr @ r;\n       ((vh # rrh, ch), w, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P", "obtain v' rr where S: \"s'=v'#rr@r\" \"((vh#rrh,ch),w,(v'#rr,c'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  sh = vh # rrh @ r\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n  \\<lbrakk>((vh # rrh @ r, ch), w, s', c') \\<in> trcl (ntrp fg);\n   \\<And>v rr.\n      \\<lbrakk>s' = v # rr @ r;\n       ((vh # rrh, ch), w, v # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>v' rr.\n        \\<lbrakk>s' = v' # rr @ r;\n         ((vh # rrh, ch), w, v' # rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' = v' # rr @ r\n  ((vh # rrh, ch), w, v' # rr, c') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>sh ch.\n       \\<lbrakk>\\<And>v rr.\n                   \\<lbrakk>s' = v # rr @ r;\n                    ((u # s, c), e # w, v # rr, c')\n                    \\<in> trcl (ntrp fg)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        ((u # s @ r, c), e, sh, ch) \\<in> ntrp fg;\n        ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> P", "from trcl.cons[OF F(2) S(2)] S(1) Cons.prems(2)"], ["proof (chain)\npicking this:\n  ((u # s, c), e # w, v' # rr, c') \\<in> trcl (ntrp fg)\n  s' = v' # rr @ r\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n  \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\nusing this:\n  ((u # s, c), e # w, v' # rr, c') \\<in> trcl (ntrp fg)\n  s' = v' # rr @ r\n  \\<lbrakk>s' = ?v # ?rr @ r;\n   ((u # s, c), e # w, ?v # ?rr, c') \\<in> trcl (ntrp fg)\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Relation to monitor consistent interleaving\\<close>"], ["", "text \\<open>\n  In this section, we describe the relation of the consistent interleaving operator (cf. Section~\\ref{thy:ConsInterleave}) and the macrostep-semantics.\n\\<close>"], ["", "subsubsection \\<open>Abstraction function for normalized paths\\<close>"], ["", "text \\<open>\n  We first need to define an abstraction function that maps a macrostep on a pair of entered and passed monitors, as required by the \\<open>\\<otimes>\\<^bsub>\\<alpha>\\<^esub>\\<close>-operator: \n  \n  A step on a normalized paths enters the monitors of the first called procedure and passes the monitors that occur in the following same-level path.\n\\<close>"], ["", "definition \n  \"\\<alpha>n fg e == if e=[] then ({},{}) else (mon_e fg (hd e), mon_w fg (tl e))\""], ["", "(* TODO: We could also use a primrec here, this would generate simps- (and induct-) lemmas automatically *)"], ["", "lemma \\<alpha>n_simps[simp]: \n  \"\\<alpha>n fg [] = ({},{})\" \n  \"\\<alpha>n fg (e#w) = (mon_e fg e, mon_w fg w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>n fg [] = ({}, {}) &&&\n    \\<alpha>n fg (e # w) = (mon_e fg e, mon_w fg w)", "by (unfold \\<alpha>n_def, auto)\n\n\\<comment> \\<open>We also need an abstraction function for normalized loc/env-paths\\<close>"], ["", "definition \n  \"\\<alpha>nl fg e == \\<alpha>n fg (le_rem_s e)\""], ["", "lemma \\<alpha>nl_def': \"\\<alpha>nl fg == \\<alpha>n fg \\<circ> le_rem_s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>nl fg \\<equiv> \\<alpha>n fg \\<circ> le_rem_s", "by (rule eq_reflection[OF ext]) (auto simp add: \\<alpha>nl_def)\n\n\\<comment> \\<open>These are some ad-hoc simplifications, with the aim at converting @{term \"\\<alpha>nl\"} back to @{term \"\\<alpha>n\"}\\<close>"], ["", "lemma \\<alpha>nl_simps[simp]: \n  \"\\<alpha>nl fg (ENV x) = \\<alpha>n fg x\" \n  \"\\<alpha>nl fg (LOC x) = \\<alpha>n fg x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>nl fg (ENV x) = \\<alpha>n fg x &&&\n    \\<alpha>nl fg (LOC x) = \\<alpha>n fg x", "by (unfold \\<alpha>nl_def, auto)"], ["", "lemma \\<alpha>nl_simps1[simp]:\n  \"(\\<alpha>nl fg) \\<circ> ENV = \\<alpha>n fg\"\n  \"(\\<alpha>nl fg) \\<circ> LOC = \\<alpha>n fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>nl fg \\<circ> ENV = \\<alpha>n fg &&&\n    \\<alpha>nl fg \\<circ> LOC = \\<alpha>n fg", "by (unfold \\<alpha>nl_def' comp_def) (simp_all)"], ["", "lemma \\<alpha>n_\\<alpha>nl: \"(\\<alpha>n fg) \\<circ> le_rem_s = \\<alpha>nl fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>n fg \\<circ> le_rem_s = \\<alpha>nl fg", "unfolding \\<alpha>nl_def'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>nl fg = \\<alpha>nl fg", ".."], ["", "lemma \\<alpha>n_fst_snd[simp]: \"fst (\\<alpha>n fg w) \\<union> snd (\\<alpha>n fg w) = mon_w fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<alpha>n fg w) \\<union> snd (\\<alpha>n fg w) = mon_w fg w", "by (induct w) auto"], ["", "lemma mon_pl_of_\\<alpha>nl: \"mon_pl (map (\\<alpha>nl fg) w) = mon_loc fg w \\<union> mon_env fg w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_pl (map (\\<alpha>nl fg) w) = mon_loc fg w \\<union> mon_env fg w", "by (induct w) (auto split: el_step.split)"], ["", "text \\<open>We now derive specialized introduction lemmas for \\<open>\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>\\<close>\\<close>"], ["", "lemma cil_\\<alpha>n_cons_helper: \"mon_pl (map (\\<alpha>n fg) wb) = mon_ww fg wb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_pl (map (\\<alpha>n fg) wb) = mon_ww fg wb", "apply (unfold mon_pl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<union>) {}\n     (map (\\<lambda>e. fst e \\<union> snd e) (map (\\<alpha>n fg) wb)) =\n    mon_ww fg wb", "apply (induct wb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. foldl (\\<union>) {}\n     (map (\\<lambda>e. fst e \\<union> snd e) (map (\\<alpha>n fg) [])) =\n    mon_ww fg []\n 2. \\<And>a wb.\n       foldl (\\<union>) {}\n        (map (\\<lambda>e. fst e \\<union> snd e) (map (\\<alpha>n fg) wb)) =\n       mon_ww fg wb \\<Longrightarrow>\n       foldl (\\<union>) {}\n        (map (\\<lambda>e. fst e \\<union> snd e)\n          (map (\\<alpha>n fg) (a # wb))) =\n       mon_ww fg (a # wb)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a wb.\n       foldl (\\<union>) {}\n        (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ> \\<alpha>n fg) wb) =\n       mon_ww fg wb \\<Longrightarrow>\n       foldl (\\<union>) (mon_w fg a)\n        (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ> \\<alpha>n fg) wb) =\n       mon_w fg a \\<union> mon_ww fg wb", "apply (unfold mon_ww_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a wb.\n       foldl (\\<union>) {}\n        (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ> \\<alpha>n fg) wb) =\n       foldl (\\<union>) {} (map (mon_w fg) wb) \\<Longrightarrow>\n       foldl (\\<union>) (mon_w fg a)\n        (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ> \\<alpha>n fg) wb) =\n       mon_w fg a \\<union> foldl (\\<union>) {} (map (mon_w fg) wb)", "apply (subst foldl_un_empty_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a wb.\n       foldl (\\<union>) {}\n        (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ> \\<alpha>n fg) wb) =\n       foldl (\\<union>) {} (map (mon_w fg) wb) \\<Longrightarrow>\n       mon_w fg a \\<union>\n       foldl (\\<union>) {}\n        (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ> \\<alpha>n fg) wb) =\n       mon_w fg a \\<union> foldl (\\<union>) {} (map (mon_w fg) wb)", "apply (case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a wb.\n       \\<lbrakk>foldl (\\<union>) {}\n                 (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ>\n                       \\<alpha>n fg)\n                   wb) =\n                foldl (\\<union>) {} (map (mon_w fg) wb);\n        a = []\\<rbrakk>\n       \\<Longrightarrow> mon_w fg a \\<union>\n                         foldl (\\<union>) {}\n                          (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ>\n                                \\<alpha>n fg)\n                            wb) =\n                         mon_w fg a \\<union>\n                         foldl (\\<union>) {} (map (mon_w fg) wb)\n 2. \\<And>a wb aa list.\n       \\<lbrakk>foldl (\\<union>) {}\n                 (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ>\n                       \\<alpha>n fg)\n                   wb) =\n                foldl (\\<union>) {} (map (mon_w fg) wb);\n        a = aa # list\\<rbrakk>\n       \\<Longrightarrow> mon_w fg a \\<union>\n                         foldl (\\<union>) {}\n                          (map ((\\<lambda>e. fst e \\<union> snd e) \\<circ>\n                                \\<alpha>n fg)\n                            wb) =\n                         mon_w fg a \\<union>\n                         foldl (\\<union>) {} (map (mon_w fg) wb)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cil_\\<alpha>nl_cons_helper: \n  \"mon_pl (map (\\<alpha>nl fg) wb) = mon_ww fg (map le_rem_s wb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_pl (map (\\<alpha>nl fg) wb) = mon_ww fg (map le_rem_s wb)", "by (simp add: \\<alpha>n_\\<alpha>nl cil_\\<alpha>n_cons_helper[symmetric])"], ["", "lemma cil_\\<alpha>n_cons1: \"\\<lbrakk>w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb; fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\\<rbrakk> \n  \\<Longrightarrow> e#w \\<in> e#wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\\<rbrakk>\n    \\<Longrightarrow> e # w\n                      \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb", "apply (rule cil_cons1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\\<rbrakk>\n    \\<Longrightarrow> w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n 2. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\\<rbrakk>\n    \\<Longrightarrow> fst (\\<alpha>n fg e) \\<inter>\n                      mon_pl (map (\\<alpha>n fg) wb) =\n                      {}", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\\<rbrakk>\n    \\<Longrightarrow> fst (\\<alpha>n fg e) \\<inter>\n                      mon_pl (map (\\<alpha>n fg) wb) =\n                      {}", "apply (subst cil_\\<alpha>n_cons_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\\<rbrakk>\n    \\<Longrightarrow> fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cil_\\<alpha>n_cons2: \"\\<lbrakk>w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb; fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\\<rbrakk> \n  \\<Longrightarrow> e#w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e#wb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\\<rbrakk>\n    \\<Longrightarrow> e # w\n                      \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb", "apply (rule cil_cons2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\\<rbrakk>\n    \\<Longrightarrow> w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n 2. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\\<rbrakk>\n    \\<Longrightarrow> fst (\\<alpha>n fg e) \\<inter>\n                      mon_pl (map (\\<alpha>n fg) wa) =\n                      {}", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\\<rbrakk>\n    \\<Longrightarrow> fst (\\<alpha>n fg e) \\<inter>\n                      mon_pl (map (\\<alpha>n fg) wa) =\n                      {}", "apply (subst cil_\\<alpha>n_cons_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n     fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\\<rbrakk>\n    \\<Longrightarrow> fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Monitors\""], ["", "lemma (in flowgraph) ntrs_mon_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrs fg\" \n  shows \"mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)", "from A"], ["proof (chain)\npicking this:\n  ((s, c), e, s', c') \\<in> ntrs fg", "obtain u r p u' w v where DET: \"s=u#r\" \"e=LCall p#w\" \"((u#r,c),LCall p,(entry fg p#u'#r,c))\\<in>trss fg\" \"(([entry fg p],c),w,([v],c'))\\<in>trcl (trss fg)\" \"s'=v#u'#r\""], ["proof (prove)\nusing this:\n  ((s, c), e, s', c') \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>u r p w u' v.\n        \\<lbrakk>s = u # r; e = LCall p # w;\n         ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg;\n         (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg);\n         s' = v # u' # r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim!: ntrs.cases[simplified])"], ["proof (state)\nthis:\n  s = u # r\n  e = LCall p # w\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n  s' = v # u' # r\n\ngoal (1 subgoal):\n 1. mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)", "hence \"mon_n fg u = mon_n fg u'\""], ["proof (prove)\nusing this:\n  s = u # r\n  e = LCall p # w\n  ((u # r, c), LCall p, entry fg p # u' # r, c) \\<in> trss fg\n  (([entry fg p], c), w, [v], c') \\<in> trcl (trss fg)\n  s' = v # u' # r\n\ngoal (1 subgoal):\n 1. mon_n fg u = mon_n fg u'", "by (auto elim!: trss.cases dest: mon_n_same_proc edges_part)"], ["proof (state)\nthis:\n  mon_n fg u = mon_n fg u'\n\ngoal (1 subgoal):\n 1. mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)", "with trss_bot_proc_const[where s=\"[]\" and s'=\"[]\", simplified, OF DET(4)] DET(1,2,5)"], ["proof (chain)\npicking this:\n  proc_of fg (entry fg p) = proc_of fg v\n  s = u # r\n  e = LCall p # w\n  s' = v # u' # r\n  mon_n fg u = mon_n fg u'", "show ?thesis"], ["proof (prove)\nusing this:\n  proc_of fg (entry fg p) = proc_of fg v\n  s = u # r\n  e = LCall p # w\n  s' = v # u' # r\n  mon_n fg u = mon_n fg u'\n\ngoal (1 subgoal):\n 1. mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)", "by (auto simp add: mon_n_def \\<alpha>n_def)"], ["proof (state)\nthis:\n  mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary (in flowgraph) ntrs_called_mon: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrs fg\" \n  shows \"fst (\\<alpha>n fg e) \\<subseteq> mon_s fg s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<alpha>n fg e) \\<subseteq> mon_s fg s'", "using ntrs_mon_s[OF A]"], ["proof (prove)\nusing this:\n  mon_s fg s' = mon_s fg s \\<union> fst (\\<alpha>n fg e)\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>n fg e) \\<subseteq> mon_s fg s'", "by auto"], ["", "lemma (in flowgraph) ntr_mon_s: \n  \"(c,e,c')\\<in>ntr fg \\<Longrightarrow> mon_c fg c' = mon_c fg c \\<union> fst (\\<alpha>n fg e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, e, c') \\<in> ntr fg \\<Longrightarrow>\n    mon_c fg c' = mon_c fg c \\<union> fst (\\<alpha>n fg e)", "by (erule gtrE) (auto simp add: mon_c_unconc ntrs_c_no_mon_s ntrs_mon_s)"], ["", "lemma (in flowgraph) ntrp_mon_s: \n  assumes A: \"((s,c),e,(s',c'))\\<in>ntrp fg\" \n  shows \"mon_c fg (add_mset s' c') = mon_c fg (add_mset s c) \\<union> fst (\\<alpha>nl fg e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg (add_mset s' c') =\n    mon_c fg (add_mset s c) \\<union> fst (\\<alpha>nl fg e)", "using ntr_mon_s[OF gtrp2gtr_s[OF A]]"], ["proof (prove)\nusing this:\n  mon_c fg (add_mset s' c') =\n  mon_c fg (add_mset s c) \\<union> fst (\\<alpha>n fg (le_rem_s e))\n\ngoal (1 subgoal):\n 1. mon_c fg (add_mset s' c') =\n    mon_c fg (add_mset s c) \\<union> fst (\\<alpha>nl fg e)", "by (unfold \\<alpha>nl_def)"], ["", "subsubsection \\<open>Interleaving theorem\\<close>"], ["", "text \\<open>In this section, we show that the consistent interleaving operator describes the intuition behind interleavability of normalized paths. We show:\n  {\\em Two paths are simultaneously executable if and only if they are consistently interleavable and the monitors of the initial configurations are compatible}\n\\<close>"], ["", "text \\<open>The split lemma splits an execution from a context of the form @{term \"ca+cb\"} into two interleavable executions from @{term ca} and @{term cb} respectively.\n  While further down we prove this lemma for loc/env-path, which is more general but also more complicated, we start with the proof for paths of the multiset-semantics\n  for illustrating the idea.\n\\<close>"], ["", "lemma (in flowgraph) ntr_split: \n  \"!!ca cb. \\<lbrakk>(ca+cb,w,c')\\<in>trcl (ntr fg); valid fg (ca+cb)\\<rbrakk> \\<Longrightarrow> \n  \\<exists>ca' cb' wa wb. \n  c'=ca'+cb' \\<and> \n  w\\<in>(wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb) \\<and> \n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and> \n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and> \n  (ca,wa,ca')\\<in>trcl (ntr fg) \\<and> (cb,wb,cb')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "proof (induct w) \\<comment> \\<open>The proof is done by induction on the path\\<close>\n   \\<comment> \\<open>If the path is empty, the lemma is trivial\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ca cb.\n       \\<lbrakk>(ca + cb, [], c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            [] \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                    fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "case Nil"], ["proof (state)\nthis:\n  (ca + cb, [], c') \\<in> trcl (ntr fg)\n  valid fg (ca + cb)\n\ngoal (2 subgoals):\n 1. \\<And>ca cb.\n       \\<lbrakk>(ca + cb, [], c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            [] \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                    fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "thus ?case"], ["proof (prove)\nusing this:\n  (ca + cb, [], c') \\<in> trcl (ntr fg)\n  valid fg (ca + cb)\n\ngoal (1 subgoal):\n 1. \\<exists>ca' cb' wa wb.\n       c' = ca' + cb' \\<and>\n       [] \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n       (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg)", "by - (rule exI[of _ \"ca\"], rule exI[of _ \"cb\"], intro exI[of _ \"[]\"], auto simp add: valid_unconc)"], ["proof (state)\nthis:\n  \\<exists>ca' cb' wa wb.\n     c' = ca' + cb' \\<and>\n     [] \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n     (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "case (Cons e w)"], ["proof (state)\nthis:\n  \\<lbrakk>(?ca + ?cb, w, c') \\<in> trcl (ntr fg);\n   valid fg (?ca + ?cb)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                       c' = ca' + cb' \\<and>\n                       w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                       mon_c fg ?ca \\<inter>\n                       (mon_c fg ?cb \\<union> mon_ww fg wb) =\n                       {} \\<and>\n                       mon_c fg ?cb \\<inter>\n                       (mon_c fg ?ca \\<union> mon_ww fg waa) =\n                       {} \\<and>\n                       (?ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                       (?cb, wb, cb') \\<in> trcl (ntr fg)\n  (ca + cb, e # w, c') \\<in> trcl (ntr fg)\n  valid fg (ca + cb)\n\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "note IHP=this\n   \\<comment> \\<open>We split a non-empty paths after the first (macro) step\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>(?ca + ?cb, w, c') \\<in> trcl (ntr fg);\n   valid fg (?ca + ?cb)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                       c' = ca' + cb' \\<and>\n                       w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                       mon_c fg ?ca \\<inter>\n                       (mon_c fg ?cb \\<union> mon_ww fg wb) =\n                       {} \\<and>\n                       mon_c fg ?cb \\<inter>\n                       (mon_c fg ?ca \\<union> mon_ww fg waa) =\n                       {} \\<and>\n                       (?ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                       (?cb, wb, cb') \\<in> trcl (ntr fg)\n  (ca + cb, e # w, c') \\<in> trcl (ntr fg)\n  valid fg (ca + cb)\n\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?ca + ?cb, w, c') \\<in> trcl (ntr fg);\n   valid fg (?ca + ?cb)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                       c' = ca' + cb' \\<and>\n                       w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                       mon_c fg ?ca \\<inter>\n                       (mon_c fg ?cb \\<union> mon_ww fg wb) =\n                       {} \\<and>\n                       mon_c fg ?cb \\<inter>\n                       (mon_c fg ?ca \\<union> mon_ww fg waa) =\n                       {} \\<and>\n                       (?ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                       (?cb, wb, cb') \\<in> trcl (ntr fg)\n  (ca + cb, e # w, c') \\<in> trcl (ntr fg)\n  valid fg (ca + cb)", "obtain ch where SPLIT: \"(ca+cb,e,ch)\\<in>ntr fg\" \"(ch,w,c')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ca + ?cb, w, c') \\<in> trcl (ntr fg);\n   valid fg (?ca + ?cb)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                       c' = ca' + cb' \\<and>\n                       w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                       mon_c fg ?ca \\<inter>\n                       (mon_c fg ?cb \\<union> mon_ww fg wb) =\n                       {} \\<and>\n                       mon_c fg ?cb \\<inter>\n                       (mon_c fg ?ca \\<union> mon_ww fg waa) =\n                       {} \\<and>\n                       (?ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                       (?cb, wb, cb') \\<in> trcl (ntr fg)\n  (ca + cb, e # w, c') \\<in> trcl (ntr fg)\n  valid fg (ca + cb)\n\ngoal (1 subgoal):\n 1. (\\<And>ch.\n        \\<lbrakk>(ca + cb, e, ch) \\<in> ntr fg;\n         (ch, w, c') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)\n  \\<comment> \\<open>Pick the stack that made the first step\\<close>"], ["proof (state)\nthis:\n  (ca + cb, e, ch) \\<in> ntr fg\n  (ch, w, c') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "from gtrE[OF SPLIT(1)]"], ["proof (chain)\npicking this:\n  (\\<And>s ce s' ce'.\n      \\<lbrakk>ca + cb = add_mset s ce; ch = add_mset s' ce';\n       ((s, ce), e, s', ce') \\<in> ntrs fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain s ce sh ceh where NTRS: \"ca+cb=add_mset s ce\" \"ch=add_mset sh ceh\" \"((s,ce),e,(sh,ceh))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  (\\<And>s ce s' ce'.\n      \\<lbrakk>ca + cb = add_mset s ce; ch = add_mset s' ce';\n       ((s, ce), e, s', ce') \\<in> ntrs fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>s ce sh ceh.\n        \\<lbrakk>ca + cb = add_mset s ce; ch = add_mset sh ceh;\n         ((s, ce), e, sh, ceh) \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ". \n  \\<comment> \\<open>And separate the threads that where spawned during the first step from the ones that where already there\\<close>"], ["proof (state)\nthis:\n  ca + cb = add_mset s ce\n  ch = add_mset sh ceh\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "then"], ["proof (chain)\npicking this:\n  ca + cb = add_mset s ce\n  ch = add_mset sh ceh\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg", "obtain csp where CEHFMT: \"ceh=csp+ce\" \"mon_c fg csp={}\""], ["proof (prove)\nusing this:\n  ca + cb = add_mset s ce\n  ch = add_mset sh ceh\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        \\<lbrakk>ceh = csp + ce; mon_c fg csp = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: ntrs_c_cases_s intro!: c_of_initial_no_mon) \n\n  \\<comment> \\<open>Needed later: The first macrostep uses no monitors already owned by threads that where already there\\<close>"], ["proof (state)\nthis:\n  ceh = csp + ce\n  mon_c fg csp = {}\n\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "from ntrs_mon_e_no_ctx[OF NTRS(3)]"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg ce = {}", "have MONED: \"mon_w fg e \\<inter> mon_c fg ce = {}\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. mon_w fg e \\<inter> mon_c fg ce = {}", "by (auto simp add: mon_c_unconc) \n  \\<comment> \\<open>Needed later: The intermediate configuration is valid\\<close>"], ["proof (state)\nthis:\n  mon_w fg e \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "from ntr_valid_preserve_s[OF SPLIT(1) IHP(3)]"], ["proof (chain)\npicking this:\n  valid fg ch", "have CHVALID: \"valid fg ch\""], ["proof (prove)\nusing this:\n  valid fg ch\n\ngoal (1 subgoal):\n 1. valid fg ch", ". \n\n  \\<comment> \\<open>We make a case distinction whether the thread that made the first step was in the left or right part of the initial configuration\\<close>"], ["proof (state)\nthis:\n  valid fg ch\n\ngoal (1 subgoal):\n 1. \\<And>a w ca cb.\n       \\<lbrakk>\\<And>ca cb.\n                   \\<lbrakk>(ca + cb, w, c') \\<in> trcl (ntr fg);\n                    valid fg (ca + cb)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n  c' = ca' + cb' \\<and>\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n  (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg);\n        (ca + cb, a # w, c') \\<in> trcl (ntr fg);\n        valid fg (ca + cb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ca' cb' wa wb.\n                            c' = ca' + cb' \\<and>\n                            a # w\n                            \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n\n                 fg\\<^esub> wb \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg wa) =\n                            {} \\<and>\n                            (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg)", "from NTRS(1)[symmetric]"], ["proof (chain)\npicking this:\n  add_mset s ce = ca + cb", "show ?case"], ["proof (prove)\nusing this:\n  add_mset s ce = ca + cb\n\ngoal (1 subgoal):\n 1. \\<exists>ca' cb' waa wb.\n       c' = ca' + cb' \\<and>\n       e # w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg waa) = {} \\<and>\n       (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg)", "proof (cases rule: mset_unplusm_dist_cases) \n    \\<comment> \\<open>The first step was on a thread in the left part of the initial configuration\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "case left"], ["proof (state)\nthis:\n  ca = add_mset s (ca - {#s#})\n  ce = ca - {#s#} + cb\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "note CASE=this \n    \\<comment> \\<open>We can write the intermediate configuration so that it is suited for the induction hypothesis\\<close>"], ["proof (state)\nthis:\n  ca = add_mset s (ca - {#s#})\n  ce = ca - {#s#} + cb\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "with CEHFMT NTRS"], ["proof (chain)\npicking this:\n  ceh = csp + ce\n  mon_c fg csp = {}\n  ca + cb = add_mset s ce\n  ch = add_mset sh ceh\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n  ca = add_mset s (ca - {#s#})\n  ce = ca - {#s#} + cb", "have CHFMT: \"ch=({#sh#}+csp+(ca-{#s#}))+cb\""], ["proof (prove)\nusing this:\n  ceh = csp + ce\n  mon_c fg csp = {}\n  ca + cb = add_mset s ce\n  ch = add_mset sh ceh\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n  ca = add_mset s (ca - {#s#})\n  ce = ca - {#s#} + cb\n\ngoal (1 subgoal):\n 1. ch = {#sh#} + csp + (ca - {#s#}) + cb", "by (simp add: union_ac) \n    \\<comment> \\<open>and by the induction hypothesis, we split the path from the intermediate configuration\\<close>"], ["proof (state)\nthis:\n  ch = {#sh#} + csp + (ca - {#s#}) + cb\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "with IHP(1) SPLIT(2) CHVALID"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?ca + ?cb, w, c') \\<in> trcl (ntr fg);\n   valid fg (?ca + ?cb)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                       c' = ca' + cb' \\<and>\n                       w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                       mon_c fg ?ca \\<inter>\n                       (mon_c fg ?cb \\<union> mon_ww fg wb) =\n                       {} \\<and>\n                       mon_c fg ?cb \\<inter>\n                       (mon_c fg ?ca \\<union> mon_ww fg waa) =\n                       {} \\<and>\n                       (?ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                       (?cb, wb, cb') \\<in> trcl (ntr fg)\n  (ch, w, c') \\<in> trcl (ntr fg)\n  valid fg ch\n  ch = {#sh#} + csp + (ca - {#s#}) + cb", "obtain ca' cb' wa wb where IHAPP: \n      \"c'=ca'+cb'\" \n      \"w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb\" \n      \"mon_c fg ({#sh#}+csp+(ca-{#s#})) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb)={}\" \n      \"mon_c fg cb \\<inter> (mon_c fg ({#sh#}+csp+(ca-{#s#})) \\<union> mon_ww fg wa)={}\" \n      \"({#sh#}+csp+(ca-{#s#}),wa,ca')\\<in>trcl (ntr fg)\" \n      \"(cb,wb,cb')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ca + ?cb, w, c') \\<in> trcl (ntr fg);\n   valid fg (?ca + ?cb)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                       c' = ca' + cb' \\<and>\n                       w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                       mon_c fg ?ca \\<inter>\n                       (mon_c fg ?cb \\<union> mon_ww fg wb) =\n                       {} \\<and>\n                       mon_c fg ?cb \\<inter>\n                       (mon_c fg ?ca \\<union> mon_ww fg waa) =\n                       {} \\<and>\n                       (?ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                       (?cb, wb, cb') \\<in> trcl (ntr fg)\n  (ch, w, c') \\<in> trcl (ntr fg)\n  valid fg ch\n  ch = {#sh#} + csp + (ca - {#s#}) + cb\n\ngoal (1 subgoal):\n 1. (\\<And>ca' cb' waa wb.\n        \\<lbrakk>c' = ca' + cb';\n         w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n         mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n         (mon_c fg cb \\<union> mon_ww fg wb) =\n         {};\n         mon_c fg cb \\<inter>\n         (mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<union> mon_ww fg waa) =\n         {};\n         ({#sh#} + csp + (ca - {#s#}), waa, ca') \\<in> trcl (ntr fg);\n         (cb, wb, cb') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c' = ca' + cb'\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n  (mon_c fg cb \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<union> mon_ww fg wa) =\n  {}\n  ({#sh#} + csp + (ca - {#s#}), wa, ca') \\<in> trcl (ntr fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "moreover\n    \\<comment> \\<open>It remains to show that we can execute the first step with the right part of the configuration removed\\<close>"], ["proof (state)\nthis:\n  c' = ca' + cb'\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n  (mon_c fg cb \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<union> mon_ww fg wa) =\n  {}\n  ({#sh#} + csp + (ca - {#s#}), wa, ca') \\<in> trcl (ntr fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "have FIRSTSTEP: \"(ca,e,{#sh#}+csp+(ca-{#s#}))\\<in>ntr fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg", "from CASE(2)"], ["proof (chain)\npicking this:\n  ce = ca - {#s#} + cb", "have \"mon_c fg (ca-{#s#}) \\<subseteq> mon_c fg ce\""], ["proof (prove)\nusing this:\n  ce = ca - {#s#} + cb\n\ngoal (1 subgoal):\n 1. mon_c fg (ca - {#s#}) \\<subseteq> mon_c fg ce", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg (ca - {#s#}) \\<subseteq> mon_c fg ce\n\ngoal (1 subgoal):\n 1. (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg", "with ntrs_xchange_context_s NTRS(3) CEHFMT CASE(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?s, ?c), ?ee, ?s', ?csp + ?c) \\<in> ntrs ?fg;\n   mon_c ?fg ?cn \\<subseteq> mon_c ?fg ?c\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?cn), ?ee, ?s', ?csp + ?cn) \\<in> ntrs ?fg\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n  ceh = csp + ce\n  mon_c fg csp = {}\n  ce = ca - {#s#} + cb\n  mon_c fg (ca - {#s#}) \\<subseteq> mon_c fg ce", "have \"((s,ca-{#s#}),e,(sh,csp+(ca-{#s#})))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((?s, ?c), ?ee, ?s', ?csp + ?c) \\<in> ntrs ?fg;\n   mon_c ?fg ?cn \\<subseteq> mon_c ?fg ?c\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?cn), ?ee, ?s', ?csp + ?cn) \\<in> ntrs ?fg\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n  ceh = csp + ce\n  mon_c fg csp = {}\n  ce = ca - {#s#} + cb\n  mon_c fg (ca - {#s#}) \\<subseteq> mon_c fg ce\n\ngoal (1 subgoal):\n 1. ((s, ca - {#s#}), e, sh, csp + (ca - {#s#})) \\<in> ntrs fg", "by blast"], ["proof (state)\nthis:\n  ((s, ca - {#s#}), e, sh, csp + (ca - {#s#})) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg", "from gtrI_s[OF this] CASE(1)"], ["proof (chain)\npicking this:\n  (add_mset s (ca - {#s#}), e, add_mset sh (csp + (ca - {#s#})))\n  \\<in> ntr fg\n  ca = add_mset s (ca - {#s#})", "show ?thesis"], ["proof (prove)\nusing this:\n  (add_mset s (ca - {#s#}), e, add_mset sh (csp + (ca - {#s#})))\n  \\<in> ntr fg\n  ca = add_mset s (ca - {#s#})\n\ngoal (1 subgoal):\n 1. (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg", "by (auto simp add: union_assoc)"], ["proof (state)\nthis:\n  (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "with IHAPP(5)"], ["proof (chain)\npicking this:\n  ({#sh#} + csp + (ca - {#s#}), wa, ca') \\<in> trcl (ntr fg)\n  (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg", "have \"(ca,e#wa,ca')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  ({#sh#} + csp + (ca - {#s#}), wa, ca') \\<in> trcl (ntr fg)\n  (ca, e, {#sh#} + csp + (ca - {#s#})) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. (ca, e # wa, ca') \\<in> trcl (ntr fg)", "by simp"], ["proof (state)\nthis:\n  (ca, e # wa, ca') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "moreover\n    \\<comment> \\<open>and that we can prepend the first step to the interleaving\\<close>"], ["proof (state)\nthis:\n  (ca, e # wa, ca') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "have \"e#w \\<in> e#wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb", "from ntrs_called_mon[OF NTRS(3)]"], ["proof (chain)\npicking this:\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh", "have \"fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh\""], ["proof (prove)\nusing this:\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh", "."], ["proof (state)\nthis:\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh\n\ngoal (1 subgoal):\n 1. e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb", "with IHAPP(3)"], ["proof (chain)\npicking this:\n  mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n  (mon_c fg cb \\<union> mon_ww fg wb) =\n  {}\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh", "have \"fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\""], ["proof (prove)\nusing this:\n  mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n  (mon_c fg cb \\<union> mon_ww fg wb) =\n  {}\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  fst (\\<alpha>n fg e) \\<inter> mon_ww fg wb = {}\n\ngoal (1 subgoal):\n 1. e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb", "from cil_\\<alpha>n_cons1[OF IHAPP(2) this]"], ["proof (chain)\npicking this:\n  e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb", "show ?thesis"], ["proof (prove)\nusing this:\n  e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n\ngoal (1 subgoal):\n 1. e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb", "."], ["proof (state)\nthis:\n  e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "moreover\n    \\<comment> \\<open>and that the monitors of the initial context does not interfere\\<close>"], ["proof (state)\nthis:\n  e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "have \"mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\" \"mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e#wa)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} &&&\n    mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n 2. mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}", "from ntr_mon_increasing_s[OF FIRSTSTEP] IHAPP(3)"], ["proof (chain)\npicking this:\n  mon_c fg ca \\<subseteq> mon_c fg ({#sh#} + csp + (ca - {#s#}))\n  mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n  (mon_c fg cb \\<union> mon_ww fg wb) =\n  {}", "show \"mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\""], ["proof (prove)\nusing this:\n  mon_c fg ca \\<subseteq> mon_c fg ({#sh#} + csp + (ca - {#s#}))\n  mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n  (mon_c fg cb \\<union> mon_ww fg wb) =\n  {}\n\ngoal (1 subgoal):\n 1. mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n\ngoal (1 subgoal):\n 1. mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}", "from MONED CASE"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg ce = {}\n  ca = add_mset s (ca - {#s#})\n  ce = ca - {#s#} + cb", "have \"mon_c fg cb \\<inter> mon_w fg e = {}\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg ce = {}\n  ca = add_mset s (ca - {#s#})\n  ce = ca - {#s#} + cb\n\ngoal (1 subgoal):\n 1. mon_c fg cb \\<inter> mon_w fg e = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg cb \\<inter> mon_w fg e = {}\n\ngoal (1 subgoal):\n 1. mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}", "with ntr_mon_increasing_s[OF FIRSTSTEP] IHAPP(4)"], ["proof (chain)\npicking this:\n  mon_c fg ca \\<subseteq> mon_c fg ({#sh#} + csp + (ca - {#s#}))\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<union> mon_ww fg wa) =\n  {}\n  mon_c fg cb \\<inter> mon_w fg e = {}", "show \"mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e#wa)) = {}\""], ["proof (prove)\nusing this:\n  mon_c fg ca \\<subseteq> mon_c fg ({#sh#} + csp + (ca - {#s#}))\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<union> mon_ww fg wa) =\n  {}\n  mon_c fg cb \\<inter> mon_w fg e = {}\n\ngoal (1 subgoal):\n 1. mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ca = add_mset s (ca - {#s#}); ce = ca - {#s#} + cb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "ultimately"], ["proof (chain)\npicking this:\n  c' = ca' + cb'\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n  (mon_c fg cb \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<union> mon_ww fg wa) =\n  {}\n  ({#sh#} + csp + (ca - {#s#}), wa, ca') \\<in> trcl (ntr fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  (ca, e # wa, ca') \\<in> trcl (ntr fg)\n  e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  c' = ca' + cb'\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<inter>\n  (mon_c fg cb \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#sh#} + csp + (ca - {#s#})) \\<union> mon_ww fg wa) =\n  {}\n  ({#sh#} + csp + (ca - {#s#}), wa, ca') \\<in> trcl (ntr fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  (ca, e # wa, ca') \\<in> trcl (ntr fg)\n  e # w \\<in> e # wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # wa)) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ca' cb' waa wb.\n       c' = ca' + cb' \\<and>\n       e # w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg waa) = {} \\<and>\n       (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ca' cb' waa wb.\n     c' = ca' + cb' \\<and>\n     e # w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg waa) = {} \\<and>\n     (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "next\n    \\<comment> \\<open>The other case, that is if the first step was made on a thread in the right part of the configuration, is shown completely analogously\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "case right"], ["proof (state)\nthis:\n  cb = add_mset s (cb - {#s#})\n  ce = ca + (cb - {#s#})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "note CASE=this"], ["proof (state)\nthis:\n  cb = add_mset s (cb - {#s#})\n  ce = ca + (cb - {#s#})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "with CEHFMT NTRS"], ["proof (chain)\npicking this:\n  ceh = csp + ce\n  mon_c fg csp = {}\n  ca + cb = add_mset s ce\n  ch = add_mset sh ceh\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n  cb = add_mset s (cb - {#s#})\n  ce = ca + (cb - {#s#})", "have CHFMT: \"ch=ca+({#sh#}+csp+(cb-{#s#}))\""], ["proof (prove)\nusing this:\n  ceh = csp + ce\n  mon_c fg csp = {}\n  ca + cb = add_mset s ce\n  ch = add_mset sh ceh\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n  cb = add_mset s (cb - {#s#})\n  ce = ca + (cb - {#s#})\n\ngoal (1 subgoal):\n 1. ch = ca + ({#sh#} + csp + (cb - {#s#}))", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  ch = ca + ({#sh#} + csp + (cb - {#s#}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "with IHP(1) SPLIT(2) CHVALID"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?ca + ?cb, w, c') \\<in> trcl (ntr fg);\n   valid fg (?ca + ?cb)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                       c' = ca' + cb' \\<and>\n                       w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                       mon_c fg ?ca \\<inter>\n                       (mon_c fg ?cb \\<union> mon_ww fg wb) =\n                       {} \\<and>\n                       mon_c fg ?cb \\<inter>\n                       (mon_c fg ?ca \\<union> mon_ww fg waa) =\n                       {} \\<and>\n                       (?ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                       (?cb, wb, cb') \\<in> trcl (ntr fg)\n  (ch, w, c') \\<in> trcl (ntr fg)\n  valid fg ch\n  ch = ca + ({#sh#} + csp + (cb - {#s#}))", "obtain ca' cb' wa wb where IHAPP: \"c'=ca'+cb'\" \"w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb\" \"mon_c fg ca \\<inter> (mon_c fg ({#sh#}+csp+(cb-{#s#})) \\<union> mon_ww fg wb)={}\" \n      \"mon_c fg ({#sh#}+csp+(cb-{#s#})) \\<inter> (mon_c fg ca \\<union> mon_ww fg wa)={}\" \"(ca,wa,ca')\\<in>trcl (ntr fg)\" \"({#sh#}+csp+(cb-{#s#}),wb,cb')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ca + ?cb, w, c') \\<in> trcl (ntr fg);\n   valid fg (?ca + ?cb)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                       c' = ca' + cb' \\<and>\n                       w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                       mon_c fg ?ca \\<inter>\n                       (mon_c fg ?cb \\<union> mon_ww fg wb) =\n                       {} \\<and>\n                       mon_c fg ?cb \\<inter>\n                       (mon_c fg ?ca \\<union> mon_ww fg waa) =\n                       {} \\<and>\n                       (?ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                       (?cb, wb, cb') \\<in> trcl (ntr fg)\n  (ch, w, c') \\<in> trcl (ntr fg)\n  valid fg ch\n  ch = ca + ({#sh#} + csp + (cb - {#s#}))\n\ngoal (1 subgoal):\n 1. (\\<And>ca' cb' waa wb.\n        \\<lbrakk>c' = ca' + cb';\n         w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb;\n         mon_c fg ca \\<inter>\n         (mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<union> mon_ww fg wb) =\n         {};\n         mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n         (mon_c fg ca \\<union> mon_ww fg waa) =\n         {};\n         (ca, waa, ca') \\<in> trcl (ntr fg);\n         ({#sh#} + csp + (cb - {#s#}), wb, cb') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c' = ca' + cb'\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ca \\<inter>\n  (mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n  (mon_c fg ca \\<union> mon_ww fg wa) =\n  {}\n  (ca, wa, ca') \\<in> trcl (ntr fg)\n  ({#sh#} + csp + (cb - {#s#}), wb, cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "moreover"], ["proof (state)\nthis:\n  c' = ca' + cb'\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ca \\<inter>\n  (mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n  (mon_c fg ca \\<union> mon_ww fg wa) =\n  {}\n  (ca, wa, ca') \\<in> trcl (ntr fg)\n  ({#sh#} + csp + (cb - {#s#}), wb, cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "have FIRSTSTEP: \"(cb,e,{#sh#}+csp+(cb-{#s#}))\\<in>ntr fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg", "from CASE(2)"], ["proof (chain)\npicking this:\n  ce = ca + (cb - {#s#})", "have \"mon_c fg (cb-{#s#}) \\<subseteq> mon_c fg ce\""], ["proof (prove)\nusing this:\n  ce = ca + (cb - {#s#})\n\ngoal (1 subgoal):\n 1. mon_c fg (cb - {#s#}) \\<subseteq> mon_c fg ce", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg (cb - {#s#}) \\<subseteq> mon_c fg ce\n\ngoal (1 subgoal):\n 1. (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg", "with ntrs_xchange_context_s NTRS(3) CEHFMT CASE(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?s, ?c), ?ee, ?s', ?csp + ?c) \\<in> ntrs ?fg;\n   mon_c ?fg ?cn \\<subseteq> mon_c ?fg ?c\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?cn), ?ee, ?s', ?csp + ?cn) \\<in> ntrs ?fg\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n  ceh = csp + ce\n  mon_c fg csp = {}\n  ce = ca + (cb - {#s#})\n  mon_c fg (cb - {#s#}) \\<subseteq> mon_c fg ce", "have \"((s,cb-{#s#}),e,(sh,csp+(cb-{#s#})))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((?s, ?c), ?ee, ?s', ?csp + ?c) \\<in> ntrs ?fg;\n   mon_c ?fg ?cn \\<subseteq> mon_c ?fg ?c\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?cn), ?ee, ?s', ?csp + ?cn) \\<in> ntrs ?fg\n  ((s, ce), e, sh, ceh) \\<in> ntrs fg\n  ceh = csp + ce\n  mon_c fg csp = {}\n  ce = ca + (cb - {#s#})\n  mon_c fg (cb - {#s#}) \\<subseteq> mon_c fg ce\n\ngoal (1 subgoal):\n 1. ((s, cb - {#s#}), e, sh, csp + (cb - {#s#})) \\<in> ntrs fg", "by blast"], ["proof (state)\nthis:\n  ((s, cb - {#s#}), e, sh, csp + (cb - {#s#})) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg", "from gtrI_s[OF this] CASE(1)"], ["proof (chain)\npicking this:\n  (add_mset s (cb - {#s#}), e, add_mset sh (csp + (cb - {#s#})))\n  \\<in> ntr fg\n  cb = add_mset s (cb - {#s#})", "show ?thesis"], ["proof (prove)\nusing this:\n  (add_mset s (cb - {#s#}), e, add_mset sh (csp + (cb - {#s#})))\n  \\<in> ntr fg\n  cb = add_mset s (cb - {#s#})\n\ngoal (1 subgoal):\n 1. (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg", "by (auto simp add: union_assoc)"], ["proof (state)\nthis:\n  (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "with IHAPP(6)"], ["proof (chain)\npicking this:\n  ({#sh#} + csp + (cb - {#s#}), wb, cb') \\<in> trcl (ntr fg)\n  (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg", "have PA: \"(cb,e#wb,cb')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  ({#sh#} + csp + (cb - {#s#}), wb, cb') \\<in> trcl (ntr fg)\n  (cb, e, {#sh#} + csp + (cb - {#s#})) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. (cb, e # wb, cb') \\<in> trcl (ntr fg)", "by simp"], ["proof (state)\nthis:\n  (cb, e # wb, cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "moreover"], ["proof (state)\nthis:\n  (cb, e # wb, cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "have \"e#w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e#wb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb", "from ntrs_called_mon[OF NTRS(3)]"], ["proof (chain)\npicking this:\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh", "have \"fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh\""], ["proof (prove)\nusing this:\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh", "."], ["proof (state)\nthis:\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh\n\ngoal (1 subgoal):\n 1. e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb", "with IHAPP(4)"], ["proof (chain)\npicking this:\n  mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n  (mon_c fg ca \\<union> mon_ww fg wa) =\n  {}\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh", "have \"fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\""], ["proof (prove)\nusing this:\n  mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n  (mon_c fg ca \\<union> mon_ww fg wa) =\n  {}\n  fst (\\<alpha>n fg e) \\<subseteq> mon_s fg sh\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  fst (\\<alpha>n fg e) \\<inter> mon_ww fg wa = {}\n\ngoal (1 subgoal):\n 1. e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb", "from cil_\\<alpha>n_cons2[OF IHAPP(2) this]"], ["proof (chain)\npicking this:\n  e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb", "show ?thesis"], ["proof (prove)\nusing this:\n  e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb\n\ngoal (1 subgoal):\n 1. e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb", "."], ["proof (state)\nthis:\n  e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "moreover"], ["proof (state)\nthis:\n  e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "have \"mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\" \"mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e#wb)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} &&&\n    mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\n 2. mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}", "from ntr_mon_increasing_s[OF FIRSTSTEP] IHAPP(4)"], ["proof (chain)\npicking this:\n  mon_c fg cb \\<subseteq> mon_c fg ({#sh#} + csp + (cb - {#s#}))\n  mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n  (mon_c fg ca \\<union> mon_ww fg wa) =\n  {}", "show \"mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\""], ["proof (prove)\nusing this:\n  mon_c fg cb \\<subseteq> mon_c fg ({#sh#} + csp + (cb - {#s#}))\n  mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n  (mon_c fg ca \\<union> mon_ww fg wa) =\n  {}\n\ngoal (1 subgoal):\n 1. mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\n\ngoal (1 subgoal):\n 1. mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}", "from MONED CASE"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg ce = {}\n  cb = add_mset s (cb - {#s#})\n  ce = ca + (cb - {#s#})", "have \"mon_c fg ca \\<inter> mon_w fg e = {}\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg ce = {}\n  cb = add_mset s (cb - {#s#})\n  ce = ca + (cb - {#s#})\n\ngoal (1 subgoal):\n 1. mon_c fg ca \\<inter> mon_w fg e = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_c fg ca \\<inter> mon_w fg e = {}\n\ngoal (1 subgoal):\n 1. mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}", "with ntr_mon_increasing_s[OF FIRSTSTEP] IHAPP(3)"], ["proof (chain)\npicking this:\n  mon_c fg cb \\<subseteq> mon_c fg ({#sh#} + csp + (cb - {#s#}))\n  mon_c fg ca \\<inter>\n  (mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg ca \\<inter> mon_w fg e = {}", "show \"mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e#wb)) = {}\""], ["proof (prove)\nusing this:\n  mon_c fg cb \\<subseteq> mon_c fg ({#sh#} + csp + (cb - {#s#}))\n  mon_c fg ca \\<inter>\n  (mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg ca \\<inter> mon_w fg e = {}\n\ngoal (1 subgoal):\n 1. mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cb = add_mset s (cb - {#s#}); ce = ca + (cb - {#s#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ca' cb' waa wb.\n                         c' = ca' + cb' \\<and>\n                         e # w\n                         \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> wb \\<and>\n                         mon_c fg ca \\<inter>\n                         (mon_c fg cb \\<union> mon_ww fg wb) =\n                         {} \\<and>\n                         mon_c fg cb \\<inter>\n                         (mon_c fg ca \\<union> mon_ww fg waa) =\n                         {} \\<and>\n                         (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n                         (cb, wb, cb') \\<in> trcl (ntr fg)", "ultimately"], ["proof (chain)\npicking this:\n  c' = ca' + cb'\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ca \\<inter>\n  (mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n  (mon_c fg ca \\<union> mon_ww fg wa) =\n  {}\n  (ca, wa, ca') \\<in> trcl (ntr fg)\n  ({#sh#} + csp + (cb - {#s#}), wb, cb') \\<in> trcl (ntr fg)\n  (cb, e # wb, cb') \\<in> trcl (ntr fg)\n  e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  c' = ca' + cb'\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n  mon_c fg ca \\<inter>\n  (mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<union> mon_ww fg wb) =\n  {}\n  mon_c fg ({#sh#} + csp + (cb - {#s#})) \\<inter>\n  (mon_c fg ca \\<union> mon_ww fg wa) =\n  {}\n  (ca, wa, ca') \\<in> trcl (ntr fg)\n  ({#sh#} + csp + (cb - {#s#}), wb, cb') \\<in> trcl (ntr fg)\n  (cb, e # wb, cb') \\<in> trcl (ntr fg)\n  e # w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> e # wb\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # wb)) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ca' cb' waa wb.\n       c' = ca' + cb' \\<and>\n       e # w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg waa) = {} \\<and>\n       (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ca' cb' waa wb.\n     c' = ca' + cb' \\<and>\n     e # w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg waa) = {} \\<and>\n     (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ca' cb' waa wb.\n     c' = ca' + cb' \\<and>\n     e # w \\<in> waa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg waa) = {} \\<and>\n     (ca, waa, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next lemma is a more general version of @{thm [source] flowgraph.ntr_split} for the semantics with a distinguished local thread. The proof follows exactly the same ideas, but is more complex.\\<close>"], ["", "lemma (in flowgraph) ntrp_split: \"\n  !!s c1 c2 s' c'. \n  \\<lbrakk>((s,c1+c2),w,(s',c'))\\<in>trcl (ntrp fg); valid fg ({#s#}+c1+c2)\\<rbrakk> \n  \\<Longrightarrow> \\<exists>w1 w2 c1' c2'. \n        w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> (map ENV w2) \\<and> \n        c'=c1'+c2' \\<and> \n        ((s,c1),w1,(s',c1'))\\<in>trcl (ntrp fg) \\<and> \n        (c2,w2,c2')\\<in>trcl (ntr fg) \\<and> \n        mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and> \n        mon_ww fg w2 \\<inter> mon_c fg ({#s#}+c1) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c1 c2 s' c'.\n       \\<lbrakk>((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                   fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "proof (induct w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s c1 c2 s' c'.\n       \\<lbrakk>((s, c1 + c2), [], s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            [] \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                    fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>a w s c1 c2 s' c'.\n       \\<lbrakk>\\<And>s c1 c2 s' c'.\n                   \\<lbrakk>((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg);\n                    valid fg ({#s#} + c1 + c2)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n  c' = c1' + c2' \\<and>\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n  (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {};\n        ((s, c1 + c2), a # w, s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            a # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "case Nil"], ["proof (state)\nthis:\n  ((s, c1 + c2), [], s', c') \\<in> trcl (ntrp fg)\n  valid fg ({#s#} + c1 + c2)\n\ngoal (2 subgoals):\n 1. \\<And>s c1 c2 s' c'.\n       \\<lbrakk>((s, c1 + c2), [], s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            [] \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                    fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>a w s c1 c2 s' c'.\n       \\<lbrakk>\\<And>s c1 c2 s' c'.\n                   \\<lbrakk>((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg);\n                    valid fg ({#s#} + c1 + c2)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n  c' = c1' + c2' \\<and>\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n  (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {};\n        ((s, c1 + c2), a # w, s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            a # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "thus ?case"], ["proof (prove)\nusing this:\n  ((s, c1 + c2), [], s', c') \\<in> trcl (ntrp fg)\n  valid fg ({#s#} + c1 + c2)\n\ngoal (1 subgoal):\n 1. \\<exists>w1 w2 c1' c2'.\n       [] \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n       c' = c1' + c2' \\<and>\n       ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n       (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n       mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "by (auto intro: exI[of _ \"[]\"] exI[of _ \"{#}\"])"], ["proof (state)\nthis:\n  \\<exists>w1 w2 c1' c2'.\n     [] \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a w s c1 c2 s' c'.\n       \\<lbrakk>\\<And>s c1 c2 s' c'.\n                   \\<lbrakk>((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg);\n                    valid fg ({#s#} + c1 + c2)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n  c' = c1' + c2' \\<and>\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n  (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {};\n        ((s, c1 + c2), a # w, s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            a # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w s c1 c2 s' c'.\n       \\<lbrakk>\\<And>s c1 c2 s' c'.\n                   \\<lbrakk>((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg);\n                    valid fg ({#s#} + c1 + c2)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n  c' = c1' + c2' \\<and>\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n  (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {};\n        ((s, c1 + c2), a # w, s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            a # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "case (Cons ee w)"], ["proof (state)\nthis:\n  \\<lbrakk>((?s, ?c1.0 + ?c2.0), w, ?s', ?c') \\<in> trcl (ntrp fg);\n   valid fg ({#?s#} + ?c1.0 + ?c2.0)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                       w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                       ?c' = c1' + c2' \\<and>\n                       ((?s, ?c1.0), w1, ?s', c1')\n                       \\<in> trcl (ntrp fg) \\<and>\n                       (?c2.0, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ?c2.0 =\n                       {} \\<and>\n                       mon_ww fg w2 \\<inter> mon_c fg ({#?s#} + ?c1.0) = {}\n  ((s, c1 + c2), ee # w, s', c') \\<in> trcl (ntrp fg)\n  valid fg ({#s#} + c1 + c2)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c1 c2 s' c'.\n       \\<lbrakk>\\<And>s c1 c2 s' c'.\n                   \\<lbrakk>((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg);\n                    valid fg ({#s#} + c1 + c2)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n  c' = c1' + c2' \\<and>\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n  (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {};\n        ((s, c1 + c2), a # w, s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            a # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?s, ?c1.0 + ?c2.0), w, ?s', ?c') \\<in> trcl (ntrp fg);\n   valid fg ({#?s#} + ?c1.0 + ?c2.0)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                       w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                       ?c' = c1' + c2' \\<and>\n                       ((?s, ?c1.0), w1, ?s', c1')\n                       \\<in> trcl (ntrp fg) \\<and>\n                       (?c2.0, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ?c2.0 =\n                       {} \\<and>\n                       mon_ww fg w2 \\<inter> mon_c fg ({#?s#} + ?c1.0) = {}\n  ((s, c1 + c2), ee # w, s', c') \\<in> trcl (ntrp fg)\n  valid fg ({#s#} + c1 + c2)", "obtain sh ch where SPLIT: \"((s,c1+c2),ee,(sh,ch))\\<in>ntrp fg\" \"((sh,ch),w,(s',c'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((?s, ?c1.0 + ?c2.0), w, ?s', ?c') \\<in> trcl (ntrp fg);\n   valid fg ({#?s#} + ?c1.0 + ?c2.0)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                       w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                       ?c' = c1' + c2' \\<and>\n                       ((?s, ?c1.0), w1, ?s', c1')\n                       \\<in> trcl (ntrp fg) \\<and>\n                       (?c2.0, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg ?c2.0 =\n                       {} \\<and>\n                       mon_ww fg w2 \\<inter> mon_c fg ({#?s#} + ?c1.0) = {}\n  ((s, c1 + c2), ee # w, s', c') \\<in> trcl (ntrp fg)\n  valid fg ({#s#} + c1 + c2)\n\ngoal (1 subgoal):\n 1. (\\<And>sh ch.\n        \\<lbrakk>((s, c1 + c2), ee, sh, ch) \\<in> ntrp fg;\n         ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  ((s, c1 + c2), ee, sh, ch) \\<in> ntrp fg\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>a w s c1 c2 s' c'.\n       \\<lbrakk>\\<And>s c1 c2 s' c'.\n                   \\<lbrakk>((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg);\n                    valid fg ({#s#} + c1 + c2)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n  c' = c1' + c2' \\<and>\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n  (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {};\n        ((s, c1 + c2), a # w, s', c') \\<in> trcl (ntrp fg);\n        valid fg ({#s#} + c1 + c2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            a # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from SPLIT(1)"], ["proof (chain)\npicking this:\n  ((s, c1 + c2), ee, sh, ch) \\<in> ntrp fg", "show ?case"], ["proof (prove)\nusing this:\n  ((s, c1 + c2), ee, sh, ch) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<exists>w1 w2 c1' c2'.\n       ee # w\n       \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n       c' = c1' + c2' \\<and>\n       ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n       (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n       mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "proof (cases rule: gtrp.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "case gtrp_loc"], ["proof (state)\nthis:\n  ee = LOC e_\n  ((s, c1 + c2), e_, sh, ch) \\<in> ntrs fg\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "then"], ["proof (chain)\npicking this:\n  ee = LOC e_\n  ((s, c1 + c2), e_, sh, ch) \\<in> ntrs fg", "obtain e where CASE: \"ee=LOC e\" \"((s,c1+c2),e,(sh,ch))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  ee = LOC e_\n  ((s, c1 + c2), e_, sh, ch) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>ee = LOC e;\n         ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ee = LOC e\n  ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from ntrs_c_cases_s[OF CASE(2)]"], ["proof (chain)\npicking this:\n  (\\<And>csp.\n      \\<lbrakk>ch = csp + (c1 + c2);\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain csp where CHFMT: \"ch=(csp+c1)+c2\" \"\\<And>s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s = [entry fg p] \\<and> (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\""], ["proof (prove)\nusing this:\n  (\\<And>csp.\n      \\<lbrakk>ch = csp + (c1 + c2);\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        \\<lbrakk>ch = csp + c1 + c2;\n         \\<And>s.\n            s \\<in># csp \\<Longrightarrow>\n            \\<exists>p u v.\n               s = [entry fg p] \\<and>\n               (u, Spawn p, v) \\<in> edges fg \\<and>\n               initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: union_assoc, blast)"], ["proof (state)\nthis:\n  ch = csp + c1 + c2\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "with c_of_initial_no_mon"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ch = csp + c1 + c2\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "have CSPNOMON: \"mon_c fg csp = {}\""], ["proof (prove)\nusing this:\n  (\\<And>s.\n      s \\<in># ?csp \\<Longrightarrow>\n      \\<exists>p.\n         s = [entry fg p] \\<and> initialproc fg p) \\<Longrightarrow>\n  mon_c fg ?csp = {}\n  ch = csp + c1 + c2\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. mon_c fg csp = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg csp = {}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from ntr_valid_preserve_s[OF gtrI_s, OF CASE(2)] Cons.prems(2) CHFMT"], ["proof (chain)\npicking this:\n  valid fg (add_mset s (c1 + c2)) \\<Longrightarrow>\n  valid fg (add_mset sh ch)\n  valid fg ({#s#} + c1 + c2)\n  ch = csp + c1 + c2\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "have VALID: \"valid fg ({#sh#}+(csp+c1)+c2)\""], ["proof (prove)\nusing this:\n  valid fg (add_mset s (c1 + c2)) \\<Longrightarrow>\n  valid fg (add_mset sh ch)\n  valid fg ({#s#} + c1 + c2)\n  ch = csp + c1 + c2\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. valid fg ({#sh#} + (csp + c1) + c2)", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  valid fg ({#sh#} + (csp + c1) + c2)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from Cons.hyps[OF _ VALID, of s' c'] CHFMT(1) SPLIT(2)"], ["proof (chain)\npicking this:\n  ((sh, csp + c1 + c2), w, s', c') \\<in> trcl (ntrp fg) \\<Longrightarrow>\n  \\<exists>w1 w2 c1' c2'.\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((sh, csp + c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#sh#} + (csp + c1)) = {}\n  ch = csp + c1 + c2\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)", "obtain w1 w2 c1' c2' where IHAPP: \"w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> (map ENV w2)\" \"c' = c1' + c2'\" \"((sh, csp + c1), w1, s', c1') \\<in> trcl (ntrp fg)\" \n      \"(c2, w2, c2') \\<in> trcl (ntr fg)\" \"mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\" \"mon_ww fg w2 \\<inter> mon_c fg ({#sh#} + (csp + c1)) = {}\""], ["proof (prove)\nusing this:\n  ((sh, csp + c1 + c2), w, s', c') \\<in> trcl (ntrp fg) \\<Longrightarrow>\n  \\<exists>w1 w2 c1' c2'.\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((sh, csp + c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#sh#} + (csp + c1)) = {}\n  ch = csp + c1 + c2\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 c1' c2'.\n        \\<lbrakk>w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n        fg\\<^esub> map ENV w2;\n         c' = c1' + c2'; ((sh, csp + c1), w1, s', c1') \\<in> trcl (ntrp fg);\n         (c2, w2, c2') \\<in> trcl (ntr fg);\n         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {};\n         mon_ww fg w2 \\<inter> mon_c fg ({#sh#} + (csp + c1)) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  c' = c1' + c2'\n  ((sh, csp + c1), w1, s', c1') \\<in> trcl (ntrp fg)\n  (c2, w2, c2') \\<in> trcl (ntr fg)\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\n  mon_ww fg w2 \\<inter> mon_c fg ({#sh#} + (csp + c1)) = {}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have \"ee#w \\<in> ee#w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> (map ENV w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2", "proof (rule cil_cons1)"], ["proof (state)\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "from ntrp_mon_env_w_no_ctx[OF SPLIT(2), unfolded mon_env_def]"], ["proof (chain)\npicking this:\n  mon_ww fg (map le_rem_s (env w)) \\<inter> mon_s fg sh = {}", "have \"mon_ww fg (map le_rem_s (env w)) \\<inter> mon_s fg sh = {}\""], ["proof (prove)\nusing this:\n  mon_ww fg (map le_rem_s (env w)) \\<inter> mon_s fg sh = {}\n\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s (env w)) \\<inter> mon_s fg sh = {}", "."], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s (env w)) \\<inter> mon_s fg sh = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s (env w)) \\<inter> mon_s fg sh = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "have \"mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "(* TODO: This proof should be shorter and more straightforward *)"], ["proof (state)\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "from cil_subset_il IHAPP(1) ileq_interleave"], ["proof (chain)\npicking this:\n  ?w \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> ?w' \\<subseteq> ?w \\<otimes> ?w'\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  ?w \\<in> ?w1.0 \\<otimes> ?w2.0 \\<Longrightarrow>\n  ?w1.0 \\<preceq> ?w \\<and> ?w2.0 \\<preceq> ?w", "have \"map ENV w2 \\<preceq> w\""], ["proof (prove)\nusing this:\n  ?w \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> ?w' \\<subseteq> ?w \\<otimes> ?w'\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  ?w \\<in> ?w1.0 \\<otimes> ?w2.0 \\<Longrightarrow>\n  ?w1.0 \\<preceq> ?w \\<and> ?w2.0 \\<preceq> ?w\n\ngoal (1 subgoal):\n 1. map ENV w2 \\<preceq> w", "by blast"], ["proof (state)\nthis:\n  map ENV w2 \\<preceq> w\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "from le_list_filter[OF this]"], ["proof (chain)\npicking this:\n  filter ?P (map ENV w2) \\<preceq> filter ?P w", "have \"env (map ENV w2) \\<preceq> env w\""], ["proof (prove)\nusing this:\n  filter ?P (map ENV w2) \\<preceq> filter ?P w\n\ngoal (1 subgoal):\n 1. env (map ENV w2) \\<preceq> env w", "by (unfold env_def) blast"], ["proof (state)\nthis:\n  env (map ENV w2) \\<preceq> env w\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "hence \"map ENV w2 \\<preceq> env w\""], ["proof (prove)\nusing this:\n  env (map ENV w2) \\<preceq> env w\n\ngoal (1 subgoal):\n 1. map ENV w2 \\<preceq> env w", "by (unfold env_def) simp"], ["proof (state)\nthis:\n  map ENV w2 \\<preceq> env w\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "from le_list_map[OF this, of le_rem_s]"], ["proof (chain)\npicking this:\n  map le_rem_s (map ENV w2) \\<preceq> map le_rem_s (env w)", "have \"w2 \\<preceq> map le_rem_s (env w)\""], ["proof (prove)\nusing this:\n  map le_rem_s (map ENV w2) \\<preceq> map le_rem_s (env w)\n\ngoal (1 subgoal):\n 1. w2 \\<preceq> map le_rem_s (env w)", "by simp"], ["proof (state)\nthis:\n  w2 \\<preceq> map le_rem_s (env w)\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "thus ?thesis"], ["proof (prove)\nusing this:\n  w2 \\<preceq> map le_rem_s (env w)\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "by (rule mon_ww_ileq)"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  mon_ww fg (map le_rem_s (env w)) \\<inter> mon_s fg sh = {}\n  mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))", "have \"mon_ww fg w2 \\<inter> mon_s fg sh = {}\""], ["proof (prove)\nusing this:\n  mon_ww fg (map le_rem_s (env w)) \\<inter> mon_s fg sh = {}\n  mon_ww fg w2 \\<subseteq> mon_ww fg (map le_rem_s (env w))\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<inter> mon_s fg sh = {}", "by blast"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<inter> mon_s fg sh = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "with ntrs_mon_s[OF CASE(2)] CASE(1)"], ["proof (chain)\npicking this:\n  mon_s fg sh = mon_s fg s \\<union> fst (\\<alpha>n fg e)\n  ee = LOC e\n  mon_ww fg w2 \\<inter> mon_s fg sh = {}", "show \"fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) (map ENV w2)) = {}\""], ["proof (prove)\nusing this:\n  mon_s fg sh = mon_s fg s \\<union> fst (\\<alpha>n fg e)\n  ee = LOC e\n  mon_ww fg w2 \\<inter> mon_s fg sh = {}\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "by (auto simp add: cil_\\<alpha>n_cons_helper)"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg ee) \\<inter>\n  mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n  {}\n\ngoal (1 subgoal):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2", "qed (rule IHAPP(1))"], ["proof (state)\nthis:\n  ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have \"((s,c1),ee#w1,(s',c1'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "from ntrs_xchange_context_s[of s \"c1+c2\" e sh \"csp\" fg \"c1\"] CASE(2) CHFMT(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>((s, c1 + c2), e, sh, csp + (c1 + c2)) \\<in> ntrs fg;\n   mon_c fg c1 \\<subseteq> mon_c fg (c1 + c2)\\<rbrakk>\n  \\<Longrightarrow> ((s, c1), e, sh, csp + c1) \\<in> ntrs fg\n  ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\n  ch = csp + c1 + c2", "have \"((s, c1), e, sh, csp + c1) \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((s, c1 + c2), e, sh, csp + (c1 + c2)) \\<in> ntrs fg;\n   mon_c fg c1 \\<subseteq> mon_c fg (c1 + c2)\\<rbrakk>\n  \\<Longrightarrow> ((s, c1), e, sh, csp + c1) \\<in> ntrs fg\n  ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\n  ch = csp + c1 + c2\n\ngoal (1 subgoal):\n 1. ((s, c1), e, sh, csp + c1) \\<in> ntrs fg", "by (auto simp add: mon_c_unconc union_ac)"], ["proof (state)\nthis:\n  ((s, c1), e, sh, csp + c1) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "with CASE(1)"], ["proof (chain)\npicking this:\n  ee = LOC e\n  ((s, c1), e, sh, csp + c1) \\<in> ntrs fg", "have \"((s, c1), ee, sh, csp + c1) \\<in> ntrp fg\""], ["proof (prove)\nusing this:\n  ee = LOC e\n  ((s, c1), e, sh, csp + c1) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s, c1), ee, sh, csp + c1) \\<in> ntrp fg", "by (auto intro: gtrp.gtrp_loc)"], ["proof (state)\nthis:\n  ((s, c1), ee, sh, csp + c1) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "also"], ["proof (state)\nthis:\n  ((s, c1), ee, sh, csp + c1) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "note IHAPP(3)"], ["proof (state)\nthis:\n  ((sh, csp + c1), w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "finally"], ["proof (chain)\npicking this:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "."], ["proof (state)\nthis:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from CASE(1) ntrs_mon_e_no_ctx[OF CASE(2)] IHAPP(5)"], ["proof (chain)\npicking this:\n  ee = LOC e\n  mon_w fg e \\<inter> mon_c fg (c1 + c2) = {}\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}", "have \"mon_ww fg (map le_rem_s (ee#w1)) \\<inter> mon_c fg c2 = {}\""], ["proof (prove)\nusing this:\n  ee = LOC e\n  mon_w fg e \\<inter> mon_c fg (c1 + c2) = {}\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\n\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from ntrs_mon_increasing_s[OF CASE(2)] CHFMT(1) IHAPP(6)"], ["proof (chain)\npicking this:\n  mon_s fg s \\<subseteq> mon_s fg sh \\<and> mon_c fg (c1 + c2) = mon_c fg ch\n  ch = csp + c1 + c2\n  mon_ww fg w2 \\<inter> mon_c fg ({#sh#} + (csp + c1)) = {}", "have \"mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\""], ["proof (prove)\nusing this:\n  mon_s fg s \\<subseteq> mon_s fg sh \\<and> mon_c fg (c1 + c2) = mon_c fg ch\n  ch = csp + c1 + c2\n  mon_ww fg w2 \\<inter> mon_c fg ({#sh#} + (csp + c1)) = {}\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "note IHAPP(2,4)"], ["proof (state)\nthis:\n  c' = c1' + c2'\n  (c2, w2, c2') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>ee = LOC e; ((s, c1 + c2), e, sh, ch) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "ultimately"], ["proof (chain)\npicking this:\n  ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n  mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n  c' = c1' + c2'\n  (c2, w2, c2') \\<in> trcl (ntr fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n  mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n  c' = c1' + c2'\n  (c2, w2, c2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<exists>w1 w2 c1' c2'.\n       ee # w\n       \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n       c' = c1' + c2' \\<and>\n       ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n       (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n       mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>w1 w2 c1' c2'.\n     ee # w\n     \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (1 subgoal):\n 1. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "case gtrp_env"], ["proof (state)\nthis:\n  c1 + c2 = add_mset s_ c_\n  ee = ENV e_\n  sh = s\n  ch = add_mset s'_ c'_\n  ((s_, add_mset s c_), e_, s'_, add_mset s c'_) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "then"], ["proof (chain)\npicking this:\n  c1 + c2 = add_mset s_ c_\n  ee = ENV e_\n  sh = s\n  ch = add_mset s'_ c'_\n  ((s_, add_mset s c_), e_, s'_, add_mset s c'_) \\<in> ntrs fg", "obtain e ss ce ssh ceh where CASE: \"ee=ENV e\" \"c1+c2=add_mset ss ce\" \"sh=s\" \"ch=add_mset ssh ceh\" \"((ss,add_mset s ce),e,(ssh,add_mset s ceh))\\<in>ntrs fg\""], ["proof (prove)\nusing this:\n  c1 + c2 = add_mset s_ c_\n  ee = ENV e_\n  sh = s\n  ch = add_mset s'_ c'_\n  ((s_, add_mset s c_), e_, s'_, add_mset s c'_) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (\\<And>e ss ce ssh ceh.\n        \\<lbrakk>ee = ENV e; c1 + c2 = add_mset ss ce; sh = s;\n         ch = add_mset ssh ceh;\n         ((ss, add_mset s ce), e, ssh, add_mset s ceh)\n         \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ee = ENV e\n  c1 + c2 = add_mset ss ce\n  sh = s\n  ch = add_mset ssh ceh\n  ((ss, add_mset s ce), e, ssh, add_mset s ceh) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from ntrs_c_cases_s[OF CASE(5)]"], ["proof (chain)\npicking this:\n  (\\<And>csp.\n      \\<lbrakk>add_mset s ceh = csp + add_mset s ce;\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain csp where HFMT: \"add_mset s ceh = csp + (add_mset s ce)\" \"\\<And>s. s \\<in># csp \\<Longrightarrow> \\<exists>p u v. s = [entry fg p] \\<and> (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\""], ["proof (prove)\nusing this:\n  (\\<And>csp.\n      \\<lbrakk>add_mset s ceh = csp + add_mset s ce;\n       \\<And>s.\n          s \\<in># csp \\<Longrightarrow>\n          \\<exists>p u v.\n             s = [entry fg p] \\<and>\n             (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>csp.\n        \\<lbrakk>add_mset s ceh = csp + add_mset s ce;\n         \\<And>s.\n            s \\<in># csp \\<Longrightarrow>\n            \\<exists>p u v.\n               s = [entry fg p] \\<and>\n               (u, Spawn p, v) \\<in> edges fg \\<and>\n               initialproc fg p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast)"], ["proof (state)\nthis:\n  add_mset s ceh = csp + add_mset s ce\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from union_left_cancel[of \"{#s#}\" ceh \"csp+ce\"] HFMT(1)"], ["proof (chain)\npicking this:\n  ({#s#} + ceh = {#s#} + (csp + ce)) = (ceh = csp + ce)\n  add_mset s ceh = csp + add_mset s ce", "have CEHFMT: \"ceh=csp+ce\""], ["proof (prove)\nusing this:\n  ({#s#} + ceh = {#s#} + (csp + ce)) = (ceh = csp + ce)\n  add_mset s ceh = csp + add_mset s ce\n\ngoal (1 subgoal):\n 1. ceh = csp + ce", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  ceh = csp + ce\n\ngoal (1 subgoal):\n 1. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from HFMT(2)"], ["proof (chain)\npicking this:\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p", "have CHNOMON: \"mon_c fg csp = {}\""], ["proof (prove)\nusing this:\n  ?s \\<in># csp \\<Longrightarrow>\n  \\<exists>p u v.\n     ?s = [entry fg p] \\<and>\n     (u, Spawn p, v) \\<in> edges fg \\<and> initialproc fg p\n\ngoal (1 subgoal):\n 1. mon_c fg csp = {}", "by (blast intro!: c_of_initial_no_mon)"], ["proof (state)\nthis:\n  mon_c fg csp = {}\n\ngoal (1 subgoal):\n 1. \\<And>sa c e s'a c'a.\n       \\<lbrakk>c1 + c2 = add_mset sa c; ee = ENV e; sh = s;\n        ch = add_mset s'a c'a;\n        ((sa, add_mset s c), e, s'a, add_mset s c'a) \\<in> ntrs fg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                            ee # w\n                            \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                 fg\\<^esub> map ENV w2 \\<and>\n                            c' = c1' + c2' \\<and>\n                            ((s, c1), w1, s', c1')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                            mon_ww fg (map le_rem_s w1) \\<inter>\n                            mon_c fg c2 =\n                            {} \\<and>\n                            mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from CASE(2)[symmetric]"], ["proof (chain)\npicking this:\n  add_mset ss ce = c1 + c2", "show ?thesis"], ["proof (prove)\nusing this:\n  add_mset ss ce = c1 + c2\n\ngoal (1 subgoal):\n 1. \\<exists>w1 w2 c1' c2'.\n       ee # w\n       \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n       c' = c1' + c2' \\<and>\n       ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n       (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n       mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "proof (cases rule: mset_unplusm_dist_cases)\n      \\<comment> \\<open>Made an env-step in @{term c1}, this is considered the ,,left'' part. Apply induction hypothesis with original(!) local thread and the spawned threads on the left side\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "case left"], ["proof (state)\nthis:\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "with HFMT(1) CASE(4) CEHFMT"], ["proof (chain)\npicking this:\n  add_mset s ceh = csp + add_mset s ce\n  ch = add_mset ssh ceh\n  ceh = csp + ce\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2", "have CHFMT': \"ch=(csp+{#ssh#}+(c1-{#ss#})) + c2\""], ["proof (prove)\nusing this:\n  add_mset s ceh = csp + add_mset s ce\n  ch = add_mset ssh ceh\n  ceh = csp + ce\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2\n\ngoal (1 subgoal):\n 1. ch = csp + {#ssh#} + (c1 - {#ss#}) + c2", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  ch = csp + {#ssh#} + (c1 - {#ss#}) + c2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have VALID: \"valid fg ({#s#} + (csp+{#ssh#}+(c1-{#ss#})) + c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#})) + c2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#})) + c2)", "from ntr_valid_preserve_s[OF gtrI_s, OF CASE(5)] Cons.prems(2) CASE(2)"], ["proof (chain)\npicking this:\n  valid fg (add_mset ss (add_mset s ce)) \\<Longrightarrow>\n  valid fg (add_mset ssh (add_mset s ceh))\n  valid fg ({#s#} + c1 + c2)\n  c1 + c2 = add_mset ss ce", "have \"valid fg ({#ssh#} + ({#s#} + ceh))\""], ["proof (prove)\nusing this:\n  valid fg (add_mset ss (add_mset s ce)) \\<Longrightarrow>\n  valid fg (add_mset ssh (add_mset s ceh))\n  valid fg ({#s#} + c1 + c2)\n  c1 + c2 = add_mset ss ce\n\ngoal (1 subgoal):\n 1. valid fg ({#ssh#} + ({#s#} + ceh))", "by (simp add: union_assoc add_mset_commute)"], ["proof (state)\nthis:\n  valid fg ({#ssh#} + ({#s#} + ceh))\n\ngoal (1 subgoal):\n 1. valid fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#})) + c2)", "with left CEHFMT"], ["proof (chain)\npicking this:\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2\n  ceh = csp + ce\n  valid fg ({#ssh#} + ({#s#} + ceh))", "show ?thesis"], ["proof (prove)\nusing this:\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2\n  ceh = csp + ce\n  valid fg ({#ssh#} + ({#s#} + ceh))\n\ngoal (1 subgoal):\n 1. valid fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#})) + c2)", "by (auto simp add: union_ac add_mset_commute)"], ["proof (state)\nthis:\n  valid fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#})) + c2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#})) + c2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from Cons.hyps[OF _ VALID,of s' c'] CHFMT' SPLIT(2) CASE(3)"], ["proof (chain)\npicking this:\n  ((s, csp + {#ssh#} + (c1 - {#ss#}) + c2), w, s', c')\n  \\<in> trcl (ntrp fg) \\<Longrightarrow>\n  \\<exists>w1 w2 c1' c2'.\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, csp + {#ssh#} + (c1 - {#ss#})), w1, s', c1')\n     \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter>\n     mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) =\n     {}\n  ch = csp + {#ssh#} + (c1 - {#ss#}) + c2\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n  sh = s", "obtain w1 w2 c1' c2' where IHAPP: \"w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\" \"c' = c1' + c2'\" \n        \"((s, csp + {#ssh#} + (c1 - {#ss#})), w1, s', c1') \\<in> trcl (ntrp fg)\" \"(c2, w2, c2') \\<in> trcl (ntr fg)\" \n        \"mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\" \"mon_ww fg w2 \\<inter> mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) = {}\""], ["proof (prove)\nusing this:\n  ((s, csp + {#ssh#} + (c1 - {#ss#}) + c2), w, s', c')\n  \\<in> trcl (ntrp fg) \\<Longrightarrow>\n  \\<exists>w1 w2 c1' c2'.\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, csp + {#ssh#} + (c1 - {#ss#})), w1, s', c1')\n     \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter>\n     mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) =\n     {}\n  ch = csp + {#ssh#} + (c1 - {#ss#}) + c2\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n  sh = s\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 c1' c2'.\n        \\<lbrakk>w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n        fg\\<^esub> map ENV w2;\n         c' = c1' + c2';\n         ((s, csp + {#ssh#} + (c1 - {#ss#})), w1, s', c1')\n         \\<in> trcl (ntrp fg);\n         (c2, w2, c2') \\<in> trcl (ntr fg);\n         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {};\n         mon_ww fg w2 \\<inter>\n         mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) =\n         {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  c' = c1' + c2'\n  ((s, csp + {#ssh#} + (c1 - {#ss#})), w1, s', c1') \\<in> trcl (ntrp fg)\n  (c2, w2, c2') \\<in> trcl (ntr fg)\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have \"ee # w \\<in> (ee#w1) \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2", "proof (rule cil_cons1)"], ["proof (state)\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "from IHAPP(6)"], ["proof (chain)\npicking this:\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) =\n  {}", "have \"mon_ww fg w2 \\<inter> mon_s fg ssh = {}\""], ["proof (prove)\nusing this:\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) =\n  {}\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<inter> mon_s fg ssh = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<inter> mon_s fg ssh = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<inter> mon_s fg ssh = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "from ntrs_mon_s[OF CASE(5)] CASE(1)"], ["proof (chain)\npicking this:\n  mon_s fg ssh = mon_s fg ss \\<union> fst (\\<alpha>n fg e)\n  ee = ENV e", "have \"fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh\""], ["proof (prove)\nusing this:\n  mon_s fg ssh = mon_s fg ss \\<union> fst (\\<alpha>n fg e)\n  ee = ENV e\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh", "by auto"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  mon_ww fg w2 \\<inter> mon_s fg ssh = {}\n  fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh", "have \"fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg w2 = {}\""], ["proof (prove)\nusing this:\n  mon_ww fg w2 \\<inter> mon_s fg ssh = {}\n  fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg w2 = {}", "by auto"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg w2 = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "moreover"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg w2 = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "have \"mon_pl (map (\\<alpha>nl fg) (map ENV w2)) = mon_ww fg w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_pl (map (\\<alpha>nl fg) (map ENV w2)) = mon_ww fg w2", "by (simp add: cil_\\<alpha>n_cons_helper)"], ["proof (state)\nthis:\n  mon_pl (map (\\<alpha>nl fg) (map ENV w2)) = mon_ww fg w2\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg w2 = {}\n  mon_pl (map (\\<alpha>nl fg) (map ENV w2)) = mon_ww fg w2", "show \"fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) (map ENV w2)) = {}\""], ["proof (prove)\nusing this:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg w2 = {}\n  mon_pl (map (\\<alpha>nl fg) (map ENV w2)) = mon_ww fg w2\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>nl fg ee) \\<inter>\n    mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n    {}", "by auto"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg ee) \\<inter>\n  mon_pl (map (\\<alpha>nl fg) (map ENV w2)) =\n  {}\n\ngoal (1 subgoal):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2", "qed (rule IHAPP(1))"], ["proof (state)\nthis:\n  ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have SS: \"((s,c1),ee,(s,csp + {#ssh#} + (c1 - {#ss#})))\\<in>ntrp fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, c1), ee, s, csp + {#ssh#} + (c1 - {#ss#})) \\<in> ntrp fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, c1), ee, s, csp + {#ssh#} + (c1 - {#ss#})) \\<in> ntrp fg", "from left HFMT(1)"], ["proof (chain)\npicking this:\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2\n  add_mset s ceh = csp + add_mset s ce", "have \"{#s#}+ce={#s#}+(c1-{#ss#})+c2\" \"{#s#}+ceh = csp+({#s#}+(c1-{#ss#})+c2)\""], ["proof (prove)\nusing this:\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2\n  add_mset s ceh = csp + add_mset s ce\n\ngoal (1 subgoal):\n 1. {#s#} + ce = {#s#} + (c1 - {#ss#}) + c2 &&&\n    {#s#} + ceh = csp + ({#s#} + (c1 - {#ss#}) + c2)", "by (simp_all add: union_ac)"], ["proof (state)\nthis:\n  {#s#} + ce = {#s#} + (c1 - {#ss#}) + c2\n  {#s#} + ceh = csp + ({#s#} + (c1 - {#ss#}) + c2)\n\ngoal (1 subgoal):\n 1. ((s, c1), ee, s, csp + {#ssh#} + (c1 - {#ss#})) \\<in> ntrp fg", "with CASE(5) ntrs_xchange_context_s[of ss \"{#s#}+(c1-{#ss#})+c2\" e ssh csp fg \"({#s#}+(c1-{#ss#}))\"]"], ["proof (chain)\npicking this:\n  ((ss, add_mset s ce), e, ssh, add_mset s ceh) \\<in> ntrs fg\n  \\<lbrakk>((ss, {#s#} + (c1 - {#ss#}) + c2), e, ssh,\n            csp + ({#s#} + (c1 - {#ss#}) + c2))\n           \\<in> ntrs fg;\n   mon_c fg ({#s#} + (c1 - {#ss#}))\n   \\<subseteq> mon_c fg ({#s#} + (c1 - {#ss#}) + c2)\\<rbrakk>\n  \\<Longrightarrow> ((ss, {#s#} + (c1 - {#ss#})), e, ssh,\n                     csp + ({#s#} + (c1 - {#ss#})))\n                    \\<in> ntrs fg\n  {#s#} + ce = {#s#} + (c1 - {#ss#}) + c2\n  {#s#} + ceh = csp + ({#s#} + (c1 - {#ss#}) + c2)", "have \n          \"((ss, add_mset s (c1 - {#ss#})), e, ssh, add_mset s (csp+(c1 - {#ss#}))) \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  ((ss, add_mset s ce), e, ssh, add_mset s ceh) \\<in> ntrs fg\n  \\<lbrakk>((ss, {#s#} + (c1 - {#ss#}) + c2), e, ssh,\n            csp + ({#s#} + (c1 - {#ss#}) + c2))\n           \\<in> ntrs fg;\n   mon_c fg ({#s#} + (c1 - {#ss#}))\n   \\<subseteq> mon_c fg ({#s#} + (c1 - {#ss#}) + c2)\\<rbrakk>\n  \\<Longrightarrow> ((ss, {#s#} + (c1 - {#ss#})), e, ssh,\n                     csp + ({#s#} + (c1 - {#ss#})))\n                    \\<in> ntrs fg\n  {#s#} + ce = {#s#} + (c1 - {#ss#}) + c2\n  {#s#} + ceh = csp + ({#s#} + (c1 - {#ss#}) + c2)\n\ngoal (1 subgoal):\n 1. ((ss, add_mset s (c1 - {#ss#})), e, ssh,\n     add_mset s (csp + (c1 - {#ss#})))\n    \\<in> ntrs fg", "by (auto simp add: mon_c_unconc union_ac)"], ["proof (state)\nthis:\n  ((ss, add_mset s (c1 - {#ss#})), e, ssh, add_mset s (csp + (c1 - {#ss#})))\n  \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s, c1), ee, s, csp + {#ssh#} + (c1 - {#ss#})) \\<in> ntrp fg", "from gtrp.gtrp_env[OF this] left(1)[symmetric] CASE(1)"], ["proof (chain)\npicking this:\n  ((s, add_mset ss (c1 - {#ss#})), ENV e, s,\n   add_mset ssh (csp + (c1 - {#ss#})))\n  \\<in> ntrp fg\n  add_mset ss (c1 - {#ss#}) = c1\n  ee = ENV e", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, add_mset ss (c1 - {#ss#})), ENV e, s,\n   add_mset ssh (csp + (c1 - {#ss#})))\n  \\<in> ntrp fg\n  add_mset ss (c1 - {#ss#}) = c1\n  ee = ENV e\n\ngoal (1 subgoal):\n 1. ((s, c1), ee, s, csp + {#ssh#} + (c1 - {#ss#})) \\<in> ntrp fg", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  ((s, c1), ee, s, csp + {#ssh#} + (c1 - {#ss#})) \\<in> ntrp fg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((s, c1), ee, s, csp + {#ssh#} + (c1 - {#ss#})) \\<in> ntrp fg\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from trcl.cons[OF this IHAPP(3)]"], ["proof (chain)\npicking this:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "have \"((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)", "."], ["proof (state)\nthis:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from ntrs_mon_e_no_ctx[OF CASE(5)] left CASE(1) IHAPP(5)"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg (add_mset s ce) = {}\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2\n  ee = ENV e\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}", "have \"mon_ww fg (map le_rem_s (ee#w1)) \\<inter> mon_c fg c2 = {}\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg (add_mset s ce) = {}\n  c1 = add_mset ss (c1 - {#ss#})\n  ce = c1 - {#ss#} + c2\n  ee = ENV e\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\n\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from ntrp_mon_increasing_s[OF SS] IHAPP(6)"], ["proof (chain)\npicking this:\n  mon_s fg s \\<subseteq> mon_s fg s \\<and>\n  mon_c fg c1 \\<subseteq> mon_c fg (csp + {#ssh#} + (c1 - {#ss#}))\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) =\n  {}", "have \"mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\""], ["proof (prove)\nusing this:\n  mon_s fg s \\<subseteq> mon_s fg s \\<and>\n  mon_c fg c1 \\<subseteq> mon_c fg (csp + {#ssh#} + (c1 - {#ss#}))\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + (csp + {#ssh#} + (c1 - {#ss#}))) =\n  {}\n\ngoal (1 subgoal):\n 1. mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "note IHAPP(2,4)"], ["proof (state)\nthis:\n  c' = c1' + c2'\n  (c2, w2, c2') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c1 = add_mset ss (c1 - {#ss#}); ce = c1 - {#ss#} + c2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "ultimately"], ["proof (chain)\npicking this:\n  ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n  mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n  c' = c1' + c2'\n  (c2, w2, c2') \\<in> trcl (ntr fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ee # w \\<in> ee # w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  ((s, c1), ee # w1, s', c1') \\<in> trcl (ntrp fg)\n  mon_ww fg (map le_rem_s (ee # w1)) \\<inter> mon_c fg c2 = {}\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n  c' = c1' + c2'\n  (c2, w2, c2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<exists>w1 w2 c1' c2'.\n       ee # w\n       \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n       c' = c1' + c2' \\<and>\n       ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n       (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n       mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>w1 w2 c1' c2'.\n     ee # w\n     \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "next\n      \\<comment> \\<open>Made an env-step in @{term c2}. This is considered the right part. Induction hypothesis is applied with original local thread and the spawned threads on the right side\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "case right"], ["proof (state)\nthis:\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "with HFMT(1) CASE(4) CEHFMT"], ["proof (chain)\npicking this:\n  add_mset s ceh = csp + add_mset s ce\n  ch = add_mset ssh ceh\n  ceh = csp + ce\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})", "have CHFMT': \"ch=c1 + (csp+{#ssh#}+(c2-{#ss#}))\""], ["proof (prove)\nusing this:\n  add_mset s ceh = csp + add_mset s ce\n  ch = add_mset ssh ceh\n  ceh = csp + ce\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})\n\ngoal (1 subgoal):\n 1. ch = c1 + (csp + {#ssh#} + (c2 - {#ss#}))", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  ch = c1 + (csp + {#ssh#} + (c2 - {#ss#}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have VALID: \"valid fg ({#s#} + c1 + ((csp+{#ssh#}+(c2-{#ss#}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg ({#s#} + c1 + (csp + {#ssh#} + (c2 - {#ss#})))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid fg ({#s#} + c1 + (csp + {#ssh#} + (c2 - {#ss#})))", "from ntr_valid_preserve_s[OF gtrI_s, OF CASE(5)] Cons.prems(2) CASE(2)"], ["proof (chain)\npicking this:\n  valid fg (add_mset ss (add_mset s ce)) \\<Longrightarrow>\n  valid fg (add_mset ssh (add_mset s ceh))\n  valid fg ({#s#} + c1 + c2)\n  c1 + c2 = add_mset ss ce", "have \"valid fg ({#ssh#} + ({#s#} + ceh))\""], ["proof (prove)\nusing this:\n  valid fg (add_mset ss (add_mset s ce)) \\<Longrightarrow>\n  valid fg (add_mset ssh (add_mset s ceh))\n  valid fg ({#s#} + c1 + c2)\n  c1 + c2 = add_mset ss ce\n\ngoal (1 subgoal):\n 1. valid fg ({#ssh#} + ({#s#} + ceh))", "by  (auto simp add: union_ac add_mset_commute)"], ["proof (state)\nthis:\n  valid fg ({#ssh#} + ({#s#} + ceh))\n\ngoal (1 subgoal):\n 1. valid fg ({#s#} + c1 + (csp + {#ssh#} + (c2 - {#ss#})))", "with right CEHFMT"], ["proof (chain)\npicking this:\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})\n  ceh = csp + ce\n  valid fg ({#ssh#} + ({#s#} + ceh))", "show ?thesis"], ["proof (prove)\nusing this:\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})\n  ceh = csp + ce\n  valid fg ({#ssh#} + ({#s#} + ceh))\n\ngoal (1 subgoal):\n 1. valid fg ({#s#} + c1 + (csp + {#ssh#} + (c2 - {#ss#})))", "by (auto simp add: union_ac add_mset_commute)"], ["proof (state)\nthis:\n  valid fg ({#s#} + c1 + (csp + {#ssh#} + (c2 - {#ss#})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid fg ({#s#} + c1 + (csp + {#ssh#} + (c2 - {#ss#})))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from Cons.hyps[OF _ VALID,of s' c'] CHFMT' SPLIT(2) CASE(3)"], ["proof (chain)\npicking this:\n  ((s, c1 + (csp + {#ssh#} + (c2 - {#ss#}))), w, s', c')\n  \\<in> trcl (ntrp fg) \\<Longrightarrow>\n  \\<exists>w1 w2 c1' c2'.\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (csp + {#ssh#} + (c2 - {#ss#}), w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter>\n     mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) =\n     {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n  ch = c1 + (csp + {#ssh#} + (c2 - {#ss#}))\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n  sh = s", "obtain w1 w2 c1' c2' where IHAPP: \"w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\" \"c' = c1' + c2'\" \n        \"((s, c1), w1, s', c1') \\<in> trcl (ntrp fg)\" \"(csp + {#ssh#} + (c2 - {#ss#}), w2, c2') \\<in> trcl (ntr fg)\" \n        \"mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) = {}\" \"mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\""], ["proof (prove)\nusing this:\n  ((s, c1 + (csp + {#ssh#} + (c2 - {#ss#}))), w, s', c')\n  \\<in> trcl (ntrp fg) \\<Longrightarrow>\n  \\<exists>w1 w2 c1' c2'.\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (csp + {#ssh#} + (c2 - {#ss#}), w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter>\n     mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) =\n     {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n  ch = c1 + (csp + {#ssh#} + (c2 - {#ss#}))\n  ((sh, ch), w, s', c') \\<in> trcl (ntrp fg)\n  sh = s\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 c1' c2'.\n        \\<lbrakk>w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n        fg\\<^esub> map ENV w2;\n         c' = c1' + c2'; ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg);\n         (csp + {#ssh#} + (c2 - {#ss#}), w2, c2') \\<in> trcl (ntr fg);\n         mon_ww fg (map le_rem_s w1) \\<inter>\n         mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) =\n         {};\n         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n  c' = c1' + c2'\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg)\n  (csp + {#ssh#} + (c2 - {#ss#}), w2, c2') \\<in> trcl (ntr fg)\n  mon_ww fg (map le_rem_s w1) \\<inter>\n  mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) =\n  {}\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have \"ee # w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV (e#w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ee # w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV (e # w2)", "proof (simp add: CASE(1), rule cil_cons2)"], ["proof (state)\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "from IHAPP(5)"], ["proof (chain)\npicking this:\n  mon_ww fg (map le_rem_s w1) \\<inter>\n  mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) =\n  {}", "have \"mon_ww fg (map le_rem_s w1) \\<inter> mon_s fg ssh = {}\""], ["proof (prove)\nusing this:\n  mon_ww fg (map le_rem_s w1) \\<inter>\n  mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) =\n  {}\n\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s w1) \\<inter> mon_s fg ssh = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_s fg ssh = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_s fg ssh = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "from ntrs_mon_s[OF CASE(5)] CASE(1)"], ["proof (chain)\npicking this:\n  mon_s fg ssh = mon_s fg ss \\<union> fst (\\<alpha>n fg e)\n  ee = ENV e", "have \"fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh\""], ["proof (prove)\nusing this:\n  mon_s fg ssh = mon_s fg ss \\<union> fst (\\<alpha>n fg e)\n  ee = ENV e\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh", "by auto"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_s fg ssh = {}\n  fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh", "have \"fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg (map le_rem_s w1) = {}\""], ["proof (prove)\nusing this:\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_s fg ssh = {}\n  fst (\\<alpha>nl fg ee) \\<subseteq> mon_s fg ssh\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg (map le_rem_s w1) = {}", "by auto"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg (map le_rem_s w1) = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "moreover"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg (map le_rem_s w1) = {}\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "have \"mon_pl (map (\\<alpha>nl fg) w1) = mon_ww fg (map le_rem_s w1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon_pl (map (\\<alpha>nl fg) w1) = mon_ww fg (map le_rem_s w1)", "by (unfold \\<alpha>nl_def') (simp add: cil_\\<alpha>n_cons_helper[symmetric])"], ["proof (state)\nthis:\n  mon_pl (map (\\<alpha>nl fg) w1) = mon_ww fg (map le_rem_s w1)\n\ngoal (2 subgoals):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2\n 2. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg (map le_rem_s w1) = {}\n  mon_pl (map (\\<alpha>nl fg) w1) = mon_ww fg (map le_rem_s w1)", "show \"fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\""], ["proof (prove)\nusing this:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg (map le_rem_s w1) = {}\n  mon_pl (map (\\<alpha>nl fg) w1) = mon_ww fg (map le_rem_s w1)\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "using CASE(1)"], ["proof (prove)\nusing this:\n  fst (\\<alpha>nl fg ee) \\<inter> mon_ww fg (map le_rem_s w1) = {}\n  mon_pl (map (\\<alpha>nl fg) w1) = mon_ww fg (map le_rem_s w1)\n  ee = ENV e\n\ngoal (1 subgoal):\n 1. fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n    {}", "by auto"], ["proof (state)\nthis:\n  fst (\\<alpha>nl fg (ENV e)) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\n\ngoal (1 subgoal):\n 1. w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2", "qed (rule IHAPP(1))"], ["proof (state)\nthis:\n  ee # w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV (e # w2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  ee # w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV (e # w2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have SS: \"(c2,e,csp + {#ssh#} + (c2 - {#ss#}))\\<in>ntr fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c2, e, csp + {#ssh#} + (c2 - {#ss#})) \\<in> ntr fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (c2, e, csp + {#ssh#} + (c2 - {#ss#})) \\<in> ntr fg", "from right HFMT(1)"], ["proof (chain)\npicking this:\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})\n  add_mset s ceh = csp + add_mset s ce", "have \"{#s#}+ce={#s#}+c1+(c2-{#ss#})\" \"{#s#}+ceh = csp+({#s#}+c1+(c2-{#ss#}))\""], ["proof (prove)\nusing this:\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})\n  add_mset s ceh = csp + add_mset s ce\n\ngoal (1 subgoal):\n 1. {#s#} + ce = {#s#} + c1 + (c2 - {#ss#}) &&&\n    {#s#} + ceh = csp + ({#s#} + c1 + (c2 - {#ss#}))", "by (simp_all add: union_ac)"], ["proof (state)\nthis:\n  {#s#} + ce = {#s#} + c1 + (c2 - {#ss#})\n  {#s#} + ceh = csp + ({#s#} + c1 + (c2 - {#ss#}))\n\ngoal (1 subgoal):\n 1. (c2, e, csp + {#ssh#} + (c2 - {#ss#})) \\<in> ntr fg", "with CASE(5) ntrs_xchange_context_s[of ss \"{#s#}+c1+(c2-{#ss#})\" e ssh csp fg \"c2-{#ss#}\"]"], ["proof (chain)\npicking this:\n  ((ss, add_mset s ce), e, ssh, add_mset s ceh) \\<in> ntrs fg\n  \\<lbrakk>((ss, {#s#} + c1 + (c2 - {#ss#})), e, ssh,\n            csp + ({#s#} + c1 + (c2 - {#ss#})))\n           \\<in> ntrs fg;\n   mon_c fg (c2 - {#ss#})\n   \\<subseteq> mon_c fg ({#s#} + c1 + (c2 - {#ss#}))\\<rbrakk>\n  \\<Longrightarrow> ((ss, c2 - {#ss#}), e, ssh, csp + (c2 - {#ss#}))\n                    \\<in> ntrs fg\n  {#s#} + ce = {#s#} + c1 + (c2 - {#ss#})\n  {#s#} + ceh = csp + ({#s#} + c1 + (c2 - {#ss#}))", "have \n          \"((ss, (c2 - {#ss#})), e, ssh, csp+ (c2 - {#ss#})) \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  ((ss, add_mset s ce), e, ssh, add_mset s ceh) \\<in> ntrs fg\n  \\<lbrakk>((ss, {#s#} + c1 + (c2 - {#ss#})), e, ssh,\n            csp + ({#s#} + c1 + (c2 - {#ss#})))\n           \\<in> ntrs fg;\n   mon_c fg (c2 - {#ss#})\n   \\<subseteq> mon_c fg ({#s#} + c1 + (c2 - {#ss#}))\\<rbrakk>\n  \\<Longrightarrow> ((ss, c2 - {#ss#}), e, ssh, csp + (c2 - {#ss#}))\n                    \\<in> ntrs fg\n  {#s#} + ce = {#s#} + c1 + (c2 - {#ss#})\n  {#s#} + ceh = csp + ({#s#} + c1 + (c2 - {#ss#}))\n\ngoal (1 subgoal):\n 1. ((ss, c2 - {#ss#}), e, ssh, csp + (c2 - {#ss#})) \\<in> ntrs fg", "by (auto simp add: mon_c_unconc union_ac)"], ["proof (state)\nthis:\n  ((ss, c2 - {#ss#}), e, ssh, csp + (c2 - {#ss#})) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. (c2, e, csp + {#ssh#} + (c2 - {#ss#})) \\<in> ntr fg", "from gtrI_s[OF this] right(1)[symmetric]"], ["proof (chain)\npicking this:\n  (add_mset ss (c2 - {#ss#}), e, add_mset ssh (csp + (c2 - {#ss#})))\n  \\<in> ntr fg\n  add_mset ss (c2 - {#ss#}) = c2", "show ?thesis"], ["proof (prove)\nusing this:\n  (add_mset ss (c2 - {#ss#}), e, add_mset ssh (csp + (c2 - {#ss#})))\n  \\<in> ntr fg\n  add_mset ss (c2 - {#ss#}) = c2\n\ngoal (1 subgoal):\n 1. (c2, e, csp + {#ssh#} + (c2 - {#ss#})) \\<in> ntr fg", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  (c2, e, csp + {#ssh#} + (c2 - {#ss#})) \\<in> ntr fg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (c2, e, csp + {#ssh#} + (c2 - {#ss#})) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from trcl.cons[OF this IHAPP(4)]"], ["proof (chain)\npicking this:\n  (c2, e # w2, c2') \\<in> trcl (ntr fg)", "have \"(c2, e # w2, c2') \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  (c2, e # w2, c2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (c2, e # w2, c2') \\<in> trcl (ntr fg)", "."], ["proof (state)\nthis:\n  (c2, e # w2, c2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  (c2, e # w2, c2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from ntr_mon_increasing_s[OF SS] IHAPP(5)"], ["proof (chain)\npicking this:\n  mon_c fg c2 \\<subseteq> mon_c fg (csp + {#ssh#} + (c2 - {#ss#}))\n  mon_ww fg (map le_rem_s w1) \\<inter>\n  mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) =\n  {}", "have \"mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\""], ["proof (prove)\nusing this:\n  mon_c fg c2 \\<subseteq> mon_c fg (csp + {#ssh#} + (c2 - {#ss#}))\n  mon_ww fg (map le_rem_s w1) \\<inter>\n  mon_c fg (csp + {#ssh#} + (c2 - {#ss#})) =\n  {}\n\ngoal (1 subgoal):\n 1. mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "from ntrs_mon_e_no_ctx[OF CASE(5)] right IHAPP(6)"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg (add_mset s ce) = {}\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "have \"mon_ww fg (e#w2) \\<inter> mon_c fg ({#s#} + c1) = {}\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg (add_mset s ce) = {}\n  c2 = add_mset ss (c2 - {#ss#})\n  ce = c1 + (c2 - {#ss#})\n  mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (1 subgoal):\n 1. mon_ww fg (e # w2) \\<inter> mon_c fg ({#s#} + c1) = {}", "by (auto simp add: mon_c_unconc)"], ["proof (state)\nthis:\n  mon_ww fg (e # w2) \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "moreover"], ["proof (state)\nthis:\n  mon_ww fg (e # w2) \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "note IHAPP(2,3)"], ["proof (state)\nthis:\n  c' = c1' + c2'\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c2 = add_mset ss (c2 - {#ss#});\n     ce = c1 + (c2 - {#ss#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         ee # w\n                         \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n              fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "ultimately"], ["proof (chain)\npicking this:\n  ee # w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV (e # w2)\n  (c2, e # w2, c2') \\<in> trcl (ntr fg)\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\n  mon_ww fg (e # w2) \\<inter> mon_c fg ({#s#} + c1) = {}\n  c' = c1' + c2'\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ee # w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV (e # w2)\n  (c2, e # w2, c2') \\<in> trcl (ntr fg)\n  mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {}\n  mon_ww fg (e # w2) \\<inter> mon_c fg ({#s#} + c1) = {}\n  c' = c1' + c2'\n  ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<exists>w1 w2 c1' c2'.\n       ee # w\n       \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n       c' = c1' + c2' \\<and>\n       ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n       (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n       mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n       mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>w1 w2 c1' c2'.\n     ee # w\n     \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w1 w2 c1' c2'.\n     ee # w\n     \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w1 w2 c1' c2'.\n     ee # w\n     \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n     c' = c1' + c2' \\<and>\n     ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n     (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n     mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n     mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Just a check that @{thm [source] \"flowgraph.ntrp_split\"} is really a generalization of @{thm [source] \"flowgraph.ntr_split\"}:\\<close>"], ["", "lemma (in flowgraph) ntr_split': \n  assumes A: \"(ca+cb,w,c')\\<in>trcl (ntr fg)\" \n  and VALID: \"valid fg (ca+cb)\" \n  shows \"\\<exists>ca' cb' wa wb. \n    c'=ca'+cb' \\<and> \n    w\\<in>(wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb) \\<and> \n    mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and> \n    mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and> \n    (ca,wa,ca')\\<in>trcl (ntr fg) \\<and> \n    (cb,wb,cb')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ca' cb' wa wb.\n       c' = ca' + cb' \\<and>\n       w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n       (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg)", "using A VALID"], ["proof (prove)\nusing this:\n  (ca + cb, w, c') \\<in> trcl (ntr fg)\n  valid fg (ca + cb)\n\ngoal (1 subgoal):\n 1. \\<exists>ca' cb' wa wb.\n       c' = ca' + cb' \\<and>\n       w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n       (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg)", "by(rule ntr_split)"], ["", "text \\<open>The unsplit lemma combines two interleavable executions. For illustration purposes, we first prove the less general version for multiset-configurations.\n  The general version for loc/env-configurations is shown later.\\<close>"], ["", "lemma (in flowgraph) ntr_unsplit: \n  assumes A: \"w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb\" and \n  B: \"(ca,wa,ca')\\<in>trcl (ntr fg)\" \n  \"(cb,wb,cb')\\<in>trcl (ntr fg)\" \n  \"mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb)={}\" \n  \"mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa)={}\"\n  shows \"(ca+cb,w,ca'+cb')\\<in>trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)", "proof -\n  \\<comment> \\<open>We have to generalize and rewrite the goal, in order to apply Isabelle's induction method\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)", "from A"], ["proof (chain)\npicking this:\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb", "have \"\\<forall>ca cb. (ca,wa,ca')\\<in>trcl (ntr fg) \\<and> (cb,wb,cb')\\<in>trcl (ntr fg) \\<and> mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb)={} \\<and> mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa)={} \\<longrightarrow> \n    (ca+cb,w,ca'+cb')\\<in>trcl (ntr fg)\"\n  \\<comment> \\<open>We prove the generalized goal by induction over the structure of consistent interleaving\\<close>"], ["proof (prove)\nusing this:\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb\n\ngoal (1 subgoal):\n 1. \\<forall>ca cb.\n       (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) =\n       {} \\<longrightarrow>\n       (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)", "proof (induct rule: cil_set_induct_fix\\<alpha>) \n    \\<comment> \\<open>If both words are empty, the proposition is trivial\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>ca cb.\n       (ca, [], ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, [], cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg []) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg []) =\n       {} \\<longrightarrow>\n       (ca + cb, [], ca' + cb') \\<in> trcl (ntr fg)\n 2. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n 3. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg w1) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<forall>ca cb.\n       (ca, [], ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, [], cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg []) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg []) =\n       {} \\<longrightarrow>\n       (ca + cb, [], ca' + cb') \\<in> trcl (ntr fg)\n 2. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n 3. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg w1) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ca cb.\n       (ca, [], ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, [], cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg []) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg []) =\n       {} \\<longrightarrow>\n       (ca + cb, [], ca' + cb') \\<in> trcl (ntr fg)", "by simp"], ["proof (state)\nthis:\n  \\<forall>ca cb.\n     (ca, [], ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, [], cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg []) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg []) =\n     {} \\<longrightarrow>\n     (ca + cb, [], ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg w1) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "next\n    \\<comment> \\<open>The first macrostep of the combined path was taken from the left operand of the interleaving\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg w1) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "case (left e w' w1' w2)"], ["proof (state)\nthis:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  \\<forall>ca cb.\n     (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n     {} \\<longrightarrow>\n     (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg w1) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "thus ?case"], ["proof (prove)\nusing this:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  \\<forall>ca cb.\n     (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n     {} \\<longrightarrow>\n     (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<forall>ca cb.\n       (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n       {} \\<longrightarrow>\n       (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "case (1 ca cb)"], ["proof (state)\nthis:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  \\<forall>ca cb.\n     (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n     {} \\<longrightarrow>\n     (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "hence I: \"w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\" \"fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\" \n        \"!!ca cb.\n           \\<lbrakk>(ca, w1', ca') \\<in> trcl (ntr fg);\n           (cb, w2, cb') \\<in> trcl (ntr fg);\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {};\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') = {}\\<rbrakk> \\<Longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\" \n        \"(ca, e # w1', ca') \\<in> trcl (ntr fg)\" \"(cb, w2, cb') \\<in> trcl (ntr fg)\"\n        \"mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\"\n        \"mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\""], ["proof (prove)\nusing this:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  \\<forall>ca cb.\n     (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n     {} \\<longrightarrow>\n     (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n\ngoal (1 subgoal):\n 1. (w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 &&&\n     fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {} &&&\n     (\\<And>ca cb.\n         \\<lbrakk>(ca, w1', ca') \\<in> trcl (ntr fg);\n          (cb, w2, cb') \\<in> trcl (ntr fg);\n          mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {};\n          mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n          {}\\<rbrakk>\n         \\<Longrightarrow> (ca + cb, w', ca' + cb')\n                           \\<in> trcl (ntr fg))) &&&\n    ((ca, e # w1', ca') \\<in> trcl (ntr fg) &&&\n     (cb, w2, cb') \\<in> trcl (ntr fg)) &&&\n    mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} &&&\n    mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}", "by blast+\n      \\<comment> \\<open>Split the left path after the first step\\<close>"], ["proof (state)\nthis:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  \\<lbrakk>(?ca, w1', ca') \\<in> trcl (ntr fg);\n   (?cb, w2, cb') \\<in> trcl (ntr fg);\n   mon_c fg ?ca \\<inter> (mon_c fg ?cb \\<union> mon_ww fg w2) = {};\n   mon_c fg ?cb \\<inter> (mon_c fg ?ca \\<union> mon_ww fg w1') = {}\\<rbrakk>\n  \\<Longrightarrow> (?ca + ?cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, e # w1', ca') \\<in> trcl (ntr fg)\n  (cb, w2, cb') \\<in> trcl (ntr fg)\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "then"], ["proof (chain)\npicking this:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  \\<lbrakk>(?ca, w1', ca') \\<in> trcl (ntr fg);\n   (?cb, w2, cb') \\<in> trcl (ntr fg);\n   mon_c fg ?ca \\<inter> (mon_c fg ?cb \\<union> mon_ww fg w2) = {};\n   mon_c fg ?cb \\<inter> (mon_c fg ?ca \\<union> mon_ww fg w1') = {}\\<rbrakk>\n  \\<Longrightarrow> (?ca + ?cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, e # w1', ca') \\<in> trcl (ntr fg)\n  (cb, w2, cb') \\<in> trcl (ntr fg)\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}", "obtain cah where SPLIT: \"(ca,e,cah)\\<in>ntr fg\" \"(cah,w1',ca')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  \\<lbrakk>(?ca, w1', ca') \\<in> trcl (ntr fg);\n   (?cb, w2, cb') \\<in> trcl (ntr fg);\n   mon_c fg ?ca \\<inter> (mon_c fg ?cb \\<union> mon_ww fg w2) = {};\n   mon_c fg ?cb \\<inter> (mon_c fg ?ca \\<union> mon_ww fg w1') = {}\\<rbrakk>\n  \\<Longrightarrow> (?ca + ?cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, e # w1', ca') \\<in> trcl (ntr fg)\n  (cb, w2, cb') \\<in> trcl (ntr fg)\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>cah.\n        \\<lbrakk>(ca, e, cah) \\<in> ntr fg;\n         (cah, w1', ca') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)\n      \\<comment> \\<open>and combine the first step of the left path with the initial right context\\<close>"], ["proof (state)\nthis:\n  (ca, e, cah) \\<in> ntr fg\n  (cah, w1', ca') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "from ntr_add_context_s[OF SPLIT(1), where cn=cb] I(7)"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg cb = {} \\<Longrightarrow>\n  (ca + cb, e, cah + cb) \\<in> ntr fg\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}", "have \"(ca + cb, e, cah + cb) \\<in> ntr fg\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg cb = {} \\<Longrightarrow>\n  (ca + cb, e, cah + cb) \\<in> ntr fg\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n\ngoal (1 subgoal):\n 1. (ca + cb, e, cah + cb) \\<in> ntr fg", "by auto"], ["proof (state)\nthis:\n  (ca + cb, e, cah + cb) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "also\n      \\<comment> \\<open>The rest of the path is combined by using the induction hypothesis\\<close>"], ["proof (state)\nthis:\n  (ca + cb, e, cah + cb) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "have \"(cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)", "from I(2,6,7) ntr_mon_s[OF SPLIT(1)]"], ["proof (chain)\npicking this:\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n  mon_c fg cah = mon_c fg ca \\<union> fst (\\<alpha>n fg e)", "have MON_CAH: \"mon_c fg cah \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\""], ["proof (prove)\nusing this:\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {}\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n  mon_c fg cah = mon_c fg ca \\<union> fst (\\<alpha>n fg e)\n\ngoal (1 subgoal):\n 1. mon_c fg cah \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}", "by (cases e) (auto simp add: cil_\\<alpha>n_cons_helper)"], ["proof (state)\nthis:\n  mon_c fg cah \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\n\ngoal (1 subgoal):\n 1. (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)", "with I(7)"], ["proof (chain)\npicking this:\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n  mon_c fg cah \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}", "have MON_CB: \"mon_c fg cb \\<inter> (mon_c fg cah \\<union> mon_ww fg w1') = {}\""], ["proof (prove)\nusing this:\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) = {}\n  mon_c fg cah \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {}\n\ngoal (1 subgoal):\n 1. mon_c fg cb \\<inter> (mon_c fg cah \\<union> mon_ww fg w1') = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg cb \\<inter> (mon_c fg cah \\<union> mon_ww fg w1') = {}\n\ngoal (1 subgoal):\n 1. (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)", "from I(3)[OF SPLIT(2) I(5) MON_CAH MON_CB]"], ["proof (chain)\npicking this:\n  (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)", "."], ["proof (state)\nthis:\n  (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (cah + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w2) = {};\n        \\<forall>ca cb.\n           (ca, w1', ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1') =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "finally"], ["proof (chain)\npicking this:\n  (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "show ?case"], ["proof (prove)\nusing this:\n  (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "."], ["proof (state)\nthis:\n  (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ca cb.\n     (ca, e # w1', ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg (e # w1')) =\n     {} \\<longrightarrow>\n     (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg w1) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "next\n    \\<comment> \\<open>The first macrostep of the combined path was taken from the right path -- this case is done completely analogous\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg w1) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "case (right e w' w2' w1)"], ["proof (state)\nthis:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2'\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  \\<forall>ca cb.\n     (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n     {} \\<longrightarrow>\n     (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ca cb.\n                            (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n                            (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ca \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ca \\<union> mon_ww fg w1) =\n                            {} \\<longrightarrow>\n                            (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "thus ?case"], ["proof (prove)\nusing this:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2'\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  \\<forall>ca cb.\n     (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n     {} \\<longrightarrow>\n     (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<forall>ca cb.\n       (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n       (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n       {} \\<and>\n       mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n       {} \\<longrightarrow>\n       (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n        {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "case (1 ca cb)"], ["proof (state)\nthis:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2'\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  \\<forall>ca cb.\n     (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n     {} \\<longrightarrow>\n     (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n  {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n        {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "hence I: \"w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2'\" \"fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\" \n        \"!!ca cb.\n           \\<lbrakk>(ca, w1, ca') \\<in> trcl (ntr fg);\n           (cb, w2', cb') \\<in> trcl (ntr fg);\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') = {};\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\\<rbrakk> \\<Longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\" \n        \"(ca, w1, ca') \\<in> trcl (ntr fg)\" \"(cb, e#w2', cb') \\<in> trcl (ntr fg)\"\n        \"mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e#w2')) = {}\"\n        \"mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\""], ["proof (prove)\nusing this:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2'\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  \\<forall>ca cb.\n     (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n     {} \\<longrightarrow>\n     (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n  (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n  {} \\<and>\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\n\ngoal (1 subgoal):\n 1. (w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2' &&&\n     fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {} &&&\n     (\\<And>ca cb.\n         \\<lbrakk>(ca, w1, ca') \\<in> trcl (ntr fg);\n          (cb, w2', cb') \\<in> trcl (ntr fg);\n          mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') = {};\n          mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n          {}\\<rbrakk>\n         \\<Longrightarrow> (ca + cb, w', ca' + cb')\n                           \\<in> trcl (ntr fg))) &&&\n    ((ca, w1, ca') \\<in> trcl (ntr fg) &&&\n     (cb, e # w2', cb') \\<in> trcl (ntr fg)) &&&\n    mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {} &&&\n    mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}", "by blast+"], ["proof (state)\nthis:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2'\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  \\<lbrakk>(?ca, w1, ca') \\<in> trcl (ntr fg);\n   (?cb, w2', cb') \\<in> trcl (ntr fg);\n   mon_c fg ?ca \\<inter> (mon_c fg ?cb \\<union> mon_ww fg w2') = {};\n   mon_c fg ?cb \\<inter> (mon_c fg ?ca \\<union> mon_ww fg w1) = {}\\<rbrakk>\n  \\<Longrightarrow> (?ca + ?cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, w1, ca') \\<in> trcl (ntr fg)\n  (cb, e # w2', cb') \\<in> trcl (ntr fg)\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n        {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "then"], ["proof (chain)\npicking this:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2'\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  \\<lbrakk>(?ca, w1, ca') \\<in> trcl (ntr fg);\n   (?cb, w2', cb') \\<in> trcl (ntr fg);\n   mon_c fg ?ca \\<inter> (mon_c fg ?cb \\<union> mon_ww fg w2') = {};\n   mon_c fg ?cb \\<inter> (mon_c fg ?ca \\<union> mon_ww fg w1) = {}\\<rbrakk>\n  \\<Longrightarrow> (?ca + ?cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, w1, ca') \\<in> trcl (ntr fg)\n  (cb, e # w2', cb') \\<in> trcl (ntr fg)\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}", "obtain cbh where SPLIT: \"(cb,e,cbh)\\<in>ntr fg\" \"(cbh,w2',cb')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2'\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  \\<lbrakk>(?ca, w1, ca') \\<in> trcl (ntr fg);\n   (?cb, w2', cb') \\<in> trcl (ntr fg);\n   mon_c fg ?ca \\<inter> (mon_c fg ?cb \\<union> mon_ww fg w2') = {};\n   mon_c fg ?cb \\<inter> (mon_c fg ?ca \\<union> mon_ww fg w1) = {}\\<rbrakk>\n  \\<Longrightarrow> (?ca + ?cb, w', ca' + cb') \\<in> trcl (ntr fg)\n  (ca, w1, ca') \\<in> trcl (ntr fg)\n  (cb, e # w2', cb') \\<in> trcl (ntr fg)\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>cbh.\n        \\<lbrakk>(cb, e, cbh) \\<in> ntr fg;\n         (cbh, w2', cb') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  (cb, e, cbh) \\<in> ntr fg\n  (cbh, w2', cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n        {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "from ntr_add_context_s[OF SPLIT(1), where cn=ca] I(6)"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg ca = {} \\<Longrightarrow>\n  (cb + ca, e, cbh + ca) \\<in> ntr fg\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}", "have \"(ca + cb, e, ca + cbh) \\<in> ntr fg\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg ca = {} \\<Longrightarrow>\n  (cb + ca, e, cbh + ca) \\<in> ntr fg\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}\n\ngoal (1 subgoal):\n 1. (ca + cb, e, ca + cbh) \\<in> ntr fg", "by (auto simp add: union_commute)"], ["proof (state)\nthis:\n  (ca + cb, e, ca + cbh) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n        {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "also"], ["proof (state)\nthis:\n  (ca + cb, e, ca + cbh) \\<in> ntr fg\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n        {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "have \"(ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)", "from I(2,6,7) ntr_mon_s[OF SPLIT(1)]"], ["proof (chain)\npicking this:\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\n  mon_c fg cbh = mon_c fg cb \\<union> fst (\\<alpha>n fg e)", "have MON_CBH: \"mon_c fg cbh \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\""], ["proof (prove)\nusing this:\n  fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {}\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\n  mon_c fg cbh = mon_c fg cb \\<union> fst (\\<alpha>n fg e)\n\ngoal (1 subgoal):\n 1. mon_c fg cbh \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}", "by (cases e) (auto simp add: cil_\\<alpha>n_cons_helper)"], ["proof (state)\nthis:\n  mon_c fg cbh \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\n\ngoal (1 subgoal):\n 1. (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)", "with I(6)"], ["proof (chain)\npicking this:\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}\n  mon_c fg cbh \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}", "have MON_CA: \"mon_c fg ca \\<inter> (mon_c fg cbh \\<union> mon_ww fg w2') = {}\""], ["proof (prove)\nusing this:\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) = {}\n  mon_c fg cbh \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) = {}\n\ngoal (1 subgoal):\n 1. mon_c fg ca \\<inter> (mon_c fg cbh \\<union> mon_ww fg w2') = {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg ca \\<inter> (mon_c fg cbh \\<union> mon_ww fg w2') = {}\n\ngoal (1 subgoal):\n 1. (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)", "from I(3)[OF I(4) SPLIT(2) MON_CA MON_CBH]"], ["proof (chain)\npicking this:\n  (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)", "."], ["proof (state)\nthis:\n  (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ca + cbh, w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>ca cb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2';\n        fst (\\<alpha>n fg e) \\<inter> mon_pl (map (\\<alpha>n fg) w1) = {};\n        \\<forall>ca cb.\n           (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n           (cb, w2', cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg w2') =\n           {} \\<and>\n           mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n           {} \\<longrightarrow>\n           (ca + cb, w', ca' + cb') \\<in> trcl (ntr fg);\n        (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n        {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "finally"], ["proof (chain)\npicking this:\n  (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "show ?case"], ["proof (prove)\nusing this:\n  (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)", "."], ["proof (state)\nthis:\n  (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ca cb.\n     (ca, w1, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, e # w2', cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg (e # w2')) =\n     {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg w1) =\n     {} \\<longrightarrow>\n     (ca + cb, e # w', ca' + cb') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ca cb.\n     (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) =\n     {} \\<longrightarrow>\n     (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)", "with B"], ["proof (chain)\npicking this:\n  (ca, wa, ca') \\<in> trcl (ntr fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\n  \\<forall>ca cb.\n     (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) =\n     {} \\<longrightarrow>\n     (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ca, wa, ca') \\<in> trcl (ntr fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {}\n  \\<forall>ca cb.\n     (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) =\n     {} \\<longrightarrow>\n     (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)", "by blast"], ["proof (state)\nthis:\n  (ca + cb, w, ca' + cb') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in flowgraph) ntrp_unsplit: \n  assumes A: \"w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> (map ENV wb)\" and\n  B: \"((s,ca),wa,(s',ca'))\\<in>trcl (ntrp fg)\" \n  \"(cb,wb,cb')\\<in>trcl (ntr fg)\" \n  \"mon_c fg ({#s#}+ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb)={}\" \n  \"mon_c fg cb \\<inter> (mon_c fg ({#s#}+ca) \\<union> mon_ww fg (map le_rem_s wa))={}\"\n  shows \"((s,ca+cb),w,(s',ca'+cb'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "fix wb'"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "have \"w\\<in>wa\\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub>wb' \\<Longrightarrow> \n      \\<forall>s ca cb wb. wb'=map ENV wb \\<and> \n      ((s,ca),wa,(s',ca'))\\<in>trcl (ntrp fg) \\<and> (cb,wb,cb')\\<in>trcl (ntr fg) \\<and> mon_c fg ({#s#}+ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb)={} \\<and> mon_c fg cb \\<inter> (mon_c fg ({#s#}+ca) \\<union> mon_ww fg (map le_rem_s wa))={} \\<longrightarrow> \n      ((s,ca+cb),w,(s',ca'+cb'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> wb' \\<Longrightarrow>\n    \\<forall>s ca cb wb.\n       wb' = map ENV wb \\<and>\n       ((s, ca), wa, s', ca') \\<in> trcl (ntrp fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n       {} \\<and>\n       mon_c fg cb \\<inter>\n       (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s wa)) =\n       {} \\<longrightarrow>\n       ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "proof (induct rule: cil_set_induct_fix\\<alpha>)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>s ca cb wb.\n       [] = map ENV wb \\<and>\n       ((s, ca), [], s', ca') \\<in> trcl (ntrp fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n       {} \\<and>\n       mon_c fg cb \\<inter>\n       (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s [])) =\n       {} \\<longrightarrow>\n       ((s, ca + cb), [], s', ca' + cb') \\<in> trcl (ntrp fg)\n 2. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            w2 = map ENV wb \\<and>\n                            ((s, ca), e # w1', s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s (e # w1'))) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)\n 3. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            e # w2' = map ENV wb \\<and>\n                            ((s, ca), w1, s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s w1)) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<forall>s ca cb wb.\n       [] = map ENV wb \\<and>\n       ((s, ca), [], s', ca') \\<in> trcl (ntrp fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n       {} \\<and>\n       mon_c fg cb \\<inter>\n       (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s [])) =\n       {} \\<longrightarrow>\n       ((s, ca + cb), [], s', ca' + cb') \\<in> trcl (ntrp fg)\n 2. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            w2 = map ENV wb \\<and>\n                            ((s, ca), e # w1', s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s (e # w1'))) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)\n 3. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            e # w2' = map ENV wb \\<and>\n                            ((s, ca), w1, s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s w1)) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s ca cb wb.\n       [] = map ENV wb \\<and>\n       ((s, ca), [], s', ca') \\<in> trcl (ntrp fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n       {} \\<and>\n       mon_c fg cb \\<inter>\n       (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s [])) =\n       {} \\<longrightarrow>\n       ((s, ca + cb), [], s', ca' + cb') \\<in> trcl (ntrp fg)", "by simp"], ["proof (state)\nthis:\n  \\<forall>s ca cb wb.\n     [] = map ENV wb \\<and>\n     ((s, ca), [], s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s [])) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), [], s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            w2 = map ENV wb \\<and>\n                            ((s, ca), e # w1', s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s (e # w1'))) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            e # w2' = map ENV wb \\<and>\n                            ((s, ca), w1, s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s w1)) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            w2 = map ENV wb \\<and>\n                            ((s, ca), e # w1', s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s (e # w1'))) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            e # w2' = map ENV wb \\<and>\n                            ((s, ca), w1, s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s w1)) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)", "case (left e w' w1' w2)"], ["proof (state)\nthis:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  \\<forall>s ca cb wb.\n     w2 = map ENV wb \\<and>\n     ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (2 subgoals):\n 1. \\<And>e w' w1' w2.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            w2 = map ENV wb \\<and>\n                            ((s, ca), e # w1', s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s (e # w1'))) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)\n 2. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            e # w2' = map ENV wb \\<and>\n                            ((s, ca), w1, s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s w1)) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)", "thus ?case"], ["proof (prove)\nusing this:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  \\<forall>s ca cb wb.\n     w2 = map ENV wb \\<and>\n     ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<forall>s ca cb wb.\n       w2 = map ENV wb \\<and>\n       ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n       {} \\<and>\n       mon_c fg cb \\<inter>\n       (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n       {} \\<longrightarrow>\n       ((s, ca + cb), e # w', s', ca' + cb') \\<in> trcl (ntrp fg)", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        w2 = map ENV wb \\<and>\n        ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union>\n         mon_ww fg (map le_rem_s (e # w1'))) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), e # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "case (1 s ca cb wb)"], ["proof (state)\nthis:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  \\<forall>s ca cb wb.\n     w2 = map ENV wb \\<and>\n     ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n  w2 = map ENV wb \\<and>\n  ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n  {} \\<and>\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        w2 = map ENV wb \\<and>\n        ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union>\n         mon_ww fg (map le_rem_s (e # w1'))) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), e # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "hence I: \"w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2\" \"fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\"\n          \"!!s ca cb wb. \\<lbrakk>\n            w2 = map ENV wb;\n            ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg);\n            (cb, wb, cb') \\<in> trcl (ntr fg);\n            mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {};\n            mon_c fg cb \\<inter> (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) = {}\n          \\<rbrakk> \\<Longrightarrow> ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\"\n          \"w2 = map ENV wb\"\n          \"((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg)\"\n          \"(cb, wb, cb') \\<in> trcl (ntr fg)\"\n          \"mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\"\n          \"mon_c fg cb \\<inter> (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) = {}\""], ["proof (prove)\nusing this:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  \\<forall>s ca cb wb.\n     w2 = map ENV wb \\<and>\n     ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n  w2 = map ENV wb \\<and>\n  ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n  {} \\<and>\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}\n\ngoal (1 subgoal):\n 1. ((w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2 &&&\n      fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) =\n      {}) &&&\n     (\\<And>s ca cb wb.\n         \\<lbrakk>w2 = map ENV wb;\n          ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg);\n          (cb, wb, cb') \\<in> trcl (ntr fg);\n          mon_c fg ({#s#} + ca) \\<inter>\n          (mon_c fg cb \\<union> mon_ww fg wb) =\n          {};\n          mon_c fg cb \\<inter>\n          (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n          {}\\<rbrakk>\n         \\<Longrightarrow> ((s, ca + cb), w', s', ca' + cb')\n                           \\<in> trcl (ntrp fg)) &&&\n     w2 = map ENV wb) &&&\n    (((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) &&&\n     (cb, wb, cb') \\<in> trcl (ntr fg)) &&&\n    mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n    {} &&&\n    mon_c fg cb \\<inter>\n    (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n    {}", "by blast+"], ["proof (state)\nthis:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  \\<lbrakk>w2 = map ENV ?wb; ((?s, ?ca), w1', s', ca') \\<in> trcl (ntrp fg);\n   (?cb, ?wb, cb') \\<in> trcl (ntr fg);\n   mon_c fg ({#?s#} + ?ca) \\<inter> (mon_c fg ?cb \\<union> mon_ww fg ?wb) =\n   {};\n   mon_c fg ?cb \\<inter>\n   (mon_c fg ({#?s#} + ?ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?ca + ?cb), w', s', ca' + cb')\n                    \\<in> trcl (ntrp fg)\n  w2 = map ENV wb\n  ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        w2 = map ENV wb \\<and>\n        ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union>\n         mon_ww fg (map le_rem_s (e # w1'))) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), e # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "then"], ["proof (chain)\npicking this:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  \\<lbrakk>w2 = map ENV ?wb; ((?s, ?ca), w1', s', ca') \\<in> trcl (ntrp fg);\n   (?cb, ?wb, cb') \\<in> trcl (ntr fg);\n   mon_c fg ({#?s#} + ?ca) \\<inter> (mon_c fg ?cb \\<union> mon_ww fg ?wb) =\n   {};\n   mon_c fg ?cb \\<inter>\n   (mon_c fg ({#?s#} + ?ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?ca + ?cb), w', s', ca' + cb')\n                    \\<in> trcl (ntrp fg)\n  w2 = map ENV wb\n  ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}", "obtain sh cah where SPLIT: \"((s,ca),e,(sh,cah))\\<in>ntrp fg\" \"((sh,cah),w1',(s',ca'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\nusing this:\n  w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  \\<lbrakk>w2 = map ENV ?wb; ((?s, ?ca), w1', s', ca') \\<in> trcl (ntrp fg);\n   (?cb, ?wb, cb') \\<in> trcl (ntr fg);\n   mon_c fg ({#?s#} + ?ca) \\<inter> (mon_c fg ?cb \\<union> mon_ww fg ?wb) =\n   {};\n   mon_c fg ?cb \\<inter>\n   (mon_c fg ({#?s#} + ?ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?ca + ?cb), w', s', ca' + cb')\n                    \\<in> trcl (ntrp fg)\n  w2 = map ENV wb\n  ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>sh cah.\n        \\<lbrakk>((s, ca), e, sh, cah) \\<in> ntrp fg;\n         ((sh, cah), w1', s', ca') \\<in> trcl (ntrp fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  ((s, ca), e, sh, cah) \\<in> ntrp fg\n  ((sh, cah), w1', s', ca') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        w2 = map ENV wb \\<and>\n        ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union>\n         mon_ww fg (map le_rem_s (e # w1'))) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), e # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "from ntrp_add_context_s[OF SPLIT(1), of cb] I(8)"], ["proof (chain)\npicking this:\n  mon_w fg (le_rem_s e) \\<inter> mon_c fg cb = {} \\<Longrightarrow>\n  ((s, ca + cb), e, sh, cah + cb) \\<in> ntrp fg\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}", "have \"((s, ca + cb), e, sh, cah + cb) \\<in> ntrp fg\""], ["proof (prove)\nusing this:\n  mon_w fg (le_rem_s e) \\<inter> mon_c fg cb = {} \\<Longrightarrow>\n  ((s, ca + cb), e, sh, cah + cb) \\<in> ntrp fg\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), e, sh, cah + cb) \\<in> ntrp fg", "by auto"], ["proof (state)\nthis:\n  ((s, ca + cb), e, sh, cah + cb) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        w2 = map ENV wb \\<and>\n        ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union>\n         mon_ww fg (map le_rem_s (e # w1'))) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), e # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "also"], ["proof (state)\nthis:\n  ((s, ca + cb), e, sh, cah + cb) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        w2 = map ENV wb \\<and>\n        ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union>\n         mon_ww fg (map le_rem_s (e # w1'))) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), e # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "have \"((sh,cah+cb),w',(s',ca'+cb'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sh, cah + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)", "proof (rule I(3))"], ["proof (state)\ngoal (5 subgoals):\n 1. w2 = map ENV ?wb\n 2. ((sh, cah), w1', s', ca') \\<in> trcl (ntrp fg)\n 3. (cb, ?wb, cb') \\<in> trcl (ntr fg)\n 4. mon_c fg ({#sh#} + cah) \\<inter> (mon_c fg cb \\<union> mon_ww fg ?wb) =\n    {}\n 5. mon_c fg cb \\<inter>\n    (mon_c fg ({#sh#} + cah) \\<union> mon_ww fg (map le_rem_s w1')) =\n    {}", "from ntrp_mon_s[OF SPLIT(1)] I(2,4,7,8)"], ["proof (chain)\npicking this:\n  mon_c fg (add_mset sh cah) =\n  mon_c fg (add_mset s ca) \\<union> fst (\\<alpha>nl fg e)\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  w2 = map ENV wb\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}", "show 1: \"mon_c fg ({#sh#} + cah) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\""], ["proof (prove)\nusing this:\n  mon_c fg (add_mset sh cah) =\n  mon_c fg (add_mset s ca) \\<union> fst (\\<alpha>nl fg e)\n  fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {}\n  w2 = map ENV wb\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}\n\ngoal (1 subgoal):\n 1. mon_c fg ({#sh#} + cah) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n    {}", "by (cases e) (rename_tac a, case_tac a, simp add: cil_\\<alpha>n_cons_helper, fastforce simp add: cil_\\<alpha>n_cons_helper)+"], ["proof (state)\nthis:\n  mon_c fg ({#sh#} + cah) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n\ngoal (4 subgoals):\n 1. w2 = map ENV wb\n 2. ((sh, cah), w1', s', ca') \\<in> trcl (ntrp fg)\n 3. (cb, wb, cb') \\<in> trcl (ntr fg)\n 4. mon_c fg cb \\<inter>\n    (mon_c fg ({#sh#} + cah) \\<union> mon_ww fg (map le_rem_s w1')) =\n    {}", "(* FIXME: Ughly apply-script style proof *)"], ["proof (state)\nthis:\n  mon_c fg ({#sh#} + cah) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n\ngoal (4 subgoals):\n 1. w2 = map ENV wb\n 2. ((sh, cah), w1', s', ca') \\<in> trcl (ntrp fg)\n 3. (cb, wb, cb') \\<in> trcl (ntr fg)\n 4. mon_c fg cb \\<inter>\n    (mon_c fg ({#sh#} + cah) \\<union> mon_ww fg (map le_rem_s w1')) =\n    {}", "from I(8) 1"], ["proof (chain)\npicking this:\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}\n  mon_c fg ({#sh#} + cah) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}", "show \"mon_c fg cb \\<inter> (mon_c fg ({#sh#} + cah) \\<union> mon_ww fg (map le_rem_s w1')) = {}\""], ["proof (prove)\nusing this:\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n  {}\n  mon_c fg ({#sh#} + cah) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n\ngoal (1 subgoal):\n 1. mon_c fg cb \\<inter>\n    (mon_c fg ({#sh#} + cah) \\<union> mon_ww fg (map le_rem_s w1')) =\n    {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#sh#} + cah) \\<union> mon_ww fg (map le_rem_s w1')) =\n  {}\n\ngoal (3 subgoals):\n 1. w2 = map ENV wb\n 2. ((sh, cah), w1', s', ca') \\<in> trcl (ntrp fg)\n 3. (cb, wb, cb') \\<in> trcl (ntr fg)", "qed (auto simp add: I(4,6) SPLIT(2))"], ["proof (state)\nthis:\n  ((sh, cah + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1' \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2;\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w2) = {};\n        \\<forall>s ca cb wb.\n           w2 = map ENV wb \\<and>\n           ((s, ca), w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1')) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        w2 = map ENV wb \\<and>\n        ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union>\n         mon_ww fg (map le_rem_s (e # w1'))) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), e # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "finally"], ["proof (chain)\npicking this:\n  ((s, ca + cb), e # w', s', ca' + cb') \\<in> trcl (ntrp fg)", "show ?case"], ["proof (prove)\nusing this:\n  ((s, ca + cb), e # w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), e # w', s', ca' + cb') \\<in> trcl (ntrp fg)", "."], ["proof (state)\nthis:\n  ((s, ca + cb), e # w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s ca cb wb.\n     w2 = map ENV wb \\<and>\n     ((s, ca), e # w1', s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s (e # w1'))) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), e # w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            e # w2' = map ENV wb \\<and>\n                            ((s, ca), w1, s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s w1)) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            e # w2' = map ENV wb \\<and>\n                            ((s, ca), w1, s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s w1)) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)", "case (right ee w' w2' w1)"], ["proof (state)\nthis:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2'\n  fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\n  \\<forall>s ca cb wb.\n     w2' = map ENV wb \\<and>\n     ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>e w' w2' w1.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg e) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ca cb wb.\n                            e # w2' = map ENV wb \\<and>\n                            ((s, ca), w1, s', ca')\n                            \\<in> trcl (ntrp fg) \\<and>\n                            (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n                            mon_c fg ({#s#} + ca) \\<inter>\n                            (mon_c fg cb \\<union> mon_ww fg wb) =\n                            {} \\<and>\n                            mon_c fg cb \\<inter>\n                            (mon_c fg ({#s#} + ca) \\<union>\n                             mon_ww fg (map le_rem_s w1)) =\n                            {} \\<longrightarrow>\n                            ((s, ca + cb), e # w', s', ca' + cb')\n                            \\<in> trcl (ntrp fg)", "thus ?case"], ["proof (prove)\nusing this:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2'\n  fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\n  \\<forall>s ca cb wb.\n     w2' = map ENV wb \\<and>\n     ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<forall>s ca cb wb.\n       ee # w2' = map ENV wb \\<and>\n       ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n       (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n       mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n       {} \\<and>\n       mon_c fg cb \\<inter>\n       (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n       {} \\<longrightarrow>\n       ((s, ca + cb), ee # w', s', ca' + cb') \\<in> trcl (ntrp fg)", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n        {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        ee # w2' = map ENV wb \\<and>\n        ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), ee # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "case (1 s ca cb wb)"], ["proof (state)\nthis:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2'\n  fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\n  \\<forall>s ca cb wb.\n     w2' = map ENV wb \\<and>\n     ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n  ee # w2' = map ENV wb \\<and>\n  ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n  {} \\<and>\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n        {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        ee # w2' = map ENV wb \\<and>\n        ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), ee # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "hence I: \"w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2'\" \"fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\"\n          \"!!s ca cb wb. \\<lbrakk>\n            w2' = map ENV wb;\n            ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg);\n            (cb, wb, cb') \\<in> trcl (ntr fg);\n            mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {};\n            mon_c fg cb \\<inter> (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) = {}\n          \\<rbrakk> \\<Longrightarrow> ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\"\n          \"ee#w2' = map ENV wb\"\n          \"((s, ca), w1, s', ca') \\<in> trcl (ntrp fg)\"\n          \"(cb, wb, cb') \\<in> trcl (ntr fg)\"\n          \"mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\"\n          \"mon_c fg cb \\<inter> (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) = {}\""], ["proof (prove)\nusing this:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2'\n  fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\n  \\<forall>s ca cb wb.\n     w2' = map ENV wb \\<and>\n     ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n  ee # w2' = map ENV wb \\<and>\n  ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n  (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n  {} \\<and>\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n\ngoal (1 subgoal):\n 1. ((w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2' &&&\n      fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n      {}) &&&\n     (\\<And>s ca cb wb.\n         \\<lbrakk>w2' = map ENV wb;\n          ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg);\n          (cb, wb, cb') \\<in> trcl (ntr fg);\n          mon_c fg ({#s#} + ca) \\<inter>\n          (mon_c fg cb \\<union> mon_ww fg wb) =\n          {};\n          mon_c fg cb \\<inter>\n          (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n          {}\\<rbrakk>\n         \\<Longrightarrow> ((s, ca + cb), w', s', ca' + cb')\n                           \\<in> trcl (ntrp fg)) &&&\n     ee # w2' = map ENV wb) &&&\n    (((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) &&&\n     (cb, wb, cb') \\<in> trcl (ntr fg)) &&&\n    mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n    {} &&&\n    mon_c fg cb \\<inter>\n    (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n    {}", "by fastforce+"], ["proof (state)\nthis:\n  w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2'\n  fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\n  \\<lbrakk>w2' = map ENV ?wb; ((?s, ?ca), w1, s', ca') \\<in> trcl (ntrp fg);\n   (?cb, ?wb, cb') \\<in> trcl (ntr fg);\n   mon_c fg ({#?s#} + ?ca) \\<inter> (mon_c fg ?cb \\<union> mon_ww fg ?wb) =\n   {};\n   mon_c fg ?cb \\<inter>\n   (mon_c fg ({#?s#} + ?ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?ca + ?cb), w', s', ca' + cb')\n                    \\<in> trcl (ntrp fg)\n  ee # w2' = map ENV wb\n  ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n        {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        ee # w2' = map ENV wb \\<and>\n        ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), ee # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "from I(4)"], ["proof (chain)\npicking this:\n  ee # w2' = map ENV wb", "obtain e wb' where EE: \"wb=e#wb'\" \"ee=ENV e\" \"w2'=map ENV wb'\""], ["proof (prove)\nusing this:\n  ee # w2' = map ENV wb\n\ngoal (1 subgoal):\n 1. (\\<And>e wb'.\n        \\<lbrakk>wb = e # wb'; ee = ENV e; w2' = map ENV wb'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases wb, auto)"], ["proof (state)\nthis:\n  wb = e # wb'\n  ee = ENV e\n  w2' = map ENV wb'\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n        {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        ee # w2' = map ENV wb \\<and>\n        ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), ee # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "with I(6)"], ["proof (chain)\npicking this:\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  wb = e # wb'\n  ee = ENV e\n  w2' = map ENV wb'", "obtain cbh where SPLIT: \"(cb,e,cbh)\\<in>ntr fg\" \"(cbh,wb',cb')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  wb = e # wb'\n  ee = ENV e\n  w2' = map ENV wb'\n\ngoal (1 subgoal):\n 1. (\\<And>cbh.\n        \\<lbrakk>(cb, e, cbh) \\<in> ntr fg;\n         (cbh, wb', cb') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: trcl_uncons)"], ["proof (state)\nthis:\n  (cb, e, cbh) \\<in> ntr fg\n  (cbh, wb', cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n        {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        ee # w2' = map ENV wb \\<and>\n        ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), ee # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "have \"((s, ca + cb), ee, (s, ca + cbh)) \\<in> ntrp fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, ca + cb), ee, s, ca + cbh) \\<in> ntrp fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((s, ca + cb), ee, s, ca + cbh) \\<in> ntrp fg", "from gtrE[OF SPLIT(1)]"], ["proof (chain)\npicking this:\n  (\\<And>s ce s' ce'.\n      \\<lbrakk>cb = add_mset s ce; cbh = add_mset s' ce';\n       ((s, ce), e, s', ce') \\<in> ntrs fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain sb ceb sbh cebh where NTRS: \"cb = add_mset sb ceb\" \"cbh = add_mset sbh cebh\" \"((sb, ceb), e, sbh, cebh) \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  (\\<And>s ce s' ce'.\n      \\<lbrakk>cb = add_mset s ce; cbh = add_mset s' ce';\n       ((s, ce), e, s', ce') \\<in> ntrs fg\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>sb ceb sbh cebh.\n        \\<lbrakk>cb = add_mset sb ceb; cbh = add_mset sbh cebh;\n         ((sb, ceb), e, sbh, cebh) \\<in> ntrs fg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  cb = add_mset sb ceb\n  cbh = add_mset sbh cebh\n  ((sb, ceb), e, sbh, cebh) \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), ee, s, ca + cbh) \\<in> ntrp fg", "from ntrs_add_context_s[OF NTRS(3), of \"{#s#}+ca\"] EE(1) I(7)"], ["proof (chain)\npicking this:\n  mon_w fg e \\<inter> mon_c fg ({#s#} + ca) = {} \\<Longrightarrow>\n  ((sb, ceb + ({#s#} + ca)), e, sbh, cebh + ({#s#} + ca)) \\<in> ntrs fg\n  wb = e # wb'\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}", "have \"((sb, add_mset s (ca+ceb)), e, sbh, add_mset s (ca+cebh)) \\<in> ntrs fg\""], ["proof (prove)\nusing this:\n  mon_w fg e \\<inter> mon_c fg ({#s#} + ca) = {} \\<Longrightarrow>\n  ((sb, ceb + ({#s#} + ca)), e, sbh, cebh + ({#s#} + ca)) \\<in> ntrs fg\n  wb = e # wb'\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n\ngoal (1 subgoal):\n 1. ((sb, add_mset s (ca + ceb)), e, sbh, add_mset s (ca + cebh))\n    \\<in> ntrs fg", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  ((sb, add_mset s (ca + ceb)), e, sbh, add_mset s (ca + cebh))\n  \\<in> ntrs fg\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), ee, s, ca + cbh) \\<in> ntrp fg", "from gtrp_env[OF this] NTRS(1,2) EE(2)"], ["proof (chain)\npicking this:\n  ((s, add_mset sb (ca + ceb)), ENV e, s, add_mset sbh (ca + cebh))\n  \\<in> ntrp fg\n  cb = add_mset sb ceb\n  cbh = add_mset sbh cebh\n  ee = ENV e", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, add_mset sb (ca + ceb)), ENV e, s, add_mset sbh (ca + cebh))\n  \\<in> ntrp fg\n  cb = add_mset sb ceb\n  cbh = add_mset sbh cebh\n  ee = ENV e\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), ee, s, ca + cbh) \\<in> ntrp fg", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  ((s, ca + cb), ee, s, ca + cbh) \\<in> ntrp fg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((s, ca + cb), ee, s, ca + cbh) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n        {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        ee # w2' = map ENV wb \\<and>\n        ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), ee # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "also"], ["proof (state)\nthis:\n  ((s, ca + cb), ee, s, ca + cbh) \\<in> ntrp fg\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n        {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        ee # w2' = map ENV wb \\<and>\n        ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), ee # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "have \"((s,ca+cbh),w',(s',ca'+cb'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, ca + cbh), w', s', ca' + cb') \\<in> trcl (ntrp fg)", "proof (rule I(3))"], ["proof (state)\ngoal (5 subgoals):\n 1. w2' = map ENV ?wb\n 2. ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg)\n 3. (cbh, ?wb, cb') \\<in> trcl (ntr fg)\n 4. mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cbh \\<union> mon_ww fg ?wb) =\n    {}\n 5. mon_c fg cbh \\<inter>\n    (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n    {}", "from ntr_mon_s[OF SPLIT(1)] I(2,4,7,8) EE(2)"], ["proof (chain)\npicking this:\n  mon_c fg cbh = mon_c fg cb \\<union> fst (\\<alpha>n fg e)\n  fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\n  ee # w2' = map ENV wb\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n  ee = ENV e", "show 1: \"mon_c fg cbh \\<inter> (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) = {}\""], ["proof (prove)\nusing this:\n  mon_c fg cbh = mon_c fg cb \\<union> fst (\\<alpha>n fg e)\n  fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) = {}\n  ee # w2' = map ENV wb\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n  ee = ENV e\n\ngoal (1 subgoal):\n 1. mon_c fg cbh \\<inter>\n    (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n    {}", "by (cases e) (simp add: cil_\\<alpha>nl_cons_helper, fastforce simp add: cil_\\<alpha>nl_cons_helper)"], ["proof (state)\nthis:\n  mon_c fg cbh \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n\ngoal (4 subgoals):\n 1. w2' = map ENV ?wb\n 2. ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg)\n 3. (cbh, ?wb, cb') \\<in> trcl (ntr fg)\n 4. mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cbh \\<union> mon_ww fg ?wb) =\n    {}", "(* FIXME: Ughly apply-script style proof *)"], ["proof (state)\nthis:\n  mon_c fg cbh \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n\ngoal (4 subgoals):\n 1. w2' = map ENV ?wb\n 2. ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg)\n 3. (cbh, ?wb, cb') \\<in> trcl (ntr fg)\n 4. mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cbh \\<union> mon_ww fg ?wb) =\n    {}", "from I(7) 1 EE(1)"], ["proof (chain)\npicking this:\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cbh \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n  wb = e # wb'", "show \"mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cbh \\<union> mon_ww fg wb') = {}\""], ["proof (prove)\nusing this:\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cbh \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n  {}\n  wb = e # wb'\n\ngoal (1 subgoal):\n 1. mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cbh \\<union> mon_ww fg wb') =\n    {}", "by auto"], ["proof (state)\nthis:\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cbh \\<union> mon_ww fg wb') = {}\n\ngoal (3 subgoals):\n 1. w2' = map ENV wb'\n 2. ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg)\n 3. (cbh, wb', cb') \\<in> trcl (ntr fg)", "qed (auto simp add: EE(3) I(5) SPLIT(2))"], ["proof (state)\nthis:\n  ((s, ca + cbh), w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<And>s ca cb wb.\n       \\<lbrakk>w' \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> w2';\n        fst (\\<alpha>nl fg ee) \\<inter> mon_pl (map (\\<alpha>nl fg) w1) =\n        {};\n        \\<forall>s ca cb wb.\n           w2' = map ENV wb \\<and>\n           ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n           (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n           mon_c fg ({#s#} + ca) \\<inter>\n           (mon_c fg cb \\<union> mon_ww fg wb) =\n           {} \\<and>\n           mon_c fg cb \\<inter>\n           (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n           {} \\<longrightarrow>\n           ((s, ca + cb), w', s', ca' + cb') \\<in> trcl (ntrp fg);\n        ee # w2' = map ENV wb \\<and>\n        ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n        mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n        {} \\<and>\n        mon_c fg cb \\<inter>\n        (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> ((s, ca + cb), ee # w', s', ca' + cb')\n                         \\<in> trcl (ntrp fg)", "finally"], ["proof (chain)\npicking this:\n  ((s, ca + cb), ee # w', s', ca' + cb') \\<in> trcl (ntrp fg)", "show ?case"], ["proof (prove)\nusing this:\n  ((s, ca + cb), ee # w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), ee # w', s', ca' + cb') \\<in> trcl (ntrp fg)", "."], ["proof (state)\nthis:\n  ((s, ca + cb), ee # w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s ca cb wb.\n     ee # w2' = map ENV wb \\<and>\n     ((s, ca), w1, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s w1)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), ee # w', s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> wb' \\<Longrightarrow>\n  \\<forall>s ca cb wb.\n     wb' = map ENV wb \\<and>\n     ((s, ca), wa, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s wa)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "}"], ["proof (state)\nthis:\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> ?wb'2 \\<Longrightarrow>\n  \\<forall>s ca cb wb.\n     ?wb'2 = map ENV wb \\<and>\n     ((s, ca), wa, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s wa)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "with A B"], ["proof (chain)\npicking this:\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV wb\n  ((s, ca), wa, s', ca') \\<in> trcl (ntrp fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s wa)) =\n  {}\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> ?wb'2 \\<Longrightarrow>\n  \\<forall>s ca cb wb.\n     ?wb'2 = map ENV wb \\<and>\n     ((s, ca), wa, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s wa)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV wb\n  ((s, ca), wa, s', ca') \\<in> trcl (ntrp fg)\n  (cb, wb, cb') \\<in> trcl (ntr fg)\n  mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {}\n  mon_c fg cb \\<inter>\n  (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s wa)) =\n  {}\n  w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> ?wb'2 \\<Longrightarrow>\n  \\<forall>s ca cb wb.\n     ?wb'2 = map ENV wb \\<and>\n     ((s, ca), wa, s', ca') \\<in> trcl (ntrp fg) \\<and>\n     (cb, wb, cb') \\<in> trcl (ntr fg) \\<and>\n     mon_c fg ({#s#} + ca) \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) =\n     {} \\<and>\n     mon_c fg cb \\<inter>\n     (mon_c fg ({#s#} + ca) \\<union> mon_ww fg (map le_rem_s wa)) =\n     {} \\<longrightarrow>\n     ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)", "by blast"], ["proof (state)\nthis:\n  ((s, ca + cb), w, s', ca' + cb') \\<in> trcl (ntrp fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>And finally we get the desired theorem: {\\em Two paths are simultaneously executable if and only if they are consistently interleavable and the monitors of the initial configurations are compatible}.\nNote that we have to assume a valid starting configuration.\\<close>"], ["", "theorem (in flowgraph) ntr_interleave: \"valid fg (ca+cb) \\<Longrightarrow> \n  (ca+cb,w,c')\\<in>trcl (ntr fg) \\<longleftrightarrow> \n  (\\<exists>ca' cb' wa wb. \n    c'=ca'+cb' \\<and> \n    w\\<in>(wa\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wb) \\<and> \n    mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and> \n    mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and> \n    (ca,wa,ca')\\<in>trcl (ntr fg) \\<and> (cb,wb,cb')\\<in>trcl (ntr fg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg (ca + cb) \\<Longrightarrow>\n    ((ca + cb, w, c') \\<in> trcl (ntr fg)) =\n    (\\<exists>ca' cb' wa wb.\n        c' = ca' + cb' \\<and>\n        w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n        mon_c fg ca \\<inter> (mon_c fg cb \\<union> mon_ww fg wb) = {} \\<and>\n        mon_c fg cb \\<inter> (mon_c fg ca \\<union> mon_ww fg wa) = {} \\<and>\n        (ca, wa, ca') \\<in> trcl (ntr fg) \\<and>\n        (cb, wb, cb') \\<in> trcl (ntr fg))", "by (blast intro!: ntr_split ntr_unsplit)\n\n\\<comment> \\<open>Here is the corresponding version for executions with an explicit local thread\\<close>"], ["", "theorem (in flowgraph) ntrp_interleave: \n  \"valid fg ({#s#}+c1+c2) \\<Longrightarrow> \n  ((s,c1+c2),w,(s',c'))\\<in>trcl (ntrp fg) \\<longleftrightarrow> \n  (\\<exists>w1 w2 c1' c2'. \n    w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> (map ENV w2) \\<and> \n    c'=c1'+c2' \\<and> \n    ((s,c1),w1,(s',c1'))\\<in>trcl (ntrp fg) \\<and> \n    (c2,w2,c2')\\<in>trcl (ntr fg) \\<and> \n    mon_ww fg (map le_rem_s w1) \\<inter> \n    mon_c fg c2 = {} \\<and> \n    mon_ww fg w2 \\<inter> mon_c fg ({#s#}+c1) = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid fg ({#s#} + c1 + c2) \\<Longrightarrow>\n    (((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg)) =\n    (\\<exists>w1 w2 c1' c2'.\n        w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n        c' = c1' + c2' \\<and>\n        ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n        (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n        mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n        mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {})", "apply (intro iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid fg ({#s#} + c1 + c2);\n     ((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w1 w2 c1' c2'.\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl\n                fg\\<^esub> map ENV w2 \\<and>\n                         c' = c1' + c2' \\<and>\n                         ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n                         (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n                         mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 =\n                         {} \\<and>\n                         mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\n 2. \\<lbrakk>valid fg ({#s#} + c1 + c2);\n     \\<exists>w1 w2 c1' c2'.\n        w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n        c' = c1' + c2' \\<and>\n        ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n        (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n        mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n        mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\\<rbrakk>\n    \\<Longrightarrow> ((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg)", "apply (blast intro: ntrp_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid fg ({#s#} + c1 + c2);\n     \\<exists>w1 w2 c1' c2'.\n        w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>nl fg\\<^esub> map ENV w2 \\<and>\n        c' = c1' + c2' \\<and>\n        ((s, c1), w1, s', c1') \\<in> trcl (ntrp fg) \\<and>\n        (c2, w2, c2') \\<in> trcl (ntr fg) \\<and>\n        mon_ww fg (map le_rem_s w1) \\<inter> mon_c fg c2 = {} \\<and>\n        mon_ww fg w2 \\<inter> mon_c fg ({#s#} + c1) = {}\\<rbrakk>\n    \\<Longrightarrow> ((s, c1 + c2), w, s', c') \\<in> trcl (ntrp fg)", "apply (auto intro!: ntrp_unsplit simp add: valid_unconc\n      mon_c_unconc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The next is a corollary of @{thm [source] flowgraph.ntrp_unsplit}, allowing us to convert a path to loc/env semantics by adding a local stack that does not make any steps.\\<close>"], ["", "corollary (in flowgraph) ntr2ntrp: \"\\<lbrakk>\n    (c,w,c')\\<in>trcl (ntr fg); \n    mon_c fg (add_mset s cl) \\<inter> (mon_c fg c \\<union> mon_ww fg w)={}\n  \\<rbrakk> \\<Longrightarrow> ((s,cl+c),map ENV w,(s,cl+c'))\\<in>trcl (ntrp fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, w, c') \\<in> trcl (ntr fg);\n     mon_c fg (add_mset s cl) \\<inter> (mon_c fg c \\<union> mon_ww fg w) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ((s, cl + c), map ENV w, s, cl + c')\n                      \\<in> trcl (ntrp fg)", "using ntrp_unsplit[where wa=\"[]\", simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w = map ENV ?wb; ?s = ?s' \\<and> ?ca = ?ca';\n   (?cb, ?wb, ?cb') \\<in> trcl (ntr fg);\n   mon_c fg (add_mset ?s ?ca) \\<inter>\n   (mon_c fg ?cb \\<union> mon_ww fg ?wb) =\n   {};\n   mon_c fg ?cb \\<inter> mon_c fg (add_mset ?s ?ca) = {}\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?ca + ?cb), ?w, ?s', ?ca' + ?cb')\n                    \\<in> trcl (ntrp fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, w, c') \\<in> trcl (ntr fg);\n     mon_c fg (add_mset s cl) \\<inter> (mon_c fg c \\<union> mon_ww fg w) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ((s, cl + c), map ENV w, s, cl + c')\n                      \\<in> trcl (ntrp fg)", "by fast"], ["", "subsubsection \"Reverse splitting\""], ["", "text \\<open>This section establishes a theorem that allows us to find the thread in the original configuration that created some distinguished thread in the final configuration.\\<close>"], ["", "lemma (in flowgraph) ntr_reverse_split: \"!!w s' ce'. \\<lbrakk> \n  (c,w,{#s'#}+ce')\\<in>trcl (ntr fg); \n  valid fg c \\<rbrakk> \\<Longrightarrow> \n  \\<exists>s ce w1 w2 ce1' ce2'. \n    c={#s#}+ce \\<and> \n    ce'=ce1'+ce2' \\<and> \n    w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and> \n    mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and> \n    mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and> \n    ({#s#},w1,{#s'#}+ce1')\\<in>trcl (ntr fg) \\<and> \n    (ce,w2,ce2')\\<in>trcl (ntr fg)\" \n\\<comment> \\<open>The proof works by induction on the initial configuration. Note that configurations consist of finitely many threads only\\<close>\n\\<comment> \\<open>FIXME: An induction over the size (rather then over the adding of some fixed element) may lead to a smoother proof here\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w s' ce'.\n       \\<lbrakk>(c, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            c = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)", "proof (induct c rule: multiset_induct') \n  \\<comment> \\<open>If the initial configuration is empty, we immediately get a contradiction\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w s' ce'.\n       \\<lbrakk>({#}, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#} = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)\n 2. \\<And>M x w s' ce'.\n       \\<lbrakk>\\<And>w s' ce'.\n                   \\<lbrakk>(M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n                    valid fg M\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n  M = {#s#} + ce \\<and>\n  ce' = ce1' + ce2' \\<and>\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n  ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n  (ce, w2, ce2') \\<in> trcl (ntr fg);\n        ({#x#} + M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg ({#x#} + M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#x#} + M = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)", "case empty"], ["proof (state)\nthis:\n  ({#}, w, {#s'#} + ce') \\<in> trcl (ntr fg)\n  valid fg {#}\n\ngoal (2 subgoals):\n 1. \\<And>w s' ce'.\n       \\<lbrakk>({#}, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#} = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)\n 2. \\<And>M x w s' ce'.\n       \\<lbrakk>\\<And>w s' ce'.\n                   \\<lbrakk>(M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n                    valid fg M\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n  M = {#s#} + ce \\<and>\n  ce' = ce1' + ce2' \\<and>\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n  ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n  (ce, w2, ce2') \\<in> trcl (ntr fg);\n        ({#x#} + M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg ({#x#} + M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#x#} + M = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)", "hence False"], ["proof (prove)\nusing this:\n  ({#}, w, {#s'#} + ce') \\<in> trcl (ntr fg)\n  valid fg {#}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>w s' ce'.\n       \\<lbrakk>({#}, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#} = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)\n 2. \\<And>M x w s' ce'.\n       \\<lbrakk>\\<And>w s' ce'.\n                   \\<lbrakk>(M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n                    valid fg M\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n  M = {#s#} + ce \\<and>\n  ce' = ce1' + ce2' \\<and>\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n  ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n  (ce, w2, ce2') \\<in> trcl (ntr fg);\n        ({#x#} + M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg ({#x#} + M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#x#} + M = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>s ce w1 w2 ce1' ce2'.\n       {#} = {#s#} + ce \\<and>\n       ce' = ce1' + ce2' \\<and>\n       w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n       mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n       mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n       ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n       (ce, w2, ce2') \\<in> trcl (ntr fg)", ".."], ["proof (state)\nthis:\n  \\<exists>s ce w1 w2 ce1' ce2'.\n     {#} = {#s#} + ce \\<and>\n     ce' = ce1' + ce2' \\<and>\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n     mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n     ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n     (ce, w2, ce2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>M x w s' ce'.\n       \\<lbrakk>\\<And>w s' ce'.\n                   \\<lbrakk>(M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n                    valid fg M\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n  M = {#s#} + ce \\<and>\n  ce' = ce1' + ce2' \\<and>\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n  ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n  (ce, w2, ce2') \\<in> trcl (ntr fg);\n        ({#x#} + M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg ({#x#} + M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#x#} + M = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)", "next\n  \\<comment> \\<open>The initial configuration has the form @{text \"{#s#}+ce\"}.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M x w s' ce'.\n       \\<lbrakk>\\<And>w s' ce'.\n                   \\<lbrakk>(M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n                    valid fg M\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n  M = {#s#} + ce \\<and>\n  ce' = ce1' + ce2' \\<and>\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n  ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n  (ce, w2, ce2') \\<in> trcl (ntr fg);\n        ({#x#} + M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg ({#x#} + M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#x#} + M = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)", "case (add ce s)\n  \\<comment> \\<open>We split the path by this initial configuration\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>(ce, ?w, {#?s'#} + ?ce') \\<in> trcl (ntr fg);\n   valid fg ce\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s cea w1 w2 ce1' ce2'.\n                       ce = {#s#} + cea \\<and>\n                       ?ce' = ce1' + ce2' \\<and>\n                       ?w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n               fg\\<^esub> w2 \\<and>\n                       mon_s fg s \\<inter>\n                       (mon_c fg cea \\<union> mon_ww fg w2) =\n                       {} \\<and>\n                       mon_c fg cea \\<inter>\n                       (mon_s fg s \\<union> mon_ww fg w1) =\n                       {} \\<and>\n                       ({#s#}, w1, {#?s'#} + ce1')\n                       \\<in> trcl (ntr fg) \\<and>\n                       (cea, w2, ce2') \\<in> trcl (ntr fg)\n  ({#s#} + ce, w, {#s'#} + ce') \\<in> trcl (ntr fg)\n  valid fg ({#s#} + ce)\n\ngoal (1 subgoal):\n 1. \\<And>M x w s' ce'.\n       \\<lbrakk>\\<And>w s' ce'.\n                   \\<lbrakk>(M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n                    valid fg M\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n  M = {#s#} + ce \\<and>\n  ce' = ce1' + ce2' \\<and>\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n  ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n  (ce, w2, ce2') \\<in> trcl (ntr fg);\n        ({#x#} + M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg ({#x#} + M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#x#} + M = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)", "from ntr_split[OF add.prems(1,2)]"], ["proof (chain)\npicking this:\n  \\<exists>ca' cb' wa wb.\n     {#s'#} + ce' = ca' + cb' \\<and>\n     w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n     mon_c fg {#s#} \\<inter> (mon_c fg ce \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg ce \\<inter> (mon_c fg {#s#} \\<union> mon_ww fg wa) = {} \\<and>\n     ({#s#}, wa, ca') \\<in> trcl (ntr fg) \\<and>\n     (ce, wb, cb') \\<in> trcl (ntr fg)", "obtain ce1' ce2' w1 w2 where \n    SPLIT: \"add_mset s' ce'=ce1'+ce2'\" \"w\\<in>w1\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>w2\" \n    \"mon_c fg ce \\<inter> (mon_s fg s\\<union>mon_ww fg w1) = {}\" \n    \"mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}\" \n    \"({#s#},w1,ce1')\\<in>trcl (ntr fg)\" \n    \"(ce,w2,ce2')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<exists>ca' cb' wa wb.\n     {#s'#} + ce' = ca' + cb' \\<and>\n     w \\<in> wa \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wb \\<and>\n     mon_c fg {#s#} \\<inter> (mon_c fg ce \\<union> mon_ww fg wb) = {} \\<and>\n     mon_c fg ce \\<inter> (mon_c fg {#s#} \\<union> mon_ww fg wa) = {} \\<and>\n     ({#s#}, wa, ca') \\<in> trcl (ntr fg) \\<and>\n     (ce, wb, cb') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>ce1' ce2' w1 w2.\n        \\<lbrakk>add_mset s' ce' = ce1' + ce2';\n         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2;\n         mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {};\n         mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {};\n         ({#s#}, w1, ce1') \\<in> trcl (ntr fg);\n         (ce, w2, ce2') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto \n  \\<comment> \\<open>And then check whether splitting off @{term s} was the right choice\\<close>"], ["proof (state)\nthis:\n  add_mset s' ce' = ce1' + ce2'\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {}\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}\n  ({#s#}, w1, ce1') \\<in> trcl (ntr fg)\n  (ce, w2, ce2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<And>M x w s' ce'.\n       \\<lbrakk>\\<And>w s' ce'.\n                   \\<lbrakk>(M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n                    valid fg M\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n  M = {#s#} + ce \\<and>\n  ce' = ce1' + ce2' \\<and>\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {} \\<and>\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n  ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n  (ce, w2, ce2') \\<in> trcl (ntr fg);\n        ({#x#} + M, w, {#s'#} + ce') \\<in> trcl (ntr fg);\n        valid fg ({#x#} + M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s ce w1 w2 ce1' ce2'.\n                            {#x#} + M = {#s#} + ce \\<and>\n                            ce' = ce1' + ce2' \\<and>\n                            w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                   fg\\<^esub> w2 \\<and>\n                            mon_s fg s \\<inter>\n                            (mon_c fg ce \\<union> mon_ww fg w2) =\n                            {} \\<and>\n                            mon_c fg ce \\<inter>\n                            (mon_s fg s \\<union> mon_ww fg w1) =\n                            {} \\<and>\n                            ({#s#}, w1, {#s'#} + ce1')\n                            \\<in> trcl (ntr fg) \\<and>\n                            (ce, w2, ce2') \\<in> trcl (ntr fg)", "from SPLIT(1)"], ["proof (chain)\npicking this:\n  add_mset s' ce' = ce1' + ce2'", "show ?case"], ["proof (prove)\nusing this:\n  add_mset s' ce' = ce1' + ce2'\n\ngoal (1 subgoal):\n 1. \\<exists>sa cea w1 w2 ce1' ce2'.\n       {#s#} + ce = {#sa#} + cea \\<and>\n       ce' = ce1' + ce2' \\<and>\n       w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n       mon_s fg sa \\<inter> (mon_c fg cea \\<union> mon_ww fg w2) = {} \\<and>\n       mon_c fg cea \\<inter> (mon_s fg sa \\<union> mon_ww fg w1) = {} \\<and>\n       ({#sa#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n       (cea, w2, ce2') \\<in> trcl (ntr fg)", "proof (cases rule: mset_unplusm_dist_cases) \n    \\<comment> \\<open>Our choice was correct, @{term s'} is generated by some descendant of @{term s}\"\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ce1' = add_mset s' (ce1' - {#s'#});\n     ce' = ce1' - {#s'#} + ce2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "case left"], ["proof (state)\nthis:\n  ce1' = add_mset s' (ce1' - {#s'#})\n  ce' = ce1' - {#s'#} + ce2'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ce1' = add_mset s' (ce1' - {#s'#});\n     ce' = ce1' - {#s'#} + ce2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)\n 2. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "with SPLIT"], ["proof (chain)\npicking this:\n  add_mset s' ce' = ce1' + ce2'\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {}\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}\n  ({#s#}, w1, ce1') \\<in> trcl (ntr fg)\n  (ce, w2, ce2') \\<in> trcl (ntr fg)\n  ce1' = add_mset s' (ce1' - {#s'#})\n  ce' = ce1' - {#s'#} + ce2'", "show ?thesis"], ["proof (prove)\nusing this:\n  add_mset s' ce' = ce1' + ce2'\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {}\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}\n  ({#s#}, w1, ce1') \\<in> trcl (ntr fg)\n  (ce, w2, ce2') \\<in> trcl (ntr fg)\n  ce1' = add_mset s' (ce1' - {#s'#})\n  ce' = ce1' - {#s'#} + ce2'\n\ngoal (1 subgoal):\n 1. \\<exists>sa cea w1 w2 ce1' ce2'.\n       {#s#} + ce = {#sa#} + cea \\<and>\n       ce' = ce1' + ce2' \\<and>\n       w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n       mon_s fg sa \\<inter> (mon_c fg cea \\<union> mon_ww fg w2) = {} \\<and>\n       mon_c fg cea \\<inter> (mon_s fg sa \\<union> mon_ww fg w1) = {} \\<and>\n       ({#sa#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n       (cea, w2, ce2') \\<in> trcl (ntr fg)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>sa cea w1 w2 ce1' ce2'.\n     {#s#} + ce = {#sa#} + cea \\<and>\n     ce' = ce1' + ce2' \\<and>\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n     mon_s fg sa \\<inter> (mon_c fg cea \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg cea \\<inter> (mon_s fg sa \\<union> mon_ww fg w1) = {} \\<and>\n     ({#sa#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n     (cea, w2, ce2') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "next\n    \\<comment> \\<open>Our choice was not correct, @{term s'} is generated by some descendant of @{term ce}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "case right"], ["proof (state)\nthis:\n  ce2' = add_mset s' (ce2' - {#s'#})\n  ce' = ce1' + (ce2' - {#s'#})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "with SPLIT(6)"], ["proof (chain)\npicking this:\n  (ce, w2, ce2') \\<in> trcl (ntr fg)\n  ce2' = add_mset s' (ce2' - {#s'#})\n  ce' = ce1' + (ce2' - {#s'#})", "have C: \"(ce,w2,{#s'#}+(ce2'-{#s'#}))\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  (ce, w2, ce2') \\<in> trcl (ntr fg)\n  ce2' = add_mset s' (ce2' - {#s'#})\n  ce' = ce1' + (ce2' - {#s'#})\n\ngoal (1 subgoal):\n 1. (ce, w2, {#s'#} + (ce2' - {#s'#})) \\<in> trcl (ntr fg)", "by auto \n    \\<comment> \\<open>In this case we apply the induction hypothesis to the path from @{term ce}\\<close>"], ["proof (state)\nthis:\n  (ce, w2, {#s'#} + (ce2' - {#s'#})) \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "from add.prems(2)"], ["proof (chain)\npicking this:\n  valid fg ({#s#} + ce)", "have VALID: \"valid fg ce\" \"mon_s fg s \\<inter> mon_c fg ce = {}\""], ["proof (prove)\nusing this:\n  valid fg ({#s#} + ce)\n\ngoal (1 subgoal):\n 1. valid fg ce &&& mon_s fg s \\<inter> mon_c fg ce = {}", "by (simp_all add: valid_unconc)"], ["proof (state)\nthis:\n  valid fg ce\n  mon_s fg s \\<inter> mon_c fg ce = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "from add.hyps[OF C VALID(1)]"], ["proof (chain)\npicking this:\n  \\<exists>s cea w1 w2a ce1' ce2'a.\n     ce = {#s#} + cea \\<and>\n     ce2' - {#s'#} = ce1' + ce2'a \\<and>\n     w2 \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2a \\<and>\n     mon_s fg s \\<inter> (mon_c fg cea \\<union> mon_ww fg w2a) = {} \\<and>\n     mon_c fg cea \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n     ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n     (cea, w2a, ce2'a) \\<in> trcl (ntr fg)", "obtain st cet w21 w22 ce21' ce22' where \n      IHAPP: \n      \"ce={#st#}+cet\" \n      \"ce2'-{#s'#} = ce21'+ce22'\" \n      \"w2\\<in>w21\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>w22\" \n      \"mon_s fg st \\<inter> (mon_c fg cet \\<union> mon_ww fg w22)={}\" \n      \"mon_c fg cet \\<inter> (mon_s fg st \\<union> mon_ww fg w21)={}\" \n      \"({#st#},w21,{#s'#}+ce21')\\<in>trcl (ntr fg)\" \n      \"(cet,w22,ce22')\\<in>trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  \\<exists>s cea w1 w2a ce1' ce2'a.\n     ce = {#s#} + cea \\<and>\n     ce2' - {#s'#} = ce1' + ce2'a \\<and>\n     w2 \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2a \\<and>\n     mon_s fg s \\<inter> (mon_c fg cea \\<union> mon_ww fg w2a) = {} \\<and>\n     mon_c fg cea \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {} \\<and>\n     ({#s#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n     (cea, w2a, ce2'a) \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (\\<And>st cet ce21' ce22' w21 w22.\n        \\<lbrakk>ce = {#st#} + cet; ce2' - {#s'#} = ce21' + ce22';\n         w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22;\n         mon_s fg st \\<inter> (mon_c fg cet \\<union> mon_ww fg w22) = {};\n         mon_c fg cet \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {};\n         ({#st#}, w21, {#s'#} + ce21') \\<in> trcl (ntr fg);\n         (cet, w22, ce22') \\<in> trcl (ntr fg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast \n    \n    \\<comment> \\<open>And finally we add the path from @{term s} again. This requires some monitor sorting and the associativity of the consistent interleaving operator.\\<close>"], ["proof (state)\nthis:\n  ce = {#st#} + cet\n  ce2' - {#s'#} = ce21' + ce22'\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg st \\<inter> (mon_c fg cet \\<union> mon_ww fg w22) = {}\n  mon_c fg cet \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n  ({#st#}, w21, {#s'#} + ce21') \\<in> trcl (ntr fg)\n  (cet, w22, ce22') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "from cil_assoc2 [of w w1 _ w2 w22 w21] SPLIT(2) IHAPP(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>w \\<in> w1 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> w2;\n   w2 \\<in> w22 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> w21\\<rbrakk>\n  \\<Longrightarrow> \\<exists>wl.\n                       w \\<in> wl \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> w21 \\<and>\n                       wl \\<in> w1 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> w22\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22", "obtain wl where CASSOC: \"w\\<in>w21\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>wl\" \"wl\\<in>w1\\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub>w22\""], ["proof (prove)\nusing this:\n  \\<lbrakk>w \\<in> w1 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> w2;\n   w2 \\<in> w22 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> w21\\<rbrakk>\n  \\<Longrightarrow> \\<exists>wl.\n                       w \\<in> wl \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> w21 \\<and>\n                       wl \\<in> w1 \\<otimes>\\<^bsub>?\\<alpha>\\<^esub> w22\n  w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n\ngoal (1 subgoal):\n 1. (\\<And>wl.\n        \\<lbrakk>w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl;\n         wl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: cil_commute)"], ["proof (state)\nthis:\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl\n  wl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "from CASSOC IHAPP(1,3,4,5) SPLIT(3,4)"], ["proof (chain)\npicking this:\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl\n  wl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  ce = {#st#} + cet\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg st \\<inter> (mon_c fg cet \\<union> mon_ww fg w22) = {}\n  mon_c fg cet \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {}\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}", "have COMBINE: \"(add_mset s cet, wl, ce1' + ce22') \\<in> trcl (ntr fg)\""], ["proof (prove)\nusing this:\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl\n  wl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  ce = {#st#} + cet\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg st \\<inter> (mon_c fg cet \\<union> mon_ww fg w22) = {}\n  mon_c fg cet \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {}\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}\n\ngoal (1 subgoal):\n 1. (add_mset s cet, wl, ce1' + ce22') \\<in> trcl (ntr fg)", "using ntr_unsplit[OF CASSOC(2) SPLIT(5) IHAPP(7)]"], ["proof (prove)\nusing this:\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl\n  wl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  ce = {#st#} + cet\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg st \\<inter> (mon_c fg cet \\<union> mon_ww fg w22) = {}\n  mon_c fg cet \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {}\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}\n  \\<lbrakk>mon_c fg {#s#} \\<inter> (mon_c fg cet \\<union> mon_ww fg w22) =\n           {};\n   mon_c fg cet \\<inter> (mon_c fg {#s#} \\<union> mon_ww fg w1) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> ({#s#} + cet, wl, ce1' + ce22') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. (add_mset s cet, wl, ce1' + ce22') \\<in> trcl (ntr fg)", "by (auto simp add: mon_c_unconc mon_ww_cil Int_Un_distrib2)"], ["proof (state)\nthis:\n  (add_mset s cet, wl, ce1' + ce22') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "moreover"], ["proof (state)\nthis:\n  (add_mset s cet, wl, ce1' + ce22') \\<in> trcl (ntr fg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "from CASSOC IHAPP(1,3,4,5) SPLIT(3,4)"], ["proof (chain)\npicking this:\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl\n  wl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  ce = {#st#} + cet\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg st \\<inter> (mon_c fg cet \\<union> mon_ww fg w22) = {}\n  mon_c fg cet \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {}\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}", "have \"mon_s fg st \\<inter> (mon_c fg ({#s#}+cet) \\<union> mon_ww fg wl) = {}\" \"mon_c fg ({#s#}+cet) \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\""], ["proof (prove)\nusing this:\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl\n  wl \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  ce = {#st#} + cet\n  w2 \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w22\n  mon_s fg st \\<inter> (mon_c fg cet \\<union> mon_ww fg w22) = {}\n  mon_c fg cet \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n  mon_c fg ce \\<inter> (mon_s fg s \\<union> mon_ww fg w1) = {}\n  mon_s fg s \\<inter> (mon_c fg ce \\<union> mon_ww fg w2) = {}\n\ngoal (1 subgoal):\n 1. mon_s fg st \\<inter> (mon_c fg ({#s#} + cet) \\<union> mon_ww fg wl) =\n    {} &&&\n    mon_c fg ({#s#} + cet) \\<inter> (mon_s fg st \\<union> mon_ww fg w21) =\n    {}", "by (auto simp add: mon_c_unconc mon_ww_cil)"], ["proof (state)\nthis:\n  mon_s fg st \\<inter> (mon_c fg ({#s#} + cet) \\<union> mon_ww fg wl) = {}\n  mon_c fg ({#s#} + cet) \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "moreover"], ["proof (state)\nthis:\n  mon_s fg st \\<inter> (mon_c fg ({#s#} + cet) \\<union> mon_ww fg wl) = {}\n  mon_c fg ({#s#} + cet) \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "from right IHAPP(1,2)"], ["proof (chain)\npicking this:\n  ce2' = add_mset s' (ce2' - {#s'#})\n  ce' = ce1' + (ce2' - {#s'#})\n  ce = {#st#} + cet\n  ce2' - {#s'#} = ce21' + ce22'", "have \"{#s#}+ce={#st#}+({#s#}+cet)\" \"ce'=ce21'+(ce1'+ce22')\""], ["proof (prove)\nusing this:\n  ce2' = add_mset s' (ce2' - {#s'#})\n  ce' = ce1' + (ce2' - {#s'#})\n  ce = {#st#} + cet\n  ce2' - {#s'#} = ce21' + ce22'\n\ngoal (1 subgoal):\n 1. {#s#} + ce = {#st#} + ({#s#} + cet) &&& ce' = ce21' + (ce1' + ce22')", "by (simp_all add: union_ac)"], ["proof (state)\nthis:\n  {#s#} + ce = {#st#} + ({#s#} + cet)\n  ce' = ce21' + (ce1' + ce22')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "moreover"], ["proof (state)\nthis:\n  {#s#} + ce = {#st#} + ({#s#} + cet)\n  ce' = ce21' + (ce1' + ce22')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "note IHAPP(6) CASSOC(1)"], ["proof (state)\nthis:\n  ({#st#}, w21, {#s'#} + ce21') \\<in> trcl (ntr fg)\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ce2' = add_mset s' (ce2' - {#s'#});\n     ce' = ce1' + (ce2' - {#s'#})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa cea w1 w2 ce1' ce2'.\n                         {#s#} + ce = {#sa#} + cea \\<and>\n                         ce' = ce1' + ce2' \\<and>\n                         w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n\n                fg\\<^esub> w2 \\<and>\n                         mon_s fg sa \\<inter>\n                         (mon_c fg cea \\<union> mon_ww fg w2) =\n                         {} \\<and>\n                         mon_c fg cea \\<inter>\n                         (mon_s fg sa \\<union> mon_ww fg w1) =\n                         {} \\<and>\n                         ({#sa#}, w1, {#s'#} + ce1')\n                         \\<in> trcl (ntr fg) \\<and>\n                         (cea, w2, ce2') \\<in> trcl (ntr fg)", "ultimately"], ["proof (chain)\npicking this:\n  (add_mset s cet, wl, ce1' + ce22') \\<in> trcl (ntr fg)\n  mon_s fg st \\<inter> (mon_c fg ({#s#} + cet) \\<union> mon_ww fg wl) = {}\n  mon_c fg ({#s#} + cet) \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n  {#s#} + ce = {#st#} + ({#s#} + cet)\n  ce' = ce21' + (ce1' + ce22')\n  ({#st#}, w21, {#s'#} + ce21') \\<in> trcl (ntr fg)\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl", "show ?thesis"], ["proof (prove)\nusing this:\n  (add_mset s cet, wl, ce1' + ce22') \\<in> trcl (ntr fg)\n  mon_s fg st \\<inter> (mon_c fg ({#s#} + cet) \\<union> mon_ww fg wl) = {}\n  mon_c fg ({#s#} + cet) \\<inter> (mon_s fg st \\<union> mon_ww fg w21) = {}\n  {#s#} + ce = {#st#} + ({#s#} + cet)\n  ce' = ce21' + (ce1' + ce22')\n  ({#st#}, w21, {#s'#} + ce21') \\<in> trcl (ntr fg)\n  w \\<in> w21 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> wl\n\ngoal (1 subgoal):\n 1. \\<exists>sa cea w1 w2 ce1' ce2'.\n       {#s#} + ce = {#sa#} + cea \\<and>\n       ce' = ce1' + ce2' \\<and>\n       w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n       mon_s fg sa \\<inter> (mon_c fg cea \\<union> mon_ww fg w2) = {} \\<and>\n       mon_c fg cea \\<inter> (mon_s fg sa \\<union> mon_ww fg w1) = {} \\<and>\n       ({#sa#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n       (cea, w2, ce2') \\<in> trcl (ntr fg)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>sa cea w1 w2 ce1' ce2'.\n     {#s#} + ce = {#sa#} + cea \\<and>\n     ce' = ce1' + ce2' \\<and>\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n     mon_s fg sa \\<inter> (mon_c fg cea \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg cea \\<inter> (mon_s fg sa \\<union> mon_ww fg w1) = {} \\<and>\n     ({#sa#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n     (cea, w2, ce2') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>sa cea w1 w2 ce1' ce2'.\n     {#s#} + ce = {#sa#} + cea \\<and>\n     ce' = ce1' + ce2' \\<and>\n     w \\<in> w1 \\<otimes>\\<^bsub>\\<alpha>n fg\\<^esub> w2 \\<and>\n     mon_s fg sa \\<inter> (mon_c fg cea \\<union> mon_ww fg w2) = {} \\<and>\n     mon_c fg cea \\<inter> (mon_s fg sa \\<union> mon_ww fg w1) = {} \\<and>\n     ({#sa#}, w1, {#s'#} + ce1') \\<in> trcl (ntr fg) \\<and>\n     (cea, w2, ce2') \\<in> trcl (ntr fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}