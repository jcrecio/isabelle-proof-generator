{"file_name": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis/Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Program-Conflict-Analysis", "problem_names": ["lemma (in AC) left_commute[simp]: \"f x (f y z) = f y (f x z)\"", "lemma (in su_rel_fun) repr1: \"(A,f A)\\<in>F\"", "lemma (in su_rel_fun) repr2: \"(A,B)\\<in>F \\<Longrightarrow> B=f A\"", "lemma (in su_rel_fun) repr: \"(f A = B) = ((A,B)\\<in>F)\"", "lemma multiset_induct'[case_names empty add]: \"\\<lbrakk>P {#}; \\<And>M x. P M \\<Longrightarrow> P ({#x#}+M)\\<rbrakk> \\<Longrightarrow> P M\"", "lemma count_ne_remove: \"\\<lbrakk> x ~= t\\<rbrakk> \\<Longrightarrow> count S x = count (S-{#t#}) x\"", "lemma mset_empty_count[simp]: \"(\\<forall>p. count M p = 0) = (M={#})\"", "lemma size_diff_se: \"\\<lbrakk>t \\<in># S\\<rbrakk> \\<Longrightarrow> size S = size (S - {#t#}) + 1\"", "lemma mset_union_diff_comm: \"t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = (T + S) - {#t#}\"", "lemma mset_right_cancel_union: \"\\<lbrakk>a \\<in># A+B; ~(a \\<in># B)\\<rbrakk> \\<Longrightarrow> a\\<in>#A\"", "lemma mset_left_cancel_union: \"\\<lbrakk>a \\<in># A+B; ~(a \\<in># A)\\<rbrakk> \\<Longrightarrow> a\\<in>#B\"", "lemmas mset_cancel_union = mset_right_cancel_union mset_left_cancel_union", "lemma mset_right_cancel_elem: \"\\<lbrakk>a \\<in># A+{#b#}; a~=b\\<rbrakk> \\<Longrightarrow> a\\<in>#A\"", "lemma mset_left_cancel_elem: \"\\<lbrakk>a \\<in># {#b#}+A; a~=b\\<rbrakk> \\<Longrightarrow> a\\<in>#A\"", "lemmas mset_cancel_elem = mset_right_cancel_elem mset_left_cancel_elem", "lemma mset_diff_cancel1elem[simp]: \"~(a \\<in># B) \\<Longrightarrow> {#a#}-B = {#a#}\"", "lemma union_diff_assoc: \"C-B={#} \\<Longrightarrow> (A+B)-C = A + (B-C)\"", "lemma mset_union_2_elem: \"{#a#}+{#b#} = M + {#c#} \\<Longrightarrow> {#a#}=M & b=c | a=c & {#b#}=M\"", "lemma mset_un_cases[cases set, case_names left right]:\n    \"\\<lbrakk>a \\<in># A + B; a\\<in>#A \\<Longrightarrow> P; a\\<in>#B \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma mset_unplusm_dist_cases[cases set, case_names left right]:\n    assumes A: \"add_mset s A = B+C\"\n    assumes L: \"\\<lbrakk>B=add_mset s (B-{#s#}); A=(B-{#s#})+C\\<rbrakk> \\<Longrightarrow> P\"\n    assumes R: \"\\<lbrakk>C=add_mset s (C-{#s#}); A=B+(C-{#s#})\\<rbrakk> \\<Longrightarrow> P\" \n    shows P", "lemma mset_unplusm_dist_cases2[cases set, case_names left right]:\n    assumes A: \"B+C = add_mset s A\"\n    assumes L: \"\\<lbrakk>B=add_mset s (B-{#s#}); A=(B-{#s#})+C\\<rbrakk> \\<Longrightarrow> P\"\n    assumes R: \"\\<lbrakk>C=add_mset s (C-{#s#}); A=B+(C-{#s#})\\<rbrakk> \\<Longrightarrow> P\" \n    shows P", "lemma mset_single_cases[cases set, case_names loc env]: \n    assumes A: \"add_mset s c = add_mset r' c'\" \n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>c'={#s#}+(c'-{#s#}); c={#r'#}+(c-{#r'#}); c-{#r'#} = c'-{#s#} \\<rbrakk> \\<Longrightarrow> P\" \n    shows \"P\"", "lemma mset_single_cases'[cases set, case_names loc env]: \n    assumes A: \"add_mset s c = add_mset r' c'\" \n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"!!cc. \\<lbrakk>c'={#s#}+cc; c={#r'#}+cc; c'-{#s#}=cc; c-{#r'#}=cc\\<rbrakk> \\<Longrightarrow> P\" \n    shows \"P\"", "lemma mset_single_cases2[cases set, case_names loc env]: \n    assumes A: \"add_mset s c = add_mset r' c'\" \n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>c'=(c'-{#s#})+{#s#}; c=(c-{#r'#})+{#r'#}; c-{#r'#} = c'-{#s#} \\<rbrakk> \\<Longrightarrow> P\" \n    shows \"P\"", "lemma mset_single_cases2'[cases set, case_names loc env]: \n    assumes A: \"add_mset s c = add_mset r' c'\" \n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"!!cc. \\<lbrakk>c'=cc+{#s#}; c=cc+{#r'#}; c'-{#s#}=cc; c-{#r'#}=cc\\<rbrakk> \\<Longrightarrow> P\" \n    shows \"P\"", "lemma mset_un_single_un_cases [consumes 1, case_names left right]:\n    assumes A: \"add_mset a A = B + C\"\n      and CASES: \"a \\<in># B \\<Longrightarrow> A = (B - {#a#}) + C \\<Longrightarrow> P\"\n        \"a \\<in># C \\<Longrightarrow> A = B + (C - {#a#}) \\<Longrightarrow> P\"\n    shows P", "lemma mset_distrib[consumes 1, case_names dist]: assumes A: \"(A::'a multiset)+B = M+N\" \"!!Am An Bm Bn. \\<lbrakk>A=Am+An; B=Bm+Bn; M=Am+Bm; N=An+Bn\\<rbrakk> \\<Longrightarrow> P\" shows \"P\"", "lemma mset_size_le1_cases[case_names empty singleton,consumes 1]: \"\\<lbrakk> size M \\<le> Suc 0; M={#} \\<Longrightarrow> P; !!m. M={#m#} \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma diff_union_single_conv2:\n  \"a \\<in># J \\<Longrightarrow> J + I - {#a#} = (J - {#a#}) + I\"", "lemmas diff_union_single_convs = diff_union_single_conv diff_union_single_conv2", "lemma mset_contains_eq: \"(m \\<in># M) = ({#m#}+(M-{#m#})=M)\"", "lemma mset_le_incr_right1: \"(a::'a multiset)\\<subseteq>#b \\<Longrightarrow> a\\<subseteq>#b+c\"", "lemma mset_le_incr_right2: \"(a::'a multiset)\\<subseteq>#b \\<Longrightarrow> a\\<subseteq>#c+b\"", "lemmas mset_le_incr_right = mset_le_incr_right1 mset_le_incr_right2", "lemma mset_le_decr_left1: \"(a::'a multiset)+c\\<subseteq>#b \\<Longrightarrow> a\\<subseteq>#b\"", "lemma mset_le_decr_left2: \"c+(a::'a multiset)\\<subseteq>#b \\<Longrightarrow> a\\<subseteq>#b\"", "lemma mset_le_add_mset_decr_left1: \"add_mset c a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b\"", "lemma mset_le_add_mset_decr_left2: \"add_mset c a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> {#c#}\\<subseteq>#b\"", "lemmas mset_le_decr_left = mset_le_decr_left1 mset_le_decr_left2 mset_le_add_mset_decr_left1\n    mset_le_add_mset_decr_left2", "lemma mset_le_subtract: \"(A::'a multiset)\\<subseteq>#B \\<Longrightarrow> A-C \\<subseteq># B-C\"", "lemma mset_union_subset: \"(A::'a multiset)+B \\<subseteq># C \\<Longrightarrow> A\\<subseteq>#C \\<and> B\\<subseteq>#C\"", "lemma mset_le_add_mset: \"add_mset x B \\<subseteq># C \\<Longrightarrow> {#x#}\\<subseteq>#C \\<and> B\\<subseteq>#(C::'a multiset)\"", "lemma mset_le_subtract_left: \"(A::'a multiset)+B \\<subseteq># X \\<Longrightarrow> B \\<subseteq># X-A \\<and> A\\<subseteq>#X\"", "lemma mset_le_subtract_right: \"(A::'a multiset)+B \\<subseteq># X \\<Longrightarrow> A \\<subseteq># X-B \\<and> B\\<subseteq>#X\"", "lemma mset_le_subtract_add_mset_left: \"add_mset x B \\<subseteq># (X::'a multiset) \\<Longrightarrow> B \\<subseteq># X-{#x#} \\<and> {#x#}\\<subseteq>#X\"", "lemma mset_le_subtract_add_mset_right: \"add_mset x B \\<subseteq># (X::'a multiset) \\<Longrightarrow> {#x#} \\<subseteq># X-B \\<and> B\\<subseteq>#X\"", "lemma mset_le_addE: \"\\<lbrakk> (xs::'a multiset) \\<subseteq># ys; !!zs. ys=xs+zs \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma mset_2dist2_cases:\n    assumes A: \"{#a, b#} \\<subseteq># A + B\"\n    assumes CASES: \"{#a, b#} \\<subseteq># A \\<Longrightarrow> P\" \"{#a, b#} \\<subseteq># B \\<Longrightarrow> P\"\n      \"a \\<in># A \\<Longrightarrow> b \\<in># B \\<Longrightarrow> P\" \"a \\<in># B \\<Longrightarrow> b \\<in># A \\<Longrightarrow> P\"\n    shows \"P\"", "lemma mset_union_subset_s: \"{#a#}+B \\<subseteq># C \\<Longrightarrow> a \\<in># C \\<and> B \\<subseteq># C\"", "lemma mset_le_single_cases[consumes 1, case_names empty singleton]: \"\\<lbrakk>M\\<subseteq>#{#a#}; M={#} \\<Longrightarrow> P; M={#a#} \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma mset_le_distrib[consumes 1, case_names dist]: \"\\<lbrakk>X\\<subseteq>#(A::'a multiset)+B; !!Xa Xb. \\<lbrakk>X=Xa+Xb; Xa\\<subseteq>#A; Xb\\<subseteq>#B\\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma mset_le_mono_add_single: \"\\<lbrakk>a \\<in># ys; b \\<in># ws\\<rbrakk> \\<Longrightarrow> {#a, b#} \\<subseteq># ys + ws\"", "lemma mset_size1elem: \"\\<lbrakk>size P \\<le> 1; q \\<in># P\\<rbrakk> \\<Longrightarrow> P={#q#}\"", "lemma mset_size2elem: \"\\<lbrakk>size P \\<le> 2; {#q#}+{#q'#} \\<subseteq># P\\<rbrakk> \\<Longrightarrow> P={#q#}+{#q'#}\"", "lemma mset_map_single_rightE[consumes 1, case_names orig]: \"\\<lbrakk>f `# P = {#y#}; !!x. \\<lbrakk> P={#x#}; f x = y \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"", "lemma mset_map_split_orig: \"!!M1 M2. \\<lbrakk>f `# P = M1+M2; !!P1 P2. \\<lbrakk>P=P1+P2; f `# P1 = M1; f `# P2 = M2\\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"", "lemma mset_map_id: \"\\<lbrakk>!!x. f (g x) = x\\<rbrakk> \\<Longrightarrow> f `# g `# X = X\"", "lemma mset_map_split_orig_le: assumes A: \"f `# P \\<subseteq># M1+M2\" and EX: \"!!P1 P2. \\<lbrakk>P=P1+P2; f `# P1 \\<subseteq># M1; f `# P2 \\<subseteq># M2\\<rbrakk> \\<Longrightarrow> Q\" shows \"Q\"", "lemma list_rev_decomp[rule_format]: \"l~=[] \\<longrightarrow> (EX ll e . l = ll@[e])\"", "lemma length_compl_rev_induct[case_names Nil snoc]: \"\\<lbrakk>P []; !! l e . \\<lbrakk>!! ll . length ll <= length l \\<Longrightarrow> P ll\\<rbrakk> \\<Longrightarrow> P (l@[e])\\<rbrakk> \\<Longrightarrow> P l\"", "lemma list_append_eq_Cons_cases: \"\\<lbrakk>ys@zs = x#xs; \\<lbrakk>ys=[]; zs=x#xs\\<rbrakk> \\<Longrightarrow> P; !!ys'. \\<lbrakk> ys=x#ys'; ys'@zs=xs \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma list_Cons_eq_append_cases: \"\\<lbrakk>x#xs = ys@zs; \\<lbrakk>ys=[]; zs=x#xs\\<rbrakk> \\<Longrightarrow> P; !!ys'. \\<lbrakk> ys=x#ys'; ys'@zs=xs \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma foldl_A1_eq: \"!!i. \\<lbrakk> !! e. f n e = e; !! e. f e n = e; !!a b c. f a (f b c) = f (f a b) c \\<rbrakk> \\<Longrightarrow> foldl f i ww = f i (foldl f n ww)\"", "lemmas foldl_conc_empty_eq = foldl_A1_eq[of \"(@)\" \"[]\", simplified]", "lemmas foldl_un_empty_eq = foldl_A1_eq[of \"(\\<union>)\" \"{}\", simplified, OF Un_assoc[symmetric]]", "lemma foldl_set: \"foldl (\\<union>) {} l = \\<Union>{x. x\\<in>set l}\"", "lemma length_compl_induct[case_names Nil Cons]: \"\\<lbrakk>P []; !! e l . \\<lbrakk>!! ll . length ll <= length l \\<Longrightarrow> P ll\\<rbrakk> \\<Longrightarrow> P (e#l)\\<rbrakk> \\<Longrightarrow> P l\"", "lemma list_2pre_induct[case_names base left right]: assumes BASE: \"P [] []\" and LEFT: \"!!e w1' w2. P w1' w2 \\<Longrightarrow> P (e#w1') w2\" and RIGHT: \"!!e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e#w2')\" shows \"P w1 w2\"", "lemma list_decomp_1: \"length l=1 \\<Longrightarrow> EX a . l=[a]\"", "lemma list_decomp_2: \"length l=2 \\<Longrightarrow> EX a b . l=[a,b]\"", "lemma drop_all_conc: \"drop (length a) (a@b) = b\"", "lemma list_rest_coinc: \"\\<lbrakk>length s2 <= length s1; s1@r1 = s2@r2\\<rbrakk> \\<Longrightarrow> EX r1p . r2=r1p@r1\"", "lemma list_tail_coinc: \"n1#r1 = n2#r2 \\<Longrightarrow> n1=n2 & r1=r2\"", "lemma last_in_set[intro]: \"\\<lbrakk>l\\<noteq>[]\\<rbrakk> \\<Longrightarrow> last l \\<in> set l\"", "lemma nat_compl_induct[case_names 0 Suc]: \"\\<lbrakk>P 0; !! n . ALL nn . nn <= n \\<longrightarrow> P nn \\<Longrightarrow> P (Suc n)\\<rbrakk> \\<Longrightarrow> P n\"", "lemma boolfun_cases_helper: \"g=(\\<lambda>x. False) | g=(\\<lambda>x. x) | g=(\\<lambda>x. True) | g= (\\<lambda>x. \\<not>x)\"", "lemma boolfun_cases[case_names False Id True Neg]: \"\\<lbrakk>g=(\\<lambda>x. False) \\<Longrightarrow> P g; g=(\\<lambda>x. x) \\<Longrightarrow> P g; g=(\\<lambda>x. True) \\<Longrightarrow> P g; g=(\\<lambda>x. \\<not>x) \\<Longrightarrow> P g\\<rbrakk> \\<Longrightarrow> P g\"", "lemma some_theI: assumes EX: \"\\<exists>a b . P a b\" and BUN: \"!! b1 b2 . \\<lbrakk>\\<exists>a . P a b1; \\<exists>a . P a b2\\<rbrakk> \\<Longrightarrow> b1=b2\" \n    shows \"P (SOME a . \\<exists>b . P a b) (THE b . \\<exists>a . P a b)\""], "translations": [["", "lemma (in AC) left_commute[simp]: \"f x (f y z) = f y (f x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x (f y z) = f y (f x z)", "by (simp only: assoc[symmetric]) simp"], ["", "text \\<open>Locale to define functions from surjective, unique relations\\<close>"], ["", "locale su_rel_fun =\n  fixes F and f\n  assumes unique: \"\\<lbrakk>(A,B)\\<in>F; (A,B')\\<in>F\\<rbrakk> \\<Longrightarrow> B=B'\"\n  assumes surjective: \"\\<lbrakk>!!B. (A,B)\\<in>F \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"\n  assumes f_def: \"f A == THE B. (A,B)\\<in>F\""], ["", "lemma (in su_rel_fun) repr1: \"(A,f A)\\<in>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, f A) \\<in> F", "proof (unfold f_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (A, THE B. (A, B) \\<in> F) \\<in> F", "obtain B where \"(A,B)\\<in>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. (A, B) \\<in> F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule surjective)"], ["proof (state)\nthis:\n  (A, B) \\<in> F\n\ngoal (1 subgoal):\n 1. (A, THE B. (A, B) \\<in> F) \\<in> F", "with theI[where P=\"\\<lambda>B. (A,B)\\<in>F\", OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x. (A, x) \\<in> F \\<Longrightarrow> x = B) \\<Longrightarrow>\n  (A, THE x. (A, x) \\<in> F) \\<in> F\n  (A, B) \\<in> F", "show \"(A, THE x. (A, x) \\<in> F) \\<in> F\""], ["proof (prove)\nusing this:\n  (\\<And>x. (A, x) \\<in> F \\<Longrightarrow> x = B) \\<Longrightarrow>\n  (A, THE x. (A, x) \\<in> F) \\<in> F\n  (A, B) \\<in> F\n\ngoal (1 subgoal):\n 1. (A, THE x. (A, x) \\<in> F) \\<in> F", "by (blast intro: unique)"], ["proof (state)\nthis:\n  (A, THE x. (A, x) \\<in> F) \\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in su_rel_fun) repr2: \"(A,B)\\<in>F \\<Longrightarrow> B=f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, B) \\<in> F \\<Longrightarrow> B = f A", "using repr1"], ["proof (prove)\nusing this:\n  (?A, f ?A) \\<in> F\n\ngoal (1 subgoal):\n 1. (A, B) \\<in> F \\<Longrightarrow> B = f A", "by (blast intro: unique)"], ["", "lemma (in su_rel_fun) repr: \"(f A = B) = ((A,B)\\<in>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f A = B) = ((A, B) \\<in> F)", "using repr1 repr2"], ["proof (prove)\nusing this:\n  (?A, f ?A) \\<in> F\n  (?A, ?B) \\<in> F \\<Longrightarrow> ?B = f ?A\n\ngoal (1 subgoal):\n 1. (f A = B) = ((A, B) \\<in> F)", "by (blast)"], ["", "subsection \\<open>Abbreviations for list order\\<close>"], ["", "abbreviation ileq :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"  (infix \"\\<preceq>\" 50) where\n  \"(\\<preceq>) \\<equiv> (\\<le>)\""], ["", "abbreviation ilt :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"  (infix \"\\<prec>\" 50) where\n  \"(\\<prec>) \\<equiv> (<)\""], ["", "subsection \\<open>Multisets\\<close>"], ["", "(*\n  The following is a syntax extension for multisets. Unfortunately, it depends on a change in the Library/Multiset.thy, so it is commented out here, until it will be incorporated \n  into Library/Multiset.thy by its maintainers.\n\n  The required change in Library/Multiset.thy is removing the syntax for single:\n     - single :: \"'a => 'a multiset\"    (\"{#_#}\")\n     + single :: \"'a => 'a multiset\"\n\n  And adding the following translations instead:\n  \n     + syntax\n     + \"_multiset\" :: \"args \\<Rightarrow> 'a multiset\" (\"{#(_)#}\")\n\n     + translations\n     +   \"{#x, xs#}\" == \"{#x#} + {#xs#}\" \n     +   \"{# x #}\" == \"single x\"\n\n  This translates \"{# \\<dots> #}\" into a sum of singletons, that is parenthesized to the right. ?? Can we also achieve left-parenthesizing ??\n\n*)\n\n\n  (* Let's try what happens if declaring AC-rules for multiset union as simp-rules *)\n(*declare union_ac[simp] -- don't do it !*)"], ["", "subsubsection \\<open>Case distinction\\<close>"], ["", "lemma multiset_induct'[case_names empty add]: \"\\<lbrakk>P {#}; \\<And>M x. P M \\<Longrightarrow> P ({#x#}+M)\\<rbrakk> \\<Longrightarrow> P M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P {#}; \\<And>M x. P M \\<Longrightarrow> P ({#x#} + M)\\<rbrakk>\n    \\<Longrightarrow> P M", "by (induct rule: multiset_induct) (auto simp add: union_commute)"], ["", "subsubsection \\<open>Count\\<close>"], ["", "lemma count_ne_remove: \"\\<lbrakk> x ~= t\\<rbrakk> \\<Longrightarrow> count S x = count (S-{#t#}) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> t \\<Longrightarrow> count S x = count (S - {#t#}) x", "by (auto)"], ["", "lemma mset_empty_count[simp]: \"(\\<forall>p. count M p = 0) = (M={#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p. count M p = 0) = (M = {#})", "by (auto simp add: multiset_eq_iff)"], ["", "subsubsection \\<open>Union, difference and intersection\\<close>"], ["", "lemma size_diff_se: \"\\<lbrakk>t \\<in># S\\<rbrakk> \\<Longrightarrow> size S = size (S - {#t#}) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> size S = size (S - {#t#}) + 1", "proof (unfold size_multiset_overloaded_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "let ?SIZE = \"sum (count S) (set_mset S)\""], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "assume A: \"t \\<in># S\""], ["proof (state)\nthis:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from A"], ["proof (chain)\npicking this:\n  t \\<in># S", "have SPLITPRE: \"finite (set_mset S) & {t}\\<subseteq>(set_mset S)\""], ["proof (prove)\nusing this:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S", "by auto"], ["proof (state)\nthis:\n  finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "hence \"?SIZE = sum (count S) (set_mset S - {t}) + sum (count S) {t}\""], ["proof (prove)\nusing this:\n  finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count S) (set_mset S - {t}) + sum (count S) {t}", "by (blast dest: sum.subset_diff)"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + sum (count S) {t}\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "hence \"?SIZE = sum (count S) (set_mset S - {t}) + count (S) t\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + sum (count S) {t}\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count S) (set_mset S - {t}) + count S t", "by auto"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "with A"], ["proof (chain)\npicking this:\n  t \\<in># S\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t", "have \"count S t = count (S-{#t#}) t + 1\""], ["proof (prove)\nusing this:\n  t \\<in># S\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n\ngoal (1 subgoal):\n 1. count S t = count (S - {#t#}) t + 1", "by auto"], ["proof (state)\nthis:\n  count S t = count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "ultimately"], ["proof (chain)\npicking this:\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n  count S t = count (S - {#t#}) t + 1", "have D: \"?SIZE = sum (count S) (set_mset S - {t}) + count (S-{#t#}) t + 1\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) = sum (count S) (set_mset S - {t}) + count S t\n  count S t = count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1", "by (arith)"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "have \"sum (count S) (set_mset S - {t}) = sum (count (S-{#t#})) (set_mset S - {t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S - {t}) =\n    sum (count (S - {#t#})) (set_mset S - {t})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S - {t}) =\n    sum (count (S - {#t#})) (set_mset S - {t})", "have \"ALL x:(set_mset S - {t}) . count S x = count (S-{#t#}) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_mset S - {t}. count S x = count (S - {#t#}) x", "by (auto iff add: count_ne_remove)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_mset S - {t}. count S x = count (S - {#t#}) x\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S - {t}) =\n    sum (count (S - {#t#})) (set_mset S - {t})", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_mset S - {t}. count S x = count (S - {#t#}) x\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S - {t}) =\n    sum (count (S - {#t#})) (set_mset S - {t})", "by simp"], ["proof (state)\nthis:\n  sum (count S) (set_mset S - {t}) =\n  sum (count (S - {#t#})) (set_mset S - {t})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (count S) (set_mset S - {t}) =\n  sum (count (S - {#t#})) (set_mset S - {t})\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "ultimately"], ["proof (chain)\npicking this:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  sum (count S) (set_mset S - {t}) =\n  sum (count (S - {#t#})) (set_mset S - {t})", "have D: \"?SIZE = sum (count (S-{#t#})) (set_mset S - {t}) + count (S-{#t#}) t + 1\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) =\n  sum (count S) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  sum (count S) (set_mset S - {t}) =\n  sum (count (S - {#t#})) (set_mset S - {t})\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1", "by (simp)"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "{"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "assume CASE: \"t \\<notin># S - {#t#}\""], ["proof (state)\nthis:\n  t \\<notin># S - {#t#}\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from CASE"], ["proof (chain)\npicking this:\n  t \\<notin># S - {#t#}", "have \"set_mset S - {t} = set_mset (S - {#t#})\""], ["proof (prove)\nusing this:\n  t \\<notin># S - {#t#}\n\ngoal (1 subgoal):\n 1. set_mset S - {t} = set_mset (S - {#t#})", "by (simp add: at_most_one_mset_mset_diff)"], ["proof (state)\nthis:\n  set_mset S - {t} = set_mset (S - {#t#})\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "with CASE D"], ["proof (chain)\npicking this:\n  t \\<notin># S - {#t#}\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  set_mset S - {t} = set_mset (S - {#t#})", "have \"?SIZE = sum (count (S-{#t#})) (set_mset (S - {#t#})) + 1\""], ["proof (prove)\nusing this:\n  t \\<notin># S - {#t#}\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  set_mset S - {t} = set_mset (S - {#t#})\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "by (simp add: not_in_iff)"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "}"], ["proof (state)\nthis:\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "{"], ["proof (state)\nthis:\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "assume CASE: \"t \\<in># S - {#t#}\""], ["proof (state)\nthis:\n  t \\<in># S - {#t#}\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from CASE"], ["proof (chain)\npicking this:\n  t \\<in># S - {#t#}", "have 1: \"set_mset S = set_mset (S-{#t#})\""], ["proof (prove)\nusing this:\n  t \\<in># S - {#t#}\n\ngoal (1 subgoal):\n 1. set_mset S = set_mset (S - {#t#})", "by (rule more_than_one_mset_mset_diff [symmetric])"], ["proof (state)\nthis:\n  set_mset S = set_mset (S - {#t#})\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  set_mset S = set_mset (S - {#t#})\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from D"], ["proof (chain)\npicking this:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1", "have \"?SIZE = sum (count (S-{#t#})) (set_mset S - {t}) + sum (count (S-{#t#})) {t} + 1\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset S - {t}) +\n    sum (count (S - {#t#})) {t} +\n    1", "by simp"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t} +\n  1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "moreover"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t} +\n  1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "from SPLITPRE sum.subset_diff"], ["proof (chain)\npicking this:\n  finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S\n  \\<lbrakk>?B \\<subseteq> ?A; finite ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?g (?A - ?B) + sum ?g ?B", "have \"sum (count (S-{#t#})) (set_mset S) = sum (count (S-{#t#})) (set_mset S - {t}) + sum (count (S-{#t#})) {t}\""], ["proof (prove)\nusing this:\n  finite (set_mset S) \\<and> {t} \\<subseteq> set_mset S\n  \\<lbrakk>?B \\<subseteq> ?A; finite ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?g (?A - ?B) + sum ?g ?B\n\ngoal (1 subgoal):\n 1. sum (count (S - {#t#})) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t}", "by (blast)"], ["proof (state)\nthis:\n  sum (count (S - {#t#})) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t}\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "ultimately"], ["proof (chain)\npicking this:\n  set_mset S = set_mset (S - {#t#})\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t} +\n  1\n  sum (count (S - {#t#})) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t}", "have \"?SIZE = sum (count (S-{#t#})) (set_mset (S-{#t#})) + 1\""], ["proof (prove)\nusing this:\n  set_mset S = set_mset (S - {#t#})\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t} +\n  1\n  sum (count (S - {#t#})) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + sum (count (S - {#t#})) {t}\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "by simp"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "}"], ["proof (state)\nthis:\n  t \\<in># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow>\n    sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "ultimately"], ["proof (chain)\npicking this:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n  t \\<in># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "show \"?SIZE = sum (count (S-{#t#})) (set_mset (S - {#t#})) + 1\""], ["proof (prove)\nusing this:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset S - {t}) + count (S - {#t#}) t + 1\n  t \\<notin># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n  t \\<in># S - {#t#} \\<Longrightarrow>\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal (1 subgoal):\n 1. sum (count S) (set_mset S) =\n    sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1", "by blast"], ["proof (state)\nthis:\n  sum (count S) (set_mset S) =\n  sum (count (S - {#t#})) (set_mset (S - {#t#})) + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Check whether this proof can be done simpler *)"], ["", "lemma mset_union_diff_comm: \"t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = (T + S) - {#t#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = T + S - {#t#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = T + S - {#t#}", "assume \"t \\<in># S\""], ["proof (state)\nthis:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = T + S - {#t#}", "then"], ["proof (chain)\npicking this:\n  t \\<in># S", "obtain S' where S: \"S = add_mset t S'\""], ["proof (prove)\nusing this:\n  t \\<in># S\n\ngoal (1 subgoal):\n 1. (\\<And>S'. S = add_mset t S' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis insert_DiffM)"], ["proof (state)\nthis:\n  S = add_mset t S'\n\ngoal (1 subgoal):\n 1. t \\<in># S \\<Longrightarrow> T + (S - {#t#}) = T + S - {#t#}", "then"], ["proof (chain)\npicking this:\n  S = add_mset t S'", "show ?thesis"], ["proof (prove)\nusing this:\n  S = add_mset t S'\n\ngoal (1 subgoal):\n 1. T + (S - {#t#}) = T + S - {#t#}", "by auto"], ["proof (state)\nthis:\n  T + (S - {#t#}) = T + S - {#t#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_right_cancel_union: \"\\<lbrakk>a \\<in># A+B; ~(a \\<in># B)\\<rbrakk> \\<Longrightarrow> a\\<in>#A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A + B; a \\<notin># B\\<rbrakk>\n    \\<Longrightarrow> a \\<in># A", "by (simp)"], ["", "lemma mset_left_cancel_union: \"\\<lbrakk>a \\<in># A+B; ~(a \\<in># A)\\<rbrakk> \\<Longrightarrow> a\\<in>#B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A + B; a \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> a \\<in># B", "by (simp)"], ["", "lemmas mset_cancel_union = mset_right_cancel_union mset_left_cancel_union"], ["", "lemma mset_right_cancel_elem: \"\\<lbrakk>a \\<in># A+{#b#}; a~=b\\<rbrakk> \\<Longrightarrow> a\\<in>#A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A + {#b#}; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<in># A", "apply(subgoal_tac \"~(a \\<in># {#b#})\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in># A + {#b#}; a \\<noteq> b; a \\<notin># {#b#}\\<rbrakk>\n    \\<Longrightarrow> a \\<in># A\n 2. \\<lbrakk>a \\<in># A + {#b#}; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<notin># {#b#}", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mset_left_cancel_elem: \"\\<lbrakk>a \\<in># {#b#}+A; a~=b\\<rbrakk> \\<Longrightarrow> a\\<in>#A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># {#b#} + A; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<in># A", "apply(subgoal_tac \"~(a \\<in># {#b#})\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in># {#b#} + A; a \\<noteq> b; a \\<notin># {#b#}\\<rbrakk>\n    \\<Longrightarrow> a \\<in># A\n 2. \\<lbrakk>a \\<in># {#b#} + A; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<notin># {#b#}", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas mset_cancel_elem = mset_right_cancel_elem mset_left_cancel_elem"], ["", "lemma mset_diff_cancel1elem[simp]: \"~(a \\<in># B) \\<Longrightarrow> {#a#}-B = {#a#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin># B \\<Longrightarrow> {#a#} - B = {#a#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin># B \\<Longrightarrow> {#a#} - B = {#a#}", "assume A: \"~(a \\<in># B)\""], ["proof (state)\nthis:\n  a \\<notin># B\n\ngoal (1 subgoal):\n 1. a \\<notin># B \\<Longrightarrow> {#a#} - B = {#a#}", "hence \"count ({#a#}-B) a = count ({#a#}) a\""], ["proof (prove)\nusing this:\n  a \\<notin># B\n\ngoal (1 subgoal):\n 1. count ({#a#} - B) a = count {#a#} a", "by (auto simp add: not_in_iff)"], ["proof (state)\nthis:\n  count ({#a#} - B) a = count {#a#} a\n\ngoal (1 subgoal):\n 1. a \\<notin># B \\<Longrightarrow> {#a#} - B = {#a#}", "moreover"], ["proof (state)\nthis:\n  count ({#a#} - B) a = count {#a#} a\n\ngoal (1 subgoal):\n 1. a \\<notin># B \\<Longrightarrow> {#a#} - B = {#a#}", "have \"ALL e . e~=a \\<longrightarrow> count ({#a#}-B) e = count ({#a#}) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e.\n       e \\<noteq> a \\<longrightarrow> count ({#a#} - B) e = count {#a#} e", "by auto"], ["proof (state)\nthis:\n  \\<forall>e.\n     e \\<noteq> a \\<longrightarrow> count ({#a#} - B) e = count {#a#} e\n\ngoal (1 subgoal):\n 1. a \\<notin># B \\<Longrightarrow> {#a#} - B = {#a#}", "ultimately"], ["proof (chain)\npicking this:\n  count ({#a#} - B) a = count {#a#} a\n  \\<forall>e.\n     e \\<noteq> a \\<longrightarrow> count ({#a#} - B) e = count {#a#} e", "show ?thesis"], ["proof (prove)\nusing this:\n  count ({#a#} - B) a = count {#a#} a\n  \\<forall>e.\n     e \\<noteq> a \\<longrightarrow> count ({#a#} - B) e = count {#a#} e\n\ngoal (1 subgoal):\n 1. {#a#} - B = {#a#}", "by (auto simp add: multiset_eq_iff)"], ["proof (state)\nthis:\n  {#a#} - B = {#a#}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*lemma union_diff_assoc_se: \"t \\<in># B \\<Longrightarrow> (A+B)-{#t#} = A + (B-{#t#})\"\n    by (auto iff add: multiset_eq_iff)\n  lemma union_diff_assoc_se2: \"t \\<in># A \\<Longrightarrow> (A+B)-{#t#} = (A-{#t#}) + B\"\n    by (auto iff add: multiset_eq_iff)\n  lemmas union_diff_assoc_se = union_diff_assoc_se1 union_diff_assoc_se2*)"], ["", "lemma union_diff_assoc: \"C-B={#} \\<Longrightarrow> (A+B)-C = A + (B-C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C - B = {#} \\<Longrightarrow> A + B - C = A + (B - C)", "by (simp add: multiset_eq_iff)"], ["", "lemma mset_union_2_elem: \"{#a#}+{#b#} = M + {#c#} \\<Longrightarrow> {#a#}=M & b=c | a=c & {#b#}=M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a#} + {#b#} = M + {#c#} \\<Longrightarrow>\n    {#a#} = M \\<and> b = c \\<or> a = c \\<and> {#b#} = M", "by (auto simp: add_eq_conv_diff)"], ["", "lemma mset_un_cases[cases set, case_names left right]:\n    \"\\<lbrakk>a \\<in># A + B; a\\<in>#A \\<Longrightarrow> P; a\\<in>#B \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A + B; a \\<in># A \\<Longrightarrow> P;\n     a \\<in># B \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto)"], ["", "lemma mset_unplusm_dist_cases[cases set, case_names left right]:\n    assumes A: \"add_mset s A = B+C\"\n    assumes L: \"\\<lbrakk>B=add_mset s (B-{#s#}); A=(B-{#s#})+C\\<rbrakk> \\<Longrightarrow> P\"\n    assumes R: \"\\<lbrakk>C=add_mset s (C-{#s#}); A=B+(C-{#s#})\\<rbrakk> \\<Longrightarrow> P\" \n    shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from A[symmetric]"], ["proof (chain)\npicking this:\n  B + C = add_mset s A", "have \"s \\<in># B+C\""], ["proof (prove)\nusing this:\n  B + C = add_mset s A\n\ngoal (1 subgoal):\n 1. s \\<in># B + C", "by simp"], ["proof (state)\nthis:\n  s \\<in># B + C\n\ngoal (1 subgoal):\n 1. P", "thus ?thesis"], ["proof (prove)\nusing this:\n  s \\<in># B + C\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: mset_un_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "case left"], ["proof (state)\nthis:\n  s \\<in># B\n\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "hence 1: \"B=add_mset s (B-{#s#})\""], ["proof (prove)\nusing this:\n  s \\<in># B\n\ngoal (1 subgoal):\n 1. B = add_mset s (B - {#s#})", "by simp"], ["proof (state)\nthis:\n  B = add_mset s (B - {#s#})\n\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  add_mset s A = B + C\n  B = add_mset s (B - {#s#})", "have \"add_mset s A = add_mset s ((B-{#s#})+C)\""], ["proof (prove)\nusing this:\n  add_mset s A = B + C\n  B = add_mset s (B - {#s#})\n\ngoal (1 subgoal):\n 1. add_mset s A = add_mset s (B - {#s#} + C)", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  add_mset s A = add_mset s (B - {#s#} + C)\n\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "hence 2: \"A = (B-{#s#})+C\""], ["proof (prove)\nusing this:\n  add_mset s A = add_mset s (B - {#s#} + C)\n\ngoal (1 subgoal):\n 1. A = B - {#s#} + C", "by (simp)"], ["proof (state)\nthis:\n  A = B - {#s#} + C\n\ngoal (2 subgoals):\n 1. s \\<in># B \\<Longrightarrow> P\n 2. s \\<in># C \\<Longrightarrow> P", "from L[OF 1 2]"], ["proof (chain)\npicking this:\n  P", "show ?thesis"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "case right"], ["proof (state)\nthis:\n  s \\<in># C\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "hence 1: \"C=add_mset s (C-{#s#})\""], ["proof (prove)\nusing this:\n  s \\<in># C\n\ngoal (1 subgoal):\n 1. C = add_mset s (C - {#s#})", "by simp"], ["proof (state)\nthis:\n  C = add_mset s (C - {#s#})\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  add_mset s A = B + C\n  C = add_mset s (C - {#s#})", "have \"add_mset s A = add_mset s (B+(C-{#s#}))\""], ["proof (prove)\nusing this:\n  add_mset s A = B + C\n  C = add_mset s (C - {#s#})\n\ngoal (1 subgoal):\n 1. add_mset s A = add_mset s (B + (C - {#s#}))", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  add_mset s A = add_mset s (B + (C - {#s#}))\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "hence 2: \"A = B+(C-{#s#})\""], ["proof (prove)\nusing this:\n  add_mset s A = add_mset s (B + (C - {#s#}))\n\ngoal (1 subgoal):\n 1. A = B + (C - {#s#})", "by (simp)"], ["proof (state)\nthis:\n  A = B + (C - {#s#})\n\ngoal (1 subgoal):\n 1. s \\<in># C \\<Longrightarrow> P", "from R[OF 1 2]"], ["proof (chain)\npicking this:\n  P", "show ?thesis"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_unplusm_dist_cases2[cases set, case_names left right]:\n    assumes A: \"B+C = add_mset s A\"\n    assumes L: \"\\<lbrakk>B=add_mset s (B-{#s#}); A=(B-{#s#})+C\\<rbrakk> \\<Longrightarrow> P\"\n    assumes R: \"\\<lbrakk>C=add_mset s (C-{#s#}); A=B+(C-{#s#})\\<rbrakk> \\<Longrightarrow> P\" \n    shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using mset_unplusm_dist_cases[OF A[symmetric]] L R"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>B = add_mset s (B - {#s#}); A = B - {#s#} + C\\<rbrakk>\n           \\<Longrightarrow> ?P;\n   \\<lbrakk>C = add_mset s (C - {#s#}); A = B + (C - {#s#})\\<rbrakk>\n   \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>B = add_mset s (B - {#s#}); A = B - {#s#} + C\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>C = add_mset s (C - {#s#}); A = B + (C - {#s#})\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["", "lemma mset_single_cases[cases set, case_names loc env]: \n    assumes A: \"add_mset s c = add_mset r' c'\" \n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>c'={#s#}+(c'-{#s#}); c={#r'#}+(c-{#r'#}); c-{#r'#} = c'-{#s#} \\<rbrakk> \\<Longrightarrow> P\" \n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "assume CASE: \"s=r'\""], ["proof (state)\nthis:\n  s = r'\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  add_mset s c = add_mset r' c'\n  s = r'", "have \"c=c'\""], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  s = r'\n\ngoal (1 subgoal):\n 1. c = c'", "by simp"], ["proof (state)\nthis:\n  c = c'\n\ngoal (1 subgoal):\n 1. P", "with CASE CASES"], ["proof (chain)\npicking this:\n  s = r'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n  c = c'", "have ?thesis"], ["proof (prove)\nusing this:\n  s = r'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n  c = c'\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  s = r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  s = r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  s = r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "assume CASE: \"s\\<noteq>r'\""], ["proof (state)\nthis:\n  s \\<noteq> r'\n\ngoal (1 subgoal):\n 1. P", "have \"s\\<in>#{#s#}+c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in># {#s#} + c", "by simp"], ["proof (state)\nthis:\n  s \\<in># {#s#} + c\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  add_mset s c = add_mset r' c'\n  s \\<in># {#s#} + c", "have \"s \\<in># {#r'#} + c'\""], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  s \\<in># {#s#} + c\n\ngoal (1 subgoal):\n 1. s \\<in># {#r'#} + c'", "by simp"], ["proof (state)\nthis:\n  s \\<in># {#r'#} + c'\n\ngoal (1 subgoal):\n 1. P", "with CASE"], ["proof (chain)\npicking this:\n  s \\<noteq> r'\n  s \\<in># {#r'#} + c'", "have \"s \\<in># c'\""], ["proof (prove)\nusing this:\n  s \\<noteq> r'\n  s \\<in># {#r'#} + c'\n\ngoal (1 subgoal):\n 1. s \\<in># c'", "by simp"], ["proof (state)\nthis:\n  s \\<in># c'\n\ngoal (1 subgoal):\n 1. P", "from insert_DiffM[OF this, symmetric]"], ["proof (chain)\npicking this:\n  c' = add_mset s (c' - {#s#})", "have 1: \"c' = add_mset s (c' - {#s#})\""], ["proof (prove)\nusing this:\n  c' = add_mset s (c' - {#s#})\n\ngoal (1 subgoal):\n 1. c' = add_mset s (c' - {#s#})", "."], ["proof (state)\nthis:\n  c' = add_mset s (c' - {#s#})\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  add_mset s c = add_mset r' c'\n  c' = add_mset s (c' - {#s#})", "have \"{#s#}+c = {#s#}+({#r'#}+(c' - {#s#}))\""], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  c' = add_mset s (c' - {#s#})\n\ngoal (1 subgoal):\n 1. {#s#} + c = {#s#} + ({#r'#} + (c' - {#s#}))", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  {#s#} + c = {#s#} + ({#r'#} + (c' - {#s#}))\n\ngoal (1 subgoal):\n 1. P", "hence 2: \"c={#r'#}+(c' - {#s#})\""], ["proof (prove)\nusing this:\n  {#s#} + c = {#s#} + ({#r'#} + (c' - {#s#}))\n\ngoal (1 subgoal):\n 1. c = {#r'#} + (c' - {#s#})", "by (auto)"], ["proof (state)\nthis:\n  c = {#r'#} + (c' - {#s#})\n\ngoal (1 subgoal):\n 1. P", "hence 3: \"c-{#r'#} = (c' - {#s#})\""], ["proof (prove)\nusing this:\n  c = {#r'#} + (c' - {#s#})\n\ngoal (1 subgoal):\n 1. c - {#r'#} = c' - {#s#}", "by auto"], ["proof (state)\nthis:\n  c - {#r'#} = c' - {#s#}\n\ngoal (1 subgoal):\n 1. P", "from 1 2 3 CASES"], ["proof (chain)\npicking this:\n  c' = add_mset s (c' - {#s#})\n  c = {#r'#} + (c' - {#s#})\n  c - {#r'#} = c' - {#s#}\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P", "have ?thesis"], ["proof (prove)\nusing this:\n  c' = add_mset s (c' - {#s#})\n  c = {#r'#} + (c' - {#s#})\n  c - {#r'#} = c' - {#s#}\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  s \\<noteq> r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "ultimately"], ["proof (chain)\npicking this:\n  s = r' \\<Longrightarrow> P\n  s \\<noteq> r' \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\nusing this:\n  s = r' \\<Longrightarrow> P\n  s \\<noteq> r' \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_single_cases'[cases set, case_names loc env]: \n    assumes A: \"add_mset s c = add_mset r' c'\" \n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"!!cc. \\<lbrakk>c'={#s#}+cc; c={#r'#}+cc; c'-{#s#}=cc; c-{#r'#}=cc\\<rbrakk> \\<Longrightarrow> P\" \n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A  CASES"], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = {#s#} + ?cc; c = {#r'#} + ?cc; c' - {#s#} = ?cc;\n   c - {#r'#} = ?cc\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (auto elim!: mset_single_cases)"], ["", "lemma mset_single_cases2[cases set, case_names loc env]: \n    assumes A: \"add_mset s c = add_mset r' c'\" \n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"\\<lbrakk>c'=(c'-{#s#})+{#s#}; c=(c-{#r'#})+{#r'#}; c-{#r'#} = c'-{#s#} \\<rbrakk> \\<Longrightarrow> P\" \n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from A"], ["proof (chain)\npicking this:\n  add_mset s c = add_mset r' c'", "have \"add_mset s c = add_mset r' c'\""], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n\ngoal (1 subgoal):\n 1. add_mset s c = add_mset r' c'", "by simp"], ["proof (state)\nthis:\n  add_mset s c = add_mset r' c'\n\ngoal (1 subgoal):\n 1. P", "thus ?thesis"], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: mset_single_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n 2. \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n     c - {#r'#} = c' - {#s#}\\<rbrakk>\n    \\<Longrightarrow> P", "case loc"], ["proof (state)\nthis:\n  s = r'\n  c = c'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n 2. \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n     c - {#r'#} = c' - {#s#}\\<rbrakk>\n    \\<Longrightarrow> P", "with CASES"], ["proof (chain)\npicking this:\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = c' - {#s#} + {#s#}; c = c - {#r'#} + {#r'#};\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n  s = r'\n  c = c'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = c' - {#s#} + {#s#}; c = c - {#r'#} + {#r'#};\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n  s = r'\n  c = c'\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n     c - {#r'#} = c' - {#s#}\\<rbrakk>\n    \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n     c - {#r'#} = c' - {#s#}\\<rbrakk>\n    \\<Longrightarrow> P", "case env"], ["proof (state)\nthis:\n  c' = {#s#} + (c' - {#s#})\n  c = {#r'#} + (c - {#r'#})\n  c - {#r'#} = c' - {#s#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c' = {#s#} + (c' - {#s#}); c = {#r'#} + (c - {#r'#});\n     c - {#r'#} = c' - {#s#}\\<rbrakk>\n    \\<Longrightarrow> P", "with CASES"], ["proof (chain)\npicking this:\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = c' - {#s#} + {#s#}; c = c - {#r'#} + {#r'#};\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n  c' = {#s#} + (c' - {#s#})\n  c = {#r'#} + (c - {#r'#})\n  c - {#r'#} = c' - {#s#}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = c' - {#s#} + {#s#}; c = c - {#r'#} + {#r'#};\n   c - {#r'#} = c' - {#s#}\\<rbrakk>\n  \\<Longrightarrow> P\n  c' = {#s#} + (c' - {#s#})\n  c = {#r'#} + (c - {#r'#})\n  c - {#r'#} = c' - {#s#}\n\ngoal (1 subgoal):\n 1. P", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_single_cases2'[cases set, case_names loc env]: \n    assumes A: \"add_mset s c = add_mset r' c'\" \n    assumes CASES: \"\\<lbrakk>s=r'; c=c'\\<rbrakk> \\<Longrightarrow> P\" \"!!cc. \\<lbrakk>c'=cc+{#s#}; c=cc+{#r'#}; c'-{#s#}=cc; c-{#r'#}=cc\\<rbrakk> \\<Longrightarrow> P\" \n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using A  CASES"], ["proof (prove)\nusing this:\n  add_mset s c = add_mset r' c'\n  \\<lbrakk>s = r'; c = c'\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>c' = ?cc + {#s#}; c = ?cc + {#r'#}; c' - {#s#} = ?cc;\n   c - {#r'#} = ?cc\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (auto elim!: mset_single_cases2)"], ["", "lemma mset_un_single_un_cases [consumes 1, case_names left right]:\n    assumes A: \"add_mset a A = B + C\"\n      and CASES: \"a \\<in># B \\<Longrightarrow> A = (B - {#a#}) + C \\<Longrightarrow> P\"\n        \"a \\<in># C \\<Longrightarrow> A = B + (C - {#a#}) \\<Longrightarrow> P\"\n    shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have \"a \\<in># A+{#a#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in># A + {#a#}", "by simp"], ["proof (state)\nthis:\n  a \\<in># A + {#a#}\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  add_mset a A = B + C\n  a \\<in># A + {#a#}", "have \"a \\<in># B+C\""], ["proof (prove)\nusing this:\n  add_mset a A = B + C\n  a \\<in># A + {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># B + C", "by auto"], ["proof (state)\nthis:\n  a \\<in># B + C\n\ngoal (1 subgoal):\n 1. P", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<in># B + C\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule: mset_un_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "case left"], ["proof (state)\nthis:\n  a \\<in># B\n\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "hence \"B=B-{#a#}+{#a#}\""], ["proof (prove)\nusing this:\n  a \\<in># B\n\ngoal (1 subgoal):\n 1. B = B - {#a#} + {#a#}", "by auto"], ["proof (state)\nthis:\n  B = B - {#a#} + {#a#}\n\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  add_mset a A = B + C\n  B = B - {#a#} + {#a#}", "have \"A+{#a#} = (B-{#a#})+C+{#a#}\""], ["proof (prove)\nusing this:\n  add_mset a A = B + C\n  B = B - {#a#} + {#a#}\n\ngoal (1 subgoal):\n 1. A + {#a#} = B - {#a#} + C + {#a#}", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  A + {#a#} = B - {#a#} + C + {#a#}\n\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "hence \"A=(B-{#a#})+C\""], ["proof (prove)\nusing this:\n  A + {#a#} = B - {#a#} + C + {#a#}\n\ngoal (1 subgoal):\n 1. A = B - {#a#} + C", "by simp"], ["proof (state)\nthis:\n  A = B - {#a#} + C\n\ngoal (2 subgoals):\n 1. a \\<in># B \\<Longrightarrow> P\n 2. a \\<in># C \\<Longrightarrow> P", "with CASES(1)[OF left]"], ["proof (chain)\npicking this:\n  A = B - {#a#} + C \\<Longrightarrow> P\n  A = B - {#a#} + C", "show ?thesis"], ["proof (prove)\nusing this:\n  A = B - {#a#} + C \\<Longrightarrow> P\n  A = B - {#a#} + C\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "case right"], ["proof (state)\nthis:\n  a \\<in># C\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "hence \"C=C-{#a#}+{#a#}\""], ["proof (prove)\nusing this:\n  a \\<in># C\n\ngoal (1 subgoal):\n 1. C = C - {#a#} + {#a#}", "by auto"], ["proof (state)\nthis:\n  C = C - {#a#} + {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "with A"], ["proof (chain)\npicking this:\n  add_mset a A = B + C\n  C = C - {#a#} + {#a#}", "have \"A+{#a#} = B+(C-{#a#})+{#a#}\""], ["proof (prove)\nusing this:\n  add_mset a A = B + C\n  C = C - {#a#} + {#a#}\n\ngoal (1 subgoal):\n 1. A + {#a#} = B + (C - {#a#}) + {#a#}", "by (auto simp add: union_ac)"], ["proof (state)\nthis:\n  A + {#a#} = B + (C - {#a#}) + {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "hence \"A=B+(C-{#a#})\""], ["proof (prove)\nusing this:\n  A + {#a#} = B + (C - {#a#}) + {#a#}\n\ngoal (1 subgoal):\n 1. A = B + (C - {#a#})", "by simp"], ["proof (state)\nthis:\n  A = B + (C - {#a#})\n\ngoal (1 subgoal):\n 1. a \\<in># C \\<Longrightarrow> P", "with CASES(2)[OF right]"], ["proof (chain)\npicking this:\n  A = B + (C - {#a#}) \\<Longrightarrow> P\n  A = B + (C - {#a#})", "show ?thesis"], ["proof (prove)\nusing this:\n  A = B + (C - {#a#}) \\<Longrightarrow> P\n  A = B + (C - {#a#})\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Can this proof be done more automatically ? *)"], ["", "lemma mset_distrib[consumes 1, case_names dist]: assumes A: \"(A::'a multiset)+B = M+N\" \"!!Am An Bm Bn. \\<lbrakk>A=Am+An; B=Bm+Bn; M=Am+Bm; N=An+Bn\\<rbrakk> \\<Longrightarrow> P\" shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have BN_MA: \"B - N = M - A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - N = M - A", "by (metis (no_types) add_diff_cancel_right assms(1) union_commute)"], ["proof (state)\nthis:\n  B - N = M - A\n\ngoal (1 subgoal):\n 1. P", "have H: \"A = A\\<inter># C + (A - C) \\<inter># D\" if \"A + B = C + D\" for A B C D :: \"'a multiset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A \\<inter># C + (A - C) \\<inter># D", "by (metis add.commute diff_intersect_left_idem mset_subset_eq_add_left subset_eq_diff_conv\n          subset_mset.add_diff_inverse subset_mset.inf_absorb1 subset_mset.inf_le1 that)"], ["proof (state)\nthis:\n  ?A + ?B = ?C + ?D \\<Longrightarrow>\n  ?A = ?A \\<inter># ?C + (?A - ?C) \\<inter># ?D\n\ngoal (1 subgoal):\n 1. P", "have A': \"A = A\\<inter># M + (A - M) \\<inter># N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A \\<inter># M + (A - M) \\<inter># N", "using A(1) H"], ["proof (prove)\nusing this:\n  A + B = M + N\n  ?A + ?B = ?C + ?D \\<Longrightarrow>\n  ?A = ?A \\<inter># ?C + (?A - ?C) \\<inter># ?D\n\ngoal (1 subgoal):\n 1. A = A \\<inter># M + (A - M) \\<inter># N", "by blast"], ["proof (state)\nthis:\n  A = A \\<inter># M + (A - M) \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  A = A \\<inter># M + (A - M) \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "have B': \"B = (B - N) \\<inter># M + B\\<inter># N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = (B - N) \\<inter># M + B \\<inter># N", "using A(1) H[of B A N M]"], ["proof (prove)\nusing this:\n  A + B = M + N\n  B + A = N + M \\<Longrightarrow> B = B \\<inter># N + (B - N) \\<inter># M\n\ngoal (1 subgoal):\n 1. B = (B - N) \\<inter># M + B \\<inter># N", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  B = (B - N) \\<inter># M + B \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  B = (B - N) \\<inter># M + B \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "have \"M = A \\<inter># M + (B - N) \\<inter># M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = A \\<inter># M + (B - N) \\<inter># M", "using H[of M N A B] BN_MA[symmetric] A(1)"], ["proof (prove)\nusing this:\n  M + N = A + B \\<Longrightarrow> M = M \\<inter># A + (M - A) \\<inter># B\n  M - A = B - N\n  A + B = M + N\n\ngoal (1 subgoal):\n 1. M = A \\<inter># M + (B - N) \\<inter># M", "by (metis (no_types) diff_intersect_left_idem\n          diff_union_cancelR multiset_inter_commute subset_mset.diff_add subset_mset.inf.cobounded1\n          union_commute)"], ["proof (state)\nthis:\n  M = A \\<inter># M + (B - N) \\<inter># M\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  M = A \\<inter># M + (B - N) \\<inter># M\n\ngoal (1 subgoal):\n 1. P", "have \"N = (A - M) \\<inter># N + B \\<inter># N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = (A - M) \\<inter># N + B \\<inter># N", "by (metis A' assms(1) diff_union_cancelL inter_union_distrib_left inter_union_distrib_right\n          mset_subset_eq_multiset_union_diff_commute subset_mset.inf.cobounded1 subset_mset.inf.commute)"], ["proof (state)\nthis:\n  N = (A - M) \\<inter># N + B \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "ultimately"], ["proof (chain)\npicking this:\n  A = A \\<inter># M + (A - M) \\<inter># N\n  B = (B - N) \\<inter># M + B \\<inter># N\n  M = A \\<inter># M + (B - N) \\<inter># M\n  N = (A - M) \\<inter># N + B \\<inter># N", "show P"], ["proof (prove)\nusing this:\n  A = A \\<inter># M + (A - M) \\<inter># N\n  B = (B - N) \\<inter># M + B \\<inter># N\n  M = A \\<inter># M + (B - N) \\<inter># M\n  N = (A - M) \\<inter># N + B \\<inter># N\n\ngoal (1 subgoal):\n 1. P", "using A(2)"], ["proof (prove)\nusing this:\n  A = A \\<inter># M + (A - M) \\<inter># N\n  B = (B - N) \\<inter># M + B \\<inter># N\n  M = A \\<inter># M + (B - N) \\<inter># M\n  N = (A - M) \\<inter># N + B \\<inter># N\n  \\<lbrakk>A = ?Am + ?An; B = ?Bm + ?Bn; M = ?Am + ?Bm;\n   N = ?An + ?Bn\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Singleton multisets\\<close>"], ["", "lemma mset_size_le1_cases[case_names empty singleton,consumes 1]: \"\\<lbrakk> size M \\<le> Suc 0; M={#} \\<Longrightarrow> P; !!m. M={#m#} \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size M \\<le> Suc 0; M = {#} \\<Longrightarrow> P;\n     \\<And>m. M = {#m#} \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases M) auto"], ["", "lemma diff_union_single_conv2:\n  \"a \\<in># J \\<Longrightarrow> J + I - {#a#} = (J - {#a#}) + I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in># J \\<Longrightarrow> J + I - {#a#} = J - {#a#} + I", "using diff_union_single_conv [of a J I]"], ["proof (prove)\nusing this:\n  a \\<in># J \\<Longrightarrow> I + J - {#a#} = I + (J - {#a#})\n\ngoal (1 subgoal):\n 1. a \\<in># J \\<Longrightarrow> J + I - {#a#} = J - {#a#} + I", "by (simp add: union_ac)"], ["", "lemmas diff_union_single_convs = diff_union_single_conv diff_union_single_conv2"], ["", "lemma mset_contains_eq: \"(m \\<in># M) = ({#m#}+(M-{#m#})=M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<in># M) = ({#m#} + (M - {#m#}) = M)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. add_mset m (M - {#m#}) = M \\<Longrightarrow> m \\<in># M", "assume \"add_mset m (M - {#m#}) = M\""], ["proof (state)\nthis:\n  add_mset m (M - {#m#}) = M\n\ngoal (1 subgoal):\n 1. add_mset m (M - {#m#}) = M \\<Longrightarrow> m \\<in># M", "moreover"], ["proof (state)\nthis:\n  add_mset m (M - {#m#}) = M\n\ngoal (1 subgoal):\n 1. add_mset m (M - {#m#}) = M \\<Longrightarrow> m \\<in># M", "have \"m \\<in># {#m#} + (M - {#m#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in># {#m#} + (M - {#m#})", "by simp"], ["proof (state)\nthis:\n  m \\<in># {#m#} + (M - {#m#})\n\ngoal (1 subgoal):\n 1. add_mset m (M - {#m#}) = M \\<Longrightarrow> m \\<in># M", "ultimately"], ["proof (chain)\npicking this:\n  add_mset m (M - {#m#}) = M\n  m \\<in># {#m#} + (M - {#m#})", "show \"m \\<in># M\""], ["proof (prove)\nusing this:\n  add_mset m (M - {#m#}) = M\n  m \\<in># {#m#} + (M - {#m#})\n\ngoal (1 subgoal):\n 1. m \\<in># M", "by simp"], ["proof (state)\nthis:\n  m \\<in># M\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Pointwise ordering\\<close>"], ["", "lemma mset_le_incr_right1: \"(a::'a multiset)\\<subseteq>#b \\<Longrightarrow> a\\<subseteq>#b+c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b + c", "using mset_subset_eq_mono_add[of a b \"{#}\" c, simplified]"], ["proof (prove)\nusing this:\n  a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b + c\n\ngoal (1 subgoal):\n 1. a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b + c", "."], ["", "lemma mset_le_incr_right2: \"(a::'a multiset)\\<subseteq>#b \\<Longrightarrow> a\\<subseteq>#c+b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># c + b", "using mset_le_incr_right1"], ["proof (prove)\nusing this:\n  ?a \\<subseteq># ?b \\<Longrightarrow> ?a \\<subseteq># ?b + ?c\n\ngoal (1 subgoal):\n 1. a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># c + b", "by (auto simp add: union_commute)"], ["", "lemmas mset_le_incr_right = mset_le_incr_right1 mset_le_incr_right2"], ["", "lemma mset_le_decr_left1: \"(a::'a multiset)+c\\<subseteq>#b \\<Longrightarrow> a\\<subseteq>#b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + c \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "using mset_le_incr_right1 mset_subset_eq_mono_add_right_cancel"], ["proof (prove)\nusing this:\n  ?a \\<subseteq># ?b \\<Longrightarrow> ?a \\<subseteq># ?b + ?c\n  (?A + ?C \\<subseteq># ?B + ?C) = (?A \\<subseteq># ?B)\n\ngoal (1 subgoal):\n 1. a + c \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "by blast"], ["", "lemma mset_le_decr_left2: \"c+(a::'a multiset)\\<subseteq>#b \\<Longrightarrow> a\\<subseteq>#b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c + a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "using mset_le_decr_left1"], ["proof (prove)\nusing this:\n  ?a + ?c \\<subseteq># ?b \\<Longrightarrow> ?a \\<subseteq># ?b\n\ngoal (1 subgoal):\n 1. c + a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "by (auto simp add: union_ac)"], ["", "lemma mset_le_add_mset_decr_left1: \"add_mset c a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> a\\<subseteq>#b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset c a \\<subseteq># b \\<Longrightarrow> a \\<subseteq># b", "by (simp add: mset_subset_eq_insertD subset_mset.dual_order.strict_implies_order)"], ["", "lemma mset_le_add_mset_decr_left2: \"add_mset c a\\<subseteq>#(b::'a multiset) \\<Longrightarrow> {#c#}\\<subseteq>#b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset c a \\<subseteq># b \\<Longrightarrow> {#c#} \\<subseteq># b", "by (simp add: mset_subset_eq_insertD subset_mset.dual_order.strict_implies_order)"], ["", "lemmas mset_le_decr_left = mset_le_decr_left1 mset_le_decr_left2 mset_le_add_mset_decr_left1\n    mset_le_add_mset_decr_left2"], ["", "lemma mset_le_subtract: \"(A::'a multiset)\\<subseteq>#B \\<Longrightarrow> A-C \\<subseteq># B-C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq># B \\<Longrightarrow> A - C \\<subseteq># B - C", "apply (unfold subseteq_mset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. count A a \\<le> count B a \\<Longrightarrow>\n    \\<forall>a. count (A - C) a \\<le> count (B - C) a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>a. count A a \\<le> count B a \\<Longrightarrow>\n       count A a - count C a \\<le> count B a - count C a", "apply (subgoal_tac \"count A a \\<le> count B a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a. count A a \\<le> count B a;\n        count A a \\<le> count B a\\<rbrakk>\n       \\<Longrightarrow> count A a - count C a \\<le> count B a - count C a\n 2. \\<And>a.\n       \\<forall>a. count A a \\<le> count B a \\<Longrightarrow>\n       count A a \\<le> count B a", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>a. count A a \\<le> count B a \\<Longrightarrow>\n       count A a \\<le> count B a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mset_union_subset: \"(A::'a multiset)+B \\<subseteq># C \\<Longrightarrow> A\\<subseteq>#C \\<and> B\\<subseteq>#C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<subseteq># C \\<Longrightarrow>\n    A \\<subseteq># C \\<and> B \\<subseteq># C", "by (auto dest: mset_le_decr_left)"], ["", "lemma mset_le_add_mset: \"add_mset x B \\<subseteq># C \\<Longrightarrow> {#x#}\\<subseteq>#C \\<and> B\\<subseteq>#(C::'a multiset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x B \\<subseteq># C \\<Longrightarrow>\n    {#x#} \\<subseteq># C \\<and> B \\<subseteq># C", "by (auto dest: mset_le_decr_left)"], ["", "lemma mset_le_subtract_left: \"(A::'a multiset)+B \\<subseteq># X \\<Longrightarrow> B \\<subseteq># X-A \\<and> A\\<subseteq>#X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<subseteq># X \\<Longrightarrow>\n    B \\<subseteq># X - A \\<and> A \\<subseteq># X", "by (auto dest: mset_le_subtract[of \"A+B\" \"X\" \"A\"] mset_union_subset)"], ["", "lemma mset_le_subtract_right: \"(A::'a multiset)+B \\<subseteq># X \\<Longrightarrow> A \\<subseteq># X-B \\<and> B\\<subseteq>#X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<subseteq># X \\<Longrightarrow>\n    A \\<subseteq># X - B \\<and> B \\<subseteq># X", "by (auto dest: mset_le_subtract[of \"A+B\" \"X\" \"B\"] mset_union_subset)"], ["", "lemma mset_le_subtract_add_mset_left: \"add_mset x B \\<subseteq># (X::'a multiset) \\<Longrightarrow> B \\<subseteq># X-{#x#} \\<and> {#x#}\\<subseteq>#X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x B \\<subseteq># X \\<Longrightarrow>\n    B \\<subseteq># X - {#x#} \\<and> {#x#} \\<subseteq># X", "by (auto dest: mset_le_subtract[of \"add_mset x B\" \"X\" \"{#x#}\"] mset_le_add_mset)"], ["", "lemma mset_le_subtract_add_mset_right: \"add_mset x B \\<subseteq># (X::'a multiset) \\<Longrightarrow> {#x#} \\<subseteq># X-B \\<and> B\\<subseteq>#X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x B \\<subseteq># X \\<Longrightarrow>\n    {#x#} \\<subseteq># X - B \\<and> B \\<subseteq># X", "by (auto dest: mset_le_subtract[of \"add_mset x B\" \"X\" \"B\"] mset_le_add_mset)"], ["", "lemma mset_le_addE: \"\\<lbrakk> (xs::'a multiset) \\<subseteq># ys; !!zs. ys=xs+zs \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<subseteq># ys;\n     \\<And>zs. ys = xs + zs \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "using mset_subset_eq_exists_conv"], ["proof (prove)\nusing this:\n  (?A \\<subseteq># ?B) = (\\<exists>C. ?B = ?A + C)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<subseteq># ys;\n     \\<And>zs. ys = xs + zs \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by blast"], ["", "declare subset_mset.diff_add[simp, intro]"], ["", "lemma mset_2dist2_cases:\n    assumes A: \"{#a, b#} \\<subseteq># A + B\"\n    assumes CASES: \"{#a, b#} \\<subseteq># A \\<Longrightarrow> P\" \"{#a, b#} \\<subseteq># B \\<Longrightarrow> P\"\n      \"a \\<in># A \\<Longrightarrow> b \\<in># B \\<Longrightarrow> P\" \"a \\<in># B \\<Longrightarrow> b \\<in># A \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from A"], ["proof (chain)\npicking this:\n  {#a, b#} \\<subseteq># A + B", "have \"count A a + count B a \\<ge> 1\"\n      \"count A b + count B b \\<ge> 1\""], ["proof (prove)\nusing this:\n  {#a, b#} \\<subseteq># A + B\n\ngoal (1 subgoal):\n 1. 1 \\<le> count A a + count B a &&& 1 \\<le> count A b + count B b", "using mset_subset_eq_count [of \"{#a, b#}\" \"A + B\" a] mset_subset_eq_count [of \"{#a, b#}\" \"A + B\" b]"], ["proof (prove)\nusing this:\n  {#a, b#} \\<subseteq># A + B\n  {#a, b#} \\<subseteq># A + B \\<Longrightarrow>\n  count {#a, b#} a \\<le> count (A + B) a\n  {#a, b#} \\<subseteq># A + B \\<Longrightarrow>\n  count {#a, b#} b \\<le> count (A + B) b\n\ngoal (1 subgoal):\n 1. 1 \\<le> count A a + count B a &&& 1 \\<le> count A b + count B b", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  1 \\<le> count A a + count B a\n  1 \\<le> count A b + count B b\n\ngoal (1 subgoal):\n 1. P", "then"], ["proof (chain)\npicking this:\n  1 \\<le> count A a + count B a\n  1 \\<le> count A b + count B b", "have B: \"a \\<in># A \\<or> a \\<in># B\"\n      \"b \\<in># A \\<or> b \\<in># B\""], ["proof (prove)\nusing this:\n  1 \\<le> count A a + count B a\n  1 \\<le> count A b + count B b\n\ngoal (1 subgoal):\n 1. a \\<in># A \\<or> a \\<in># B &&& b \\<in># A \\<or> b \\<in># B", "by (auto simp add: not_in_iff Suc_le_eq)"], ["proof (state)\nthis:\n  a \\<in># A \\<or> a \\<in># B\n  b \\<in># A \\<or> b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  a \\<in># A \\<or> a \\<in># B\n  b \\<in># A \\<or> b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "assume C: \"a \\<in># A\" \"b \\<in># A - {#a#}\""], ["proof (state)\nthis:\n  a \\<in># A\n  b \\<in># A - {#a#}\n\ngoal (1 subgoal):\n 1. P", "with mset_subset_eq_mono_add [of \"{#a#}\" \"{#a#}\" \"{#b#}\" \"A-{#a#}\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{#a#} \\<subseteq># {#a#}; {#b#} \\<subseteq># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># {#a#} + (A - {#a#})\n  a \\<in># A\n  b \\<in># A - {#a#}", "have \"{#a, b#} \\<subseteq># A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{#a#} \\<subseteq># {#a#}; {#b#} \\<subseteq># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># {#a#} + (A - {#a#})\n  a \\<in># A\n  b \\<in># A - {#a#}\n\ngoal (1 subgoal):\n 1. {#a, b#} \\<subseteq># A", "by (auto simp: add_mset_commute)"], ["proof (state)\nthis:\n  {#a, b#} \\<subseteq># A\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># A\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># A\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># A\n\ngoal (1 subgoal):\n 1. P", "assume C: \"a \\<in># A\" \"b \\<notin># A - {#a#}\""], ["proof (state)\nthis:\n  a \\<in># A\n  b \\<notin># A - {#a#}\n\ngoal (1 subgoal):\n 1. P", "with B A"], ["proof (chain)\npicking this:\n  a \\<in># A \\<or> a \\<in># B\n  b \\<in># A \\<or> b \\<in># B\n  {#a, b#} \\<subseteq># A + B\n  a \\<in># A\n  b \\<notin># A - {#a#}", "have \"b \\<in># B\""], ["proof (prove)\nusing this:\n  a \\<in># A \\<or> a \\<in># B\n  b \\<in># A \\<or> b \\<in># B\n  {#a, b#} \\<subseteq># A + B\n  a \\<in># A\n  b \\<notin># A - {#a#}\n\ngoal (1 subgoal):\n 1. b \\<in># B", "by (auto simp: insert_subset_eq_iff diff_union_single_convs\n            simp del: subset_mset.add_diff_assoc2)"], ["proof (state)\nthis:\n  b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n\ngoal (1 subgoal):\n 1. P", "assume C: \"a \\<notin># A\" \"b \\<in># B - {#a#}\""], ["proof (state)\nthis:\n  a \\<notin># A\n  b \\<in># B - {#a#}\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  {#a, b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<in># B - {#a#}", "have \"a \\<in># B\""], ["proof (prove)\nusing this:\n  {#a, b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<in># B - {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># B", "using B"], ["proof (prove)\nusing this:\n  {#a, b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<in># B - {#a#}\n  a \\<in># A \\<or> a \\<in># B\n  b \\<in># A \\<or> b \\<in># B\n\ngoal (1 subgoal):\n 1. a \\<in># B", "by blast"], ["proof (state)\nthis:\n  a \\<in># B\n\ngoal (1 subgoal):\n 1. P", "with C mset_subset_eq_mono_add [of \"{#a#}\" \"{#a#}\" \"{#b#}\" \"B-{#a#}\"]"], ["proof (chain)\npicking this:\n  a \\<notin># A\n  b \\<in># B - {#a#}\n  \\<lbrakk>{#a#} \\<subseteq># {#a#}; {#b#} \\<subseteq># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># {#a#} + (B - {#a#})\n  a \\<in># B", "have \"{#a, b#} \\<subseteq># B\""], ["proof (prove)\nusing this:\n  a \\<notin># A\n  b \\<in># B - {#a#}\n  \\<lbrakk>{#a#} \\<subseteq># {#a#}; {#b#} \\<subseteq># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a#} + {#b#} \\<subseteq># {#a#} + (B - {#a#})\n  a \\<in># B\n\ngoal (1 subgoal):\n 1. {#a, b#} \\<subseteq># B", "by (auto simp: add_mset_commute)"], ["proof (state)\nthis:\n  {#a, b#} \\<subseteq># B\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># B\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># B\n\ngoal (1 subgoal):\n 1. P", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># B\n\ngoal (1 subgoal):\n 1. P", "assume C: \"a \\<notin># A\" \"b \\<notin># B - {#a#}\""], ["proof (state)\nthis:\n  a \\<notin># A\n  b \\<notin># B - {#a#}\n\ngoal (1 subgoal):\n 1. P", "with A"], ["proof (chain)\npicking this:\n  {#a, b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<notin># B - {#a#}", "have \"a \\<in># B \\<and> b \\<in># A\""], ["proof (prove)\nusing this:\n  {#a, b#} \\<subseteq># A + B\n  a \\<notin># A\n  b \\<notin># B - {#a#}\n\ngoal (1 subgoal):\n 1. a \\<in># B \\<and> b \\<in># A", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{#a, b#} \\<subseteq># A + B; a \\<notin># A;\n     b \\<notin># B - {#a#}\\<rbrakk>\n    \\<Longrightarrow> a \\<in># B\n 2. \\<lbrakk>{#a, b#} \\<subseteq># A + B; a \\<notin># A;\n     b \\<notin># B - {#a#}\\<rbrakk>\n    \\<Longrightarrow> b \\<in># A", "apply (auto dest!: mset_subset_eq_insertD simp: insert_union_subset_iff; fail)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{#a, b#} \\<subseteq># A + B; a \\<notin># A;\n     b \\<notin># B - {#a#}\\<rbrakk>\n    \\<Longrightarrow> b \\<in># A", "by (metis (no_types, lifting) B(1) add_mset_remove_trivial insert_DiffM2 \n            mset_diff_cancel1elem single_subset_iff subset_eq_diff_conv subset_mset.diff_diff_right\n            union_single_eq_member)"], ["proof (state)\nthis:\n  a \\<in># B \\<and> b \\<in># A\n\ngoal (1 subgoal):\n 1. P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin># A; b \\<notin># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> a \\<in># B \\<and> b \\<in># A\n\ngoal (1 subgoal):\n 1. P", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># A\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># B\n  \\<lbrakk>a \\<notin># A; b \\<notin># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> a \\<in># B \\<and> b \\<in># A", "show P"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># A\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># B\n  \\<lbrakk>a \\<notin># A; b \\<notin># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> a \\<in># B \\<and> b \\<in># A\n\ngoal (1 subgoal):\n 1. P", "using CASES"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in># A; b \\<in># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># A\n  \\<lbrakk>a \\<in># A; b \\<notin># A - {#a#}\\<rbrakk>\n  \\<Longrightarrow> b \\<in># B\n  \\<lbrakk>a \\<notin># A; b \\<in># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> {#a, b#} \\<subseteq># B\n  \\<lbrakk>a \\<notin># A; b \\<notin># B - {#a#}\\<rbrakk>\n  \\<Longrightarrow> a \\<in># B \\<and> b \\<in># A\n  {#a, b#} \\<subseteq># A \\<Longrightarrow> P\n  {#a, b#} \\<subseteq># B \\<Longrightarrow> P\n  \\<lbrakk>a \\<in># A; b \\<in># B\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>a \\<in># B; b \\<in># A\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_union_subset_s: \"{#a#}+B \\<subseteq># C \\<Longrightarrow> a \\<in># C \\<and> B \\<subseteq># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a#} + B \\<subseteq># C \\<Longrightarrow>\n    a \\<in># C \\<and> B \\<subseteq># C", "by (drule mset_union_subset) simp"], ["", "lemma mset_le_single_cases[consumes 1, case_names empty singleton]: \"\\<lbrakk>M\\<subseteq>#{#a#}; M={#} \\<Longrightarrow> P; M={#a#} \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<subseteq># {#a#}; M = {#} \\<Longrightarrow> P;\n     M = {#a#} \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct M) auto"], ["", "lemma mset_le_distrib[consumes 1, case_names dist]: \"\\<lbrakk>X\\<subseteq>#(A::'a multiset)+B; !!Xa Xb. \\<lbrakk>X=Xa+Xb; Xa\\<subseteq>#A; Xb\\<subseteq>#B\\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq># A + B;\n     \\<And>Xa Xb.\n        \\<lbrakk>X = Xa + Xb; Xa \\<subseteq># A; Xb \\<subseteq># B\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto elim!: mset_le_addE mset_distrib)"], ["", "lemma mset_le_mono_add_single: \"\\<lbrakk>a \\<in># ys; b \\<in># ws\\<rbrakk> \\<Longrightarrow> {#a, b#} \\<subseteq># ys + ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># ys; b \\<in># ws\\<rbrakk>\n    \\<Longrightarrow> {#a, b#} \\<subseteq># ys + ws", "using mset_subset_eq_mono_add[of \"{#a#}\" _ \"{#b#}\", simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in># ?B; b \\<in># ?D\\<rbrakk>\n  \\<Longrightarrow> {#b, a#} \\<subseteq># ?B + ?D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># ys; b \\<in># ws\\<rbrakk>\n    \\<Longrightarrow> {#a, b#} \\<subseteq># ys + ws", "by (simp add: add_mset_commute)"], ["", "lemma mset_size1elem: \"\\<lbrakk>size P \\<le> 1; q \\<in># P\\<rbrakk> \\<Longrightarrow> P={#q#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size P \\<le> 1; q \\<in># P\\<rbrakk> \\<Longrightarrow> P = {#q#}", "by (auto elim: mset_size_le1_cases)"], ["", "lemma mset_size2elem: \"\\<lbrakk>size P \\<le> 2; {#q#}+{#q'#} \\<subseteq># P\\<rbrakk> \\<Longrightarrow> P={#q#}+{#q'#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size P \\<le> 2; {#q#} + {#q'#} \\<subseteq># P\\<rbrakk>\n    \\<Longrightarrow> P = {#q#} + {#q'#}", "by (auto elim: mset_le_addE)"], ["", "subsubsection \\<open>Image under function\\<close>"], ["", "notation image_mset (infixr \"`#\" 90)"], ["", "lemma mset_map_single_rightE[consumes 1, case_names orig]: \"\\<lbrakk>f `# P = {#y#}; !!x. \\<lbrakk> P={#x#}; f x = y \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f `# P = {#y#};\n     \\<And>x.\n        \\<lbrakk>P = {#x#}; f x = y\\<rbrakk> \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by (cases P) auto"], ["", "lemma mset_map_split_orig: \"!!M1 M2. \\<lbrakk>f `# P = M1+M2; !!P1 P2. \\<lbrakk>P=P1+P2; f `# P1 = M1; f `# P2 = M2\\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M1 M2.\n       \\<lbrakk>f `# P = M1 + M2;\n        \\<And>P1 P2.\n           \\<lbrakk>P = P1 + P2; f `# P1 = M1; f `# P2 = M2\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (induct P)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M1 M2.\n       \\<lbrakk>f `# {#} = M1 + M2;\n        \\<And>P1 P2.\n           \\<lbrakk>{#} = P1 + P2; f `# P1 = M1; f `# P2 = M2\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>x P M1 M2.\n       \\<lbrakk>\\<And>M1 M2.\n                   \\<lbrakk>f `# P = M1 + M2;\n                    \\<And>P1 P2.\n                       \\<lbrakk>P = P1 + P2; f `# P1 = M1;\n                        f `# P2 = M2\\<rbrakk>\n                       \\<Longrightarrow> Q\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        f `# add_mset x P = M1 + M2;\n        \\<And>P1 P2.\n           \\<lbrakk>add_mset x P = P1 + P2; f `# P1 = M1;\n            f `# P2 = M2\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x P M1 M2.\n       \\<lbrakk>\\<And>M1 M2.\n                   \\<lbrakk>f `# P = M1 + M2;\n                    \\<And>P1 P2.\n                       \\<lbrakk>P = P1 + P2; f `# P1 = M1;\n                        f `# P2 = M2\\<rbrakk>\n                       \\<Longrightarrow> Q\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        f `# add_mset x P = M1 + M2;\n        \\<And>P1 P2.\n           \\<lbrakk>add_mset x P = P1 + P2; f `# P1 = M1;\n            f `# P2 = M2\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (force elim!: mset_un_single_un_cases simp add: union_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* TODO: This proof need's quite long. Try to write a faster one. *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mset_map_id: \"\\<lbrakk>!!x. f (g x) = x\\<rbrakk> \\<Longrightarrow> f `# g `# X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f (g x) = x) \\<Longrightarrow> f `# g `# X = X", "by (induct X) auto"], ["", "text \\<open>The following is a very specialized lemma. Intuitively, it splits the original multiset\\<close>"], ["", "text \\<open>The following is a very specialized   by a splitting of some pointwise supermultiset of its image.\n\n  Application:\n  This lemma came in handy when proving the correctness of a constraint system that collects at most k sized submultisets of the sets of spawned threads.\n\\<close>"], ["", "lemma mset_map_split_orig_le: assumes A: \"f `# P \\<subseteq># M1+M2\" and EX: \"!!P1 P2. \\<lbrakk>P=P1+P2; f `# P1 \\<subseteq># M1; f `# P2 \\<subseteq># M2\\<rbrakk> \\<Longrightarrow> Q\" shows \"Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q", "using A EX"], ["proof (prove)\nusing this:\n  f `# P \\<subseteq># M1 + M2\n  \\<lbrakk>P = ?P1.0 + ?P2.0; f `# ?P1.0 \\<subseteq># M1;\n   f `# ?P2.0 \\<subseteq># M2\\<rbrakk>\n  \\<Longrightarrow> Q\n\ngoal (1 subgoal):\n 1. Q", "by (auto elim: mset_le_distrib mset_map_split_orig)"], ["", "subsection \\<open>Lists\\<close>"], ["", "subsubsection \\<open>Reverse lists\\<close>"], ["", "lemma list_rev_decomp[rule_format]: \"l~=[] \\<longrightarrow> (EX ll e . l = ll@[e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<longrightarrow> (\\<exists>ll e. l = ll @ [e])", "apply(induct_tac l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow> (\\<exists>ll e. [] = ll @ [e])\n 2. \\<And>a list.\n       list \\<noteq> [] \\<longrightarrow>\n       (\\<exists>ll e. list = ll @ [e]) \\<Longrightarrow>\n       a # list \\<noteq> [] \\<longrightarrow>\n       (\\<exists>ll e. a # list = ll @ [e])", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Was already there as rev_induct\n  lemma list_rev_induct: \"\\<lbrakk>P []; !! l e . P l \\<Longrightarrow> P (l@[e]) \\<rbrakk> \\<Longrightarrow> P l\"\n    by (blast intro: rev_induct)\n  proof (induct l rule: measure_induct[of length])\n    fix x :: \"'a list\"\n    assume A: \"\\<forall>y. length y < length x \\<longrightarrow> P [] \\<longrightarrow> (\\<forall>x xa. P (x::'a list) \\<longrightarrow> P (x @ [xa])) \\<longrightarrow> P y\" \"P []\" and IS: \"\\<And>l e. P l \\<Longrightarrow> P (l @ [e])\"\n    show \"P x\" proof (cases \"x=[]\")\n      assume \"x=[]\" with A show ?thesis by simp\n    next\n      assume CASE: \"x~=[]\"\n      then obtain xx e where DECOMP: \"x=xx@[e]\" by (blast dest: list_rev_decomp)\n      hence LEN: \"length xx < length x\" by auto\n      with A IS have \"P xx\" by auto\n      with IS have \"P (xx@[e])\" by auto\n      with DECOMP show ?thesis by auto\n    qed\n  qed\n  *)"], ["", "text \\<open>Caution: Same order of case variables in snoc-case as @{thm [source] rev_exhaust}, the other way round than @{thm [source] rev_induct} !\\<close>"], ["", "lemma length_compl_rev_induct[case_names Nil snoc]: \"\\<lbrakk>P []; !! l e . \\<lbrakk>!! ll . length ll <= length l \\<Longrightarrow> P ll\\<rbrakk> \\<Longrightarrow> P (l@[e])\\<rbrakk> \\<Longrightarrow> P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P [];\n     \\<And>l e.\n        (\\<And>ll.\n            length ll \\<le> length l \\<Longrightarrow>\n            P ll) \\<Longrightarrow>\n        P (l @ [e])\\<rbrakk>\n    \\<Longrightarrow> P l", "apply(induct_tac l rule: length_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>P [];\n        \\<And>l e.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (l @ [e]);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> P xs", "apply(case_tac \"xs\" rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>P [];\n        \\<And>l e.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (l @ [e]);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs = []\\<rbrakk>\n       \\<Longrightarrow> P xs\n 2. \\<And>xs ys y.\n       \\<lbrakk>P [];\n        \\<And>l e.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (l @ [e]);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> P xs", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_append_eq_Cons_cases: \"\\<lbrakk>ys@zs = x#xs; \\<lbrakk>ys=[]; zs=x#xs\\<rbrakk> \\<Longrightarrow> P; !!ys'. \\<lbrakk> ys=x#ys'; ys'@zs=xs \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys @ zs = x # xs;\n     \\<lbrakk>ys = []; zs = x # xs\\<rbrakk> \\<Longrightarrow> P;\n     \\<And>ys'.\n        \\<lbrakk>ys = x # ys'; ys' @ zs = xs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto iff add: append_eq_Cons_conv)"], ["", "lemma list_Cons_eq_append_cases: \"\\<lbrakk>x#xs = ys@zs; \\<lbrakk>ys=[]; zs=x#xs\\<rbrakk> \\<Longrightarrow> P; !!ys'. \\<lbrakk> ys=x#ys'; ys'@zs=xs \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x # xs = ys @ zs;\n     \\<lbrakk>ys = []; zs = x # xs\\<rbrakk> \\<Longrightarrow> P;\n     \\<And>ys'.\n        \\<lbrakk>ys = x # ys'; ys' @ zs = xs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto iff add: Cons_eq_append_conv)"], ["", "subsubsection \"folding\""], ["", "text \"Ugly lemma about foldl over associative operator with left and right neutral element\""], ["", "lemma foldl_A1_eq: \"!!i. \\<lbrakk> !! e. f n e = e; !! e. f e n = e; !!a b c. f a (f b c) = f (f a b) c \\<rbrakk> \\<Longrightarrow> foldl f i ww = f i (foldl f n ww)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i ww = f i (foldl f n ww)", "proof (induct ww)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i [] = f i (foldl f n [])\n 2. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "case Nil"], ["proof (state)\nthis:\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i [] = f i (foldl f n [])\n 2. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "thus ?case"], ["proof (prove)\nusing this:\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. foldl f i [] = f i (foldl f n [])", "by simp"], ["proof (state)\nthis:\n  foldl f i [] = f i (foldl f n [])\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "case (Cons a ww i)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n   \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n  \\<Longrightarrow> foldl f ?i ww = f ?i (foldl f n ww)\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "note IHP[simplified]=this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n   \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n  \\<Longrightarrow> foldl f ?i ww = f ?i (foldl f n ww)\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "have \"foldl f i (a # ww) = foldl f (f i a) ww\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f i (a # ww) = foldl f (f i a) ww", "by simp"], ["proof (state)\nthis:\n  foldl f i (a # ww) = foldl f (f i a) ww\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  foldl f i (a # ww) = foldl f (f i a) ww\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "from IHP"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n   \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n  \\<Longrightarrow> foldl f ?i ww = f ?i (foldl f n ww)\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c", "have \"\\<dots> = f (f i a) (foldl f n ww)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n   \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n  \\<Longrightarrow> foldl f ?i ww = f ?i (foldl f n ww)\n  f n ?e = ?e\n  f ?e n = ?e\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. foldl f (f i a) ww = f (f i a) (foldl f n ww)", "by blast"], ["proof (state)\nthis:\n  foldl f (f i a) ww = f (f i a) (foldl f n ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  foldl f (f i a) ww = f (f i a) (foldl f n ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "from IHP(4)"], ["proof (chain)\npicking this:\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c", "have \"\\<dots> = f i (f a (foldl f n ww))\""], ["proof (prove)\nusing this:\n  f ?a (f ?b ?c) = f (f ?a ?b) ?c\n\ngoal (1 subgoal):\n 1. f (f i a) (foldl f n ww) = f i (f a (foldl f n ww))", "by simp"], ["proof (state)\nthis:\n  f (f i a) (foldl f n ww) = f i (f a (foldl f n ww))\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  f (f i a) (foldl f n ww) = f i (f a (foldl f n ww))\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "from IHP(1)[OF IHP(2,3,4), where i=a]"], ["proof (chain)\npicking this:\n  foldl f a ww = f a (foldl f n ww)", "have \"\\<dots> = f i (foldl f a ww)\""], ["proof (prove)\nusing this:\n  foldl f a ww = f a (foldl f n ww)\n\ngoal (1 subgoal):\n 1. f i (f a (foldl f n ww)) = f i (foldl f a ww)", "by simp"], ["proof (state)\nthis:\n  f i (f a (foldl f n ww)) = f i (foldl f a ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  f i (f a (foldl f n ww)) = f i (foldl f a ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "from IHP(2)[of a]"], ["proof (chain)\npicking this:\n  f n a = a", "have \"\\<dots> = f i (foldl f (f n a) ww)\""], ["proof (prove)\nusing this:\n  f n a = a\n\ngoal (1 subgoal):\n 1. f i (foldl f a ww) = f i (foldl f (f n a) ww)", "by simp"], ["proof (state)\nthis:\n  f i (foldl f a ww) = f i (foldl f (f n a) ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "also"], ["proof (state)\nthis:\n  f i (foldl f a ww) = f i (foldl f (f n a) ww)\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "have \"\\<dots> = f i (foldl f n (a#ww))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i (foldl f (f n a) ww) = f i (foldl f n (a # ww))", "by simp"], ["proof (state)\nthis:\n  f i (foldl f (f n a) ww) = f i (foldl f n (a # ww))\n\ngoal (1 subgoal):\n 1. \\<And>a ww i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>e. f n e = e; \\<And>e. f e n = e;\n                    \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n                   \\<Longrightarrow> foldl f i ww = f i (foldl f n ww);\n        \\<And>e. f n e = e; \\<And>e. f e n = e;\n        \\<And>a b c. f a (f b c) = f (f a b) c\\<rbrakk>\n       \\<Longrightarrow> foldl f i (a # ww) = f i (foldl f n (a # ww))", "finally"], ["proof (chain)\npicking this:\n  foldl f i (a # ww) = f i (foldl f n (a # ww))", "show ?case"], ["proof (prove)\nusing this:\n  foldl f i (a # ww) = f i (foldl f n (a # ww))\n\ngoal (1 subgoal):\n 1. foldl f i (a # ww) = f i (foldl f n (a # ww))", "."], ["proof (state)\nthis:\n  foldl f i (a # ww) = f i (foldl f n (a # ww))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas foldl_conc_empty_eq = foldl_A1_eq[of \"(@)\" \"[]\", simplified]"], ["", "lemmas foldl_un_empty_eq = foldl_A1_eq[of \"(\\<union>)\" \"{}\", simplified, OF Un_assoc[symmetric]]"], ["", "lemma foldl_set: \"foldl (\\<union>) {} l = \\<Union>{x. x\\<in>set l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<union>) {} l = \\<Union> {x. x \\<in> set l}", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. foldl (\\<union>) {} [] = \\<Union> {x. x \\<in> set []}\n 2. \\<And>a l.\n       foldl (\\<union>) {} l = \\<Union> {x. x \\<in> set l} \\<Longrightarrow>\n       foldl (\\<union>) {} (a # l) = \\<Union> {x. x \\<in> set (a # l)}", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       foldl (\\<union>) {} l = \\<Union> (set l) \\<Longrightarrow>\n       foldl (\\<union>) a l = \\<Union> {x. x = a \\<or> x \\<in> set l}", "apply (subst foldl_un_empty_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       foldl (\\<union>) {} l = \\<Union> (set l) \\<Longrightarrow>\n       a \\<union> foldl (\\<union>) {} l =\n       \\<Union> {x. x = a \\<or> x \\<in> set l}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Miscellaneous\\<close>"], ["", "lemma length_compl_induct[case_names Nil Cons]: \"\\<lbrakk>P []; !! e l . \\<lbrakk>!! ll . length ll <= length l \\<Longrightarrow> P ll\\<rbrakk> \\<Longrightarrow> P (e#l)\\<rbrakk> \\<Longrightarrow> P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P [];\n     \\<And>e l.\n        (\\<And>ll.\n            length ll \\<le> length l \\<Longrightarrow>\n            P ll) \\<Longrightarrow>\n        P (e # l)\\<rbrakk>\n    \\<Longrightarrow> P l", "apply(induct_tac l rule: length_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>P [];\n        \\<And>e l.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (e # l);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> P xs", "apply(case_tac \"xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>P [];\n        \\<And>e l.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (e # l);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs = []\\<rbrakk>\n       \\<Longrightarrow> P xs\n 2. \\<And>xs a list.\n       \\<lbrakk>P [];\n        \\<And>e l.\n           (\\<And>ll.\n               length ll \\<le> length l \\<Longrightarrow>\n               P ll) \\<Longrightarrow>\n           P (e # l);\n        \\<forall>ys. length ys < length xs \\<longrightarrow> P ys;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> P xs", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Simultaneous induction over two lists, prepending an element to one of the lists in each step\\<close>"], ["", "lemma list_2pre_induct[case_names base left right]: assumes BASE: \"P [] []\" and LEFT: \"!!e w1' w2. P w1' w2 \\<Longrightarrow> P (e#w1') w2\" and RIGHT: \"!!e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e#w2')\" shows \"P w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P w1 w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P w1 w2", "{ \\<comment> \\<open>The proof is done by induction over the sum of the lengths of the lists\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. P w1 w2", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. P w1 w2", "have \"!!w1 w2. \\<lbrakk>length w1 + length w2 = n; P [] []; !!e w1' w2. P w1' w2 \\<Longrightarrow> P (e#w1') w2; !!e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e#w2') \\<rbrakk> \\<Longrightarrow> P w1 w2 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>length w1 + length w2 = n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P w1 w2", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w1 w2.\n       \\<lbrakk>length w1 + length w2 = 0; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P w1 w2\n 2. \\<And>n w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   \\<lbrakk>length w1 + length w2 = n; P [] [];\n                    \\<And>e w1' w2.\n                       P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n                    \\<And>e w1 w2'.\n                       P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n                   \\<Longrightarrow> P w1 w2;\n        length w1 + length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P w1 w2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   \\<lbrakk>length w1 + length w2 = n; P [] [];\n                    \\<And>e w1' w2.\n                       P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n                    \\<And>e w1 w2'.\n                       P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n                   \\<Longrightarrow> P w1 w2;\n        length w1 + length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P w1 w2", "apply (case_tac w1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   \\<lbrakk>length w1 + length w2 = n; P [] [];\n                    \\<And>e w1' w2.\n                       P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n                    \\<And>e w1 w2'.\n                       P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n                   \\<Longrightarrow> P w1 w2;\n        length w1 + length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2');\n        w1 = []\\<rbrakk>\n       \\<Longrightarrow> P w1 w2\n 2. \\<And>n w1 w2 a list.\n       \\<lbrakk>\\<And>w1 w2.\n                   \\<lbrakk>length w1 + length w2 = n; P [] [];\n                    \\<And>e w1' w2.\n                       P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n                    \\<And>e w1 w2'.\n                       P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n                   \\<Longrightarrow> P w1 w2;\n        length w1 + length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2');\n        w1 = a # list\\<rbrakk>\n       \\<Longrightarrow> P w1 w2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   length w1 + length w2 = n \\<Longrightarrow> P w1 w2;\n        length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n       \\<Longrightarrow> P [] w2", "apply (case_tac w2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   length w1 + length w2 = n \\<Longrightarrow> P w1 w2;\n        length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2');\n        w2 = []\\<rbrakk>\n       \\<Longrightarrow> P [] w2\n 2. \\<And>n w2 a list.\n       \\<lbrakk>\\<And>w1 w2.\n                   length w1 + length w2 = n \\<Longrightarrow> P w1 w2;\n        length w2 = Suc n; P [] [];\n        \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n        \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2');\n        w2 = a # list\\<rbrakk>\n       \\<Longrightarrow> P [] w2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>length ?w1.0 + length ?w2.0 = n; P [] [];\n   \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n   \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 ?w2.0\n\ngoal (1 subgoal):\n 1. P w1 w2", "}"], ["proof (state)\nthis:\n  \\<lbrakk>length ?w1.0 + length ?w2.0 = ?n3; P [] [];\n   \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P (e # w1') w2;\n   \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 (e # w2')\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 ?w2.0\n\ngoal (1 subgoal):\n 1. P w1 w2", "from this[OF _ BASE LEFT RIGHT]"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?w1.0 + length ?w2.0 = ?n3;\n   \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P w1' w2;\n   \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 w2'\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 ?w2.0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?w1.0 + length ?w2.0 = ?n3;\n   \\<And>e w1' w2. P w1' w2 \\<Longrightarrow> P w1' w2;\n   \\<And>e w1 w2'. P w1 w2' \\<Longrightarrow> P w1 w2'\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 ?w2.0\n\ngoal (1 subgoal):\n 1. P w1 w2", "by blast"], ["proof (state)\nthis:\n  P w1 w2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_decomp_1: \"length l=1 \\<Longrightarrow> EX a . l=[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = 1 \\<Longrightarrow> \\<exists>a. l = [a]", "by (case_tac l, auto)"], ["", "lemma list_decomp_2: \"length l=2 \\<Longrightarrow> EX a b . l=[a,b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = 2 \\<Longrightarrow> \\<exists>a b. l = [a, b]", "by (case_tac l, auto simp add: list_decomp_1)"], ["", "lemma drop_all_conc: \"drop (length a) (a@b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (length a) (a @ b) = b", "by (simp)"], ["", "lemma list_rest_coinc: \"\\<lbrakk>length s2 <= length s1; s1@r1 = s2@r2\\<rbrakk> \\<Longrightarrow> EX r1p . r2=r1p@r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "assume A: \"length s2 <= length s1\" \"s1@r1 = s2@r2\""], ["proof (state)\nthis:\n  length s2 \\<le> length s1\n  s1 @ r1 = s2 @ r2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "hence \"r1 = drop (length s1) (s2@r2)\""], ["proof (prove)\nusing this:\n  length s2 \\<le> length s1\n  s1 @ r1 = s2 @ r2\n\ngoal (1 subgoal):\n 1. r1 = drop (length s1) (s2 @ r2)", "by (auto simp only:drop_all_conc dest: sym)"], ["proof (state)\nthis:\n  r1 = drop (length s1) (s2 @ r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "moreover"], ["proof (state)\nthis:\n  r1 = drop (length s1) (s2 @ r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "from A"], ["proof (chain)\npicking this:\n  length s2 \\<le> length s1\n  s1 @ r1 = s2 @ r2", "have \"length s1 = length s1 - length s2 + length s2\""], ["proof (prove)\nusing this:\n  length s2 \\<le> length s1\n  s1 @ r1 = s2 @ r2\n\ngoal (1 subgoal):\n 1. length s1 = length s1 - length s2 + length s2", "by arith"], ["proof (state)\nthis:\n  length s1 = length s1 - length s2 + length s2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "ultimately"], ["proof (chain)\npicking this:\n  r1 = drop (length s1) (s2 @ r2)\n  length s1 = length s1 - length s2 + length s2", "have \"r1 = drop ((length s1 - length s2)) r2\""], ["proof (prove)\nusing this:\n  r1 = drop (length s1) (s2 @ r2)\n  length s1 = length s1 - length s2 + length s2\n\ngoal (1 subgoal):\n 1. r1 = drop (length s1 - length s2) r2", "by (auto)"], ["proof (state)\nthis:\n  r1 = drop (length s1 - length s2) r2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "hence \"r2 = take ((length s1 - length s2)) r2 @ r1\""], ["proof (prove)\nusing this:\n  r1 = drop (length s1 - length s2) r2\n\ngoal (1 subgoal):\n 1. r2 = take (length s1 - length s2) r2 @ r1", "by auto"], ["proof (state)\nthis:\n  r2 = take (length s1 - length s2) r2 @ r1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length s2 \\<le> length s1; s1 @ r1 = s2 @ r2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r1p. r2 = r1p @ r1", "thus ?thesis"], ["proof (prove)\nusing this:\n  r2 = take (length s1 - length s2) r2 @ r1\n\ngoal (1 subgoal):\n 1. \\<exists>r1p. r2 = r1p @ r1", "by auto"], ["proof (state)\nthis:\n  \\<exists>r1p. r2 = r1p @ r1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_tail_coinc: \"n1#r1 = n2#r2 \\<Longrightarrow> n1=n2 & r1=r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n1 # r1 = n2 # r2 \\<Longrightarrow> n1 = n2 \\<and> r1 = r2", "by (auto)"], ["", "lemma last_in_set[intro]: \"\\<lbrakk>l\\<noteq>[]\\<rbrakk> \\<Longrightarrow> last l \\<in> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> last l \\<in> set l", "by (induct l) auto"], ["", "subsection \\<open>Induction on nat\\<close>"], ["", "lemma nat_compl_induct[case_names 0 Suc]: \"\\<lbrakk>P 0; !! n . ALL nn . nn <= n \\<longrightarrow> P nn \\<Longrightarrow> P (Suc n)\\<rbrakk> \\<Longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P 0;\n     \\<And>n. \\<forall>nn\\<le>n. P nn \\<Longrightarrow> P (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P n", "apply(induct_tac n rule: nat_less_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>P 0;\n        \\<And>n. \\<forall>nn\\<le>n. P nn \\<Longrightarrow> P (Suc n);\n        \\<forall>m<n. P m\\<rbrakk>\n       \\<Longrightarrow> P n", "apply(case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>P 0;\n        \\<And>n. \\<forall>nn\\<le>n. P nn \\<Longrightarrow> P (Suc n);\n        \\<forall>m<n. P m; n = 0\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n nat.\n       \\<lbrakk>P 0;\n        \\<And>n. \\<forall>nn\\<le>n. P nn \\<Longrightarrow> P (Suc n);\n        \\<forall>m<n. P m; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> P n", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Functions of type @{typ \"bool\\<Rightarrow>bool\"}\\<close>"], ["", "lemma boolfun_cases_helper: \"g=(\\<lambda>x. False) | g=(\\<lambda>x. x) | g=(\\<lambda>x. True) | g= (\\<lambda>x. \\<not>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "assume \"g False\" \"g True\""], ["proof (state)\nthis:\n  g False\n  g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "hence \"g = (\\<lambda>x. True)\""], ["proof (prove)\nusing this:\n  g False\n  g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. True)", "by (rule_tac ext, case_tac x, auto)"], ["proof (state)\nthis:\n  g = (\\<lambda>x. True)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "{"], ["proof (state)\nthis:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "assume \"g False\" \"\\<not>g True\""], ["proof (state)\nthis:\n  g False\n  \\<not> g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "hence \"g = (\\<lambda>x. \\<not>x)\""], ["proof (prove)\nusing this:\n  g False\n  \\<not> g True\n\ngoal (1 subgoal):\n 1. g = Not", "by (rule_tac ext, case_tac x, auto)"], ["proof (state)\nthis:\n  g = Not\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "{"], ["proof (state)\nthis:\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "assume \"\\<not>g False\" \"g True\""], ["proof (state)\nthis:\n  \\<not> g False\n  g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "hence \"g = (\\<lambda>x. x)\""], ["proof (prove)\nusing this:\n  \\<not> g False\n  g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. x)", "by (rule_tac ext, case_tac x, auto)"], ["proof (state)\nthis:\n  g = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "assume \"\\<not>g False\" \"\\<not>g True\""], ["proof (state)\nthis:\n  \\<not> g False\n  \\<not> g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "hence \"g = (\\<lambda>x. False)\""], ["proof (prove)\nusing this:\n  \\<not> g False\n  \\<not> g True\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False)", "by (rule_tac ext, case_tac x, auto)"], ["proof (state)\nthis:\n  g = (\\<lambda>x. False)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> g False; \\<not> g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. False)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n  \\<lbrakk>\\<not> g False; \\<not> g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. False)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>g False; g True\\<rbrakk> \\<Longrightarrow> g = (\\<lambda>x. True)\n  \\<lbrakk>g False; \\<not> g True\\<rbrakk> \\<Longrightarrow> g = Not\n  \\<lbrakk>\\<not> g False; g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. x)\n  \\<lbrakk>\\<not> g False; \\<not> g True\\<rbrakk>\n  \\<Longrightarrow> g = (\\<lambda>x. False)\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>x. False) \\<or>\n    g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not", "by fast"], ["proof (state)\nthis:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma boolfun_cases[case_names False Id True Neg]: \"\\<lbrakk>g=(\\<lambda>x. False) \\<Longrightarrow> P g; g=(\\<lambda>x. x) \\<Longrightarrow> P g; g=(\\<lambda>x. True) \\<Longrightarrow> P g; g=(\\<lambda>x. \\<not>x) \\<Longrightarrow> P g\\<rbrakk> \\<Longrightarrow> P g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P g;\n     g = Not \\<Longrightarrow> P g\\<rbrakk>\n    \\<Longrightarrow> P g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P g;\n     g = Not \\<Longrightarrow> P g\\<rbrakk>\n    \\<Longrightarrow> P g", "note boolfun_cases_helper[of g]"], ["proof (state)\nthis:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P g;\n     g = Not \\<Longrightarrow> P g\\<rbrakk>\n    \\<Longrightarrow> P g", "moreover"], ["proof (state)\nthis:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P g;\n     g = Not \\<Longrightarrow> P g\\<rbrakk>\n    \\<Longrightarrow> P g", "assume \"g=(\\<lambda>x. False) \\<Longrightarrow> P g\" \"g=(\\<lambda>x. x) \\<Longrightarrow> P g\" \"g=(\\<lambda>x. True) \\<Longrightarrow> P g\" \"g=(\\<lambda>x. \\<not>x) \\<Longrightarrow> P g\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. False) \\<Longrightarrow> P g\n  g = (\\<lambda>x. x) \\<Longrightarrow> P g\n  g = (\\<lambda>x. True) \\<Longrightarrow> P g\n  g = Not \\<Longrightarrow> P g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g = (\\<lambda>x. False) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. x) \\<Longrightarrow> P g;\n     g = (\\<lambda>x. True) \\<Longrightarrow> P g;\n     g = Not \\<Longrightarrow> P g\\<rbrakk>\n    \\<Longrightarrow> P g", "ultimately"], ["proof (chain)\npicking this:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n  g = (\\<lambda>x. False) \\<Longrightarrow> P g\n  g = (\\<lambda>x. x) \\<Longrightarrow> P g\n  g = (\\<lambda>x. True) \\<Longrightarrow> P g\n  g = Not \\<Longrightarrow> P g", "show ?thesis"], ["proof (prove)\nusing this:\n  g = (\\<lambda>x. False) \\<or>\n  g = (\\<lambda>x. x) \\<or> g = (\\<lambda>x. True) \\<or> g = Not\n  g = (\\<lambda>x. False) \\<Longrightarrow> P g\n  g = (\\<lambda>x. x) \\<Longrightarrow> P g\n  g = (\\<lambda>x. True) \\<Longrightarrow> P g\n  g = Not \\<Longrightarrow> P g\n\ngoal (1 subgoal):\n 1. P g", "by fast"], ["proof (state)\nthis:\n  P g\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definite and indefinite description\\<close>"], ["", "text \"Combined definite and indefinite description for binary predicate\""], ["", "lemma some_theI: assumes EX: \"\\<exists>a b . P a b\" and BUN: \"!! b1 b2 . \\<lbrakk>\\<exists>a . P a b1; \\<exists>a . P a b2\\<rbrakk> \\<Longrightarrow> b1=b2\" \n    shows \"P (SOME a . \\<exists>b . P a b) (THE b . \\<exists>a . P a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "from EX"], ["proof (chain)\npicking this:\n  \\<exists>a b. P a b", "have \"EX b . P (SOME a . EX b . P a b) b\""], ["proof (prove)\nusing this:\n  \\<exists>a b. P a b\n\ngoal (1 subgoal):\n 1. \\<exists>b. P (SOME a. \\<exists>b. P a b) b", "by (rule someI_ex)"], ["proof (state)\nthis:\n  \\<exists>b. P (SOME a. \\<exists>b. P a b) b\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "moreover"], ["proof (state)\nthis:\n  \\<exists>b. P (SOME a. \\<exists>b. P a b) b\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "from EX"], ["proof (chain)\npicking this:\n  \\<exists>a b. P a b", "have \"EX b . EX a . P a b\""], ["proof (prove)\nusing this:\n  \\<exists>a b. P a b\n\ngoal (1 subgoal):\n 1. \\<exists>b a. P a b", "by blast"], ["proof (state)\nthis:\n  \\<exists>b a. P a b\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "with BUN theI'[of \"\\<lambda>b . EX a . P a b\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0\n  \\<exists>!x. \\<exists>a. P a x \\<Longrightarrow>\n  \\<exists>a. P a (THE x. \\<exists>a. P a x)\n  \\<exists>b a. P a b", "have \"EX a . P a (THE b . EX a . P a b)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0\n  \\<exists>!x. \\<exists>a. P a x \\<Longrightarrow>\n  \\<exists>a. P a (THE x. \\<exists>a. P a x)\n  \\<exists>b a. P a b\n\ngoal (1 subgoal):\n 1. \\<exists>a. P a (THE b. \\<exists>a. P a b)", "by (unfold Ex1_def, blast)"], ["proof (state)\nthis:\n  \\<exists>a. P a (THE b. \\<exists>a. P a b)\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "moreover"], ["proof (state)\nthis:\n  \\<exists>a. P a (THE b. \\<exists>a. P a b)\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "note BUN"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>b. P (SOME a. \\<exists>b. P a b) b\n  \\<exists>a. P a (THE b. \\<exists>a. P a b)\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>b. P (SOME a. \\<exists>b. P a b) b\n  \\<exists>a. P a (THE b. \\<exists>a. P a b)\n  \\<lbrakk>\\<exists>a. P a ?b1.0; \\<exists>a. P a ?b2.0\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 = ?b2.0\n\ngoal (1 subgoal):\n 1. P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)", "by (fast)"], ["proof (state)\nthis:\n  P (SOME a. \\<exists>b. P a b) (THE b. \\<exists>a. P a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}