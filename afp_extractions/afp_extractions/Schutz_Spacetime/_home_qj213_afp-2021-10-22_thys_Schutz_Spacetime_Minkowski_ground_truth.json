{"file_name": "/home/qj213/afp-2021-10-22/thys/Schutz_Spacetime/Minkowski.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Schutz_Spacetime", "problem_names": ["lemma path_sub_events:\n  \"Q \\<in> \\<P> \\<Longrightarrow> Q \\<subseteq> \\<E>\"", "lemma paths_sub_power:\n  \"\\<P> \\<subseteq> Pow \\<E>\"", "lemma path_permute:\n  \"path ab a b = path ab b a\"", "lemma path_of_ex: \"path (path_of a b) a b \\<longleftrightarrow> path_ex a b\"", "lemma path_unique:\n  assumes \"path ab a b\" and \"path ab' a b\"\n    shows \"ab = ab'\"", "lemma tri_full:\n  \"\\<triangle> a b c = (a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E> \\<and> a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c\n              \\<and> (\\<exists>Q\\<in>\\<P>. \\<exists>R\\<in>\\<P>. Q \\<noteq> R \\<and> (\\<exists>S\\<in>\\<P>. Q \\<noteq> S \\<and> R \\<noteq> S\n                                              \\<and> a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<notin> Q\n                                              \\<and> a \\<in> R \\<and> c \\<in> R \\<and> b \\<notin> R\n                                              \\<and> b \\<in> S \\<and> c \\<in> S \\<and> a \\<notin> S)))\"", "lemma SPRAY_event:\n  \"SPRAY x \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>\"", "lemma SPRAY_nonevent:\n  \"x \\<notin> \\<E> \\<Longrightarrow> SPRAY x = {}\"", "lemma SPRAY_path:\n  \"P \\<in> SPRAY x \\<Longrightarrow> P \\<in> \\<P>\"", "lemma in_SPRAY_path:\n  \"P \\<in> SPRAY x \\<Longrightarrow> x \\<in> P\"", "lemma source_in_SPRAY:\n  \"SPRAY x \\<noteq> {} \\<Longrightarrow> \\<exists>P \\<in> SPRAY x. x \\<in> P\"", "lemma spray_event:\n  \"spray x \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>\"", "lemma spray_nonevent:\n  \"x \\<notin> \\<E> \\<Longrightarrow> spray x = {}\"", "lemma in_spray_event:\n  \"y \\<in> spray x \\<Longrightarrow> y \\<in> \\<E>\"", "lemma source_in_spray:\n  \"spray x \\<noteq> {} \\<Longrightarrow> x \\<in> spray x\"", "lemma dep3_nonspray:\n  assumes \"dep3_event Q R S x\"\n    shows \"\\<exists>P\\<in>\\<P>. P \\<notin> SPRAY x\"", "lemma dep3_path:\n  assumes dep3_QRSx: \"dep3_event Q R S x\"\n  shows \"Q \\<in> \\<P>\" \"R \\<in> \\<P>\" \"S \\<in> \\<P>\"", "lemma dep3_is_event:\n  \"dep3_event Q R S x \\<Longrightarrow> x \\<in> \\<E>\"", "lemma dep3_event_permute [no_atp]:\n  assumes \"dep3_event Q R S x\"\n    shows \"dep3_event Q S R x\" \"dep3_event R Q S x\" \"dep3_event R S Q x\"\n     \"dep3_event S Q R x\" \"dep3_event S R Q x\"", "lemma dependent_superset:\n  assumes \"dep_set A\" and \"A\\<subseteq>B\"\n  shows \"dep_set B\"", "lemma path_in_dep_set:\n  assumes \"dep3_event P Q R x\"\n  shows \"dep_set {P,Q,R}\"", "lemma path_in_dep_set2:\n  assumes \"dep3_event P Q R x\"\n  shows \"dep_path P {P,Q,R} x\"", "lemma three_SPRAY_ge4:\n  assumes \"three_SPRAY x\"\n  shows \"\\<exists>Q1\\<in>\\<P>. \\<exists>Q2\\<in>\\<P>. \\<exists>Q3\\<in>\\<P>. \\<exists>Q4\\<in>\\<P>. Q1 \\<noteq> Q2 \\<and> Q1 \\<noteq> Q3 \\<and> Q1 \\<noteq> Q4 \\<and> Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4\"", "lemma betw_events:\n  assumes abc: \"[[a b c]]\"\n  shows \"a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E>\"", "lemma O5_still_O5 [no_atp]:\n  \"((Q \\<in> \\<P> \\<and> {a,b,c} \\<subseteq> Q \\<and> a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E> \\<and> a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c)\n     \\<longrightarrow> [[a b c]] \\<or> [[b c a]] \\<or> [[c a b]])\n   =\n   ((Q \\<in> \\<P> \\<and> {a,b,c} \\<subseteq> Q \\<and> a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E> \\<and> a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c)\n     \\<longrightarrow> [[a b c]] \\<or> [[b c a]] \\<or> [[c a b]] \\<or> [[c b a]] \\<or> [[a c b]] \\<or> [[b a c]])\"", "lemma some_betw_xor:\n   \"\\<lbrakk>Q \\<in> \\<P>; a \\<in> Q; b \\<in> Q; c \\<in> Q; a \\<noteq> b; a \\<noteq> c; b \\<noteq> c\\<rbrakk>\n               \\<Longrightarrow> ([[a b c]] \\<and> \\<not> [[b c a]] \\<and> \\<not> [[c a b]])\n                 \\<or> ([[b c a]] \\<and> \\<not> [[a b c]] \\<and> \\<not> [[c a b]])\n                 \\<or> ([[c a b]] \\<and> \\<not> [[a b c]] \\<and> \\<not> [[b c a]])\"", "lemma abc_abc_neq:\n  assumes abc: \"[[a b c]]\"\n  shows \"a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c\"", "lemma abc_bcd_acd:\n  assumes abc: \"[[a b c]]\"\n      and bcd: \"[[b c d]]\"\n  shows \"[[a c d]]\"", "lemma abc_only_cba:\n  assumes \"[[a b c]]\"\n    shows \"\\<not> [[b a c]]\" \"\\<not> [[a c b]]\" \"\\<not> [[b c a]]\" \"\\<not> [[c a b]]\"", "lemma index_middle_element:\n  assumes \"[f[a..b..c]X]\"\n  shows \"\\<exists>n. 0<n \\<and> n<(card X - 1) \\<and> f n = b\"", "lemma fin_ch_betw:\n  assumes \"[f[a..b..c]X]\"\n  shows \"[[a b c]]\"", "lemma chain_sym_obtain:\n  assumes \"[f[a..b..c]X]\"\n  obtains g where \"[g[c..b..a]X]\" and \"g=(\\<lambda>n. f (card X - 1 - n))\"", "lemma chain_sym:\n  assumes \"[f[a..b..c]X]\"\n    shows \"[\\<lambda>n. f (card X - 1 - n)[c..b..a]X]\"", "lemma points_in_chain:\n  assumes \"[f[x..y..z]Q]\"\n  shows \"x\\<in>Q \\<and> y\\<in>Q \\<and> z\\<in>Q\"", "lemma ch_long_if_card_ge3:\n  assumes \"ch X\"\n      and \"card X \\<ge> 3\"\n    shows \"\\<exists>f. long_ch_by_ord f X\"", "lemma long_chain_betw: \"[[..a..b..c..]X] \\<Longrightarrow> [[a b c]]\"", "lemma finite_chain3_betw: \"[[a..b..c]X] \\<Longrightarrow> [[a b c]]\"", "lemma finite_chain2_betw: \"[[a..c]X] \\<Longrightarrow> \\<exists>b. [[a b c]]\"", "lemma ends_notin_segment: \"a \\<notin> segment a b \\<and> b \\<notin> segment a b\"", "lemma ends_in_int: \"a \\<in> interval a b \\<and> b \\<in> interval a b\"", "lemma seg_betw: \"x \\<in> segment a b \\<longleftrightarrow> [[a x b]]\"", "lemma pro_betw: \"x \\<in> prolongation a b \\<longleftrightarrow> [[a b x]]\"", "lemma seg_sym: \"segment a b = segment b a\"", "lemma empty_segment: \"segment a a = {}\"", "lemma int_sym: \"interval a b = interval b a\"", "lemma seg_path:\n  assumes \"x \\<in> segment a b\" (* thus segment \\<noteq> {} *)\n  obtains ab where \"path ab a b\" \"segment a b \\<subseteq> ab\"", "lemma seg_path2:\n  assumes \"segment a b \\<noteq> {}\"\n  obtains ab where \"path ab a b\" \"segment a b \\<subseteq> ab\"", "lemma seg_endpoints_on_path:\n  assumes \"card (segment a b) \\<ge> 2\" \"segment a b \\<subseteq> P\" \"P\\<in>\\<P>\"\n  shows \"path P a b\"", "lemma pro_path:\n  assumes \"x \\<in> prolongation a b\" (* thus prolongation \\<noteq> {} *)\n  obtains ab where \"path ab a b\" \"prolongation a b \\<subseteq> ab\"", "lemma ray_cases:\n  assumes \"x \\<in> ray a b\"\n  shows \"[[a x b]] \\<or> [[a b x]] \\<or> x = b\"", "lemma ray_path:\n  assumes \"x \\<in> ray a b\" \"x\\<noteq>b\"\n  obtains ab where \"path ab a b \\<and> ray a b \\<subseteq> ab\"", "lemma bounded_imp_inf:\n  assumes \"bounded Q\"\n  shows \"infinite Q\"", "lemma card_unreach_geq_2:\n  assumes \"Q\\<in>\\<P>\" \"b\\<in>\\<E>-Q\"\n  shows \"2 \\<le> card (\\<emptyset> Q b) \\<or> (infinite (\\<emptyset> Q b))\"", "lemma four_paths:\n  \"\\<exists>Q1\\<in>\\<P>. \\<exists>Q2\\<in>\\<P>. \\<exists>Q3\\<in>\\<P>. \\<exists>Q4\\<in>\\<P>. Q1 \\<noteq> Q2 \\<and> Q1 \\<noteq> Q3 \\<and> Q1 \\<noteq> Q4 \\<and> Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4\""], "translations": [["", "lemma path_sub_events:\n  \"Q \\<in> \\<P> \\<Longrightarrow> Q \\<subseteq> \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> \\<P> \\<Longrightarrow> Q \\<subseteq> \\<E>", "by (simp add: subsetI)"], ["", "lemma paths_sub_power:\n  \"\\<P> \\<subseteq> Pow \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<P> \\<subseteq> Pow \\<E>", "by (simp add: path_sub_events subsetI)"], ["", "text \\<open>\n  For more terse statements.\n  $a \\neq b$ because $a$ and $b$ are being used to identify the path, and $a = b$ would not do that.\n\\<close>"], ["", "abbreviation path :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"path ab a b \\<equiv> ab \\<in> \\<P> \\<and> a \\<in> ab \\<and> b \\<in> ab \\<and> a \\<noteq> b\""], ["", "abbreviation path_ex :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"path_ex a b \\<equiv> \\<exists>Q. path Q a b\""], ["", "lemma path_permute:\n  \"path ab a b = path ab b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path ab a b = path ab b a", "by auto"], ["", "abbreviation path_of :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set\" where\n  \"path_of a b \\<equiv> THE ab. path ab a b\""], ["", "lemma path_of_ex: \"path (path_of a b) a b \\<longleftrightarrow> path_ex a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (THE ab. path ab a b) a b = (\\<exists>Q. path Q a b)", "using theI' [where P=\"\\<lambda>x. path x a b\"] eq_paths"], ["proof (prove)\nusing this:\n  \\<exists>!x. path x a b \\<Longrightarrow> path (THE x. path x a b) a b\n  \\<lbrakk>?P \\<in> \\<P>; ?Q \\<in> \\<P>; ?a \\<in> ?P; ?b \\<in> ?P;\n   ?a \\<in> ?Q; ?b \\<in> ?Q; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ?P = ?Q\n\ngoal (1 subgoal):\n 1. path (THE ab. path ab a b) a b = (\\<exists>Q. path Q a b)", "by blast"], ["", "lemma path_unique:\n  assumes \"path ab a b\" and \"path ab' a b\"\n    shows \"ab = ab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ab = ab'", "using eq_paths assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P \\<in> \\<P>; ?Q \\<in> \\<P>; ?a \\<in> ?P; ?b \\<in> ?P;\n   ?a \\<in> ?Q; ?b \\<in> ?Q; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ?P = ?Q\n  path ab a b\n  path ab' a b\n\ngoal (1 subgoal):\n 1. ab = ab'", "by blast"], ["", "section \"Primitives: Unreachable Subset (from an Event)\""], ["", "text \\<open>\n  The \\<open>Q \\<in> \\<P> \\<and> b \\<in> \\<E>\\<close> constraints are necessary as the types as not expressive enough to do it on\n  their own. Schutz's notation is: $Q(b,\\emptyset)$.\n\\<close>"], ["", "definition unreachable_subset :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a set\" (\"\\<emptyset> _ _\" [100, 100] 100) where\n  \"unreachable_subset Q b \\<equiv> {x\\<in>Q. Q \\<in> \\<P> \\<and> b \\<in> \\<E> \\<and> b \\<notin> Q \\<and> \\<not>(path_ex b x)}\""], ["", "section \"Primitives: Kinematic Triangle\""], ["", "definition kinematic_triangle :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"\\<triangle> _ _ _\" [100, 100, 100] 100) where\n    \"kinematic_triangle a b c \\<equiv>\n       a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E> \\<and> a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c\n       \\<and> (\\<exists>Q\\<in>\\<P>. \\<exists>R\\<in>\\<P>. Q \\<noteq> R \\<and> (\\<exists>S\\<in>\\<P>. Q \\<noteq> S \\<and> R \\<noteq> S\n                                       \\<and> a \\<in> Q \\<and> b \\<in> Q\n                                       \\<and> a \\<in> R \\<and> c \\<in> R\n                                       \\<and> b \\<in> S \\<and> c \\<in> S))\""], ["", "text \\<open>A fuller, more explicit equivalent of \\<open>\\<triangle>\\<close>, to show that the above definition is sufficient.\\<close>"], ["", "lemma tri_full:\n  \"\\<triangle> a b c = (a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E> \\<and> a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c\n              \\<and> (\\<exists>Q\\<in>\\<P>. \\<exists>R\\<in>\\<P>. Q \\<noteq> R \\<and> (\\<exists>S\\<in>\\<P>. Q \\<noteq> S \\<and> R \\<noteq> S\n                                              \\<and> a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<notin> Q\n                                              \\<and> a \\<in> R \\<and> c \\<in> R \\<and> b \\<notin> R\n                                              \\<and> b \\<in> S \\<and> c \\<in> S \\<and> a \\<notin> S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<triangle> a b c =\n    (a \\<in> \\<E> \\<and>\n     b \\<in> \\<E> \\<and>\n     c \\<in> \\<E> \\<and>\n     a \\<noteq> b \\<and>\n     a \\<noteq> c \\<and>\n     b \\<noteq> c \\<and>\n     (\\<exists>Q\\<in>\\<P>.\n         \\<exists>R\\<in>\\<P>.\n            Q \\<noteq> R \\<and>\n            (\\<exists>S\\<in>\\<P>.\n                Q \\<noteq> S \\<and>\n                R \\<noteq> S \\<and>\n                a \\<in> Q \\<and>\n                b \\<in> Q \\<and>\n                c \\<notin> Q \\<and>\n                a \\<in> R \\<and>\n                c \\<in> R \\<and>\n                b \\<notin> R \\<and>\n                b \\<in> S \\<and> c \\<in> S \\<and> a \\<notin> S)))", "unfolding kinematic_triangle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> \\<E> \\<and>\n     b \\<in> \\<E> \\<and>\n     c \\<in> \\<E> \\<and>\n     a \\<noteq> b \\<and>\n     a \\<noteq> c \\<and>\n     b \\<noteq> c \\<and>\n     (\\<exists>Q\\<in>\\<P>.\n         \\<exists>R\\<in>\\<P>.\n            Q \\<noteq> R \\<and>\n            (\\<exists>S\\<in>\\<P>.\n                Q \\<noteq> S \\<and>\n                R \\<noteq> S \\<and>\n                a \\<in> Q \\<and>\n                b \\<in> Q \\<and>\n                a \\<in> R \\<and>\n                c \\<in> R \\<and> b \\<in> S \\<and> c \\<in> S))) =\n    (a \\<in> \\<E> \\<and>\n     b \\<in> \\<E> \\<and>\n     c \\<in> \\<E> \\<and>\n     a \\<noteq> b \\<and>\n     a \\<noteq> c \\<and>\n     b \\<noteq> c \\<and>\n     (\\<exists>Q\\<in>\\<P>.\n         \\<exists>R\\<in>\\<P>.\n            Q \\<noteq> R \\<and>\n            (\\<exists>S\\<in>\\<P>.\n                Q \\<noteq> S \\<and>\n                R \\<noteq> S \\<and>\n                a \\<in> Q \\<and>\n                b \\<in> Q \\<and>\n                c \\<notin> Q \\<and>\n                a \\<in> R \\<and>\n                c \\<in> R \\<and>\n                b \\<notin> R \\<and>\n                b \\<in> S \\<and> c \\<in> S \\<and> a \\<notin> S)))", "by (meson path_unique)"], ["", "section \"Primitives: SPRAY\""], ["", "text \\<open>\n  It's okay to not require $x \\in \\E$ because if $x \\notin \\E$ the \\<open>SPRAY\\<close> will be empty anyway,\n  and if it's nonempty then $x \\in \\E$ is derivable.\\<close>"], ["", "definition SPRAY :: \"'a \\<Rightarrow> ('a set) set\" where\n  \"SPRAY x \\<equiv> {R\\<in>\\<P>. x \\<in> R}\""], ["", "definition spray :: \"'a \\<Rightarrow> 'a set\" where\n  \"spray x \\<equiv> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\""], ["", "(* Just for convenience. *)"], ["", "definition is_SPRAY :: \"('a set) set \\<Rightarrow> bool\" where\n  \"is_SPRAY S \\<equiv> \\<exists>x\\<in>\\<E>. S = SPRAY x\""], ["", "definition is_spray :: \"'a set \\<Rightarrow> bool\" where\n  \"is_spray S \\<equiv> \\<exists>x\\<in>\\<E>. S = spray x\""], ["", "text \\<open>Some very simple SPRAY and spray lemmas below.\\<close>"], ["", "lemma SPRAY_event:\n  \"SPRAY x \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPRAY x \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>", "proof (unfold SPRAY_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. {R \\<in> \\<P>. x \\<in> R} \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>", "assume nonempty_SPRAY: \"{R \\<in> \\<P>. x \\<in> R} \\<noteq> {}\""], ["proof (state)\nthis:\n  {R \\<in> \\<P>. x \\<in> R} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {R \\<in> \\<P>. x \\<in> R} \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>", "then"], ["proof (chain)\npicking this:\n  {R \\<in> \\<P>. x \\<in> R} \\<noteq> {}", "have x_in_path_R: \"\\<exists>R \\<in> \\<P>. x \\<in> R\""], ["proof (prove)\nusing this:\n  {R \\<in> \\<P>. x \\<in> R} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>R\\<in>\\<P>. x \\<in> R", "by blast"], ["proof (state)\nthis:\n  \\<exists>R\\<in>\\<P>. x \\<in> R\n\ngoal (1 subgoal):\n 1. {R \\<in> \\<P>. x \\<in> R} \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>", "thus \"x \\<in> \\<E>\""], ["proof (prove)\nusing this:\n  \\<exists>R\\<in>\\<P>. x \\<in> R\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>", "using in_path_event"], ["proof (prove)\nusing this:\n  \\<exists>R\\<in>\\<P>. x \\<in> R\n  \\<lbrakk>?Q \\<in> \\<P>; ?a \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<E>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<E>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SPRAY_nonevent:\n  \"x \\<notin> \\<E> \\<Longrightarrow> SPRAY x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> \\<Longrightarrow> SPRAY x = {}", "using SPRAY_event"], ["proof (prove)\nusing this:\n  SPRAY ?x \\<noteq> {} \\<Longrightarrow> ?x \\<in> \\<E>\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> \\<Longrightarrow> SPRAY x = {}", "by auto"], ["", "lemma SPRAY_path:\n  \"P \\<in> SPRAY x \\<Longrightarrow> P \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> SPRAY x \\<Longrightarrow> P \\<in> \\<P>", "by (simp add: SPRAY_def)"], ["", "lemma in_SPRAY_path:\n  \"P \\<in> SPRAY x \\<Longrightarrow> x \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> SPRAY x \\<Longrightarrow> x \\<in> P", "by (simp add: SPRAY_def)"], ["", "lemma source_in_SPRAY:\n  \"SPRAY x \\<noteq> {} \\<Longrightarrow> \\<exists>P \\<in> SPRAY x. x \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPRAY x \\<noteq> {} \\<Longrightarrow> \\<exists>P\\<in>SPRAY x. x \\<in> P", "using in_SPRAY_path"], ["proof (prove)\nusing this:\n  ?P \\<in> SPRAY ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. SPRAY x \\<noteq> {} \\<Longrightarrow> \\<exists>P\\<in>SPRAY x. x \\<in> P", "by auto"], ["", "lemma spray_event:\n  \"spray x \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spray x \\<noteq> {} \\<Longrightarrow> x \\<in> \\<E>", "proof (unfold spray_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<noteq> {} \\<Longrightarrow>\n    x \\<in> \\<E>", "assume \"{y. \\<exists>R \\<in> SPRAY x. y \\<in> R} \\<noteq> {}\""], ["proof (state)\nthis:\n  {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<noteq> {} \\<Longrightarrow>\n    x \\<in> \\<E>", "then"], ["proof (chain)\npicking this:\n  {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<noteq> {}", "have \"\\<exists>y. \\<exists>R \\<in> SPRAY x. y \\<in> R\""], ["proof (prove)\nusing this:\n  {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R", "by simp"], ["proof (state)\nthis:\n  \\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R\n\ngoal (1 subgoal):\n 1. {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<noteq> {} \\<Longrightarrow>\n    x \\<in> \\<E>", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R", "have \"SPRAY x \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R\n\ngoal (1 subgoal):\n 1. SPRAY x \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  SPRAY x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<noteq> {} \\<Longrightarrow>\n    x \\<in> \\<E>", "thus \"x \\<in> \\<E>\""], ["proof (prove)\nusing this:\n  SPRAY x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>", "using SPRAY_event"], ["proof (prove)\nusing this:\n  SPRAY x \\<noteq> {}\n  SPRAY ?x \\<noteq> {} \\<Longrightarrow> ?x \\<in> \\<E>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<E>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spray_nonevent:\n  \"x \\<notin> \\<E> \\<Longrightarrow> spray x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> \\<Longrightarrow> spray x = {}", "using spray_event"], ["proof (prove)\nusing this:\n  spray ?x \\<noteq> {} \\<Longrightarrow> ?x \\<in> \\<E>\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> \\<Longrightarrow> spray x = {}", "by auto"], ["", "lemma in_spray_event:\n  \"y \\<in> spray x \\<Longrightarrow> y \\<in> \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> spray x \\<Longrightarrow> y \\<in> \\<E>", "proof (unfold spray_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<Longrightarrow>\n    y \\<in> \\<E>", "assume \"y \\<in> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\""], ["proof (state)\nthis:\n  y \\<in> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\n\ngoal (1 subgoal):\n 1. y \\<in> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<Longrightarrow>\n    y \\<in> \\<E>", "then"], ["proof (chain)\npicking this:\n  y \\<in> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}", "have \"\\<exists>R\\<in>SPRAY x. y \\<in> R\""], ["proof (prove)\nusing this:\n  y \\<in> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\n\ngoal (1 subgoal):\n 1. \\<exists>R\\<in>SPRAY x. y \\<in> R", "by (rule CollectD)"], ["proof (state)\nthis:\n  \\<exists>R\\<in>SPRAY x. y \\<in> R\n\ngoal (1 subgoal):\n 1. y \\<in> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<Longrightarrow>\n    y \\<in> \\<E>", "then"], ["proof (chain)\npicking this:\n  \\<exists>R\\<in>SPRAY x. y \\<in> R", "obtain R where path_R: \"R \\<in> \\<P>\"\n                  and y_inR: \"y \\<in> R\""], ["proof (prove)\nusing this:\n  \\<exists>R\\<in>SPRAY x. y \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> \\<P>; y \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using SPRAY_path"], ["proof (prove)\nusing this:\n  \\<exists>R\\<in>SPRAY x. y \\<in> R\n  ?P \\<in> SPRAY ?x \\<Longrightarrow> ?P \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> \\<P>; y \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R \\<in> \\<P>\n  y \\<in> R\n\ngoal (1 subgoal):\n 1. y \\<in> {y. \\<exists>R\\<in>SPRAY x. y \\<in> R} \\<Longrightarrow>\n    y \\<in> \\<E>", "thus \"y \\<in> \\<E>\""], ["proof (prove)\nusing this:\n  R \\<in> \\<P>\n  y \\<in> R\n\ngoal (1 subgoal):\n 1. y \\<in> \\<E>", "using in_path_event"], ["proof (prove)\nusing this:\n  R \\<in> \\<P>\n  y \\<in> R\n  \\<lbrakk>?Q \\<in> \\<P>; ?a \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<E>\n\ngoal (1 subgoal):\n 1. y \\<in> \\<E>", "by simp"], ["proof (state)\nthis:\n  y \\<in> \\<E>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma source_in_spray:\n  \"spray x \\<noteq> {} \\<Longrightarrow> x \\<in> spray x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spray x \\<noteq> {} \\<Longrightarrow> x \\<in> spray x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spray x \\<noteq> {} \\<Longrightarrow> x \\<in> spray x", "assume nonempty_spray: \"spray x \\<noteq> {}\""], ["proof (state)\nthis:\n  spray x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. spray x \\<noteq> {} \\<Longrightarrow> x \\<in> spray x", "have spray_eq: \"spray x = {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spray x = {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}", "using spray_def"], ["proof (prove)\nusing this:\n  spray ?x \\<equiv> {y. \\<exists>R\\<in>SPRAY ?x. y \\<in> R}\n\ngoal (1 subgoal):\n 1. spray x = {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}", "by simp"], ["proof (state)\nthis:\n  spray x = {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\n\ngoal (1 subgoal):\n 1. spray x \\<noteq> {} \\<Longrightarrow> x \\<in> spray x", "then"], ["proof (chain)\npicking this:\n  spray x = {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}", "have ex_in_SPRAY_path: \"\\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R\""], ["proof (prove)\nusing this:\n  spray x = {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\n\ngoal (1 subgoal):\n 1. \\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R", "using nonempty_spray"], ["proof (prove)\nusing this:\n  spray x = {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\n  spray x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R", "by simp"], ["proof (state)\nthis:\n  \\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R\n\ngoal (1 subgoal):\n 1. spray x \\<noteq> {} \\<Longrightarrow> x \\<in> spray x", "show \"x \\<in> spray x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> spray x", "using ex_in_SPRAY_path spray_eq source_in_SPRAY"], ["proof (prove)\nusing this:\n  \\<exists>y. \\<exists>R\\<in>SPRAY x. y \\<in> R\n  spray x = {y. \\<exists>R\\<in>SPRAY x. y \\<in> R}\n  SPRAY ?x \\<noteq> {} \\<Longrightarrow> \\<exists>P\\<in>SPRAY ?x. ?x \\<in> P\n\ngoal (1 subgoal):\n 1. x \\<in> spray x", "by auto"], ["proof (state)\nthis:\n  x \\<in> spray x\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Primitives: Path (In)dependence\""], ["", "text \\<open>\n  \"A subset of three paths of a SPRAY is dependent if there is a path which does not belong\n  to the SPRAY and which contains one event from each of the three paths: we also say any\n  one of the three paths is dependent on the other two.\n  Otherwise the subset is independent.\" [Schutz97]\n\\<close>"], ["", "text \\<open>The definition of \\<open>SPRAY\\<close> constrains $x, Q, R, S$ to be in $\\E$ and $\\P$.\\<close>"], ["", "definition dep3_event :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"dep3_event Q R S x \\<equiv> Q \\<noteq> R \\<and> Q \\<noteq> S \\<and> R \\<noteq> S \\<and> Q \\<in> SPRAY x \\<and> R \\<in> SPRAY x \\<and> S \\<in> SPRAY x\n                         \\<and> (\\<exists>T\\<in>\\<P>. T \\<notin> SPRAY x \\<and> (\\<exists>y\\<in>Q. y \\<in> T) \\<and> (\\<exists>y\\<in>R. y \\<in> T) \\<and> (\\<exists>y\\<in>S. y \\<in> T))\""], ["", "definition dep3_spray :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set \\<Rightarrow> ('a set) set \\<Rightarrow> bool\" where\n  \"dep3_spray Q R S SPR \\<equiv> \\<exists>x. SPRAY x = SPR \\<and> dep3_event Q R S x\""], ["", "definition dep3 :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"dep3 Q R S \\<equiv> \\<exists>x. dep3_event Q R S x\""], ["", "text \\<open>Some very simple lemmas related to \\<open>dep3_event\\<close>.\\<close>"], ["", "(* Nice to have this on its own. *)"], ["", "lemma dep3_nonspray:\n  assumes \"dep3_event Q R S x\"\n    shows \"\\<exists>P\\<in>\\<P>. P \\<notin> SPRAY x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>\\<P>. P \\<notin> SPRAY x", "by (metis assms dep3_event_def)"], ["", "lemma dep3_path:\n  assumes dep3_QRSx: \"dep3_event Q R S x\"\n  shows \"Q \\<in> \\<P>\" \"R \\<in> \\<P>\" \"S \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> \\<P> &&& R \\<in> \\<P> &&& S \\<in> \\<P>", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. Q \\<in> \\<P>\n 2. R \\<in> \\<P>\n 3. S \\<in> \\<P>", "have \"{Q,R,S} \\<subseteq> SPRAY x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Q, R, S} \\<subseteq> SPRAY x", "using dep3_event_def"], ["proof (prove)\nusing this:\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n\ngoal (1 subgoal):\n 1. {Q, R, S} \\<subseteq> SPRAY x", "using dep3_QRSx"], ["proof (prove)\nusing this:\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n  dep3_event Q R S x\n\ngoal (1 subgoal):\n 1. {Q, R, S} \\<subseteq> SPRAY x", "by simp"], ["proof (state)\nthis:\n  {Q, R, S} \\<subseteq> SPRAY x\n\ngoal (3 subgoals):\n 1. Q \\<in> \\<P>\n 2. R \\<in> \\<P>\n 3. S \\<in> \\<P>", "thus \"Q \\<in> \\<P>\" \"R \\<in> \\<P>\" \"S \\<in> \\<P>\""], ["proof (prove)\nusing this:\n  {Q, R, S} \\<subseteq> SPRAY x\n\ngoal (1 subgoal):\n 1. Q \\<in> \\<P> &&& R \\<in> \\<P> &&& S \\<in> \\<P>", "using SPRAY_path"], ["proof (prove)\nusing this:\n  {Q, R, S} \\<subseteq> SPRAY x\n  ?P \\<in> SPRAY ?x \\<Longrightarrow> ?P \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. Q \\<in> \\<P> &&& R \\<in> \\<P> &&& S \\<in> \\<P>", "by auto"], ["proof (state)\nthis:\n  Q \\<in> \\<P>\n  R \\<in> \\<P>\n  S \\<in> \\<P>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dep3_is_event:\n  \"dep3_event Q R S x \\<Longrightarrow> x \\<in> \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep3_event Q R S x \\<Longrightarrow> x \\<in> \\<E>", "using SPRAY_event dep3_event_def"], ["proof (prove)\nusing this:\n  SPRAY ?x \\<noteq> {} \\<Longrightarrow> ?x \\<in> \\<E>\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n\ngoal (1 subgoal):\n 1. dep3_event Q R S x \\<Longrightarrow> x \\<in> \\<E>", "by auto"], ["", "lemma dep3_event_permute [no_atp]:\n  assumes \"dep3_event Q R S x\"\n    shows \"dep3_event Q S R x\" \"dep3_event R Q S x\" \"dep3_event R S Q x\"\n     \"dep3_event S Q R x\" \"dep3_event S R Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dep3_event Q S R x &&& dep3_event R Q S x) &&&\n    dep3_event R S Q x &&& dep3_event S Q R x &&& dep3_event S R Q x", "using dep3_event_def assms"], ["proof (prove)\nusing this:\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n  dep3_event Q R S x\n\ngoal (1 subgoal):\n 1. (dep3_event Q S R x &&& dep3_event R Q S x) &&&\n    dep3_event R S Q x &&& dep3_event S Q R x &&& dep3_event S R Q x", "by auto"], ["", "text \\<open>\n  \"We next give recursive definitions of dependence and independence which will be used to\n  characterize the concept of dimension. A path $T$ is dependent on the set of $n$ paths (where $n\\geq3$)\n\n  $$S = \\left\\lbrace Q_i \\colon i = 1, 2, ..., n; Q_i \\in \\spray x\\right\\rbrace$$\n\n  if it is dependent on two paths $S_1$ and $S_2$, where each of these two paths is dependent\n  on some subset of $n - 1$ paths from the set $S$.\" [Schutz97]\\<close>"], ["", "inductive dep_path :: \"'a set \\<Rightarrow> ('a set) set \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  dep_two: \"dep3_event T A B x \\<Longrightarrow> dep_path T {A, B} x\"\n| dep_n:   \"\\<lbrakk>S \\<subseteq> SPRAY x; card S \\<ge> 3; dep_path T {S1, S2} x;\n             S' \\<subseteq> S; S'' \\<subseteq> S; card S' = card S - 1; card S'' = card S - 1;\n             dep_path S1 S' x; dep_path S2 S'' x\\<rbrakk> \\<Longrightarrow> dep_path T S x\""], ["", "text \\<open>\n  \"We also say that the set of $n + 1$ paths $S\\cup\\{T\\}$ is a dependent set.\" [Schutz97]\n  Starting from this constructive definition, the below gives an analytical one.\n\\<close>"], ["", "definition dep_set :: \"('a set) set \\<Rightarrow> bool\" where\n  \"dep_set S \\<equiv> \\<exists>x. \\<exists>S'\\<subseteq>S. \\<exists>P\\<in>(S-S'). dep_path P S' x\""], ["", "lemma dependent_superset:\n  assumes \"dep_set A\" and \"A\\<subseteq>B\"\n  shows \"dep_set B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep_set B", "using assms(1) assms(2) dep_set_def"], ["proof (prove)\nusing this:\n  dep_set A\n  A \\<subseteq> B\n  dep_set ?S \\<equiv>\n  \\<exists>x S'.\n     S' \\<subseteq> ?S \\<and> (\\<exists>P\\<in>?S - S'. dep_path P S' x)\n\ngoal (1 subgoal):\n 1. dep_set B", "by (meson Diff_mono dual_order.trans in_mono order_refl)"], ["", "lemma path_in_dep_set:\n  assumes \"dep3_event P Q R x\"\n  shows \"dep_set {P,Q,R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep_set {P, Q, R}", "using dep_two assms dep3_event_def dep_set_def"], ["proof (prove)\nusing this:\n  dep3_event ?T ?A ?B ?x \\<Longrightarrow> dep_path ?T {?A, ?B} ?x\n  dep3_event P Q R x\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n  dep_set ?S \\<equiv>\n  \\<exists>x S'.\n     S' \\<subseteq> ?S \\<and> (\\<exists>P\\<in>?S - S'. dep_path P S' x)\n\ngoal (1 subgoal):\n 1. dep_set {P, Q, R}", "by (metis DiffI insertE insertI1 singletonD subset_insertI)"], ["", "lemma path_in_dep_set2:\n  assumes \"dep3_event P Q R x\"\n  shows \"dep_path P {P,Q,R} x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep_path P {P, Q, R} x", "proof"], ["proof (state)\ngoal (9 subgoals):\n 1. {P, Q, R} \\<subseteq> SPRAY x\n 2. 3 \\<le> card {P, Q, R}\n 3. dep_path P {?S1.0, ?S2.0} x\n 4. ?S' \\<subseteq> {P, Q, R}\n 5. ?S'' \\<subseteq> {P, Q, R}\n 6. card ?S' = card {P, Q, R} - 1\n 7. card ?S'' = card {P, Q, R} - 1\n 8. dep_path ?S1.0 ?S' x\n 9. dep_path ?S2.0 ?S'' x", "let ?S1 = \"Q\""], ["proof (state)\ngoal (9 subgoals):\n 1. {P, Q, R} \\<subseteq> SPRAY x\n 2. 3 \\<le> card {P, Q, R}\n 3. dep_path P {?S1.0, ?S2.0} x\n 4. ?S' \\<subseteq> {P, Q, R}\n 5. ?S'' \\<subseteq> {P, Q, R}\n 6. card ?S' = card {P, Q, R} - 1\n 7. card ?S'' = card {P, Q, R} - 1\n 8. dep_path ?S1.0 ?S' x\n 9. dep_path ?S2.0 ?S'' x", "let ?S2 = \"R\""], ["proof (state)\ngoal (9 subgoals):\n 1. {P, Q, R} \\<subseteq> SPRAY x\n 2. 3 \\<le> card {P, Q, R}\n 3. dep_path P {?S1.0, ?S2.0} x\n 4. ?S' \\<subseteq> {P, Q, R}\n 5. ?S'' \\<subseteq> {P, Q, R}\n 6. card ?S' = card {P, Q, R} - 1\n 7. card ?S'' = card {P, Q, R} - 1\n 8. dep_path ?S1.0 ?S' x\n 9. dep_path ?S2.0 ?S'' x", "let ?S' = \"{P,R}\""], ["proof (state)\ngoal (9 subgoals):\n 1. {P, Q, R} \\<subseteq> SPRAY x\n 2. 3 \\<le> card {P, Q, R}\n 3. dep_path P {?S1.0, ?S2.0} x\n 4. ?S' \\<subseteq> {P, Q, R}\n 5. ?S'' \\<subseteq> {P, Q, R}\n 6. card ?S' = card {P, Q, R} - 1\n 7. card ?S'' = card {P, Q, R} - 1\n 8. dep_path ?S1.0 ?S' x\n 9. dep_path ?S2.0 ?S'' x", "let ?S'' = \"{P,Q}\""], ["proof (state)\ngoal (9 subgoals):\n 1. {P, Q, R} \\<subseteq> SPRAY x\n 2. 3 \\<le> card {P, Q, R}\n 3. dep_path P {?S1.0, ?S2.0} x\n 4. ?S' \\<subseteq> {P, Q, R}\n 5. ?S'' \\<subseteq> {P, Q, R}\n 6. card ?S' = card {P, Q, R} - 1\n 7. card ?S'' = card {P, Q, R} - 1\n 8. dep_path ?S1.0 ?S' x\n 9. dep_path ?S2.0 ?S'' x", "show \"{P, Q, R} \\<subseteq> SPRAY x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P, Q, R} \\<subseteq> SPRAY x", "using assms dep3_event_def"], ["proof (prove)\nusing this:\n  dep3_event P Q R x\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n\ngoal (1 subgoal):\n 1. {P, Q, R} \\<subseteq> SPRAY x", "by blast"], ["proof (state)\nthis:\n  {P, Q, R} \\<subseteq> SPRAY x\n\ngoal (8 subgoals):\n 1. 3 \\<le> card {P, Q, R}\n 2. dep_path P {?S1.0, ?S2.0} x\n 3. ?S' \\<subseteq> {P, Q, R}\n 4. ?S'' \\<subseteq> {P, Q, R}\n 5. card ?S' = card {P, Q, R} - 1\n 6. card ?S'' = card {P, Q, R} - 1\n 7. dep_path ?S1.0 ?S' x\n 8. dep_path ?S2.0 ?S'' x", "show \"3 \\<le> card {P, Q, R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> card {P, Q, R}", "using assms dep3_event_def"], ["proof (prove)\nusing this:\n  dep3_event P Q R x\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n\ngoal (1 subgoal):\n 1. 3 \\<le> card {P, Q, R}", "by auto"], ["proof (state)\nthis:\n  3 \\<le> card {P, Q, R}\n\ngoal (7 subgoals):\n 1. dep_path P {?S1.0, ?S2.0} x\n 2. ?S' \\<subseteq> {P, Q, R}\n 3. ?S'' \\<subseteq> {P, Q, R}\n 4. card ?S' = card {P, Q, R} - 1\n 5. card ?S'' = card {P, Q, R} - 1\n 6. dep_path ?S1.0 ?S' x\n 7. dep_path ?S2.0 ?S'' x", "show \"dep_path P {?S1, ?S2} x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep_path P {Q, R} x", "using assms dep3_event_def"], ["proof (prove)\nusing this:\n  dep3_event P Q R x\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n\ngoal (1 subgoal):\n 1. dep_path P {Q, R} x", "by (simp add: dep_two)"], ["proof (state)\nthis:\n  dep_path P {Q, R} x\n\ngoal (6 subgoals):\n 1. ?S' \\<subseteq> {P, Q, R}\n 2. ?S'' \\<subseteq> {P, Q, R}\n 3. card ?S' = card {P, Q, R} - 1\n 4. card ?S'' = card {P, Q, R} - 1\n 5. dep_path Q ?S' x\n 6. dep_path R ?S'' x", "show \"?S' \\<subseteq> {P, Q, R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P, R} \\<subseteq> {P, Q, R}", "by simp"], ["proof (state)\nthis:\n  {P, R} \\<subseteq> {P, Q, R}\n\ngoal (5 subgoals):\n 1. ?S'' \\<subseteq> {P, Q, R}\n 2. card {P, R} = card {P, Q, R} - 1\n 3. card ?S'' = card {P, Q, R} - 1\n 4. dep_path Q {P, R} x\n 5. dep_path R ?S'' x", "show \"?S'' \\<subseteq> {P, Q, R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P, Q} \\<subseteq> {P, Q, R}", "by simp"], ["proof (state)\nthis:\n  {P, Q} \\<subseteq> {P, Q, R}\n\ngoal (4 subgoals):\n 1. card {P, R} = card {P, Q, R} - 1\n 2. card {P, Q} = card {P, Q, R} - 1\n 3. dep_path Q {P, R} x\n 4. dep_path R {P, Q} x", "show \"card ?S' = card {P, Q, R} - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P, R} = card {P, Q, R} - 1", "using assms dep3_event_def"], ["proof (prove)\nusing this:\n  dep3_event P Q R x\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n\ngoal (1 subgoal):\n 1. card {P, R} = card {P, Q, R} - 1", "by auto"], ["proof (state)\nthis:\n  card {P, R} = card {P, Q, R} - 1\n\ngoal (3 subgoals):\n 1. card {P, Q} = card {P, Q, R} - 1\n 2. dep_path Q {P, R} x\n 3. dep_path R {P, Q} x", "show \"card ?S'' = card {P, Q, R} - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P, Q} = card {P, Q, R} - 1", "using assms dep3_event_def"], ["proof (prove)\nusing this:\n  dep3_event P Q R x\n  dep3_event ?Q ?R ?S ?x \\<equiv>\n  ?Q \\<noteq> ?R \\<and>\n  ?Q \\<noteq> ?S \\<and>\n  ?R \\<noteq> ?S \\<and>\n  ?Q \\<in> SPRAY ?x \\<and>\n  ?R \\<in> SPRAY ?x \\<and>\n  ?S \\<in> SPRAY ?x \\<and>\n  (\\<exists>T\\<in>\\<P>.\n      T \\<notin> SPRAY ?x \\<and>\n      (\\<exists>y\\<in>?Q. y \\<in> T) \\<and>\n      (\\<exists>y\\<in>?R. y \\<in> T) \\<and> (\\<exists>y\\<in>?S. y \\<in> T))\n\ngoal (1 subgoal):\n 1. card {P, Q} = card {P, Q, R} - 1", "by auto"], ["proof (state)\nthis:\n  card {P, Q} = card {P, Q, R} - 1\n\ngoal (2 subgoals):\n 1. dep_path Q {P, R} x\n 2. dep_path R {P, Q} x", "show \"dep_path ?S1 ?S' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep_path Q {P, R} x", "by (simp add: assms dep3_event_permute(2) dep_two)"], ["proof (state)\nthis:\n  dep_path Q {P, R} x\n\ngoal (1 subgoal):\n 1. dep_path R {P, Q} x", "show \"dep_path ?S2 ?S'' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep_path R {P, Q} x", "using assms dep3_event_permute(2,4) dep_two"], ["proof (prove)\nusing this:\n  dep3_event P Q R x\n  dep3_event ?Q ?R ?S ?x \\<Longrightarrow> dep3_event ?R ?Q ?S ?x\n  dep3_event ?Q ?R ?S ?x \\<Longrightarrow> dep3_event ?S ?Q ?R ?x\n  dep3_event ?T ?A ?B ?x \\<Longrightarrow> dep_path ?T {?A, ?B} ?x\n\ngoal (1 subgoal):\n 1. dep_path R {P, Q} x", "by blast"], ["proof (state)\nthis:\n  dep_path R {P, Q} x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition indep_set :: \"('a set) set \\<Rightarrow> bool\" where\n  \"indep_set S \\<equiv> \\<not>(\\<exists>T \\<subseteq> S. dep_set T)\""], ["", "section \"Primitives: 3-SPRAY\""], ["", "text \\<open>\n  \"We now make the following definition which enables us to specify the dimensions of Minkowski\n  space-time. A SPRAY is a 3-SPRAY if:\n    i) it contains four independent paths, and\n   ii) all paths of the SPRAY are dependent on these four paths.\" [Schutz97]\n\\<close>"], ["", "definition three_SPRAY :: \"'a \\<Rightarrow> bool\" where\n  \"three_SPRAY x \\<equiv> \\<exists>S1\\<in>\\<P>. \\<exists>S2\\<in>\\<P>. \\<exists>S3\\<in>\\<P>. \\<exists>S4\\<in>\\<P>.\n    S1 \\<noteq> S2 \\<and> S1 \\<noteq> S3 \\<and> S1 \\<noteq> S4 \\<and> S2 \\<noteq> S3 \\<and> S2 \\<noteq> S4 \\<and> S3 \\<noteq> S4\n    \\<and> S1 \\<in> SPRAY x \\<and> S2 \\<in> SPRAY x \\<and> S3 \\<in> SPRAY x \\<and> S4 \\<in> SPRAY x\n    \\<and> (indep_set {S1, S2, S3, S4})\n    \\<and> (\\<forall>S\\<in>SPRAY x. dep_path S {S1,S2,S3,S4} x)\""], ["", "text \\<open>\n  Lemma \\<open>is_three_SPRAY\\<close> says \"this set of sets of elements is a set of paths which is a 3-$\\spray$\".\n  Lemma \\<open>three_SPRAY_ge4\\<close> just extracts a bit of the definition.\n\\<close>"], ["", "definition is_three_SPRAY :: \"('a set) set \\<Rightarrow> bool\" where\n  \"is_three_SPRAY SPR \\<equiv> \\<exists> x. SPR = SPRAY x \\<and> three_SPRAY x\""], ["", "lemma three_SPRAY_ge4:\n  assumes \"three_SPRAY x\"\n  shows \"\\<exists>Q1\\<in>\\<P>. \\<exists>Q2\\<in>\\<P>. \\<exists>Q3\\<in>\\<P>. \\<exists>Q4\\<in>\\<P>. Q1 \\<noteq> Q2 \\<and> Q1 \\<noteq> Q3 \\<and> Q1 \\<noteq> Q4 \\<and> Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q1\\<in>\\<P>.\n       \\<exists>Q2\\<in>\\<P>.\n          \\<exists>Q3\\<in>\\<P>.\n             \\<exists>Q4\\<in>\\<P>.\n                Q1 \\<noteq> Q2 \\<and>\n                Q1 \\<noteq> Q3 \\<and>\n                Q1 \\<noteq> Q4 \\<and>\n                Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4", "using assms three_SPRAY_def"], ["proof (prove)\nusing this:\n  three_SPRAY x\n  three_SPRAY ?x \\<equiv>\n  \\<exists>S1\\<in>\\<P>.\n     \\<exists>S2\\<in>\\<P>.\n        \\<exists>S3\\<in>\\<P>.\n           \\<exists>S4\\<in>\\<P>.\n              S1 \\<noteq> S2 \\<and>\n              S1 \\<noteq> S3 \\<and>\n              S1 \\<noteq> S4 \\<and>\n              S2 \\<noteq> S3 \\<and>\n              S2 \\<noteq> S4 \\<and>\n              S3 \\<noteq> S4 \\<and>\n              S1 \\<in> SPRAY ?x \\<and>\n              S2 \\<in> SPRAY ?x \\<and>\n              S3 \\<in> SPRAY ?x \\<and>\n              S4 \\<in> SPRAY ?x \\<and>\n              indep_set {S1, S2, S3, S4} \\<and>\n              (\\<forall>S\\<in>SPRAY ?x. dep_path S {S1, S2, S3, S4} ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>Q1\\<in>\\<P>.\n       \\<exists>Q2\\<in>\\<P>.\n          \\<exists>Q3\\<in>\\<P>.\n             \\<exists>Q4\\<in>\\<P>.\n                Q1 \\<noteq> Q2 \\<and>\n                Q1 \\<noteq> Q3 \\<and>\n                Q1 \\<noteq> Q4 \\<and>\n                Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4", "by meson"], ["", "end"], ["", "(* MinkowskiPrimitive *)"], ["", "section \"MinkowskiBetweenness: O1-O5\""], ["", "text \\<open>\n  In O4, I have removed the requirement that $a \\neq d$ in order to prove negative\n  betweenness statements as Schutz does. For example, if we have $[abc]$\n  and $[bca]$ we want to conclude $[aba]$ and claim \"contradiction!\", but\n  we can't as long as we mandate that $a \\neq d$.\n\\<close>"], ["", "locale MinkowskiBetweenness = MinkowskiPrimitive +\n  fixes betw :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"[[_ _ _]]\")\n      (* O1 *) (*notice this is not only for events, but all things with same data type*)\n  assumes abc_ex_path: \"[[a b c]] \\<Longrightarrow> \\<exists>Q\\<in>\\<P>. a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<in> Q\"\n      (* O2 *)\n      and abc_sym: \"[[a b c]] \\<Longrightarrow> [[c b a]]\"\n      (* O3, relaxed, as O3 can be proven from this. *)\n      and abc_ac_neq: \"[[a b c]] \\<Longrightarrow> a \\<noteq> c\"\n      (* O4 *)\n      and abc_bcd_abd [intro]: \"\\<lbrakk>[[a b c]]; [[b c d]]\\<rbrakk> \\<Longrightarrow> [[a b d]]\"\n      (* O5, relaxed; exhausting all six options is not necessary thanks to abc_sym. *)\n      and some_betw: \"\\<lbrakk>Q \\<in> \\<P>; a \\<in> Q; b \\<in> Q; c \\<in> Q; a \\<noteq> b; a \\<noteq> c; b \\<noteq> c\\<rbrakk>\n               \\<Longrightarrow> [[a b c]] \\<or> [[b c a]] \\<or> [[c a b]]\"\nbegin"], ["", "text \\<open>\n  The next few lemmas either provide the full axiom from the text derived from a new simpler\n  statement, or provide some very simple fundamental additions which make sense to prove\n  immediately before starting, usually related to set-level things that should be true which\n  fix the type-level ambiguity of 'a.\n\\<close>"], ["", "lemma betw_events:\n  assumes abc: \"[[a b c]]\"\n  shows \"a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E>", "have \"\\<exists>Q\\<in>\\<P>. a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q\\<in>\\<P>. a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<in> Q", "using abc_ex_path abc"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow>\n  \\<exists>Q\\<in>\\<P>. ?a \\<in> Q \\<and> ?b \\<in> Q \\<and> ?c \\<in> Q\n  [[a b c]]\n\ngoal (1 subgoal):\n 1. \\<exists>Q\\<in>\\<P>. a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<in> Q", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q\\<in>\\<P>. a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<in> Q\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>Q\\<in>\\<P>. a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<in> Q\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E>", "using in_path_event"], ["proof (prove)\nusing this:\n  \\<exists>Q\\<in>\\<P>. a \\<in> Q \\<and> b \\<in> Q \\<and> c \\<in> Q\n  \\<lbrakk>?Q \\<in> \\<P>; ?a \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<E>\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E>", "by auto"], ["proof (state)\nthis:\n  a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This shows the shorter version of O5 is equivalent.\\<close>"], ["", "lemma O5_still_O5 [no_atp]:\n  \"((Q \\<in> \\<P> \\<and> {a,b,c} \\<subseteq> Q \\<and> a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E> \\<and> a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c)\n     \\<longrightarrow> [[a b c]] \\<or> [[b c a]] \\<or> [[c a b]])\n   =\n   ((Q \\<in> \\<P> \\<and> {a,b,c} \\<subseteq> Q \\<and> a \\<in> \\<E> \\<and> b \\<in> \\<E> \\<and> c \\<in> \\<E> \\<and> a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c)\n     \\<longrightarrow> [[a b c]] \\<or> [[b c a]] \\<or> [[c a b]] \\<or> [[c b a]] \\<or> [[a c b]] \\<or> [[b a c]])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q \\<in> \\<P> \\<and>\n     {a, b, c} \\<subseteq> Q \\<and>\n     a \\<in> \\<E> \\<and>\n     b \\<in> \\<E> \\<and>\n     c \\<in> \\<E> \\<and>\n     a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c \\<longrightarrow>\n     [[a b c]] \\<or> [[b c a]] \\<or> [[c a b]]) =\n    (Q \\<in> \\<P> \\<and>\n     {a, b, c} \\<subseteq> Q \\<and>\n     a \\<in> \\<E> \\<and>\n     b \\<in> \\<E> \\<and>\n     c \\<in> \\<E> \\<and>\n     a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c \\<longrightarrow>\n     [[a b c]] \\<or>\n     [[b c a]] \\<or>\n     [[c a b]] \\<or> [[c b a]] \\<or> [[a c b]] \\<or> [[b a c]])", "by (auto simp add: abc_sym)"], ["", "lemma some_betw_xor:\n   \"\\<lbrakk>Q \\<in> \\<P>; a \\<in> Q; b \\<in> Q; c \\<in> Q; a \\<noteq> b; a \\<noteq> c; b \\<noteq> c\\<rbrakk>\n               \\<Longrightarrow> ([[a b c]] \\<and> \\<not> [[b c a]] \\<and> \\<not> [[c a b]])\n                 \\<or> ([[b c a]] \\<and> \\<not> [[a b c]] \\<and> \\<not> [[c a b]])\n                 \\<or> ([[c a b]] \\<and> \\<not> [[a b c]] \\<and> \\<not> [[b c a]])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<in> \\<P>; a \\<in> Q; b \\<in> Q; c \\<in> Q; a \\<noteq> b;\n     a \\<noteq> c; b \\<noteq> c\\<rbrakk>\n    \\<Longrightarrow> [[a b c]] \\<and>\n                      \\<not> [[b c a]] \\<and> \\<not> [[c a b]] \\<or>\n                      [[b c a]] \\<and>\n                      \\<not> [[a b c]] \\<and> \\<not> [[c a b]] \\<or>\n                      [[c a b]] \\<and>\n                      \\<not> [[a b c]] \\<and> \\<not> [[b c a]]", "by (meson abc_ac_neq abc_bcd_abd some_betw)"], ["", "text \\<open>The lemma \\<open>abc_abc_neq\\<close> is the full O3 as stated by Schutz.\\<close>"], ["", "lemma abc_abc_neq:\n  assumes abc: \"[[a b c]]\"\n  shows \"a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c", "using abc_sym abc_ac_neq assms abc_bcd_abd"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow> [[?c ?b ?a]]\n  [[?a ?b ?c]] \\<Longrightarrow> ?a \\<noteq> ?c\n  [[a b c]]\n  \\<lbrakk>[[?a ?b ?c]]; [[?b ?c ?d]]\\<rbrakk>\n  \\<Longrightarrow> [[?a ?b ?d]]\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<and> a \\<noteq> c \\<and> b \\<noteq> c", "by blast"], ["", "lemma abc_bcd_acd:\n  assumes abc: \"[[a b c]]\"\n      and bcd: \"[[b c d]]\"\n  shows \"[[a c d]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[a c d]]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [[a c d]]", "have cba: \"[[c b a]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[c b a]]", "using abc_sym abc"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow> [[?c ?b ?a]]\n  [[a b c]]\n\ngoal (1 subgoal):\n 1. [[c b a]]", "by simp"], ["proof (state)\nthis:\n  [[c b a]]\n\ngoal (1 subgoal):\n 1. [[a c d]]", "have dcb: \"[[d c b]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[d c b]]", "using abc_sym bcd"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow> [[?c ?b ?a]]\n  [[b c d]]\n\ngoal (1 subgoal):\n 1. [[d c b]]", "by simp"], ["proof (state)\nthis:\n  [[d c b]]\n\ngoal (1 subgoal):\n 1. [[a c d]]", "have \"[[d c a]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[d c a]]", "using abc_bcd_abd dcb cba"], ["proof (prove)\nusing this:\n  \\<lbrakk>[[?a ?b ?c]]; [[?b ?c ?d]]\\<rbrakk>\n  \\<Longrightarrow> [[?a ?b ?d]]\n  [[d c b]]\n  [[c b a]]\n\ngoal (1 subgoal):\n 1. [[d c a]]", "by blast"], ["proof (state)\nthis:\n  [[d c a]]\n\ngoal (1 subgoal):\n 1. [[a c d]]", "thus ?thesis"], ["proof (prove)\nusing this:\n  [[d c a]]\n\ngoal (1 subgoal):\n 1. [[a c d]]", "using abc_sym"], ["proof (prove)\nusing this:\n  [[d c a]]\n  [[?a ?b ?c]] \\<Longrightarrow> [[?c ?b ?a]]\n\ngoal (1 subgoal):\n 1. [[a c d]]", "by simp"], ["proof (state)\nthis:\n  [[a c d]]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abc_only_cba:\n  assumes \"[[a b c]]\"\n    shows \"\\<not> [[b a c]]\" \"\\<not> [[a c b]]\" \"\\<not> [[b c a]]\" \"\\<not> [[c a b]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> [[b a c]] &&& \\<not> [[a c b]]) &&&\n    \\<not> [[b c a]] &&& \\<not> [[c a b]]", "using abc_sym abc_abc_neq abc_bcd_abd assms"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow> [[?c ?b ?a]]\n  [[?a ?b ?c]] \\<Longrightarrow>\n  ?a \\<noteq> ?b \\<and> ?a \\<noteq> ?c \\<and> ?b \\<noteq> ?c\n  \\<lbrakk>[[?a ?b ?c]]; [[?b ?c ?d]]\\<rbrakk>\n  \\<Longrightarrow> [[?a ?b ?d]]\n  [[a b c]]\n\ngoal (1 subgoal):\n 1. (\\<not> [[b a c]] &&& \\<not> [[a c b]]) &&&\n    \\<not> [[b c a]] &&& \\<not> [[c a b]]", "by blast+"], ["", "section \"Betweenness: Unreachable Subset Via a Path\""], ["", "definition unreachable_subset_via :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> 'a \\<Rightarrow> 'a set\"\n                                     (\"\\<emptyset> _ from _ via _ at _\" [100, 100, 100, 100] 100) where\n  \"unreachable_subset_via Q Qa R x \\<equiv> {Qy. [[x Qy Qa]] \\<and> (\\<exists>Rw\\<in>R. Qa \\<in> \\<emptyset> Q Rw \\<and> Qy \\<in> \\<emptyset> Q Rw)}\""], ["", "section \"Betweenness: Chains\""], ["", "subsection \"Totally ordered chains with indexing\""], ["", "definition short_ch :: \"'a set \\<Rightarrow> bool\" where\n  \"short_ch X \\<equiv>\n    \\<comment>\\<open>EITHER two distinct events connected by a path\\<close>\n    \\<exists>x\\<in>X. \\<exists>y\\<in>X. path_ex x y \\<and> \\<not>(\\<exists>z\\<in>X. z\\<noteq>x \\<and> z\\<noteq>y)\""], ["", "text \\<open>Infinite sets have card 0, because card gives a natural number always.\\<close>"], ["", "definition long_ch_by_ord :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"long_ch_by_ord f X \\<equiv>\n    \\<comment>\\<open>OR at least three events such that any three events are ordered\\<close>\n    \\<exists>x\\<in>X. \\<exists>y\\<in>X. \\<exists>z\\<in>X. x\\<noteq>y \\<and> y\\<noteq>z \\<and> x\\<noteq>z \\<and> ordering f betw X\""], ["", "text \\<open>Does this restrict chains to lie on paths? Proven in Ch3's Interlude!\\<close>"], ["", "definition ch_by_ord :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"ch_by_ord f X \\<equiv> short_ch X \\<or> long_ch_by_ord f X\""], ["", "definition ch :: \"'a set \\<Rightarrow> bool\" where\n  \"ch X \\<equiv> \\<exists>f. ch_by_ord f X\""], ["", "text \\<open>\n  Since $f(0)$ is always in the chain, and plays a special role particularly for infinite chains\n  (as the 'endpoint', the non-finite edge) let us fix it straight in the definition.\n  Notice we require both \\<open>infinite X\\<close> and \\<open>long_ch_by_ord\\<close>, thus circumventing infinite\n  Isabelle sets having cardinality $0$.\n\\<close>"], ["", "definition semifin_chain:: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> bool\" (\"[_[_ ..]_]\") where\n  \"semifin_chain f x Q \\<equiv>\n    infinite Q \\<and> long_ch_by_ord f Q\n    \\<and> f 0 = x\""], ["", "definition fin_long_chain:: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> bool\"\n  (\"[_[_ .. _ ..  _]_]\") where\n  \"fin_long_chain f x y z Q \\<equiv>\n    x\\<noteq>y \\<and> x\\<noteq>z \\<and> y\\<noteq>z\n    \\<and> finite Q \\<and> long_ch_by_ord f Q\n    \\<and> f 0 = x \\<and> y\\<in>Q \\<and> f (card Q - 1) = z\""], ["", "lemma index_middle_element:\n  assumes \"[f[a..b..c]X]\"\n  shows \"\\<exists>n. 0<n \\<and> n<(card X - 1) \\<and> f n = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n>0. n < card X - 1 \\<and> f n = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n>0. n < card X - 1 \\<and> f n = b", "obtain n where n_def: \"n < card X\" \"f n = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < card X; f n = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis TernaryOrdering.ordering_def assms fin_long_chain_def long_ch_by_ord_def)"], ["proof (state)\nthis:\n  n < card X\n  f n = b\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. n < card X - 1 \\<and> f n = b", "have \"0<n \\<and> n<(card X - 1) \\<and> f n = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<and> n < card X - 1 \\<and> f n = b", "using assms fin_long_chain_def n_def"], ["proof (prove)\nusing this:\n  [f[a .. b ..  c]X]\n  [?f[?x .. ?y ..  ?z]?Q] \\<equiv>\n  ?x \\<noteq> ?y \\<and>\n  ?x \\<noteq> ?z \\<and>\n  ?y \\<noteq> ?z \\<and>\n  finite ?Q \\<and>\n  long_ch_by_ord ?f ?Q \\<and>\n  ?f 0 = ?x \\<and> ?y \\<in> ?Q \\<and> ?f (card ?Q - 1) = ?z\n  n < card X\n  f n = b\n\ngoal (1 subgoal):\n 1. 0 < n \\<and> n < card X - 1 \\<and> f n = b", "by (metis Suc_pred' gr_implies_not0 less_SucE not_gr_zero)"], ["proof (state)\nthis:\n  0 < n \\<and> n < card X - 1 \\<and> f n = b\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. n < card X - 1 \\<and> f n = b", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < n \\<and> n < card X - 1 \\<and> f n = b\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. n < card X - 1 \\<and> f n = b", "by blast"], ["proof (state)\nthis:\n  \\<exists>n>0. n < card X - 1 \\<and> f n = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_ch_betw:\n  assumes \"[f[a..b..c]X]\"\n  shows \"[[a b c]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[a b c]]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [[a b c]]", "obtain nb where n_def: \"nb\\<noteq>0\" \"nb<card X - 1\" \"f nb = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nb.\n        \\<lbrakk>nb \\<noteq> 0; nb < card X - 1; f nb = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms index_middle_element"], ["proof (prove)\nusing this:\n  [f[a .. b ..  c]X]\n  [?f[?a .. ?b ..  ?c]?X] \\<Longrightarrow>\n  \\<exists>n>0. n < card ?X - 1 \\<and> ?f n = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>nb.\n        \\<lbrakk>nb \\<noteq> 0; nb < card X - 1; f nb = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nb \\<noteq> 0\n  nb < card X - 1\n  f nb = b\n\ngoal (1 subgoal):\n 1. [[a b c]]", "have \"[[(f 0) (f nb) (f (card X - 1))]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[f 0 f nb f (card X - 1)]]", "using fin_long_chain_def long_ch_by_ord_def assms n_def ordering_ord_ijk zero_less_iff_neq_zero"], ["proof (prove)\nusing this:\n  [?f[?x .. ?y ..  ?z]?Q] \\<equiv>\n  ?x \\<noteq> ?y \\<and>\n  ?x \\<noteq> ?z \\<and>\n  ?y \\<noteq> ?z \\<and>\n  finite ?Q \\<and>\n  long_ch_by_ord ?f ?Q \\<and>\n  ?f 0 = ?x \\<and> ?y \\<in> ?Q \\<and> ?f (card ?Q - 1) = ?z\n  long_ch_by_ord ?f ?X \\<equiv>\n  \\<exists>x\\<in>?X.\n     \\<exists>y\\<in>?X.\n        \\<exists>z\\<in>?X.\n           x \\<noteq> y \\<and>\n           y \\<noteq> z \\<and>\n           x \\<noteq> z \\<and> TernaryOrdering.ordering ?f betw ?X\n  [f[a .. b ..  c]X]\n  nb \\<noteq> 0\n  nb < card X - 1\n  f nb = b\n  \\<lbrakk>TernaryOrdering.ordering ?f ?ord ?X;\n   ?i < ?j \\<and>\n   ?j < ?k \\<and> (finite ?X \\<longrightarrow> ?k < card ?X)\\<rbrakk>\n  \\<Longrightarrow> ?ord (?f ?i) (?f ?j) (?f ?k)\n  ((0::?'a) < ?n) = (?n \\<noteq> (0::?'a))\n\ngoal (1 subgoal):\n 1. [[f 0 f nb f (card X - 1)]]", "by fastforce"], ["proof (state)\nthis:\n  [[f 0 f nb f (card X - 1)]]\n\ngoal (1 subgoal):\n 1. [[a b c]]", "thus ?thesis"], ["proof (prove)\nusing this:\n  [[f 0 f nb f (card X - 1)]]\n\ngoal (1 subgoal):\n 1. [[a b c]]", "using assms fin_long_chain_def n_def(3)"], ["proof (prove)\nusing this:\n  [[f 0 f nb f (card X - 1)]]\n  [f[a .. b ..  c]X]\n  [?f[?x .. ?y ..  ?z]?Q] \\<equiv>\n  ?x \\<noteq> ?y \\<and>\n  ?x \\<noteq> ?z \\<and>\n  ?y \\<noteq> ?z \\<and>\n  finite ?Q \\<and>\n  long_ch_by_ord ?f ?Q \\<and>\n  ?f 0 = ?x \\<and> ?y \\<in> ?Q \\<and> ?f (card ?Q - 1) = ?z\n  f nb = b\n\ngoal (1 subgoal):\n 1. [[a b c]]", "by auto"], ["proof (state)\nthis:\n  [[a b c]]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_sym_obtain:\n  assumes \"[f[a..b..c]X]\"\n  obtains g where \"[g[c..b..a]X]\" and \"g=(\\<lambda>n. f (card X - 1 - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>[g[c .. b ..  a]X];\n         g = (\\<lambda>n. f (card X - 1 - n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ordering_sym assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a b c. ?ord a b c \\<Longrightarrow> ?ord c b a; finite ?X;\n   TernaryOrdering.ordering ?f ?ord ?X\\<rbrakk>\n  \\<Longrightarrow> TernaryOrdering.ordering\n                     (\\<lambda>n. ?f (card ?X - 1 - n)) ?ord ?X\n  [f[a .. b ..  c]X]\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>[g[c .. b ..  a]X];\n         g = (\\<lambda>n. f (card X - 1 - n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fin_long_chain_def long_ch_by_ord_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a b c. ?ord a b c \\<Longrightarrow> ?ord c b a; finite ?X;\n   TernaryOrdering.ordering ?f ?ord ?X\\<rbrakk>\n  \\<Longrightarrow> TernaryOrdering.ordering\n                     (\\<lambda>n. ?f (card ?X - 1 - n)) ?ord ?X\n  a \\<noteq> b \\<and>\n  a \\<noteq> c \\<and>\n  b \\<noteq> c \\<and>\n  finite X \\<and>\n  (\\<exists>x\\<in>X.\n      \\<exists>y\\<in>X.\n         \\<exists>z\\<in>X.\n            x \\<noteq> y \\<and>\n            y \\<noteq> z \\<and>\n            x \\<noteq> z \\<and> TernaryOrdering.ordering f betw X) \\<and>\n  f 0 = a \\<and> b \\<in> X \\<and> f (card X - 1) = c\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>c \\<noteq> b \\<and>\n                 c \\<noteq> a \\<and>\n                 b \\<noteq> a \\<and>\n                 finite X \\<and>\n                 (\\<exists>x\\<in>X.\n                     \\<exists>y\\<in>X.\n                        \\<exists>z\\<in>X.\n                           x \\<noteq> y \\<and>\n                           y \\<noteq> z \\<and>\n                           x \\<noteq> z \\<and>\n                           TernaryOrdering.ordering g betw X) \\<and>\n                 g 0 = c \\<and> b \\<in> X \\<and> g (card X - 1) = a;\n         g = (\\<lambda>n. f (card X - 1 - n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, lifting) abc_sym diff_self_eq_0 diff_zero)"], ["", "lemma chain_sym:\n  assumes \"[f[a..b..c]X]\"\n    shows \"[\\<lambda>n. f (card X - 1 - n)[c..b..a]X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>n. f (card X - 1 - n)[c .. b ..  a]X]", "using chain_sym_obtain [where f=f and a=a and b=b and c=c and X=X]"], ["proof (prove)\nusing this:\n  \\<lbrakk>[f[a .. b ..  c]X];\n   \\<And>g.\n      \\<lbrakk>[g[c .. b ..  a]X];\n       g = (\\<lambda>n. f (card X - 1 - n))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. [\\<lambda>n. f (card X - 1 - n)[c .. b ..  a]X]", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>[f[a .. b ..  c]X];\n   \\<And>g.\n      \\<lbrakk>[g[c .. b ..  a]X];\n       g = (\\<lambda>n. f (card X - 1 - n))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  [f[a .. b ..  c]X]\n\ngoal (1 subgoal):\n 1. [\\<lambda>n. f (card X - 1 - n)[c .. b ..  a]X]", "by blast"], ["", "definition fin_long_chain_2:: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"fin_long_chain_2 x y z Q \\<equiv> \\<exists>f. [f[x..y..z]Q]\""], ["", "definition fin_chain:: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> bool\" (\"[_[_ .. _]_]\") where\n  \"fin_chain f x y Q \\<equiv>\n    (short_ch Q \\<and> x\\<in>Q \\<and> y\\<in>Q \\<and> x\\<noteq>y)\n    \\<or> (\\<exists>z\\<in>Q. [f[x..z..y]Q])\""], ["", "lemma points_in_chain:\n  assumes \"[f[x..y..z]Q]\"\n  shows \"x\\<in>Q \\<and> y\\<in>Q \\<and> z\\<in>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q", "have \"x\\<in>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Q", "using ordering_def assms card_gt_0_iff emptyE fin_long_chain_def long_ch_by_ord_def"], ["proof (prove)\nusing this:\n  TernaryOrdering.ordering ?f ?ord ?X \\<equiv>\n  (\\<forall>n.\n      (finite ?X \\<longrightarrow> n < card ?X) \\<longrightarrow>\n      ?f n \\<in> ?X) \\<and>\n  (\\<forall>x\\<in>?X.\n      \\<exists>n.\n         (finite ?X \\<longrightarrow> n < card ?X) \\<and> ?f n = x) \\<and>\n  (\\<forall>n n' n''.\n      (finite ?X \\<longrightarrow> n'' < card ?X) \\<and>\n      n < n' \\<and> n' < n'' \\<longrightarrow>\n      ?ord (?f n) (?f n') (?f n''))\n  [f[x .. y ..  z]Q]\n  (0 < card ?A) = (?A \\<noteq> {} \\<and> finite ?A)\n  ?a \\<in> {} \\<Longrightarrow> ?P\n  [?f[?x .. ?y ..  ?z]?Q] \\<equiv>\n  ?x \\<noteq> ?y \\<and>\n  ?x \\<noteq> ?z \\<and>\n  ?y \\<noteq> ?z \\<and>\n  finite ?Q \\<and>\n  long_ch_by_ord ?f ?Q \\<and>\n  ?f 0 = ?x \\<and> ?y \\<in> ?Q \\<and> ?f (card ?Q - 1) = ?z\n  long_ch_by_ord ?f ?X \\<equiv>\n  \\<exists>x\\<in>?X.\n     \\<exists>y\\<in>?X.\n        \\<exists>z\\<in>?X.\n           x \\<noteq> y \\<and>\n           y \\<noteq> z \\<and>\n           x \\<noteq> z \\<and> TernaryOrdering.ordering ?f betw ?X\n\ngoal (1 subgoal):\n 1. x \\<in> Q", "by metis"], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q", "moreover"], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q", "have \"y\\<in>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> Q", "using assms fin_long_chain_def"], ["proof (prove)\nusing this:\n  [f[x .. y ..  z]Q]\n  [?f[?x .. ?y ..  ?z]?Q] \\<equiv>\n  ?x \\<noteq> ?y \\<and>\n  ?x \\<noteq> ?z \\<and>\n  ?y \\<noteq> ?z \\<and>\n  finite ?Q \\<and>\n  long_ch_by_ord ?f ?Q \\<and>\n  ?f 0 = ?x \\<and> ?y \\<in> ?Q \\<and> ?f (card ?Q - 1) = ?z\n\ngoal (1 subgoal):\n 1. y \\<in> Q", "by auto"], ["proof (state)\nthis:\n  y \\<in> Q\n\ngoal (1 subgoal):\n 1. x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q", "moreover"], ["proof (state)\nthis:\n  y \\<in> Q\n\ngoal (1 subgoal):\n 1. x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q", "have \"z\\<in>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> Q", "using ordering_def assms card_gt_0_iff emptyE fin_long_chain_def long_ch_by_ord_def"], ["proof (prove)\nusing this:\n  TernaryOrdering.ordering ?f ?ord ?X \\<equiv>\n  (\\<forall>n.\n      (finite ?X \\<longrightarrow> n < card ?X) \\<longrightarrow>\n      ?f n \\<in> ?X) \\<and>\n  (\\<forall>x\\<in>?X.\n      \\<exists>n.\n         (finite ?X \\<longrightarrow> n < card ?X) \\<and> ?f n = x) \\<and>\n  (\\<forall>n n' n''.\n      (finite ?X \\<longrightarrow> n'' < card ?X) \\<and>\n      n < n' \\<and> n' < n'' \\<longrightarrow>\n      ?ord (?f n) (?f n') (?f n''))\n  [f[x .. y ..  z]Q]\n  (0 < card ?A) = (?A \\<noteq> {} \\<and> finite ?A)\n  ?a \\<in> {} \\<Longrightarrow> ?P\n  [?f[?x .. ?y ..  ?z]?Q] \\<equiv>\n  ?x \\<noteq> ?y \\<and>\n  ?x \\<noteq> ?z \\<and>\n  ?y \\<noteq> ?z \\<and>\n  finite ?Q \\<and>\n  long_ch_by_ord ?f ?Q \\<and>\n  ?f 0 = ?x \\<and> ?y \\<in> ?Q \\<and> ?f (card ?Q - 1) = ?z\n  long_ch_by_ord ?f ?X \\<equiv>\n  \\<exists>x\\<in>?X.\n     \\<exists>y\\<in>?X.\n        \\<exists>z\\<in>?X.\n           x \\<noteq> y \\<and>\n           y \\<noteq> z \\<and>\n           x \\<noteq> z \\<and> TernaryOrdering.ordering ?f betw ?X\n\ngoal (1 subgoal):\n 1. z \\<in> Q", "by (metis (no_types, hide_lams) Suc_diff_1 lessI)"], ["proof (state)\nthis:\n  z \\<in> Q\n\ngoal (1 subgoal):\n 1. x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> Q\n  y \\<in> Q\n  z \\<in> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Q\n  y \\<in> Q\n  z \\<in> Q\n\ngoal (1 subgoal):\n 1. x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q", "by blast"], ["proof (state)\nthis:\n  x \\<in> Q \\<and> y \\<in> Q \\<and> z \\<in> Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ch_long_if_card_ge3:\n  assumes \"ch X\"\n      and \"card X \\<ge> 3\"\n    shows \"\\<exists>f. long_ch_by_ord f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. long_ch_by_ord f X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>f. long_ch_by_ord f X \\<Longrightarrow> False", "assume \"\\<nexists>f. long_ch_by_ord f X\""], ["proof (state)\nthis:\n  \\<nexists>f. long_ch_by_ord f X\n\ngoal (1 subgoal):\n 1. \\<nexists>f. long_ch_by_ord f X \\<Longrightarrow> False", "hence \"short_ch X\""], ["proof (prove)\nusing this:\n  \\<nexists>f. long_ch_by_ord f X\n\ngoal (1 subgoal):\n 1. short_ch X", "using assms(1) ch_by_ord_def ch_def"], ["proof (prove)\nusing this:\n  \\<nexists>f. long_ch_by_ord f X\n  ch X\n  ch_by_ord ?f ?X \\<equiv> short_ch ?X \\<or> long_ch_by_ord ?f ?X\n  ch ?X \\<equiv> \\<exists>f. ch_by_ord f ?X\n\ngoal (1 subgoal):\n 1. short_ch X", "by auto"], ["proof (state)\nthis:\n  short_ch X\n\ngoal (1 subgoal):\n 1. \\<nexists>f. long_ch_by_ord f X \\<Longrightarrow> False", "obtain x y z where \"x\\<in>X \\<and> y\\<in>X \\<and> z\\<in>X\" and \"x\\<noteq>y \\<and> y\\<noteq>z \\<and> x\\<noteq>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>x \\<in> X \\<and> y \\<in> X \\<and> z \\<in> X;\n         x \\<noteq> y \\<and> y \\<noteq> z \\<and> x \\<noteq> z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  3 \\<le> card X\n\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>x \\<in> X \\<and> y \\<in> X \\<and> z \\<in> X;\n         x \\<noteq> y \\<and> y \\<noteq> z \\<and> x \\<noteq> z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: card_le_Suc_iff numeral_3_eq_3)"], ["proof (state)\nthis:\n  x \\<in> X \\<and> y \\<in> X \\<and> z \\<in> X\n  x \\<noteq> y \\<and> y \\<noteq> z \\<and> x \\<noteq> z\n\ngoal (1 subgoal):\n 1. \\<nexists>f. long_ch_by_ord f X \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  x \\<in> X \\<and> y \\<in> X \\<and> z \\<in> X\n  x \\<noteq> y \\<and> y \\<noteq> z \\<and> x \\<noteq> z\n\ngoal (1 subgoal):\n 1. False", "using \\<open>short_ch X\\<close> short_ch_def"], ["proof (prove)\nusing this:\n  x \\<in> X \\<and> y \\<in> X \\<and> z \\<in> X\n  x \\<noteq> y \\<and> y \\<noteq> z \\<and> x \\<noteq> z\n  short_ch X\n  short_ch ?X \\<equiv>\n  \\<exists>x\\<in>?X.\n     \\<exists>y\\<in>?X.\n        (\\<exists>Q. path Q x y) \\<and>\n        \\<not> (\\<exists>z\\<in>?X. z \\<noteq> x \\<and> z \\<noteq> y)\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Locally ordered chains with indexing\""], ["", "text \\<open>Definition for Schutz-like chains, with local order only.\\<close>"], ["", "definition long_ch_by_ord2 :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"long_ch_by_ord2 f X \\<equiv>\n    \\<exists>x\\<in>X. \\<exists>y\\<in>X. \\<exists>z\\<in>X. x\\<noteq>y \\<and> y\\<noteq>z \\<and> x\\<noteq>z \\<and> ordering2 f betw X\""], ["", "subsection \"Chains using betweenness\""], ["", "text \\<open>Old definitions of chains. Shown equivalent to \\<open>fin_long_chain_2\\<close> in TemporalOrderOnPath.thy.\\<close>"], ["", "definition chain_with :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> bool\" (\"[[.. _ .. _ .. _ ..]_]\") where\n  \"chain_with x y z X \\<equiv> [[x y z]] \\<and> x \\<in> X \\<and> y \\<in> X \\<and> z \\<in> X \\<and> (\\<exists>f. ordering f betw X)\""], ["", "definition finite_chain_with3 :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> bool\" (\"[[_ .. _ .. _]_]\") where\n  \"finite_chain_with3 x y z X \\<equiv> [[..x..y..z..]X] \\<and> \\<not>(\\<exists>w\\<in>X. [[w x y]] \\<or> [[y z w]])\""], ["", "lemma long_chain_betw: \"[[..a..b..c..]X] \\<Longrightarrow> [[a b c]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[.. a .. b .. c ..]X] \\<Longrightarrow> [[a b c]]", "by (simp add: chain_with_def)"], ["", "lemma finite_chain3_betw: \"[[a..b..c]X] \\<Longrightarrow> [[a b c]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[a .. b .. c]X] \\<Longrightarrow> [[a b c]]", "by (simp add: chain_with_def finite_chain_with3_def)"], ["", "definition finite_chain_with2 :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> bool\" (\"[[_ .. _]_]\") where\n  \"finite_chain_with2 x z X \\<equiv> \\<exists>y\\<in>X. [[x..y..z]X]\""], ["", "lemma finite_chain2_betw: \"[[a..c]X] \\<Longrightarrow> \\<exists>b. [[a b c]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[a .. c]X] \\<Longrightarrow> \\<exists>b. [[a b c]]", "using finite_chain_with2_def finite_chain3_betw"], ["proof (prove)\nusing this:\n  [[?x .. ?z]?X] \\<equiv> \\<exists>y\\<in>?X. [[?x .. y .. ?z]?X]\n  [[?a .. ?b .. ?c]?X] \\<Longrightarrow> [[?a ?b ?c]]\n\ngoal (1 subgoal):\n 1. [[a .. c]X] \\<Longrightarrow> \\<exists>b. [[a b c]]", "by meson"], ["", "section \"Betweenness: Rays and Intervals\""], ["", "text \\<open>\n  ``Given any two distinct events $a,b$ of a path we define the segment\n  $(ab) = \\left\\lbrace x : \\ord{a}{x}{b},\\; x \\in ab \\right\\rbrace$\" [Schutz97]\n  Our version is a little different, because it is defined for any $a,b$ of type \\<open>'a\\<close>.\n  Thus we can have empty set segments, while Schutz can prove (once he proves path density)\n  that segments are never empty.\n\\<close>"], ["", "definition segment :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set\"\n  where \"segment a b \\<equiv> {x::'a. \\<exists>ab. [[a x b]] \\<and> x\\<in>ab \\<and> path ab a b}\""], ["", "abbreviation is_segment :: \"'a set \\<Rightarrow> bool\"\n  where \"is_segment ab \\<equiv> (\\<exists>a b. ab = segment a b)\""], ["", "definition interval :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set\"\n  where \"interval a b \\<equiv> insert b (insert a (segment a b))\""], ["", "abbreviation is_interval :: \"'a set \\<Rightarrow> bool\"\n  where \"is_interval ab \\<equiv> (\\<exists>a b. ab = interval a b)\""], ["", "definition prolongation :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set\"\n  where \"prolongation a b \\<equiv> {x::'a. \\<exists>ab. [[a b x]] \\<and> x\\<in>ab \\<and> path ab a b}\""], ["", "abbreviation is_prolongation :: \"'a set \\<Rightarrow> bool\"\n  where \"is_prolongation ab \\<equiv> \\<exists>a b. ab = prolongation a b\""], ["", "text \\<open>\n  I think this is what Schutz actually meant, maybe there is a typo in the text?\n  Notice that \\<open>b \\<in> ray a b\\<close> for any $a$, always. Cf the comment on \\<open>segment_def\\<close>.\n  Thus \\<open>\\<exists>ray a b \\<noteq> {}\\<close> is no guarantee that a path $ab$ exists.\n\\<close>"], ["", "definition ray :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set\"\n  where \"ray a b \\<equiv> insert b (segment a b \\<union> prolongation a b)\""], ["", "abbreviation is_ray :: \"'a set \\<Rightarrow> bool\"\n  where \"is_ray R \\<equiv> \\<exists>a b. R = ray a b\""], ["", "definition is_ray_on :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\"\n  where \"is_ray_on R P \\<equiv> P\\<in>\\<P> \\<and> R\\<subseteq>P \\<and> is_ray R\""], ["", "text \\<open>This is as in Schutz. Notice $b$ is not in the ray through $b$?\\<close>"], ["", "definition ray_Schutz :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set\"\n  where \"ray_Schutz a b \\<equiv> insert a (segment a b \\<union> prolongation a b)\""], ["", "lemma ends_notin_segment: \"a \\<notin> segment a b \\<and> b \\<notin> segment a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> segment a b \\<and> b \\<notin> segment a b", "using abc_abc_neq segment_def"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow>\n  ?a \\<noteq> ?b \\<and> ?a \\<noteq> ?c \\<and> ?b \\<noteq> ?c\n  segment ?a ?b \\<equiv>\n  {x. \\<exists>ab. [[?a x ?b]] \\<and> x \\<in> ab \\<and> path ab ?a ?b}\n\ngoal (1 subgoal):\n 1. a \\<notin> segment a b \\<and> b \\<notin> segment a b", "by fastforce"], ["", "lemma ends_in_int: \"a \\<in> interval a b \\<and> b \\<in> interval a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> interval a b \\<and> b \\<in> interval a b", "using interval_def"], ["proof (prove)\nusing this:\n  interval ?a ?b \\<equiv> insert ?b (insert ?a (segment ?a ?b))\n\ngoal (1 subgoal):\n 1. a \\<in> interval a b \\<and> b \\<in> interval a b", "by auto"], ["", "lemma seg_betw: \"x \\<in> segment a b \\<longleftrightarrow> [[a x b]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> segment a b) = [[a x b]]", "using segment_def abc_abc_neq abc_ex_path"], ["proof (prove)\nusing this:\n  segment ?a ?b \\<equiv>\n  {x. \\<exists>ab. [[?a x ?b]] \\<and> x \\<in> ab \\<and> path ab ?a ?b}\n  [[?a ?b ?c]] \\<Longrightarrow>\n  ?a \\<noteq> ?b \\<and> ?a \\<noteq> ?c \\<and> ?b \\<noteq> ?c\n  [[?a ?b ?c]] \\<Longrightarrow>\n  \\<exists>Q\\<in>\\<P>. ?a \\<in> Q \\<and> ?b \\<in> Q \\<and> ?c \\<in> Q\n\ngoal (1 subgoal):\n 1. (x \\<in> segment a b) = [[a x b]]", "by fastforce"], ["", "lemma pro_betw: \"x \\<in> prolongation a b \\<longleftrightarrow> [[a b x]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> prolongation a b) = [[a b x]]", "using prolongation_def abc_abc_neq abc_ex_path"], ["proof (prove)\nusing this:\n  prolongation ?a ?b \\<equiv>\n  {x. \\<exists>ab. [[?a ?b x]] \\<and> x \\<in> ab \\<and> path ab ?a ?b}\n  [[?a ?b ?c]] \\<Longrightarrow>\n  ?a \\<noteq> ?b \\<and> ?a \\<noteq> ?c \\<and> ?b \\<noteq> ?c\n  [[?a ?b ?c]] \\<Longrightarrow>\n  \\<exists>Q\\<in>\\<P>. ?a \\<in> Q \\<and> ?b \\<in> Q \\<and> ?c \\<in> Q\n\ngoal (1 subgoal):\n 1. (x \\<in> prolongation a b) = [[a b x]]", "by fastforce"], ["", "lemma seg_sym: \"segment a b = segment b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. segment a b = segment b a", "using abc_sym segment_def"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow> [[?c ?b ?a]]\n  segment ?a ?b \\<equiv>\n  {x. \\<exists>ab. [[?a x ?b]] \\<and> x \\<in> ab \\<and> path ab ?a ?b}\n\ngoal (1 subgoal):\n 1. segment a b = segment b a", "by auto"], ["", "lemma empty_segment: \"segment a a = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. segment a a = {}", "by (simp add: segment_def)"], ["", "lemma int_sym: \"interval a b = interval b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interval a b = interval b a", "by (simp add: insert_commute interval_def seg_sym)"], ["", "lemma seg_path:\n  assumes \"x \\<in> segment a b\" (* thus segment \\<noteq> {} *)\n  obtains ab where \"path ab a b\" \"segment a b \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; segment a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; segment a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ab where \"path ab a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ab. path ab a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using abc_abc_neq abc_ex_path assms seg_betw"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow>\n  ?a \\<noteq> ?b \\<and> ?a \\<noteq> ?c \\<and> ?b \\<noteq> ?c\n  [[?a ?b ?c]] \\<Longrightarrow>\n  \\<exists>Q\\<in>\\<P>. ?a \\<in> Q \\<and> ?b \\<in> Q \\<and> ?c \\<in> Q\n  x \\<in> segment a b\n  (?x \\<in> segment ?a ?b) = [[?a ?x ?b]]\n\ngoal (1 subgoal):\n 1. (\\<And>ab. path ab a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  path ab a b\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; segment a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"segment a b \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. segment a b \\<subseteq> ab", "using \\<open>path ab a b\\<close> abc_ex_path path_unique seg_betw"], ["proof (prove)\nusing this:\n  path ab a b\n  [[?a ?b ?c]] \\<Longrightarrow>\n  \\<exists>Q\\<in>\\<P>. ?a \\<in> Q \\<and> ?b \\<in> Q \\<and> ?c \\<in> Q\n  \\<lbrakk>path ?ab ?a ?b; path ?ab' ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?ab = ?ab'\n  (?x \\<in> segment ?a ?b) = [[?a ?x ?b]]\n\ngoal (1 subgoal):\n 1. segment a b \\<subseteq> ab", "by fastforce"], ["proof (state)\nthis:\n  segment a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; segment a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  segment a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>path ab a b\\<close> that"], ["proof (prove)\nusing this:\n  segment a b \\<subseteq> ab\n  path ab a b\n  \\<lbrakk>path ?ab a b; segment a b \\<subseteq> ?ab\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seg_path2:\n  assumes \"segment a b \\<noteq> {}\"\n  obtains ab where \"path ab a b\" \"segment a b \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; segment a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms seg_path"], ["proof (prove)\nusing this:\n  segment a b \\<noteq> {}\n  \\<lbrakk>?x \\<in> segment ?a ?b;\n   \\<And>ab.\n      \\<lbrakk>path ab ?a ?b; segment ?a ?b \\<subseteq> ab\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; segment a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["", "text \\<open>Path density (theorem 17) will extend this by weakening the assumptions to \\<open>segment a b \\<noteq> {}\\<close>.\\<close>"], ["", "lemma seg_endpoints_on_path:\n  assumes \"card (segment a b) \\<ge> 2\" \"segment a b \\<subseteq> P\" \"P\\<in>\\<P>\"\n  shows \"path P a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path P a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path P a b", "have non_empty: \"segment a b \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. segment a b \\<noteq> {}", "using assms(1) numeral_2_eq_2"], ["proof (prove)\nusing this:\n  2 \\<le> card (segment a b)\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. segment a b \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  segment a b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path P a b", "then"], ["proof (chain)\npicking this:\n  segment a b \\<noteq> {}", "obtain ab where \"path ab a b\" \"segment a b \\<subseteq> ab\""], ["proof (prove)\nusing this:\n  segment a b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; segment a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using seg_path2"], ["proof (prove)\nusing this:\n  segment a b \\<noteq> {}\n  \\<lbrakk>segment ?a ?b \\<noteq> {};\n   \\<And>ab.\n      \\<lbrakk>path ab ?a ?b; segment ?a ?b \\<subseteq> ab\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; segment a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  path ab a b\n  segment a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. path P a b", "have \"a\\<noteq>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by (simp add: \\<open>path ab a b\\<close>)"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. path P a b", "obtain x y where \"x\\<in>segment a b\" \"y\\<in>segment a b\" \"x\\<noteq>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> segment a b; y \\<in> segment a b;\n         x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) numeral_2_eq_2"], ["proof (prove)\nusing this:\n  2 \\<le> card (segment a b)\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> segment a b; y \\<in> segment a b;\n         x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis card.infinite card_le_Suc0_iff_eq not_less_eq_eq not_numeral_le_zero)"], ["proof (state)\nthis:\n  x \\<in> segment a b\n  y \\<in> segment a b\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. path P a b", "have \"[[a x b]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[a x b]]", "using \\<open>x \\<in> segment a b\\<close> seg_betw"], ["proof (prove)\nusing this:\n  x \\<in> segment a b\n  (?x \\<in> segment ?a ?b) = [[?a ?x ?b]]\n\ngoal (1 subgoal):\n 1. [[a x b]]", "by auto"], ["proof (state)\nthis:\n  [[a x b]]\n\ngoal (1 subgoal):\n 1. path P a b", "have \"[[a y b]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[a y b]]", "using \\<open>y \\<in> segment a b\\<close> seg_betw"], ["proof (prove)\nusing this:\n  y \\<in> segment a b\n  (?x \\<in> segment ?a ?b) = [[?a ?x ?b]]\n\ngoal (1 subgoal):\n 1. [[a y b]]", "by auto"], ["proof (state)\nthis:\n  [[a y b]]\n\ngoal (1 subgoal):\n 1. path P a b", "have \"x\\<in>P \\<and> y\\<in>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> P \\<and> y \\<in> P", "using \\<open>x \\<in> segment a b\\<close> \\<open>y \\<in> segment a b\\<close> assms(2)"], ["proof (prove)\nusing this:\n  x \\<in> segment a b\n  y \\<in> segment a b\n  segment a b \\<subseteq> P\n\ngoal (1 subgoal):\n 1. x \\<in> P \\<and> y \\<in> P", "by blast"], ["proof (state)\nthis:\n  x \\<in> P \\<and> y \\<in> P\n\ngoal (1 subgoal):\n 1. path P a b", "have \"x\\<in>ab \\<and> y\\<in>ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ab \\<and> y \\<in> ab", "using \\<open>segment a b \\<subseteq> ab\\<close> \\<open>x \\<in> segment a b\\<close> \\<open>y \\<in> segment a b\\<close>"], ["proof (prove)\nusing this:\n  segment a b \\<subseteq> ab\n  x \\<in> segment a b\n  y \\<in> segment a b\n\ngoal (1 subgoal):\n 1. x \\<in> ab \\<and> y \\<in> ab", "by blast"], ["proof (state)\nthis:\n  x \\<in> ab \\<and> y \\<in> ab\n\ngoal (1 subgoal):\n 1. path P a b", "have \"ab=P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ab = P", "using \\<open>path ab a b\\<close> \\<open>x \\<in> P \\<and> y \\<in> P\\<close> \\<open>x \\<in> ab \\<and> y \\<in> ab\\<close> \\<open>x \\<noteq> y\\<close> assms(3) path_unique"], ["proof (prove)\nusing this:\n  path ab a b\n  x \\<in> P \\<and> y \\<in> P\n  x \\<in> ab \\<and> y \\<in> ab\n  x \\<noteq> y\n  P \\<in> \\<P>\n  \\<lbrakk>path ?ab ?a ?b; path ?ab' ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?ab = ?ab'\n\ngoal (1 subgoal):\n 1. ab = P", "by auto"], ["proof (state)\nthis:\n  ab = P\n\ngoal (1 subgoal):\n 1. path P a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  ab = P\n\ngoal (1 subgoal):\n 1. path P a b", "using \\<open>path ab a b\\<close>"], ["proof (prove)\nusing this:\n  ab = P\n  path ab a b\n\ngoal (1 subgoal):\n 1. path P a b", "by auto"], ["proof (state)\nthis:\n  path P a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pro_path:\n  assumes \"x \\<in> prolongation a b\" (* thus prolongation \\<noteq> {} *)\n  obtains ab where \"path ab a b\" \"prolongation a b \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; prolongation a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; prolongation a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ab where \"path ab a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ab. path ab a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using abc_abc_neq abc_ex_path assms pro_betw"], ["proof (prove)\nusing this:\n  [[?a ?b ?c]] \\<Longrightarrow>\n  ?a \\<noteq> ?b \\<and> ?a \\<noteq> ?c \\<and> ?b \\<noteq> ?c\n  [[?a ?b ?c]] \\<Longrightarrow>\n  \\<exists>Q\\<in>\\<P>. ?a \\<in> Q \\<and> ?b \\<in> Q \\<and> ?c \\<in> Q\n  x \\<in> prolongation a b\n  (?x \\<in> prolongation ?a ?b) = [[?a ?b ?x]]\n\ngoal (1 subgoal):\n 1. (\\<And>ab. path ab a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  path ab a b\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; prolongation a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"prolongation a b \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prolongation a b \\<subseteq> ab", "using \\<open>path ab a b\\<close> abc_ex_path path_unique pro_betw"], ["proof (prove)\nusing this:\n  path ab a b\n  [[?a ?b ?c]] \\<Longrightarrow>\n  \\<exists>Q\\<in>\\<P>. ?a \\<in> Q \\<and> ?b \\<in> Q \\<and> ?c \\<in> Q\n  \\<lbrakk>path ?ab ?a ?b; path ?ab' ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?ab = ?ab'\n  (?x \\<in> prolongation ?a ?b) = [[?a ?b ?x]]\n\ngoal (1 subgoal):\n 1. prolongation a b \\<subseteq> ab", "by fastforce"], ["proof (state)\nthis:\n  prolongation a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        \\<lbrakk>path ab a b; prolongation a b \\<subseteq> ab\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  prolongation a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>path ab a b\\<close> that"], ["proof (prove)\nusing this:\n  prolongation a b \\<subseteq> ab\n  path ab a b\n  \\<lbrakk>path ?ab a b; prolongation a b \\<subseteq> ?ab\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ray_cases:\n  assumes \"x \\<in> ray a b\"\n  shows \"[[a x b]] \\<or> [[a b x]] \\<or> x = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[a x b]] \\<or> [[a b x]] \\<or> x = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [[a x b]] \\<or> [[a b x]] \\<or> x = b", "have \"x\\<in>segment a b \\<or> x\\<in> prolongation a b \\<or> x=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> segment a b \\<or> x \\<in> prolongation a b \\<or> x = b", "using assms ray_def"], ["proof (prove)\nusing this:\n  x \\<in> ray a b\n  ray ?a ?b \\<equiv> insert ?b (segment ?a ?b \\<union> prolongation ?a ?b)\n\ngoal (1 subgoal):\n 1. x \\<in> segment a b \\<or> x \\<in> prolongation a b \\<or> x = b", "by auto"], ["proof (state)\nthis:\n  x \\<in> segment a b \\<or> x \\<in> prolongation a b \\<or> x = b\n\ngoal (1 subgoal):\n 1. [[a x b]] \\<or> [[a b x]] \\<or> x = b", "thus \"[[a x b]] \\<or> [[a b x]] \\<or> x = b\""], ["proof (prove)\nusing this:\n  x \\<in> segment a b \\<or> x \\<in> prolongation a b \\<or> x = b\n\ngoal (1 subgoal):\n 1. [[a x b]] \\<or> [[a b x]] \\<or> x = b", "using pro_betw seg_betw"], ["proof (prove)\nusing this:\n  x \\<in> segment a b \\<or> x \\<in> prolongation a b \\<or> x = b\n  (?x \\<in> prolongation ?a ?b) = [[?a ?b ?x]]\n  (?x \\<in> segment ?a ?b) = [[?a ?x ?b]]\n\ngoal (1 subgoal):\n 1. [[a x b]] \\<or> [[a b x]] \\<or> x = b", "by auto"], ["proof (state)\nthis:\n  [[a x b]] \\<or> [[a b x]] \\<or> x = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ray_path:\n  assumes \"x \\<in> ray a b\" \"x\\<noteq>b\"\n  obtains ab where \"path ab a b \\<and> ray a b \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        path ab a b \\<and> ray a b \\<subseteq> ab \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        path ab a b \\<and> ray a b \\<subseteq> ab \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?r = \"ray a b\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        path ab a b \\<and> ray a b \\<subseteq> ab \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"?r \\<noteq> {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ray a b \\<noteq> {b}", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> ray a b\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. ray a b \\<noteq> {b}", "by blast"], ["proof (state)\nthis:\n  ray a b \\<noteq> {b}\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        path ab a b \\<and> ray a b \\<subseteq> ab \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab", "have betw_cases: \"[[a x b]] \\<or> [[a b x]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[a x b]] \\<or> [[a b x]]", "using ray_cases assms"], ["proof (prove)\nusing this:\n  ?x \\<in> ray ?a ?b \\<Longrightarrow>\n  [[?a ?x ?b]] \\<or> [[?a ?b ?x]] \\<or> ?x = ?b\n  x \\<in> ray a b\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. [[a x b]] \\<or> [[a b x]]", "by blast"], ["proof (state)\nthis:\n  [[a x b]] \\<or> [[a b x]]\n\ngoal (1 subgoal):\n 1. \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab", "then"], ["proof (chain)\npicking this:\n  [[a x b]] \\<or> [[a b x]]", "obtain ab where \"path ab a b\""], ["proof (prove)\nusing this:\n  [[a x b]] \\<or> [[a b x]]\n\ngoal (1 subgoal):\n 1. (\\<And>ab. path ab a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using abc_abc_neq abc_ex_path"], ["proof (prove)\nusing this:\n  [[a x b]] \\<or> [[a b x]]\n  [[?a ?b ?c]] \\<Longrightarrow>\n  ?a \\<noteq> ?b \\<and> ?a \\<noteq> ?c \\<and> ?b \\<noteq> ?c\n  [[?a ?b ?c]] \\<Longrightarrow>\n  \\<exists>Q\\<in>\\<P>. ?a \\<in> Q \\<and> ?b \\<in> Q \\<and> ?c \\<in> Q\n\ngoal (1 subgoal):\n 1. (\\<And>ab. path ab a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path ab a b\n\ngoal (1 subgoal):\n 1. \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab", "have \"?r \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ray a b \\<subseteq> ab", "using betw_cases"], ["proof (prove)\nusing this:\n  [[a x b]] \\<or> [[a b x]]\n\ngoal (1 subgoal):\n 1. ray a b \\<subseteq> ab", "proof (rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. [[a x b]] \\<Longrightarrow> ray a b \\<subseteq> ab\n 2. [[a b x]] \\<Longrightarrow> ray a b \\<subseteq> ab", "assume \"[[a x b]]\""], ["proof (state)\nthis:\n  [[a x b]]\n\ngoal (2 subgoals):\n 1. [[a x b]] \\<Longrightarrow> ray a b \\<subseteq> ab\n 2. [[a b x]] \\<Longrightarrow> ray a b \\<subseteq> ab", "show \"?r \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ray a b \\<subseteq> ab", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ray a b \\<Longrightarrow> x \\<in> ab", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ray a b \\<Longrightarrow> x \\<in> ab", "assume \"x\\<in>?r\""], ["proof (state)\nthis:\n  x \\<in> ray a b\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ray a b \\<Longrightarrow> x \\<in> ab", "show \"x\\<in>ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ab", "by (metis \\<open>path ab a b\\<close> \\<open>x \\<in> ray a b\\<close> abc_ex_path eq_paths ray_cases)"], ["proof (state)\nthis:\n  x \\<in> ab\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ray a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. [[a b x]] \\<Longrightarrow> ray a b \\<subseteq> ab", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [[a b x]] \\<Longrightarrow> ray a b \\<subseteq> ab", "assume \"[[a b x]]\""], ["proof (state)\nthis:\n  [[a b x]]\n\ngoal (1 subgoal):\n 1. [[a b x]] \\<Longrightarrow> ray a b \\<subseteq> ab", "show \"?r \\<subseteq> ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ray a b \\<subseteq> ab", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ray a b \\<Longrightarrow> x \\<in> ab", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ray a b \\<Longrightarrow> x \\<in> ab", "assume \"x\\<in>?r\""], ["proof (state)\nthis:\n  x \\<in> ray a b\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ray a b \\<Longrightarrow> x \\<in> ab", "show \"x\\<in>ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ab", "by (metis \\<open>path ab a b\\<close> \\<open>x \\<in> ray a b\\<close> abc_ex_path eq_paths ray_cases)"], ["proof (state)\nthis:\n  x \\<in> ab\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ray a b \\<subseteq> ab\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ray a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab", "thus ?thesis"], ["proof (prove)\nusing this:\n  ray a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab", "using \\<open>path ab a b\\<close>"], ["proof (prove)\nusing this:\n  ray a b \\<subseteq> ab\n  path ab a b\n\ngoal (1 subgoal):\n 1. \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab", "by blast"], ["proof (state)\nthis:\n  \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. (\\<And>ab.\n        path ab a b \\<and> ray a b \\<subseteq> ab \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>ab. path ab a b \\<and> ray a b \\<subseteq> ab\n  path ?ab a b \\<and> ray a b \\<subseteq> ?ab \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* MinkowskiBetweenness *)"], ["", "section \"MinkowskiChain: O6\""], ["", "text \\<open>O6 supposedly serves the same purpose as Pasch's axiom.\\<close>"], ["", "locale MinkowskiChain = MinkowskiBetweenness +\n  assumes O6: \"\\<lbrakk>Q \\<in> \\<P>; R \\<in> \\<P>; S \\<in> \\<P>; T \\<in> \\<P>; Q \\<noteq> R; Q \\<noteq> S; R \\<noteq> S; a \\<in> Q\\<inter>R \\<and> b \\<in> Q\\<inter>S \\<and> c \\<in> R\\<inter>S;\n                \\<exists>d\\<in>S. [[b c d]] \\<and> (\\<exists>e\\<in>R. d \\<in> T \\<and> e \\<in> T \\<and> [[c e a]])\\<rbrakk>\n               \\<Longrightarrow> \\<exists>f\\<in>T\\<inter>Q. \\<exists>X. [[a..f..b]X]\"\nbegin"], ["", "section \"Chains: (Closest) Bounds\""], ["", "definition is_bound_f :: \"'a \\<Rightarrow> 'a set \\<Rightarrow> (nat\\<Rightarrow>'a) \\<Rightarrow> bool\" where\n  \"is_bound_f Q\\<^sub>b Q f \\<equiv>\n    \\<forall>i j ::nat. [f[(f 0)..]Q] \\<and> (i<j \\<longrightarrow> [[(f i) (f j) Q\\<^sub>b]])\""], ["", "definition is_bound :: \"'a \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"is_bound Q\\<^sub>b Q \\<equiv>\n    \\<exists>f::(nat\\<Rightarrow>'a). is_bound_f Q\\<^sub>b Q f\""], ["", "text \\<open>\n  $Q_b$ has to be on the same path as the chain $Q$.\n  This is left implicit in the betweenness condition (as is $Q_b\\in\\E$).\n  So this is equivalent to Schutz only if we also assume his axioms,\n  i.e. the statement of the continuity axiom is no longer independent of other axioms.\n\\<close>"], ["", "definition all_bounds :: \"'a set \\<Rightarrow> 'a set\" where\n  \"all_bounds Q = {Q\\<^sub>b. is_bound Q\\<^sub>b Q}\""], ["", "definition bounded :: \"'a set \\<Rightarrow> bool\" where\n  \"bounded Q \\<equiv> \\<exists> Q\\<^sub>b. is_bound Q\\<^sub>b Q\""], ["", "text \\<open>Just to make sure Continuity is not too strong.\\<close>"], ["", "lemma bounded_imp_inf:\n  assumes \"bounded Q\"\n  shows \"infinite Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite Q", "using assms bounded_def is_bound_def is_bound_f_def semifin_chain_def"], ["proof (prove)\nusing this:\n  bounded Q\n  bounded ?Q \\<equiv> \\<exists>Q\\<^sub>b. is_bound Q\\<^sub>b ?Q\n  is_bound ?Q\\<^sub>b ?Q \\<equiv> \\<exists>f. is_bound_f ?Q\\<^sub>b ?Q f\n  is_bound_f ?Q\\<^sub>b ?Q ?f \\<equiv>\n  \\<forall>i j.\n     [?f[?f 0 ..]?Q] \\<and>\n     (i < j \\<longrightarrow> [[?f i ?f j ?Q\\<^sub>b]])\n  [?f[?x ..]?Q] \\<equiv>\n  infinite ?Q \\<and> long_ch_by_ord ?f ?Q \\<and> ?f 0 = ?x\n\ngoal (1 subgoal):\n 1. infinite Q", "by blast"], ["", "definition closest_bound_f :: \"'a \\<Rightarrow> 'a set \\<Rightarrow> (nat\\<Rightarrow>'a) \\<Rightarrow> bool\" where\n  \"closest_bound_f Q\\<^sub>b Q f \\<equiv>\n\\<^cancel>\\<open>Q is an infinite chain indexed by f bound by Q\\<^sub>b\\<close>\n    is_bound_f Q\\<^sub>b Q f \\<and>\n\\<^cancel>\\<open>Any other bound must be further from the start of the chain than the closest bound\\<close>\n    (\\<forall> Q\\<^sub>b'. (is_bound Q\\<^sub>b' Q \\<and> Q\\<^sub>b' \\<noteq> Q\\<^sub>b) \\<longrightarrow> [[(f 0) Q\\<^sub>b Q\\<^sub>b']])\""], ["", "definition closest_bound :: \"'a \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"closest_bound Q\\<^sub>b Q \\<equiv>\n\\<^cancel>\\<open>Q is an infinite chain indexed by f bound by Q\\<^sub>b\\<close>\n    \\<exists>f. is_bound_f Q\\<^sub>b Q f \\<and>\n\\<^cancel>\\<open>Any other bound must be further from the start of the chain than the closest bound\\<close>\n    (\\<forall> Q\\<^sub>b'. (is_bound Q\\<^sub>b' Q \\<and> Q\\<^sub>b' \\<noteq> Q\\<^sub>b) \\<longrightarrow> [[(f 0) Q\\<^sub>b Q\\<^sub>b']])\""], ["", "end"], ["", "(*MinkowskiChain*)"], ["", "section \"MinkowskiUnreachable: I5-I7\""], ["", "locale MinkowskiUnreachable = MinkowskiChain +\n  (* I5 *)\n  assumes two_in_unreach: \"\\<lbrakk>Q \\<in> \\<P>; b \\<in> \\<E>; b \\<notin> Q\\<rbrakk> \\<Longrightarrow> \\<exists>x\\<in>\\<emptyset> Q b. \\<exists>y\\<in>\\<emptyset> Q b. x \\<noteq> y\"\n\n      and I6: \"\\<lbrakk>Q \\<in> \\<P>; b \\<notin> Q; b \\<in> \\<E>; Qx \\<in> (\\<emptyset> Q b); Qz \\<in> (\\<emptyset> Q b); Qx\\<noteq>Qz\\<rbrakk>\n               \\<Longrightarrow> \\<exists>X. \\<exists>f. ch_by_ord f X \\<and> f 0 = Qx \\<and> f (card X - 1) = Qz\n                         \\<and> (\\<forall>i\\<in>{1 .. card X - 1}. (f i) \\<in> \\<emptyset> Q b\n                              \\<and> (\\<forall>Qy\\<in>\\<E>. [[(f(i-1)) Qy (f i)]] \\<longrightarrow> Qy \\<in> \\<emptyset> Q b))\n                         \\<and> (short_ch X \\<longrightarrow> Qx\\<in>X \\<and> Qz\\<in>X \\<and> (\\<forall>Qy\\<in>\\<E>. [[Qx Qy Qz]] \\<longrightarrow> Qy \\<in> \\<emptyset> Q b))\"\n      and I7: \"\\<lbrakk>Q \\<in> \\<P>; b \\<notin> Q; b \\<in> \\<E>; Qx \\<in> Q - \\<emptyset> Q b; Qy \\<in> \\<emptyset> Q b\\<rbrakk>\n               \\<Longrightarrow> \\<exists>g X Qn. [g[Qx..Qy..Qn]X] \\<and> Qn \\<in> Q - \\<emptyset> Q b\"\nbegin"], ["", "lemma card_unreach_geq_2:\n  assumes \"Q\\<in>\\<P>\" \"b\\<in>\\<E>-Q\"\n  shows \"2 \\<le> card (\\<emptyset> Q b) \\<or> (infinite (\\<emptyset> Q b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> card (\\<emptyset> Q b) \\<or> infinite (\\<emptyset> Q b)", "using DiffD1 assms(1) assms(2) card_le_Suc0_iff_eq two_in_unreach"], ["proof (prove)\nusing this:\n  ?c \\<in> ?A - ?B \\<Longrightarrow> ?c \\<in> ?A\n  Q \\<in> \\<P>\n  b \\<in> \\<E> - Q\n  finite ?A \\<Longrightarrow>\n  (card ?A \\<le> Suc 0) = (\\<forall>a1\\<in>?A. \\<forall>a2\\<in>?A. a1 = a2)\n  \\<lbrakk>?Q \\<in> \\<P>; ?b \\<in> \\<E>; ?b \\<notin> ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>\\<emptyset> ?Q ?b.\n                       \\<exists>y\\<in>\\<emptyset> ?Q ?b. x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (\\<emptyset> Q b) \\<or> infinite (\\<emptyset> Q b)", "by fastforce"], ["", "end"], ["", "section \"MinkowskiSymmetry: Symmetry\""], ["", "locale MinkowskiSymmetry = MinkowskiUnreachable +\n  assumes Symmetry: \"\\<lbrakk>Q \\<in> \\<P>; R \\<in> \\<P>; S \\<in> \\<P>; Q \\<noteq> R; Q \\<noteq> S; R \\<noteq> S;\n               x \\<in> Q\\<inter>R\\<inter>S; Q\\<^sub>a \\<in> Q; Q\\<^sub>a \\<noteq> x;\n               \\<emptyset> Q from Q\\<^sub>a via R at x = \\<emptyset> Q from Q\\<^sub>a via S at x\\<rbrakk>\n               \\<Longrightarrow> \\<exists>\\<theta>::'a\\<Rightarrow>'a.                               \\<^cancel>\\<open>i) there is a map \\<theta>:\\<E>\\<Rightarrow>\\<E>\\<close>\n                     bij_betw (\\<lambda>P. {\\<theta> y | y. y\\<in>P}) \\<P> \\<P>      \\<^cancel>\\<open>ii) which induces a bijection \\<Theta>\\<close>\n                     \\<and> (y\\<in>Q \\<longrightarrow> \\<theta> y = y)                    \\<^cancel>\\<open>iii) \\<theta> leaves Q invariant\\<close>\n                     \\<and> (\\<lambda>P. {\\<theta> y | y. y\\<in>P}) R = S     \\<^cancel>\\<open>iv) \\<Theta> maps R to S\\<close>\""], ["", "section \"MinkowskiContinuity: Continuity\""], ["", "locale MinkowskiContinuity = MinkowskiSymmetry +\n  assumes Continuity: \"bounded Q \\<Longrightarrow> (\\<exists>Q\\<^sub>b. closest_bound Q\\<^sub>b Q)\""], ["", "section \"MinkowskiSpacetime: Dimension (I4)\""], ["", "locale MinkowskiSpacetime = MinkowskiContinuity +\n  (* I4 *)\n  assumes ex_3SPRAY [simp]: \"\\<lbrakk>\\<E> \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>x\\<in>\\<E>. three_SPRAY x\"\nbegin"], ["", "(* substitute for I1, if I1 is omitted *)\n(* lemma nonempty_events:\n  \"\\<E> \\<noteq> {}\"\nusing ex_3SPRAY by blast *)"], ["", "text \\<open>\n  There exists an event by \\<open>nonempty_events\\<close>, and by \\<open>ex_3SPRAY\\<close> there is a three-$\\spray$, which by\n  \\<open>three_SPRAY_ge4\\<close> means that there are at least four paths.\n\\<close>"], ["", "lemma four_paths:\n  \"\\<exists>Q1\\<in>\\<P>. \\<exists>Q2\\<in>\\<P>. \\<exists>Q3\\<in>\\<P>. \\<exists>Q4\\<in>\\<P>. Q1 \\<noteq> Q2 \\<and> Q1 \\<noteq> Q3 \\<and> Q1 \\<noteq> Q4 \\<and> Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q1\\<in>\\<P>.\n       \\<exists>Q2\\<in>\\<P>.\n          \\<exists>Q3\\<in>\\<P>.\n             \\<exists>Q4\\<in>\\<P>.\n                Q1 \\<noteq> Q2 \\<and>\n                Q1 \\<noteq> Q3 \\<and>\n                Q1 \\<noteq> Q4 \\<and>\n                Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4", "using nonempty_events ex_3SPRAY three_SPRAY_ge4"], ["proof (prove)\nusing this:\n  \\<E> \\<noteq> {}\n  \\<E> \\<noteq> {} \\<Longrightarrow> Bex \\<E> three_SPRAY\n  three_SPRAY ?x \\<Longrightarrow>\n  \\<exists>Q1\\<in>\\<P>.\n     \\<exists>Q2\\<in>\\<P>.\n        \\<exists>Q3\\<in>\\<P>.\n           \\<exists>Q4\\<in>\\<P>.\n              Q1 \\<noteq> Q2 \\<and>\n              Q1 \\<noteq> Q3 \\<and>\n              Q1 \\<noteq> Q4 \\<and>\n              Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4\n\ngoal (1 subgoal):\n 1. \\<exists>Q1\\<in>\\<P>.\n       \\<exists>Q2\\<in>\\<P>.\n          \\<exists>Q3\\<in>\\<P>.\n             \\<exists>Q4\\<in>\\<P>.\n                Q1 \\<noteq> Q2 \\<and>\n                Q1 \\<noteq> Q3 \\<and>\n                Q1 \\<noteq> Q4 \\<and>\n                Q2 \\<noteq> Q3 \\<and> Q2 \\<noteq> Q4 \\<and> Q3 \\<noteq> Q4", "by blast"], ["", "end"], ["", "end"]]}