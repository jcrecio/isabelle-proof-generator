{"file_name": "/home/qj213/afp-2021-10-22/thys/Dirichlet_Series/Dirichlet_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dirichlet_Series", "problem_names": ["lemma\n  fixes a k :: nat\n  assumes \"a > 1\" \"k > 0\"\n  shows geometric_sum_nat_aux: \"(a - 1) * (\\<Sum>i<k. a ^ i) = a ^ k - 1\"\n    and geometric_sum_nat_dvd: \"a - 1 dvd a ^ k - 1\"\n    and geometric_sum_nat:     \"(\\<Sum>i<k. a ^ i) = (a ^ k - 1) div (a - 1)\"", "lemma dvd_div_gt0: \"d dvd n \\<Longrightarrow> n > 0 \\<Longrightarrow> n div d > (0::nat)\"", "lemma Set_filter_insert: \n  \"Set.filter P (insert x A) = (if P x then insert x (Set.filter P A) else Set.filter P A)\"", "lemma Set_filter_union: \"Set.filter P (A \\<union> B) = Set.filter P A \\<union> Set.filter P B\"", "lemma Set_filter_empty [simp]: \"Set.filter P {} = {}\"", "lemma Set_filter_image: \"Set.filter P (f ` A) = f ` Set.filter (P \\<circ> f) A\"", "lemma Set_filter_cong [cong]:\n    \"(\\<And>x. x \\<in> A \\<Longrightarrow> P x \\<longleftrightarrow> Q x) \\<Longrightarrow> A = B \\<Longrightarrow>  Set.filter P A = Set.filter Q B\"", "lemma finite_Set_filter: \"finite A \\<Longrightarrow> finite (Set.filter P A)\"", "lemma inj_on_insert': \"(\\<And>B. B \\<in> A \\<Longrightarrow> x \\<notin> B) \\<Longrightarrow> inj_on (insert x) A\"", "lemma\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows   card_even_subset_aux: \"card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)\"\n    and   card_odd_subset_aux:  \"card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\"\n    and   card_even_odd_subset: \"card {B. B \\<subseteq> A \\<and> even (card B)} = card {B. B \\<subseteq> A \\<and> odd (card B)}\"", "lemma bij_betw_prod_divisors_coprime:\n  assumes \"coprime a (b :: nat)\"\n  shows   \"bij_betw (\\<lambda>x. fst x * snd x) ({d. d dvd a} \\<times> {d. d dvd b}) {k. k dvd a * b}\"", "lemma bij_betw_prime_power_divisors:\n  assumes \"prime (p :: nat)\"\n  shows   \"bij_betw ((^) p) {..k} {d. d dvd p ^ k}\"", "lemma power_diff':\n  assumes \"m \\<ge> n\" \"x \\<noteq> 0\"\n  shows   \"x ^ (m - n) = (x ^ m div x ^ n :: 'a :: unique_euclidean_semiring)\"", "lemma sum_divisors_coprime_mult:\n  assumes \"coprime a (b :: nat)\"\n  shows   \"(\\<Sum>d | d dvd a * b. f d) = (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))\""], "translations": [["", "lemma\n  fixes a k :: nat\n  assumes \"a > 1\" \"k > 0\"\n  shows geometric_sum_nat_aux: \"(a - 1) * (\\<Sum>i<k. a ^ i) = a ^ k - 1\"\n    and geometric_sum_nat_dvd: \"a - 1 dvd a ^ k - 1\"\n    and geometric_sum_nat:     \"(\\<Sum>i<k. a ^ i) = (a ^ k - 1) div (a - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - 1) * sum ((^) a) {..<k} = a ^ k - 1 &&&\n    a - 1 dvd a ^ k - 1 &&& sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (a - 1) * sum ((^) a) {..<k} = a ^ k - 1\n 2. a - 1 dvd a ^ k - 1\n 3. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "have \"(real a - 1) * (\\<Sum>i<k. real a ^ i) = real a ^ k - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real a - 1) * sum ((^) (real a)) {..<k} = real a ^ k - 1", "using assms"], ["proof (prove)\nusing this:\n  1 < a\n  0 < k\n\ngoal (1 subgoal):\n 1. (real a - 1) * sum ((^) (real a)) {..<k} = real a ^ k - 1", "by (subst geometric_sum) auto"], ["proof (state)\nthis:\n  (real a - 1) * sum ((^) (real a)) {..<k} = real a ^ k - 1\n\ngoal (3 subgoals):\n 1. (a - 1) * sum ((^) a) {..<k} = a ^ k - 1\n 2. a - 1 dvd a ^ k - 1\n 3. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "also"], ["proof (state)\nthis:\n  (real a - 1) * sum ((^) (real a)) {..<k} = real a ^ k - 1\n\ngoal (3 subgoals):\n 1. (a - 1) * sum ((^) a) {..<k} = a ^ k - 1\n 2. a - 1 dvd a ^ k - 1\n 3. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "have \"(real a - 1) * (\\<Sum>i<k. real a ^ i) = real ((a - 1) * (\\<Sum>i<k. a ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real a - 1) * sum ((^) (real a)) {..<k} =\n    real ((a - 1) * sum ((^) a) {..<k})", "using assms"], ["proof (prove)\nusing this:\n  1 < a\n  0 < k\n\ngoal (1 subgoal):\n 1. (real a - 1) * sum ((^) (real a)) {..<k} =\n    real ((a - 1) * sum ((^) a) {..<k})", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  (real a - 1) * sum ((^) (real a)) {..<k} =\n  real ((a - 1) * sum ((^) a) {..<k})\n\ngoal (3 subgoals):\n 1. (a - 1) * sum ((^) a) {..<k} = a ^ k - 1\n 2. a - 1 dvd a ^ k - 1\n 3. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "also"], ["proof (state)\nthis:\n  (real a - 1) * sum ((^) (real a)) {..<k} =\n  real ((a - 1) * sum ((^) a) {..<k})\n\ngoal (3 subgoals):\n 1. (a - 1) * sum ((^) a) {..<k} = a ^ k - 1\n 2. a - 1 dvd a ^ k - 1\n 3. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "have \"real a ^ k - 1 = real (a ^ k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real a ^ k - 1 = real (a ^ k - 1)", "using assms"], ["proof (prove)\nusing this:\n  1 < a\n  0 < k\n\ngoal (1 subgoal):\n 1. real a ^ k - 1 = real (a ^ k - 1)", "by (subst of_nat_diff) auto"], ["proof (state)\nthis:\n  real a ^ k - 1 = real (a ^ k - 1)\n\ngoal (3 subgoals):\n 1. (a - 1) * sum ((^) a) {..<k} = a ^ k - 1\n 2. a - 1 dvd a ^ k - 1\n 3. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "finally"], ["proof (chain)\npicking this:\n  real ((a - 1) * sum ((^) a) {..<k}) = real (a ^ k - 1)", "show *: \"(a - 1) * (\\<Sum>i<k. a ^ i) = a ^ k - 1\""], ["proof (prove)\nusing this:\n  real ((a - 1) * sum ((^) a) {..<k}) = real (a ^ k - 1)\n\ngoal (1 subgoal):\n 1. (a - 1) * sum ((^) a) {..<k} = a ^ k - 1", "by (subst (asm) of_nat_eq_iff)"], ["proof (state)\nthis:\n  (a - 1) * sum ((^) a) {..<k} = a ^ k - 1\n\ngoal (2 subgoals):\n 1. a - 1 dvd a ^ k - 1\n 2. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "show \"a - 1 dvd a ^ k - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - 1 dvd a ^ k - 1", "by (subst * [symmetric]) simp"], ["proof (state)\nthis:\n  a - 1 dvd a ^ k - 1\n\ngoal (1 subgoal):\n 1. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "from assms"], ["proof (chain)\npicking this:\n  1 < a\n  0 < k", "show \"(\\<Sum>i<k. a ^ i) = (a ^ k - 1) div (a - 1)\""], ["proof (prove)\nusing this:\n  1 < a\n  0 < k\n\ngoal (1 subgoal):\n 1. sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)", "by (subst * [symmetric]) simp"], ["proof (state)\nthis:\n  sum ((^) a) {..<k} = (a ^ k - 1) div (a - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_div_gt0: \"d dvd n \\<Longrightarrow> n > 0 \\<Longrightarrow> n div d > (0::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d dvd n; 0 < n\\<rbrakk> \\<Longrightarrow> 0 < n div d", "by (auto elim: dvdE)"], ["", "lemma Set_filter_insert: \n  \"Set.filter P (insert x A) = (if P x then insert x (Set.filter P A) else Set.filter P A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter P (insert x A) =\n    (if P x then insert x (Set.filter P A) else Set.filter P A)", "by (auto simp: Set.filter_def)"], ["", "lemma Set_filter_union: \"Set.filter P (A \\<union> B) = Set.filter P A \\<union> Set.filter P B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter P (A \\<union> B) = Set.filter P A \\<union> Set.filter P B", "by (auto simp: Set.filter_def)"], ["", "lemma Set_filter_empty [simp]: \"Set.filter P {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter P {} = {}", "by (auto simp: Set.filter_def)"], ["", "lemma Set_filter_image: \"Set.filter P (f ` A) = f ` Set.filter (P \\<circ> f) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter P (f ` A) = f ` Set.filter (P \\<circ> f) A", "by (auto simp: Set.filter_def)"], ["", "lemma Set_filter_cong [cong]:\n    \"(\\<And>x. x \\<in> A \\<Longrightarrow> P x \\<longleftrightarrow> Q x) \\<Longrightarrow> A = B \\<Longrightarrow>  Set.filter P A = Set.filter Q B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> P x = Q x; A = B\\<rbrakk>\n    \\<Longrightarrow> Set.filter P A = Set.filter Q B", "by (auto simp: Set.filter_def)"], ["", "lemma finite_Set_filter: \"finite A \\<Longrightarrow> finite (Set.filter P A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> finite (Set.filter P A)", "by (auto simp: Set.filter_def)"], ["", "lemma inj_on_insert': \"(\\<And>B. B \\<in> A \\<Longrightarrow> x \\<notin> B) \\<Longrightarrow> inj_on (insert x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. B \\<in> A \\<Longrightarrow> x \\<notin> B) \\<Longrightarrow>\n    inj_on (insert x) A", "by (auto simp: inj_on_def insert_eq_iff)"], ["", "lemma\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows   card_even_subset_aux: \"card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)\"\n    and   card_odd_subset_aux:  \"card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\"\n    and   card_even_odd_subset: \"card {B. B \\<subseteq> A \\<and> even (card B)} = card {B. B \\<subseteq> A \\<and> odd (card B)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1) &&&\n    card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1) &&&\n    card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 3. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "from assms"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have *: \"2 * card (Set.filter (even \\<circ> card) (Pow A)) = 2 ^ card A\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 2 * card (Set.filter (even \\<circ> card) (Pow A)) = 2 ^ card A", "proof (induction A rule: finite_ne_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       2 * card (Set.filter (even \\<circ> card) (Pow {x})) = 2 ^ card {x}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "case (singleton x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       2 * card (Set.filter (even \\<circ> card) (Pow {x})) = 2 ^ card {x}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "hence \"Pow {x} = {{}, {x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow {x} = {{}, {x}}", "by auto"], ["proof (state)\nthis:\n  Pow {x} = {{}, {x}}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       2 * card (Set.filter (even \\<circ> card) (Pow {x})) = 2 ^ card {x}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "thus ?case"], ["proof (prove)\nusing this:\n  Pow {x} = {{}, {x}}\n\ngoal (1 subgoal):\n 1. 2 * card (Set.filter (even \\<circ> card) (Pow {x})) = 2 ^ card {x}", "by (simp add: Set_filter_insert)"], ["proof (state)\nthis:\n  2 * card (Set.filter (even \\<circ> card) (Pow {x})) = 2 ^ card {x}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  A \\<noteq> {}\n  x \\<notin> A\n  2 * card (Set.filter (even \\<circ> card) (Pow A)) = 2 ^ card A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "note fin = finite_subset[OF _ \\<open>finite A\\<close>]"], ["proof (state)\nthis:\n  ?A \\<subseteq> A \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"Pow (insert x A) = Pow A \\<union> insert x ` Pow A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow (insert x A) = Pow A \\<union> insert x ` Pow A", "by (rule Pow_insert)"], ["proof (state)\nthis:\n  Pow (insert x A) = Pow A \\<union> insert x ` Pow A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"Set.filter (even \\<circ> card) (Pow (insert x A)) = \n            Set.filter (even \\<circ> card) (Pow A) \\<union> \n            insert x ` Set.filter (even \\<circ> card \\<circ> insert x) (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter (even \\<circ> card) (Pow (insert x A)) =\n    Set.filter (even \\<circ> card) (Pow A) \\<union>\n    insert x ` Set.filter (even \\<circ> card \\<circ> insert x) (Pow A)", "unfolding Pow_insert Set_filter_union Set_filter_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter (even \\<circ> card) (Pow A) \\<union>\n    insert x ` Set.filter (even \\<circ> card \\<circ> insert x) (Pow A) =\n    Set.filter (even \\<circ> card) (Pow A) \\<union>\n    insert x ` Set.filter (even \\<circ> card \\<circ> insert x) (Pow A)", "by blast"], ["proof (state)\nthis:\n  Set.filter (even \\<circ> card) (Pow (insert x A)) =\n  Set.filter (even \\<circ> card) (Pow A) \\<union>\n  insert x ` Set.filter (even \\<circ> card \\<circ> insert x) (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "also"], ["proof (state)\nthis:\n  Set.filter (even \\<circ> card) (Pow (insert x A)) =\n  Set.filter (even \\<circ> card) (Pow A) \\<union>\n  insert x ` Set.filter (even \\<circ> card \\<circ> insert x) (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"Set.filter (even \\<circ> card \\<circ> insert x) (Pow A) = Set.filter (odd \\<circ> card) (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter (even \\<circ> card \\<circ> insert x) (Pow A) =\n    Set.filter (odd \\<circ> card) (Pow A)", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter (\\<lambda>xa. even (card (insert x xa))) (Pow A) =\n    Set.filter (\\<lambda>x. odd (card x)) (Pow A)", "by (intro Set_filter_cong refl, subst card_insert_disjoint) \n         (insert insert.hyps, auto dest: finite_subset)"], ["proof (state)\nthis:\n  Set.filter (even \\<circ> card \\<circ> insert x) (Pow A) =\n  Set.filter (odd \\<circ> card) (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "also"], ["proof (state)\nthis:\n  Set.filter (even \\<circ> card \\<circ> insert x) (Pow A) =\n  Set.filter (odd \\<circ> card) (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"card (Set.filter (even \\<circ> card) (Pow A) \\<union> insert x ` \\<dots>) = \n                 card (Set.filter (even \\<circ> card) (Pow A)) + card (insert x ` \\<dots>)\"\n      (is \"card (?A \\<union> ?B) = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (Set.filter (even \\<circ> card) (Pow A) \\<union>\n      insert x ` Set.filter (odd \\<circ> card) (Pow A)) =\n    card (Set.filter (even \\<circ> card) (Pow A)) +\n    card (insert x ` Set.filter (odd \\<circ> card) (Pow A))", "by (intro card_Un_disjoint finite_Set_filter finite_imageI) (auto simp:  insert.hyps)"], ["proof (state)\nthis:\n  card\n   (Set.filter (even \\<circ> card) (Pow A) \\<union>\n    insert x ` Set.filter (odd \\<circ> card) (Pow A)) =\n  card (Set.filter (even \\<circ> card) (Pow A)) +\n  card (insert x ` Set.filter (odd \\<circ> card) (Pow A))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "also"], ["proof (state)\nthis:\n  card\n   (Set.filter (even \\<circ> card) (Pow A) \\<union>\n    insert x ` Set.filter (odd \\<circ> card) (Pow A)) =\n  card (Set.filter (even \\<circ> card) (Pow A)) +\n  card (insert x ` Set.filter (odd \\<circ> card) (Pow A))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"card ?B = card (Set.filter (odd \\<circ> card) (Pow A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x ` Set.filter (odd \\<circ> card) (Pow A)) =\n    card (Set.filter (odd \\<circ> card) (Pow A))", "using insert.hyps"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. card (insert x ` Set.filter (odd \\<circ> card) (Pow A)) =\n    card (Set.filter (odd \\<circ> card) (Pow A))", "by (intro card_image inj_on_insert') auto"], ["proof (state)\nthis:\n  card (insert x ` Set.filter (odd \\<circ> card) (Pow A)) =\n  card (Set.filter (odd \\<circ> card) (Pow A))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "also"], ["proof (state)\nthis:\n  card (insert x ` Set.filter (odd \\<circ> card) (Pow A)) =\n  card (Set.filter (odd \\<circ> card) (Pow A))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"Set.filter (odd \\<circ> card) (Pow A) = Pow A - Set.filter (even \\<circ> card) (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter (odd \\<circ> card) (Pow A) =\n    Pow A - Set.filter (even \\<circ> card) (Pow A)", "by auto"], ["proof (state)\nthis:\n  Set.filter (odd \\<circ> card) (Pow A) =\n  Pow A - Set.filter (even \\<circ> card) (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "also"], ["proof (state)\nthis:\n  Set.filter (odd \\<circ> card) (Pow A) =\n  Pow A - Set.filter (even \\<circ> card) (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"card \\<dots> = card (Pow A) - card (Set.filter (even \\<circ> card) (Pow A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Pow A - Set.filter (even \\<circ> card) (Pow A)) =\n    card (Pow A) - card (Set.filter (even \\<circ> card) (Pow A))", "using insert.hyps"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. card (Pow A - Set.filter (even \\<circ> card) (Pow A)) =\n    card (Pow A) - card (Set.filter (even \\<circ> card) (Pow A))", "by (subst card_Diff_subset) (auto simp: finite_Set_filter)"], ["proof (state)\nthis:\n  card (Pow A - Set.filter (even \\<circ> card) (Pow A)) =\n  card (Pow A) - card (Set.filter (even \\<circ> card) (Pow A))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "also"], ["proof (state)\nthis:\n  card (Pow A - Set.filter (even \\<circ> card) (Pow A)) =\n  card (Pow A) - card (Set.filter (even \\<circ> card) (Pow A))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"card (Set.filter (even \\<circ> card) (Pow A)) + \\<dots> = card (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Set.filter (even \\<circ> card) (Pow A)) +\n    (card (Pow A) - card (Set.filter (even \\<circ> card) (Pow A))) =\n    card (Pow A)", "by (intro add_diff_inverse_nat, subst not_less, rule card_mono) (insert insert.hyps, auto)"], ["proof (state)\nthis:\n  card (Set.filter (even \\<circ> card) (Pow A)) +\n  (card (Pow A) - card (Set.filter (even \\<circ> card) (Pow A))) =\n  card (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "also"], ["proof (state)\nthis:\n  card (Set.filter (even \\<circ> card) (Pow A)) +\n  (card (Pow A) - card (Set.filter (even \\<circ> card) (Pow A))) =\n  card (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "have \"2 * \\<dots> = 2 ^ card (insert x A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * card (Pow A) = 2 ^ card (insert x A)", "using insert.hyps"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. 2 * card (Pow A) = 2 ^ card (insert x A)", "by (simp add: card_Pow)"], ["proof (state)\nthis:\n  2 * card (Pow A) = 2 ^ card (insert x A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        2 * card (Set.filter (even \\<circ> card) (Pow F)) =\n        2 ^ card F\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         card\n                          (Set.filter (even \\<circ> card)\n                            (Pow (insert x F))) =\n                         2 ^ card (insert x F)", "finally"], ["proof (chain)\npicking this:\n  2 * card (Set.filter (even \\<circ> card) (Pow (insert x A))) =\n  2 ^ card (insert x A)", "show ?case"], ["proof (prove)\nusing this:\n  2 * card (Set.filter (even \\<circ> card) (Pow (insert x A))) =\n  2 ^ card (insert x A)\n\ngoal (1 subgoal):\n 1. 2 * card (Set.filter (even \\<circ> card) (Pow (insert x A))) =\n    2 ^ card (insert x A)", "."], ["proof (state)\nthis:\n  2 * card (Set.filter (even \\<circ> card) (Pow (insert x A))) =\n  2 ^ card (insert x A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * card (Set.filter (even \\<circ> card) (Pow A)) = 2 ^ card A\n\ngoal (3 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 3. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "from *"], ["proof (chain)\npicking this:\n  2 * card (Set.filter (even \\<circ> card) (Pow A)) = 2 ^ card A", "show A: \"card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)\""], ["proof (prove)\nusing this:\n  2 * card (Set.filter (even \\<circ> card) (Pow A)) = 2 ^ card A\n\ngoal (1 subgoal):\n 1. card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)", "by (cases \"card A\") (simp_all add: Set.filter_def)"], ["proof (state)\nthis:\n  card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)\n\ngoal (2 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "have \"Set.filter (odd \\<circ> card) (Pow A) = Pow A - Set.filter (even \\<circ> card) (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter (odd \\<circ> card) (Pow A) =\n    Pow A - Set.filter (even \\<circ> card) (Pow A)", "by auto"], ["proof (state)\nthis:\n  Set.filter (odd \\<circ> card) (Pow A) =\n  Pow A - Set.filter (even \\<circ> card) (Pow A)\n\ngoal (2 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "also"], ["proof (state)\nthis:\n  Set.filter (odd \\<circ> card) (Pow A) =\n  Pow A - Set.filter (even \\<circ> card) (Pow A)\n\ngoal (2 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "have \"2 * card \\<dots> = 2 * 2 ^ card A - 2 * card (Set.filter (even \\<circ> card) (Pow A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * card (Pow A - Set.filter (even \\<circ> card) (Pow A)) =\n    2 * 2 ^ card A - 2 * card (Set.filter (even \\<circ> card) (Pow A))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 2 * card (Pow A - Set.filter (even \\<circ> card) (Pow A)) =\n    2 * 2 ^ card A - 2 * card (Set.filter (even \\<circ> card) (Pow A))", "by (subst card_Diff_subset) (auto intro!: finite_Set_filter simp: card_Pow)"], ["proof (state)\nthis:\n  2 * card (Pow A - Set.filter (even \\<circ> card) (Pow A)) =\n  2 * 2 ^ card A - 2 * card (Set.filter (even \\<circ> card) (Pow A))\n\ngoal (2 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "also"], ["proof (state)\nthis:\n  2 * card (Pow A - Set.filter (even \\<circ> card) (Pow A)) =\n  2 * 2 ^ card A - 2 * card (Set.filter (even \\<circ> card) (Pow A))\n\ngoal (2 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "note *"], ["proof (state)\nthis:\n  2 * card (Set.filter (even \\<circ> card) (Pow A)) = 2 ^ card A\n\ngoal (2 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "also"], ["proof (state)\nthis:\n  2 * card (Set.filter (even \\<circ> card) (Pow A)) = 2 ^ card A\n\ngoal (2 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "have \"2 * 2 ^ card A - 2 ^ card A = (2 ^ card A :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * 2 ^ card A - 2 ^ card A = 2 ^ card A", "by simp"], ["proof (state)\nthis:\n  2 * 2 ^ card A - 2 ^ card A = 2 ^ card A\n\ngoal (2 subgoals):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n 2. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "finally"], ["proof (chain)\npicking this:\n  2 * card (Set.filter (odd \\<circ> card) (Pow A)) = 2 ^ card A", "show B: \"card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\""], ["proof (prove)\nusing this:\n  2 * card (Set.filter (odd \\<circ> card) (Pow A)) = 2 ^ card A\n\ngoal (1 subgoal):\n 1. card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)", "by (cases \"card A\") (simp_all add: Set.filter_def)"], ["proof (state)\nthis:\n  card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n\ngoal (1 subgoal):\n 1. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "from A and B"], ["proof (chain)\npicking this:\n  card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)\n  card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)", "show \"card {B. B \\<subseteq> A \\<and> even (card B)} = card {B. B \\<subseteq> A \\<and> odd (card B)}\""], ["proof (prove)\nusing this:\n  card {B. B \\<subseteq> A \\<and> even (card B)} = 2 ^ (card A - 1)\n  card {B. B \\<subseteq> A \\<and> odd (card B)} = 2 ^ (card A - 1)\n\ngoal (1 subgoal):\n 1. card {B. B \\<subseteq> A \\<and> even (card B)} =\n    card {B. B \\<subseteq> A \\<and> odd (card B)}", "by simp"], ["proof (state)\nthis:\n  card {B. B \\<subseteq> A \\<and> even (card B)} =\n  card {B. B \\<subseteq> A \\<and> odd (card B)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_prod_divisors_coprime:\n  assumes \"coprime a (b :: nat)\"\n  shows   \"bij_betw (\\<lambda>x. fst x * snd x) ({d. d dvd a} \\<times> {d. d dvd b}) {k. k dvd a * b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. fst x * snd x)\n     ({d. d dvd a} \\<times> {d. d dvd b}) {k. k dvd a * b}", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. fst x * snd x)\n     ({d. d dvd a} \\<times> {d. d dvd b}) \\<and>\n    (\\<lambda>x. fst x * snd x) ` ({d. d dvd a} \\<times> {d. d dvd b}) =\n    {k. k dvd a * b}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. fst x * snd x) ({d. d dvd a} \\<times> {d. d dvd b})\n 2. (\\<lambda>x. fst x * snd x) ` ({d. d dvd a} \\<times> {d. d dvd b}) =\n    {k. k dvd a * b}", "from assms"], ["proof (chain)\npicking this:\n  coprime a b", "show \"inj_on (\\<lambda>x. fst x * snd x) ({d. d dvd a} \\<times> {d. d dvd b})\""], ["proof (prove)\nusing this:\n  coprime a b\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. fst x * snd x) ({d. d dvd a} \\<times> {d. d dvd b})", "by (auto simp: inj_on_def coprime_crossproduct_nat coprime_divisors)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. fst x * snd x) ({d. d dvd a} \\<times> {d. d dvd b})\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. fst x * snd x) ` ({d. d dvd a} \\<times> {d. d dvd b}) =\n    {k. k dvd a * b}", "show \"(\\<lambda>x. fst x * snd x) ` ({d. d dvd a} \\<times> {d. d dvd b}) = {k. k dvd a * b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. fst x * snd x) ` ({d. d dvd a} \\<times> {d. d dvd b}) =\n    {k. k dvd a * b}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x aa ba.\n       \\<lbrakk>aa dvd a; ba dvd b\\<rbrakk>\n       \\<Longrightarrow> fst (aa, ba) * snd (aa, ba) dvd a * b\n 2. \\<And>x.\n       x dvd a * b \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. fst x * snd x) `\n               ({d. d dvd a} \\<times> {d. d dvd b})", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x aa ba.\n       \\<lbrakk>aa dvd a; ba dvd b\\<rbrakk>\n       \\<Longrightarrow> fst (aa, ba) * snd (aa, ba) dvd a * b\n 2. \\<And>x.\n       x dvd a * b \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. fst x * snd x) `\n               ({d. d dvd a} \\<times> {d. d dvd b})", "assume \"x dvd a * b\""], ["proof (state)\nthis:\n  x dvd a * b\n\ngoal (2 subgoals):\n 1. \\<And>x aa ba.\n       \\<lbrakk>aa dvd a; ba dvd b\\<rbrakk>\n       \\<Longrightarrow> fst (aa, ba) * snd (aa, ba) dvd a * b\n 2. \\<And>x.\n       x dvd a * b \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. fst x * snd x) `\n               ({d. d dvd a} \\<times> {d. d dvd b})", "from division_decomp[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>b' c'. x = b' * c' \\<and> b' dvd a \\<and> c' dvd b", "guess b' c'"], ["proof (prove)\nusing this:\n  \\<exists>b' c'. x = b' * c' \\<and> b' dvd a \\<and> c' dvd b\n\ngoal (1 subgoal):\n 1. thesis", "by (elim exE conjE)"], ["proof (state)\nthis:\n  x = b' * c'\n  b' dvd a\n  c' dvd b\n\ngoal (2 subgoals):\n 1. \\<And>x aa ba.\n       \\<lbrakk>aa dvd a; ba dvd b\\<rbrakk>\n       \\<Longrightarrow> fst (aa, ba) * snd (aa, ba) dvd a * b\n 2. \\<And>x.\n       x dvd a * b \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. fst x * snd x) `\n               ({d. d dvd a} \\<times> {d. d dvd b})", "thus \"x \\<in> (\\<lambda>x. fst x * snd x) ` ({d. d dvd a} \\<times> {d. d dvd b})\""], ["proof (prove)\nusing this:\n  x = b' * c'\n  b' dvd a\n  c' dvd b\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. fst x * snd x) `\n            ({d. d dvd a} \\<times> {d. d dvd b})", "by force"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>x. fst x * snd x) ` ({d. d dvd a} \\<times> {d. d dvd b})\n\ngoal (1 subgoal):\n 1. \\<And>x aa ba.\n       \\<lbrakk>aa dvd a; ba dvd b\\<rbrakk>\n       \\<Longrightarrow> fst (aa, ba) * snd (aa, ba) dvd a * b", "qed (insert assms, auto intro: mult_dvd_mono)"], ["proof (state)\nthis:\n  (\\<lambda>x. fst x * snd x) ` ({d. d dvd a} \\<times> {d. d dvd b}) =\n  {k. k dvd a * b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_prime_power_divisors:\n  assumes \"prime (p :: nat)\"\n  shows   \"bij_betw ((^) p) {..k} {d. d dvd p ^ k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((^) p) {..k} {d. d dvd p ^ k}", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((^) p) {..k} \\<and> (^) p ` {..k} = {d. d dvd p ^ k}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on ((^) p) {..k}\n 2. (^) p ` {..k} = {d. d dvd p ^ k}", "from assms"], ["proof (chain)\npicking this:\n  prime p", "have *: \"p > 1\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 1 < p", "by (simp add: prime_gt_Suc_0_nat)"], ["proof (state)\nthis:\n  1 < p\n\ngoal (2 subgoals):\n 1. inj_on ((^) p) {..k}\n 2. (^) p ` {..k} = {d. d dvd p ^ k}", "show \"inj_on ((^) p) {..k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((^) p) {..k}", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. inj_on ((^) p) {..k}", "by (auto simp: inj_on_def prime_gt_Suc_0_nat power_inject_exp[OF *])"], ["proof (state)\nthis:\n  inj_on ((^) p) {..k}\n\ngoal (1 subgoal):\n 1. (^) p ` {..k} = {d. d dvd p ^ k}", "show \"(^) p ` {..k} = {d. d dvd p ^ k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (^) p ` {..k} = {d. d dvd p ^ k}", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. (^) p ` {..k} = {d. d dvd p ^ k}", "by (auto simp: le_imp_power_dvd divides_primepow_nat)"], ["proof (state)\nthis:\n  (^) p ` {..k} = {d. d dvd p ^ k}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_diff':\n  assumes \"m \\<ge> n\" \"x \\<noteq> 0\"\n  shows   \"x ^ (m - n) = (x ^ m div x ^ n :: 'a :: unique_euclidean_semiring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ (m - n) = x ^ m div x ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ (m - n) = x ^ m div x ^ n", "from assms"], ["proof (chain)\npicking this:\n  n \\<le> m\n  x \\<noteq> (0::'a)", "have \"x ^ m = x ^ (m - n) * x ^ n\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x ^ m = x ^ (m - n) * x ^ n", "by (subst power_add [symmetric]) simp"], ["proof (state)\nthis:\n  x ^ m = x ^ (m - n) * x ^ n\n\ngoal (1 subgoal):\n 1. x ^ (m - n) = x ^ m div x ^ n", "also"], ["proof (state)\nthis:\n  x ^ m = x ^ (m - n) * x ^ n\n\ngoal (1 subgoal):\n 1. x ^ (m - n) = x ^ m div x ^ n", "from assms"], ["proof (chain)\npicking this:\n  n \\<le> m\n  x \\<noteq> (0::'a)", "have \"\\<dots> div x ^ n = x ^ (m - n)\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x ^ (m - n) * x ^ n div x ^ n = x ^ (m - n)", "by simp"], ["proof (state)\nthis:\n  x ^ (m - n) * x ^ n div x ^ n = x ^ (m - n)\n\ngoal (1 subgoal):\n 1. x ^ (m - n) = x ^ m div x ^ n", "finally"], ["proof (chain)\npicking this:\n  x ^ m div x ^ n = x ^ (m - n)", "show ?thesis"], ["proof (prove)\nusing this:\n  x ^ m div x ^ n = x ^ (m - n)\n\ngoal (1 subgoal):\n 1. x ^ (m - n) = x ^ m div x ^ n", ".."], ["proof (state)\nthis:\n  x ^ (m - n) = x ^ m div x ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_divisors_coprime_mult:\n  assumes \"coprime a (b :: nat)\"\n  shows   \"(\\<Sum>d | d dvd a * b. f d) = (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd a * b. f d) =\n    (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd a * b. f d) =\n    (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))", "have \"(\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s)) =\n          (\\<Sum>z\\<in>{r. r dvd a} \\<times> {s. s dvd b}. f (fst z * snd z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s)) =\n    (\\<Sum>z\\<in>{r. r dvd a} \\<times> {s. s dvd b}. f (fst z * snd z))", "by (subst sum.cartesian_product) (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s)) =\n  (\\<Sum>z\\<in>{r. r dvd a} \\<times> {s. s dvd b}. f (fst z * snd z))\n\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd a * b. f d) =\n    (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))", "also"], ["proof (state)\nthis:\n  (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s)) =\n  (\\<Sum>z\\<in>{r. r dvd a} \\<times> {s. s dvd b}. f (fst z * snd z))\n\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd a * b. f d) =\n    (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))", "have \"\\<dots> = (\\<Sum>d | d dvd a * b. f d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>{r. r dvd a} \\<times> {s. s dvd b}. f (fst z * snd z)) =\n    (\\<Sum>d | d dvd a * b. f d)", "by (intro sum.reindex_bij_betw bij_betw_prod_divisors_coprime assms)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>{r. r dvd a} \\<times> {s. s dvd b}. f (fst z * snd z)) =\n  (\\<Sum>d | d dvd a * b. f d)\n\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd a * b. f d) =\n    (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s)) =\n  (\\<Sum>d | d dvd a * b. f d)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s)) =\n  (\\<Sum>d | d dvd a * b. f d)\n\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd a * b. f d) =\n    (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))", ".."], ["proof (state)\nthis:\n  (\\<Sum>d | d dvd a * b. f d) =\n  (\\<Sum>r | r dvd a. \\<Sum>s | s dvd b. f (r * s))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}