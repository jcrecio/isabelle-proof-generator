{"file_name": "/home/qj213/afp-2021-10-22/thys/Dirichlet_Series/More_Totient.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dirichlet_Series", "problem_names": ["lemma fds_totient_times_zeta: \n  \"fds (\\<lambda>n. of_nat (totient n) :: 'a :: comm_semiring_1) * fds_zeta = fds of_nat\"", "lemma fds_totient_times_zeta': \"fds totient * fds_zeta = fds id\"", "lemma fds_totient: \"fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu\"", "lemma totient_conv_moebius_mu:\n  \"int (totient n) = dirichlet_prod moebius_mu int n\"", "lemma even_prime_nat: \"prime p \\<Longrightarrow> even p \\<Longrightarrow> p = (2::nat)\"", "lemma twopow_dvd_totient:\n  fixes n :: nat\n  assumes \"n > 0\"\n  defines \"k \\<equiv> card {p\\<in>prime_factors n. odd p}\"\n  shows   \"2 ^ k dvd totient n\"", "lemma totient_conv_moebius_mu':\n  assumes \"n > (0::nat)\"\n  shows   \"real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)\"", "lemma totient_prime_power_Suc:\n  assumes \"prime p\"\n  shows   \"totient (p ^ Suc n) = p ^ Suc n - p ^ n\""], "translations": [["", "lemma fds_totient_times_zeta: \n  \"fds (\\<lambda>n. of_nat (totient n) :: 'a :: comm_semiring_1) * fds_zeta = fds of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) * fds_zeta = fds of_nat", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n       fds_nth (fds of_nat) n", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n       fds_nth (fds of_nat) n", "assume n: \"n > 0\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n       fds_nth (fds of_nat) n", "have \"fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n = \n          dirichlet_prod (\\<lambda>n. of_nat (totient n)) (\\<lambda>_. 1) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n    dirichlet_prod (\\<lambda>n. of_nat (totient n)) (\\<lambda>_. 1::'b) n", "by (simp add: fds_nth_mult)"], ["proof (state)\nthis:\n  fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n  dirichlet_prod (\\<lambda>n. of_nat (totient n)) (\\<lambda>_. 1::?'b1) n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n       fds_nth (fds of_nat) n", "also"], ["proof (state)\nthis:\n  fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n  dirichlet_prod (\\<lambda>n. of_nat (totient n)) (\\<lambda>_. 1::?'b1) n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n       fds_nth (fds of_nat) n", "from n"], ["proof (chain)\npicking this:\n  0 < n", "have \"\\<dots> = fds_nth (fds of_nat) n\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. dirichlet_prod (\\<lambda>n. of_nat (totient n)) (\\<lambda>_. 1::'b) n =\n    fds_nth (fds of_nat) n", "by (simp add: fds_nth_fds dirichlet_prod_def totient_divisor_sum of_nat_sum [symmetric]\n             del: of_nat_sum)"], ["proof (state)\nthis:\n  dirichlet_prod (\\<lambda>n. of_nat (totient n)) (\\<lambda>_. 1::?'b2) n =\n  fds_nth (fds of_nat) n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n       fds_nth (fds of_nat) n", "finally"], ["proof (chain)\npicking this:\n  fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n  fds_nth (fds of_nat) n", "show \"fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n = fds_nth (fds of_nat) n\""], ["proof (prove)\nusing this:\n  fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n  fds_nth (fds of_nat) n\n\ngoal (1 subgoal):\n 1. fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n    fds_nth (fds of_nat) n", "."], ["proof (state)\nthis:\n  fds_nth (fds (\\<lambda>n. of_nat (totient n)) * fds_zeta) n =\n  fds_nth (fds of_nat) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fds_totient_times_zeta': \"fds totient * fds_zeta = fds id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds totient * fds_zeta = fds id", "using fds_totient_times_zeta[where 'a = nat]"], ["proof (prove)\nusing this:\n  fds (\\<lambda>n. of_nat (totient n)) * fds_zeta = fds of_nat\n\ngoal (1 subgoal):\n 1. fds totient * fds_zeta = fds id", "by simp"], ["", "lemma fds_totient: \"fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu", "have \"fds (\\<lambda>n. of_nat (totient n)) * fds_zeta * fds moebius_mu = fds of_nat * fds moebius_mu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) * fds_zeta * fds moebius_mu =\n    fds of_nat * fds moebius_mu", "by (simp add: fds_totient_times_zeta)"], ["proof (state)\nthis:\n  fds (\\<lambda>n. of_nat (totient n)) * fds_zeta * fds moebius_mu =\n  fds of_nat * fds moebius_mu\n\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu", "also"], ["proof (state)\nthis:\n  fds (\\<lambda>n. of_nat (totient n)) * fds_zeta * fds moebius_mu =\n  fds of_nat * fds moebius_mu\n\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu", "have \"fds (\\<lambda>n. of_nat (totient n)) * fds_zeta * fds moebius_mu = \n               fds (\\<lambda>n. of_nat (totient n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) * fds_zeta * fds moebius_mu =\n    fds (\\<lambda>n. of_nat (totient n))", "by (simp only: mult.assoc fds_zeta_times_moebius_mu mult_1_right)"], ["proof (state)\nthis:\n  fds (\\<lambda>n. of_nat (totient n)) * fds_zeta * fds moebius_mu =\n  fds (\\<lambda>n. of_nat (totient n))\n\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu", "finally"], ["proof (chain)\npicking this:\n  fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu", "show ?thesis"], ["proof (prove)\nusing this:\n  fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu\n\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu", "."], ["proof (state)\nthis:\n  fds (\\<lambda>n. of_nat (totient n)) = fds of_nat * fds moebius_mu\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totient_conv_moebius_mu:\n  \"int (totient n) = dirichlet_prod moebius_mu int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (totient n) = dirichlet_prod moebius_mu int n", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    int (totient n) = dirichlet_prod moebius_mu int n\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    int (totient n) = dirichlet_prod moebius_mu int n", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    int (totient n) = dirichlet_prod moebius_mu int n\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    int (totient n) = dirichlet_prod moebius_mu int n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (totient n) = dirichlet_prod moebius_mu int n", "by (rule moebius_inversion)\n       (insert False, simp_all add: of_nat_sum [symmetric] totient_divisor_sum del: of_nat_sum)"], ["proof (state)\nthis:\n  int (totient n) = dirichlet_prod moebius_mu int n\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    int (totient n) = dirichlet_prod moebius_mu int n", "qed simp_all"], ["", "interpretation totient: multiplicative_function totient"], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function totient", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multiplicative_function totient", "have \"multiplicative_function int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function int", "by standard simp_all"], ["proof (state)\nthis:\n  multiplicative_function int\n\ngoal (1 subgoal):\n 1. multiplicative_function totient", "hence \"multiplicative_function (dirichlet_prod moebius_mu int)\""], ["proof (prove)\nusing this:\n  multiplicative_function int\n\ngoal (1 subgoal):\n 1. multiplicative_function (dirichlet_prod moebius_mu int)", "by (intro multiplicative_dirichlet_prod moebius_mu.multiplicative_function_axioms)"], ["proof (state)\nthis:\n  multiplicative_function (dirichlet_prod moebius_mu int)\n\ngoal (1 subgoal):\n 1. multiplicative_function totient", "also"], ["proof (state)\nthis:\n  multiplicative_function (dirichlet_prod moebius_mu int)\n\ngoal (1 subgoal):\n 1. multiplicative_function totient", "have \"dirichlet_prod moebius_mu int = (\\<lambda>n. int (totient n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dirichlet_prod moebius_mu int = (\\<lambda>n. int (totient n))", "by (simp add: fun_eq_iff totient_conv_moebius_mu)"], ["proof (state)\nthis:\n  dirichlet_prod moebius_mu int = (\\<lambda>n. int (totient n))\n\ngoal (1 subgoal):\n 1. multiplicative_function totient", "finally"], ["proof (chain)\npicking this:\n  multiplicative_function (\\<lambda>a. int (totient a))", "show \"multiplicative_function totient\""], ["proof (prove)\nusing this:\n  multiplicative_function (\\<lambda>a. int (totient a))\n\ngoal (1 subgoal):\n 1. multiplicative_function totient", "by (rule multiplicative_function_of_natD)"], ["proof (state)\nthis:\n  multiplicative_function totient\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma even_prime_nat: \"prime p \\<Longrightarrow> even p \\<Longrightarrow> p = (2::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; even p\\<rbrakk> \\<Longrightarrow> p = 2", "using prime_odd_nat[of p] prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; 2 < p\\<rbrakk> \\<Longrightarrow> odd p\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; even p\\<rbrakk> \\<Longrightarrow> p = 2", "by (cases \"p = 2\") auto"], ["", "lemma twopow_dvd_totient:\n  fixes n :: nat\n  assumes \"n > 0\"\n  defines \"k \\<equiv> card {p\\<in>prime_factors n. odd p}\"\n  shows   \"2 ^ k dvd totient n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "define P where \"P = {p\\<in>prime_factors n. odd p}\""], ["proof (state)\nthis:\n  P = {p. p \\<in># prime_factorization n \\<and> odd p}\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "define P' where \"P' = {p\\<in>prime_factors n. even p}\""], ["proof (state)\nthis:\n  P' = {p. p \\<in># prime_factorization n \\<and> even p}\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "define r where \"r = (\\<lambda>p. multiplicity p n)\""], ["proof (state)\nthis:\n  r = (\\<lambda>p. multiplicity p n)\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "from \\<open>n > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < n", "have \"totient n = (\\<Prod>p\\<in>prime_factors n. totient (p ^ r p))\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. totient n = (\\<Prod>p\\<in>prime_factors n. totient (p ^ r p))", "unfolding r_def"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. totient n =\n    (\\<Prod>p\\<in>prime_factors n. totient (p ^ multiplicity p n))", "by (rule totient.prod_prime_factors)"], ["proof (state)\nthis:\n  totient n = (\\<Prod>p\\<in>prime_factors n. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "also"], ["proof (state)\nthis:\n  totient n = (\\<Prod>p\\<in>prime_factors n. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "have \"prime_factors n = P \\<union> P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors n = P \\<union> P'", "by (auto simp: P_def P'_def)"], ["proof (state)\nthis:\n  prime_factors n = P \\<union> P'\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "also"], ["proof (state)\nthis:\n  prime_factors n = P \\<union> P'\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "have \"(\\<Prod>p\\<in>\\<dots>. totient (p ^ r p)) =\n               (\\<Prod>p\\<in>P. totient (p ^ r p)) * (\\<Prod>p\\<in>P'. totient (p ^ r p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>P \\<union> P'. totient (p ^ r p)) =\n    (\\<Prod>p\\<in>P. totient (p ^ r p)) *\n    (\\<Prod>p\\<in>P'. totient (p ^ r p))", "by (subst prod.union_disjoint) (auto simp: P_def P'_def)"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>P \\<union> P'. totient (p ^ r p)) =\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) * (\\<Prod>p\\<in>P'. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "finally"], ["proof (chain)\npicking this:\n  totient n =\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) * (\\<Prod>p\\<in>P'. totient (p ^ r p))", "have eq: \"totient n = \\<dots>\""], ["proof (prove)\nusing this:\n  totient n =\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) * (\\<Prod>p\\<in>P'. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. totient n =\n    (\\<Prod>p\\<in>P. totient (p ^ r p)) *\n    (\\<Prod>p\\<in>P'. totient (p ^ r p))", "."], ["proof (state)\nthis:\n  totient n =\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) * (\\<Prod>p\\<in>P'. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "have \"p ^ r p > 2\" if \"p \\<in> P\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "have \"p \\<noteq> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 2", "using that"], ["proof (prove)\nusing this:\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. p \\<noteq> 2", "by (auto simp: P_def)"], ["proof (state)\nthis:\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "have \"p > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < p", "using prime_gt_1_nat[of p] that"], ["proof (prove)\nusing this:\n  prime p \\<Longrightarrow> 1 < p\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. 1 < p", "by (auto simp: P_def)"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> 2\n  1 < p", "have \"2 < p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 2\n  1 < p\n\ngoal (1 subgoal):\n 1. 2 < p", "by linarith"], ["proof (state)\nthis:\n  2 < p\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "also"], ["proof (state)\nthis:\n  2 < p\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "have \"p = p ^ 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p ^ 1", "by simp"], ["proof (state)\nthis:\n  p = p ^ 1\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "also"], ["proof (state)\nthis:\n  p = p ^ 1\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "have \"p ^ 1 \\<le> p ^ r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ 1 \\<le> p ^ r p", "using that prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  p \\<in> P\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. p ^ 1 \\<le> p ^ r p", "by (intro power_increasing) (auto simp: P_def prime_factors_multiplicity r_def)"], ["proof (state)\nthis:\n  p ^ 1 \\<le> p ^ r p\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "finally"], ["proof (chain)\npicking this:\n  2 < p ^ r p", "show ?thesis"], ["proof (prove)\nusing this:\n  2 < p ^ r p\n\ngoal (1 subgoal):\n 1. 2 < p ^ r p", "."], ["proof (state)\nthis:\n  2 < p ^ r p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p \\<in> P \\<Longrightarrow> 2 < ?p ^ r ?p\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "hence \"(\\<Prod>p\\<in>P. 2) dvd (\\<Prod>p\\<in>P. totient (p ^ r p))\""], ["proof (prove)\nusing this:\n  ?p \\<in> P \\<Longrightarrow> 2 < ?p ^ r ?p\n\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>P. 2) dvd (\\<Prod>p\\<in>P. totient (p ^ r p))", "by (intro prod_dvd_prod totient_even)"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>P. 2) dvd (\\<Prod>p\\<in>P. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "hence \"2 ^ card P dvd (\\<Prod>p\\<in>P. totient (p ^ r p))\""], ["proof (prove)\nusing this:\n  (\\<Prod>p\\<in>P. 2) dvd (\\<Prod>p\\<in>P. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ card P dvd (\\<Prod>p\\<in>P. totient (p ^ r p))", "by simp"], ["proof (state)\nthis:\n  2 ^ card P dvd (\\<Prod>p\\<in>P. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "also"], ["proof (state)\nthis:\n  2 ^ card P dvd (\\<Prod>p\\<in>P. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "have \"\\<dots> dvd (\\<Prod>p\\<in>P. totient (p ^ r p)) * (\\<Prod>p\\<in>P'. totient (p ^ r p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>P. totient (p ^ r p)) dvd\n    (\\<Prod>p\\<in>P. totient (p ^ r p)) *\n    (\\<Prod>p\\<in>P'. totient (p ^ r p))", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) dvd\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) * (\\<Prod>p\\<in>P'. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "also"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) dvd\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) * (\\<Prod>p\\<in>P'. totient (p ^ r p))\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "have \"\\<dots> = totient n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>P. totient (p ^ r p)) *\n    (\\<Prod>p\\<in>P'. totient (p ^ r p)) =\n    totient n", "by (rule eq [symmetric])"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>P. totient (p ^ r p)) *\n  (\\<Prod>p\\<in>P'. totient (p ^ r p)) =\n  totient n\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "finally"], ["proof (chain)\npicking this:\n  2 ^ card P dvd totient n", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ card P dvd totient n\n\ngoal (1 subgoal):\n 1. 2 ^ k dvd totient n", "unfolding k_def P_def"], ["proof (prove)\nusing this:\n  2 ^ card {p. p \\<in># prime_factorization n \\<and> odd p} dvd totient n\n\ngoal (1 subgoal):\n 1. 2 ^ card {p. p \\<in># prime_factorization n \\<and> odd p} dvd totient n", "."], ["proof (state)\nthis:\n  2 ^ k dvd totient n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totient_conv_moebius_mu':\n  assumes \"n > (0::nat)\"\n  shows   \"real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "have \"real (totient n) = of_int (int (totient n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (totient n) = real_of_int (int (totient n))", "by simp"], ["proof (state)\nthis:\n  real (totient n) = real_of_int (int (totient n))\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "also"], ["proof (state)\nthis:\n  real (totient n) = real_of_int (int (totient n))\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "have \"int (totient n) = (\\<Sum>d | d dvd n. moebius_mu d * int (n div d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (totient n) = (\\<Sum>d | d dvd n. moebius_mu d * int (n div d))", "using totient_conv_moebius_mu"], ["proof (prove)\nusing this:\n  int (totient ?n) = dirichlet_prod moebius_mu int ?n\n\ngoal (1 subgoal):\n 1. int (totient n) = (\\<Sum>d | d dvd n. moebius_mu d * int (n div d))", "by (simp add: dirichlet_prod_def assms)"], ["proof (state)\nthis:\n  int (totient n) = (\\<Sum>d | d dvd n. moebius_mu d * int (n div d))\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "also"], ["proof (state)\nthis:\n  int (totient n) = (\\<Sum>d | d dvd n. moebius_mu d * int (n div d))\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "have \"real_of_int (\\<Sum>d | d dvd n. moebius_mu d * int (n div d)) =\n               (\\<Sum>d | d dvd n. moebius_mu d * real (n div d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (\\<Sum>d | d dvd n. moebius_mu d * int (n div d)) =\n    (\\<Sum>d | d dvd n. moebius_mu d * real (n div d))", "by simp"], ["proof (state)\nthis:\n  real_of_int (\\<Sum>d | d dvd n. moebius_mu d * int (n div d)) =\n  (\\<Sum>d | d dvd n. moebius_mu d * real (n div d))\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "also"], ["proof (state)\nthis:\n  real_of_int (\\<Sum>d | d dvd n. moebius_mu d * int (n div d)) =\n  (\\<Sum>d | d dvd n. moebius_mu d * real (n div d))\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "have \"\\<dots> = (\\<Sum>d | d dvd n. real n * moebius_mu d / real d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd n. moebius_mu d * real (n div d)) =\n    (\\<Sum>d | d dvd n. real n * moebius_mu d / real d)", "by (rule sum.cong) (simp_all add: field_char_0_class.of_nat_div)"], ["proof (state)\nthis:\n  (\\<Sum>d | d dvd n. moebius_mu d * real (n div d)) =\n  (\\<Sum>d | d dvd n. real n * moebius_mu d / real d)\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>d | d dvd n. moebius_mu d * real (n div d)) =\n  (\\<Sum>d | d dvd n. real n * moebius_mu d / real d)\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "have \"\\<dots> = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd n. real n * moebius_mu d / real d) =\n    real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>d | d dvd n. real n * moebius_mu d / real d) =\n  real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "finally"], ["proof (chain)\npicking this:\n  real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)\n\ngoal (1 subgoal):\n 1. real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)", "."], ["proof (state)\nthis:\n  real (totient n) = real n * (\\<Sum>d | d dvd n. moebius_mu d / real d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totient_prime_power_Suc:\n  assumes \"prime p\"\n  shows   \"totient (p ^ Suc n) = p ^ Suc n - p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient (p ^ Suc n) = p ^ Suc n - p ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. totient (p ^ Suc n) = p ^ Suc n - p ^ n", "have \"totient (p ^ Suc n) = p ^ Suc n - card ((*) p ` {0<..p ^ n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient (p ^ Suc n) = p ^ Suc n - card ((*) p ` {0<..p ^ n})", "unfolding totient_def totatives_prime_power_Suc[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({0<..p ^ Suc n} - (*) p ` {0<..p ^ n}) =\n    p ^ Suc n - card ((*) p ` {0<..p ^ n})", "by (subst card_Diff_subset) (insert assms, auto simp: prime_gt_0_nat)"], ["proof (state)\nthis:\n  totient (p ^ Suc n) = p ^ Suc n - card ((*) p ` {0<..p ^ n})\n\ngoal (1 subgoal):\n 1. totient (p ^ Suc n) = p ^ Suc n - p ^ n", "also"], ["proof (state)\nthis:\n  totient (p ^ Suc n) = p ^ Suc n - card ((*) p ` {0<..p ^ n})\n\ngoal (1 subgoal):\n 1. totient (p ^ Suc n) = p ^ Suc n - p ^ n", "from assms"], ["proof (chain)\npicking this:\n  prime p", "have \"card ((*) p ` {0<..p^n}) = p ^ n\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. card ((*) p ` {0<..p ^ n}) = p ^ n", "by (subst card_image) (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  card ((*) p ` {0<..p ^ n}) = p ^ n\n\ngoal (1 subgoal):\n 1. totient (p ^ Suc n) = p ^ Suc n - p ^ n", "finally"], ["proof (chain)\npicking this:\n  totient (p ^ Suc n) = p ^ Suc n - p ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  totient (p ^ Suc n) = p ^ Suc n - p ^ n\n\ngoal (1 subgoal):\n 1. totient (p ^ Suc n) = p ^ Suc n - p ^ n", "."], ["proof (state)\nthis:\n  totient (p ^ Suc n) = p ^ Suc n - p ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation totient: multiplicative_function' totient \"\\<lambda>p k. p ^ k - p ^ (k - 1)\" \"\\<lambda>p. p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function' totient (\\<lambda>p k. p ^ k - p ^ (k - 1))\n     (\\<lambda>p. p - 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> totient (p ^ k) = p ^ k - p ^ (k - 1)\n 2. \\<And>p. prime p \\<Longrightarrow> p ^ 1 - p ^ (1 - 1) = p - 1", "fix p k :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> totient (p ^ k) = p ^ k - p ^ (k - 1)\n 2. \\<And>p. prime p \\<Longrightarrow> p ^ 1 - p ^ (1 - 1) = p - 1", "assume \"prime p\" \"k > 0\""], ["proof (state)\nthis:\n  prime p\n  0 < k\n\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> totient (p ^ k) = p ^ k - p ^ (k - 1)\n 2. \\<And>p. prime p \\<Longrightarrow> p ^ 1 - p ^ (1 - 1) = p - 1", "thus \"totient (p ^ k) = p ^ k - p ^ (k - 1)\""], ["proof (prove)\nusing this:\n  prime p\n  0 < k\n\ngoal (1 subgoal):\n 1. totient (p ^ k) = p ^ k - p ^ (k - 1)", "by (cases k) (simp_all add: totient_prime_power_Suc del: power_Suc)"], ["proof (state)\nthis:\n  totient (p ^ k) = p ^ k - p ^ (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>p. prime p \\<Longrightarrow> p ^ 1 - p ^ (1 - 1) = p - 1", "qed simp_all"], ["", "end"]]}