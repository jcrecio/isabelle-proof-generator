{"file_name": "/home/qj213/afp-2021-10-22/thys/Dirichlet_Series/Dirichlet_Efficient_Code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dirichlet_Series", "problem_names": ["lemma set_prime_factorization_nat':\n  \"set (prime_factorization_nat' n) = (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\"", "lemma distinct_prime_factorization_nat' [simp]: \"distinct (prime_factorization_nat' n)\"", "lemmas (in multiplicative_function') efficient_code' = \n   efficient_code [of \"\\<lambda>_. prime_factorization_nat' n\" n for n, \n     OF set_prime_factorization_nat' distinct_prime_factorization_nat']", "lemma moebius_mu_conv_moebius_mu_aux:\n  fixes qs :: \"unit \\<Rightarrow> nat list\"\n  defines \"ps \\<equiv> qs ()\"\n  assumes \"mset ps = prime_factorization n\"\n  shows   \"moebius_mu n = of_int (moebius_mu_aux n qs)\"", "lemma moebius_mu_code [code]: \n    \"moebius_mu n = of_int (moebius_mu_aux n (\\<lambda>_. prime_factorization_nat n))\"", "lemma of_nat_totient_aux1:\n  assumes \"\\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\" \"\\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n\" \"distinct ps\"\n  shows   \"real (totient_aux1 n ps) = real n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\"", "lemma totient_conv_totient_aux1:\n  assumes \"set ps = prime_factors n\" \"distinct ps\"\n  shows   \"totient n = totient_aux1 n ps\"", "lemma set_prime_factors_nat [simp]: \"set (prime_factors_nat n) = prime_factors n\"", "lemma distinct_prime_factors_nat [simp]: \"distinct (prime_factors_nat n)\"", "lemma totient_conv_totient_aux2:\n  assumes \"n \\<noteq> 0\"\n  assumes \"set xs = (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\"\n  assumes \"distinct xs\"\n  shows   \"totient n = totient_aux2 xs\"", "lemma totient_code1: \"totient n = totient_aux1 n (prime_factors_nat n)\"", "lemma totient_code2: \"totient n = (if n = 0 then 0 else totient_aux2 (prime_factorization_nat' n))\"", "lemmas [code] = totient_code2", "lemmas [code del] = divisor_count_naive divisor_sum_naive", "lemmas [code] = divisor_count.efficient_code' divisor_sum.efficient_code'", "lemma [code]: \"liouville_lambda n = \n  (if n = 0 then 0 else if even (length (prime_factorization_nat n)) then 1 else -1)\""], "translations": [["", "lemma set_prime_factorization_nat':\n  \"set (prime_factorization_nat' n) = (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (prime_factorization_nat' n) =\n    (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n", "proof (intro equalityI subsetI; clarify)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (prime_factorization_nat' n) \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n 2. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "fix p k :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (prime_factorization_nat' n) \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n 2. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "assume pk: \"(p, k) \\<in> set (prime_factorization_nat' n)\""], ["proof (state)\nthis:\n  (p, k) \\<in> set (prime_factorization_nat' n)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (prime_factorization_nat' n) \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n 2. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "hence p: \"p \\<in> prime_factors n\""], ["proof (prove)\nusing this:\n  (p, k) \\<in> set (prime_factorization_nat' n)\n\ngoal (1 subgoal):\n 1. p \\<in># prime_factorization n", "by (auto simp: prime_factorization_nat'_def Let_def multiset_prime_factorization_nat_correct)"], ["proof (state)\nthis:\n  p \\<in># prime_factorization n\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (prime_factorization_nat' n) \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n 2. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "hence p': \"prime p\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. prime p", "by (simp add: prime_factors_multiplicity)"], ["proof (state)\nthis:\n  prime p\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (prime_factorization_nat' n) \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n 2. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "from pk p'"], ["proof (chain)\npicking this:\n  (p, k) \\<in> set (prime_factorization_nat' n)\n  prime p", "have \"k = multiplicity p n - 1\""], ["proof (prove)\nusing this:\n  (p, k) \\<in> set (prime_factorization_nat' n)\n  prime p\n\ngoal (1 subgoal):\n 1. k = multiplicity p n - 1", "by (auto simp: prime_factorization_nat'_def Let_def multiset_prime_factorization_nat_correct\n          count_prime_factorization_prime [symmetric] count_mset )"], ["proof (state)\nthis:\n  k = multiplicity p n - 1\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (prime_factorization_nat' n) \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n 2. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "with p"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization n\n  k = multiplicity p n - 1", "show \"(p, k) \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization n\n  k = multiplicity p n - 1\n\ngoal (1 subgoal):\n 1. (p, k) \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n", "by auto"], ["proof (state)\nthis:\n  (p, k) \\<in> (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "fix p :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "assume \"p \\<in> prime_factors n\""], ["proof (state)\nthis:\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "moreover"], ["proof (state)\nthis:\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "from this"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization n", "have \"prime p\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. prime p", "by (simp add: prime_factors_multiplicity)"], ["proof (state)\nthis:\n  prime p\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       p \\<in># prime_factorization n \\<Longrightarrow>\n       (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "ultimately"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization n\n  prime p", "show \"(p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization n\n  prime p\n\ngoal (1 subgoal):\n 1. (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)", "by (auto simp: prime_factorization_nat'_def Let_def multiset_prime_factorization_nat_correct \n          count_prime_factorization_prime [symmetric] count_mset)"], ["proof (state)\nthis:\n  (p, multiplicity p n - 1) \\<in> set (prime_factorization_nat' n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_prime_factorization_nat' [simp]: \"distinct (prime_factorization_nat' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (prime_factorization_nat' n)", "by (simp add: distinct_map inj_on_def prime_factorization_nat'_def Let_def)"], ["", "lemmas (in multiplicative_function') efficient_code' = \n   efficient_code [of \"\\<lambda>_. prime_factorization_nat' n\" n for n, \n     OF set_prime_factorization_nat' distinct_prime_factorization_nat']"], ["", "subsection \\<open>M\\\"{o}bius $\\mu$ function\\<close>"], ["", "definition moebius_mu_aux :: \"nat \\<Rightarrow> (unit \\<Rightarrow> nat list) \\<Rightarrow> int\" where\n  \"moebius_mu_aux n ps = \n     (if n \\<noteq> 0 \\<and> \\<not>4 dvd n \\<and> \\<not>9 dvd n then\n        (let ps = ps () in if distinct ps then if even (length ps) then 1 else -1 else 0) else 0)\""], ["", "lemma moebius_mu_conv_moebius_mu_aux:\n  fixes qs :: \"unit \\<Rightarrow> nat list\"\n  defines \"ps \\<equiv> qs ()\"\n  assumes \"mset ps = prime_factorization n\"\n  shows   \"moebius_mu n = of_int (moebius_mu_aux n qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_mu n = of_int (moebius_mu_aux n qs)", "proof (cases \"n = 0 \\<or> 4 dvd n \\<or> 9 dvd n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<or> 4 dvd n \\<or> 9 dvd n \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> (n = 0 \\<or> 4 dvd n \\<or> 9 dvd n) \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "case False"], ["proof (state)\nthis:\n  \\<not> (n = 0 \\<or> 4 dvd n \\<or> 9 dvd n)\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> 4 dvd n \\<or> 9 dvd n \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> (n = 0 \\<or> 4 dvd n \\<or> 9 dvd n) \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "hence [simp]: \"n > 0\""], ["proof (prove)\nusing this:\n  \\<not> (n = 0 \\<or> 4 dvd n \\<or> 9 dvd n)\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> 4 dvd n \\<or> 9 dvd n \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> (n = 0 \\<or> 4 dvd n \\<or> 9 dvd n) \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "have \"set_mset (mset ps) = prime_factors n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (mset ps) = prime_factors n", "by (subst assms) simp"], ["proof (state)\nthis:\n  set_mset (mset ps) = prime_factors n\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> 4 dvd n \\<or> 9 dvd n \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> (n = 0 \\<or> 4 dvd n \\<or> 9 dvd n) \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "hence [simp]: \"set ps = prime_factors n\""], ["proof (prove)\nusing this:\n  set_mset (mset ps) = prime_factors n\n\ngoal (1 subgoal):\n 1. set ps = prime_factors n", "by simp"], ["proof (state)\nthis:\n  set ps = prime_factors n\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> 4 dvd n \\<or> 9 dvd n \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> (n = 0 \\<or> 4 dvd n \\<or> 9 dvd n) \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_mu n = of_int (moebius_mu_aux n qs)", "proof (cases \"distinct ps\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "case True"], ["proof (state)\nthis:\n  distinct ps\n\ngoal (2 subgoals):\n 1. distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "have \"multiplicity p n = 1\" if p: \"p \\<in> prime_factors n\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p n = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multiplicity p n = 1", "from p and True"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization n\n  distinct ps", "have \"count (mset ps) p = 1\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization n\n  distinct ps\n\ngoal (1 subgoal):\n 1. count (mset ps) p = 1", "by (auto simp: distinct_count_atmost_1)"], ["proof (state)\nthis:\n  count (mset ps) p = 1\n\ngoal (1 subgoal):\n 1. multiplicity p n = 1", "also"], ["proof (state)\nthis:\n  count (mset ps) p = 1\n\ngoal (1 subgoal):\n 1. multiplicity p n = 1", "from assms and p"], ["proof (chain)\npicking this:\n  ps \\<equiv> qs ()\n  mset ps = prime_factorization n\n  p \\<in># prime_factorization n", "have \"count (mset ps) p = multiplicity p n\""], ["proof (prove)\nusing this:\n  ps \\<equiv> qs ()\n  mset ps = prime_factorization n\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. count (mset ps) p = multiplicity p n", "by (simp add: prime_factors_multiplicity count_prime_factorization_prime)"], ["proof (state)\nthis:\n  count (mset ps) p = multiplicity p n\n\ngoal (1 subgoal):\n 1. multiplicity p n = 1", "finally"], ["proof (chain)\npicking this:\n  multiplicity p n = 1", "show \"multiplicity p n = 1\""], ["proof (prove)\nusing this:\n  multiplicity p n = 1\n\ngoal (1 subgoal):\n 1. multiplicity p n = 1", "."], ["proof (state)\nthis:\n  multiplicity p n = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p \\<in># prime_factorization n \\<Longrightarrow> multiplicity ?p n = 1\n\ngoal (2 subgoals):\n 1. distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "moreover"], ["proof (state)\nthis:\n  ?p \\<in># prime_factorization n \\<Longrightarrow> multiplicity ?p n = 1\n\ngoal (2 subgoals):\n 1. distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "from True"], ["proof (chain)\npicking this:\n  distinct ps", "have \"card (prime_factors n) = length ps\""], ["proof (prove)\nusing this:\n  distinct ps\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = length ps", "by (simp only: assms [symmetric] set_mset_mset distinct_card)"], ["proof (state)\nthis:\n  card (prime_factors n) = length ps\n\ngoal (2 subgoals):\n 1. distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)\n 2. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "ultimately"], ["proof (chain)\npicking this:\n  ?p \\<in># prime_factorization n \\<Longrightarrow> multiplicity ?p n = 1\n  card (prime_factors n) = length ps", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p \\<in># prime_factorization n \\<Longrightarrow> multiplicity ?p n = 1\n  card (prime_factors n) = length ps\n\ngoal (1 subgoal):\n 1. moebius_mu n = of_int (moebius_mu_aux n qs)", "using False and True"], ["proof (prove)\nusing this:\n  ?p \\<in># prime_factorization n \\<Longrightarrow> multiplicity ?p n = 1\n  card (prime_factors n) = length ps\n  \\<not> (n = 0 \\<or> 4 dvd n \\<or> 9 dvd n)\n  distinct ps\n\ngoal (1 subgoal):\n 1. moebius_mu n = of_int (moebius_mu_aux n qs)", "by (auto simp add: moebius_mu_def moebius_mu_aux_def ps_def \n            Let_def squarefree_factorial_semiring')"], ["proof (state)\nthis:\n  moebius_mu n = of_int (moebius_mu_aux n qs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "case False"], ["proof (state)\nthis:\n  \\<not> distinct ps\n\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct ps", "obtain p where \"count (mset ps) p \\<noteq> (if p \\<in> set ps then 1 else 0)\""], ["proof (prove)\nusing this:\n  \\<not> distinct ps\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        count (mset ps) p \\<noteq>\n        (if p \\<in> set ps then 1 else 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) distinct_count_atmost_1) auto"], ["proof (state)\nthis:\n  count (mset ps) p \\<noteq> (if p \\<in> set ps then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "moreover"], ["proof (state)\nthis:\n  count (mset ps) p \\<noteq> (if p \\<in> set ps then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "from this"], ["proof (chain)\npicking this:\n  count (mset ps) p \\<noteq> (if p \\<in> set ps then 1 else 0)", "have p: \"p \\<in> prime_factors n\""], ["proof (prove)\nusing this:\n  count (mset ps) p \\<noteq> (if p \\<in> set ps then 1 else 0)\n\ngoal (1 subgoal):\n 1. p \\<in># prime_factorization n", "by (cases \"count (mset ps) p = 0\") (auto split: if_splits)"], ["proof (state)\nthis:\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "ultimately"], ["proof (chain)\npicking this:\n  count (mset ps) p \\<noteq> (if p \\<in> set ps then 1 else 0)\n  p \\<in># prime_factorization n", "have \"count (mset ps) p > 1\""], ["proof (prove)\nusing this:\n  count (mset ps) p \\<noteq> (if p \\<in> set ps then 1 else 0)\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. 1 < count (mset ps) p", "by (cases \"count (mset ps) p\") auto"], ["proof (state)\nthis:\n  1 < count (mset ps) p\n\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "with p and assms"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization n\n  ps \\<equiv> qs ()\n  mset ps = prime_factorization n\n  1 < count (mset ps) p", "have \"multiplicity p n > 1\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization n\n  ps \\<equiv> qs ()\n  mset ps = prime_factorization n\n  1 < count (mset ps) p\n\ngoal (1 subgoal):\n 1. 1 < multiplicity p n", "by (simp add: prime_factors_multiplicity count_prime_factorization_prime)"], ["proof (state)\nthis:\n  1 < multiplicity p n\n\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "with False and assms and p"], ["proof (chain)\npicking this:\n  \\<not> distinct ps\n  ps \\<equiv> qs ()\n  mset ps = prime_factorization n\n  p \\<in># prime_factorization n\n  1 < multiplicity p n", "have \"\\<not>squarefree n\""], ["proof (prove)\nusing this:\n  \\<not> distinct ps\n  ps \\<equiv> qs ()\n  mset ps = prime_factorization n\n  p \\<in># prime_factorization n\n  1 < multiplicity p n\n\ngoal (1 subgoal):\n 1. \\<not> squarefree n", "by (auto simp: squarefree_factorial_semiring'')"], ["proof (state)\nthis:\n  \\<not> squarefree n\n\ngoal (1 subgoal):\n 1. \\<not> distinct ps \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "with False and assms and p"], ["proof (chain)\npicking this:\n  \\<not> distinct ps\n  ps \\<equiv> qs ()\n  mset ps = prime_factorization n\n  p \\<in># prime_factorization n\n  \\<not> squarefree n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> distinct ps\n  ps \\<equiv> qs ()\n  mset ps = prime_factorization n\n  p \\<in># prime_factorization n\n  \\<not> squarefree n\n\ngoal (1 subgoal):\n 1. moebius_mu n = of_int (moebius_mu_aux n qs)", "by (auto simp: moebius_mu_def moebius_mu_aux_def)"], ["proof (state)\nthis:\n  moebius_mu n = of_int (moebius_mu_aux n qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  moebius_mu n = of_int (moebius_mu_aux n qs)\n\ngoal (1 subgoal):\n 1. n = 0 \\<or> 4 dvd n \\<or> 9 dvd n \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 0 \\<or> 4 dvd n \\<or> 9 dvd n \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "case True"], ["proof (state)\nthis:\n  n = 0 \\<or> 4 dvd n \\<or> 9 dvd n\n\ngoal (1 subgoal):\n 1. n = 0 \\<or> 4 dvd n \\<or> 9 dvd n \\<Longrightarrow>\n    moebius_mu n = of_int (moebius_mu_aux n qs)", "with not_squarefreeI[of 2 n] and not_squarefreeI[of 3 n]"], ["proof (chain)\npicking this:\n  \\<lbrakk>2\\<^sup>2 dvd n; \\<not> is_unit 2\\<rbrakk>\n  \\<Longrightarrow> \\<not> squarefree n\n  \\<lbrakk>3\\<^sup>2 dvd n; \\<not> is_unit 3\\<rbrakk>\n  \\<Longrightarrow> \\<not> squarefree n\n  n = 0 \\<or> 4 dvd n \\<or> 9 dvd n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>2\\<^sup>2 dvd n; \\<not> is_unit 2\\<rbrakk>\n  \\<Longrightarrow> \\<not> squarefree n\n  \\<lbrakk>3\\<^sup>2 dvd n; \\<not> is_unit 3\\<rbrakk>\n  \\<Longrightarrow> \\<not> squarefree n\n  n = 0 \\<or> 4 dvd n \\<or> 9 dvd n\n\ngoal (1 subgoal):\n 1. moebius_mu n = of_int (moebius_mu_aux n qs)", "by (auto simp: moebius_mu_aux_def)"], ["proof (state)\nthis:\n  moebius_mu n = of_int (moebius_mu_aux n qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma moebius_mu_code [code]: \n    \"moebius_mu n = of_int (moebius_mu_aux n (\\<lambda>_. prime_factorization_nat n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_mu n =\n    of_int (moebius_mu_aux n (\\<lambda>_. prime_factorization_nat n))", "by (rule moebius_mu_conv_moebius_mu_aux) (simp_all add: multiset_prime_factorization_nat_correct)"], ["", "value \"moebius_mu 12578972695257 :: int\""], ["", "subsection \\<open>Euler's $\\phi$ function\\<close>"], ["", "primrec totient_aux1 :: \"nat \\<Rightarrow> nat list \\<Rightarrow> nat\" where\n  \"totient_aux1 n [] = n\"\n| \"totient_aux1 n (p # ps) = totient_aux1 (n - n div p) ps\""], ["", "lemma of_nat_totient_aux1:\n  assumes \"\\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\" \"\\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n\" \"distinct ps\"\n  shows   \"real (totient_aux1 n ps) = real n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (totient_aux1 n ps) =\n    real n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)", "using assms"], ["proof (prove)\nusing this:\n  ?p \\<in> set ps \\<Longrightarrow> prime ?p\n  ?p \\<in> set ps \\<Longrightarrow> ?p dvd n\n  distinct ps\n\ngoal (1 subgoal):\n 1. real (totient_aux1 n ps) =\n    real n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)", "proof (induction ps arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "case (Cons p ps n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>p. p \\<in> set ps \\<Longrightarrow> prime p;\n   \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd ?n; distinct ps\\<rbrakk>\n  \\<Longrightarrow> real (totient_aux1 ?n ps) =\n                    real ?n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\n  ?p \\<in> set (p # ps) \\<Longrightarrow> prime ?p\n  ?p \\<in> set (p # ps) \\<Longrightarrow> ?p dvd n\n  distinct (p # ps)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "from Cons.prems"], ["proof (chain)\npicking this:\n  ?p \\<in> set (p # ps) \\<Longrightarrow> prime ?p\n  ?p \\<in> set (p # ps) \\<Longrightarrow> ?p dvd n\n  distinct (p # ps)", "have p: \"prime p\" \"p dvd n\""], ["proof (prove)\nusing this:\n  ?p \\<in> set (p # ps) \\<Longrightarrow> prime ?p\n  ?p \\<in> set (p # ps) \\<Longrightarrow> ?p dvd n\n  distinct (p # ps)\n\ngoal (1 subgoal):\n 1. prime p &&& p dvd n", "by auto"], ["proof (state)\nthis:\n  prime p\n  p dvd n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "have \"real (totient_aux1 n (p # ps)) = real (totient_aux1 (n - n div p) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (totient_aux1 n (p # ps)) = real (totient_aux1 (n - n div p) ps)", "by simp"], ["proof (state)\nthis:\n  real (totient_aux1 n (p # ps)) = real (totient_aux1 (n - n div p) ps)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "also"], ["proof (state)\nthis:\n  real (totient_aux1 n (p # ps)) = real (totient_aux1 (n - n div p) ps)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "have \"\\<dots> = real (n - n div p) * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (totient_aux1 (n - n div p) ps) =\n    real (n - n div p) * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)", "proof (rule Cons.IH)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\n 2. \\<And>pa. pa \\<in> set ps \\<Longrightarrow> pa dvd n - n div p\n 3. distinct ps", "fix q"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\n 2. \\<And>pa. pa \\<in> set ps \\<Longrightarrow> pa dvd n - n div p\n 3. distinct ps", "assume q: \"q \\<in> set ps\""], ["proof (state)\nthis:\n  q \\<in> set ps\n\ngoal (3 subgoals):\n 1. \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\n 2. \\<And>pa. pa \\<in> set ps \\<Longrightarrow> pa dvd n - n div p\n 3. distinct ps", "define m where \"m = n div p\""], ["proof (state)\nthis:\n  m = n div p\n\ngoal (3 subgoals):\n 1. \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\n 2. \\<And>pa. pa \\<in> set ps \\<Longrightarrow> pa dvd n - n div p\n 3. distinct ps", "from p"], ["proof (chain)\npicking this:\n  prime p\n  p dvd n", "have m: \"n = p * m\""], ["proof (prove)\nusing this:\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. n = p * m", "by (simp add: m_def)"], ["proof (state)\nthis:\n  n = p * m\n\ngoal (3 subgoals):\n 1. \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\n 2. \\<And>pa. pa \\<in> set ps \\<Longrightarrow> pa dvd n - n div p\n 3. distinct ps", "from Cons.prems q"], ["proof (chain)\npicking this:\n  ?p \\<in> set (p # ps) \\<Longrightarrow> prime ?p\n  ?p \\<in> set (p # ps) \\<Longrightarrow> ?p dvd n\n  distinct (p # ps)\n  q \\<in> set ps", "have \"prime q\" \"q dvd n\" \"p \\<noteq> q\""], ["proof (prove)\nusing this:\n  ?p \\<in> set (p # ps) \\<Longrightarrow> prime ?p\n  ?p \\<in> set (p # ps) \\<Longrightarrow> ?p dvd n\n  distinct (p # ps)\n  q \\<in> set ps\n\ngoal (1 subgoal):\n 1. prime q &&& q dvd n &&& p \\<noteq> q", "by auto"], ["proof (state)\nthis:\n  prime q\n  q dvd n\n  p \\<noteq> q\n\ngoal (3 subgoals):\n 1. \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\n 2. \\<And>pa. pa \\<in> set ps \\<Longrightarrow> pa dvd n - n div p\n 3. distinct ps", "hence \"q dvd m\""], ["proof (prove)\nusing this:\n  prime q\n  q dvd n\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. q dvd m", "using primes_dvd_imp_eq[of q p]  p"], ["proof (prove)\nusing this:\n  prime q\n  q dvd n\n  p \\<noteq> q\n  \\<lbrakk>prime q; prime p; q dvd p\\<rbrakk> \\<Longrightarrow> q = p\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. q dvd m", "by (auto simp add: m prime_dvd_mult_iff)"], ["proof (state)\nthis:\n  q dvd m\n\ngoal (3 subgoals):\n 1. \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\n 2. \\<And>pa. pa \\<in> set ps \\<Longrightarrow> pa dvd n - n div p\n 3. distinct ps", "thus \"q dvd n - n div p\""], ["proof (prove)\nusing this:\n  q dvd m\n\ngoal (1 subgoal):\n 1. q dvd n - n div p", "unfolding m_def"], ["proof (prove)\nusing this:\n  q dvd n div p\n\ngoal (1 subgoal):\n 1. q dvd n - n div p", "using p \\<open>q dvd n\\<close>"], ["proof (prove)\nusing this:\n  q dvd n div p\n  prime p\n  p dvd n\n  q dvd n\n\ngoal (1 subgoal):\n 1. q dvd n - n div p", "by simp"], ["proof (state)\nthis:\n  q dvd n - n div p\n\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\n 2. distinct ps", "qed (insert Cons.prems, auto)"], ["proof (state)\nthis:\n  real (totient_aux1 (n - n div p) ps) =\n  real (n - n div p) * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "also"], ["proof (state)\nthis:\n  real (totient_aux1 (n - n div p) ps) =\n  real (n - n div p) * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "have \"real (n - n div p) = real n * (1 - 1 / real p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n - n div p) = real n * (1 - 1 / real p)", "by (simp add: of_nat_diff real_of_nat_div p field_simps)"], ["proof (state)\nthis:\n  real (n - n div p) = real n * (1 - 1 / real p)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "also"], ["proof (state)\nthis:\n  real (n - n div p) = real n * (1 - 1 / real p)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "have \"\\<dots> * (\\<Prod>p\\<in>set ps. 1 - 1 / real p) = real n * (\\<Prod>p\\<in>set (p#ps). 1 - 1 / real p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n * (1 - 1 / real p) * (\\<Prod>p\\<in>set ps. 1 - 1 / real p) =\n    real n * (\\<Prod>p\\<in>set (p # ps). 1 - 1 / real p)", "using Cons.prems"], ["proof (prove)\nusing this:\n  ?p \\<in> set (p # ps) \\<Longrightarrow> prime ?p\n  ?p \\<in> set (p # ps) \\<Longrightarrow> ?p dvd n\n  distinct (p # ps)\n\ngoal (1 subgoal):\n 1. real n * (1 - 1 / real p) * (\\<Prod>p\\<in>set ps. 1 - 1 / real p) =\n    real n * (\\<Prod>p\\<in>set (p # ps). 1 - 1 / real p)", "by simp"], ["proof (state)\nthis:\n  real n * (1 - 1 / real p) * (\\<Prod>p\\<in>set ps. 1 - 1 / real p) =\n  real n * (\\<Prod>p\\<in>set (p # ps). 1 - 1 / real p)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>\\<And>p.\n                               p \\<in> set ps \\<Longrightarrow> prime p;\n                    \\<And>p. p \\<in> set ps \\<Longrightarrow> p dvd n;\n                    distinct ps\\<rbrakk>\n                   \\<Longrightarrow> real (totient_aux1 n ps) =\n                                     real n *\n                                     (\\<Prod>p\\<in>set ps. 1 - 1 / real p);\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set (a # ps) \\<Longrightarrow> p dvd n;\n        distinct (a # ps)\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n (a # ps)) =\n                         real n *\n                         (\\<Prod>p\\<in>set (a # ps). 1 - 1 / real p)", "finally"], ["proof (chain)\npicking this:\n  real (totient_aux1 n (p # ps)) =\n  real n * (\\<Prod>p\\<in>set (p # ps). 1 - 1 / real p)", "show ?case"], ["proof (prove)\nusing this:\n  real (totient_aux1 n (p # ps)) =\n  real n * (\\<Prod>p\\<in>set (p # ps). 1 - 1 / real p)\n\ngoal (1 subgoal):\n 1. real (totient_aux1 n (p # ps)) =\n    real n * (\\<Prod>p\\<in>set (p # ps). 1 - 1 / real p)", "."], ["proof (state)\nthis:\n  real (totient_aux1 n (p # ps)) =\n  real n * (\\<Prod>p\\<in>set (p # ps). 1 - 1 / real p)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>p. p \\<in> set [] \\<Longrightarrow> prime p;\n        \\<And>p. p \\<in> set [] \\<Longrightarrow> p dvd n;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> real (totient_aux1 n []) =\n                         real n * (\\<Prod>p\\<in>set []. 1 - 1 / real p)", "qed simp_all"], ["", "lemma totient_conv_totient_aux1:\n  assumes \"set ps = prime_factors n\" \"distinct ps\"\n  shows   \"totient n = totient_aux1 n ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n ps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n ps", "from assms"], ["proof (chain)\npicking this:\n  set ps = prime_factors n\n  distinct ps", "have \"real (totient_aux1 n ps) = real n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\""], ["proof (prove)\nusing this:\n  set ps = prime_factors n\n  distinct ps\n\ngoal (1 subgoal):\n 1. real (totient_aux1 n ps) =\n    real n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)", "by (intro of_nat_totient_aux1) auto"], ["proof (state)\nthis:\n  real (totient_aux1 n ps) = real n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\n\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n ps", "also"], ["proof (state)\nthis:\n  real (totient_aux1 n ps) = real n * (\\<Prod>p\\<in>set ps. 1 - 1 / real p)\n\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n ps", "have \"set ps = prime_factors n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps = prime_factors n", "by fact"], ["proof (state)\nthis:\n  set ps = prime_factors n\n\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n ps", "also"], ["proof (state)\nthis:\n  set ps = prime_factors n\n\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n ps", "have \"real n * (\\<Prod>p\\<in>prime_factors n. 1 - 1 / real p) = real (totient n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n * (\\<Prod>p\\<in>prime_factors n. 1 - 1 / real p) =\n    real (totient n)", "by (rule totient_formula2 [symmetric])"], ["proof (state)\nthis:\n  real n * (\\<Prod>p\\<in>prime_factors n. 1 - 1 / real p) = real (totient n)\n\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n ps", "finally"], ["proof (chain)\npicking this:\n  real (totient_aux1 n ps) = real (totient n)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (totient_aux1 n ps) = real (totient n)\n\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n ps", "by (simp only: of_nat_eq_iff)"], ["proof (state)\nthis:\n  totient n = totient_aux1 n ps\n\ngoal:\nNo subgoals!", "qed"], ["", "definition prime_factors_nat :: \"nat \\<Rightarrow> nat list\" where\n  \"prime_factors_nat n = remdups_adj (sort (prime_factorization_nat n))\""], ["", "lemma set_prime_factors_nat [simp]: \"set (prime_factors_nat n) = prime_factors n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (prime_factors_nat n) = prime_factors n", "unfolding prime_factors_nat_def multiset_prime_factorization_nat_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups_adj (sort (prime_factorization_nat n))) =\n    set_mset (mset (prime_factorization_nat n))", "by simp"], ["", "lemma distinct_prime_factors_nat [simp]: \"distinct (prime_factors_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (prime_factors_nat n)", "by (simp add: prime_factors_nat_def)"], ["", "definition totient_aux2 :: \"(nat \\<times> nat) list \\<Rightarrow> nat\" where\n  \"totient_aux2 xs = (\\<Prod>(p,k)\\<leftarrow>xs. p ^ k * (p - 1))\""], ["", "lemma totient_conv_totient_aux2:\n  assumes \"n \\<noteq> 0\"\n  assumes \"set xs = (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\"\n  assumes \"distinct xs\"\n  shows   \"totient n = totient_aux2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "have \"totient_aux2 xs = (\\<Prod>(p,k)\\<leftarrow>xs. p ^ k * (p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient_aux2 xs = (\\<Prod>(p, k)\\<leftarrow>xs. p ^ k * (p - 1))", "by (fact totient_aux2_def)"], ["proof (state)\nthis:\n  totient_aux2 xs = (\\<Prod>(p, k)\\<leftarrow>xs. p ^ k * (p - 1))\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "also"], ["proof (state)\nthis:\n  totient_aux2 xs = (\\<Prod>(p, k)\\<leftarrow>xs. p ^ k * (p - 1))\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "from assms"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  set xs = (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n  distinct xs", "have \"\\<dots> = \n    (\\<Prod>x\\<in>(\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n. case x of (p, k) \\<Rightarrow> p ^ k * (p - Suc 0))\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  set xs = (\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n\n  distinct xs\n\ngoal (1 subgoal):\n 1. (\\<Prod>(p, k)\\<leftarrow>xs. p ^ k * (p - 1)) =\n    (\\<Prod>x\\<in>(\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n.\n       case x of (p, k) \\<Rightarrow> p ^ k * (p - Suc 0))", "by (subst prod.distinct_set_conv_list [symmetric]) simp_all"], ["proof (state)\nthis:\n  (\\<Prod>(p, k)\\<leftarrow>xs. p ^ k * (p - 1)) =\n  (\\<Prod>x\\<in>(\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n.\n     case x of (p, k) \\<Rightarrow> p ^ k * (p - Suc 0))\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "also"], ["proof (state)\nthis:\n  (\\<Prod>(p, k)\\<leftarrow>xs. p ^ k * (p - 1)) =\n  (\\<Prod>x\\<in>(\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n.\n     case x of (p, k) \\<Rightarrow> p ^ k * (p - Suc 0))\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "have \"\\<dots> = (\\<Prod>p\\<in>prime_factors n. p ^ (multiplicity p n - 1) * (p - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>(\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n.\n       case x of (p, k) \\<Rightarrow> p ^ k * (p - Suc 0)) =\n    (\\<Prod>p\\<in>prime_factors n. p ^ (multiplicity p n - 1) * (p - Suc 0))", "by (subst prod.reindex) (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>(\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n.\n     case x of (p, k) \\<Rightarrow> p ^ k * (p - Suc 0)) =\n  (\\<Prod>p\\<in>prime_factors n. p ^ (multiplicity p n - 1) * (p - Suc 0))\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>(\\<lambda>p. (p, multiplicity p n - 1)) ` prime_factors n.\n     case x of (p, k) \\<Rightarrow> p ^ k * (p - Suc 0)) =\n  (\\<Prod>p\\<in>prime_factors n. p ^ (multiplicity p n - 1) * (p - Suc 0))\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "have \"\\<dots> = (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n - p ^ (multiplicity p n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors n.\n       p ^ (multiplicity p n - 1) * (p - Suc 0)) =\n    (\\<Prod>p\\<in>prime_factors n.\n       p ^ multiplicity p n - p ^ (multiplicity p n - 1))", "by (intro prod.cong refl) (auto simp: prime_factors_multiplicity algebra_simps\n                                 power_Suc [symmetric] simp del: power_Suc)"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors n. p ^ (multiplicity p n - 1) * (p - Suc 0)) =\n  (\\<Prod>p\\<in>prime_factors n.\n     p ^ multiplicity p n - p ^ (multiplicity p n - 1))\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "also"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors n. p ^ (multiplicity p n - 1) * (p - Suc 0)) =\n  (\\<Prod>p\\<in>prime_factors n.\n     p ^ multiplicity p n - p ^ (multiplicity p n - 1))\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "have \"\\<dots> = totient n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors n.\n       p ^ multiplicity p n - p ^ (multiplicity p n - 1)) =\n    totient n", "using assms(1)"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors n.\n       p ^ multiplicity p n - p ^ (multiplicity p n - 1)) =\n    totient n", "by (subst totient.prod_prime_factors') auto"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors n.\n     p ^ multiplicity p n - p ^ (multiplicity p n - 1)) =\n  totient n\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", "finally"], ["proof (chain)\npicking this:\n  totient_aux2 xs = totient n", "show ?thesis"], ["proof (prove)\nusing this:\n  totient_aux2 xs = totient n\n\ngoal (1 subgoal):\n 1. totient n = totient_aux2 xs", ".."], ["proof (state)\nthis:\n  totient n = totient_aux2 xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totient_code1: \"totient n = totient_aux1 n (prime_factors_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n = totient_aux1 n (prime_factors_nat n)", "by (intro totient_conv_totient_aux1) simp_all"], ["", "lemma totient_code2: \"totient n = (if n = 0 then 0 else totient_aux2 (prime_factorization_nat' n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n =\n    (if n = 0 then 0 else totient_aux2 (prime_factorization_nat' n))", "by (simp_all add: set_prime_factorization_nat' totient_conv_totient_aux2 split: if_splits)"], ["", "declare totient_code_naive [code del]"], ["", "lemmas [code] = totient_code2"], ["", "value \"totient 125789726827482323235784\""], ["", "subsection \\<open>Divisor Functions\\<close>"], ["", "lemmas [code del] = divisor_count_naive divisor_sum_naive"], ["", "lemmas [code] = divisor_count.efficient_code' divisor_sum.efficient_code'"], ["", "value \"int (divisor_count 378568418621)\""], ["", "value \"int (divisor_sum 378568418621)\""], ["", "subsection \\<open>Liouville's $\\lambda$ function\\<close>"], ["", "lemma [code]: \"liouville_lambda n = \n  (if n = 0 then 0 else if even (length (prime_factorization_nat n)) then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liouville_lambda n =\n    (if n = 0 then 0::'a\n     else if even (length (prime_factorization_nat n)) then 1::'a\n          else - (1::'a))", "by (auto simp: liouville_lambda_def multiset_prime_factorization_nat_correct)"], ["", "value \"liouville_lambda 1264785343674 :: int\""], ["", "end"]]}