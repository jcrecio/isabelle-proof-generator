{"file_name": "/home/qj213/afp-2021-10-22/thys/Dirichlet_Series/Divisor_Count.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dirichlet_Series", "problem_names": ["lemma divisor_sigma_0 [simp]: \"divisor_sigma x 0 = 0\"", "lemma divisor_sigma_Suc_0 [simp]: \"divisor_sigma x (Suc 0) = 1\"", "lemma divisor_sigma_1 [simp]: \"divisor_sigma x 1 = 1\"", "lemma fds_divisor_sigma: \"fds (divisor_sigma x) = fds_zeta * fds_shift x fds_zeta\"", "lemma divisor_sigma_naive [code]:\n  \"divisor_sigma x n = (if n = 0 then 0 else fold_atLeastAtMost_nat\n        (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1 n 0)\"", "lemma divisor_sigma_of_nat: \"divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)\"", "lemma divisor_sigma_prime_power_field:\n  fixes x :: \"'a :: {field, nat_power}\"\n  assumes \"prime p\"\n  shows   \"divisor_sigma x (p ^ k) = \n             (if nat_power p x = 1 then of_nat (k + 1) else\n             (nat_power p x ^ Suc k - 1) / (nat_power p x - 1))\"", "lemma divisor_sigma_prime_power_nat:\n  assumes \"prime p\"\n  shows   \"divisor_sigma x (p ^ k) = (if x = 0 then Suc k else\n             (p ^ (x * Suc k) - 1) div (p ^ x - 1))\"", "lemma divisor_sigma_prime:\n  assumes \"prime p\"\n  shows   \"divisor_sigma x p = nat_power p x + 1\"", "lemma divisor_count_0 [simp]: \"divisor_count 0 = 0\"", "lemma divisor_count_Suc_0 [simp]: \"divisor_count (Suc 0) = 1\"", "lemma divisor_sigma_0_left_nat: \"divisor_sigma 0 n = divisor_count n\"", "lemma divisor_sigma_0_left: \"divisor_sigma 0 n = of_nat (divisor_count n)\"", "lemma divisor_count_altdef: \"divisor_count n = divisor_sigma 0 n\"", "lemma divisor_count_naive [code]:\n  \"divisor_count n = (if n = 0 then 0 else \n     fold_atLeastAtMost_nat (\\<lambda>d acc. if d dvd n then Suc acc else acc) 1 n 0)\"", "lemma divisor_count_dvd_mono:\n  assumes \"a dvd b\" \"b \\<noteq> 0\"\n  shows   \"divisor_count a \\<le> divisor_count b\"", "lemma divisor_sum_0 [simp]: \"divisor_sum 0 = 0\"", "lemma divisor_sum_Suc_0 [simp]: \"divisor_sum (Suc 0) = Suc 0\"", "lemma divisor_sigma_1_left_nat: \"divisor_sigma (Suc 0) n = divisor_sum n\"", "lemma divisor_sigma_1_left: \"divisor_sigma 1 n = of_nat (divisor_sum n)\"", "lemma divisor_sum_altdef: \"divisor_sum n = divisor_sigma 1 n\"", "lemma divisor_sum_dvd_mono:\n  assumes \"a dvd b\" \"b \\<noteq> 0\"\n  shows   \"divisor_sum a \\<le> divisor_sum b\"", "lemma divisor_sum_naive [code]:\n  \"divisor_sum n = (if n = 0 then 0 else \n     fold_atLeastAtMost_nat (\\<lambda>d acc. if d dvd n then d + acc else acc) 1 n 0)\"", "lemma fds_divisor_count: \"fds divisor_count = fds_zeta ^ 2\"", "lemma fds_shift_zeta_1: \"fds_shift 1 fds_zeta = fds of_nat\"", "lemma fds_shift_zeta_Suc_0: \"fds_shift (Suc 0) fds_zeta = fds id\"", "lemma fds_divisor_sum: \"fds divisor_sum = fds_zeta * fds id\"", "lemma fds_divisor_sum_eq_totient_times_d: \"fds divisor_sum = fds totient * fds divisor_count\"", "lemma fds_divisor_sum_times_moebius_mu: \n  \"fds (divisor_sigma (1 :: 'a :: {nat_power,comm_ring_1})) * fds moebius_mu = fds of_nat\"", "lemma inverse_divisor_sigma:\n  fixes a :: \"'a :: {field, nat_power}\"\n  shows \"inverse (fds (divisor_sigma a)) = fds_shift a (fds moebius_mu) * fds moebius_mu\""], "translations": [["", "lemma divisor_sigma_0 [simp]: \"divisor_sigma x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x 0 = (0::'a)", "by (simp add: divisor_sigma_def)"], ["", "lemma divisor_sigma_Suc_0 [simp]: \"divisor_sigma x (Suc 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x (Suc 0) = (1::'a)", "by (simp add: divisor_sigma_def)"], ["", "lemma divisor_sigma_1 [simp]: \"divisor_sigma x 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x 1 = (1::'a)", "by simp"], ["", "lemma fds_divisor_sigma: \"fds (divisor_sigma x) = fds_zeta * fds_shift x fds_zeta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (divisor_sigma x) = fds_zeta * fds_shift x fds_zeta", "by (rule fds_eqI) (simp add: fds_nth_mult dirichlet_prod_altdef1 divisor_sigma_def)"], ["", "interpretation divisor_sigma: multiplicative_function \"divisor_sigma x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function (divisor_sigma x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multiplicative_function (divisor_sigma x)", "have \"multiplicative_function (dirichlet_prod (\\<lambda>n. if n = 0 then 0 else 1) \n           (\\<lambda>n. if n = 0 then 0 else nat_power n x))\" (is \"multiplicative_function ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function\n     (dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n       (\\<lambda>n. if n = 0 then 0::'a else nat_power n x))", "by (rule multiplicative_dirichlet_prod; standard)\n       (simp_all add: nat_power_mult_distrib)"], ["proof (state)\nthis:\n  multiplicative_function\n   (dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n     (\\<lambda>n. if n = 0 then 0::'a else nat_power n x))\n\ngoal (1 subgoal):\n 1. multiplicative_function (divisor_sigma x)", "also"], ["proof (state)\nthis:\n  multiplicative_function\n   (dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n     (\\<lambda>n. if n = 0 then 0::'a else nat_power n x))\n\ngoal (1 subgoal):\n 1. multiplicative_function (divisor_sigma x)", "have \"?f n = divisor_sigma x n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n     (\\<lambda>n. if n = 0 then 0::'a else nat_power n x) n =\n    divisor_sigma x n", "using fds_divisor_sigma[of x]"], ["proof (prove)\nusing this:\n  fds (divisor_sigma x) = fds_zeta * fds_shift x fds_zeta\n\ngoal (1 subgoal):\n 1. dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n     (\\<lambda>n. if n = 0 then 0::'a else nat_power n x) n =\n    divisor_sigma x n", "by (cases \"n = 0\") (simp_all add: fds_eq_iff fds_nth_mult )"], ["proof (state)\nthis:\n  dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n   (\\<lambda>n. if n = 0 then 0::'a else nat_power n x) ?n =\n  divisor_sigma x ?n\n\ngoal (1 subgoal):\n 1. multiplicative_function (divisor_sigma x)", "hence \"?f = divisor_sigma x\""], ["proof (prove)\nusing this:\n  dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n   (\\<lambda>n. if n = 0 then 0::'a else nat_power n x) ?n =\n  divisor_sigma x ?n\n\ngoal (1 subgoal):\n 1. dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n     (\\<lambda>n. if n = 0 then 0::'a else nat_power n x) =\n    divisor_sigma x", ".."], ["proof (state)\nthis:\n  dirichlet_prod (\\<lambda>n. if n = 0 then 0::'a else (1::'a))\n   (\\<lambda>n. if n = 0 then 0::'a else nat_power n x) =\n  divisor_sigma x\n\ngoal (1 subgoal):\n 1. multiplicative_function (divisor_sigma x)", "finally"], ["proof (chain)\npicking this:\n  multiplicative_function (divisor_sigma x)", "show \"multiplicative_function (divisor_sigma x)\""], ["proof (prove)\nusing this:\n  multiplicative_function (divisor_sigma x)\n\ngoal (1 subgoal):\n 1. multiplicative_function (divisor_sigma x)", "."], ["proof (state)\nthis:\n  multiplicative_function (divisor_sigma x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma divisor_sigma_naive [code]:\n  \"divisor_sigma x n = (if n = 0 then 0 else fold_atLeastAtMost_nat\n        (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1 n 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "have \"divisor_sigma x n = (\\<Sum>d\\<in>{1..n}. if d dvd n then nat_power d x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x n =\n    (\\<Sum>d = 1..n. if d dvd n then nat_power d x else (0::'a))", "unfolding divisor_sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd n. nat_power d x) =\n    (\\<Sum>d = 1..n. if d dvd n then nat_power d x else (0::'a))", "using False"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd n. nat_power d x) =\n    (\\<Sum>d = 1..n. if d dvd n then nat_power d x else (0::'a))", "by (intro sum.mono_neutral_cong_left) (auto elim: dvdE)"], ["proof (state)\nthis:\n  divisor_sigma x n =\n  (\\<Sum>d = 1..n. if d dvd n then nat_power d x else (0::'a))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "also"], ["proof (state)\nthis:\n  divisor_sigma x n =\n  (\\<Sum>d = 1..n. if d dvd n then nat_power d x else (0::'a))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "have \"\\<dots> = fold_atLeastAtMost_nat\n        (\\<lambda>d acc. (if d dvd n then nat_power d x else 0) + acc) 1 n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d = 1..n. if d dvd n then nat_power d x else (0::'a)) =\n    fold_atLeastAtMost_nat\n     (\\<lambda>d. (+) (if d dvd n then nat_power d x else (0::'a))) 1 n\n     (0::'a)", "by (rule sum_atLeastAtMost_code)"], ["proof (state)\nthis:\n  (\\<Sum>d = 1..n. if d dvd n then nat_power d x else (0::'a)) =\n  fold_atLeastAtMost_nat\n   (\\<lambda>d. (+) (if d dvd n then nat_power d x else (0::'a))) 1 n\n   (0::'a)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "also"], ["proof (state)\nthis:\n  (\\<Sum>d = 1..n. if d dvd n then nat_power d x else (0::'a)) =\n  fold_atLeastAtMost_nat\n   (\\<lambda>d. (+) (if d dvd n then nat_power d x else (0::'a))) 1 n\n   (0::'a)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "have \"(\\<lambda>d acc. (if d dvd n then nat_power d x else 0) + acc) =\n               (\\<lambda>d acc. (if d dvd n then nat_power d x + acc else acc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>d. (+) (if d dvd n then nat_power d x else (0::'a))) =\n    (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc)", "by (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>d. (+) (if d dvd n then nat_power d x else (0::'a))) =\n  (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "finally"], ["proof (chain)\npicking this:\n  divisor_sigma x n =\n  fold_atLeastAtMost_nat\n   (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1 n\n   (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  divisor_sigma x n =\n  fold_atLeastAtMost_nat\n   (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1 n\n   (0::'a)\n\ngoal (1 subgoal):\n 1. divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "using False"], ["proof (prove)\nusing this:\n  divisor_sigma x n =\n  fold_atLeastAtMost_nat\n   (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1 n\n   (0::'a)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "by simp"], ["proof (state)\nthis:\n  divisor_sigma x n =\n  (if n = 0 then 0::'a\n   else fold_atLeastAtMost_nat\n         (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1 n\n         (0::'a))\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma x n =\n    (if n = 0 then 0::'a\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then nat_power d x + acc else acc) 1\n           n (0::'a))", "qed auto"], ["", "lemma divisor_sigma_of_nat: \"divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)", "unfolding divisor_sigma_def of_nat_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd n. nat_power d (of_nat x)) =\n    (\\<Sum>xa\\<in>{d. d dvd n}. of_nat (nat_power xa x))", "by (intro sum.cong refl, subst nat_power_of_nat) (insert False, auto elim: dvdE)"], ["proof (state)\nthis:\n  divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    divisor_sigma (of_nat x) n = of_nat (divisor_sigma x n)", "qed auto"], ["", "lemma divisor_sigma_prime_power_field:\n  fixes x :: \"'a :: {field, nat_power}\"\n  assumes \"prime p\"\n  shows   \"divisor_sigma x (p ^ k) = \n             (if nat_power p x = 1 then of_nat (k + 1) else\n             (nat_power p x ^ Suc k - 1) / (nat_power p x - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "have \"divisor_sigma x (p ^ k) = (\\<Sum>i\\<le>k. nat_power (p^i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) = (\\<Sum>i\\<le>k. nat_power (p ^ i) x)", "unfolding divisor_sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d | d dvd p ^ k. nat_power d x) =\n    (\\<Sum>i\\<le>k. nat_power (p ^ i) x)", "by (rule sum.reindex_bij_betw [symmetric])\n       (insert assms, auto simp: bij_betw_def inj_on_def prime_gt_Suc_0_nat \n          divides_primepow_nat intro: le_imp_power_dvd)"], ["proof (state)\nthis:\n  divisor_sigma x (p ^ k) = (\\<Sum>i\\<le>k. nat_power (p ^ i) x)\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "also"], ["proof (state)\nthis:\n  divisor_sigma x (p ^ k) = (\\<Sum>i\\<le>k. nat_power (p ^ i) x)\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "have \"\\<dots> = (\\<Sum>i\\<le>k. nat_power p x ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k. nat_power (p ^ i) x) = sum ((^) (nat_power p x)) {..k}", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k. nat_power (p ^ i) x) = sum ((^) (nat_power p x)) {..k}", "by (intro sum.cong refl) (simp_all add: prime_gt_0_nat nat_power_power_left)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k. nat_power (p ^ i) x) = sum ((^) (nat_power p x)) {..k}\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k. nat_power (p ^ i) x) = sum ((^) (nat_power p x)) {..k}\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "have \"\\<dots> = (if nat_power p x = 1 then of_nat (k + 1) else\n                    (nat_power p x ^ Suc k - 1) / (nat_power p x - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (nat_power p x)) {..k} =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "using geometric_sum[of \"nat_power p x\" \"Suc k\"]"], ["proof (prove)\nusing this:\n  nat_power p x \\<noteq> (1::'a) \\<Longrightarrow>\n  sum ((^) (nat_power p x)) {..<Suc k} =\n  (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a))\n\ngoal (1 subgoal):\n 1. sum ((^) (nat_power p x)) {..k} =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "unfolding lessThan_Suc_atMost"], ["proof (prove)\nusing this:\n  nat_power p x \\<noteq> (1::'a) \\<Longrightarrow>\n  sum ((^) (nat_power p x)) {..k} =\n  (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a))\n\ngoal (1 subgoal):\n 1. sum ((^) (nat_power p x)) {..k} =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  sum ((^) (nat_power p x)) {..k} =\n  (if nat_power p x = (1::'a) then of_nat (k + 1)\n   else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "finally"], ["proof (chain)\npicking this:\n  divisor_sigma x (p ^ k) =\n  (if nat_power p x = (1::'a) then of_nat (k + 1)\n   else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "show ?thesis"], ["proof (prove)\nusing this:\n  divisor_sigma x (p ^ k) =\n  (if nat_power p x = (1::'a) then of_nat (k + 1)\n   else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if nat_power p x = (1::'a) then of_nat (k + 1)\n     else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))", "."], ["proof (state)\nthis:\n  divisor_sigma x (p ^ k) =\n  (if nat_power p x = (1::'a) then of_nat (k + 1)\n   else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma divisor_sigma_prime_power_nat:\n  assumes \"prime p\"\n  shows   \"divisor_sigma x (p ^ k) = (if x = 0 then Suc k else\n             (p ^ (x * Suc k) - 1) div (p ^ x - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "with assms"], ["proof (chain)\npicking this:\n  prime p\n  x = 0", "have \"nat_power p (real x) = 1\""], ["proof (prove)\nusing this:\n  prime p\n  x = 0\n\ngoal (1 subgoal):\n 1. nat_power p (real x) = 1", "by simp"], ["proof (state)\nthis:\n  nat_power p (real x) = 1\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "hence \"divisor_sigma (real x) (p ^ k) = real (Suc k)\""], ["proof (prove)\nusing this:\n  nat_power p (real x) = 1\n\ngoal (1 subgoal):\n 1. divisor_sigma (real x) (p ^ k) = real (Suc k)", "by (subst divisor_sigma_prime_power_field) (simp_all del: nat_power_real_def add: assms)"], ["proof (state)\nthis:\n  divisor_sigma (real x) (p ^ k) = real (Suc k)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  divisor_sigma (real x) (p ^ k) = real (Suc k)\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "unfolding divisor_sigma_of_nat"], ["proof (prove)\nusing this:\n  real (divisor_sigma x (p ^ k)) = real (Suc k)\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "by (subst (asm) of_nat_eq_iff) (insert True, simp)"], ["proof (state)\nthis:\n  divisor_sigma x (p ^ k) =\n  (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "with assms"], ["proof (chain)\npicking this:\n  prime p\n  x \\<noteq> 0", "have gt_1: \"p ^ x > 1\""], ["proof (prove)\nusing this:\n  prime p\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < p ^ x", "using power_gt1[of p \"x - 1\"]"], ["proof (prove)\nusing this:\n  prime p\n  x \\<noteq> 0\n  1 < p \\<Longrightarrow> 1 < p ^ Suc (x - 1)\n\ngoal (1 subgoal):\n 1. 1 < p ^ x", "by (simp add: prime_gt_Suc_0_nat)"], ["proof (state)\nthis:\n  1 < p ^ x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "hence not_one: \"real p ^ x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  1 < p ^ x\n\ngoal (1 subgoal):\n 1. real p ^ x \\<noteq> 1", "unfolding of_nat_power [symmetric] of_nat_eq_1_iff"], ["proof (prove)\nusing this:\n  1 < p ^ x\n\ngoal (1 subgoal):\n 1. p ^ x \\<noteq> 1", "by (intro notI) simp"], ["proof (state)\nthis:\n  real p ^ x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "from gt_1"], ["proof (chain)\npicking this:\n  1 < p ^ x", "have dvd: \"p ^ x - 1 dvd p ^ (x * Suc k) - 1\""], ["proof (prove)\nusing this:\n  1 < p ^ x\n\ngoal (1 subgoal):\n 1. p ^ x - 1 dvd p ^ (x * Suc k) - 1", "using geometric_sum_nat_dvd[of \"p ^ x\" \"Suc k\"] assms"], ["proof (prove)\nusing this:\n  1 < p ^ x\n  \\<lbrakk>1 < p ^ x; 0 < Suc k\\<rbrakk>\n  \\<Longrightarrow> p ^ x - 1 dvd (p ^ x) ^ Suc k - 1\n  prime p\n\ngoal (1 subgoal):\n 1. p ^ x - 1 dvd p ^ (x * Suc k) - 1", "by (simp add: power_mult prime_gt_Suc_0_nat power_add)"], ["proof (state)\nthis:\n  p ^ x - 1 dvd p ^ (x * Suc k) - 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "have \"divisor_sigma (real x) (p ^ k) =\n          real (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma (real x) (p ^ k) =\n    real (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "by (subst divisor_sigma_prime_power_field [OF assms, where 'a = real])\n       (insert assms False dvd not_one, auto simp del: power_Suc nat_power_real_def \n        simp: prime_gt_0_nat real_of_nat_div of_nat_diff prime_ge_Suc_0_nat power_mult [symmetric])"], ["proof (state)\nthis:\n  divisor_sigma (real x) (p ^ k) =\n  real (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  divisor_sigma (real x) (p ^ k) =\n  real (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "unfolding divisor_sigma_of_nat"], ["proof (prove)\nusing this:\n  real (divisor_sigma x (p ^ k)) =\n  real (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))", "by (subst (asm) of_nat_eq_iff)"], ["proof (state)\nthis:\n  divisor_sigma x (p ^ k) =\n  (if x = 0 then Suc k else (p ^ (x * Suc k) - 1) div (p ^ x - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation divisor_sigma_field: \n  multiplicative_function' \"divisor_sigma (x :: 'a :: {field, nat_power})\"\n    \"\\<lambda>p k. if nat_power p x = 1 then of_nat (Suc k) else \n        (nat_power p x ^ Suc k - 1) / (nat_power p x - 1)\"\n    \"\\<lambda>p. nat_power p x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function' (divisor_sigma x)\n     (\\<lambda>p k.\n         if nat_power p x = (1::'a) then of_nat (Suc k)\n         else (nat_power p x ^ Suc k - (1::'a)) / (nat_power p x - (1::'a)))\n     (\\<lambda>p. nat_power p x + (1::'a))", "by standard (auto simp: divisor_sigma_prime_power_field prime_gt_0_nat field_simps)"], ["", "interpretation divisor_sigma_real: \n  multiplicative_function' \"divisor_sigma (x :: real)\"\n    \"\\<lambda>p k. if x = 0 then of_nat (Suc k) else ((real p powr x) ^ Suc k - 1) / (real p powr x - 1)\"\n    \"\\<lambda>p. real p powr x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function' (divisor_sigma x)\n     (\\<lambda>p k.\n         if x = 0 then real (Suc k)\n         else ((real p powr x) ^ Suc k - 1) / (real p powr x - 1))\n     (\\<lambda>p. real p powr x + 1)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sigma x (p ^ k) =\n                         (if x = 0 then real (Suc k)\n                          else ((real p powr x) ^ Suc k - 1) /\n                               (real p powr x - 1))\n 2. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then real (Suc 1)\n        else ((real p powr x) ^ Suc 1 - 1) / (real p powr x - 1)) =\n       real p powr x + 1", "case (1 p k)"], ["proof (state)\nthis:\n  prime p\n  0 < k\n\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sigma x (p ^ k) =\n                         (if x = 0 then real (Suc k)\n                          else ((real p powr x) ^ Suc k - 1) /\n                               (real p powr x - 1))\n 2. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then real (Suc 1)\n        else ((real p powr x) ^ Suc 1 - 1) / (real p powr x - 1)) =\n       real p powr x + 1", "thus ?case"], ["proof (prove)\nusing this:\n  prime p\n  0 < k\n\ngoal (1 subgoal):\n 1. divisor_sigma x (p ^ k) =\n    (if x = 0 then real (Suc k)\n     else ((real p powr x) ^ Suc k - 1) / (real p powr x - 1))", "by (auto simp: divisor_sigma_prime_power_field prime_gt_0_nat powr_def of_nat_eq_1_iff\n                   exp_of_nat_mult [symmetric] mult_ac simp del: of_nat_Suc power_Suc)"], ["proof (state)\nthis:\n  divisor_sigma x (p ^ k) =\n  (if x = 0 then real (Suc k)\n   else ((real p powr x) ^ Suc k - 1) / (real p powr x - 1))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then real (Suc 1)\n        else ((real p powr x) ^ Suc 1 - 1) / (real p powr x - 1)) =\n       real p powr x + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then real (Suc 1)\n        else ((real p powr x) ^ Suc 1 - 1) / (real p powr x - 1)) =\n       real p powr x + 1", "case (2 p)"], ["proof (state)\nthis:\n  prime p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then real (Suc 1)\n        else ((real p powr x) ^ Suc 1 - 1) / (real p powr x - 1)) =\n       real p powr x + 1", "hence \"real p powr x \\<noteq> 1\" if \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. real p powr x \\<noteq> 1", "by (auto simp: powr_def that prime_gt_0_nat of_nat_eq_1_iff)"], ["proof (state)\nthis:\n  x \\<noteq> 0 \\<Longrightarrow> real p powr x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then real (Suc 1)\n        else ((real p powr x) ^ Suc 1 - 1) / (real p powr x - 1)) =\n       real p powr x + 1", "with 2"], ["proof (chain)\npicking this:\n  prime p\n  x \\<noteq> 0 \\<Longrightarrow> real p powr x \\<noteq> 1", "show ?case"], ["proof (prove)\nusing this:\n  prime p\n  x \\<noteq> 0 \\<Longrightarrow> real p powr x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (if x = 0 then real (Suc 1)\n     else ((real p powr x) ^ Suc 1 - 1) / (real p powr x - 1)) =\n    real p powr x + 1", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (if x = 0 then real (Suc 1)\n   else ((real p powr x) ^ Suc 1 - 1) / (real p powr x - 1)) =\n  real p powr x + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation divisor_sigma_nat: \n  multiplicative_function' \"divisor_sigma (x :: nat)\"\n    \"\\<lambda>p k. if x = 0 then Suc k else (p ^ (Suc k * x) - 1) div (p ^ x - 1)\"\n    \"\\<lambda>p. p ^ x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function' (divisor_sigma x)\n     (\\<lambda>p k.\n         if x = 0 then Suc k else (p ^ (Suc k * x) - 1) div (p ^ x - 1))\n     (\\<lambda>p. p ^ x + 1)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sigma x (p ^ k) =\n                         (if x = 0 then Suc k\n                          else (p ^ (Suc k * x) - 1) div (p ^ x - 1))\n 2. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then Suc 1 else (p ^ (Suc 1 * x) - 1) div (p ^ x - 1)) =\n       p ^ x + 1", "case (2 p)"], ["proof (state)\nthis:\n  prime p\n\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sigma x (p ^ k) =\n                         (if x = 0 then Suc k\n                          else (p ^ (Suc k * x) - 1) div (p ^ x - 1))\n 2. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then Suc 1 else (p ^ (Suc 1 * x) - 1) div (p ^ x - 1)) =\n       p ^ x + 1", "have \"(p ^ (x + x) - 1) = (p ^ x + 1) * (p ^ x - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ (x + x) - 1 = (p ^ x + 1) * (p ^ x - 1)", "by (simp add: algebra_simps power_add)"], ["proof (state)\nthis:\n  p ^ (x + x) - 1 = (p ^ x + 1) * (p ^ x - 1)\n\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sigma x (p ^ k) =\n                         (if x = 0 then Suc k\n                          else (p ^ (Suc k * x) - 1) div (p ^ x - 1))\n 2. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then Suc 1 else (p ^ (Suc 1 * x) - 1) div (p ^ x - 1)) =\n       p ^ x + 1", "moreover"], ["proof (state)\nthis:\n  p ^ (x + x) - 1 = (p ^ x + 1) * (p ^ x - 1)\n\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sigma x (p ^ k) =\n                         (if x = 0 then Suc k\n                          else (p ^ (Suc k * x) - 1) div (p ^ x - 1))\n 2. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then Suc 1 else (p ^ (Suc 1 * x) - 1) div (p ^ x - 1)) =\n       p ^ x + 1", "have \"p ^ x > 1\" if \"x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < p ^ x", "using that 2 one_less_power prime_gt_1_nat"], ["proof (prove)\nusing this:\n  0 < x\n  prime p\n  \\<lbrakk>(1::?'a) < ?a; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> (1::?'a) < ?a ^ ?n\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. 1 < p ^ x", "by blast"], ["proof (state)\nthis:\n  0 < x \\<Longrightarrow> 1 < p ^ x\n\ngoal (2 subgoals):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sigma x (p ^ k) =\n                         (if x = 0 then Suc k\n                          else (p ^ (Suc k * x) - 1) div (p ^ x - 1))\n 2. \\<And>p.\n       prime p \\<Longrightarrow>\n       (if x = 0 then Suc 1 else (p ^ (Suc 1 * x) - 1) div (p ^ x - 1)) =\n       p ^ x + 1", "ultimately"], ["proof (chain)\npicking this:\n  p ^ (x + x) - 1 = (p ^ x + 1) * (p ^ x - 1)\n  0 < x \\<Longrightarrow> 1 < p ^ x", "show ?case"], ["proof (prove)\nusing this:\n  p ^ (x + x) - 1 = (p ^ x + 1) * (p ^ x - 1)\n  0 < x \\<Longrightarrow> 1 < p ^ x\n\ngoal (1 subgoal):\n 1. (if x = 0 then Suc 1 else (p ^ (Suc 1 * x) - 1) div (p ^ x - 1)) =\n    p ^ x + 1", "using prime_ge_Suc_0_nat[of p]"], ["proof (prove)\nusing this:\n  p ^ (x + x) - 1 = (p ^ x + 1) * (p ^ x - 1)\n  0 < x \\<Longrightarrow> 1 < p ^ x\n  prime p \\<Longrightarrow> Suc 0 \\<le> p\n\ngoal (1 subgoal):\n 1. (if x = 0 then Suc 1 else (p ^ (Suc 1 * x) - 1) div (p ^ x - 1)) =\n    p ^ x + 1", "by auto"], ["proof (state)\nthis:\n  (if x = 0 then Suc 1 else (p ^ (Suc 1 * x) - 1) div (p ^ x - 1)) =\n  p ^ x + 1\n\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sigma x (p ^ k) =\n                         (if x = 0 then Suc k\n                          else (p ^ (Suc k * x) - 1) div (p ^ x - 1))", "qed (auto simp: divisor_sigma_prime_power_nat mult_ac)"], ["", "lemma divisor_sigma_prime:\n  assumes \"prime p\"\n  shows   \"divisor_sigma x p = nat_power p x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x p = nat_power p x + (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. divisor_sigma x p = nat_power p x + (1::'a)", "have \"divisor_sigma x p = (\\<Sum>d | d dvd p. nat_power d x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma x p = (\\<Sum>d | d dvd p. nat_power d x)", "by (simp add: divisor_sigma_def)"], ["proof (state)\nthis:\n  divisor_sigma x p = (\\<Sum>d | d dvd p. nat_power d x)\n\ngoal (1 subgoal):\n 1. divisor_sigma x p = nat_power p x + (1::'a)", "also"], ["proof (state)\nthis:\n  divisor_sigma x p = (\\<Sum>d | d dvd p. nat_power d x)\n\ngoal (1 subgoal):\n 1. divisor_sigma x p = nat_power p x + (1::'a)", "from assms"], ["proof (chain)\npicking this:\n  prime p", "have \"{d. d dvd p} = {1, p}\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. {d. d dvd p} = {1, p}", "by (auto simp: prime_nat_iff)"], ["proof (state)\nthis:\n  {d. d dvd p} = {1, p}\n\ngoal (1 subgoal):\n 1. divisor_sigma x p = nat_power p x + (1::'a)", "also"], ["proof (state)\nthis:\n  {d. d dvd p} = {1, p}\n\ngoal (1 subgoal):\n 1. divisor_sigma x p = nat_power p x + (1::'a)", "have \"(\\<Sum>d\\<in>\\<dots>. nat_power d x) = nat_power p x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>{1, p}. nat_power d x) = nat_power p x + (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>{1, p}. nat_power d x) = nat_power p x + (1::'a)", "by (subst sum.insert) (auto simp: add_ac)"], ["proof (state)\nthis:\n  (\\<Sum>d\\<in>{1, p}. nat_power d x) = nat_power p x + (1::'a)\n\ngoal (1 subgoal):\n 1. divisor_sigma x p = nat_power p x + (1::'a)", "finally"], ["proof (chain)\npicking this:\n  divisor_sigma x p = nat_power p x + (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  divisor_sigma x p = nat_power p x + (1::'a)\n\ngoal (1 subgoal):\n 1. divisor_sigma x p = nat_power p x + (1::'a)", "."], ["proof (state)\nthis:\n  divisor_sigma x p = nat_power p x + (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The divisor-counting function\\<close>"], ["", "definition divisor_count :: \"nat \\<Rightarrow> nat\" where\n  \"divisor_count n = card {d. d dvd n}\""], ["", "lemma divisor_count_0 [simp]: \"divisor_count 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_count 0 = 0", "by (simp add: divisor_count_def)"], ["", "lemma divisor_count_Suc_0 [simp]: \"divisor_count (Suc 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_count (Suc 0) = 1", "by (simp add: divisor_count_def)"], ["", "lemma divisor_sigma_0_left_nat: \"divisor_sigma 0 n = divisor_count n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma 0 n = divisor_count n", "by (simp add: divisor_sigma_def divisor_count_def)"], ["", "lemma divisor_sigma_0_left: \"divisor_sigma 0 n = of_nat (divisor_count n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma (0::'a) n = of_nat (divisor_count n)", "unfolding divisor_sigma_0_left_nat [symmetric] divisor_sigma_of_nat [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma (0::'a) n = divisor_sigma (of_nat 0) n", "by simp"], ["", "lemma divisor_count_altdef: \"divisor_count n = divisor_sigma 0 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_count n = divisor_sigma 0 n", "by (simp add: divisor_sigma_0_left)"], ["", "lemma divisor_count_naive [code]:\n  \"divisor_count n = (if n = 0 then 0 else \n     fold_atLeastAtMost_nat (\\<lambda>d acc. if d dvd n then Suc acc else acc) 1 n 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_count n =\n    (if n = 0 then 0\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then Suc acc else acc) 1 n 0)", "using divisor_sigma_naive[of \"0 :: nat\" n]"], ["proof (prove)\nusing this:\n  divisor_sigma 0 n =\n  (if n = 0 then 0\n   else fold_atLeastAtMost_nat\n         (\\<lambda>d acc. if d dvd n then nat_power d 0 + acc else acc) 1 n\n         0)\n\ngoal (1 subgoal):\n 1. divisor_count n =\n    (if n = 0 then 0\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then Suc acc else acc) 1 n 0)", "by (simp split: if_splits add: divisor_count_altdef cong: if_cong)"], ["", "interpretation divisor_count: multiplicative_function' divisor_count \"\\<lambda>p k. Suc k\" \"\\<lambda>_. 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function' divisor_count (\\<lambda>p. Suc) (\\<lambda>_. 2)", "by standard (simp_all add: divisor_count_altdef divisor_sigma.mult_coprime\n                             divisor_sigma_nat.prime_power)"], ["", "lemma divisor_count_dvd_mono:\n  assumes \"a dvd b\" \"b \\<noteq> 0\"\n  shows   \"divisor_count a \\<le> divisor_count b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_count a \\<le> divisor_count b", "using assms"], ["proof (prove)\nusing this:\n  a dvd b\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. divisor_count a \\<le> divisor_count b", "by (auto simp: divisor_count_def intro!: card_mono intro: dvd_trans)"], ["", "subsection \\<open>The divisor sum function\\<close>"], ["", "definition divisor_sum :: \"nat \\<Rightarrow> nat\" where\n  \"divisor_sum n = \\<Sum>{d. d dvd n}\""], ["", "lemma divisor_sum_0 [simp]: \"divisor_sum 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sum 0 = 0", "by (simp add: divisor_sum_def)"], ["", "lemma divisor_sum_Suc_0 [simp]: \"divisor_sum (Suc 0) = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sum (Suc 0) = Suc 0", "by (simp add: divisor_sum_def)"], ["", "lemma divisor_sigma_1_left_nat: \"divisor_sigma (Suc 0) n = divisor_sum n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma (Suc 0) n = divisor_sum n", "by (simp add: divisor_sum_def divisor_sigma_def)"], ["", "lemma divisor_sigma_1_left: \"divisor_sigma 1 n = of_nat (divisor_sum n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sigma (1::'a) n = of_nat (divisor_sum n)", "by (simp add: divisor_sum_def divisor_sigma_def)"], ["", "lemma divisor_sum_altdef: \"divisor_sum n = divisor_sigma 1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sum n = divisor_sigma 1 n", "by (simp add: divisor_sigma_1_left_nat)"], ["", "interpretation divisor_sum: \n  multiplicative_function' divisor_sum \"\\<lambda>p k. (p ^ Suc k - 1) div (p - 1)\" \"\\<lambda>p. Suc p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicative_function' divisor_sum\n     (\\<lambda>p k. (p ^ Suc k - 1) div (p - 1)) Suc", "proof (standard, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. divisor_sum 0 = 0\n 2. divisor_sum 1 = 1\n 3. \\<And>a b.\n       \\<lbrakk>1 < a; 1 < b; coprime a b\\<rbrakk>\n       \\<Longrightarrow> divisor_sum (a * b) = divisor_sum a * divisor_sum b\n 4. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sum (p ^ k) = (p ^ Suc k - 1) div (p - 1)\n 5. \\<And>p. prime p \\<Longrightarrow> (p ^ Suc 1 - 1) div (p - 1) = Suc p", "case (5 p)"], ["proof (state)\nthis:\n  prime p\n\ngoal (5 subgoals):\n 1. divisor_sum 0 = 0\n 2. divisor_sum 1 = 1\n 3. \\<And>a b.\n       \\<lbrakk>1 < a; 1 < b; coprime a b\\<rbrakk>\n       \\<Longrightarrow> divisor_sum (a * b) = divisor_sum a * divisor_sum b\n 4. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sum (p ^ k) = (p ^ Suc k - 1) div (p - 1)\n 5. \\<And>p. prime p \\<Longrightarrow> (p ^ Suc 1 - 1) div (p - 1) = Suc p", "thus ?case"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. (p ^ Suc 1 - 1) div (p - 1) = Suc p", "using divisor_sigma_nat.prime_aux[of p 1]"], ["proof (prove)\nusing this:\n  prime p\n  prime p \\<Longrightarrow>\n  (if 1 = 0 then Suc 1 else (p ^ (Suc 1 * 1) - 1) div (p ^ 1 - 1)) =\n  p ^ 1 + 1\n\ngoal (1 subgoal):\n 1. (p ^ Suc 1 - 1) div (p - 1) = Suc p", "by (simp_all add: divisor_sum_altdef)"], ["proof (state)\nthis:\n  (p ^ Suc 1 - 1) div (p - 1) = Suc p\n\ngoal (4 subgoals):\n 1. divisor_sum 0 = 0\n 2. divisor_sum 1 = 1\n 3. \\<And>a b.\n       \\<lbrakk>1 < a; 1 < b; coprime a b\\<rbrakk>\n       \\<Longrightarrow> divisor_sum (a * b) = divisor_sum a * divisor_sum b\n 4. \\<And>p k.\n       \\<lbrakk>prime p; 0 < k\\<rbrakk>\n       \\<Longrightarrow> divisor_sum (p ^ k) = (p ^ Suc k - 1) div (p - 1)", "qed (simp_all add: divisor_sum_altdef divisor_sigma_nat.prime_power divisor_sigma.mult_coprime)"], ["", "lemma divisor_sum_dvd_mono:\n  assumes \"a dvd b\" \"b \\<noteq> 0\"\n  shows   \"divisor_sum a \\<le> divisor_sum b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sum a \\<le> divisor_sum b", "using assms"], ["proof (prove)\nusing this:\n  a dvd b\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. divisor_sum a \\<le> divisor_sum b", "by (cases \"a = 0\") (auto simp: divisor_sum_def intro!: sum_le_included intro: dvd_trans)"], ["", "lemma divisor_sum_naive [code]:\n  \"divisor_sum n = (if n = 0 then 0 else \n     fold_atLeastAtMost_nat (\\<lambda>d acc. if d dvd n then d + acc else acc) 1 n 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisor_sum n =\n    (if n = 0 then 0\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then d + acc else acc) 1 n 0)", "using divisor_sigma_naive[of \"Suc 0\" n]"], ["proof (prove)\nusing this:\n  divisor_sigma (Suc 0) n =\n  (if n = 0 then 0\n   else fold_atLeastAtMost_nat\n         (\\<lambda>d acc.\n             if d dvd n then nat_power d (Suc 0) + acc else acc)\n         1 n 0)\n\ngoal (1 subgoal):\n 1. divisor_sum n =\n    (if n = 0 then 0\n     else fold_atLeastAtMost_nat\n           (\\<lambda>d acc. if d dvd n then d + acc else acc) 1 n 0)", "by (simp split: if_splits add: divisor_sum_altdef cong: if_cong)"], ["", "lemma fds_divisor_count: \"fds divisor_count = fds_zeta ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds divisor_count = fds_zeta\\<^sup>2", "by (rule fds_eqI) \n     (simp add: fds_nth_mult dirichlet_prod_altdef1 divisor_count_def power2_eq_square)"], ["", "lemma fds_shift_zeta_1: \"fds_shift 1 fds_zeta = fds of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_shift (1::'a) fds_zeta = fds of_nat", "by (rule fds_eqI) (simp add: fds_nth_mult)"], ["", "lemma fds_shift_zeta_Suc_0: \"fds_shift (Suc 0) fds_zeta = fds id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_shift (Suc 0) fds_zeta = fds id", "by (rule fds_eqI) (simp add: fds_nth_mult)"], ["", "lemma fds_divisor_sum: \"fds divisor_sum = fds_zeta * fds id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds divisor_sum = fds_zeta * fds id", "by (rule fds_eqI) (simp add: fds_nth_mult dirichlet_prod_altdef1 divisor_sum_def)"], ["", "lemma fds_divisor_sum_eq_totient_times_d: \"fds divisor_sum = fds totient * fds divisor_count\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds divisor_sum = fds totient * fds divisor_count", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fds divisor_sum = fds totient * fds divisor_count", "have \"fds divisor_sum = fds_zeta * fds id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds divisor_sum = fds_zeta * fds id", "by (fact fds_divisor_sum)"], ["proof (state)\nthis:\n  fds divisor_sum = fds_zeta * fds id\n\ngoal (1 subgoal):\n 1. fds divisor_sum = fds totient * fds divisor_count", "also"], ["proof (state)\nthis:\n  fds divisor_sum = fds_zeta * fds id\n\ngoal (1 subgoal):\n 1. fds divisor_sum = fds totient * fds divisor_count", "have \"fds id = fds totient * fds_zeta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds id = fds totient * fds_zeta", "by (rule fds_totient_times_zeta' [symmetric])"], ["proof (state)\nthis:\n  fds id = fds totient * fds_zeta\n\ngoal (1 subgoal):\n 1. fds divisor_sum = fds totient * fds divisor_count", "also"], ["proof (state)\nthis:\n  fds id = fds totient * fds_zeta\n\ngoal (1 subgoal):\n 1. fds divisor_sum = fds totient * fds divisor_count", "have \"fds_zeta * \\<dots> = fds totient * fds divisor_count\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_zeta * (fds totient * fds_zeta) = fds totient * fds divisor_count", "using fds_divisor_count"], ["proof (prove)\nusing this:\n  fds divisor_count = fds_zeta\\<^sup>2\n\ngoal (1 subgoal):\n 1. fds_zeta * (fds totient * fds_zeta) = fds totient * fds divisor_count", "by (simp add: power2_eq_square mult_ac)"], ["proof (state)\nthis:\n  fds_zeta * (fds totient * fds_zeta) = fds totient * fds divisor_count\n\ngoal (1 subgoal):\n 1. fds divisor_sum = fds totient * fds divisor_count", "finally"], ["proof (chain)\npicking this:\n  fds divisor_sum = fds totient * fds divisor_count", "show ?thesis"], ["proof (prove)\nusing this:\n  fds divisor_sum = fds totient * fds divisor_count\n\ngoal (1 subgoal):\n 1. fds divisor_sum = fds totient * fds divisor_count", "."], ["proof (state)\nthis:\n  fds divisor_sum = fds totient * fds divisor_count\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fds_divisor_sum_times_moebius_mu: \n  \"fds (divisor_sigma (1 :: 'a :: {nat_power,comm_ring_1})) * fds moebius_mu = fds of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat", "have \"fds (divisor_sigma 1) * fds moebius_mu = \n          fds of_nat * (fds_zeta * fds moebius_mu :: 'a fds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (divisor_sigma (1::'a)) * fds moebius_mu =\n    fds of_nat * (fds_zeta * fds moebius_mu)", "by (subst mult.assoc [symmetric], subst fds_zeta_commutes [symmetric]) \n       (simp add: fds_divisor_sigma fds_shift_zeta_1)"], ["proof (state)\nthis:\n  fds (divisor_sigma (1::'a)) * fds moebius_mu =\n  fds of_nat * (fds_zeta * fds moebius_mu)\n\ngoal (1 subgoal):\n 1. fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat", "also"], ["proof (state)\nthis:\n  fds (divisor_sigma (1::'a)) * fds moebius_mu =\n  fds of_nat * (fds_zeta * fds moebius_mu)\n\ngoal (1 subgoal):\n 1. fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat", "have \"fds_zeta * fds moebius_mu = (1 :: 'a fds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_zeta * fds moebius_mu = 1", "by (fact fds_zeta_times_moebius_mu)"], ["proof (state)\nthis:\n  fds_zeta * fds moebius_mu = 1\n\ngoal (1 subgoal):\n 1. fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat", "finally"], ["proof (chain)\npicking this:\n  fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat * 1", "show ?thesis"], ["proof (prove)\nusing this:\n  fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat * 1\n\ngoal (1 subgoal):\n 1. fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat", "by simp"], ["proof (state)\nthis:\n  fds (divisor_sigma (1::'a)) * fds moebius_mu = fds of_nat\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Theorem 2.20 *)"], ["", "lemma inverse_divisor_sigma:\n  fixes a :: \"'a :: {field, nat_power}\"\n  shows \"inverse (fds (divisor_sigma a)) = fds_shift a (fds moebius_mu) * fds moebius_mu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "have \"fds (divisor_sigma a) = fds_zeta * fds_shift a fds_zeta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (divisor_sigma a) = fds_zeta * fds_shift a fds_zeta", "by (simp add: fds_divisor_sigma)"], ["proof (state)\nthis:\n  fds (divisor_sigma a) = fds_zeta * fds_shift a fds_zeta\n\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "also"], ["proof (state)\nthis:\n  fds (divisor_sigma a) = fds_zeta * fds_shift a fds_zeta\n\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "have \"inverse \\<dots> = fds moebius_mu * inverse (fds_shift a fds_zeta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (fds_zeta * fds_shift a fds_zeta) =\n    fds moebius_mu * inverse (fds_shift a fds_zeta)", "by (simp add: fds_moebius_inverse_zeta inverse_mult_fds)"], ["proof (state)\nthis:\n  inverse (fds_zeta * fds_shift a fds_zeta) =\n  fds moebius_mu * inverse (fds_shift a fds_zeta)\n\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "also"], ["proof (state)\nthis:\n  inverse (fds_zeta * fds_shift a fds_zeta) =\n  fds moebius_mu * inverse (fds_shift a fds_zeta)\n\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "have \"inverse (fds_shift a fds_zeta) =\n               fds (\\<lambda>n. moebius_mu n * fds_nth (fds_shift a fds_zeta) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (fds_shift a fds_zeta) =\n    fds (\\<lambda>n. moebius_mu n * fds_nth (fds_shift a fds_zeta) n)", "by (intro completely_multiplicative_fds_inverse', unfold_locales)\n       (auto simp: nat_power_mult_distrib)"], ["proof (state)\nthis:\n  inverse (fds_shift a fds_zeta) =\n  fds (\\<lambda>n. moebius_mu n * fds_nth (fds_shift a fds_zeta) n)\n\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "also"], ["proof (state)\nthis:\n  inverse (fds_shift a fds_zeta) =\n  fds (\\<lambda>n. moebius_mu n * fds_nth (fds_shift a fds_zeta) n)\n\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "have \"\\<dots> = fds_shift a (fds moebius_mu)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds (\\<lambda>n. moebius_mu n * fds_nth (fds_shift a fds_zeta) n) =\n    fds_shift a (fds moebius_mu)", "by (auto simp: fds_eq_iff)"], ["proof (state)\nthis:\n  fds (\\<lambda>n. moebius_mu n * fds_nth (fds_shift a fds_zeta) n) =\n  fds_shift a (fds moebius_mu)\n\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "finally"], ["proof (chain)\npicking this:\n  inverse (fds (divisor_sigma a)) =\n  fds moebius_mu * fds_shift a (fds moebius_mu)", "show ?thesis"], ["proof (prove)\nusing this:\n  inverse (fds (divisor_sigma a)) =\n  fds moebius_mu * fds_shift a (fds moebius_mu)\n\ngoal (1 subgoal):\n 1. inverse (fds (divisor_sigma a)) =\n    fds_shift a (fds moebius_mu) * fds moebius_mu", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  inverse (fds (divisor_sigma a)) =\n  fds_shift a (fds moebius_mu) * fds moebius_mu\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}