{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/Common_Primitive_Matcher.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma packet_independent_\\<beta>_unknown_common_matcher: \"packet_independent_\\<beta>_unknown common_matcher\"", "lemma primitive_matcher_generic_common_matcher: \"primitive_matcher_generic common_matcher\"", "lemma \"\\<not> matches (common_matcher, \\<alpha>) (MatchNot (Match (Src_Ports (L4Ports TCP [(0,65535)])))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=2065, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\"", "lemma \"matches (common_matcher, \\<alpha>) (MatchNot (Match (Src_Ports (L4Ports any [])))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=2065, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\"", "lemma \"matches (common_matcher, \\<alpha>) (Match (Src_Ports (L4Ports TCP [(1024,4096), (9999, 65535)]))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=2065, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\"\n        \"\\<not> matches (common_matcher, \\<alpha>) (Match (Src_Ports (L4Ports TCP [(1024,4096), (9999, 65535)]))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=5000, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\"\n        \"\\<not>matches (common_matcher, \\<alpha>) (MatchNot (Match (Src_Ports (L4Ports TCP [(1024,4096), (9999, 65535)])))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=2065, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\"", "lemma common_matcher_SrcDst_defined:\n  \"common_matcher (Src m) p \\<noteq> TernaryUnknown\"\n  \"common_matcher (Dst m) p \\<noteq> TernaryUnknown\"\n  \"common_matcher (Src_Ports ps) p \\<noteq> TernaryUnknown\"\n  \"common_matcher (Dst_Ports ps) p \\<noteq> TernaryUnknown\"\n  \"common_matcher (MultiportPorts ps) p \\<noteq> TernaryUnknown\"", "lemma common_matcher_SrcDst_defined_simp:\n  \"common_matcher (Src x) p \\<noteq> TernaryFalse \\<longleftrightarrow> common_matcher (Src x) p = TernaryTrue\"\n  \"common_matcher (Dst x) p \\<noteq> TernaryFalse \\<longleftrightarrow> common_matcher (Dst x) p = TernaryTrue\"", "lemma match_simplematcher_SrcDst:\n  \"matches (common_matcher, \\<alpha>) (Match (Src X)) a p \\<longleftrightarrow> p_src  p \\<in> ipt_iprange_to_set X\"\n  \"matches (common_matcher, \\<alpha>) (Match (Dst X)) a p \\<longleftrightarrow> p_dst  p \\<in> ipt_iprange_to_set X\"", "lemma match_simplematcher_SrcDst_not:\n  \"matches (common_matcher, \\<alpha>) (MatchNot (Match (Src X))) a p \\<longleftrightarrow> p_src  p \\<notin> ipt_iprange_to_set X\"\n  \"matches (common_matcher, \\<alpha>) (MatchNot (Match (Dst X))) a p \\<longleftrightarrow> p_dst  p \\<notin> ipt_iprange_to_set X\"", "lemma common_matcher_SrcDst_Inter:\n  \"(\\<forall>m\\<in>set X. matches (common_matcher, \\<alpha>) (Match (Src m)) a p) \\<longleftrightarrow> p_src p \\<in> (\\<Inter>x\\<in>set X. ipt_iprange_to_set x)\"\n  \"(\\<forall>m\\<in>set X. matches (common_matcher, \\<alpha>) (Match (Dst m)) a p) \\<longleftrightarrow> p_dst p \\<in> (\\<Inter>x\\<in>set X. ipt_iprange_to_set x)\"", "lemma optimize_primitive_univ_unchanged_primitives:\n    \"optimize_primitive_univ (Match a) = (Match a) \\<or> optimize_primitive_univ (Match a) = MatchAny\"", "lemma optimize_primitive_univ_correct_matchexpr: fixes m::\"'i::len common_primitive match_expr\"\n    shows \"matches (common_matcher, \\<alpha>) m = matches (common_matcher, \\<alpha>) (optimize_primitive_univ m)\"", "lemma upper_closure_matchexpr_generic: \n    \"a = Accept \\<or> a = Drop \\<Longrightarrow> remove_unknowns_generic (common_matcher, in_doubt_allow) a m = upper_closure_matchexpr a m\"", "lemma lower_closure_matchexpr_generic: \n    \"a = Accept \\<or> a = Drop \\<Longrightarrow> remove_unknowns_generic (common_matcher, in_doubt_deny) a m = lower_closure_matchexpr a m\""], "translations": [["", "lemma packet_independent_\\<beta>_unknown_common_matcher: \"packet_independent_\\<beta>_unknown common_matcher\""], ["proof (prove)\ngoal (1 subgoal):\n 1. packet_independent_\\<beta>_unknown common_matcher", "apply(simp add: packet_independent_\\<beta>_unknown_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       (\\<exists>p.\n           common_matcher A p \\<noteq> TernaryUnknown) \\<longrightarrow>\n       (\\<forall>p. common_matcher A p \\<noteq> TernaryUnknown)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A p pa.\n       \\<lbrakk>common_matcher A p \\<noteq> TernaryUnknown;\n        common_matcher A pa = TernaryUnknown\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac a p1 p2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p1 p2.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac a)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>a p1 p2 x1.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = Src x1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a p1 p2 x2.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = Dst x2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a p1 p2 x3.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = IIface x3\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a p1 p2 x4.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = OIface x4\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a p1 p2 x5.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = Prot x5\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a p1 p2 x6.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = Src_Ports x6\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a p1 p2 x7.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = Dst_Ports x7\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a p1 p2 x8.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = MultiportPorts x8\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a p1 p2 x9.\n       \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n        common_matcher a p2 = TernaryUnknown; a = L4_Flags x9\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>a p1 p2 x10.\n        \\<lbrakk>common_matcher a p1 \\<noteq> TernaryUnknown;\n         common_matcher a p2 = TernaryUnknown; a = CT_State x10\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 11 subgoals...", "apply(simp_all add: bool_to_ternary_Unknown)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a p1 p2 x6.\n       \\<lbrakk>common_matcher (Src_Ports x6) p1 \\<noteq> TernaryUnknown;\n        common_matcher (Src_Ports x6) p2 = TernaryUnknown;\n        a = Src_Ports x6\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a p1 p2 x7.\n       \\<lbrakk>common_matcher (Dst_Ports x7) p1 \\<noteq> TernaryUnknown;\n        common_matcher (Dst_Ports x7) p2 = TernaryUnknown;\n        a = Dst_Ports x7\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a p1 p2 x8.\n       \\<lbrakk>common_matcher (MultiportPorts x8) p1 \\<noteq>\n                TernaryUnknown;\n        common_matcher (MultiportPorts x8) p2 = TernaryUnknown;\n        a = MultiportPorts x8\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac l4ports, case_tac l4ports; simp add: bool_to_ternary_Unknown; fail)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primitive_matcher_generic_common_matcher: \"primitive_matcher_generic common_matcher\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_matcher_generic common_matcher", "by unfold_locales  simp_all"], ["", "(* What if we specify a port range where the start port is greater than the end port?\n    For example, mathematically, {3 .. 2} = {}. Does iptables have the same behavior?\n    For example, --source-port 1:0 raises an error on my system. For normal port specification, -m tcp, and -m multiport.\n    There is also a manpage which states \"if the first port is greater than the second one they will be swapped.\"\n    I also saw a system where such an empty port range (--source-port 1:0) was really this impossible range and caused a rule that could never match.\n    Because \\<nexists> port. port \\<in> {}.\n    The behaviour if the end of the port range is smaller than the start is not 100% consistent among iptables versions and different modules.\n    In general, it would be best to raise an error if such a range occurs.\n    *)"], ["", "text\\<open>Warning: beware of the sloppy term `empty' portrange\\<close>"], ["", "text\\<open>An `empty' port range means it can never match! Basically, @{term \"MatchNot (Match (Src_Ports (L4Ports proto [(0,65535)])))\"} is False\\<close>"], ["", "lemma \"\\<not> matches (common_matcher, \\<alpha>) (MatchNot (Match (Src_Ports (L4Ports TCP [(0,65535)])))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=2065, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> matches (common_matcher, \\<alpha>)\n            (MatchNot (Match (Src_Ports (L4Ports TCP [(0, 65535)])))) a\n            \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n               p_src = ipv4addr_of_dotdecimal (192, 168, 2, 45),\n               p_dst = ipv4addr_of_dotdecimal (173, 194, 112, 111),\n               p_proto = TCP, p_sport = 2065, p_dport = 80,\n               p_tcp_flags = {}, p_payload = [],\n               p_tag_ctstate = CT_New\\<rparr>", "by(simp add: primitive_matcher_generic_common_matcher primitive_matcher_generic.Ports_single_not)"], ["", "text\\<open>An `empty' port range means it always matches! Basically, @{term \"(MatchNot (Match (Src_Ports (L4Ports any []))))\"} is True.\n        This corresponds to firewall behavior, but usually you cannot specify an empty portrange in firewalls, but omission of portrange means no-port-restrictions, \n        i.e. every port matches.\\<close>"], ["", "lemma \"matches (common_matcher, \\<alpha>) (MatchNot (Match (Src_Ports (L4Ports any [])))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=2065, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (common_matcher, \\<alpha>)\n     (MatchNot (Match (Src_Ports (L4Ports any [])))) a\n     \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n        p_src = ipv4addr_of_dotdecimal (192, 168, 2, 45),\n        p_dst = ipv4addr_of_dotdecimal (173, 194, 112, 111), p_proto = TCP,\n        p_sport = 2065, p_dport = 80, p_tcp_flags = {}, p_payload = [],\n        p_tag_ctstate = CT_New\\<rparr>", "by(simp add: primitive_matcher_generic_common_matcher primitive_matcher_generic.Ports_single_not)"], ["", "text\\<open>If not a corner case, portrange matching is straight forward.\\<close>"], ["", "lemma \"matches (common_matcher, \\<alpha>) (Match (Src_Ports (L4Ports TCP [(1024,4096), (9999, 65535)]))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=2065, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\"\n        \"\\<not> matches (common_matcher, \\<alpha>) (Match (Src_Ports (L4Ports TCP [(1024,4096), (9999, 65535)]))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=5000, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\"\n        \"\\<not>matches (common_matcher, \\<alpha>) (MatchNot (Match (Src_Ports (L4Ports TCP [(1024,4096), (9999, 65535)])))) a \n          \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n           p_src = ipv4addr_of_dotdecimal (192,168,2,45), p_dst= ipv4addr_of_dotdecimal (173,194,112,111),\n           p_proto=TCP, p_sport=2065, p_dport=80, p_tcp_flags = {},\n           p_payload = '''', p_tag_ctstate = CT_New\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (common_matcher, \\<alpha>)\n     (Match (Src_Ports (L4Ports TCP [(1024, 4096), (9999, 65535)]))) a\n     \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n        p_src = ipv4addr_of_dotdecimal (192, 168, 2, 45),\n        p_dst = ipv4addr_of_dotdecimal (173, 194, 112, 111), p_proto = TCP,\n        p_sport = 2065, p_dport = 80, p_tcp_flags = {}, p_payload = [],\n        p_tag_ctstate = CT_New\\<rparr> &&&\n    \\<not> matches (common_matcher, \\<alpha>)\n            (Match (Src_Ports (L4Ports TCP [(1024, 4096), (9999, 65535)])))\n            a \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n                 p_src = ipv4addr_of_dotdecimal (192, 168, 2, 45),\n                 p_dst = ipv4addr_of_dotdecimal (173, 194, 112, 111),\n                 p_proto = TCP, p_sport = 5000, p_dport = 80,\n                 p_tcp_flags = {}, p_payload = [],\n                 p_tag_ctstate = CT_New\\<rparr> &&&\n    \\<not> matches (common_matcher, \\<alpha>)\n            (MatchNot\n              (Match\n                (Src_Ports (L4Ports TCP [(1024, 4096), (9999, 65535)]))))\n            a \\<lparr>p_iiface = ''eth0'', p_oiface = ''eth1'',\n                 p_src = ipv4addr_of_dotdecimal (192, 168, 2, 45),\n                 p_dst = ipv4addr_of_dotdecimal (173, 194, 112, 111),\n                 p_proto = TCP, p_sport = 2065, p_dport = 80,\n                 p_tcp_flags = {}, p_payload = [],\n                 p_tag_ctstate = CT_New\\<rparr>", "by(simp_all add: primitive_matcher_generic_common_matcher primitive_matcher_generic.Ports_single_not primitive_matcher_generic.Ports_single)"], ["", "text\\<open>Lemmas when matching on @{term Src} or @{term Dst}\\<close>"], ["", "lemma common_matcher_SrcDst_defined:\n  \"common_matcher (Src m) p \\<noteq> TernaryUnknown\"\n  \"common_matcher (Dst m) p \\<noteq> TernaryUnknown\"\n  \"common_matcher (Src_Ports ps) p \\<noteq> TernaryUnknown\"\n  \"common_matcher (Dst_Ports ps) p \\<noteq> TernaryUnknown\"\n  \"common_matcher (MultiportPorts ps) p \\<noteq> TernaryUnknown\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher (Src m) p \\<noteq> TernaryUnknown &&&\n     common_matcher (Dst m) p \\<noteq> TernaryUnknown) &&&\n    common_matcher (Src_Ports ps) p \\<noteq> TernaryUnknown &&&\n    common_matcher (Dst_Ports ps) p \\<noteq> TernaryUnknown &&&\n    common_matcher (MultiportPorts ps) p \\<noteq> TernaryUnknown", "apply(case_tac [!] m, case_tac [!] ps)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x1 x1a x2.\n       \\<lbrakk>m = IpAddr x1; ps = L4Ports x1a x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Src m) p \\<noteq> TernaryUnknown\n 2. \\<And>x21 x22 x1 x2.\n       \\<lbrakk>m = IpAddrNetmask x21 x22; ps = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Src m) p \\<noteq> TernaryUnknown\n 3. \\<And>x31 x32 x1 x2.\n       \\<lbrakk>m = IpAddrRange x31 x32; ps = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Src m) p \\<noteq> TernaryUnknown\n 4. \\<And>x1 x1a x2.\n       \\<lbrakk>m = IpAddr x1; ps = L4Ports x1a x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Dst m) p \\<noteq> TernaryUnknown\n 5. \\<And>x21 x22 x1 x2.\n       \\<lbrakk>m = IpAddrNetmask x21 x22; ps = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Dst m) p \\<noteq> TernaryUnknown\n 6. \\<And>x31 x32 x1 x2.\n       \\<lbrakk>m = IpAddrRange x31 x32; ps = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Dst m) p \\<noteq> TernaryUnknown\n 7. \\<And>x1 x1a x2.\n       \\<lbrakk>m = IpAddr x1; ps = L4Ports x1a x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Src_Ports ps) p \\<noteq>\n                         TernaryUnknown\n 8. \\<And>x21 x22 x1 x2.\n       \\<lbrakk>m = IpAddrNetmask x21 x22; ps = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Src_Ports ps) p \\<noteq>\n                         TernaryUnknown\n 9. \\<And>x31 x32 x1 x2.\n       \\<lbrakk>m = IpAddrRange x31 x32; ps = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> common_matcher (Src_Ports ps) p \\<noteq>\n                         TernaryUnknown\n 10. \\<And>x1 x1a x2.\n        \\<lbrakk>m = IpAddr x1; ps = L4Ports x1a x2\\<rbrakk>\n        \\<Longrightarrow> common_matcher (Dst_Ports ps) p \\<noteq>\n                          TernaryUnknown\nA total of 15 subgoals...", "apply(simp_all add: bool_to_ternary_Unknown)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma common_matcher_SrcDst_defined_simp:\n  \"common_matcher (Src x) p \\<noteq> TernaryFalse \\<longleftrightarrow> common_matcher (Src x) p = TernaryTrue\"\n  \"common_matcher (Dst x) p \\<noteq> TernaryFalse \\<longleftrightarrow> common_matcher (Dst x) p = TernaryTrue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher (Src x) p \\<noteq> TernaryFalse) =\n    (common_matcher (Src x) p = TernaryTrue) &&&\n    (common_matcher (Dst x) p \\<noteq> TernaryFalse) =\n    (common_matcher (Dst x) p = TernaryTrue)", "apply (metis eval_ternary_Not.cases common_matcher_SrcDst_defined(1) ternaryvalue.distinct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher (Dst x) p \\<noteq> TernaryFalse) =\n    (common_matcher (Dst x) p = TernaryTrue)", "apply (metis eval_ternary_Not.cases common_matcher_SrcDst_defined(2) ternaryvalue.distinct(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*The primitive_matcher_generic does not know anything about IP addresses*)"], ["", "lemma match_simplematcher_SrcDst:\n  \"matches (common_matcher, \\<alpha>) (Match (Src X)) a p \\<longleftrightarrow> p_src  p \\<in> ipt_iprange_to_set X\"\n  \"matches (common_matcher, \\<alpha>) (Match (Dst X)) a p \\<longleftrightarrow> p_dst  p \\<in> ipt_iprange_to_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (common_matcher, \\<alpha>) (Match (Src X)) a p =\n    (p_src p \\<in> ipt_iprange_to_set X) &&&\n    matches (common_matcher, \\<alpha>) (Match (Dst X)) a p =\n    (p_dst p \\<in> ipt_iprange_to_set X)", "by(simp_all add: match_raw_ternary bool_to_ternary_simps split: ternaryvalue.split)"], ["", "lemma match_simplematcher_SrcDst_not:\n  \"matches (common_matcher, \\<alpha>) (MatchNot (Match (Src X))) a p \\<longleftrightarrow> p_src  p \\<notin> ipt_iprange_to_set X\"\n  \"matches (common_matcher, \\<alpha>) (MatchNot (Match (Dst X))) a p \\<longleftrightarrow> p_dst  p \\<notin> ipt_iprange_to_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (common_matcher, \\<alpha>) (MatchNot (Match (Src X))) a p =\n    (p_src p \\<notin> ipt_iprange_to_set X) &&&\n    matches (common_matcher, \\<alpha>) (MatchNot (Match (Dst X))) a p =\n    (p_dst p \\<notin> ipt_iprange_to_set X)", "apply(simp_all add: matches_case_ternaryvalue_tuple split: ternaryvalue.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (eval_ternary_Not\n      (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n     TernaryTrue \\<longrightarrow>\n     p_src p \\<notin> ipt_iprange_to_set X) \\<and>\n    (eval_ternary_Not\n      (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n     TernaryFalse \\<longrightarrow>\n     p_src p \\<in> ipt_iprange_to_set X) \\<and>\n    (eval_ternary_Not\n      (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n     TernaryUnknown \\<longrightarrow>\n     \\<alpha> a p = (p_src p \\<notin> ipt_iprange_to_set X))\n 2. (eval_ternary_Not\n      (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n     TernaryTrue \\<longrightarrow>\n     p_dst p \\<notin> ipt_iprange_to_set X) \\<and>\n    (eval_ternary_Not\n      (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n     TernaryFalse \\<longrightarrow>\n     p_dst p \\<in> ipt_iprange_to_set X) \\<and>\n    (eval_ternary_Not\n      (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n     TernaryUnknown \\<longrightarrow>\n     \\<alpha> a p = (p_dst p \\<notin> ipt_iprange_to_set X))", "apply(case_tac [!] X)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1.\n       X = IpAddr x1 \\<Longrightarrow>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryTrue \\<longrightarrow>\n        p_src p \\<notin> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryFalse \\<longrightarrow>\n        p_src p \\<in> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryUnknown \\<longrightarrow>\n        \\<alpha> a p = (p_src p \\<notin> ipt_iprange_to_set X))\n 2. \\<And>x21 x22.\n       X = IpAddrNetmask x21 x22 \\<Longrightarrow>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryTrue \\<longrightarrow>\n        p_src p \\<notin> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryFalse \\<longrightarrow>\n        p_src p \\<in> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryUnknown \\<longrightarrow>\n        \\<alpha> a p = (p_src p \\<notin> ipt_iprange_to_set X))\n 3. \\<And>x31 x32.\n       X = IpAddrRange x31 x32 \\<Longrightarrow>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryTrue \\<longrightarrow>\n        p_src p \\<notin> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryFalse \\<longrightarrow>\n        p_src p \\<in> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_src p \\<in> ipt_iprange_to_set X)) =\n        TernaryUnknown \\<longrightarrow>\n        \\<alpha> a p = (p_src p \\<notin> ipt_iprange_to_set X))\n 4. \\<And>x1.\n       X = IpAddr x1 \\<Longrightarrow>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryTrue \\<longrightarrow>\n        p_dst p \\<notin> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryFalse \\<longrightarrow>\n        p_dst p \\<in> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryUnknown \\<longrightarrow>\n        \\<alpha> a p = (p_dst p \\<notin> ipt_iprange_to_set X))\n 5. \\<And>x21 x22.\n       X = IpAddrNetmask x21 x22 \\<Longrightarrow>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryTrue \\<longrightarrow>\n        p_dst p \\<notin> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryFalse \\<longrightarrow>\n        p_dst p \\<in> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryUnknown \\<longrightarrow>\n        \\<alpha> a p = (p_dst p \\<notin> ipt_iprange_to_set X))\n 6. \\<And>x31 x32.\n       X = IpAddrRange x31 x32 \\<Longrightarrow>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryTrue \\<longrightarrow>\n        p_dst p \\<notin> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryFalse \\<longrightarrow>\n        p_dst p \\<in> ipt_iprange_to_set X) \\<and>\n       (eval_ternary_Not\n         (bool_to_ternary (p_dst p \\<in> ipt_iprange_to_set X)) =\n        TernaryUnknown \\<longrightarrow>\n        \\<alpha> a p = (p_dst p \\<notin> ipt_iprange_to_set X))", "apply(simp_all add: bool_to_ternary_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma common_matcher_SrcDst_Inter:\n  \"(\\<forall>m\\<in>set X. matches (common_matcher, \\<alpha>) (Match (Src m)) a p) \\<longleftrightarrow> p_src p \\<in> (\\<Inter>x\\<in>set X. ipt_iprange_to_set x)\"\n  \"(\\<forall>m\\<in>set X. matches (common_matcher, \\<alpha>) (Match (Dst m)) a p) \\<longleftrightarrow> p_dst p \\<in> (\\<Inter>x\\<in>set X. ipt_iprange_to_set x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set X.\n        matches (common_matcher, \\<alpha>) (Match (Src m)) a p) =\n    (p_src p \\<in> \\<Inter> (ipt_iprange_to_set ` set X)) &&&\n    (\\<forall>m\\<in>set X.\n        matches (common_matcher, \\<alpha>) (Match (Dst m)) a p) =\n    (p_dst p \\<in> \\<Inter> (ipt_iprange_to_set ` set X))", "by(simp_all add: match_raw_ternary bool_to_ternary_simps split: ternaryvalue.split)"], ["", "subsection\\<open>Basic optimisations\\<close>"], ["", "text\\<open>Perform very basic optimization. Remove matches to primitives which are essentially @{const MatchAny}\\<close>"], ["", "fun optimize_primitive_univ :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr\" where\n    \"optimize_primitive_univ (Match (Src (IpAddrNetmask _ 0))) = MatchAny\" |\n    \"optimize_primitive_univ (Match (Dst (IpAddrNetmask _ 0))) = MatchAny\" |\n    (*missing: the other IPs ...*)\n    \"optimize_primitive_univ (Match (IIface iface)) = (if iface = ifaceAny then MatchAny else (Match (IIface iface)))\" |\n    \"optimize_primitive_univ (Match (OIface iface)) = (if iface = ifaceAny then MatchAny else (Match (OIface iface)))\" |\n    (*missing: L4Ports. But this introduces a new match, which causes problems.\n    \"optimize_primitive_univ (Match (Src_Ports (L4Ports proto [(s, e)]))) = (if s = 0 \\<and> e = 0xFFFF then (Match (Prot (Proto proto))) else (Match (Src_Ports (L4Ports proto [(s, e)]))))\" |\n    \"optimize_primitive_univ (Match (Dst_Ports (L4Ports proto [(s, e)]))) = (if s = 0 \\<and> e = 0xFFFF then (Match (Prot (Proto proto))) else (Match (Dst_Ports (L4Ports proto [(s, e)]))))\" |*)\n    \"optimize_primitive_univ (Match (Prot ProtoAny)) = MatchAny\" |\n    \"optimize_primitive_univ (Match (L4_Flags (TCP_Flags m c))) = (if m = {} \\<and> c = {} then MatchAny else (Match (L4_Flags (TCP_Flags m c))))\" |\n    \"optimize_primitive_univ (Match (CT_State ctstate)) = (if ctstate_is_UNIV ctstate then MatchAny else Match (CT_State ctstate))\" |\n    \"optimize_primitive_univ (Match m) = Match m\" |\n    (*\"optimize_primitive_univ (MatchNot (MatchNot m)) = (optimize_primitive_univ m)\" | --\"needed to preserve normalized condition\"*)\n    \"optimize_primitive_univ (MatchNot m) = (MatchNot (optimize_primitive_univ m))\" |\n    (*\"optimize_primitive_univ (MatchAnd (Match (Extra e1)) (Match (Extra e2))) = optimize_primitive_univ (Match (Extra (e1@'' ''@e2)))\" |\n      -- \"can be done but normalization does not work afterwards\"*)\n    \"optimize_primitive_univ (MatchAnd m1 m2) = MatchAnd (optimize_primitive_univ m1) (optimize_primitive_univ m2)\" |\n    \"optimize_primitive_univ MatchAny = MatchAny\""], ["", "lemma optimize_primitive_univ_unchanged_primitives:\n    \"optimize_primitive_univ (Match a) = (Match a) \\<or> optimize_primitive_univ (Match a) = MatchAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. optimize_primitive_univ (Match a) = Match a \\<or>\n    optimize_primitive_univ (Match a) = MatchAny", "by (induction \"(Match a)\" rule: optimize_primitive_univ.induct)\n         (auto split: if_split_asm)"], ["", "lemma optimize_primitive_univ_correct_matchexpr: fixes m::\"'i::len common_primitive match_expr\"\n    shows \"matches (common_matcher, \\<alpha>) m = matches (common_matcher, \\<alpha>) (optimize_primitive_univ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (common_matcher, \\<alpha>) m =\n    matches (common_matcher, \\<alpha>) (optimize_primitive_univ m)", "proof(simp add: fun_eq_iff, clarify, rename_tac a p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       matches (common_matcher, \\<alpha>) m a p =\n       matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p", "fix a and p :: \"('i::len, 'a) tagged_packet_scheme\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       matches (common_matcher, \\<alpha>) m a p =\n       matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p", "have \"65535 = (max_word::16 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 65535 = - 1", "by simp"], ["proof (state)\nthis:\n  65535 = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       matches (common_matcher, \\<alpha>) m a p =\n       matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p", "then"], ["proof (chain)\npicking this:\n  65535 = - 1", "have port_range: \"\\<And>s e port. s = 0 \\<and> e = 0xFFFF \\<longrightarrow> (port::16 word) \\<le> 0xFFFF\""], ["proof (prove)\nusing this:\n  65535 = - 1\n\ngoal (1 subgoal):\n 1. \\<And>s e port.\n       s = (0::'b) \\<and> e = (65535::'c) \\<longrightarrow> port \\<le> 65535", "by (simp only:) simp"], ["proof (state)\nthis:\n  ?s = (0::?'b1) \\<and> ?e = (65535::?'c1) \\<longrightarrow>\n  ?port \\<le> 65535\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       matches (common_matcher, \\<alpha>) m a p =\n       matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p", "have \"ternary_ternary_eval (map_match_tac common_matcher p m) = ternary_ternary_eval (map_match_tac common_matcher p (optimize_primitive_univ m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ternary_ternary_eval (map_match_tac common_matcher p m) =\n    ternary_ternary_eval\n     (map_match_tac common_matcher p (optimize_primitive_univ m))", "apply(induction m rule: optimize_primitive_univ.induct)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>uu_.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (Match (Src (IpAddrNetmask uu_ 0)))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (optimize_primitive_univ (Match (Src (IpAddrNetmask uu_ 0)))))\n 2. \\<And>uv_.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (Match (Dst (IpAddrNetmask uv_ 0)))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (optimize_primitive_univ (Match (Dst (IpAddrNetmask uv_ 0)))))\n 3. \\<And>iface.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (Match (IIface iface))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (optimize_primitive_univ (Match (IIface iface))))\n 4. \\<And>iface.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (Match (OIface iface))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (optimize_primitive_univ (Match (OIface iface))))\n 5. ternary_ternary_eval\n     (map_match_tac common_matcher p (Match (Prot ProtoAny))) =\n    ternary_ternary_eval\n     (map_match_tac common_matcher p\n       (optimize_primitive_univ (Match (Prot ProtoAny))))\n 6. \\<And>m c.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (Match (L4_Flags (TCP_Flags m c)))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (optimize_primitive_univ (Match (L4_Flags (TCP_Flags m c)))))\n 7. \\<And>ctstate.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (Match (CT_State ctstate))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (optimize_primitive_univ (Match (CT_State ctstate))))\n 8. \\<And>va.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (Match (Src (IpAddr va)))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (optimize_primitive_univ (Match (Src (IpAddr va)))))\n 9. \\<And>va vc.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (Match (Src (IpAddrNetmask va (Suc vc))))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (optimize_primitive_univ\n            (Match (Src (IpAddrNetmask va (Suc vc))))))\n 10. \\<And>va vb.\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (Match (Src (IpAddrRange va vb)))) =\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (optimize_primitive_univ (Match (Src (IpAddrRange va vb)))))\nA total of 21 subgoals...", "by(simp_all add: port_range match_ifaceAny ipset_from_cidr_0 ctstate_is_UNIV)"], ["proof (state)\nthis:\n  ternary_ternary_eval (map_match_tac common_matcher p m) =\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (optimize_primitive_univ m))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       matches (common_matcher, \\<alpha>) m a p =\n       matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p", "(*by(fastforce intro: arg_cong[where f=bool_to_ternary])+ if we add pots again*)"], ["proof (state)\nthis:\n  ternary_ternary_eval (map_match_tac common_matcher p m) =\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (optimize_primitive_univ m))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       matches (common_matcher, \\<alpha>) m a p =\n       matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p", "thus \"matches (common_matcher, \\<alpha>) m a p = matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p\""], ["proof (prove)\nusing this:\n  ternary_ternary_eval (map_match_tac common_matcher p m) =\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (optimize_primitive_univ m))\n\ngoal (1 subgoal):\n 1. matches (common_matcher, \\<alpha>) m a p =\n    matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p", "by(rule matches_iff_apply_f)"], ["proof (state)\nthis:\n  matches (common_matcher, \\<alpha>) m a p =\n  matches (common_matcher, \\<alpha>) (optimize_primitive_univ m) a p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary optimize_primitive_univ_correct: \"approximating_bigstep_fun (common_matcher, \\<alpha>) p (optimize_matches optimize_primitive_univ rs) s = \n                                              approximating_bigstep_fun (common_matcher, \\<alpha>) p rs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. approximating_bigstep_fun (common_matcher, \\<alpha>) p\n     (optimize_matches optimize_primitive_univ rs) s =\n    approximating_bigstep_fun (common_matcher, \\<alpha>) p rs s", "using optimize_matches optimize_primitive_univ_correct_matchexpr"], ["proof (prove)\nusing this:\n  \\<forall>m a.\n     matches ?\\<gamma> (?f m) a ?p =\n     matches ?\\<gamma> m a ?p \\<Longrightarrow>\n  approximating_bigstep_fun ?\\<gamma> ?p (optimize_matches ?f ?rs) ?s =\n  approximating_bigstep_fun ?\\<gamma> ?p ?rs ?s\n  matches (common_matcher, ?\\<alpha>) ?m =\n  matches (common_matcher, ?\\<alpha>) (optimize_primitive_univ ?m)\n\ngoal (1 subgoal):\n 1. approximating_bigstep_fun (common_matcher, \\<alpha>) p\n     (optimize_matches optimize_primitive_univ rs) s =\n    approximating_bigstep_fun (common_matcher, \\<alpha>) p rs s", "by metis"], ["", "subsection\\<open>Abstracting over unknowns\\<close>"], ["", "text\\<open>remove @{const Extra} (i.e. @{const TernaryUnknown}) match expressions\\<close>"], ["", "fun upper_closure_matchexpr :: \"action \\<Rightarrow> 'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr\" where\n    \"upper_closure_matchexpr _ MatchAny = MatchAny\" |\n    \"upper_closure_matchexpr Accept (Match (Extra _)) = MatchAny\" |\n    \"upper_closure_matchexpr Reject (Match (Extra _)) = MatchNot MatchAny\" |\n    \"upper_closure_matchexpr Drop (Match (Extra _)) = MatchNot MatchAny\" |\n    \"upper_closure_matchexpr _ (Match m) = Match m\" |\n    \"upper_closure_matchexpr Accept (MatchNot (Match (Extra _))) = MatchAny\" |\n    \"upper_closure_matchexpr Drop (MatchNot (Match (Extra _))) = MatchNot MatchAny\" |\n    \"upper_closure_matchexpr Reject (MatchNot (Match (Extra _))) = MatchNot MatchAny\" |\n    \"upper_closure_matchexpr a (MatchNot (MatchNot m)) = upper_closure_matchexpr a m\" |\n    \"upper_closure_matchexpr a (MatchNot (MatchAnd m1 m2)) = \n      (let m1' = upper_closure_matchexpr a (MatchNot m1); m2' = upper_closure_matchexpr a (MatchNot m2) in\n      (if m1' = MatchAny \\<or> m2' = MatchAny\n       then MatchAny\n       else \n          if m1' = MatchNot MatchAny then m2' else\n          if m2' = MatchNot MatchAny then m1'\n       else\n          MatchNot (MatchAnd (MatchNot m1') (MatchNot m2')))\n         )\" |\n    \"upper_closure_matchexpr _ (MatchNot m) = MatchNot m\" | \n    \"upper_closure_matchexpr a (MatchAnd m1 m2) = MatchAnd (upper_closure_matchexpr a m1) (upper_closure_matchexpr a m2)\""], ["", "lemma upper_closure_matchexpr_generic: \n    \"a = Accept \\<or> a = Drop \\<Longrightarrow> remove_unknowns_generic (common_matcher, in_doubt_allow) a m = upper_closure_matchexpr a m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = Accept \\<or> a = Drop \\<Longrightarrow>\n    remove_unknowns_generic (common_matcher, in_doubt_allow) a m =\n    upper_closure_matchexpr a m", "by(induction a m rule: upper_closure_matchexpr.induct)\n      (simp_all add: remove_unknowns_generic_simps2 bool_to_ternary_Unknown common_matcher_SrcDst_defined)"], ["", "fun lower_closure_matchexpr :: \"action \\<Rightarrow> 'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr\" where\n    \"lower_closure_matchexpr _ MatchAny = MatchAny\" |\n    \"lower_closure_matchexpr Accept (Match (Extra _)) = MatchNot MatchAny\" |\n    \"lower_closure_matchexpr Reject (Match (Extra _)) = MatchAny\" |\n    \"lower_closure_matchexpr Drop (Match (Extra _)) = MatchAny\" |\n    \"lower_closure_matchexpr _ (Match m) = Match m\" |\n    \"lower_closure_matchexpr Accept (MatchNot (Match (Extra _))) = MatchNot MatchAny\" |\n    \"lower_closure_matchexpr Drop (MatchNot (Match (Extra _))) = MatchAny\" |\n    \"lower_closure_matchexpr Reject (MatchNot (Match (Extra _))) = MatchAny\" |\n    \"lower_closure_matchexpr a (MatchNot (MatchNot m)) = lower_closure_matchexpr a m\" |\n    \"lower_closure_matchexpr a (MatchNot (MatchAnd m1 m2)) = \n      (let m1' = lower_closure_matchexpr a (MatchNot m1); m2' = lower_closure_matchexpr a (MatchNot m2) in\n      (if m1' = MatchAny \\<or> m2' = MatchAny\n       then MatchAny\n       else \n          if m1' = MatchNot MatchAny then m2' else\n          if m2' = MatchNot MatchAny then m1'\n       else\n          MatchNot (MatchAnd (MatchNot m1') (MatchNot m2')))\n         )\" |\n    \"lower_closure_matchexpr _ (MatchNot m) = MatchNot m\" | \n    \"lower_closure_matchexpr a (MatchAnd m1 m2) = MatchAnd (lower_closure_matchexpr a m1) (lower_closure_matchexpr a m2)\""], ["", "lemma lower_closure_matchexpr_generic: \n    \"a = Accept \\<or> a = Drop \\<Longrightarrow> remove_unknowns_generic (common_matcher, in_doubt_deny) a m = lower_closure_matchexpr a m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = Accept \\<or> a = Drop \\<Longrightarrow>\n    remove_unknowns_generic (common_matcher, in_doubt_deny) a m =\n    lower_closure_matchexpr a m", "by(induction a m rule: lower_closure_matchexpr.induct)\n    (simp_all add: remove_unknowns_generic_simps2 bool_to_ternary_Unknown common_matcher_SrcDst_defined)"], ["", "end"]]}