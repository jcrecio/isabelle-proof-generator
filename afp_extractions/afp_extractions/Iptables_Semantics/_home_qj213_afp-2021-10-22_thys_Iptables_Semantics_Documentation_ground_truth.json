{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Documentation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma unfold_optimize_common_matcher_univ_ruleset_CHAIN:\n    \\<comment> \\<open>for IPv4 and IPv6 packets\\<close>\n    fixes \\<gamma> :: \"'i::len common_primitive \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool\"\n    and   p :: \"('i::len, 'pkt_ext) tagged_packet_scheme\"\n    assumes \"sanity_wf_ruleset \\<Gamma>\" and \"chain_name \\<in> set (map fst \\<Gamma>)\"\n    and \"default_action = action.Accept \\<or> default_action = action.Drop\"\n    and \"matcher_agree_on_exact_matches \\<gamma> common_matcher\"\n    and \"unfold_ruleset_CHAIN_safe chain_name default_action (map_of \\<Gamma>) = Some rs\"\n    shows \"(map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n           (map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\"\n    and \"simple_ruleset rs\""], "translations": [["", "lemma unfold_optimize_common_matcher_univ_ruleset_CHAIN:\n    \\<comment> \\<open>for IPv4 and IPv6 packets\\<close>\n    fixes \\<gamma> :: \"'i::len common_primitive \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool\"\n    and   p :: \"('i::len, 'pkt_ext) tagged_packet_scheme\"\n    assumes \"sanity_wf_ruleset \\<Gamma>\" and \"chain_name \\<in> set (map fst \\<Gamma>)\"\n    and \"default_action = action.Accept \\<or> default_action = action.Drop\"\n    and \"matcher_agree_on_exact_matches \\<gamma> common_matcher\"\n    and \"unfold_ruleset_CHAIN_safe chain_name default_action (map_of \\<Gamma>) = Some rs\"\n    shows \"(map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n           (map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\"\n    and \"simple_ruleset rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t &&&\n    simple_ruleset rs", "apply(intro unfold_optimize_ruleset_CHAIN[where optimize=optimize_primitive_univ, OF assms(1) assms(2) assms(3)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       Semantics.matches \\<gamma> (optimize_primitive_univ m) p =\n       Semantics.matches \\<gamma> m p\n 2. unfold_optimize_ruleset_CHAIN optimize_primitive_univ chain_name\n     default_action (map_of \\<Gamma>) =\n    Some rs\n 3. simple_ruleset rs", "using assms"], ["proof (prove)\nusing this:\n  sanity_wf_ruleset \\<Gamma>\n  chain_name \\<in> set (map fst \\<Gamma>)\n  default_action = action.Accept \\<or> default_action = action.Drop\n  matcher_agree_on_exact_matches \\<gamma> common_matcher\n  unfold_ruleset_CHAIN_safe chain_name default_action (map_of \\<Gamma>) =\n  Some rs\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       Semantics.matches \\<gamma> (optimize_primitive_univ m) p =\n       Semantics.matches \\<gamma> m p\n 2. unfold_optimize_ruleset_CHAIN optimize_primitive_univ chain_name\n     default_action (map_of \\<Gamma>) =\n    Some rs\n 3. simple_ruleset rs", "apply(simp_all add: unfold_ruleset_CHAIN_safe_def Semantics_optimize_primitive_univ_common_matcher)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sanity_wf_ruleset \\<Gamma>;\n     chain_name \\<in> fst ` set \\<Gamma>;\n     default_action = action.Accept \\<or> default_action = action.Drop;\n     matcher_agree_on_exact_matches \\<gamma> common_matcher;\n     unfold_optimize_ruleset_CHAIN optimize_primitive_univ chain_name\n      default_action (map_of \\<Gamma>) =\n     Some rs\\<rbrakk>\n    \\<Longrightarrow> simple_ruleset rs", "by(simp add: unfold_optimize_ruleset_CHAIN_def Let_def split: if_split_asm)"], ["", "subsection\\<open>Spoofing protection\\<close>"], ["", "text\\<open>We provide an executable algorithm @{const no_spoofing_iface} which checks that a ruleset provides spoofing protection:\n\n@{thm no_spoofing_executable_set [no_vars]}\n\nText the firewall needs normalized match conditions, this is a good way to preprocess the firewall before \nchecking spoofing protection:\n\n@{thm no_spoofing_executable_set_preprocessed [no_vars]}\n\n\\<close>"], ["", "subsection\\<open>Simple Firewall Model\\<close>"], ["", "text\\<open>The simple firewall supports the following match conditions: @{typ \"'i::len simple_match\"}.\n\nThe @{const simple_fw} model is remarkably simple: @{thm simple_fw.simps [no_vars]}\n\nWe support translating to a stricter version (a version that accepts less packets): \n\n@{thm new_packets_to_simple_firewall_underapproximation [no_vars]}\n\n\nWe support translating to a more permissive version (a version that accepts more packets): \n\n@{thm new_packets_to_simple_firewall_overapproximation [no_vars]}\n\n\n\nThere is also a different approach to translate to the simple firewall which removes all matches on interfaces:\n\n@{thm to_simple_firewall_without_interfaces[no_vars]}\n\n\\<close>"], ["", "subsection\\<open>Service Matrices\\<close>"], ["", "text\\<open>\nFor a @{typ \"'i::len simple_rule list\"} and a fixed @{typ parts_connection}, \nwe support to partition the IPv4 address space the following.\n\nAll members of a partition have the same access rights:\n@{thm build_ip_partition_same_fw [no_vars]}\n\nMinimal:\n@{thm build_ip_partition_same_fw_min [no_vars]}\n\n\nThe resulting access control matrix is sound and complete:\n\n@{thm access_matrix [no_vars]}\n\nTheorem reads: \nFor a fixed connection, you can look up IP addresses (source and destination pairs) in the matrix \nif and only if the firewall accepts this src,dst IP address pair for the fixed connection.\nNote: The matrix is actually a graph (nice visualization!), you need to look up IP addresses \nin the Vertices and check the access of the representants in the edges. If you want to visualize\nthe graph (e.g. with Graphviz or tkiz): The vertices are the node description (i.e. header; \n  @{term \"dom V\"} is the label for each node which will also be referenced in the edges,\n  @{term \"ran V\"} is the human-readable description for each node (i.e. the full IP range it represents)), \nthe edges are the edges. Result looks nice. Theorem also tells us that this visualization is correct.\n\\<close>"], ["", "text\\<open>\nA final theorem which does not mention the simple firewall at all.\nIf the real iptables firewall (@{const iptables_bigstep}) accepts a packet, we have a corresponding\nedge in the @{const access_matrix}:\n\n@{thm access_matrix_and_bigstep_semantics [no_vars]}\n\n\nActually, we want to ignore all interfaces for a service matrix.\nThis is done in @{thm access_matrix_no_interfaces_and_bigstep_semantics[no_vars]}.\nThe theorem reads a bit ugly because we need well-formedness assumptions if we rewrite interfaces.\nInternally, it uses @{const iface_try_rewrite} which is pretty safe to use, even if you don't have\nan @{term ipassmt} or routing tables.\n\\<close>"], ["", "end"]]}