{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/Ports_Normalize.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma normalized_src_ports_def2: \"normalized_src_ports ms = normalized_n_primitive (is_Src_Ports, src_ports_sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) ms\"", "lemma normalized_dst_ports_def2: \"normalized_dst_ports ms = normalized_n_primitive (is_Dst_Ports, dst_ports_sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) ms\"", "lemma raw_ports_compress_src_CannotMatch:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = CannotMatch\"\n  shows \"\\<not> matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p\"", "lemma raw_ports_compress_dst_CannotMatch:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = CannotMatch\"\n  shows \"\\<not> matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p\"", "lemma l4_ports_compress_length_Matchall: \"length pss > 0 \\<Longrightarrow> l4_ports_compress pss \\<noteq> MatchesAll\"", "lemma raw_ports_compress_MatchesAll:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = MatchesAll\"\n  shows \"matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p\"\n  and \"matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p\"", "lemma raw_ports_compress_src_MatchExpr:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = MatchExpr m\"\n  shows \"matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p\"", "lemma raw_ports_compress_dst_MatchExpr:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = MatchExpr m\"\n  shows \"matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p\"", "lemma l4_ports_negate_one:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  shows \"matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Src_Ports ports) a p \\<longleftrightarrow>\n          matches (\\<beta>, \\<alpha>) (MatchNot (Match (Src_Ports ports))) a p\"\n  and \"matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Dst_Ports ports) a p \\<longleftrightarrow>\n          matches (\\<beta>, \\<alpha>) (MatchNot (Match (Dst_Ports ports))) a p\"", "lemma l4_ports_negate_one_nodisc:\n    \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> \\<forall>a. \\<not> disc (Prot a) \\<Longrightarrow> \\<not> has_disc disc (l4_ports_negate_one C pt)\"", "lemma l4_ports_negate_one_not_has_disc_negated_generic:\n    assumes noProt: \"\\<forall>a. \\<not> disc (Prot a)\"\n    shows \"\\<not> has_disc_negated disc False (l4_ports_negate_one C ports)\"", "lemma l4_ports_negate_one_not_has_disc_negated:\n    \"\\<not> has_disc_negated is_Src_Ports False (l4_ports_negate_one Src_Ports ports)\"\n    \"\\<not> has_disc_negated is_Dst_Ports False (l4_ports_negate_one Dst_Ports ports)\"", "lemma negated_normalized_folded_ports_nodisc:\n    \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [] \\<Longrightarrow>\n     m \\<in> set (normalize_match (andfold_MatchExp (map (l4_ports_negate_one C) pts))) \\<Longrightarrow>\n      \\<not> has_disc disc m\"", "lemma negated_normalized_folded_ports_normalized_n_primitive:\n    \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [] \\<Longrightarrow>\n     x \\<in> set (normalize_match (andfold_MatchExp (map (l4_ports_negate_one C) pts))) \\<Longrightarrow>\n      normalized_n_primitive (disc, sel) f x\"", "lemma \"\\<not> normalized_nnf_match (l4_ports_negate_one C ports)\"", "lemma \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> \\<not> normalized_n_primitive (disc, sel) f (l4_ports_negate_one C a)\"", "lemma \"((normalize_match (l4_ports_negate_one Src_Ports (L4Ports TCP [(22,22),(80,90)]))):: 32 common_primitive match_expr list)\n    =\n    [ MatchNot (Match (Prot (Proto TCP)))\n    , Match (Src_Ports (L4Ports 6 [(0, 21), (23, 79), (91, 0xFFFF)]))]\"", "lemma rewrite_negated_primitives_unchanged_if_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\"\n  and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and noDisc: \"\\<not> has_disc_negated disc False m\"\n  shows \"rewrite_negated_primitives (disc,sel) C negate_f m = m\"", "lemma rewrite_negated_primitives_normalized_no_modification:\n    assumes wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n    and disc_p: \"\\<not> has_disc_negated disc False m\"\n    and n: \"normalized_nnf_match m\"\n    and a: \"a \\<in> set (normalize_match (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m))\"\n    shows \"a = m\"", "lemma rewrite_negated_primitives_preserves_not_has_disc:\n  assumes n: \"normalized_nnf_match m\"\n  and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n  and nodisc: \"\\<not> has_disc disc2 m\"\n  and noNeg: \"\\<not> has_disc_negated disc False m\"\n  and disc2_noC: \"\\<forall>a. \\<not> disc2 (C a)\"\n  shows \"\\<not> has_disc disc2 (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)\"", "lemma rewrite_negated_primitives:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel disc_sel C\"\n  and negate_f: \"\\<forall>pts. matches \\<gamma> (negate_f C pts) a p \\<longleftrightarrow> matches \\<gamma> (MatchNot (Match (C pts))) a p\"\n  shows \"matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a p \\<longleftrightarrow> matches \\<gamma> m a p\"", "lemma rewrite_negated_primitives_not_has_disc:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and nodisc: \"\\<not> has_disc disc2 m\"\n  (*only need a condition for negate_f if it is actually applied*)\n  and negate_f: \"has_disc_negated disc False m \\<Longrightarrow> \\<forall>pts. \\<not> has_disc disc2 (negate_f C pts)\"\n  and no_disc: \"\\<forall>a. \\<not> disc2 (C a)\"\n  shows  \"\\<not> has_disc disc2 (rewrite_negated_primitives (disc,sel) C negate_f m)\"", "lemma rewrite_negated_primitives_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and negate_f: \"has_disc_negated disc False m \\<Longrightarrow> \\<forall>pts. \\<not> has_disc_negated disc False (negate_f C pts)\"\n  shows  \"\\<not> has_disc_negated disc False (rewrite_negated_primitives (disc,sel) C negate_f m)\"", "lemma rewrite_negated_primitives_preserves_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and negate_f: \"has_disc_negated disc False m \\<Longrightarrow> \\<forall>pts. \\<not> has_disc_negated disc2 False (negate_f C pts)\"\n  and no_disc: \"\\<not> has_disc_negated disc2 False m\"\n  shows  \"\\<not> has_disc_negated disc2 False (rewrite_negated_primitives (disc,sel) C negate_f m)\"", "lemma rewrite_negated_primitives_normalized_preserves_unrelated_helper:\n    assumes wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n    and disc: \"\\<forall>a. \\<not> disc2 (C a)\"\n    and disc_p: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated disc False m\" (*either we do not disc on protocol or the is no negated port*)\n    shows \"normalized_nnf_match m \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f m \\<Longrightarrow>\n         a \\<in> set (normalize_match (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  a\"", "lemma rewrite_negated_src_ports:\n  assumes generic: \"primitive_matcher_generic \\<beta>\"  and n: \"normalized_nnf_match m\"\n  shows \"matches (\\<beta>, \\<alpha>) (rewrite_negated_src_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma rewrite_negated_dst_ports:\n  assumes generic: \"primitive_matcher_generic \\<beta>\"  and n: \"normalized_nnf_match m\"\n  shows \"matches (\\<beta>, \\<alpha>) (rewrite_negated_dst_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma rewrite_negated_src_ports_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\"\n  shows  \"\\<not> has_disc_negated is_Src_Ports False (rewrite_negated_src_ports m)\"", "lemma rewrite_negated_dst_ports_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\"\n  shows  \"\\<not> has_disc_negated is_Dst_Ports False (rewrite_negated_dst_ports m)\"", "lemma \"\\<not> has_disc_negated disc t m \\<Longrightarrow> \\<forall>m' \\<in> set (normalize_match m). \\<not> has_disc_negated disc t m'\"", "lemma singletonize_L4Ports_src: assumes generic: \"primitive_matcher_generic \\<beta>\"\n   shows \"match_list (\\<beta>, \\<alpha>) (map (Match \\<circ> Src_Ports) (singletonize_L4Ports pts)) a p \\<longleftrightarrow> \n    matches (\\<beta>, \\<alpha>) (Match (Src_Ports pts)) a p\"", "lemma singletonize_L4Ports_dst: assumes generic: \"primitive_matcher_generic \\<beta>\"\n   shows \"match_list (\\<beta>, \\<alpha>) (map (Match \\<circ> Dst_Ports) (singletonize_L4Ports pts)) a p \\<longleftrightarrow> \n    matches (\\<beta>, \\<alpha>) (Match (Dst_Ports pts)) a p\"", "lemma singletonize_L4Ports_normalized_generic:\n    assumes wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    and \"m' \\<in> (\\<lambda>spt. Match (C spt)) ` set (singletonize_L4Ports pt)\"\n    shows \"normalized_n_primitive (disc, sel) (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1))  m'\"", "lemma singletonize_L4Ports_normalized_src_ports:\n    \"m' \\<in> (\\<lambda>spt. Match (Src_Ports spt)) ` set (singletonize_L4Ports pt) \\<Longrightarrow> normalized_src_ports m'\"", "lemma singletonize_L4Ports_normalized_dst_ports:\n    \"m' \\<in> (\\<lambda>spt. Match (Dst_Ports spt)) ` set (singletonize_L4Ports pt) \\<Longrightarrow> normalized_dst_ports m'\"", "lemma normalized_ports_singletonize_combine_rst:\n    assumes wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    shows \"normalized_n_primitive (disc, sel) (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) rst \\<Longrightarrow>\n    m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) ` set (singletonize_L4Ports pt) \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'\"", "lemma normalize_positive_ports_step_nnf:\n    assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    and noneg: \"\\<not> has_disc_negated disc False m\"\n    shows \"m' \\<in> set (normalize_positive_ports_step (disc,sel) C m) \\<Longrightarrow> normalized_nnf_match m'\"", "lemma normalize_positive_ports_step_normalized_n_primitive: \n    assumes n: \"normalized_nnf_match m\"  and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    and noneg: \"\\<not> has_disc_negated disc False m\"\n    shows \"\\<forall>m' \\<in> set (normalize_positive_ports_step (disc,sel) C m). \n            normalized_n_primitive (disc,sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) m'\"", "lemma noNeg_mapNegPos_helper: \"getNeg ls = [] \\<Longrightarrow>\n           map (Pos \\<circ> C) (getPos ls) = NegPos_map C ls\"", "lemma normalize_positive_src_ports:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Src_Ports False m\"\n    shows\n        \"match_list (\\<beta>, \\<alpha>) (normalize_positive_src_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma normalize_positive_dst_ports:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Dst_Ports False m\"\n    shows \"match_list (\\<beta>, \\<alpha>) (normalize_positive_dst_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma normalize_positive_src_ports_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Src_Ports False m\"\n    shows \"m' \\<in> set (normalize_positive_src_ports m) \\<Longrightarrow> normalized_nnf_match m'\"", "lemma normalize_positive_dst_ports_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Dst_Ports False m\"\n    shows \"m' \\<in> set (normalize_positive_dst_ports m) \\<Longrightarrow> normalized_nnf_match m'\"", "lemma normalize_positive_src_ports_normalized_n_primitive: \n    assumes n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Src_Ports False m\"\n    shows \"\\<forall>m' \\<in> set (normalize_positive_src_ports m). normalized_src_ports m'\"", "lemma normalize_positive_dst_ports_normalized_n_primitive: \n    assumes n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Dst_Ports False m\"\n    shows \"\\<forall>m' \\<in> set (normalize_positive_dst_ports m). normalized_dst_ports m'\"", "lemma normalize_ports_generic_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    and inset: \"m' \\<in> set (normalize_ports_generic normalize_pos rewrite_neg m)\"\n    and noNeg: \"\\<not> has_disc_negated disc False (rewrite_neg m)\"\n    and normalize_nnf_pos: \"\\<And>m m'.\n        normalized_nnf_match  m \\<Longrightarrow> \\<not> has_disc_negated disc False m \\<Longrightarrow>\n          m' \\<in> set (normalize_pos m) \\<Longrightarrow> normalized_nnf_match m'\"\n    shows \"normalized_nnf_match m'\"", "lemma normalize_ports_generic:\n    assumes n: \"normalized_nnf_match m\"\n    and normalize_pos: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated disc False m \\<Longrightarrow>\n                          match_list \\<gamma> (normalize_pos m) a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n    and rewrite_neg: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow>\n                          matches \\<gamma> (rewrite_neg m) a p = matches \\<gamma> m a p\"\n    and noNeg: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\"\n    shows\n        \"match_list \\<gamma> (normalize_ports_generic normalize_pos rewrite_neg m) a p \\<longleftrightarrow> matches \\<gamma> m a p\"", "lemma normalize_ports_generic_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"  and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    and noNeg: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\"\n    and normalize_nnf_pos: \"\\<And>m m'.\n        normalized_nnf_match  m \\<Longrightarrow> \\<not> has_disc_negated disc False m \\<Longrightarrow>\n          m' \\<in> set (normalize_pos m) \\<Longrightarrow> normalized_nnf_match m'\"\n    and normalize_pos: \"\\<And>m m'.\n        normalized_nnf_match m \\<Longrightarrow>  \\<not> has_disc_negated disc False m \\<Longrightarrow> \n          \\<forall>m'\\<in>set (normalize_pos m).\n                 normalized_n_primitive (disc,sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) m'\"\n    shows \"\\<forall>m' \\<in> set (normalize_ports_generic normalize_pos rewrite_neg m). \n             normalized_n_primitive (disc,sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) m'\"", "lemma normalize_ports_generic_normalize_positive_ports_step_erule:\n    assumes n: \"normalized_nnf_match m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and noProt: \"\\<forall>a. \\<not> disc (Prot a)\" (*disc is src_ports or dst_ports anyway*)\n      and P: \"P (disc2, sel2) m\"\n      and P1: \"\\<And>a. normalized_nnf_match a \\<Longrightarrow> \n                a \\<in> set (normalize_match (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)) \\<Longrightarrow>\n                P (disc2, sel2) a\"\n      and P2: \"\\<And>a dpts rst. normalized_nnf_match a \\<Longrightarrow> \n                    primitive_extractor (disc, sel) a = (dpts, rst) \\<Longrightarrow>\n                    getNeg dpts = [] \\<Longrightarrow> P (disc2, sel2) a \\<Longrightarrow> P (disc2, sel2) rst\"\n      and P3: \"\\<And> a spt rst. P (disc2, sel2) rst \\<Longrightarrow> P (disc2, sel2) (MatchAnd (Match (C spt)) rst)\"\n    shows \"m' \\<in> set (normalize_ports_generic (normalize_positive_ports_step (disc, sel) C) (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one) m) \\<Longrightarrow>\n          P (disc2, sel2) m'\"", "lemma normalize_ports_generic_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and noProt: \"\\<forall>a. \\<not> disc (Prot a)\" (*disc is src_ports or dst_ports anyway*)\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (C a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated disc False m\"\n    shows \"m' \\<in> set (normalize_ports_generic (normalize_positive_ports_step (disc, sel) C) (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one) m) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f m \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f m'\"", "lemma normalize_ports_generic_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc disc2 m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and noProt: \"\\<forall>a. \\<not> disc (Prot a)\" (*disc is src_ports or dst_ports anyway*)\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (C a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated disc False m\"\n     shows \"m'\\<in> set (normalize_ports_generic (normalize_positive_ports_step (disc, sel) C) (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one) m)\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\"", "lemma normalize_ports_generic_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc_negated disc2 False m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and noProt: \"\\<forall>a. \\<not> disc (Prot a)\" (*disc is src_ports or dst_ports anyway*)\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated disc False m\"\n     shows \"m'\\<in> set (normalize_ports_generic (normalize_positive_ports_step (disc, sel) C) (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one) m)\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 False m'\"", "lemma normalize_src_ports:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    shows \"match_list (\\<beta>, \\<alpha>) (normalize_src_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma normalize_dst_ports:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    shows \"match_list (\\<beta>, \\<alpha>) (normalize_dst_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma normalize_src_ports_normalized_n_primitive:\n    assumes n:\"normalized_nnf_match m\"\n    shows \"\\<forall>m' \\<in> set (normalize_src_ports m). normalized_src_ports m'\"", "lemma normalize_dst_ports_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n    shows \"\\<forall>m' \\<in> set (normalize_dst_ports m). normalized_dst_ports m'\"", "lemma normalize_src_ports_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    shows \"m' \\<in> set (normalize_src_ports m) \\<Longrightarrow> normalized_nnf_match m'\"", "lemma normalize_dst_ports_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    shows \"m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow> normalized_nnf_match m'\"", "lemma normalize_src_ports_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Src_Ports False m\"\n    shows \"m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  m \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f m'\"", "lemma normalize_dst_ports_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Dst_Ports False m\"\n    shows \"m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  m \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f m'\"", "lemma normalize_src_ports_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc disc2 m\"\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Src_Ports False m\"\n     shows \"m'\\<in> set (normalize_src_ports m)\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\"", "lemma normalize_dst_ports_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc disc2 m\"\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Dst_Ports False m\"\n     shows \"m'\\<in> set (normalize_dst_ports m)\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\"", "lemma normalize_src_ports_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc_negated disc2 False m\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Src_Ports False m\"\n     shows \"m'\\<in> set (normalize_src_ports m)\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 False m'\"", "lemma normalize_dst_ports_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc_negated disc2 False m\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Dst_Ports False m\"\n     shows \"m'\\<in> set (normalize_dst_ports m)\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 False m'\"", "lemma \"map opt_MatchAny_match_expr (normalize_src_ports\n                (MatchAnd (Match (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n                   (MatchAnd (Match (Prot (Proto TCP)))\n                        (MatchNot (Match (Src_Ports (L4Ports UDP [(80,80)]))))\n                 ))) =\n [MatchAnd (MatchNot (Match (Prot (Proto UDP)))) (MatchAnd (Match (Dst (IpAddrNetmask 0x7F000000 8))) (Match (Prot (Proto TCP)))),\n  MatchAnd (Match (Src_Ports (L4Ports UDP [(0, 79)]))) (MatchAnd (Match (Dst (IpAddrNetmask 0x7F000000 8))) (Match (Prot (Proto TCP)))),\n  MatchAnd (Match (Src_Ports (L4Ports UDP [(81, 0xFFFF)]))) (MatchAnd (Match (Dst (IpAddrNetmask 0x7F000000 8))) (Match (Prot (Proto TCP))))]\"", "lemma \"map opt_MatchAny_match_expr (normalize_src_ports\n                (MatchAnd (Match (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n                   (MatchAnd (Match (Prot (Proto ICMP)))\n                     (MatchAnd (Match (Src_Ports (L4Ports TCP [(22,22)])))\n                        (MatchNot (Match (Src_Ports (L4Ports UDP [(80,80)]))))\n                 ))))\n =\n[MatchAnd (Match (Src_Ports (L4Ports TCP [(22, 22)])))\n   (MatchAnd (MatchNot (Match (Prot (Proto UDP)))) (MatchAnd (Match (Dst (IpAddrNetmask 0x7F000000 8))) (Match (Prot (Proto ICMP)))))]\"", "lemma \"map opt_MatchAny_match_expr (normalize_src_ports\n                (MatchAnd (Match ((Src_Ports (L4Ports UDP [(21,21), (22,22)])) :: 32 common_primitive))\n                  (Match (Prot (Proto UDP)))))\n  =\n[MatchAnd (Match (Src_Ports (L4Ports UDP [(21, 22)]))) (Match (Prot (Proto UDP)))]\"", "lemma \"normalize_match (andfold_MatchExp (map (l4_ports_negate_one C) [])) = [MatchAny]\"", "lemma replace_primitive_matchexpr_unchanged_if_not_has_disc:\n  assumes n: \"normalized_nnf_match m\"\n  and wf_disc_sel: \"wf_disc_sel (disc,sel) C\" (*any C*)\n  and noDisc: \"\\<not> has_disc disc m\"\n  shows \"replace_primitive_matchexpr (disc,sel) replace_f m = m\"", "lemma replace_primitive_matchexpr:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel disc_sel C\"\n  and replace_f: \"\\<forall>pt. matches \\<gamma> (replace_f pt) a p \\<longleftrightarrow>\n                        matches \\<gamma> (negation_type_to_match_expr_f C pt) a p\"\n  shows \"matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a p \\<longleftrightarrow> matches \\<gamma> m a p\"", "lemma replace_primitive_matchexpr_replaces_disc:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n  and replace_f: \"\\<forall>a. \\<not> has_disc disc (replace_f a)\"\n  shows \"\\<not> has_disc disc (replace_primitive_matchexpr (disc, sel) replace_f m)\"", "lemma replace_primitive_matchexpr_preserves_not_has_disc:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and nodisc: \"\\<not> has_disc disc2 m\"\n  and replace_f: \"has_disc disc m \\<Longrightarrow> \\<forall>pts. \\<not> has_disc disc2 (replace_f pts)\"\n  shows \"\\<not> has_disc disc2 (replace_primitive_matchexpr (disc,sel) replace_f m)\"", "lemma normalize_replace_primitive_matchexpr_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and replace_f:\n        \"\\<And>a m'. m' \\<in> set (normalize_match (replace_f a)) \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'\"\n      and nprim: \"normalized_n_primitive (disc2, sel2) f m\"\n      and m': \"m' \\<in> set (normalize_match (replace_primitive_matchexpr (disc,sel) replace_f m))\"\n    shows \"normalized_n_primitive (disc2, sel2) f m'\"", "lemma normalize_replace_primitive_matchexpr_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" \n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and nodisc: \"\\<not> has_disc disc2 m\"\n      and replace_f: \"\\<And>a. \\<not> has_disc disc2 (replace_f a)\"\n     shows \"m'\\<in> set (normalize_match (replace_primitive_matchexpr (disc,sel) replace_f m))\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\"", "lemma normalize_replace_primitive_matchexpr_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" \n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and nodisc: \"\\<not> has_disc_negated disc2 neg m\"\n      and replace_f: \"\\<And>a. \\<not> has_disc_negated disc2 neg (replace_f a)\"\n     shows \"m'\\<in> set (normalize_match (replace_primitive_matchexpr (disc,sel) replace_f m))\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'\"", "lemma rewrite_MultiportPorts_one:\n  assumes generic: \"primitive_matcher_generic \\<beta>\" and n: \"normalized_nnf_match m\"\n  shows\n    \"matches (\\<beta>, \\<alpha>) (replace_primitive_matchexpr (is_MultiportPorts, multiportports_sel) rewrite_MultiportPorts_one m) a p \\<longleftrightarrow>\n      matches (\\<beta>, \\<alpha>) m a p\"", "lemma \"\\<forall>a. \\<not> disc (Src_Ports a) \\<Longrightarrow> \\<forall>a. \\<not> disc (Dst_Ports a) \\<Longrightarrow>\n          normalized_n_primitive (disc, sel) f m \\<Longrightarrow>\n         \\<forall>m' \\<in> set (normalize_match (rewrite_MultiportPorts_one a)).\n            normalized_n_primitive (disc, sel) f m'\"", "lemma rewrite_MultiportPorts_one_nodisc: \n    \"\\<forall>a. \\<not> disc (Src_Ports a) \\<Longrightarrow> \\<forall>a. \\<not> disc (Dst_Ports a) \\<Longrightarrow>\n          \\<not> has_disc disc (rewrite_MultiportPorts_one a)\"\n    \"\\<forall>a. \\<not> disc (Src_Ports a) \\<Longrightarrow> \\<forall>a. \\<not> disc (Dst_Ports a) \\<Longrightarrow>\n          \\<not> has_disc_negated disc neg (rewrite_MultiportPorts_one a)\"", "lemma rewrite_MultiportPorts:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    shows\n        \"match_list (\\<beta>, \\<alpha>) (rewrite_MultiportPorts m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma rewrite_MultiportPorts_normalized_nnf_match:\n      \"m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow> normalized_nnf_match m'\"", "lemma rewrite_MultiportPorts_unchanged_if_not_has_disc:\n  assumes n: \"normalized_nnf_match m\"\n  and noDisc: \"\\<not> has_disc is_MultiportPorts m\"\n  shows \"rewrite_MultiportPorts m = [m]\"", "lemma rewrite_MultiportPorts_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and disc2_noSrcPorts: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noDstPorts: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n    shows \"m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  m \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f m'\"", "lemma rewrite_MultiportPorts_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" \n      and nodisc: \"\\<not> has_disc disc2 m\"\n      and disc2_noSrcPorts: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noDstPorts: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n     shows \"m'\\<in> set (rewrite_MultiportPorts m)\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\"", "lemma rewrite_MultiportPorts_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" \n      and nodisc: \"\\<not> has_disc_negated disc2 neg m\"\n      and disc2_noSrcPorts: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noDstPorts: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n     shows \"m'\\<in> set (rewrite_MultiportPorts m)\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'\"", "lemma rewrite_MultiportPorts_removes_MultiportsPorts:\n    assumes n: \"normalized_nnf_match m\"\n    shows \"m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow> \\<not> has_disc is_MultiportPorts m'\""], "translations": [["", "lemma normalized_src_ports_def2: \"normalized_src_ports ms = normalized_n_primitive (is_Src_Ports, src_ports_sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_src_ports ms =\n    normalized_n_primitive (is_Src_Ports, src_ports_sel)\n     (\\<lambda>ps.\n         case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n     ms", "by(induction ms rule: normalized_src_ports.induct, simp_all)"], ["", "lemma normalized_dst_ports_def2: \"normalized_dst_ports ms = normalized_n_primitive (is_Dst_Ports, dst_ports_sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_dst_ports ms =\n    normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n     (\\<lambda>ps.\n         case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n     ms", "by(induction ms rule: normalized_dst_ports.induct, simp_all)"], ["", "text\\<open>Idea: first, remove all negated matches, then @{const normalize_match},\n  then only work with @{const primitive_extractor} on @{const Pos} ones.\n  They only need an intersect and split later on. \n\n  This is not very efficient because normalizing nnf will blow up a lot.\n  but we can tune performance later on go for correctness first!\n  Anything with @{const MatchOr} and @{const normalize_match} later is a bit inefficient.\n\\<close>"], ["", "subsection\\<open>Compressing Positive Matches on Ports into a Single Match\\<close>"], ["", "(*compressing positive matches on ports into a single match*)"], ["", "fun l4_ports_compress :: \"ipt_l4_ports list \\<Rightarrow> ipt_l4_ports match_compress\" where\n    \"l4_ports_compress [] = MatchesAll\" | \n    \"l4_ports_compress [L4Ports proto ps] = MatchExpr (L4Ports proto (wi2l (wordinterval_compress (l2wi ps))))\" |\n    \"l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n      (if\n          proto1 \\<noteq> proto2\n       then\n         CannotMatch\n       else\n         l4_ports_compress (L4Ports proto1 (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) # pss)\n      )\""], ["", "value[code] \"l4_ports_compress [L4Ports TCP [(22,22), (23,23)]]\""], ["", "(*only for src*)"], ["", "lemma raw_ports_compress_src_CannotMatch:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = CannotMatch\"\n  shows \"\\<not> matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> matches (\\<beta>, \\<alpha>)\n            (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p", "using c"], ["proof (prove)\nusing this:\n  l4_ports_compress pss = CannotMatch\n\ngoal (1 subgoal):\n 1. \\<not> matches (\\<beta>, \\<alpha>)\n            (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p", "apply(induction pss rule: l4_ports_compress.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. l4_ports_compress [] = CannotMatch \\<Longrightarrow>\n    \\<not> matches (\\<beta>, \\<alpha>)\n            (alist_and (map (Pos \\<circ> Src_Ports) [])) a p\n 2. \\<And>proto ps.\n       l4_ports_compress [L4Ports proto ps] = CannotMatch \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>)\n               (alist_and (map (Pos \\<circ> Src_Ports) [L4Ports proto ps]))\n               a p\n 3. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>\\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                 l4_ports_compress\n                  (L4Ports proto1\n                    (wi2l\n                      (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n                   pss) =\n                 CannotMatch\\<rbrakk>\n                \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n    (alist_and\n      (map (Pos \\<circ> Src_Ports)\n        (L4Ports proto1\n          (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n         pss)))\n    a p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Src_Ports)\n                                     (L4Ports proto1 ps1 #\nL4Ports proto2 ps2 # pss)))\n                                 a p", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>proto ps.\n       l4_ports_compress [L4Ports proto ps] = CannotMatch \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>)\n               (alist_and (map (Pos \\<circ> Src_Ports) [L4Ports proto ps]))\n               a p\n 2. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>\\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                 l4_ports_compress\n                  (L4Ports proto1\n                    (wi2l\n                      (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n                   pss) =\n                 CannotMatch\\<rbrakk>\n                \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n    (alist_and\n      (map (Pos \\<circ> Src_Ports)\n        (L4Ports proto1\n          (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n         pss)))\n    a p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Src_Ports)\n                                     (L4Ports proto1 ps1 #\nL4Ports proto2 ps2 # pss)))\n                                 a p", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>\\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                 l4_ports_compress\n                  (L4Ports proto1\n                    (wi2l\n                      (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n                   pss) =\n                 CannotMatch\\<rbrakk>\n                \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n    (alist_and\n      (map (Pos \\<circ> Src_Ports)\n        (L4Ports proto1\n          (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n         pss)))\n    a p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Src_Ports)\n                                     (L4Ports proto1 ps1 #\nL4Ports proto2 ps2 # pss)))\n                                 a p", "apply(simp add: primitive_matcher_generic.Ports_single[OF generic] bunch_of_lemmata_about_matches split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>proto1 ps1 proto2 ps2 pss.\n       proto1 \\<noteq> proto2 \\<Longrightarrow>\n       p_sport p \\<in> ports_to_set ps2 \\<longrightarrow>\n       proto2 = p_proto p \\<longrightarrow>\n       p_sport p \\<in> ports_to_set ps1 \\<longrightarrow>\n       proto1 = p_proto p \\<longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>)\n               (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p\n 2. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>p_sport p\n                \\<in> ports_to_set\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) \\<longrightarrow>\n                proto2 = p_proto p \\<longrightarrow>\n                \\<not> matches (\\<beta>, \\<alpha>)\n                        (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p;\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> p_sport p \\<in> ports_to_set ps2 \\<longrightarrow>\n                         proto2 = p_proto p \\<longrightarrow>\n                         p_sport p \\<in> ports_to_set ps1 \\<longrightarrow>\n                         \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Src_Ports) pss))\n                                 a p", "apply meson"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>p_sport p\n                \\<in> ports_to_set\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) \\<longrightarrow>\n                proto2 = p_proto p \\<longrightarrow>\n                \\<not> matches (\\<beta>, \\<alpha>)\n                        (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p;\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> p_sport p \\<in> ports_to_set ps2 \\<longrightarrow>\n                         proto2 = p_proto p \\<longrightarrow>\n                         p_sport p \\<in> ports_to_set ps1 \\<longrightarrow>\n                         \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Src_Ports) pss))\n                                 a p", "by(simp add: l2wi_wi2l ports_to_set_wordinterval)"], ["", "lemma raw_ports_compress_dst_CannotMatch:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = CannotMatch\"\n  shows \"\\<not> matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> matches (\\<beta>, \\<alpha>)\n            (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p", "using c"], ["proof (prove)\nusing this:\n  l4_ports_compress pss = CannotMatch\n\ngoal (1 subgoal):\n 1. \\<not> matches (\\<beta>, \\<alpha>)\n            (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p", "apply(induction pss rule: l4_ports_compress.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. l4_ports_compress [] = CannotMatch \\<Longrightarrow>\n    \\<not> matches (\\<beta>, \\<alpha>)\n            (alist_and (map (Pos \\<circ> Dst_Ports) [])) a p\n 2. \\<And>proto ps.\n       l4_ports_compress [L4Ports proto ps] = CannotMatch \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>)\n               (alist_and (map (Pos \\<circ> Dst_Ports) [L4Ports proto ps]))\n               a p\n 3. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>\\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                 l4_ports_compress\n                  (L4Ports proto1\n                    (wi2l\n                      (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n                   pss) =\n                 CannotMatch\\<rbrakk>\n                \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n    (alist_and\n      (map (Pos \\<circ> Dst_Ports)\n        (L4Ports proto1\n          (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n         pss)))\n    a p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Dst_Ports)\n                                     (L4Ports proto1 ps1 #\nL4Ports proto2 ps2 # pss)))\n                                 a p", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>proto ps.\n       l4_ports_compress [L4Ports proto ps] = CannotMatch \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>)\n               (alist_and (map (Pos \\<circ> Dst_Ports) [L4Ports proto ps]))\n               a p\n 2. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>\\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                 l4_ports_compress\n                  (L4Ports proto1\n                    (wi2l\n                      (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n                   pss) =\n                 CannotMatch\\<rbrakk>\n                \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n    (alist_and\n      (map (Pos \\<circ> Dst_Ports)\n        (L4Ports proto1\n          (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n         pss)))\n    a p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Dst_Ports)\n                                     (L4Ports proto1 ps1 #\nL4Ports proto2 ps2 # pss)))\n                                 a p", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>\\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                 l4_ports_compress\n                  (L4Ports proto1\n                    (wi2l\n                      (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n                   pss) =\n                 CannotMatch\\<rbrakk>\n                \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n    (alist_and\n      (map (Pos \\<circ> Dst_Ports)\n        (L4Ports proto1\n          (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n         pss)))\n    a p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Dst_Ports)\n                                     (L4Ports proto1 ps1 #\nL4Ports proto2 ps2 # pss)))\n                                 a p", "apply(simp add: primitive_matcher_generic.Ports_single[OF generic] bunch_of_lemmata_about_matches split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>proto1 ps1 proto2 ps2 pss.\n       proto1 \\<noteq> proto2 \\<Longrightarrow>\n       p_dport p \\<in> ports_to_set ps2 \\<longrightarrow>\n       proto2 = p_proto p \\<longrightarrow>\n       p_dport p \\<in> ports_to_set ps1 \\<longrightarrow>\n       proto1 = p_proto p \\<longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>)\n               (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p\n 2. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>p_dport p\n                \\<in> ports_to_set\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) \\<longrightarrow>\n                proto2 = p_proto p \\<longrightarrow>\n                \\<not> matches (\\<beta>, \\<alpha>)\n                        (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p;\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> p_dport p \\<in> ports_to_set ps2 \\<longrightarrow>\n                         proto2 = p_proto p \\<longrightarrow>\n                         p_dport p \\<in> ports_to_set ps1 \\<longrightarrow>\n                         \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Dst_Ports) pss))\n                                 a p", "apply meson"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>p_dport p\n                \\<in> ports_to_set\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) \\<longrightarrow>\n                proto2 = p_proto p \\<longrightarrow>\n                \\<not> matches (\\<beta>, \\<alpha>)\n                        (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p;\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        CannotMatch\\<rbrakk>\n       \\<Longrightarrow> p_dport p \\<in> ports_to_set ps2 \\<longrightarrow>\n                         proto2 = p_proto p \\<longrightarrow>\n                         p_dport p \\<in> ports_to_set ps1 \\<longrightarrow>\n                         \\<not> matches (\\<beta>, \\<alpha>)\n                                 (alist_and\n                                   (map (Pos \\<circ> Dst_Ports) pss))\n                                 a p", "by(simp add: l2wi_wi2l ports_to_set_wordinterval)"], ["", "lemma l4_ports_compress_length_Matchall: \"length pss > 0 \\<Longrightarrow> l4_ports_compress pss \\<noteq> MatchesAll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length pss \\<Longrightarrow>\n    l4_ports_compress pss \\<noteq> MatchesAll", "by(induction pss rule: l4_ports_compress.induct) simp+"], ["", "lemma raw_ports_compress_MatchesAll:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = MatchesAll\"\n  shows \"matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p\"\n  and \"matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p &&&\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p", "using c"], ["proof (prove)\nusing this:\n  l4_ports_compress pss = MatchesAll\n\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p &&&\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p", "apply(induction pss rule: l4_ports_compress.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. l4_ports_compress [] = MatchesAll \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Src_Ports) []))\n     a p\n 2. l4_ports_compress [] = MatchesAll \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Dst_Ports) []))\n     a p\n 3. \\<And>proto ps.\n       l4_ports_compress [L4Ports proto ps] = MatchesAll \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (map (Pos \\<circ> Src_Ports) [L4Ports proto ps])) a p\n 4. \\<And>proto ps.\n       l4_ports_compress [L4Ports proto ps] = MatchesAll \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (map (Pos \\<circ> Dst_Ports) [L4Ports proto ps])) a p\n 5. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>\\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                 l4_ports_compress\n                  (L4Ports proto1\n                    (wi2l\n                      (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n                   pss) =\n                 MatchesAll\\<rbrakk>\n                \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                                   (alist_and\n                                     (map (Pos \\<circ> Src_Ports)\n (L4Ports proto1 (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n  pss)))\n                                   a p;\n        \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n         l4_ports_compress\n          (L4Ports proto1\n            (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n           pss) =\n         MatchesAll\\<rbrakk>\n        \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                           (alist_and\n                             (map (Pos \\<circ> Dst_Ports)\n                               (L4Ports proto1\n                                 (wi2l\n                                   (wordinterval_intersection (l2wi ps1)\n                                     (l2wi ps2))) #\n                                pss)))\n                           a p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchesAll\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Src_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p\n 6. \\<And>proto1 ps1 proto2 ps2 pss.\n       \\<lbrakk>\\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                 l4_ports_compress\n                  (L4Ports proto1\n                    (wi2l\n                      (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n                   pss) =\n                 MatchesAll\\<rbrakk>\n                \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                                   (alist_and\n                                     (map (Pos \\<circ> Src_Ports)\n (L4Ports proto1 (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n  pss)))\n                                   a p;\n        \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n         l4_ports_compress\n          (L4Ports proto1\n            (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n           pss) =\n         MatchesAll\\<rbrakk>\n        \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                           (alist_and\n                             (map (Pos \\<circ> Dst_Ports)\n                               (L4Ports proto1\n                                 (wi2l\n                                   (wordinterval_intersection (l2wi ps1)\n                                     (l2wi ps2))) #\n                                pss)))\n                           a p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchesAll\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Dst_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "by(simp add: l4_ports_compress_length_Matchall bunch_of_lemmata_about_matches split: if_split_asm)+"], ["", "lemma raw_ports_compress_src_MatchExpr:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = MatchExpr m\"\n  shows \"matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p =\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p", "using c"], ["proof (prove)\nusing this:\n  l4_ports_compress pss = MatchExpr m\n\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p =\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p", "apply(induction pss arbitrary: m rule: l4_ports_compress.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       l4_ports_compress [] = MatchExpr m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p =\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (map (Pos \\<circ> Src_Ports) [])) a p\n 2. \\<And>proto ps m.\n       l4_ports_compress [L4Ports proto ps] = MatchExpr m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p =\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (map (Pos \\<circ> Src_Ports) [L4Ports proto ps])) a p\n 3. \\<And>proto1 ps1 proto2 ps2 pss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                    l4_ports_compress\n                     (L4Ports proto1\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) #\n                      pss) =\n                    MatchExpr m\\<rbrakk>\n                   \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n(Match (Src_Ports m)) a p =\n                                     matches (\\<beta>, \\<alpha>)\n(alist_and\n  (map (Pos \\<circ> Src_Ports)\n    (L4Ports proto1\n      (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n     pss)))\na p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchExpr m\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a\n                          p =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Src_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "apply(simp add: bunch_of_lemmata_about_matches; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>proto ps m.\n       l4_ports_compress [L4Ports proto ps] = MatchExpr m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p =\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (map (Pos \\<circ> Src_Ports) [L4Ports proto ps])) a p\n 2. \\<And>proto1 ps1 proto2 ps2 pss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                    l4_ports_compress\n                     (L4Ports proto1\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) #\n                      pss) =\n                    MatchExpr m\\<rbrakk>\n                   \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n(Match (Src_Ports m)) a p =\n                                     matches (\\<beta>, \\<alpha>)\n(alist_and\n  (map (Pos \\<circ> Src_Ports)\n    (L4Ports proto1\n      (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n     pss)))\na p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchExpr m\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a\n                          p =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Src_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l4_ports_compress [L4Ports proto_ ps_] = MatchExpr m_ \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>) (Match (Src_Ports m_)) a p =\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Src_Ports) [L4Ports proto_ ps_])) a p", "apply(simp add: bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. L4Ports proto_ (wi2l (wordinterval_compress (l2wi ps_))) =\n    m_ \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>) (Match (Src_Ports m_)) a p =\n    matches (\\<beta>, \\<alpha>) (Match (Src_Ports (L4Ports proto_ ps_))) a p", "apply(drule sym, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m_ =\n    L4Ports proto_\n     (wi2l (wordinterval_compress (l2wi ps_))) \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>)\n     (Match\n       (Src_Ports\n         (L4Ports proto_ (wi2l (wordinterval_compress (l2wi ps_))))))\n     a p =\n    matches (\\<beta>, \\<alpha>) (Match (Src_Ports (L4Ports proto_ ps_))) a p", "by(simp add: primitive_matcher_generic.Ports_single[OF generic] wordinterval_compress l2wi_wi2l ports_to_set_wordinterval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                    l4_ports_compress\n                     (L4Ports proto1\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) #\n                      pss) =\n                    MatchExpr m\\<rbrakk>\n                   \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n(Match (Src_Ports m)) a p =\n                                     matches (\\<beta>, \\<alpha>)\n(alist_and\n  (map (Pos \\<circ> Src_Ports)\n    (L4Ports proto1\n      (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n     pss)))\na p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchExpr m\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a\n                          p =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Src_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "apply(case_tac m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m x1 x2.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                    l4_ports_compress\n                     (L4Ports proto1\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) #\n                      pss) =\n                    MatchExpr m\\<rbrakk>\n                   \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n(Match (Src_Ports m)) a p =\n                                     matches (\\<beta>, \\<alpha>)\n(alist_and\n  (map (Pos \\<circ> Src_Ports)\n    (L4Ports proto1\n      (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n     pss)))\na p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchExpr m;\n        m = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a\n                          p =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Src_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "apply(simp add: bunch_of_lemmata_about_matches split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m x1 x2.\n       \\<lbrakk>m = L4Ports x1 x2;\n        matches (\\<beta>, \\<alpha>) (Match (Src_Ports (L4Ports x1 x2))) a\n         p =\n        (matches (\\<beta>, \\<alpha>)\n          (Match\n            (Src_Ports\n              (L4Ports proto2\n                (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))))))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>)\n          (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p);\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        MatchExpr (L4Ports x1 x2)\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (Match\n                             (Src_Ports\n                               (L4Ports proto2\n                                 (wi2l\n                                   (wordinterval_intersection (l2wi ps1)\n                                     (l2wi ps2))))))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Src_Ports) pss)) a\n                           p) =\n                         (matches (\\<beta>, \\<alpha>)\n                           (Match (Src_Ports (L4Ports proto2 ps1))) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (Match (Src_Ports (L4Ports proto2 ps2))) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Src_Ports) pss)) a\n                           p)", "apply(simp add: primitive_matcher_generic.Ports_single[OF generic])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m x1 x2.\n       \\<lbrakk>m = L4Ports x1 x2;\n        (x1 = p_proto p \\<and> p_sport p \\<in> ports_to_set x2) =\n        (proto2 = p_proto p \\<and>\n         p_sport p\n         \\<in> ports_to_set\n                (wi2l\n                  (wordinterval_intersection (l2wi ps1) (l2wi ps2))) \\<and>\n         matches (\\<beta>, \\<alpha>)\n          (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p);\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        MatchExpr (L4Ports x1 x2)\\<rbrakk>\n       \\<Longrightarrow> (proto2 = p_proto p \\<and>\n                          p_sport p\n                          \\<in> ports_to_set\n                                 (wi2l\n                                   (wordinterval_intersection (l2wi ps1)\n                                     (l2wi ps2))) \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Src_Ports) pss)) a\n                           p) =\n                         (proto2 = p_proto p \\<and>\n                          p_sport p \\<in> ports_to_set ps1 \\<and>\n                          proto2 = p_proto p \\<and>\n                          p_sport p \\<in> ports_to_set ps2 \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Src_Ports) pss)) a\n                           p)", "apply(simp add: l2wi_wi2l ports_to_set_wordinterval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m x1 x2.\n       \\<lbrakk>m = L4Ports x1 x2;\n        (x1 = p_proto p \\<and>\n         p_sport p \\<in> wordinterval_to_set (l2wi x2)) =\n        (proto2 = p_proto p \\<and>\n         p_sport p \\<in> wordinterval_to_set (l2wi ps1) \\<and>\n         p_sport p \\<in> wordinterval_to_set (l2wi ps2) \\<and>\n         matches (\\<beta>, \\<alpha>)\n          (alist_and (map (Pos \\<circ> Src_Ports) pss)) a p);\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        MatchExpr (L4Ports x1 x2)\\<rbrakk>\n       \\<Longrightarrow> (proto2 = p_proto p \\<and>\n                          p_sport p\n                          \\<in> wordinterval_to_set (l2wi ps1) \\<and>\n                          p_sport p\n                          \\<in> wordinterval_to_set (l2wi ps2) \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Src_Ports) pss)) a\n                           p) =\n                         (proto2 = p_proto p \\<and>\n                          p_sport p\n                          \\<in> wordinterval_to_set (l2wi ps1) \\<and>\n                          proto2 = p_proto p \\<and>\n                          p_sport p\n                          \\<in> wordinterval_to_set (l2wi ps2) \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Src_Ports) pss)) a\n                           p)", "by fastforce"], ["", "lemma raw_ports_compress_dst_MatchExpr:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  and c: \"l4_ports_compress pss = MatchExpr m\"\n  shows \"matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p =\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p", "using c"], ["proof (prove)\nusing this:\n  l4_ports_compress pss = MatchExpr m\n\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p =\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p", "apply(induction pss arbitrary: m rule: l4_ports_compress.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       l4_ports_compress [] = MatchExpr m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p =\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (map (Pos \\<circ> Dst_Ports) [])) a p\n 2. \\<And>proto ps m.\n       l4_ports_compress [L4Ports proto ps] = MatchExpr m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p =\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (map (Pos \\<circ> Dst_Ports) [L4Ports proto ps])) a p\n 3. \\<And>proto1 ps1 proto2 ps2 pss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                    l4_ports_compress\n                     (L4Ports proto1\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) #\n                      pss) =\n                    MatchExpr m\\<rbrakk>\n                   \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n(Match (Dst_Ports m)) a p =\n                                     matches (\\<beta>, \\<alpha>)\n(alist_and\n  (map (Pos \\<circ> Dst_Ports)\n    (L4Ports proto1\n      (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n     pss)))\na p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchExpr m\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a\n                          p =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Dst_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "apply(simp add: bunch_of_lemmata_about_matches; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>proto ps m.\n       l4_ports_compress [L4Ports proto ps] = MatchExpr m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p =\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (map (Pos \\<circ> Dst_Ports) [L4Ports proto ps])) a p\n 2. \\<And>proto1 ps1 proto2 ps2 pss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                    l4_ports_compress\n                     (L4Ports proto1\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) #\n                      pss) =\n                    MatchExpr m\\<rbrakk>\n                   \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n(Match (Dst_Ports m)) a p =\n                                     matches (\\<beta>, \\<alpha>)\n(alist_and\n  (map (Pos \\<circ> Dst_Ports)\n    (L4Ports proto1\n      (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n     pss)))\na p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchExpr m\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a\n                          p =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Dst_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l4_ports_compress [L4Ports proto_ ps_] = MatchExpr m_ \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m_)) a p =\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (map (Pos \\<circ> Dst_Ports) [L4Ports proto_ ps_])) a p", "apply(simp add: bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. L4Ports proto_ (wi2l (wordinterval_compress (l2wi ps_))) =\n    m_ \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m_)) a p =\n    matches (\\<beta>, \\<alpha>) (Match (Dst_Ports (L4Ports proto_ ps_))) a p", "apply(drule sym, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m_ =\n    L4Ports proto_\n     (wi2l (wordinterval_compress (l2wi ps_))) \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>)\n     (Match\n       (Dst_Ports\n         (L4Ports proto_ (wi2l (wordinterval_compress (l2wi ps_))))))\n     a p =\n    matches (\\<beta>, \\<alpha>) (Match (Dst_Ports (L4Ports proto_ ps_))) a p", "by(simp add: primitive_matcher_generic.Ports_single[OF generic] wordinterval_compress l2wi_wi2l ports_to_set_wordinterval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                    l4_ports_compress\n                     (L4Ports proto1\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) #\n                      pss) =\n                    MatchExpr m\\<rbrakk>\n                   \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n(Match (Dst_Ports m)) a p =\n                                     matches (\\<beta>, \\<alpha>)\n(alist_and\n  (map (Pos \\<circ> Dst_Ports)\n    (L4Ports proto1\n      (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n     pss)))\na p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchExpr m\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a\n                          p =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Dst_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "apply(case_tac m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m x1 x2.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<not> proto1 \\<noteq> proto2;\n                    l4_ports_compress\n                     (L4Ports proto1\n                       (wi2l\n                         (wordinterval_intersection (l2wi ps1)\n                           (l2wi ps2))) #\n                      pss) =\n                    MatchExpr m\\<rbrakk>\n                   \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n(Match (Dst_Ports m)) a p =\n                                     matches (\\<beta>, \\<alpha>)\n(alist_and\n  (map (Pos \\<circ> Dst_Ports)\n    (L4Ports proto1\n      (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n     pss)))\na p;\n        l4_ports_compress (L4Ports proto1 ps1 # L4Ports proto2 ps2 # pss) =\n        MatchExpr m;\n        m = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a\n                          p =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and\n                            (map (Pos \\<circ> Dst_Ports)\n                              (L4Ports proto1 ps1 #\n                               L4Ports proto2 ps2 # pss)))\n                          a p", "apply(simp add: bunch_of_lemmata_about_matches split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m x1 x2.\n       \\<lbrakk>m = L4Ports x1 x2;\n        matches (\\<beta>, \\<alpha>) (Match (Dst_Ports (L4Ports x1 x2))) a\n         p =\n        (matches (\\<beta>, \\<alpha>)\n          (Match\n            (Dst_Ports\n              (L4Ports proto2\n                (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))))))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>)\n          (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p);\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        MatchExpr (L4Ports x1 x2)\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (Match\n                             (Dst_Ports\n                               (L4Ports proto2\n                                 (wi2l\n                                   (wordinterval_intersection (l2wi ps1)\n                                     (l2wi ps2))))))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a\n                           p) =\n                         (matches (\\<beta>, \\<alpha>)\n                           (Match (Dst_Ports (L4Ports proto2 ps1))) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (Match (Dst_Ports (L4Ports proto2 ps2))) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a\n                           p)", "apply(simp add: primitive_matcher_generic.Ports_single[OF generic])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m x1 x2.\n       \\<lbrakk>m = L4Ports x1 x2;\n        (x1 = p_proto p \\<and> p_dport p \\<in> ports_to_set x2) =\n        (proto2 = p_proto p \\<and>\n         p_dport p\n         \\<in> ports_to_set\n                (wi2l\n                  (wordinterval_intersection (l2wi ps1) (l2wi ps2))) \\<and>\n         matches (\\<beta>, \\<alpha>)\n          (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p);\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        MatchExpr (L4Ports x1 x2)\\<rbrakk>\n       \\<Longrightarrow> (proto2 = p_proto p \\<and>\n                          p_dport p\n                          \\<in> ports_to_set\n                                 (wi2l\n                                   (wordinterval_intersection (l2wi ps1)\n                                     (l2wi ps2))) \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a\n                           p) =\n                         (proto2 = p_proto p \\<and>\n                          p_dport p \\<in> ports_to_set ps1 \\<and>\n                          proto2 = p_proto p \\<and>\n                          p_dport p \\<in> ports_to_set ps2 \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a\n                           p)", "apply(simp add: l2wi_wi2l ports_to_set_wordinterval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto1 ps1 proto2 ps2 pss m x1 x2.\n       \\<lbrakk>m = L4Ports x1 x2;\n        (x1 = p_proto p \\<and>\n         p_dport p \\<in> wordinterval_to_set (l2wi x2)) =\n        (proto2 = p_proto p \\<and>\n         p_dport p \\<in> wordinterval_to_set (l2wi ps1) \\<and>\n         p_dport p \\<in> wordinterval_to_set (l2wi ps2) \\<and>\n         matches (\\<beta>, \\<alpha>)\n          (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a p);\n        proto1 = proto2;\n        l4_ports_compress\n         (L4Ports proto2\n           (wi2l (wordinterval_intersection (l2wi ps1) (l2wi ps2))) #\n          pss) =\n        MatchExpr (L4Ports x1 x2)\\<rbrakk>\n       \\<Longrightarrow> (proto2 = p_proto p \\<and>\n                          p_dport p\n                          \\<in> wordinterval_to_set (l2wi ps1) \\<and>\n                          p_dport p\n                          \\<in> wordinterval_to_set (l2wi ps2) \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a\n                           p) =\n                         (proto2 = p_proto p \\<and>\n                          p_dport p\n                          \\<in> wordinterval_to_set (l2wi ps1) \\<and>\n                          proto2 = p_proto p \\<and>\n                          p_dport p\n                          \\<in> wordinterval_to_set (l2wi ps2) \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (map (Pos \\<circ> Dst_Ports) pss)) a\n                           p)", "by fastforce"], ["", "subsection\\<open>Rewriting Negated Matches on Ports\\<close>"], ["", "fun l4_ports_negate_one\n    :: \"(ipt_l4_ports \\<Rightarrow> 'i common_primitive) \\<Rightarrow> ipt_l4_ports \\<Rightarrow> ('i::len common_primitive) match_expr\"\n  where\n    \"l4_ports_negate_one C (L4Ports proto pts) = MatchOr\n           (MatchNot (Match (Prot (Proto proto))))\n            (Match (C (L4Ports proto (raw_ports_invert pts))))\""], ["", "lemma l4_ports_negate_one:\n  fixes p :: \"('i::len, 'a) tagged_packet_scheme\"\n  assumes generic: \"primitive_matcher_generic \\<beta>\"\n  shows \"matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Src_Ports ports) a p \\<longleftrightarrow>\n          matches (\\<beta>, \\<alpha>) (MatchNot (Match (Src_Ports ports))) a p\"\n  and \"matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Dst_Ports ports) a p \\<longleftrightarrow>\n          matches (\\<beta>, \\<alpha>) (MatchNot (Match (Dst_Ports ports))) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Src_Ports ports) a p =\n    matches (\\<beta>, \\<alpha>) (MatchNot (Match (Src_Ports ports))) a p &&&\n    matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Dst_Ports ports) a p =\n    matches (\\<beta>, \\<alpha>) (MatchNot (Match (Dst_Ports ports))) a p", "apply(case_tac [!] ports)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       ports = L4Ports x1 x2 \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Src_Ports ports) a\n        p =\n       matches (\\<beta>, \\<alpha>) (MatchNot (Match (Src_Ports ports))) a p\n 2. \\<And>x1 x2.\n       ports = L4Ports x1 x2 \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Dst_Ports ports) a\n        p =\n       matches (\\<beta>, \\<alpha>) (MatchNot (Match (Dst_Ports ports))) a p", "by(auto simp add: primitive_matcher_generic.Ports_single_not[OF generic]\n                    MatchOr bunch_of_lemmata_about_matches\n                    primitive_matcher_generic.Prot_single_not[OF generic]\n                    primitive_matcher_generic.Ports_single[OF generic]\n                    raw_ports_invert)"], ["", "lemma l4_ports_negate_one_nodisc:\n    \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> \\<forall>a. \\<not> disc (Prot a) \\<Longrightarrow> \\<not> has_disc disc (l4_ports_negate_one C pt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc (l4_ports_negate_one C pt)", "apply(cases pt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n        \\<forall>a. \\<not> disc (Prot a); pt = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc (l4_ports_negate_one C pt)", "by(simp add: MatchOr_def)"], ["", "lemma l4_ports_negate_one_not_has_disc_negated_generic:\n    assumes noProt: \"\\<forall>a. \\<not> disc (Prot a)\"\n    shows \"\\<not> has_disc_negated disc False (l4_ports_negate_one C ports)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False (l4_ports_negate_one C ports)", "apply(cases ports, rename_tac proto pts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto pts.\n       ports = L4Ports proto pts \\<Longrightarrow>\n       \\<not> has_disc_negated disc False (l4_ports_negate_one C ports)", "by(simp add: MatchOr_def noProt)"], ["", "lemma l4_ports_negate_one_not_has_disc_negated:\n    \"\\<not> has_disc_negated is_Src_Ports False (l4_ports_negate_one Src_Ports ports)\"\n    \"\\<not> has_disc_negated is_Dst_Ports False (l4_ports_negate_one Dst_Ports ports)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Src_Ports False\n            (l4_ports_negate_one Src_Ports ports) &&&\n    \\<not> has_disc_negated is_Dst_Ports False\n            (l4_ports_negate_one Dst_Ports ports)", "by(simp add: l4_ports_negate_one_not_has_disc_negated_generic)+"], ["", "lemma negated_normalized_folded_ports_nodisc:\n    \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [] \\<Longrightarrow>\n     m \\<in> set (normalize_match (andfold_MatchExp (map (l4_ports_negate_one C) pts))) \\<Longrightarrow>\n      \\<not> has_disc disc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "apply(subgoal_tac \"\\<not> has_disc disc (andfold_MatchExp (map (l4_ports_negate_one C) pts))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (andfold_MatchExp\n                                (map (l4_ports_negate_one C) pts))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (andfold_MatchExp\n                                (map (l4_ports_negate_one C) pts))\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "apply(rule andfold_MatchExp_not_discI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set (map (l4_ports_negate_one C) pts).\n                         \\<not> has_disc disc m\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set pts.\n                         \\<not> has_disc disc (l4_ports_negate_one C m)\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "apply(elim disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set pts.\n                         \\<not> has_disc disc (l4_ports_negate_one C m)\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     pts = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set pts.\n                         \\<not> has_disc disc (l4_ports_negate_one C m)\n 3. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "using l4_ports_negate_one_nodisc"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. \\<not> ?disc (?C a);\n   \\<forall>a. \\<not> ?disc (Prot a)\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc ?disc (l4_ports_negate_one ?C ?pt)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set pts.\n                         \\<not> has_disc disc (l4_ports_negate_one C m)\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     pts = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set pts.\n                         \\<not> has_disc disc (l4_ports_negate_one C m)\n 3. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     pts = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set pts.\n                         \\<not> has_disc disc (l4_ports_negate_one C m)\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "using normalize_match_preserves_nodisc"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> has_disc ?disc ?m;\n   ?m' \\<in> set (normalize_match ?m)\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc ?disc ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     m \\<in> set (normalize_match\n                   (andfold_MatchExp (map (l4_ports_negate_one C) pts)));\n     \\<not> has_disc disc\n             (andfold_MatchExp (map (l4_ports_negate_one C) pts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m", "by blast"], ["", "lemma negated_normalized_folded_ports_normalized_n_primitive:\n    \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [] \\<Longrightarrow>\n     x \\<in> set (normalize_match (andfold_MatchExp (map (l4_ports_negate_one C) pts))) \\<Longrightarrow>\n      normalized_n_primitive (disc, sel) f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f x", "apply(rule normalized_n_primitive_if_no_primitive)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match x\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc x", "using normalized_nnf_match_normalize_match"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_match ?m). normalized_nnf_match m'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match x\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc x", "apply(rule negated_normalized_folded_ports_nodisc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a. \\<not> disc (?C28 a)\n 2. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<or> ?pts28 = []\n 3. \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n     (\\<forall>a. \\<not> disc (Prot a)) \\<or> pts = [];\n     x \\<in> set (normalize_match\n                   (andfold_MatchExp\n                     (map (l4_ports_negate_one C) pts)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (normalize_match\n                                    (andfold_MatchExp\n(map (l4_ports_negate_one ?C28) ?pts28)))", "by simp_all"], ["", "text\\<open>beware, the result is not nnf normalized!\\<close>"], ["", "lemma \"\\<not> normalized_nnf_match (l4_ports_negate_one C ports)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> normalized_nnf_match (l4_ports_negate_one C ports)", "by(cases ports) (simp add: MatchOr_def)"], ["", "text\\<open>Warning: does not preserve negated primitive property in general.\n       Might be violated for @{const Prot}. We will nnf normalize after applying the function.\\<close>"], ["", "lemma \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> \\<not> normalized_n_primitive (disc, sel) f (l4_ports_negate_one C a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. \\<not> disc (C a) \\<Longrightarrow>\n    \\<not> normalized_n_primitive (disc, sel) f (l4_ports_negate_one C a)", "by(cases a)(simp add: MatchOr_def)"], ["", "declare l4_ports_negate_one.simps[simp del]"], ["", "lemma \"((normalize_match (l4_ports_negate_one Src_Ports (L4Ports TCP [(22,22),(80,90)]))):: 32 common_primitive match_expr list)\n    =\n    [ MatchNot (Match (Prot (Proto TCP)))\n    , Match (Src_Ports (L4Ports 6 [(0, 21), (23, 79), (91, 0xFFFF)]))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_match\n     (l4_ports_negate_one Src_Ports (L4Ports TCP [(22, 22), (80, 90)])) =\n    [MatchNot (Match (Prot (Proto TCP))),\n     Match (Src_Ports (L4Ports 6 [(0, 21), (23, 79), (91, 65535)]))]", "by eval"], ["", "(*TODO: this one is generic, move?*)"], ["", "definition rewrite_negated_primitives\n    :: \"(('a \\<Rightarrow> bool) \\<times> ('a \\<Rightarrow> 'b)) \\<Rightarrow> ('b \\<Rightarrow> 'a) \\<Rightarrow> \\<comment> \\<open>\\<open>disc_sel C\\<close>\\<close>\n        (('b \\<Rightarrow> 'a) \\<Rightarrow> 'b \\<Rightarrow> 'a match_expr) \\<Rightarrow> \\<comment> \\<open>\\<open>negate_one\\<close> function\\<close>\n        'a match_expr \\<Rightarrow> 'a match_expr\" where\n    \"rewrite_negated_primitives disc_sel C negate m \\<equiv>\n        let (spts, rst) = primitive_extractor disc_sel m\n        in if getNeg spts = [] then m else \n          MatchAnd\n            (andfold_MatchExp (map (negate C) (getNeg spts)))\n            (MatchAnd\n              (andfold_MatchExp (map (Match \\<circ> C) (getPos spts))) \\<comment> \\<open>TODO: compress all the positive ports into one?\\<close>\n            rst)\""], ["", "text\\<open>It does nothing of there is not even a negated primitive in it\\<close>"], ["", "lemma rewrite_negated_primitives_unchanged_if_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\"\n  and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and noDisc: \"\\<not> has_disc_negated disc False m\"\n  shows \"rewrite_negated_primitives (disc,sel) C negate_f m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rewrite_negated_primitives (disc, sel) C negate_f m = m", "apply(simp add: rewrite_negated_primitives_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case primitive_extractor (disc, sel) m of\n     (spts, rst) \\<Rightarrow>\n       if getNeg spts = [] then m\n       else MatchAnd (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n             (MatchAnd\n               (andfold_MatchExp (map (Match \\<circ> C) (getPos spts)))\n               rst)) =\n    m", "apply(case_tac \"primitive_extractor (disc,sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       (case primitive_extractor (disc, sel) m of\n        (spts, rst) \\<Rightarrow>\n          if getNeg spts = [] then m\n          else MatchAnd (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n                (MatchAnd\n                  (andfold_MatchExp (map (Match \\<circ> C) (getPos spts)))\n                  rst)) =\n       m", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       getNeg spts \\<noteq> [] \\<longrightarrow>\n       MatchAnd (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n        (MatchAnd (andfold_MatchExp (map (Match \\<circ> C) (getPos spts)))\n          rst) =\n       m", "apply(frule primitive_extractor_correct(8)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = [])\\<rbrakk>\n       \\<Longrightarrow> getNeg spts \\<noteq> [] \\<longrightarrow>\n                         MatchAnd\n                          (andfold_MatchExp\n                            (map (negate_f C) (getNeg spts)))\n                          (MatchAnd\n                            (andfold_MatchExp\n                              (map (Match \\<circ> C) (getPos spts)))\n                            rst) =\n                         m", "using noDisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc False m\n\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = [])\\<rbrakk>\n       \\<Longrightarrow> getNeg spts \\<noteq> [] \\<longrightarrow>\n                         MatchAnd\n                          (andfold_MatchExp\n                            (map (negate_f C) (getNeg spts)))\n                          (MatchAnd\n                            (andfold_MatchExp\n                              (map (Match \\<circ> C) (getPos spts)))\n                            rst) =\n                         m", "by blast"], ["", "lemma rewrite_negated_primitives_normalized_no_modification:\n    assumes wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n    and disc_p: \"\\<not> has_disc_negated disc False m\"\n    and n: \"normalized_nnf_match m\"\n    and a: \"a \\<in> set (normalize_match (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m))\"\n    shows \"a = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = m", "from rewrite_negated_primitives_unchanged_if_not_has_disc_negated[OF n wf_disc_sel disc_p]"], ["proof (chain)\npicking this:\n  rewrite_negated_primitives (disc, sel) C ?negate_f m = m", "have m: \"rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m = m\""], ["proof (prove)\nusing this:\n  rewrite_negated_primitives (disc, sel) C ?negate_f m = m\n\ngoal (1 subgoal):\n 1. rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m = m", "by simp"], ["proof (state)\nthis:\n  rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m = m\n\ngoal (1 subgoal):\n 1. a = m", "from a"], ["proof (chain)\npicking this:\n  a \\<in> set (normalize_match\n                (rewrite_negated_primitives (disc, sel) C\n                  l4_ports_negate_one m))", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> set (normalize_match\n                (rewrite_negated_primitives (disc, sel) C\n                  l4_ports_negate_one m))\n\ngoal (1 subgoal):\n 1. a = m", "apply(subst(asm) m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (normalize_match m) \\<Longrightarrow> a = m", "using normalize_match_already_normalized[OF n]"], ["proof (prove)\nusing this:\n  normalize_match m = [m]\n\ngoal (1 subgoal):\n 1. a \\<in> set (normalize_match m) \\<Longrightarrow> a = m", "by fastforce"], ["proof (state)\nthis:\n  a = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rewrite_negated_primitives_preserves_not_has_disc:\n  assumes n: \"normalized_nnf_match m\"\n  and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n  and nodisc: \"\\<not> has_disc disc2 m\"\n  and noNeg: \"\\<not> has_disc_negated disc False m\"\n  and disc2_noC: \"\\<forall>a. \\<not> disc2 (C a)\"\n  shows \"\\<not> has_disc disc2 (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2\n            (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)", "apply(subst rewrite_negated_primitives_unchanged_if_not_has_disc_negated)"], ["proof (prove)\ngoal (4 subgoals):\n 1. normalized_nnf_match m\n 2. wf_disc_sel (disc, sel) C\n 3. \\<not> has_disc_negated disc False m\n 4. \\<not> has_disc disc2 m", "using n wf_disc_sel noNeg nodisc"], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  wf_disc_sel (disc, sel) C\n  \\<not> has_disc_negated disc False m\n  \\<not> has_disc disc2 m\n\ngoal (4 subgoals):\n 1. normalized_nnf_match m\n 2. wf_disc_sel (disc, sel) C\n 3. \\<not> has_disc_negated disc False m\n 4. \\<not> has_disc disc2 m", "by(simp)+"], ["", "lemma rewrite_negated_primitives:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel disc_sel C\"\n  and negate_f: \"\\<forall>pts. matches \\<gamma> (negate_f C pts) a p \\<longleftrightarrow> matches \\<gamma> (MatchNot (Match (C pts))) a p\"\n  shows \"matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a p \\<longleftrightarrow> matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a\n     p =\n    matches \\<gamma> m a p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a\n     p =\n    matches \\<gamma> m a p", "obtain spts rst where pext: \"primitive_extractor disc_sel m = (spts, rst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>spts rst.\n        primitive_extractor disc_sel m = (spts, rst) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"primitive_extractor disc_sel m\") simp"], ["proof (state)\nthis:\n  primitive_extractor disc_sel m = (spts, rst)\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a\n     p =\n    matches \\<gamma> m a p", "obtain disc sel where disc_sel: \"disc_sel = (disc, sel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>disc sel.\n        disc_sel = (disc, sel) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases disc_sel) simp"], ["proof (state)\nthis:\n  disc_sel = (disc, sel)\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a\n     p =\n    matches \\<gamma> m a p", "with wf_disc_sel"], ["proof (chain)\npicking this:\n  wf_disc_sel disc_sel C\n  disc_sel = (disc, sel)", "have wf_disc_sel': \"wf_disc_sel (disc, sel) C\""], ["proof (prove)\nusing this:\n  wf_disc_sel disc_sel C\n  disc_sel = (disc, sel)\n\ngoal (1 subgoal):\n 1. wf_disc_sel (disc, sel) C", "by simp"], ["proof (state)\nthis:\n  wf_disc_sel (disc, sel) C\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a\n     p =\n    matches \\<gamma> m a p", "from disc_sel pext"], ["proof (chain)\npicking this:\n  disc_sel = (disc, sel)\n  primitive_extractor disc_sel m = (spts, rst)", "have pext': \"primitive_extractor (disc, sel) m = (spts, rst)\""], ["proof (prove)\nusing this:\n  disc_sel = (disc, sel)\n  primitive_extractor disc_sel m = (spts, rst)\n\ngoal (1 subgoal):\n 1. primitive_extractor (disc, sel) m = (spts, rst)", "by simp"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (spts, rst)\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a\n     p =\n    matches \\<gamma> m a p", "have \"matches \\<gamma> (andfold_MatchExp (map (negate_f C) (getNeg spts))) a p \\<and>\n          matches \\<gamma> (andfold_MatchExp (map (Match \\<circ> C) (getPos spts))) a p \\<and> matches \\<gamma> rst a p \\<longleftrightarrow>\n       matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (matches \\<gamma> (andfold_MatchExp (map (negate_f C) (getNeg spts))) a\n      p \\<and>\n     matches \\<gamma>\n      (andfold_MatchExp (map (Match \\<circ> C) (getPos spts))) a p \\<and>\n     matches \\<gamma> rst a p) =\n    matches \\<gamma> m a p", "apply(subst primitive_extractor_correct(1)[OF n wf_disc_sel' pext', symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (matches \\<gamma> (andfold_MatchExp (map (negate_f C) (getNeg spts))) a\n      p \\<and>\n     matches \\<gamma>\n      (andfold_MatchExp (map (Match \\<circ> C) (getPos spts))) a p \\<and>\n     matches \\<gamma> rst a p) =\n    (matches \\<gamma> (alist_and (NegPos_map C spts)) a p \\<and>\n     matches \\<gamma> rst a p)", "apply(simp add: andfold_MatchExp_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<in>set (getNeg spts).\n         matches \\<gamma> (negate_f C m) a p) \\<and>\n     (\\<forall>m\\<in>set (getPos spts).\n         matches \\<gamma> (Match (C m)) a p) \\<and>\n     matches \\<gamma> rst a p) =\n    (matches \\<gamma> (alist_and (NegPos_map C spts)) a p \\<and>\n     matches \\<gamma> rst a p)", "apply(simp add: negate_f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<in>set (getNeg spts).\n         matches \\<gamma> (MatchNot (Match (C m))) a p) \\<and>\n     (\\<forall>m\\<in>set (getPos spts).\n         matches \\<gamma> (Match (C m)) a p) \\<and>\n     matches \\<gamma> rst a p) =\n    (matches \\<gamma> (alist_and (NegPos_map C spts)) a p \\<and>\n     matches \\<gamma> rst a p)", "using alist_and_NegPos_map_getNeg_getPos_matches"], ["proof (prove)\nusing this:\n  ((\\<forall>m\\<in>set (getNeg ?spts).\n       matches ?\\<gamma> (MatchNot (Match (?C m))) ?a ?p) \\<and>\n   (\\<forall>m\\<in>set (getPos ?spts).\n       matches ?\\<gamma> (Match (?C m)) ?a ?p)) =\n  matches ?\\<gamma> (alist_and (NegPos_map ?C ?spts)) ?a ?p\n\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<in>set (getNeg spts).\n         matches \\<gamma> (MatchNot (Match (C m))) a p) \\<and>\n     (\\<forall>m\\<in>set (getPos spts).\n         matches \\<gamma> (Match (C m)) a p) \\<and>\n     matches \\<gamma> rst a p) =\n    (matches \\<gamma> (alist_and (NegPos_map C spts)) a p \\<and>\n     matches \\<gamma> rst a p)", "by fast"], ["proof (state)\nthis:\n  (matches \\<gamma> (andfold_MatchExp (map (negate_f C) (getNeg spts))) a\n    p \\<and>\n   matches \\<gamma> (andfold_MatchExp (map (Match \\<circ> C) (getPos spts)))\n    a p \\<and>\n   matches \\<gamma> rst a p) =\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a\n     p =\n    matches \\<gamma> m a p", "thus ?thesis"], ["proof (prove)\nusing this:\n  (matches \\<gamma> (andfold_MatchExp (map (negate_f C) (getNeg spts))) a\n    p \\<and>\n   matches \\<gamma> (andfold_MatchExp (map (Match \\<circ> C) (getPos spts)))\n    a p \\<and>\n   matches \\<gamma> rst a p) =\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a\n     p =\n    matches \\<gamma> m a p", "by(simp add: rewrite_negated_primitives_def pext bunch_of_lemmata_about_matches)"], ["proof (state)\nthis:\n  matches \\<gamma> (rewrite_negated_primitives disc_sel C negate_f m) a p =\n  matches \\<gamma> m a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rewrite_negated_primitives_not_has_disc:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and nodisc: \"\\<not> has_disc disc2 m\"\n  (*only need a condition for negate_f if it is actually applied*)\n  and negate_f: \"has_disc_negated disc False m \\<Longrightarrow> \\<forall>pts. \\<not> has_disc disc2 (negate_f C pts)\"\n  and no_disc: \"\\<forall>a. \\<not> disc2 (C a)\"\n  shows  \"\\<not> has_disc disc2 (rewrite_negated_primitives (disc,sel) C negate_f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2\n            (rewrite_negated_primitives (disc, sel) C negate_f m)", "apply(simp add: rewrite_negated_primitives_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2\n            (case primitive_extractor (disc, sel) m of\n             (spts, rst) \\<Rightarrow>\n               if getNeg spts = [] then m\n               else MatchAnd\n                     (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n                     (MatchAnd\n                       (andfold_MatchExp\n                         (map (Match \\<circ> C) (getPos spts)))\n                       rst))", "apply(case_tac \"primitive_extractor (disc,sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       \\<not> has_disc disc2\n               (case primitive_extractor (disc, sel) m of\n                (spts, rst) \\<Rightarrow>\n                  if getNeg spts = [] then m\n                  else MatchAnd\n                        (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n                        (MatchAnd\n                          (andfold_MatchExp\n                            (map (Match \\<circ> C) (getPos spts)))\n                          rst))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       (getNeg spts = [] \\<longrightarrow> \\<not> has_disc disc2 m) \\<and>\n       (getNeg spts \\<noteq> [] \\<longrightarrow>\n        \\<not> has_disc disc2\n                (andfold_MatchExp (map (negate_f C) (getNeg spts))) \\<and>\n        \\<not> has_disc disc2\n                (andfold_MatchExp\n                  (map (Match \\<circ> C) (getPos spts))) \\<and>\n        \\<not> has_disc disc2 rst)", "apply(frule primitive_extractor_correct(4)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst\\<rbrakk>\n       \\<Longrightarrow> (getNeg spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc2 m) \\<and>\n                         (getNeg spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map (negate_f C) (getNeg spts))) \\<and>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map (Match \\<circ> C)\n(getPos spts))) \\<and>\n                          \\<not> has_disc disc2 rst)", "apply(frule primitive_extractor_correct(8)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = [])\\<rbrakk>\n       \\<Longrightarrow> (getNeg spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc2 m) \\<and>\n                         (getNeg spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map (negate_f C) (getNeg spts))) \\<and>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map (Match \\<circ> C)\n(getPos spts))) \\<and>\n                          \\<not> has_disc disc2 rst)", "apply(intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (negate_f C) (getNeg spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 4. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "using nodisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 m\n\ngoal (4 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (negate_f C) (getNeg spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 4. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "apply(simp; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (negate_f C) (getNeg spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "apply(rule andfold_MatchExp_not_discI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set\n   (map (negate_f C) (getNeg spts)).\n                            \\<not> has_disc disc2 m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "apply(simp add: negate_f; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "using andfold_MatchExp_not_disc_mapMatch no_disc"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> ?disc (?C a) \\<Longrightarrow>\n  \\<not> has_disc ?disc (andfold_MatchExp (map (Match \\<circ> ?C) ?ls))\n  \\<forall>a. \\<not> disc2 (C a)\n\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "using nodisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 m\n\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "by blast"], ["", "lemma rewrite_negated_primitives_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and negate_f: \"has_disc_negated disc False m \\<Longrightarrow> \\<forall>pts. \\<not> has_disc_negated disc False (negate_f C pts)\"\n  shows  \"\\<not> has_disc_negated disc False (rewrite_negated_primitives (disc,sel) C negate_f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False\n            (rewrite_negated_primitives (disc, sel) C negate_f m)", "apply(simp add: rewrite_negated_primitives_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False\n            (case primitive_extractor (disc, sel) m of\n             (spts, rst) \\<Rightarrow>\n               if getNeg spts = [] then m\n               else MatchAnd\n                     (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n                     (MatchAnd\n                       (andfold_MatchExp\n                         (map (Match \\<circ> C) (getPos spts)))\n                       rst))", "apply(case_tac \"primitive_extractor (disc,sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       \\<not> has_disc_negated disc False\n               (case primitive_extractor (disc, sel) m of\n                (spts, rst) \\<Rightarrow>\n                  if getNeg spts = [] then m\n                  else MatchAnd\n                        (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n                        (MatchAnd\n                          (andfold_MatchExp\n                            (map (Match \\<circ> C) (getPos spts)))\n                          rst))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       (getNeg spts = [] \\<longrightarrow>\n        \\<not> has_disc_negated disc False m) \\<and>\n       (getNeg spts \\<noteq> [] \\<longrightarrow>\n        \\<not> has_disc_negated disc False\n                (andfold_MatchExp (map (negate_f C) (getNeg spts))) \\<and>\n        \\<not> has_disc_negated disc False\n                (andfold_MatchExp\n                  (map (Match \\<circ> C) (getPos spts))) \\<and>\n        \\<not> has_disc_negated disc False rst)", "apply(frule primitive_extractor_correct(3)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst\\<rbrakk>\n       \\<Longrightarrow> (getNeg spts = [] \\<longrightarrow>\n                          \\<not> has_disc_negated disc False m) \\<and>\n                         (getNeg spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc_negated disc False\n                                  (andfold_MatchExp\n                                    (map (negate_f C) (getNeg spts))) \\<and>\n                          \\<not> has_disc_negated disc False\n                                  (andfold_MatchExp\n                                    (map (Match \\<circ> C)\n(getPos spts))) \\<and>\n                          \\<not> has_disc_negated disc False rst)", "apply(frule primitive_extractor_correct(8)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = [])\\<rbrakk>\n       \\<Longrightarrow> (getNeg spts = [] \\<longrightarrow>\n                          \\<not> has_disc_negated disc False m) \\<and>\n                         (getNeg spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc_negated disc False\n                                  (andfold_MatchExp\n                                    (map (negate_f C) (getNeg spts))) \\<and>\n                          \\<not> has_disc_negated disc False\n                                  (andfold_MatchExp\n                                    (map (Match \\<circ> C)\n(getPos spts))) \\<and>\n                          \\<not> has_disc_negated disc False rst)", "apply(intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (negate_f C) (getNeg spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 4. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (negate_f C) (getNeg spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst", "apply(rule andfold_MatchExp_not_disc_negatedI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set\n   (map (negate_f C) (getNeg spts)).\n                            \\<not> has_disc_negated disc False m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst", "apply(simp add: negate_f; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst", "using andfold_MatchExp_not_disc_negated_mapMatch"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated ?disc False\n          (andfold_MatchExp (map (Match \\<circ> ?C) ?ls))\n\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst", "using has_disc_negated_has_disc"], ["proof (prove)\nusing this:\n  has_disc_negated ?disc ?neg ?m \\<Longrightarrow> has_disc ?disc ?m\n\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst", "by blast"], ["", "lemma rewrite_negated_primitives_preserves_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and negate_f: \"has_disc_negated disc False m \\<Longrightarrow> \\<forall>pts. \\<not> has_disc_negated disc2 False (negate_f C pts)\"\n  and no_disc: \"\\<not> has_disc_negated disc2 False m\"\n  shows  \"\\<not> has_disc_negated disc2 False (rewrite_negated_primitives (disc,sel) C negate_f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc2 False\n            (rewrite_negated_primitives (disc, sel) C negate_f m)", "apply(simp add: rewrite_negated_primitives_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc2 False\n            (case primitive_extractor (disc, sel) m of\n             (spts, rst) \\<Rightarrow>\n               if getNeg spts = [] then m\n               else MatchAnd\n                     (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n                     (MatchAnd\n                       (andfold_MatchExp\n                         (map (Match \\<circ> C) (getPos spts)))\n                       rst))", "apply(case_tac \"primitive_extractor (disc,sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       \\<not> has_disc_negated disc2 False\n               (case primitive_extractor (disc, sel) m of\n                (spts, rst) \\<Rightarrow>\n                  if getNeg spts = [] then m\n                  else MatchAnd\n                        (andfold_MatchExp (map (negate_f C) (getNeg spts)))\n                        (MatchAnd\n                          (andfold_MatchExp\n                            (map (Match \\<circ> C) (getPos spts)))\n                          rst))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       (getNeg spts = [] \\<longrightarrow>\n        \\<not> has_disc_negated disc2 False m) \\<and>\n       (getNeg spts \\<noteq> [] \\<longrightarrow>\n        \\<not> has_disc_negated disc2 False\n                (andfold_MatchExp (map (negate_f C) (getNeg spts))) \\<and>\n        \\<not> has_disc_negated disc2 False\n                (andfold_MatchExp\n                  (map (Match \\<circ> C) (getPos spts))) \\<and>\n        \\<not> has_disc_negated disc2 False rst)", "apply(frule primitive_extractor_correct(3)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst\\<rbrakk>\n       \\<Longrightarrow> (getNeg spts = [] \\<longrightarrow>\n                          \\<not> has_disc_negated disc2 False m) \\<and>\n                         (getNeg spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc_negated disc2 False\n                                  (andfold_MatchExp\n                                    (map (negate_f C) (getNeg spts))) \\<and>\n                          \\<not> has_disc_negated disc2 False\n                                  (andfold_MatchExp\n                                    (map (Match \\<circ> C)\n(getPos spts))) \\<and>\n                          \\<not> has_disc_negated disc2 False rst)", "apply(frule primitive_extractor_correct(8)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = [])\\<rbrakk>\n       \\<Longrightarrow> (getNeg spts = [] \\<longrightarrow>\n                          \\<not> has_disc_negated disc2 False m) \\<and>\n                         (getNeg spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc_negated disc2 False\n                                  (andfold_MatchExp\n                                    (map (negate_f C) (getNeg spts))) \\<and>\n                          \\<not> has_disc_negated disc2 False\n                                  (andfold_MatchExp\n                                    (map (Match \\<circ> C)\n(getPos spts))) \\<and>\n                          \\<not> has_disc_negated disc2 False rst)", "apply(intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (negate_f C) (getNeg spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 4. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "using no_disc"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc2 False m\n\ngoal (4 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (negate_f C) (getNeg spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 4. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (negate_f C) (getNeg spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "apply(rule andfold_MatchExp_not_disc_negatedI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set\n   (map (negate_f C) (getNeg spts)).\n                            \\<not> has_disc_negated disc2 False m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "apply(simp add: negate_f; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "using andfold_MatchExp_not_disc_negated_mapMatch"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated ?disc False\n          (andfold_MatchExp (map (Match \\<circ> ?C) ?ls))\n\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "apply(drule primitive_extractor_correct(6)[OF n wf_disc_sel, where neg=False])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>\\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 False m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 False rst\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "using no_disc"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc2 False m\n\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>\\<not> has_disc disc rst;\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = []);\n        getNeg spts \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 False m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 False rst\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "by blast"], ["", "lemma rewrite_negated_primitives_normalized_preserves_unrelated_helper:\n    assumes wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n    and disc: \"\\<forall>a. \\<not> disc2 (C a)\"\n    and disc_p: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated disc False m\" (*either we do not disc on protocol or the is no negated port*)\n    shows \"normalized_nnf_match m \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f m \\<Longrightarrow>\n         a \\<in> set (normalize_match (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "have helper_a_normalized: \"a \\<in> MatchAnd x ` (\\<Union>x\\<in>set spts. MatchAnd x ` set (normalize_match rst)) \\<Longrightarrow>\n        normalized_n_primitive (disc, sel) f x \\<Longrightarrow>\n        (\\<forall>s \\<in> set spts. normalized_n_primitive (disc, sel) f s) \\<Longrightarrow>\n        normalized_n_primitive (disc, sel) f rst \\<Longrightarrow>\n             normalized_n_primitive (disc, sel) f a\"\n        for a x spts rst f disc and sel::\"'a common_primitive \\<Rightarrow> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> MatchAnd x `\n                     (\\<Union>x\\<in>set spts.\n                         MatchAnd x ` set (normalize_match rst));\n     normalized_n_primitive (disc, sel) f x;\n     \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n     normalized_n_primitive (disc, sel) f rst\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f a", "apply(subgoal_tac \"\\<exists> s r. a = MatchAnd x (MatchAnd s r) \\<and> s \\<in> set spts \\<and> r \\<in> set (normalize_match rst)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> MatchAnd x `\n                     (\\<Union>x\\<in>set spts.\n                         MatchAnd x ` set (normalize_match rst));\n     normalized_n_primitive (disc, sel) f x;\n     \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n     normalized_n_primitive (disc, sel) f rst;\n     \\<exists>s r.\n        a = MatchAnd x (MatchAnd s r) \\<and>\n        s \\<in> set spts \\<and> r \\<in> set (normalize_match rst)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f a\n 2. \\<lbrakk>a \\<in> MatchAnd x `\n                     (\\<Union>x\\<in>set spts.\n                         MatchAnd x ` set (normalize_match rst));\n     normalized_n_primitive (disc, sel) f x;\n     \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n     normalized_n_primitive (disc, sel) f rst\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s r.\n                         a = MatchAnd x (MatchAnd s r) \\<and>\n                         s \\<in> set spts \\<and>\n                         r \\<in> set (normalize_match rst)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> MatchAnd x `\n                     (\\<Union>x\\<in>set spts.\n                         MatchAnd x ` set (normalize_match rst));\n     normalized_n_primitive (disc, sel) f x;\n     \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n     normalized_n_primitive (disc, sel) f rst\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s r.\n                         a = MatchAnd x (MatchAnd s r) \\<and>\n                         s \\<in> set spts \\<and>\n                         r \\<in> set (normalize_match rst)\n 2. \\<lbrakk>a \\<in> MatchAnd x `\n                     (\\<Union>x\\<in>set spts.\n                         MatchAnd x ` set (normalize_match rst));\n     normalized_n_primitive (disc, sel) f x;\n     \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n     normalized_n_primitive (disc, sel) f rst;\n     \\<exists>s r.\n        a = MatchAnd x (MatchAnd s r) \\<and>\n        s \\<in> set spts \\<and> r \\<in> set (normalize_match rst)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f a", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> MatchAnd x `\n                     (\\<Union>x\\<in>set spts.\n                         MatchAnd x ` set (normalize_match rst));\n     normalized_n_primitive (disc, sel) f x;\n     \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n     normalized_n_primitive (disc, sel) f rst;\n     \\<exists>s r.\n        a = MatchAnd x (MatchAnd s r) \\<and>\n        s \\<in> set spts \\<and> r \\<in> set (normalize_match rst)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f a", "apply(elim exE conjE, rename_tac s r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r.\n       \\<lbrakk>a \\<in> MatchAnd x `\n                        (\\<Union>x\\<in>set spts.\n                            MatchAnd x ` set (normalize_match rst));\n        normalized_n_primitive (disc, sel) f x;\n        \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n        normalized_n_primitive (disc, sel) f rst;\n        a = MatchAnd x (MatchAnd s r); s \\<in> set spts;\n        r \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f a", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r.\n       \\<lbrakk>MatchAnd x (MatchAnd s r)\n                \\<in> MatchAnd x `\n                      (\\<Union>x\\<in>set spts.\n                          MatchAnd x ` set (normalize_match rst));\n        normalized_n_primitive (disc, sel) f x;\n        \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n        normalized_n_primitive (disc, sel) f rst;\n        a = MatchAnd x (MatchAnd s r); s \\<in> set spts;\n        r \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f r", "using normalize_match_preserves_normalized_n_primitive"], ["proof (prove)\nusing this:\n  normalized_n_primitive ?disc_sel ?f ?rst \\<Longrightarrow>\n  \\<forall>m\\<in>set (normalize_match ?rst).\n     normalized_n_primitive ?disc_sel ?f m\n\ngoal (1 subgoal):\n 1. \\<And>s r.\n       \\<lbrakk>MatchAnd x (MatchAnd s r)\n                \\<in> MatchAnd x `\n                      (\\<Union>x\\<in>set spts.\n                          MatchAnd x ` set (normalize_match rst));\n        normalized_n_primitive (disc, sel) f x;\n        \\<forall>s\\<in>set spts. normalized_n_primitive (disc, sel) f s;\n        normalized_n_primitive (disc, sel) f rst;\n        a = MatchAnd x (MatchAnd s r); s \\<in> set spts;\n        r \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f r", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> MatchAnd ?x `\n                    (\\<Union>x\\<in>set ?spts.\n                        MatchAnd x ` set (normalize_match ?rst));\n   normalized_n_primitive (?disc, ?sel) ?f ?x;\n   \\<forall>s\\<in>set ?spts. normalized_n_primitive (?disc, ?sel) ?f s;\n   normalized_n_primitive (?disc, ?sel) ?f ?rst\\<rbrakk>\n  \\<Longrightarrow> normalized_n_primitive (?disc, ?sel) ?f ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "show \"normalized_nnf_match m \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f m \\<Longrightarrow>\n         a \\<in> set (normalize_match (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(case_tac \"\\<not> has_disc_negated disc False m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a\n 2. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "using rewrite_negated_primitives_normalized_no_modification[OF wf_disc_sel]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> has_disc_negated disc False ?m; normalized_nnf_match ?m;\n   ?a \\<in> set (normalize_match\n                  (rewrite_negated_primitives (disc, sel) C\n                    l4_ports_negate_one ?m))\\<rbrakk>\n  \\<Longrightarrow> ?a = ?m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(simp add: rewrite_negated_primitives_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (case primitive_extractor (disc, sel) m of\n                    (spts, rst) \\<Rightarrow>\n                      if getNeg spts = [] then m\n                      else MatchAnd\n                            (andfold_MatchExp\n                              (map (l4_ports_negate_one C) (getNeg spts)))\n                            (MatchAnd\n                              (andfold_MatchExp\n                                (map (Match \\<circ> C) (getPos spts)))\n                              rst)));\n     has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(case_tac \"primitive_extractor (disc, sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>normalized_nnf_match m;\n        normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (case primitive_extractor (disc, sel) m of\n                       (spts, rst) \\<Rightarrow>\n                         if getNeg spts = [] then m\n                         else MatchAnd\n                               (andfold_MatchExp\n                                 (map (l4_ports_negate_one C)\n                                   (getNeg spts)))\n                               (MatchAnd\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ> C) (getPos spts)))\n                                 rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>normalized_nnf_match m;\n        normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (if getNeg spts = [] then m\n                       else MatchAnd\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C) (getNeg spts)))\n                             (MatchAnd\n                               (andfold_MatchExp\n                                 (map (Match \\<circ> C) (getPos spts)))\n                               rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(subgoal_tac \"normalized_n_primitive (disc2, sel2) f rst\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>normalized_nnf_match m;\n        normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (if getNeg spts = [] then m\n                       else MatchAnd\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C) (getNeg spts)))\n                             (MatchAnd\n                               (andfold_MatchExp\n                                 (map (Match \\<circ> C) (getPos spts)))\n                               rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a\n 2. \\<And>spts rst.\n       \\<lbrakk>normalized_nnf_match m;\n        normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (if getNeg spts = [] then m\n                       else MatchAnd\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C) (getNeg spts)))\n                             (MatchAnd\n                               (andfold_MatchExp\n                                 (map (Match \\<circ> C) (getPos spts)))\n                               rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>normalized_nnf_match m;\n        normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (if getNeg spts = [] then m\n                       else MatchAnd\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C) (getNeg spts)))\n                             (MatchAnd\n                               (andfold_MatchExp\n                                 (map (Match \\<circ> C) (getPos spts)))\n                               rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst\n 2. \\<And>spts rst.\n       \\<lbrakk>normalized_nnf_match m;\n        normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (if getNeg spts = [] then m\n                       else MatchAnd\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C) (getNeg spts)))\n                             (MatchAnd\n                               (andfold_MatchExp\n                                 (map (Match \\<circ> C) (getPos spts)))\n                               rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "subgoal for spts rst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (if getNeg spts = [] then m\n                    else MatchAnd\n                          (andfold_MatchExp\n                            (map (l4_ports_negate_one C) (getNeg spts)))\n                          (MatchAnd\n                            (andfold_MatchExp\n                              (map (Match \\<circ> C) (getPos spts)))\n                            rst)));\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "apply(drule primitive_extractor_correct(5)[OF _ wf_disc_sel, where P=\"f\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (if getNeg spts = [] then m\n                    else MatchAnd\n                          (andfold_MatchExp\n                            (map (l4_ports_negate_one C) (getNeg spts)))\n                          (MatchAnd\n                            (andfold_MatchExp\n                              (map (Match \\<circ> C) (getPos spts)))\n                            rst)));\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n    \\<Longrightarrow> primitive_extractor (disc, sel) m = (?as, ?ms)\n 2. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (if getNeg spts = [] then m\n                    else MatchAnd\n                          (andfold_MatchExp\n                            (map (l4_ports_negate_one C) (getNeg spts)))\n                          (MatchAnd\n                            (andfold_MatchExp\n                              (map (Match \\<circ> C) (getPos spts)))\n                            rst)));\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst);\n     \\<forall>disc2 sel2.\n        normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n        normalized_n_primitive (disc2, sel2) f ?ms\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     a \\<in> set (normalize_match\n                   (if getNeg spts = [] then m\n                    else MatchAnd\n                          (andfold_MatchExp\n                            (map (l4_ports_negate_one C) (getNeg spts)))\n                          (MatchAnd\n                            (andfold_MatchExp\n                              (map (Match \\<circ> C) (getPos spts)))\n                            rst)));\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst);\n     \\<forall>disc2 sel2.\n        normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n        normalized_n_primitive (disc2, sel2) f rst\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "by(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>normalized_nnf_match m;\n        normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (if getNeg spts = [] then m\n                       else MatchAnd\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C) (getNeg spts)))\n                             (MatchAnd\n                               (andfold_MatchExp\n                                 (map (Match \\<circ> C) (getPos spts)))\n                               rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(insert disc_p, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>normalized_nnf_match m;\n        normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (if getNeg spts = [] then m\n                       else MatchAnd\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C) (getNeg spts)))\n                             (MatchAnd\n                               (andfold_MatchExp\n                                 (map (Match \\<circ> C) (getPos spts)))\n                               rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(drule(1) primitive_extractor_correct(8)[OF _ wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        a \\<in> set (normalize_match\n                      (if getNeg spts = [] then m\n                       else MatchAnd\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C) (getNeg spts)))\n                             (MatchAnd\n                               (andfold_MatchExp\n                                 (map (Match \\<circ> C) (getPos spts)))\n                               rst)));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a);\n        (\\<not> has_disc_negated disc False m) = (getNeg spts = [])\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp\n                               (map (l4_ports_negate_one C)\n                                 (getNeg spts)))).\n           a \\<in> MatchAnd x `\n                   (\\<Union>x\\<in>set (normalize_match\n  (andfold_MatchExp (map (Match \\<circ> C) (getPos spts)))).\n                       MatchAnd x ` set (normalize_match rst));\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(elim bexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n        x \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (l4_ports_negate_one C) (getNeg spts))));\n        a \\<in> MatchAnd x `\n                (\\<Union>x\\<in>set (normalize_match\n                                     (andfold_MatchExp\n (map (Match \\<circ> C) (getPos spts)))).\n                    MatchAnd x ` set (normalize_match rst))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a", "apply(erule helper_a_normalized)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst x.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n        x \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (l4_ports_negate_one C)\n                          (getNeg spts))))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f x\n 2. \\<And>spts rst x.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n        x \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (l4_ports_negate_one C)\n                          (getNeg spts))))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s\\<in>set\n   (normalize_match\n     (andfold_MatchExp (map (Match \\<circ> C) (getPos spts)))).\n                            normalized_n_primitive (disc2, sel2) f s\n 3. \\<And>spts rst x.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n        x \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (l4_ports_negate_one C)\n                          (getNeg spts))))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "subgoal for spts"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f x_", "apply(rule_tac pts=\"(getNeg spts)\" in negated_normalized_folded_ports_normalized_n_primitive[where C=C])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a. \\<not> disc2 (C a)\n 2. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n                      getNeg spts = []\n 3. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> set (normalize_match\n                                     (andfold_MatchExp\n (map (l4_ports_negate_one C) (getNeg spts))))", "using disc"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (C a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a. \\<not> disc2 (C a)\n 2. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n                      getNeg spts = []\n 3. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> set (normalize_match\n                                     (andfold_MatchExp\n (map (l4_ports_negate_one C) (getNeg spts))))", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n                      getNeg spts = []\n 2. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> set (normalize_match\n                                     (andfold_MatchExp\n (map (l4_ports_negate_one C) (getNeg spts))))", "using disc_p primitive_extractor_correct(8)[OF _ wf_disc_sel]"], ["proof (prove)\nusing this:\n  (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n  \\<not> has_disc_negated disc False m\n  \\<lbrakk>normalized_nnf_match ?m;\n   primitive_extractor (disc, sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc_negated disc False ?m) =\n                    (getNeg ?as = [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n                      getNeg spts = []\n 2. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> set (normalize_match\n                                     (andfold_MatchExp\n (map (l4_ports_negate_one C) (getNeg spts))))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (spts, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg spts))))\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> set (normalize_match\n                                     (andfold_MatchExp\n (map (l4_ports_negate_one C) (getNeg spts))))", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst x.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n        x \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (l4_ports_negate_one C)\n                          (getNeg spts))))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s\\<in>set\n   (normalize_match\n     (andfold_MatchExp (map (Match \\<circ> C) (getPos spts)))).\n                            normalized_n_primitive (disc2, sel2) f s\n 2. \\<And>spts rst x.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n        x \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (l4_ports_negate_one C)\n                          (getNeg spts))))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n     has_disc_negated disc False m;\n     primitive_extractor (disc, sel) m = (x, rst_);\n     normalized_n_primitive (disc2, sel2) f rst_;\n     \\<forall>a. \\<not> disc2 (Prot a); getNeg x \\<noteq> [];\n     x_ \\<in> set (normalize_match\n                    (andfold_MatchExp\n                      (map (l4_ports_negate_one C) (getNeg x))))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s\\<in>set\n(normalize_match (andfold_MatchExp (map (Match \\<circ> C) (getPos x)))).\n                         normalized_n_primitive (disc2, sel2) f s", "apply(intro ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (x, rst_);\n        normalized_n_primitive (disc2, sel2) f rst_;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg x \\<noteq> [];\n        x_ \\<in> set (normalize_match\n                       (andfold_MatchExp\n                         (map (l4_ports_negate_one C) (getNeg x))));\n        s \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (Match \\<circ> C) (getPos x))))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f s", "apply(rule andfold_MatchExp_normalized_normalized_n_primitive_single[where C=C])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (x, rst_);\n        normalized_n_primitive (disc2, sel2) f rst_;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg x \\<noteq> [];\n        x_ \\<in> set (normalize_match\n                       (andfold_MatchExp\n                         (map (l4_ports_negate_one C) (getNeg x))));\n        s \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (Match \\<circ> C) (getPos x))))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a. \\<not> disc2 (C a)\n 2. \\<And>s.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (x, rst_);\n        normalized_n_primitive (disc2, sel2) f rst_;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg x \\<noteq> [];\n        x_ \\<in> set (normalize_match\n                       (andfold_MatchExp\n                         (map (l4_ports_negate_one C) (getNeg x))));\n        s \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (Match \\<circ> C) (getPos x))))\\<rbrakk>\n       \\<Longrightarrow> s \\<in> set (normalize_match\n (andfold_MatchExp (map (Match \\<circ> C) (?xs1 s))))", "using disc disc_p"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (C a)\n  (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n  \\<not> has_disc_negated disc False m\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (x, rst_);\n        normalized_n_primitive (disc2, sel2) f rst_;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg x \\<noteq> [];\n        x_ \\<in> set (normalize_match\n                       (andfold_MatchExp\n                         (map (l4_ports_negate_one C) (getNeg x))));\n        s \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (Match \\<circ> C) (getPos x))))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a. \\<not> disc2 (C a)\n 2. \\<And>s.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (x, rst_);\n        normalized_n_primitive (disc2, sel2) f rst_;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg x \\<noteq> [];\n        x_ \\<in> set (normalize_match\n                       (andfold_MatchExp\n                         (map (l4_ports_negate_one C) (getNeg x))));\n        s \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (Match \\<circ> C) (getPos x))))\\<rbrakk>\n       \\<Longrightarrow> s \\<in> set (normalize_match\n (andfold_MatchExp (map (Match \\<circ> C) (?xs1 s))))", "by(simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) f m;\n        has_disc_negated disc False m;\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_n_primitive (disc2, sel2) f rst;\n        \\<forall>a. \\<not> disc2 (Prot a); getNeg spts \\<noteq> [];\n        x \\<in> set (normalize_match\n                      (andfold_MatchExp\n                        (map (l4_ports_negate_one C)\n                          (getNeg spts))))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match m; normalized_n_primitive (disc2, sel2) f m;\n   a \\<in> set (normalize_match\n                 (rewrite_negated_primitives (disc, sel) C\n                   l4_ports_negate_one m))\\<rbrakk>\n  \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a\n\ngoal:\nNo subgoals!", "qed"], ["", "definition rewrite_negated_src_ports\n    :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr\" where\n    \"rewrite_negated_src_ports m \\<equiv>\n          rewrite_negated_primitives (is_Src_Ports, src_ports_sel) Src_Ports l4_ports_negate_one m\""], ["", "definition rewrite_negated_dst_ports\n    :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr\" where\n    \"rewrite_negated_dst_ports m \\<equiv>\n          rewrite_negated_primitives (is_Dst_Ports, dst_ports_sel) Dst_Ports l4_ports_negate_one m\""], ["", "value \"rewrite_negated_src_ports (MatchAnd (Match (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n                   (MatchAnd (Match (Prot (Proto TCP)))\n                        (MatchNot (Match (Src_Ports (L4Ports UDP [(80,80)]))))\n                 ))\""], ["", "value \"rewrite_negated_src_ports (MatchAnd (Match (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n                   (MatchAnd (Match (Prot (Proto TCP)))\n                        (MatchNot (Match (Extra ''foobar'')))\n                 ))\""], ["", "lemma rewrite_negated_src_ports:\n  assumes generic: \"primitive_matcher_generic \\<beta>\"  and n: \"normalized_nnf_match m\"\n  shows \"matches (\\<beta>, \\<alpha>) (rewrite_negated_src_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (rewrite_negated_src_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: rewrite_negated_src_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>)\n     (rewrite_negated_primitives (is_Src_Ports, src_ports_sel) Src_Ports\n       l4_ports_negate_one m)\n     a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(rule rewrite_negated_primitives)"], ["proof (prove)\ngoal (3 subgoals):\n 1. normalized_nnf_match m\n 2. wf_disc_sel (is_Src_Ports, src_ports_sel) Src_Ports\n 3. \\<forall>pts.\n       matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Src_Ports pts) a p =\n       matches (\\<beta>, \\<alpha>) (MatchNot (Match (Src_Ports pts))) a p", "by(simp add: l4_ports_negate_one[OF generic] n wf_disc_sel_common_primitive(1))+"], ["", "lemma rewrite_negated_dst_ports:\n  assumes generic: \"primitive_matcher_generic \\<beta>\"  and n: \"normalized_nnf_match m\"\n  shows \"matches (\\<beta>, \\<alpha>) (rewrite_negated_dst_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (rewrite_negated_dst_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: rewrite_negated_dst_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>)\n     (rewrite_negated_primitives (is_Dst_Ports, dst_ports_sel) Dst_Ports\n       l4_ports_negate_one m)\n     a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(rule rewrite_negated_primitives)"], ["proof (prove)\ngoal (3 subgoals):\n 1. normalized_nnf_match m\n 2. wf_disc_sel (is_Dst_Ports, dst_ports_sel) Dst_Ports\n 3. \\<forall>pts.\n       matches (\\<beta>, \\<alpha>) (l4_ports_negate_one Dst_Ports pts) a p =\n       matches (\\<beta>, \\<alpha>) (MatchNot (Match (Dst_Ports pts))) a p", "by(simp add: l4_ports_negate_one[OF generic] n wf_disc_sel_common_primitive(2))+"], ["", "lemma rewrite_negated_src_ports_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\"\n  shows  \"\\<not> has_disc_negated is_Src_Ports False (rewrite_negated_src_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Src_Ports False (rewrite_negated_src_ports m)", "apply(simp add: rewrite_negated_src_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Src_Ports False\n            (rewrite_negated_primitives (is_Src_Ports, src_ports_sel)\n              Src_Ports l4_ports_negate_one m)", "apply(rule rewrite_negated_primitives_not_has_disc_negated)"], ["proof (prove)\ngoal (3 subgoals):\n 1. normalized_nnf_match m\n 2. wf_disc_sel (is_Src_Ports, src_ports_sel) Src_Ports\n 3. has_disc_negated is_Src_Ports False m \\<Longrightarrow>\n    \\<forall>pts.\n       \\<not> has_disc_negated is_Src_Ports False\n               (l4_ports_negate_one Src_Ports pts)", "by(simp add: n wf_disc_sel_common_primitive(1) l4_ports_negate_one_not_has_disc_negated)+"], ["", "lemma rewrite_negated_dst_ports_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\"\n  shows  \"\\<not> has_disc_negated is_Dst_Ports False (rewrite_negated_dst_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Dst_Ports False (rewrite_negated_dst_ports m)", "apply(simp add: rewrite_negated_dst_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Dst_Ports False\n            (rewrite_negated_primitives (is_Dst_Ports, dst_ports_sel)\n              Dst_Ports l4_ports_negate_one m)", "apply(rule rewrite_negated_primitives_not_has_disc_negated)"], ["proof (prove)\ngoal (3 subgoals):\n 1. normalized_nnf_match m\n 2. wf_disc_sel (is_Dst_Ports, dst_ports_sel) Dst_Ports\n 3. has_disc_negated is_Dst_Ports False m \\<Longrightarrow>\n    \\<forall>pts.\n       \\<not> has_disc_negated is_Dst_Ports False\n               (l4_ports_negate_one Dst_Ports pts)", "by(simp add: n wf_disc_sel_common_primitive(2) l4_ports_negate_one_not_has_disc_negated)+"], ["", "lemma \"\\<not> has_disc_negated disc t m \\<Longrightarrow> \\<forall>m' \\<in> set (normalize_match m). \\<not> has_disc_negated disc t m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc t m \\<Longrightarrow>\n    \\<forall>m'\\<in>set (normalize_match m).\n       \\<not> has_disc_negated disc t m'", "by(fact i_m_giving_this_a_funny_name_so_i_can_thank_my_future_me_when_sledgehammer_will_find_this_one_day)"], ["", "corollary normalize_rewrite_negated_src_ports_not_has_disc_negated:\n  assumes n: \"normalized_nnf_match m\"\n  shows \"\\<forall>m' \\<in> set (normalize_match (rewrite_negated_src_ports m)). \\<not> has_disc_negated is_Src_Ports False m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_match (rewrite_negated_src_ports m)).\n       \\<not> has_disc_negated is_Src_Ports False m'", "apply(rule i_m_giving_this_a_funny_name_so_i_can_thank_my_future_me_when_sledgehammer_will_find_this_one_day)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Src_Ports False (rewrite_negated_src_ports m)", "apply(rule rewrite_negated_src_ports_not_has_disc_negated)"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m", "using n"], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m", "by simp"], ["", "subsection\\<open>Normalizing Positive Matches on Ports\\<close>"], ["", "(*now normalizing the match expression which does not have negated ports*)\n\n(*creates a disjunction where all interval lists only have one element*)"], ["", "fun singletonize_L4Ports :: \"ipt_l4_ports \\<Rightarrow> ipt_l4_ports list\" where\n    \"singletonize_L4Ports (L4Ports proto pts) = map (\\<lambda>p. L4Ports proto [p]) pts\""], ["", "lemma singletonize_L4Ports_src: assumes generic: \"primitive_matcher_generic \\<beta>\"\n   shows \"match_list (\\<beta>, \\<alpha>) (map (Match \\<circ> Src_Ports) (singletonize_L4Ports pts)) a p \\<longleftrightarrow> \n    matches (\\<beta>, \\<alpha>) (Match (Src_Ports pts)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>)\n     (map (Match \\<circ> Src_Ports) (singletonize_L4Ports pts)) a p =\n    matches (\\<beta>, \\<alpha>) (Match (Src_Ports pts)) a p", "apply(cases pts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       pts = L4Ports x1 x2 \\<Longrightarrow>\n       match_list (\\<beta>, \\<alpha>)\n        (map (Match \\<circ> Src_Ports) (singletonize_L4Ports pts)) a p =\n       matches (\\<beta>, \\<alpha>) (Match (Src_Ports pts)) a p", "apply(simp add: match_list_matches primitive_matcher_generic.Ports_single[OF generic])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       pts = L4Ports x1 x2 \\<Longrightarrow>\n       (x1 = p_proto p \\<and>\n        (\\<exists>m\\<in>set x2. p_sport p \\<in> ports_to_set [m])) =\n       (x1 = p_proto p \\<and> p_sport p \\<in> ports_to_set x2)", "apply(simp add: ports_to_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       pts = L4Ports x1 x2 \\<Longrightarrow>\n       (x1 = p_proto p \\<and>\n        (\\<exists>m\\<in>set x2.\n            \\<exists>x.\n               (\\<exists>s e. x = {s..e} \\<and> (s, e) = m) \\<and>\n               p_sport p \\<in> x)) =\n       (x1 = p_proto p \\<and>\n        (\\<exists>x.\n            (\\<exists>s e. x = {s..e} \\<and> (s, e) \\<in> set x2) \\<and>\n            p_sport p \\<in> x))", "by auto"], ["", "lemma singletonize_L4Ports_dst: assumes generic: \"primitive_matcher_generic \\<beta>\"\n   shows \"match_list (\\<beta>, \\<alpha>) (map (Match \\<circ> Dst_Ports) (singletonize_L4Ports pts)) a p \\<longleftrightarrow> \n    matches (\\<beta>, \\<alpha>) (Match (Dst_Ports pts)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>)\n     (map (Match \\<circ> Dst_Ports) (singletonize_L4Ports pts)) a p =\n    matches (\\<beta>, \\<alpha>) (Match (Dst_Ports pts)) a p", "apply(cases pts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       pts = L4Ports x1 x2 \\<Longrightarrow>\n       match_list (\\<beta>, \\<alpha>)\n        (map (Match \\<circ> Dst_Ports) (singletonize_L4Ports pts)) a p =\n       matches (\\<beta>, \\<alpha>) (Match (Dst_Ports pts)) a p", "apply(simp add: match_list_matches primitive_matcher_generic.Ports_single[OF generic])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       pts = L4Ports x1 x2 \\<Longrightarrow>\n       (x1 = p_proto p \\<and>\n        (\\<exists>m\\<in>set x2. p_dport p \\<in> ports_to_set [m])) =\n       (x1 = p_proto p \\<and> p_dport p \\<in> ports_to_set x2)", "apply(simp add: ports_to_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       pts = L4Ports x1 x2 \\<Longrightarrow>\n       (x1 = p_proto p \\<and>\n        (\\<exists>m\\<in>set x2.\n            \\<exists>x.\n               (\\<exists>s e. x = {s..e} \\<and> (s, e) = m) \\<and>\n               p_dport p \\<in> x)) =\n       (x1 = p_proto p \\<and>\n        (\\<exists>x.\n            (\\<exists>s e. x = {s..e} \\<and> (s, e) \\<in> set x2) \\<and>\n            p_dport p \\<in> x))", "by auto"], ["", "lemma singletonize_L4Ports_normalized_generic:\n    assumes wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    and \"m' \\<in> (\\<lambda>spt. Match (C spt)) ` set (singletonize_L4Ports pt)\"\n    shows \"normalized_n_primitive (disc, sel) (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1))  m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc, sel)\n     (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "using assms"], ["proof (prove)\nusing this:\n  wf_disc_sel (disc, sel) C\n  m' \\<in> (\\<lambda>spt. Match (C spt)) ` set (singletonize_L4Ports pt)\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc, sel)\n     (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "apply(case_tac pt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        m' \\<in> (\\<lambda>spt. Match (C spt)) `\n                 set (singletonize_L4Ports pt);\n        pt = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (case_ipt_l4_ports\n                            (\\<lambda>x pts. length pts \\<le> 1))\n                          m'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        m' \\<in> (\\<lambda>x. Match (C x)) `\n                 (\\<lambda>p. L4Ports x1 [p]) ` set x2;\n        pt = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (case_ipt_l4_ports\n                            (\\<lambda>x pts. length pts \\<le> Suc 0))\n                          m'", "apply(induction m')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        Match x\n        \\<in> (\\<lambda>x. Match (C x)) `\n              (\\<lambda>p. L4Ports x1 [p]) ` set x2;\n        pt = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (case_ipt_l4_ports\n                            (\\<lambda>x pts. length pts \\<le> Suc 0))\n                          (Match x)\n 2. \\<And>m' x1 x2.\n       \\<lbrakk>\\<And>x1 x2.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    m' \\<in> (\\<lambda>x. Match (C x)) `\n                             (\\<lambda>p. L4Ports x1 [p]) ` set x2;\n                    pt = L4Ports x1 x2\\<rbrakk>\n                   \\<Longrightarrow> normalized_n_primitive (disc, sel)\n(case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> Suc 0)) m';\n        wf_disc_sel (disc, sel) C;\n        MatchNot m'\n        \\<in> (\\<lambda>x. Match (C x)) `\n              (\\<lambda>p. L4Ports x1 [p]) ` set x2;\n        pt = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (case_ipt_l4_ports\n                            (\\<lambda>x pts. length pts \\<le> Suc 0))\n                          (MatchNot m')\n 3. \\<And>m'1 m'2 x1 x2.\n       \\<lbrakk>\\<And>x1 x2.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    m'1\n                    \\<in> (\\<lambda>x. Match (C x)) `\n                          (\\<lambda>p. L4Ports x1 [p]) ` set x2;\n                    pt = L4Ports x1 x2\\<rbrakk>\n                   \\<Longrightarrow> normalized_n_primitive (disc, sel)\n(case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> Suc 0)) m'1;\n        \\<And>x1 x2.\n           \\<lbrakk>wf_disc_sel (disc, sel) C;\n            m'2\n            \\<in> (\\<lambda>x. Match (C x)) `\n                  (\\<lambda>p. L4Ports x1 [p]) ` set x2;\n            pt = L4Ports x1 x2\\<rbrakk>\n           \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                              (case_ipt_l4_ports\n                                (\\<lambda>x pts. length pts \\<le> Suc 0))\n                              m'2;\n        wf_disc_sel (disc, sel) C;\n        MatchAnd m'1 m'2\n        \\<in> (\\<lambda>x. Match (C x)) `\n              (\\<lambda>p. L4Ports x1 [p]) ` set x2;\n        pt = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (case_ipt_l4_ports\n                            (\\<lambda>x pts. length pts \\<le> Suc 0))\n                          (MatchAnd m'1 m'2)\n 4. \\<And>x1 x2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        MatchAny\n        \\<in> (\\<lambda>x. Match (C x)) `\n              (\\<lambda>p. L4Ports x1 [p]) ` set x2;\n        pt = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (case_ipt_l4_ports\n                            (\\<lambda>x pts. length pts \\<le> Suc 0))\n                          MatchAny", "by(auto simp: wf_disc_sel.simps)"], ["", "lemma singletonize_L4Ports_normalized_src_ports:\n    \"m' \\<in> (\\<lambda>spt. Match (Src_Ports spt)) ` set (singletonize_L4Ports pt) \\<Longrightarrow> normalized_src_ports m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> (\\<lambda>spt. Match (Src_Ports spt)) `\n             set (singletonize_L4Ports pt) \\<Longrightarrow>\n    normalized_src_ports m'", "apply(simp add: normalized_src_ports_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> (\\<lambda>spt. Match (Src_Ports spt)) `\n             set (singletonize_L4Ports pt) \\<Longrightarrow>\n    normalized_n_primitive (is_Src_Ports, src_ports_sel)\n     (\\<lambda>ps.\n         case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n     m'", "using singletonize_L4Ports_normalized_generic[OF wf_disc_sel_common_primitive(1)]"], ["proof (prove)\nusing this:\n  ?m'\n  \\<in> (\\<lambda>spt. Match (Src_Ports spt)) `\n        set (singletonize_L4Ports ?pt) \\<Longrightarrow>\n  normalized_n_primitive (is_Src_Ports, src_ports_sel)\n   (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) ?m'\n\ngoal (1 subgoal):\n 1. m' \\<in> (\\<lambda>spt. Match (Src_Ports spt)) `\n             set (singletonize_L4Ports pt) \\<Longrightarrow>\n    normalized_n_primitive (is_Src_Ports, src_ports_sel)\n     (\\<lambda>ps.\n         case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n     m'", "by blast"], ["", "lemma singletonize_L4Ports_normalized_dst_ports:\n    \"m' \\<in> (\\<lambda>spt. Match (Dst_Ports spt)) ` set (singletonize_L4Ports pt) \\<Longrightarrow> normalized_dst_ports m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> (\\<lambda>spt. Match (Dst_Ports spt)) `\n             set (singletonize_L4Ports pt) \\<Longrightarrow>\n    normalized_dst_ports m'", "apply(simp add: normalized_dst_ports_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> (\\<lambda>spt. Match (Dst_Ports spt)) `\n             set (singletonize_L4Ports pt) \\<Longrightarrow>\n    normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n     (\\<lambda>ps.\n         case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n     m'", "using singletonize_L4Ports_normalized_generic[OF wf_disc_sel_common_primitive(2)]"], ["proof (prove)\nusing this:\n  ?m'\n  \\<in> (\\<lambda>spt. Match (Dst_Ports spt)) `\n        set (singletonize_L4Ports ?pt) \\<Longrightarrow>\n  normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n   (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) ?m'\n\ngoal (1 subgoal):\n 1. m' \\<in> (\\<lambda>spt. Match (Dst_Ports spt)) `\n             set (singletonize_L4Ports pt) \\<Longrightarrow>\n    normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n     (\\<lambda>ps.\n         case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n     m'", "by blast"], ["", "declare singletonize_L4Ports.simps[simp del]"], ["", "lemma normalized_ports_singletonize_combine_rst:\n    assumes wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    shows \"normalized_n_primitive (disc, sel) (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) rst \\<Longrightarrow>\n    m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) ` set (singletonize_L4Ports pt) \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel)\n              (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) rst;\n     m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n              set (singletonize_L4Ports pt)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                       (case_ipt_l4_ports\n                         (\\<lambda>x pts. length pts \\<le> 1))\n                       m'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel)\n              (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> Suc 0))\n              rst;\n     m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n              set (singletonize_L4Ports pt)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                       (case_ipt_l4_ports\n                         (\\<lambda>x pts. length pts \\<le> Suc 0))\n                       m'", "apply(rule normalized_n_primitive_MatchAnd_combine_map)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel)\n              (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> Suc 0))\n              rst;\n     m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n              set (singletonize_L4Ports pt)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                       (case_ipt_l4_ports\n                         (\\<lambda>x pts. length pts \\<le> Suc 0))\n                       ?rst1\n 2. \\<lbrakk>normalized_n_primitive (disc, sel)\n              (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> Suc 0))\n              rst;\n     m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n              set (singletonize_L4Ports pt)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m'\\<in>(\\<lambda>spt. Match (?C1 spt)) `\nset ?pts1.\n                         normalized_n_primitive (disc, sel)\n                          (case_ipt_l4_ports\n                            (\\<lambda>x pts. length pts \\<le> Suc 0))\n                          m'\n 3. \\<lbrakk>normalized_n_primitive (disc, sel)\n              (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> Suc 0))\n              rst;\n     m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n              set (singletonize_L4Ports pt)\\<rbrakk>\n    \\<Longrightarrow> m' \\<in> (\\<lambda>spt.\n                                   MatchAnd (Match (?C1 spt)) ?rst1) `\n                               set ?pts1", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel)\n              (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> Suc 0))\n              rst;\n     m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n              set (singletonize_L4Ports pt)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (singletonize_L4Ports pt).\n                         disc (C x) \\<longrightarrow>\n                         (case sel (C x) of\n                          L4Ports x pts \\<Rightarrow>\n                            length pts \\<le> Suc 0)", "using singletonize_L4Ports_normalized_generic[OF wf_disc_sel]"], ["proof (prove)\nusing this:\n  ?m'\n  \\<in> (\\<lambda>spt. Match (C spt)) `\n        set (singletonize_L4Ports ?pt) \\<Longrightarrow>\n  normalized_n_primitive (disc, sel)\n   (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel)\n              (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> Suc 0))\n              rst;\n     m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n              set (singletonize_L4Ports pt)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (singletonize_L4Ports pt).\n                         disc (C x) \\<longrightarrow>\n                         (case sel (C x) of\n                          L4Ports x pts \\<Rightarrow>\n                            length pts \\<le> Suc 0)", "by fastforce"], ["", "text\\<open>Normalizing match expressions such that at most one port will exist in it.\n       Returns a list of match expressions (splits one firewall rule into several rules).\\<close>"], ["", "definition normalize_positive_ports_step\n    :: \"(('i::len common_primitive \\<Rightarrow> bool) \\<times> ('i common_primitive \\<Rightarrow> ipt_l4_ports)) \\<Rightarrow> \n       (ipt_l4_ports \\<Rightarrow> 'i common_primitive) \\<Rightarrow>\n       'i common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr list\" where \n    \"normalize_positive_ports_step disc_sel C m \\<equiv>\n        let (spts, rst) = primitive_extractor disc_sel m in\n        case (getPos spts, getNeg spts)\n          of (pspts, []) \\<Rightarrow> (case l4_ports_compress pspts of CannotMatch \\<Rightarrow> []\n                                                          |  MatchesAll \\<Rightarrow> [rst]\n                                                          |  MatchExpr m \\<Rightarrow> map (\\<lambda>spt. (MatchAnd (Match (C spt)) rst)) (singletonize_L4Ports m)\n                            )\n          |  (_, _) \\<Rightarrow> undefined\""], ["", "lemma normalize_positive_ports_step_nnf:\n    assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    and noneg: \"\\<not> has_disc_negated disc False m\"\n    shows \"m' \\<in> set (normalize_positive_ports_step (disc,sel) C m) \\<Longrightarrow> normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_positive_ports_step (disc, sel) C\n                   m) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(simp add: normalize_positive_ports_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>uu_ uua_.\n       (uua_, uu_) = primitive_extractor (disc, sel) m \\<and>\n       m' \\<in> set (case getNeg uua_ of\n                     [] \\<Rightarrow>\n                       case l4_ports_compress (getPos uua_) of\n                       CannotMatch \\<Rightarrow> []\n                       | MatchesAll \\<Rightarrow> [uu_]\n                       | MatchExpr m \\<Rightarrow>\n                           map (\\<lambda>spt. MatchAnd (Match (C spt)) uu_)\n                            (singletonize_L4Ports m)) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(elim exE conjE, rename_tac rst spts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rst spts.\n       \\<lbrakk>(spts, rst) = primitive_extractor (disc, sel) m;\n        m' \\<in> set (case getNeg spts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos spts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply(drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "(*switch primitive_extrartor = *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply(frule primitive_extractor_correct(2)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply(subgoal_tac \"getNeg spts = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst\\<rbrakk>\n       \\<Longrightarrow> getNeg spts = []", "(*duplication above*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst\\<rbrakk>\n       \\<Longrightarrow> getNeg spts = []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst\\<rbrakk>\n       \\<Longrightarrow> getNeg spts = []\n 2. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (case getNeg spts_ of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts_) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst_]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (C spt)) rst_)\n                                  (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) m = (spts_, rst_);\n     normalized_nnf_match rst_\\<rbrakk>\n    \\<Longrightarrow> getNeg spts_ = []", "apply(drule primitive_extractor_correct(8)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (case getNeg spts_ of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts_) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst_]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (C spt)) rst_)\n                                  (singletonize_L4Ports m));\n     normalized_nnf_match rst_;\n     (\\<not> has_disc_negated disc False m) = (getNeg spts_ = [])\\<rbrakk>\n    \\<Longrightarrow> getNeg spts_ = []", "using noneg"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc False m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (case getNeg spts_ of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts_) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst_]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (C spt)) rst_)\n                                  (singletonize_L4Ports m));\n     normalized_nnf_match rst_;\n     (\\<not> has_disc_negated disc False m) = (getNeg spts_ = [])\\<rbrakk>\n    \\<Longrightarrow> getNeg spts_ = []", "by simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply(simp split: match_compress.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rst spts x3.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; getNeg spts = [];\n        l4_ports_compress (getPos spts) = MatchExpr x3;\n        m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n                 set (singletonize_L4Ports x3)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "by fastforce"], ["", "lemma normalize_positive_ports_step_normalized_n_primitive: \n    assumes n: \"normalized_nnf_match m\"  and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    and noneg: \"\\<not> has_disc_negated disc False m\"\n    shows \"\\<forall>m' \\<in> set (normalize_positive_ports_step (disc,sel) C m). \n            normalized_n_primitive (disc,sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_ports_step (disc, sel) C m).\n       normalized_n_primitive (disc, sel)\n        (\\<lambda>ps.\n            case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n        m'", "unfolding normalize_positive_ports_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (let (spts, rst) = primitive_extractor (disc, sel) m\n                         in case (getPos spts, getNeg spts) of\n                            (pspts, []) \\<Rightarrow>\n                              case l4_ports_compress pspts of\n                              CannotMatch \\<Rightarrow> []\n                              | MatchesAll \\<Rightarrow> [rst]\n                              | MatchExpr m \\<Rightarrow>\n                                  map (\\<lambda>spt.\n    MatchAnd (Match (C spt)) rst)\n                                   (singletonize_L4Ports m)).\n       normalized_n_primitive (disc, sel)\n        (\\<lambda>ps.\n            case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n        m'", "apply(intro ballI, rename_tac m')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (let (spts, rst) = primitive_extractor (disc, sel) m\n                     in case (getPos spts, getNeg spts) of\n                        (pspts, []) \\<Rightarrow>\n                          case l4_ports_compress pspts of\n                          CannotMatch \\<Rightarrow> []\n                          | MatchesAll \\<Rightarrow> [rst]\n                          | MatchExpr m \\<Rightarrow>\n                              map (\\<lambda>spt.\nMatchAnd (Match (C spt)) rst)\n                               (singletonize_L4Ports m)) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel)\n        (\\<lambda>ps.\n            case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n        m'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<exists>uu_ uua_.\n          (uua_, uu_) = primitive_extractor (disc, sel) m \\<and>\n          m' \\<in> set (case getNeg uua_ of\n                        [] \\<Rightarrow>\n                          case l4_ports_compress (getPos uua_) of\n                          CannotMatch \\<Rightarrow> []\n                          | MatchesAll \\<Rightarrow> [uu_]\n                          | MatchExpr m \\<Rightarrow>\n                              map (\\<lambda>spt.\nMatchAnd (Match (C spt)) uu_)\n                               (singletonize_L4Ports m)) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel)\n        (\\<lambda>ps.\n            case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n        m'", "apply(elim exE conjE, rename_tac rst spts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>(spts, rst) = primitive_extractor (disc, sel) m;\n        m' \\<in> set (case getNeg spts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos spts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "(*switch primitive_extrartor = *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(frule primitive_extractor_correct(2)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(frule primitive_extractor_correct(3)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(subgoal_tac \"getNeg spts = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'\n 2. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst\\<rbrakk>\n       \\<Longrightarrow> getNeg spts = []", "(*duplication above*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'\n 2. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst\\<rbrakk>\n       \\<Longrightarrow> getNeg spts = []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst\\<rbrakk>\n       \\<Longrightarrow> getNeg spts = []\n 2. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m'_\n             \\<in> set (case getNeg spts_ of\n                        [] \\<Rightarrow>\n                          case l4_ports_compress (getPos spts_) of\n                          CannotMatch \\<Rightarrow> []\n                          | MatchesAll \\<Rightarrow> [rst_]\n                          | MatchExpr m \\<Rightarrow>\n                              map (\\<lambda>spt.\nMatchAnd (Match (C spt)) rst_)\n                               (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) m = (spts_, rst_);\n     normalized_nnf_match rst_; \\<not> has_disc disc rst_\\<rbrakk>\n    \\<Longrightarrow> getNeg spts_ = []", "apply(drule primitive_extractor_correct(8)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m'_\n             \\<in> set (case getNeg spts_ of\n                        [] \\<Rightarrow>\n                          case l4_ports_compress (getPos spts_) of\n                          CannotMatch \\<Rightarrow> []\n                          | MatchesAll \\<Rightarrow> [rst_]\n                          | MatchExpr m \\<Rightarrow>\n                              map (\\<lambda>spt.\nMatchAnd (Match (C spt)) rst_)\n                               (singletonize_L4Ports m));\n     normalized_nnf_match rst_; \\<not> has_disc disc rst_;\n     (\\<not> has_disc_negated disc False m) = (getNeg spts_ = [])\\<rbrakk>\n    \\<Longrightarrow> getNeg spts_ = []", "using noneg"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc False m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m'_\n             \\<in> set (case getNeg spts_ of\n                        [] \\<Rightarrow>\n                          case l4_ports_compress (getPos spts_) of\n                          CannotMatch \\<Rightarrow> []\n                          | MatchesAll \\<Rightarrow> [rst_]\n                          | MatchExpr m \\<Rightarrow>\n                              map (\\<lambda>spt.\nMatchAnd (Match (C spt)) rst_)\n                               (singletonize_L4Ports m));\n     normalized_nnf_match rst_; \\<not> has_disc disc rst_;\n     (\\<not> has_disc_negated disc False m) = (getNeg spts_ = [])\\<rbrakk>\n    \\<Longrightarrow> getNeg spts_ = []", "by simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(subgoal_tac \"normalized_n_primitive (disc,sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) rst\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = [];\n        normalized_n_primitive (disc, sel)\n         (\\<lambda>ps.\n             case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n         rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'\n 2. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          rst", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          rst\n 2. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = [];\n        normalized_n_primitive (disc, sel)\n         (\\<lambda>ps.\n             case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n         rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m'_\n             \\<in> set (case getNeg spts_ of\n                        [] \\<Rightarrow>\n                          case l4_ports_compress (getPos spts_) of\n                          CannotMatch \\<Rightarrow> []\n                          | MatchesAll \\<Rightarrow> [rst_]\n                          | MatchExpr m \\<Rightarrow>\n                              map (\\<lambda>spt.\nMatchAnd (Match (C spt)) rst_)\n                               (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) m = (spts_, rst_);\n     normalized_nnf_match rst_; \\<not> has_disc disc rst_;\n     getNeg spts_ = []\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                       (\\<lambda>ps.\n                           case ps of\n                           L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n                       rst_", "by(drule(2) normalized_n_primitive_if_no_primitive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' rst spts.\n       \\<lbrakk>m' \\<in> set (case getNeg spts of\n                              [] \\<Rightarrow>\n                                case l4_ports_compress (getPos spts) of\n                                CannotMatch \\<Rightarrow> []\n                                | MatchesAll \\<Rightarrow> [rst]\n                                | MatchExpr m \\<Rightarrow>\n                                    map (\\<lambda>spt.\n      MatchAnd (Match (C spt)) rst)\n                                     (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = [];\n        normalized_n_primitive (disc, sel)\n         (\\<lambda>ps.\n             case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n         rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(simp split: match_compress.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' rst spts x3.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = [];\n        normalized_n_primitive (disc, sel)\n         (\\<lambda>ps.\n             case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n         rst;\n        l4_ports_compress (getPos spts) = MatchExpr x3;\n        m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n                 set (singletonize_L4Ports x3)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "using normalized_ports_singletonize_combine_rst[OF wf_disc_sel]"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_n_primitive (disc, sel)\n            (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) ?rst;\n   ?m'\n   \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ?rst) `\n         set (singletonize_L4Ports ?pt)\\<rbrakk>\n  \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                     (case_ipt_l4_ports\n                       (\\<lambda>x pts. length pts \\<le> 1))\n                     ?m'\n\ngoal (1 subgoal):\n 1. \\<And>m' rst spts x3.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        normalized_nnf_match rst; \\<not> has_disc disc rst;\n        getNeg spts = [];\n        normalized_n_primitive (disc, sel)\n         (\\<lambda>ps.\n             case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n         rst;\n        l4_ports_compress (getPos spts) = MatchExpr x3;\n        m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n                 set (singletonize_L4Ports x3)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "by blast"], ["", "definition normalize_positive_src_ports :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr list\" where\n    \"normalize_positive_src_ports = normalize_positive_ports_step (is_Src_Ports, src_ports_sel) Src_Ports\""], ["", "definition normalize_positive_dst_ports :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr list\" where\n    \"normalize_positive_dst_ports = normalize_positive_ports_step (is_Dst_Ports, dst_ports_sel) Dst_Ports\""], ["", "(*TODO: into next lemmas?*)"], ["", "lemma noNeg_mapNegPos_helper: \"getNeg ls = [] \\<Longrightarrow>\n           map (Pos \\<circ> C) (getPos ls) = NegPos_map C ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getNeg ls = [] \\<Longrightarrow>\n    map (Pos \\<circ> C) (getPos ls) = NegPos_map C ls", "by(induction ls rule: getPos.induct) simp+"], ["", "lemma normalize_positive_src_ports:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Src_Ports False m\"\n    shows\n        \"match_list (\\<beta>, \\<alpha>) (normalize_positive_src_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>) (normalize_positive_src_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: normalize_positive_src_ports_def normalize_positive_ports_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>)\n     (case primitive_extractor (is_Src_Ports, src_ports_sel) m of\n      (spts, rst) \\<Rightarrow>\n        case getNeg spts of\n        [] \\<Rightarrow>\n          case l4_ports_compress (getPos spts) of\n          CannotMatch \\<Rightarrow> [] | MatchesAll \\<Rightarrow> [rst]\n          | MatchExpr m \\<Rightarrow>\n              map (\\<lambda>spt. MatchAnd (Match (Src_Ports spt)) rst)\n               (singletonize_L4Ports m))\n     a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(case_tac \"primitive_extractor (is_Src_Ports, src_ports_sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (is_Src_Ports, src_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       match_list (\\<beta>, \\<alpha>)\n        (case primitive_extractor (is_Src_Ports, src_ports_sel) m of\n         (spts, rst) \\<Rightarrow>\n           case getNeg spts of\n           [] \\<Rightarrow>\n             case l4_ports_compress (getPos spts) of\n             CannotMatch \\<Rightarrow> [] | MatchesAll \\<Rightarrow> [rst]\n             | MatchExpr m \\<Rightarrow>\n                 map (\\<lambda>spt. MatchAnd (Match (Src_Ports spt)) rst)\n                  (singletonize_L4Ports m))\n        a p =\n       matches (\\<beta>, \\<alpha>) m a p", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (is_Src_Ports, src_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       match_list (\\<beta>, \\<alpha>)\n        (case getNeg spts of\n         [] \\<Rightarrow>\n           case l4_ports_compress (getPos spts) of\n           CannotMatch \\<Rightarrow> [] | MatchesAll \\<Rightarrow> [rst]\n           | MatchExpr m \\<Rightarrow>\n               map (\\<lambda>spt. MatchAnd (Match (Src_Ports spt)) rst)\n                (singletonize_L4Ports m))\n        a p =\n       matches (\\<beta>, \\<alpha>) m a p", "apply(subgoal_tac \"getNeg spts = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Src_Ports, src_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case getNeg spts of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (Src_Ports spt)) rst)\n                                  (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       primitive_extractor (is_Src_Ports, src_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       getNeg spts = []", "(*needs assumption for this step *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Src_Ports, src_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case getNeg spts of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (Src_Ports spt)) rst)\n                                  (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       primitive_extractor (is_Src_Ports, src_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       getNeg spts = []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       primitive_extractor (is_Src_Ports, src_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       getNeg spts = []\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Src_Ports, src_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case getNeg spts of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (Src_Ports spt)) rst)\n                                  (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_extractor (is_Src_Ports, src_ports_sel) m =\n    (spts_, rst_) \\<Longrightarrow>\n    getNeg spts_ = []", "apply(drule primitive_extractor_correct(8)[OF n wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> has_disc_negated is_Src_Ports False m) =\n    (getNeg spts_ = []) \\<Longrightarrow>\n    getNeg spts_ = []", "using noneg"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated is_Src_Ports False m\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc_negated is_Src_Ports False m) =\n    (getNeg spts_ = []) \\<Longrightarrow>\n    getNeg spts_ = []", "by simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Src_Ports, src_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case getNeg spts of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (Src_Ports spt)) rst)\n                                  (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Src_Ports, src_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(drule primitive_extractor_correct(1)[OF n wf_disc_sel_common_primitive(1), where \\<gamma>=\"(\\<beta>, \\<alpha>)\" and a=a and p=p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(case_tac \"l4_ports_compress (getPos spts)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = CannotMatch\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = CannotMatch\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(drule raw_ports_compress_src_CannotMatch[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        \\<not> matches (\\<beta>, \\<alpha>)\n                (alist_and (map (Pos \\<circ> Src_Ports) (getPos spts))) a\n                p\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: noNeg_mapNegPos_helper; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>) rst a\n                           p \\<longrightarrow>\n                          matches (\\<beta>, \\<alpha>) m a p) \\<and>\n                         (\\<not> matches (\\<beta>, \\<alpha>) rst a\n                                  p \\<longrightarrow>\n                          \\<not> matches (\\<beta>, \\<alpha>) m a p)\n 2. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(drule raw_ports_compress_MatchesAll[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Src_Ports) (getPos spts))) a\n         p\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>) rst a\n                           p \\<longrightarrow>\n                          matches (\\<beta>, \\<alpha>) m a p) \\<and>\n                         (\\<not> matches (\\<beta>, \\<alpha>) rst a\n                                  p \\<longrightarrow>\n                          \\<not> matches (\\<beta>, \\<alpha>) m a p)\n 2. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: noNeg_mapNegPos_helper; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Src_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (map (\\<lambda>spt.\n                                   MatchAnd (Match (Src_Ports spt)) rst)\n                            (singletonize_L4Ports x3))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(drule raw_ports_compress_src_MatchExpr[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>) (Match (Src_Ports x3)) a p =\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Src_Ports) (getPos spts))) a\n         p\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (map (\\<lambda>spt.\n                                   MatchAnd (Match (Src_Ports spt)) rst)\n                            (singletonize_L4Ports x3))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(insert singletonize_L4Ports_src[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>) (Match (Src_Ports x3)) a p =\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Src_Ports) (getPos spts))) a p;\n        \\<And>pts.\n           match_list (\\<beta>, \\<alpha>)\n            (map (Match \\<circ> Src_Ports) (singletonize_L4Ports pts)) a p =\n           matches (\\<beta>, \\<alpha>) (Match (Src_Ports pts)) a p\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (map (\\<lambda>spt.\n                                   MatchAnd (Match (Src_Ports spt)) rst)\n                            (singletonize_L4Ports x3))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: match_list_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>) (Match (Src_Ports x3)) a p =\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Src_Ports) (getPos spts))) a p;\n        \\<And>pts.\n           (\\<exists>m\\<in>set (singletonize_L4Ports pts).\n               matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p) =\n           matches (\\<beta>, \\<alpha>) (Match (Src_Ports pts)) a p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (singletonize_L4Ports x3).\n                             matches (\\<beta>, \\<alpha>)\n                              (MatchAnd (Match (Src_Ports m)) rst) a p) =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Src_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>) (Match (Src_Ports x3)) a p =\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Src_Ports) (getPos spts))) a p;\n        \\<And>pts.\n           (\\<exists>m\\<in>set (singletonize_L4Ports pts).\n               matches (\\<beta>, \\<alpha>) (Match (Src_Ports m)) a p) =\n           matches (\\<beta>, \\<alpha>) (Match (Src_Ports pts)) a p\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (alist_and\n                             (map (Pos \\<circ> Src_Ports) (getPos spts)))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>) rst a p) =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: noNeg_mapNegPos_helper; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*copy & paste, TODO generalize*)"], ["", "lemma normalize_positive_dst_ports:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Dst_Ports False m\"\n    shows \"match_list (\\<beta>, \\<alpha>) (normalize_positive_dst_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>) (normalize_positive_dst_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: normalize_positive_dst_ports_def normalize_positive_ports_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>)\n     (case primitive_extractor (is_Dst_Ports, dst_ports_sel) m of\n      (spts, rst) \\<Rightarrow>\n        case getNeg spts of\n        [] \\<Rightarrow>\n          case l4_ports_compress (getPos spts) of\n          CannotMatch \\<Rightarrow> [] | MatchesAll \\<Rightarrow> [rst]\n          | MatchExpr m \\<Rightarrow>\n              map (\\<lambda>spt. MatchAnd (Match (Dst_Ports spt)) rst)\n               (singletonize_L4Ports m))\n     a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(case_tac \"primitive_extractor (is_Dst_Ports, dst_ports_sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       match_list (\\<beta>, \\<alpha>)\n        (case primitive_extractor (is_Dst_Ports, dst_ports_sel) m of\n         (spts, rst) \\<Rightarrow>\n           case getNeg spts of\n           [] \\<Rightarrow>\n             case l4_ports_compress (getPos spts) of\n             CannotMatch \\<Rightarrow> [] | MatchesAll \\<Rightarrow> [rst]\n             | MatchExpr m \\<Rightarrow>\n                 map (\\<lambda>spt. MatchAnd (Match (Dst_Ports spt)) rst)\n                  (singletonize_L4Ports m))\n        a p =\n       matches (\\<beta>, \\<alpha>) m a p", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       match_list (\\<beta>, \\<alpha>)\n        (case getNeg spts of\n         [] \\<Rightarrow>\n           case l4_ports_compress (getPos spts) of\n           CannotMatch \\<Rightarrow> [] | MatchesAll \\<Rightarrow> [rst]\n           | MatchExpr m \\<Rightarrow>\n               map (\\<lambda>spt. MatchAnd (Match (Dst_Ports spt)) rst)\n                (singletonize_L4Ports m))\n        a p =\n       matches (\\<beta>, \\<alpha>) m a p", "apply(subgoal_tac \"getNeg spts = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case getNeg spts of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (Dst_Ports spt)) rst)\n                                  (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       getNeg spts = []", "(*needs assumption for this step *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case getNeg spts of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (Dst_Ports spt)) rst)\n                                  (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       getNeg spts = []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n       (spts, rst) \\<Longrightarrow>\n       getNeg spts = []\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case getNeg spts of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (Dst_Ports spt)) rst)\n                                  (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n    (spts_, rst_) \\<Longrightarrow>\n    getNeg spts_ = []", "apply(drule primitive_extractor_correct(8)[OF n wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> has_disc_negated is_Dst_Ports False m) =\n    (getNeg spts_ = []) \\<Longrightarrow>\n    getNeg spts_ = []", "using noneg"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated is_Dst_Ports False m\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc_negated is_Dst_Ports False m) =\n    (getNeg spts_ = []) \\<Longrightarrow>\n    getNeg spts_ = []", "by simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case getNeg spts of\n                           [] \\<Rightarrow>\n                             case l4_ports_compress (getPos spts) of\n                             CannotMatch \\<Rightarrow> []\n                             | MatchesAll \\<Rightarrow> [rst]\n                             | MatchExpr m \\<Rightarrow>\n                                 map (\\<lambda>spt.\n   MatchAnd (Match (Dst_Ports spt)) rst)\n                                  (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (is_Dst_Ports, dst_ports_sel) m =\n                (spts, rst);\n        getNeg spts = []\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(drule primitive_extractor_correct(1)[OF n wf_disc_sel_common_primitive(2), where \\<gamma>=\"(\\<beta>, \\<alpha>)\" and a=a and p=p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(case_tac \"l4_ports_compress (getPos spts)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = CannotMatch\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = CannotMatch\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(drule raw_ports_compress_dst_CannotMatch[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        \\<not> matches (\\<beta>, \\<alpha>)\n                (alist_and (map (Pos \\<circ> Dst_Ports) (getPos spts))) a\n                p\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: noNeg_mapNegPos_helper; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchesAll\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>) rst a\n                           p \\<longrightarrow>\n                          matches (\\<beta>, \\<alpha>) m a p) \\<and>\n                         (\\<not> matches (\\<beta>, \\<alpha>) rst a\n                                  p \\<longrightarrow>\n                          \\<not> matches (\\<beta>, \\<alpha>) m a p)\n 2. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(drule raw_ports_compress_MatchesAll(2)[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Dst_Ports) (getPos spts))) a\n         p\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>) rst a\n                           p \\<longrightarrow>\n                          matches (\\<beta>, \\<alpha>) m a p) \\<and>\n                         (\\<not> matches (\\<beta>, \\<alpha>) rst a\n                                  p \\<longrightarrow>\n                          \\<not> matches (\\<beta>, \\<alpha>) m a p)\n 2. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: noNeg_mapNegPos_helper; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (case l4_ports_compress (getPos spts) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [rst]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (Dst_Ports spt)) rst)\n                                (singletonize_L4Ports m))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        l4_ports_compress (getPos spts) = MatchExpr x3\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (map (\\<lambda>spt.\n                                   MatchAnd (Match (Dst_Ports spt)) rst)\n                            (singletonize_L4Ports x3))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(drule raw_ports_compress_dst_MatchExpr[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>) (Match (Dst_Ports x3)) a p =\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Dst_Ports) (getPos spts))) a\n         p\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (map (\\<lambda>spt.\n                                   MatchAnd (Match (Dst_Ports spt)) rst)\n                            (singletonize_L4Ports x3))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(insert singletonize_L4Ports_dst[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>) (Match (Dst_Ports x3)) a p =\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Dst_Ports) (getPos spts))) a p;\n        \\<And>pts.\n           match_list (\\<beta>, \\<alpha>)\n            (map (Match \\<circ> Dst_Ports) (singletonize_L4Ports pts)) a p =\n           matches (\\<beta>, \\<alpha>) (Match (Dst_Ports pts)) a p\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (map (\\<lambda>spt.\n                                   MatchAnd (Match (Dst_Ports spt)) rst)\n                            (singletonize_L4Ports x3))\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: match_list_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>) (Match (Dst_Ports x3)) a p =\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Dst_Ports) (getPos spts))) a p;\n        \\<And>pts.\n           (\\<exists>m\\<in>set (singletonize_L4Ports pts).\n               matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p) =\n           matches (\\<beta>, \\<alpha>) (Match (Dst_Ports pts)) a p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (singletonize_L4Ports x3).\n                             matches (\\<beta>, \\<alpha>)\n                              (MatchAnd (Match (Dst_Ports m)) rst) a p) =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst x3.\n       \\<lbrakk>getNeg spts = [];\n        (matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Dst_Ports spts))\n          a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst a p) =\n        matches (\\<beta>, \\<alpha>) m a p;\n        matches (\\<beta>, \\<alpha>) (Match (Dst_Ports x3)) a p =\n        matches (\\<beta>, \\<alpha>)\n         (alist_and (map (Pos \\<circ> Dst_Ports) (getPos spts))) a p;\n        \\<And>pts.\n           (\\<exists>m\\<in>set (singletonize_L4Ports pts).\n               matches (\\<beta>, \\<alpha>) (Match (Dst_Ports m)) a p) =\n           matches (\\<beta>, \\<alpha>) (Match (Dst_Ports pts)) a p\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (alist_and\n                             (map (Pos \\<circ> Dst_Ports) (getPos spts)))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>) rst a p) =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: noNeg_mapNegPos_helper; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma normalize_positive_src_ports_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Src_Ports False m\"\n    shows \"m' \\<in> set (normalize_positive_src_ports m) \\<Longrightarrow> normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_positive_src_ports m) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(rule normalize_positive_ports_step_nnf[OF n wf_disc_sel_common_primitive(1) noneg])"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_positive_src_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_positive_ports_step\n                   (is_Src_Ports, src_ports_sel) Src_Ports m)", "by(simp add: normalize_positive_src_ports_def)"], ["", "lemma normalize_positive_dst_ports_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Dst_Ports False m\"\n    shows \"m' \\<in> set (normalize_positive_dst_ports m) \\<Longrightarrow> normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_positive_dst_ports m) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(rule normalize_positive_ports_step_nnf[OF n wf_disc_sel_common_primitive(2) noneg])"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_positive_dst_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_positive_ports_step\n                   (is_Dst_Ports, dst_ports_sel) Dst_Ports m)", "by(simp add: normalize_positive_dst_ports_def)"], ["", "lemma normalize_positive_src_ports_normalized_n_primitive: \n    assumes n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Src_Ports False m\"\n    shows \"\\<forall>m' \\<in> set (normalize_positive_src_ports m). normalized_src_ports m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_src_ports m).\n       normalized_src_ports m'", "unfolding normalized_src_ports_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_src_ports m).\n       normalized_n_primitive (is_Src_Ports, src_ports_sel)\n        (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "unfolding normalize_positive_src_ports_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_ports_step\n                          (is_Src_Ports, src_ports_sel) Src_Ports m).\n       normalized_n_primitive (is_Src_Ports, src_ports_sel)\n        (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "using normalize_positive_ports_step_normalized_n_primitive[OF n wf_disc_sel_common_primitive(1) noneg]"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_positive_ports_step\n                        (is_Src_Ports, src_ports_sel) Src_Ports m).\n     normalized_n_primitive (is_Src_Ports, src_ports_sel)\n      (\\<lambda>ps.\n          case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n      m'\n\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_ports_step\n                          (is_Src_Ports, src_ports_sel) Src_Ports m).\n       normalized_n_primitive (is_Src_Ports, src_ports_sel)\n        (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "by blast"], ["", "lemma normalize_positive_dst_ports_normalized_n_primitive: \n    assumes n: \"normalized_nnf_match m\"\n    and noneg: \"\\<not> has_disc_negated is_Dst_Ports False m\"\n    shows \"\\<forall>m' \\<in> set (normalize_positive_dst_ports m). normalized_dst_ports m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_dst_ports m).\n       normalized_dst_ports m'", "unfolding normalized_dst_ports_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_dst_ports m).\n       normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n        (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "unfolding normalize_positive_dst_ports_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_ports_step\n                          (is_Dst_Ports, dst_ports_sel) Dst_Ports m).\n       normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n        (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "using normalize_positive_ports_step_normalized_n_primitive[OF n wf_disc_sel_common_primitive(2) noneg]"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_positive_ports_step\n                        (is_Dst_Ports, dst_ports_sel) Dst_Ports m).\n     normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n      (\\<lambda>ps.\n          case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n      m'\n\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_positive_ports_step\n                          (is_Dst_Ports, dst_ports_sel) Dst_Ports m).\n       normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n        (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "by blast"], ["", "subsection\\<open>Complete Normalization\\<close>"], ["", "definition normalize_ports_generic\n    :: \"('i common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr list) \\<Rightarrow>\n        ('i common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr) \\<Rightarrow>\n       'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr list\"\n  where\n    \"normalize_ports_generic normalize_pos rewrite_neg m = concat (map normalize_pos (normalize_match (rewrite_neg m)))\""], ["", "lemma normalize_ports_generic_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    and inset: \"m' \\<in> set (normalize_ports_generic normalize_pos rewrite_neg m)\"\n    and noNeg: \"\\<not> has_disc_negated disc False (rewrite_neg m)\"\n    and normalize_nnf_pos: \"\\<And>m m'.\n        normalized_nnf_match  m \\<Longrightarrow> \\<not> has_disc_negated disc False m \\<Longrightarrow>\n          m' \\<in> set (normalize_pos m) \\<Longrightarrow> normalized_nnf_match m'\"\n    shows \"normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m'", "using inset"], ["proof (prove)\nusing this:\n  m' \\<in> set (normalize_ports_generic normalize_pos rewrite_neg m)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m'", "apply(simp add: normalize_ports_generic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (normalize_match (rewrite_neg m)).\n       m' \\<in> set (normalize_pos x) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(elim bexE, rename_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply(subgoal_tac \"normalized_nnf_match a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "using normalized_nnf_match_normalize_match"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_match ?m). normalized_nnf_match m'\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply(erule normalize_nnf_pos, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False a", "apply(rule not_has_disc_normalize_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False (?m24 a)\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (normalize_match (?m24 a))", "using noNeg n"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc False (rewrite_neg m)\n  normalized_nnf_match m\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False (?m24 a)\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (normalize_match (?m24 a))", "by blast+"], ["", "lemma normalize_ports_generic:\n    assumes n: \"normalized_nnf_match m\"\n    and normalize_pos: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated disc False m \\<Longrightarrow>\n                          match_list \\<gamma> (normalize_pos m) a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n    and rewrite_neg: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow>\n                          matches \\<gamma> (rewrite_neg m) a p = matches \\<gamma> m a p\"\n    and noNeg: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\"\n    shows\n        \"match_list \\<gamma> (normalize_ports_generic normalize_pos rewrite_neg m) a p \\<longleftrightarrow> matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list \\<gamma>\n     (normalize_ports_generic normalize_pos rewrite_neg m) a p =\n    matches \\<gamma> m a p", "unfolding normalize_ports_generic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p =\n    matches \\<gamma> m a p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a\n     p \\<Longrightarrow>\n    matches \\<gamma> m a p\n 2. matches \\<gamma> m a p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "have 1: \"ls \\<in> set (normalize_match (rewrite_neg m)) \\<Longrightarrow>\n          match_list \\<gamma> (normalize_pos ls) a p \\<Longrightarrow> normalized_nnf_match ls \\<Longrightarrow> matches \\<gamma> m a p\"\n      for ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     match_list \\<gamma> (normalize_pos ls) a p;\n     normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> m a p", "apply(subst(asm) normalize_pos)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ls\n 2. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False ls\n 3. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> m a p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ls", "using normalized_nnf_match_normalize_match"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_match ?m). normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ls", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False ls\n 2. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> m a p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False ls", "apply(rule_tac m=\"rewrite_neg m\" in not_has_disc_normalize_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\n 2. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (normalize_match (rewrite_neg m))", "using noNeg n"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated disc False (rewrite_neg ?m)\n  normalized_nnf_match m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\n 2. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (normalize_match (rewrite_neg m))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match ls;\n     ls \\<in> set (normalize_match (rewrite_neg m))\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (normalize_match (rewrite_neg m))", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> m a p", "apply(subgoal_tac \"matches \\<gamma> (rewrite_neg m) a p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls;\n     matches \\<gamma> (rewrite_neg m) a p\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> m a p\n 2. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> (rewrite_neg m) a p", "using rewrite_neg[OF n]"], ["proof (prove)\nusing this:\n  matches \\<gamma> (rewrite_neg m) a p = matches \\<gamma> m a p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls;\n     matches \\<gamma> (rewrite_neg m) a p\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> m a p\n 2. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> (rewrite_neg m) a p", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> (rewrite_neg m) a p", "using in_normalized_matches[where \\<gamma>=\\<gamma> and a=a and p=p]"], ["proof (prove)\nusing this:\n  ?ls \\<in> set (normalize_match ?m) \\<and>\n  matches \\<gamma> ?ls a p \\<Longrightarrow>\n  matches \\<gamma> ?m a p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> (rewrite_neg m) a p", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?ls \\<in> set (normalize_match (rewrite_neg m));\n   match_list \\<gamma> (normalize_pos ?ls) a p;\n   normalized_nnf_match ?ls\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> m a p\n\ngoal (2 subgoals):\n 1. match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a\n     p \\<Longrightarrow>\n    matches \\<gamma> m a p\n 2. matches \\<gamma> m a p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "show \"match_list \\<gamma> (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p \\<Longrightarrow> matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a\n     p \\<Longrightarrow>\n    matches \\<gamma> m a p", "apply(simp add: match_list_concat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ls\\<in>set (normalize_match (rewrite_neg m)).\n       match_list \\<gamma> (normalize_pos ls) a p \\<Longrightarrow>\n    matches \\<gamma> m a p", "apply(clarify, rename_tac ls)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        match_list \\<gamma> (normalize_pos ls) a p\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m a p", "apply(subgoal_tac \"normalized_nnf_match ls\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        match_list \\<gamma> (normalize_pos ls) a p;\n        normalized_nnf_match ls\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m a p\n 2. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        match_list \\<gamma> (normalize_pos ls) a p\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ls", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ls \\<in> set (normalize_match (rewrite_neg m));\n   match_list \\<gamma> (normalize_pos ?ls) a p;\n   normalized_nnf_match ?ls\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> m a p\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        match_list \\<gamma> (normalize_pos ls) a p;\n        normalized_nnf_match ls\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m a p\n 2. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        match_list \\<gamma> (normalize_pos ls) a p\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ls", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        match_list \\<gamma> (normalize_pos ls) a p\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ls", "using normalized_nnf_match_normalize_match"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_match ?m). normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        match_list \\<gamma> (normalize_pos ls) a p\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ls", "by blast"], ["proof (state)\nthis:\n  match_list \\<gamma>\n   (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a\n   p \\<Longrightarrow>\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m a p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. matches \\<gamma> m a p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "have 1: \"ls \\<in> set (normalize_match (rewrite_neg m)) \\<Longrightarrow>\n          matches \\<gamma> ls a p \\<Longrightarrow>\n          normalized_nnf_match ls \\<Longrightarrow>\n          match_list \\<gamma> (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p\" for ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> match_list \\<gamma>\n                       (concat\n                         (map normalize_pos\n                           (normalize_match (rewrite_neg m))))\n                       a p", "apply(simp add: match_list_concat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ls\\<in>set (normalize_match (rewrite_neg m)).\n                         match_list \\<gamma> (normalize_pos ls) a p", "apply(rule_tac x=ls in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> match_list \\<gamma> (normalize_pos ls) a p\n 2. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (normalize_match (rewrite_neg m))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (normalize_match (rewrite_neg m))\n 2. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> match_list \\<gamma> (normalize_pos ls) a p", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> match_list \\<gamma> (normalize_pos ls) a p", "apply(subst normalize_pos)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ls\n 2. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False ls\n 3. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> ls a p", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False ls", "apply(rule_tac m=\"rewrite_neg m\" in not_has_disc_normalize_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\n 2. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (normalize_match (rewrite_neg m))", "using noNeg n"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated disc False (rewrite_neg ?m)\n  normalized_nnf_match m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\n 2. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (normalize_match (rewrite_neg m))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n     matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (normalize_match (rewrite_neg m))", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?ls \\<in> set (normalize_match (rewrite_neg m));\n   matches \\<gamma> ?ls a p; normalized_nnf_match ?ls\\<rbrakk>\n  \\<Longrightarrow> match_list \\<gamma>\n                     (concat\n                       (map normalize_pos\n                         (normalize_match (rewrite_neg m))))\n                     a p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m a p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "show \"matches \\<gamma> m a p \\<Longrightarrow> match_list \\<gamma> (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m a p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "apply(subst(asm) rewrite_neg[OF n, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> (rewrite_neg m) a p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "apply(subst(asm) matches_to_match_list_normalize)"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_match (rewrite_neg m)) a\n     p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "apply(subst(asm) match_list_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (normalize_match (rewrite_neg m)).\n       matches \\<gamma> m a p \\<Longrightarrow>\n    match_list \\<gamma>\n     (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p", "apply(elim bexE, rename_tac ls)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        matches \\<gamma> ls a p\\<rbrakk>\n       \\<Longrightarrow> match_list \\<gamma>\n                          (concat\n                            (map normalize_pos\n                              (normalize_match (rewrite_neg m))))\n                          a p", "apply(subgoal_tac \"normalized_nnf_match ls\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n       \\<Longrightarrow> match_list \\<gamma>\n                          (concat\n                            (map normalize_pos\n                              (normalize_match (rewrite_neg m))))\n                          a p\n 2. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        matches \\<gamma> ls a p\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ls", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ls \\<in> set (normalize_match (rewrite_neg m));\n   matches \\<gamma> ?ls a p; normalized_nnf_match ?ls\\<rbrakk>\n  \\<Longrightarrow> match_list \\<gamma>\n                     (concat\n                       (map normalize_pos\n                         (normalize_match (rewrite_neg m))))\n                     a p\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        matches \\<gamma> ls a p; normalized_nnf_match ls\\<rbrakk>\n       \\<Longrightarrow> match_list \\<gamma>\n                          (concat\n                            (map normalize_pos\n                              (normalize_match (rewrite_neg m))))\n                          a p\n 2. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        matches \\<gamma> ls a p\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ls", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        matches \\<gamma> ls a p\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ls", "using normalized_nnf_match_normalize_match"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_match ?m). normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set (normalize_match (rewrite_neg m));\n        matches \\<gamma> ls a p\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ls", "by blast"], ["proof (state)\nthis:\n  matches \\<gamma> m a p \\<Longrightarrow>\n  match_list \\<gamma>\n   (concat (map normalize_pos (normalize_match (rewrite_neg m)))) a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_ports_generic_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"  and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n    and noNeg: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\"\n    and normalize_nnf_pos: \"\\<And>m m'.\n        normalized_nnf_match  m \\<Longrightarrow> \\<not> has_disc_negated disc False m \\<Longrightarrow>\n          m' \\<in> set (normalize_pos m) \\<Longrightarrow> normalized_nnf_match m'\"\n    and normalize_pos: \"\\<And>m m'.\n        normalized_nnf_match m \\<Longrightarrow>  \\<not> has_disc_negated disc False m \\<Longrightarrow> \n          \\<forall>m'\\<in>set (normalize_pos m).\n                 normalized_n_primitive (disc,sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) m'\"\n    shows \"\\<forall>m' \\<in> set (normalize_ports_generic normalize_pos rewrite_neg m). \n             normalized_n_primitive (disc,sel) (\\<lambda>ps. case ps of L4Ports _ pts \\<Rightarrow> length pts \\<le> 1) m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_ports_generic normalize_pos rewrite_neg\n                          m).\n       normalized_n_primitive (disc, sel)\n        (\\<lambda>ps.\n            case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n        m'", "unfolding normalize_ports_generic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (concat\n                          (map normalize_pos\n                            (normalize_match (rewrite_neg m)))).\n       normalized_n_primitive (disc, sel)\n        (\\<lambda>ps.\n            case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n        m'", "apply(intro ballI, rename_tac m')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (concat\n                      (map normalize_pos\n                        (normalize_match\n                          (rewrite_neg m)))) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel)\n        (\\<lambda>ps.\n            case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n        m'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<exists>x\\<in>set (normalize_match (rewrite_neg m)).\n          m' \\<in> set (normalize_pos x) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel)\n        (\\<lambda>ps.\n            case ps of L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n        m'", "apply(elim bexE, rename_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(subgoal_tac \"normalized_nnf_match a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'\n 2. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a\n 2. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "using normalized_nnf_match_normalize_match"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_match ?m). normalized_nnf_match m'\n\ngoal (2 subgoals):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a\n 2. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(subgoal_tac \"\\<not> has_disc_negated disc False a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'\n 2. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False a\n 2. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "subgoal for ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_ \\<in> set (normalize_match (rewrite_neg m));\n     ls \\<in> set (normalize_pos a_); normalized_nnf_match a_\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False a_", "(*TODO: same is already above!*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_ \\<in> set (normalize_match (rewrite_neg m));\n     ls \\<in> set (normalize_pos a_); normalized_nnf_match a_\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False a_", "apply(rule_tac m=\"rewrite_neg m\" in not_has_disc_normalize_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a_ \\<in> set (normalize_match (rewrite_neg m));\n     ls \\<in> set (normalize_pos a_); normalized_nnf_match a_\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\n 2. \\<lbrakk>a_ \\<in> set (normalize_match (rewrite_neg m));\n     ls \\<in> set (normalize_pos a_); normalized_nnf_match a_\\<rbrakk>\n    \\<Longrightarrow> a_ \\<in> set (normalize_match (rewrite_neg m))", "using noNeg n"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated disc False (rewrite_neg ?m)\n  normalized_nnf_match m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a_ \\<in> set (normalize_match (rewrite_neg m));\n     ls \\<in> set (normalize_pos a_); normalized_nnf_match a_\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False (rewrite_neg m)\n 2. \\<lbrakk>a_ \\<in> set (normalize_match (rewrite_neg m));\n     ls \\<in> set (normalize_pos a_); normalized_nnf_match a_\\<rbrakk>\n    \\<Longrightarrow> a_ \\<in> set (normalize_match (rewrite_neg m))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_ \\<in> set (normalize_match (rewrite_neg m));\n     ls \\<in> set (normalize_pos a_); normalized_nnf_match a_\\<rbrakk>\n    \\<Longrightarrow> a_ \\<in> set (normalize_match (rewrite_neg m))", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply(subgoal_tac \"normalized_nnf_match m'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a;\n        normalized_nnf_match m'\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'\n 2. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a;\n        normalized_nnf_match m'\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "using normalize_nnf_pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m; \\<not> has_disc_negated disc False ?m;\n   ?m' \\<in> set (normalize_pos ?m)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (2 subgoals):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a;\n        normalized_nnf_match m'\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a;\n        normalized_nnf_match m'\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "using normalize_pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated disc False ?m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m'\\<in>set (normalize_pos ?m).\n                       normalized_n_primitive (disc, sel)\n                        (\\<lambda>ps.\n                            case ps of\n                            L4Ports x pts \\<Rightarrow> length pts \\<le> 1)\n                        m'\n\ngoal (1 subgoal):\n 1. \\<And>m' a.\n       \\<lbrakk>a \\<in> set (normalize_match (rewrite_neg m));\n        m' \\<in> set (normalize_pos a); normalized_nnf_match a;\n        \\<not> has_disc_negated disc False a;\n        normalized_nnf_match m'\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel)\n                          (\\<lambda>ps.\n                              case ps of\n                              L4Ports x pts \\<Rightarrow>\n                                length pts \\<le> 1)\n                          m'", "by blast"], ["", "lemma normalize_ports_generic_normalize_positive_ports_step_erule:\n    assumes n: \"normalized_nnf_match m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and noProt: \"\\<forall>a. \\<not> disc (Prot a)\" (*disc is src_ports or dst_ports anyway*)\n      and P: \"P (disc2, sel2) m\"\n      and P1: \"\\<And>a. normalized_nnf_match a \\<Longrightarrow> \n                a \\<in> set (normalize_match (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)) \\<Longrightarrow>\n                P (disc2, sel2) a\"\n      and P2: \"\\<And>a dpts rst. normalized_nnf_match a \\<Longrightarrow> \n                    primitive_extractor (disc, sel) a = (dpts, rst) \\<Longrightarrow>\n                    getNeg dpts = [] \\<Longrightarrow> P (disc2, sel2) a \\<Longrightarrow> P (disc2, sel2) rst\"\n      and P3: \"\\<And> a spt rst. P (disc2, sel2) rst \\<Longrightarrow> P (disc2, sel2) (MatchAnd (Match (C spt)) rst)\"\n    shows \"m' \\<in> set (normalize_ports_generic (normalize_positive_ports_step (disc, sel) C) (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one) m) \\<Longrightarrow>\n          P (disc2, sel2) m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m) \\<Longrightarrow>\n    P (disc2, sel2) m'", "using P"], ["proof (prove)\nusing this:\n  P (disc2, sel2) m\n\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m) \\<Longrightarrow>\n    P (disc2, sel2) m'", "apply(simp add: normalize_ports_generic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x\\<in>set (normalize_match\n                                  (rewrite_negated_primitives (disc, sel) C\n                                    l4_ports_negate_one m)).\n                m' \\<in> set (normalize_positive_ports_step (disc, sel) C\n                               x);\n     P (disc2, sel2) m\\<rbrakk>\n    \\<Longrightarrow> P (disc2, sel2) m'", "apply(elim bexE, rename_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (normalize_positive_ports_step (disc, sel) C\n                       a)\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply(subgoal_tac \"normalized_nnf_match a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (normalize_positive_ports_step (disc, sel) C a);\n        normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'\n 2. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (normalize_positive_ports_step (disc, sel) C\n                       a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (normalize_positive_ports_step (disc, sel) C\n                       a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a\n 2. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (normalize_positive_ports_step (disc, sel) C a);\n        normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "using normalized_nnf_match_normalize_match"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_match ?m). normalized_nnf_match m'\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (normalize_positive_ports_step (disc, sel) C\n                       a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match a\n 2. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (normalize_positive_ports_step (disc, sel) C a);\n        normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (normalize_positive_ports_step (disc, sel) C a);\n        normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply(simp add: normalize_positive_ports_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        \\<exists>uu_ uua_.\n           (uua_, uu_) = primitive_extractor (disc, sel) a \\<and>\n           m' \\<in> set (case getNeg uua_ of\n                         [] \\<Rightarrow>\n                           case l4_ports_compress (getPos uua_) of\n                           CannotMatch \\<Rightarrow> []\n                           | MatchesAll \\<Rightarrow> [uu_]\n                           | MatchExpr m \\<Rightarrow>\n                               map (\\<lambda>spt.\n MatchAnd (Match (C spt)) uu_)\n                                (singletonize_L4Ports m));\n        normalized_nnf_match a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply(elim exE conjE, rename_tac rst dpts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        (dpts, rst) = primitive_extractor (disc, sel) a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m))\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply(drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "(*primitive extractor*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply(subgoal_tac \"getNeg dpts = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst);\n        getNeg dpts = []\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'\n 2. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n       \\<Longrightarrow> getNeg dpts = []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n       \\<Longrightarrow> getNeg dpts = []\n 2. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst);\n        getNeg dpts = []\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "subgoal for a rst dpts"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (disc2, sel2) m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     normalized_nnf_match a;\n     m' \\<in> set (case getNeg dpts of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n    \\<Longrightarrow> getNeg dpts = []", "apply(erule iffD1[OF primitive_extractor_correct(8)[OF _ wf_disc_sel]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P (disc2, sel2) m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     m' \\<in> set (case getNeg dpts of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n    \\<Longrightarrow> primitive_extractor (disc, sel) a = (dpts, ?ms1)\n 2. \\<lbrakk>P (disc2, sel2) m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     m' \\<in> set (case getNeg dpts of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False a", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (disc2, sel2) m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     m' \\<in> set (case getNeg dpts of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False a", "apply(rule not_has_disc_normalize_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P (disc2, sel2) m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     m' \\<in> set (case getNeg dpts of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False ?m8\n 2. \\<lbrakk>P (disc2, sel2) m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     m' \\<in> set (case getNeg dpts of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set (normalize_match ?m8)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (disc2, sel2) m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     m' \\<in> set (case getNeg dpts of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a = (dpts, rst)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "apply(rule rewrite_negated_primitives_not_has_disc_negated[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (disc2, sel2) m;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     m' \\<in> set (case getNeg dpts of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a = (dpts, rst);\n     has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pts.\n                         \\<not> has_disc_negated disc False\n                                 (l4_ports_negate_one C pts)", "apply(intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst);\n        has_disc_negated disc False m\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (l4_ports_negate_one C pts)", "apply(rule l4_ports_negate_one_not_has_disc_negated_generic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst);\n        has_disc_negated disc False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a. \\<not> disc (Prot a)", "by(simp add: noProt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst);\n        getNeg dpts = []\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply(subgoal_tac \"P (disc2, sel2) a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        P (disc2, sel2) a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'\n 2. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst);\n        getNeg dpts = []\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst);\n        getNeg dpts = []\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) a\n 2. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        P (disc2, sel2) a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (disc2, sel2) m;\n     a_ \\<in> set (normalize_match\n                    (rewrite_negated_primitives (disc, sel) C\n                      l4_ports_negate_one m));\n     normalized_nnf_match a_;\n     m' \\<in> set (case getNeg dpts_ of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts_) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst_]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst_)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a_ = (dpts_, rst_);\n     getNeg dpts_ = []\\<rbrakk>\n    \\<Longrightarrow> P (disc2, sel2) a_", "apply(rule P1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P (disc2, sel2) m;\n     a_ \\<in> set (normalize_match\n                    (rewrite_negated_primitives (disc, sel) C\n                      l4_ports_negate_one m));\n     normalized_nnf_match a_;\n     m' \\<in> set (case getNeg dpts_ of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts_) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst_]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst_)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a_ = (dpts_, rst_);\n     getNeg dpts_ = []\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match a_\n 2. \\<lbrakk>P (disc2, sel2) m;\n     a_ \\<in> set (normalize_match\n                    (rewrite_negated_primitives (disc, sel) C\n                      l4_ports_negate_one m));\n     normalized_nnf_match a_;\n     m' \\<in> set (case getNeg dpts_ of\n                   [] \\<Rightarrow>\n                     case l4_ports_compress (getPos dpts_) of\n                     CannotMatch \\<Rightarrow> []\n                     | MatchesAll \\<Rightarrow> [rst_]\n                     | MatchExpr m \\<Rightarrow>\n                         map (\\<lambda>spt. MatchAnd (Match (C spt)) rst_)\n                          (singletonize_L4Ports m));\n     primitive_extractor (disc, sel) a_ = (dpts_, rst_);\n     getNeg dpts_ = []\\<rbrakk>\n    \\<Longrightarrow> a_ \\<in> set (normalize_match\n                                     (rewrite_negated_primitives (disc, sel)\n C l4_ports_negate_one m))", "by(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        P (disc2, sel2) a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply(frule_tac a=a in P2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        P (disc2, sel2) a\\<rbrakk>\n       \\<Longrightarrow> primitive_extractor (disc, sel) a =\n                         (?dpts28 a rst dpts, ?rst28 a rst dpts)\n 2. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        P (disc2, sel2) a\\<rbrakk>\n       \\<Longrightarrow> getNeg (?dpts28 a rst dpts) = []\n 3. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        P (disc2, sel2) a\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) a\n 4. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        P (disc2, sel2) a; P (disc2, sel2) (?rst28 a rst dpts)\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply blast+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rst dpts.\n       \\<lbrakk>P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        m' \\<in> set (case getNeg dpts of\n                      [] \\<Rightarrow>\n                        case l4_ports_compress (getPos dpts) of\n                        CannotMatch \\<Rightarrow> []\n                        | MatchesAll \\<Rightarrow> [rst]\n                        | MatchExpr m \\<Rightarrow>\n                            map (\\<lambda>spt. MatchAnd (Match (C spt)) rst)\n                             (singletonize_L4Ports m));\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        P (disc2, sel2) a; P (disc2, sel2) rst\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "apply(simp split: match_compress.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rst dpts x3.\n       \\<lbrakk>primitive_extractor (disc, sel) a = (dpts, rst);\n        getNeg dpts = []; P (disc2, sel2) a; P (disc2, sel2) rst;\n        P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        l4_ports_compress (getPos dpts) = MatchExpr x3;\n        m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n                 set (singletonize_L4Ports x3)\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "using P3"], ["proof (prove)\nusing this:\n  P (disc2, sel2) ?rst \\<Longrightarrow>\n  P (disc2, sel2) (MatchAnd (Match (C ?spt)) ?rst)\n\ngoal (1 subgoal):\n 1. \\<And>a rst dpts x3.\n       \\<lbrakk>primitive_extractor (disc, sel) a = (dpts, rst);\n        getNeg dpts = []; P (disc2, sel2) a; P (disc2, sel2) rst;\n        P (disc2, sel2) m;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m));\n        normalized_nnf_match a;\n        l4_ports_compress (getPos dpts) = MatchExpr x3;\n        m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n                 set (singletonize_L4Ports x3)\\<rbrakk>\n       \\<Longrightarrow> P (disc2, sel2) m'", "by auto"], ["", "(*disc is is_Src_Ports or is_Dst_Ports*)"], ["", "lemma normalize_ports_generic_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and noProt: \"\\<forall>a. \\<not> disc (Prot a)\" (*disc is src_ports or dst_ports anyway*)\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (C a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated disc False m\"\n    shows \"m' \\<in> set (normalize_ports_generic (normalize_positive_ports_step (disc, sel) C) (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one) m) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f m \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "thm normalize_ports_generic_normalize_positive_ports_step_erule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "apply(rule normalize_ports_generic_normalize_positive_ports_step_erule[OF n wf_disc_sel noProt])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m\n 2. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a\n 3. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        normalized_n_primitive (disc2, sel2) f a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst\n 4. \\<And>a spt rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m;\n        normalized_n_primitive (disc2, sel2) f rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f\n                          (MatchAnd (Match (C spt)) rst)\n 5. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> m' \\<in> set (normalize_ports_generic\n                                     (normalize_positive_ports_step\n (disc, sel) C)\n                                     (rewrite_negated_primitives (disc, sel)\n C l4_ports_negate_one)\n                                     m)", "apply(simp_all add: disc2_noC disc2_noProt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a\n 2. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        normalized_n_primitive (disc2, sel2) f a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "apply(rule rewrite_negated_primitives_normalized_preserves_unrelated_helper[OF wf_disc_sel _ _ n])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a. \\<not> disc2 (C a)\n 2. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n                         \\<not> has_disc_negated disc False m\n 3. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m\n 4. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (normalize_match\n (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m))\n 5. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        normalized_n_primitive (disc2, sel2) f a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "apply(simp_all add: disc2_noC disc2_noProt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        normalized_n_primitive (disc2, sel2) f a\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "apply(frule_tac m=a in primitive_extractor_correct(5)[OF _ wf_disc_sel, where P=f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        normalized_n_primitive (disc2, sel2) f a\\<rbrakk>\n       \\<Longrightarrow> primitive_extractor (disc, sel) a =\n                         (?as13 a dpts rst, ?ms13 a dpts rst)\n 2. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_n_primitive (disc2, sel2) f m; normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        normalized_n_primitive (disc2, sel2) f a;\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f a \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f\n            (?ms13 a dpts rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f rst", "by blast+"], ["", "lemma normalize_ports_generic_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc disc2 m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and noProt: \"\\<forall>a. \\<not> disc (Prot a)\" (*disc is src_ports or dst_ports anyway*)\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (C a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated disc False m\"\n     shows \"m'\\<in> set (normalize_ports_generic (normalize_positive_ports_step (disc, sel) C) (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one) m)\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m) \\<Longrightarrow>\n    \\<not> has_disc disc2 m'", "apply(rule normalize_ports_generic_normalize_positive_ports_step_erule[OF n wf_disc_sel noProt])"], ["proof (prove)\ngoal (5 subgoals):\n 1. m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m) \\<Longrightarrow>\n    \\<not> has_disc disc2 m\n 2. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 a\n 3. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        \\<not> has_disc disc2 a\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst\n 4. \\<And>a spt rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        \\<not> has_disc disc2 rst\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (MatchAnd (Match (C spt)) rst)\n 5. m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m)", "apply(simp_all add: disc2_noC disc2_noProt nodisc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 a\n 2. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        \\<not> has_disc disc2 a\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2 a", "thm normalize_match_preserves_nodisc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2 a", "apply(rule_tac m=\"rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m\" in normalize_match_preserves_nodisc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)\n 2. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set (normalize_match\n                                    (rewrite_negated_primitives (disc, sel)\nC l4_ports_negate_one m))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "apply(insert disc2_noProt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n     \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "apply(elim disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<forall>a. \\<not> disc2 (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)\n 2. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "thm rewrite_negated_primitives_not_has_disc[of _ disc2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<forall>a. \\<not> disc2 (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)\n 2. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<forall>a. \\<not> disc2 (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "apply(rule rewrite_negated_primitives_not_has_disc[OF n wf_disc_sel nodisc _ disc2_noC])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<forall>a. \\<not> disc2 (Prot a);\n     has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pts.\n                         \\<not> has_disc disc2 (l4_ports_negate_one C pts)", "using l4_ports_negate_one_nodisc[OF disc2_noC]"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (Prot a) \\<Longrightarrow>\n  \\<not> has_disc disc2 (l4_ports_negate_one C ?pt)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<forall>a. \\<not> disc2 (Prot a);\n     has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pts.\n                         \\<not> has_disc disc2 (l4_ports_negate_one C pts)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "using rewrite_negated_primitives_preserves_not_has_disc[OF n wf_disc_sel nodisc _ disc2_noC]"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc False m \\<Longrightarrow>\n  \\<not> has_disc disc2\n          (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     \\<not> has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        \\<not> has_disc disc2 a\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "apply(frule_tac m=a in primitive_extractor_correct(4)[OF _ wf_disc_sel])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        \\<not> has_disc disc2 a\\<rbrakk>\n       \\<Longrightarrow> primitive_extractor (disc, sel) a =\n                         (?as6 a dpts rst, ?ms6 a dpts rst)\n 2. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        \\<not> has_disc disc2 a;\n        \\<forall>disc2.\n           \\<not> has_disc disc2 a \\<longrightarrow>\n           \\<not> has_disc disc2 (?ms6 a dpts rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "by blast+"], ["", "lemma normalize_ports_generic_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc_negated disc2 False m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and noProt: \"\\<forall>a. \\<not> disc (Prot a)\" (*disc is src_ports or dst_ports anyway*)\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated disc False m\"\n     shows \"m'\\<in> set (normalize_ports_generic (normalize_positive_ports_step (disc, sel) C) (rewrite_negated_primitives (disc, sel) C l4_ports_negate_one) m)\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 False m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m) \\<Longrightarrow>\n    \\<not> has_disc_negated disc2 False m'", "apply(rule normalize_ports_generic_normalize_positive_ports_step_erule[OF n wf_disc_sel noProt])"], ["proof (prove)\ngoal (5 subgoals):\n 1. m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m) \\<Longrightarrow>\n    \\<not> has_disc_negated disc2 False m\n 2. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False a\n 3. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        \\<not> has_disc_negated disc2 False a\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst\n 4. \\<And>a spt rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        \\<not> has_disc_negated disc2 False rst\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                                 (MatchAnd (Match (C spt)) rst)\n 5. m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step (disc, sel) C)\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one)\n                   m)", "apply(simp_all add: disc2_noProt nodisc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        a \\<in> set (normalize_match\n                      (rewrite_negated_primitives (disc, sel) C\n                        l4_ports_negate_one m))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False a\n 2. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        \\<not> has_disc_negated disc2 False a\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False a", "apply(rule_tac m=\"rewrite_negated_primitives (disc, sel) C l4_ports_negate_one m\" in not_has_disc_normalize_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)\n 2. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set (normalize_match\n                                    (rewrite_negated_primitives (disc, sel)\nC l4_ports_negate_one m))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False\n                              (rewrite_negated_primitives (disc, sel) C\n                                l4_ports_negate_one m)", "apply(rule rewrite_negated_primitives_preserves_not_has_disc_negated[OF n wf_disc_sel ])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pts.\n                         \\<not> has_disc_negated disc2 False\n                                 (l4_ports_negate_one C pts)\n 2. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False m", "using disc2_noProt l4_ports_negate_one_not_has_disc_negated_generic"], ["proof (prove)\nusing this:\n  (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n  \\<not> has_disc_negated disc False m\n  \\<forall>a. \\<not> ?disc (Prot a) \\<Longrightarrow>\n  \\<not> has_disc_negated ?disc False (l4_ports_negate_one ?C ?ports)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m));\n     has_disc_negated disc False m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pts.\n                         \\<not> has_disc_negated disc2 False\n                                 (l4_ports_negate_one C pts)\n 2. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False m", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False m", "using nodisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc2 False m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     a \\<in> set (normalize_match\n                   (rewrite_negated_primitives (disc, sel) C\n                     l4_ports_negate_one m))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False m", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a dpts rst.\n       \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                               (normalize_positive_ports_step (disc, sel) C)\n                               (rewrite_negated_primitives (disc, sel) C\n                                 l4_ports_negate_one)\n                               m);\n        normalized_nnf_match a;\n        primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n        \\<not> has_disc_negated disc2 False a\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "subgoal for a dpts rst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n     \\<not> has_disc_negated disc2 False a\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "apply(frule_tac m=a and as=dpts and ms=rst and neg=False in primitive_extractor_correct(6)[OF _ wf_disc_sel])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n     \\<not> has_disc_negated disc2 False a\\<rbrakk>\n    \\<Longrightarrow> primitive_extractor (disc, sel) a = (dpts, rst)\n 2. \\<lbrakk>m' \\<in> set (normalize_ports_generic\n                            (normalize_positive_ports_step (disc, sel) C)\n                            (rewrite_negated_primitives (disc, sel) C\n                              l4_ports_negate_one)\n                            m);\n     normalized_nnf_match a;\n     primitive_extractor (disc, sel) a = (dpts, rst); getNeg dpts = [];\n     \\<not> has_disc_negated disc2 False a;\n     \\<forall>disc2.\n        \\<not> has_disc_negated disc2 False a \\<longrightarrow>\n        \\<not> has_disc_negated disc2 False rst\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 False rst", "by blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition normalize_src_ports\n    :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr list\"\n  where\n    \"normalize_src_ports m = normalize_ports_generic normalize_positive_src_ports rewrite_negated_src_ports m\""], ["", "definition normalize_dst_ports\n    :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr list\"\n  where\n    \"normalize_dst_ports m = normalize_ports_generic normalize_positive_dst_ports rewrite_negated_dst_ports m\""], ["", "lemma normalize_src_ports:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    shows \"match_list (\\<beta>, \\<alpha>) (normalize_src_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>) (normalize_src_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: normalize_src_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>)\n     (normalize_ports_generic normalize_positive_src_ports\n       rewrite_negated_src_ports m)\n     a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(rule normalize_ports_generic[OF n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated ?disc False m\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (normalize_positive_src_ports m) a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (rewrite_negated_src_ports m) a p =\n       matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<not> has_disc_negated ?disc False (rewrite_negated_src_ports m)", "using normalize_positive_src_ports[OF generic]\n             rewrite_negated_src_ports[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p]\n             rewrite_negated_src_ports_not_has_disc_negated"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Src_Ports False ?m\\<rbrakk>\n  \\<Longrightarrow> match_list (\\<beta>, ?\\<alpha>)\n                     (normalize_positive_src_ports ?m) ?a ?p =\n                    matches (\\<beta>, ?\\<alpha>) ?m ?a ?p\n  normalized_nnf_match ?m \\<Longrightarrow>\n  matches (\\<beta>, \\<alpha>) (rewrite_negated_src_ports ?m) a p =\n  matches (\\<beta>, \\<alpha>) ?m a p\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated is_Src_Ports False (rewrite_negated_src_ports ?m)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated ?disc False m\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (normalize_positive_src_ports m) a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (rewrite_negated_src_ports m) a p =\n       matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<not> has_disc_negated ?disc False (rewrite_negated_src_ports m)", "by blast+"], ["", "lemma normalize_dst_ports:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    shows \"match_list (\\<beta>, \\<alpha>) (normalize_dst_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>) (normalize_dst_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: normalize_dst_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>)\n     (normalize_ports_generic normalize_positive_dst_ports\n       rewrite_negated_dst_ports m)\n     a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(rule normalize_ports_generic[OF n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated ?disc False m\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (normalize_positive_dst_ports m) a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (rewrite_negated_dst_ports m) a p =\n       matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<not> has_disc_negated ?disc False (rewrite_negated_dst_ports m)", "using normalize_positive_dst_ports[OF generic]\n             rewrite_negated_dst_ports[OF generic, where \\<alpha>=\\<alpha> and a=a and p=p]\n             rewrite_negated_dst_ports_not_has_disc_negated"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Dst_Ports False ?m\\<rbrakk>\n  \\<Longrightarrow> match_list (\\<beta>, ?\\<alpha>)\n                     (normalize_positive_dst_ports ?m) ?a ?p =\n                    matches (\\<beta>, ?\\<alpha>) ?m ?a ?p\n  normalized_nnf_match ?m \\<Longrightarrow>\n  matches (\\<beta>, \\<alpha>) (rewrite_negated_dst_ports ?m) a p =\n  matches (\\<beta>, \\<alpha>) ?m a p\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated is_Dst_Ports False (rewrite_negated_dst_ports ?m)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated ?disc False m\\<rbrakk>\n       \\<Longrightarrow> match_list (\\<beta>, \\<alpha>)\n                          (normalize_positive_dst_ports m) a p =\n                         matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (rewrite_negated_dst_ports m) a p =\n       matches (\\<beta>, \\<alpha>) m a p\n 3. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<not> has_disc_negated ?disc False (rewrite_negated_dst_ports m)", "by blast+"], ["", "lemma normalize_src_ports_normalized_n_primitive:\n    assumes n:\"normalized_nnf_match m\"\n    shows \"\\<forall>m' \\<in> set (normalize_src_ports m). normalized_src_ports m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_src_ports m). normalized_src_ports m'", "unfolding normalize_src_ports_def normalized_src_ports_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_ports_generic\n                          normalize_positive_src_ports\n                          rewrite_negated_src_ports m).\n       normalized_n_primitive (is_Src_Ports, src_ports_sel)\n        (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "apply(rule normalize_ports_generic_normalized_n_primitive[OF n wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<not> has_disc_negated is_Src_Ports False\n               (rewrite_negated_src_ports m)\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m;\n        m' \\<in> set (normalize_positive_src_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 3. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_src_ports m).\n                            normalized_n_primitive\n                             (is_Src_Ports, src_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "using rewrite_negated_src_ports_not_has_disc_negated"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated is_Src_Ports False (rewrite_negated_src_ports ?m)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<not> has_disc_negated is_Src_Ports False\n               (rewrite_negated_src_ports m)\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m;\n        m' \\<in> set (normalize_positive_src_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 3. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_src_ports m).\n                            normalized_n_primitive\n                             (is_Src_Ports, src_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m;\n        m' \\<in> set (normalize_positive_src_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_src_ports m).\n                            normalized_n_primitive\n                             (is_Src_Ports, src_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "using normalize_positive_src_ports_nnf"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Src_Ports False ?m;\n   ?m' \\<in> set (normalize_positive_src_ports ?m)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m;\n        m' \\<in> set (normalize_positive_src_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_src_ports m).\n                            normalized_n_primitive\n                             (is_Src_Ports, src_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_src_ports m).\n                            normalized_n_primitive\n                             (is_Src_Ports, src_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "unfolding normalized_src_ports_def2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_src_ports m).\n                            normalized_src_ports m'", "using normalize_positive_src_ports_normalized_n_primitive"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Src_Ports False ?m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m'\\<in>set (normalize_positive_src_ports ?m).\n                       normalized_src_ports m'\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_src_ports m).\n                            normalized_src_ports m'", "by blast"], ["", "lemma normalize_dst_ports_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n    shows \"\\<forall>m' \\<in> set (normalize_dst_ports m). normalized_dst_ports m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_dst_ports m). normalized_dst_ports m'", "unfolding normalize_dst_ports_def normalized_dst_ports_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_ports_generic\n                          normalize_positive_dst_ports\n                          rewrite_negated_dst_ports m).\n       normalized_n_primitive (is_Dst_Ports, dst_ports_sel)\n        (case_ipt_l4_ports (\\<lambda>x pts. length pts \\<le> 1)) m'", "apply(rule normalize_ports_generic_normalized_n_primitive[OF n wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<not> has_disc_negated is_Dst_Ports False\n               (rewrite_negated_dst_ports m)\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m;\n        m' \\<in> set (normalize_positive_dst_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 3. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_dst_ports m).\n                            normalized_n_primitive\n                             (is_Dst_Ports, dst_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "using rewrite_negated_dst_ports_not_has_disc_negated"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated is_Dst_Ports False (rewrite_negated_dst_ports ?m)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<not> has_disc_negated is_Dst_Ports False\n               (rewrite_negated_dst_ports m)\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m;\n        m' \\<in> set (normalize_positive_dst_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 3. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_dst_ports m).\n                            normalized_n_primitive\n                             (is_Dst_Ports, dst_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m;\n        m' \\<in> set (normalize_positive_dst_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_dst_ports m).\n                            normalized_n_primitive\n                             (is_Dst_Ports, dst_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "using normalize_positive_dst_ports_nnf"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Dst_Ports False ?m;\n   ?m' \\<in> set (normalize_positive_dst_ports ?m)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m;\n        m' \\<in> set (normalize_positive_dst_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_dst_ports m).\n                            normalized_n_primitive\n                             (is_Dst_Ports, dst_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_dst_ports m).\n                            normalized_n_primitive\n                             (is_Dst_Ports, dst_ports_sel)\n                             (\\<lambda>ps.\n                                 case ps of\n                                 L4Ports x pts \\<Rightarrow>\n                                   length pts \\<le> 1)\n                             m'", "unfolding normalized_dst_ports_def2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_dst_ports m).\n                            normalized_dst_ports m'", "using normalize_positive_dst_ports_normalized_n_primitive"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Dst_Ports False ?m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m'\\<in>set (normalize_positive_dst_ports ?m).\n                       normalized_dst_ports m'\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_positive_dst_ports m).\n                            normalized_dst_ports m'", "by blast"], ["", "lemma normalize_src_ports_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    shows \"m' \\<in> set (normalize_src_ports m) \\<Longrightarrow> normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(simp add: normalize_src_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_ports_generic normalize_positive_src_ports\n                   rewrite_negated_src_ports m) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(erule normalize_ports_generic_nnf[OF n])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> has_disc_negated ?disc False (rewrite_negated_src_ports m)\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated ?disc False m;\n        m' \\<in> set (normalize_positive_src_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "using n rewrite_negated_src_ports_not_has_disc_negated"], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated is_Src_Ports False (rewrite_negated_src_ports ?m)\n\ngoal (2 subgoals):\n 1. \\<not> has_disc_negated ?disc False (rewrite_negated_src_ports m)\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated ?disc False m;\n        m' \\<in> set (normalize_positive_src_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m;\n        m' \\<in> set (normalize_positive_src_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "using normalize_positive_src_ports_nnf"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Src_Ports False ?m;\n   ?m' \\<in> set (normalize_positive_src_ports ?m)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Src_Ports False m;\n        m' \\<in> set (normalize_positive_src_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "by blast"], ["", "lemma normalize_dst_ports_nnf:\n    assumes n: \"normalized_nnf_match m\"\n    shows \"m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow> normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(simp add: normalize_dst_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_ports_generic normalize_positive_dst_ports\n                   rewrite_negated_dst_ports m) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(erule normalize_ports_generic_nnf[OF n])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> has_disc_negated ?disc False (rewrite_negated_dst_ports m)\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated ?disc False m;\n        m' \\<in> set (normalize_positive_dst_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "using n rewrite_negated_dst_ports_not_has_disc_negated"], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  normalized_nnf_match ?m \\<Longrightarrow>\n  \\<not> has_disc_negated is_Dst_Ports False (rewrite_negated_dst_ports ?m)\n\ngoal (2 subgoals):\n 1. \\<not> has_disc_negated ?disc False (rewrite_negated_dst_ports m)\n 2. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated ?disc False m;\n        m' \\<in> set (normalize_positive_dst_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m;\n        m' \\<in> set (normalize_positive_dst_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "using normalize_positive_dst_ports_nnf"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Dst_Ports False ?m;\n   ?m' \\<in> set (normalize_positive_dst_ports ?m)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>normalized_nnf_match m;\n        \\<not> has_disc_negated is_Dst_Ports False m;\n        m' \\<in> set (normalize_positive_dst_ports m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "by blast"], ["", "lemma normalize_src_ports_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Src_Ports False m\"\n    shows \"m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  m \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_src_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "apply(rule normalize_ports_generic_preserves_normalized_n_primitive[OF n wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_src_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a. \\<not> is_Src_Ports (Prot a)\n 2. \\<lbrakk>m' \\<in> set (normalize_src_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a. \\<not> disc2 (Src_Ports a)\n 3. \\<lbrakk>m' \\<in> set (normalize_src_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n                      \\<not> has_disc_negated is_Src_Ports False m\n 4. \\<lbrakk>m' \\<in> set (normalize_src_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> m' \\<in> set (normalize_ports_generic\n                                     (normalize_positive_ports_step\n (is_Src_Ports, src_ports_sel) Src_Ports)\n                                     (rewrite_negated_primitives\n (is_Src_Ports, src_ports_sel) Src_Ports l4_ports_negate_one)\n                                     m)\n 5. \\<lbrakk>m' \\<in> set (normalize_src_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m", "by(simp_all add: disc2_noC disc2_noProt normalize_src_ports_def normalize_ports_generic_def\n                normalize_positive_src_ports_def rewrite_negated_src_ports_def)"], ["", "lemma normalize_dst_ports_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Dst_Ports False m\"\n    shows \"m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  m \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_dst_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "apply(rule normalize_ports_generic_preserves_normalized_n_primitive[OF n wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>m' \\<in> set (normalize_dst_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a. \\<not> is_Dst_Ports (Prot a)\n 2. \\<lbrakk>m' \\<in> set (normalize_dst_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a. \\<not> disc2 (Dst_Ports a)\n 3. \\<lbrakk>m' \\<in> set (normalize_dst_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n                      \\<not> has_disc_negated is_Dst_Ports False m\n 4. \\<lbrakk>m' \\<in> set (normalize_dst_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> m' \\<in> set (normalize_ports_generic\n                                     (normalize_positive_ports_step\n (is_Dst_Ports, dst_ports_sel) Dst_Ports)\n                                     (rewrite_negated_primitives\n (is_Dst_Ports, dst_ports_sel) Dst_Ports l4_ports_negate_one)\n                                     m)\n 5. \\<lbrakk>m' \\<in> set (normalize_dst_ports m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m", "by(simp_all add: disc2_noC disc2_noProt normalize_dst_ports_def normalize_ports_generic_def\n                normalize_positive_dst_ports_def rewrite_negated_dst_ports_def)"], ["", "lemma normalize_src_ports_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc disc2 m\"\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Src_Ports False m\"\n     shows \"m'\\<in> set (normalize_src_ports m)\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    \\<not> has_disc disc2 m'", "apply(rule normalize_ports_generic_preserves_normalized_not_has_disc[OF n nodisc wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (4 subgoals):\n 1. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    \\<forall>a. \\<not> is_Src_Ports (Prot a)\n 2. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    \\<forall>a. \\<not> disc2 (Src_Ports a)\n 3. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n    \\<not> has_disc_negated is_Src_Ports False m\n 4. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step\n                     (is_Src_Ports, src_ports_sel) Src_Ports)\n                   (rewrite_negated_primitives (is_Src_Ports, src_ports_sel)\n                     Src_Ports l4_ports_negate_one)\n                   m)", "apply(simp add: disc2_noC disc2_noProt)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step\n                     (is_Src_Ports, src_ports_sel) Src_Ports)\n                   (rewrite_negated_primitives (is_Src_Ports, src_ports_sel)\n                     Src_Ports l4_ports_negate_one)\n                   m)", "by (simp add: normalize_ports_generic_def normalize_positive_src_ports_def normalize_src_ports_def rewrite_negated_src_ports_def)"], ["", "lemma normalize_dst_ports_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc disc2 m\"\n      and disc2_noC: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Dst_Ports False m\"\n     shows \"m'\\<in> set (normalize_dst_ports m)\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    \\<not> has_disc disc2 m'", "apply(rule normalize_ports_generic_preserves_normalized_not_has_disc[OF n nodisc wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (4 subgoals):\n 1. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    \\<forall>a. \\<not> is_Dst_Ports (Prot a)\n 2. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    \\<forall>a. \\<not> disc2 (Dst_Ports a)\n 3. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n    \\<not> has_disc_negated is_Dst_Ports False m\n 4. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step\n                     (is_Dst_Ports, dst_ports_sel) Dst_Ports)\n                   (rewrite_negated_primitives (is_Dst_Ports, dst_ports_sel)\n                     Dst_Ports l4_ports_negate_one)\n                   m)", "apply(simp add: disc2_noC disc2_noProt)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step\n                     (is_Dst_Ports, dst_ports_sel) Dst_Ports)\n                   (rewrite_negated_primitives (is_Dst_Ports, dst_ports_sel)\n                     Dst_Ports l4_ports_negate_one)\n                   m)", "by (simp add: normalize_ports_generic_def normalize_positive_dst_ports_def normalize_dst_ports_def rewrite_negated_dst_ports_def)"], ["", "lemma normalize_src_ports_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc_negated disc2 False m\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Src_Ports False m\"\n     shows \"m'\\<in> set (normalize_src_ports m)\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 False m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    \\<not> has_disc_negated disc2 False m'", "apply(rule normalize_ports_generic_preserves_normalized_not_has_disc_negated[OF n nodisc wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    \\<forall>a. \\<not> is_Src_Ports (Prot a)\n 2. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n    \\<not> has_disc_negated is_Src_Ports False m\n 3. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step\n                     (is_Src_Ports, src_ports_sel) Src_Ports)\n                   (rewrite_negated_primitives (is_Src_Ports, src_ports_sel)\n                     Src_Ports l4_ports_negate_one)\n                   m)", "apply(simp add: disc2_noProt)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_src_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step\n                     (is_Src_Ports, src_ports_sel) Src_Ports)\n                   (rewrite_negated_primitives (is_Src_Ports, src_ports_sel)\n                     Src_Ports l4_ports_negate_one)\n                   m)", "by (simp add: normalize_ports_generic_def normalize_positive_src_ports_def normalize_src_ports_def rewrite_negated_src_ports_def)"], ["", "lemma normalize_dst_ports_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" and nodisc: \"\\<not> has_disc_negated disc2 False m\"\n      and disc2_noProt: \"(\\<forall>a. \\<not> disc2 (Prot a)) \\<or> \\<not> has_disc_negated is_Dst_Ports False m\"\n     shows \"m'\\<in> set (normalize_dst_ports m)\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 False m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    \\<not> has_disc_negated disc2 False m'", "apply(rule normalize_ports_generic_preserves_normalized_not_has_disc_negated[OF n nodisc wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    \\<forall>a. \\<not> is_Dst_Ports (Prot a)\n 2. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    (\\<forall>a. \\<not> disc2 (Prot a)) \\<or>\n    \\<not> has_disc_negated is_Dst_Ports False m\n 3. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step\n                     (is_Dst_Ports, dst_ports_sel) Dst_Ports)\n                   (rewrite_negated_primitives (is_Dst_Ports, dst_ports_sel)\n                     Dst_Ports l4_ports_negate_one)\n                   m)", "apply(simp add: disc2_noProt)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_dst_ports m) \\<Longrightarrow>\n    m' \\<in> set (normalize_ports_generic\n                   (normalize_positive_ports_step\n                     (is_Dst_Ports, dst_ports_sel) Dst_Ports)\n                   (rewrite_negated_primitives (is_Dst_Ports, dst_ports_sel)\n                     Dst_Ports l4_ports_negate_one)\n                   m)", "by (simp add: normalize_ports_generic_def normalize_positive_dst_ports_def normalize_dst_ports_def rewrite_negated_dst_ports_def)"], ["", "value[code] \"normalize_src_ports\n                (MatchAnd (Match (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n                   (MatchAnd (Match (Prot (Proto TCP)))\n                        (MatchNot (Match (Src_Ports (L4Ports UDP [(80,80)]))))\n                 ))\""], ["", "lemma \"map opt_MatchAny_match_expr (normalize_src_ports\n                (MatchAnd (Match (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n                   (MatchAnd (Match (Prot (Proto TCP)))\n                        (MatchNot (Match (Src_Ports (L4Ports UDP [(80,80)]))))\n                 ))) =\n [MatchAnd (MatchNot (Match (Prot (Proto UDP)))) (MatchAnd (Match (Dst (IpAddrNetmask 0x7F000000 8))) (Match (Prot (Proto TCP)))),\n  MatchAnd (Match (Src_Ports (L4Ports UDP [(0, 79)]))) (MatchAnd (Match (Dst (IpAddrNetmask 0x7F000000 8))) (Match (Prot (Proto TCP)))),\n  MatchAnd (Match (Src_Ports (L4Ports UDP [(81, 0xFFFF)]))) (MatchAnd (Match (Dst (IpAddrNetmask 0x7F000000 8))) (Match (Prot (Proto TCP))))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map opt_MatchAny_match_expr\n     (normalize_src_ports\n       (MatchAnd\n         (Match\n           (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n         (MatchAnd (Match (Prot (Proto TCP)))\n           (MatchNot (Match (Src_Ports (L4Ports UDP [(80, 80)]))))))) =\n    [MatchAnd (MatchNot (Match (Prot (Proto UDP))))\n      (MatchAnd (Match (Dst (IpAddrNetmask 2130706432 8)))\n        (Match (Prot (Proto TCP)))),\n     MatchAnd (Match (Src_Ports (L4Ports UDP [(0, 79)])))\n      (MatchAnd (Match (Dst (IpAddrNetmask 2130706432 8)))\n        (Match (Prot (Proto TCP)))),\n     MatchAnd (Match (Src_Ports (L4Ports UDP [(81, 65535)])))\n      (MatchAnd (Match (Dst (IpAddrNetmask 2130706432 8)))\n        (Match (Prot (Proto TCP))))]", "by eval"], ["", "lemma \"map opt_MatchAny_match_expr (normalize_src_ports\n                (MatchAnd (Match (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n                   (MatchAnd (Match (Prot (Proto ICMP)))\n                     (MatchAnd (Match (Src_Ports (L4Ports TCP [(22,22)])))\n                        (MatchNot (Match (Src_Ports (L4Ports UDP [(80,80)]))))\n                 ))))\n =\n[MatchAnd (Match (Src_Ports (L4Ports TCP [(22, 22)])))\n   (MatchAnd (MatchNot (Match (Prot (Proto UDP)))) (MatchAnd (Match (Dst (IpAddrNetmask 0x7F000000 8))) (Match (Prot (Proto ICMP)))))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map opt_MatchAny_match_expr\n     (normalize_src_ports\n       (MatchAnd\n         (Match\n           (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n         (MatchAnd (Match (Prot (Proto ICMP)))\n           (MatchAnd (Match (Src_Ports (L4Ports TCP [(22, 22)])))\n             (MatchNot (Match (Src_Ports (L4Ports UDP [(80, 80)])))))))) =\n    [MatchAnd (Match (Src_Ports (L4Ports TCP [(22, 22)])))\n      (MatchAnd (MatchNot (Match (Prot (Proto UDP))))\n        (MatchAnd (Match (Dst (IpAddrNetmask 2130706432 8)))\n          (Match (Prot (Proto ICMP)))))]", "by eval"], ["", "lemma \"map opt_MatchAny_match_expr (normalize_src_ports\n                (MatchAnd (Match ((Src_Ports (L4Ports UDP [(21,21), (22,22)])) :: 32 common_primitive))\n                  (Match (Prot (Proto UDP)))))\n  =\n[MatchAnd (Match (Src_Ports (L4Ports UDP [(21, 22)]))) (Match (Prot (Proto UDP)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map opt_MatchAny_match_expr\n     (normalize_src_ports\n       (MatchAnd (Match (Src_Ports (L4Ports UDP [(21, 21), (22, 22)])))\n         (Match (Prot (Proto UDP))))) =\n    [MatchAnd (Match (Src_Ports (L4Ports UDP [(21, 22)])))\n      (Match (Prot (Proto UDP)))]", "by eval"], ["", "lemma \"normalize_match (andfold_MatchExp (map (l4_ports_negate_one C) [])) = [MatchAny]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_match (andfold_MatchExp (map (l4_ports_negate_one C) [])) =\n    [MatchAny]", "by(simp)"], ["", "(*scratch*)\n(*TODO: move?*)\n  (*TODO: add nnf_normalization directly afterwards?*)"], ["", "definition replace_primitive_matchexpr\n    :: \"(('a \\<Rightarrow> bool) \\<times> ('a \\<Rightarrow> 'b)) \\<Rightarrow> \\<comment> \\<open>\\<open>disc_sel\\<close>\\<close>\n        ('b negation_type \\<Rightarrow> 'a match_expr) \\<Rightarrow> \\<comment> \\<open>replace function\\<close>\n        'a match_expr \\<Rightarrow> 'a match_expr\" where\n    \"replace_primitive_matchexpr disc_sel replace_f m \\<equiv>\n        let (as, rst) = primitive_extractor disc_sel m\n        in if as = [] then m else \n          MatchAnd\n            (andfold_MatchExp (map replace_f as))\n            rst\""], ["", "text\\<open>It does nothing of there is not even a primitive in it\\<close>"], ["", "lemma replace_primitive_matchexpr_unchanged_if_not_has_disc:\n  assumes n: \"normalized_nnf_match m\"\n  and wf_disc_sel: \"wf_disc_sel (disc,sel) C\" (*any C*)\n  and noDisc: \"\\<not> has_disc disc m\"\n  shows \"replace_primitive_matchexpr (disc,sel) replace_f m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_primitive_matchexpr (disc, sel) replace_f m = m", "apply(simp add: replace_primitive_matchexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case primitive_extractor (disc, sel) m of\n     (as, rst) \\<Rightarrow>\n       if as = [] then m\n       else MatchAnd (andfold_MatchExp (map replace_f as)) rst) =\n    m", "apply(case_tac \"primitive_extractor (disc,sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       (case primitive_extractor (disc, sel) m of\n        (as, rst) \\<Rightarrow>\n          if as = [] then m\n          else MatchAnd (andfold_MatchExp (map replace_f as)) rst) =\n       m", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       spts \\<noteq> [] \\<longrightarrow>\n       MatchAnd (andfold_MatchExp (map replace_f spts)) rst = m", "apply(frule primitive_extractor_correct(7)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        (\\<not> has_disc disc m) = (spts = [] \\<and> rst = m)\\<rbrakk>\n       \\<Longrightarrow> spts \\<noteq> [] \\<longrightarrow>\n                         MatchAnd (andfold_MatchExp (map replace_f spts))\n                          rst =\n                         m", "using noDisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc m\n\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        (\\<not> has_disc disc m) = (spts = [] \\<and> rst = m)\\<rbrakk>\n       \\<Longrightarrow> spts \\<noteq> [] \\<longrightarrow>\n                         MatchAnd (andfold_MatchExp (map replace_f spts))\n                          rst =\n                         m", "by blast+"], ["", "(*lemma replace_primitive_matchexpr_preserves_not_has_disc:\n  assumes n: \"normalized_nnf_match m\"\n  and wf_disc_sel: \"wf_disc_sel (disc, sel) C'\"\n  and nodisc: \"\\<not> has_disc disc2 m\"\n  and noNeg: \"\\<not> has_disc disc m\"\n  and disc2_noC: \"\\<forall>a. \\<not> disc2 (C a)\"\n  shows \"\\<not> has_disc disc2 (replace_primitive_matchexpr (disc, sel) negate_f m)\"\n    apply(subst replace_primitive_matchexpr_unchanged_if_not_has_disc)\n    using n wf_disc_sel noNeg nodisc by(simp)+*)"], ["", "lemma replace_primitive_matchexpr:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel disc_sel C\"\n  and replace_f: \"\\<forall>pt. matches \\<gamma> (replace_f pt) a p \\<longleftrightarrow>\n                        matches \\<gamma> (negation_type_to_match_expr_f C pt) a p\"\n  shows \"matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a p \\<longleftrightarrow> matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a\n     p =\n    matches \\<gamma> m a p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a\n     p =\n    matches \\<gamma> m a p", "obtain spts rst where pext: \"primitive_extractor disc_sel m = (spts, rst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>spts rst.\n        primitive_extractor disc_sel m = (spts, rst) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"primitive_extractor disc_sel m\") simp"], ["proof (state)\nthis:\n  primitive_extractor disc_sel m = (spts, rst)\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a\n     p =\n    matches \\<gamma> m a p", "obtain disc sel where disc_sel: \"disc_sel = (disc, sel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>disc sel.\n        disc_sel = (disc, sel) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases disc_sel) simp"], ["proof (state)\nthis:\n  disc_sel = (disc, sel)\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a\n     p =\n    matches \\<gamma> m a p", "with wf_disc_sel"], ["proof (chain)\npicking this:\n  wf_disc_sel disc_sel C\n  disc_sel = (disc, sel)", "have wf_disc_sel': \"wf_disc_sel (disc, sel) C\""], ["proof (prove)\nusing this:\n  wf_disc_sel disc_sel C\n  disc_sel = (disc, sel)\n\ngoal (1 subgoal):\n 1. wf_disc_sel (disc, sel) C", "by simp"], ["proof (state)\nthis:\n  wf_disc_sel (disc, sel) C\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a\n     p =\n    matches \\<gamma> m a p", "from disc_sel pext"], ["proof (chain)\npicking this:\n  disc_sel = (disc, sel)\n  primitive_extractor disc_sel m = (spts, rst)", "have pext': \"primitive_extractor (disc, sel) m = (spts, rst)\""], ["proof (prove)\nusing this:\n  disc_sel = (disc, sel)\n  primitive_extractor disc_sel m = (spts, rst)\n\ngoal (1 subgoal):\n 1. primitive_extractor (disc, sel) m = (spts, rst)", "by simp"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (spts, rst)\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a\n     p =\n    matches \\<gamma> m a p", "have \"matches \\<gamma> (andfold_MatchExp (map replace_f spts)) a p \\<and> matches \\<gamma> rst a p \\<longleftrightarrow>\n       matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (matches \\<gamma> (andfold_MatchExp (map replace_f spts)) a p \\<and>\n     matches \\<gamma> rst a p) =\n    matches \\<gamma> m a p", "apply(subst primitive_extractor_correct(1)[OF n wf_disc_sel' pext', symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (matches \\<gamma> (andfold_MatchExp (map replace_f spts)) a p \\<and>\n     matches \\<gamma> rst a p) =\n    (matches \\<gamma> (alist_and (NegPos_map C spts)) a p \\<and>\n     matches \\<gamma> rst a p)", "apply(simp add: andfold_MatchExp_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<in>set spts. matches \\<gamma> (replace_f m) a p) \\<and>\n     matches \\<gamma> rst a p) =\n    (matches \\<gamma> (alist_and (NegPos_map C spts)) a p \\<and>\n     matches \\<gamma> rst a p)", "apply(simp add: replace_f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<in>set spts.\n         matches \\<gamma> (negation_type_to_match_expr_f C m) a p) \\<and>\n     matches \\<gamma> rst a p) =\n    (matches \\<gamma> (alist_and (NegPos_map C spts)) a p \\<and>\n     matches \\<gamma> rst a p)", "using alist_and_negation_type_to_match_expr_f_matches"], ["proof (prove)\nusing this:\n  matches ?\\<gamma> (alist_and (NegPos_map ?C ?spts)) ?a ?p =\n  (\\<forall>m\\<in>set ?spts.\n      matches ?\\<gamma> (negation_type_to_match_expr_f ?C m) ?a ?p)\n\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<in>set spts.\n         matches \\<gamma> (negation_type_to_match_expr_f C m) a p) \\<and>\n     matches \\<gamma> rst a p) =\n    (matches \\<gamma> (alist_and (NegPos_map C spts)) a p \\<and>\n     matches \\<gamma> rst a p)", "by fast"], ["proof (state)\nthis:\n  (matches \\<gamma> (andfold_MatchExp (map replace_f spts)) a p \\<and>\n   matches \\<gamma> rst a p) =\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a\n     p =\n    matches \\<gamma> m a p", "thus ?thesis"], ["proof (prove)\nusing this:\n  (matches \\<gamma> (andfold_MatchExp (map replace_f spts)) a p \\<and>\n   matches \\<gamma> rst a p) =\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a\n     p =\n    matches \\<gamma> m a p", "by(simp add: replace_primitive_matchexpr_def pext bunch_of_lemmata_about_matches)"], ["proof (state)\nthis:\n  matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a p =\n  matches \\<gamma> m a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replace_primitive_matchexpr_replaces_disc:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n  and replace_f: \"\\<forall>a. \\<not> has_disc disc (replace_f a)\"\n  shows \"\\<not> has_disc disc (replace_primitive_matchexpr (disc, sel) replace_f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc\n            (replace_primitive_matchexpr (disc, sel) replace_f m)", "apply(simp add: replace_primitive_matchexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc\n            (case primitive_extractor (disc, sel) m of\n             (as, rst) \\<Rightarrow>\n               if as = [] then m\n               else MatchAnd (andfold_MatchExp (map replace_f as)) rst)", "apply(case_tac \"primitive_extractor (disc,sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       \\<not> has_disc disc\n               (case primitive_extractor (disc, sel) m of\n                (as, rst) \\<Rightarrow>\n                  if as = [] then m\n                  else MatchAnd (andfold_MatchExp (map replace_f as)) rst)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       (spts = [] \\<longrightarrow> \\<not> has_disc disc m) \\<and>\n       (spts \\<noteq> [] \\<longrightarrow>\n        \\<not> has_disc disc (andfold_MatchExp (map replace_f spts)) \\<and>\n        \\<not> has_disc disc rst)", "apply(frule primitive_extractor_correct(3)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp\n                                    (map replace_f spts)) \\<and>\n                          \\<not> has_disc disc rst)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp (map replace_f spts)))", "apply(frule primitive_extractor_correct(7)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc disc m) = (spts = [] \\<and> rst = m)\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp (map replace_f spts)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc disc m) = (spts = [] \\<and> rst = m)\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow> rst = m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp (map replace_f spts)))", "apply(case_tac \"\\<not> has_disc disc m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc disc m) = (spts = [] \\<and> rst = m);\n        \\<not> has_disc disc m\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow> rst = m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp (map replace_f spts)))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc disc m) = (spts = [] \\<and> rst = m);\n        \\<not> \\<not> has_disc disc m\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow> rst = m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp (map replace_f spts)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        (\\<not> has_disc disc m) = (spts = [] \\<and> rst = m);\n        \\<not> \\<not> has_disc disc m\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow> rst = m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp (map replace_f spts)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        spts = [] \\<longrightarrow> rst \\<noteq> m; has_disc disc m\\<rbrakk>\n       \\<Longrightarrow> spts \\<noteq> [] \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp (map replace_f spts)))", "apply(frule(1) primitive_extractor_correct(9)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst;\n        spts = [] \\<longrightarrow> rst \\<noteq> m; has_disc disc m;\n        spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> spts \\<noteq> [] \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc\n                                  (andfold_MatchExp (map replace_f spts)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst; has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (andfold_MatchExp (map replace_f spts))", "apply(rule MatchExpr_Fold.andfold_MatchExp_not_discI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst; has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (map replace_f spts).\n                            \\<not> has_disc disc m", "using replace_f"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> has_disc disc (replace_f a)\n\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<not> has_disc disc rst; has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (map replace_f spts).\n                            \\<not> has_disc disc m", "by simp"], ["", "lemma replace_primitive_matchexpr_preserves_not_has_disc:\n  assumes n: \"normalized_nnf_match m\" and wf_disc_sel: \"wf_disc_sel (disc,sel) C\"\n  and nodisc: \"\\<not> has_disc disc2 m\"\n  and replace_f: \"has_disc disc m \\<Longrightarrow> \\<forall>pts. \\<not> has_disc disc2 (replace_f pts)\"\n  shows \"\\<not> has_disc disc2 (replace_primitive_matchexpr (disc,sel) replace_f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2\n            (replace_primitive_matchexpr (disc, sel) replace_f m)", "apply(simp add: replace_primitive_matchexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2\n            (case primitive_extractor (disc, sel) m of\n             (as, rst) \\<Rightarrow>\n               if as = [] then m\n               else MatchAnd (andfold_MatchExp (map replace_f as)) rst)", "apply(case_tac \"primitive_extractor (disc,sel) m\", rename_tac spts rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       \\<not> has_disc disc2\n               (case primitive_extractor (disc, sel) m of\n                (as, rst) \\<Rightarrow>\n                  if as = [] then m\n                  else MatchAnd (andfold_MatchExp (map replace_f as)) rst)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       primitive_extractor (disc, sel) m = (spts, rst) \\<Longrightarrow>\n       (spts = [] \\<longrightarrow> \\<not> has_disc disc2 m) \\<and>\n       (spts \\<noteq> [] \\<longrightarrow>\n        \\<not> has_disc disc2 (andfold_MatchExp (map replace_f spts)) \\<and>\n        \\<not> has_disc disc2 rst)", "apply(frule primitive_extractor_correct(4)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc2 m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map replace_f spts)) \\<and>\n                          \\<not> has_disc disc2 rst)", "apply(case_tac \"\\<not> has_disc disc m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        \\<not> has_disc disc m\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc2 m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map replace_f spts)) \\<and>\n                          \\<not> has_disc disc2 rst)\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        \\<not> \\<not> has_disc disc m\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc2 m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map replace_f spts)) \\<and>\n                          \\<not> has_disc disc2 rst)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primitive_extractor (disc, sel) m = (spts_, rst_);\n     \\<forall>disc2.\n        \\<not> has_disc disc2 m \\<longrightarrow>\n        \\<not> has_disc disc2 rst_;\n     \\<not> has_disc disc m\\<rbrakk>\n    \\<Longrightarrow> (spts_ = [] \\<longrightarrow>\n                       \\<not> has_disc disc2 m) \\<and>\n                      (spts_ \\<noteq> [] \\<longrightarrow>\n                       \\<not> has_disc disc2\n                               (andfold_MatchExp\n                                 (map replace_f spts_)) \\<and>\n                       \\<not> has_disc disc2 rst_)", "apply(frule primitive_extractor_correct(7)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primitive_extractor (disc, sel) m = (spts_, rst_);\n     \\<forall>disc2.\n        \\<not> has_disc disc2 m \\<longrightarrow>\n        \\<not> has_disc disc2 rst_;\n     \\<not> has_disc disc m;\n     (\\<not> has_disc disc m) = (spts_ = [] \\<and> rst_ = m)\\<rbrakk>\n    \\<Longrightarrow> (spts_ = [] \\<longrightarrow>\n                       \\<not> has_disc disc2 m) \\<and>\n                      (spts_ \\<noteq> [] \\<longrightarrow>\n                       \\<not> has_disc disc2\n                               (andfold_MatchExp\n                                 (map replace_f spts_)) \\<and>\n                       \\<not> has_disc disc2 rst_)", "using nodisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>primitive_extractor (disc, sel) m = (spts_, rst_);\n     \\<forall>disc2.\n        \\<not> has_disc disc2 m \\<longrightarrow>\n        \\<not> has_disc disc2 rst_;\n     \\<not> has_disc disc m;\n     (\\<not> has_disc disc m) = (spts_ = [] \\<and> rst_ = m)\\<rbrakk>\n    \\<Longrightarrow> (spts_ = [] \\<longrightarrow>\n                       \\<not> has_disc disc2 m) \\<and>\n                      (spts_ \\<noteq> [] \\<longrightarrow>\n                       \\<not> has_disc disc2\n                               (andfold_MatchExp\n                                 (map replace_f spts_)) \\<and>\n                       \\<not> has_disc disc2 rst_)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        \\<not> \\<not> has_disc disc m\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc2 m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map replace_f spts)) \\<and>\n                          \\<not> has_disc disc2 rst)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m\\<rbrakk>\n       \\<Longrightarrow> (spts = [] \\<longrightarrow>\n                          \\<not> has_disc disc2 m) \\<and>\n                         (spts \\<noteq> [] \\<longrightarrow>\n                          \\<not> has_disc disc2\n                                  (andfold_MatchExp\n                                    (map replace_f spts)) \\<and>\n                          \\<not> has_disc disc2 rst)", "apply(intro conjI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp (map replace_f spts))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "using nodisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 m\n\ngoal (3 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp (map replace_f spts))\n 3. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp (map replace_f spts))\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "apply(rule andfold_MatchExp_not_discI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (map replace_f spts).\n                            \\<not> has_disc disc2 m\n 2. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "apply(simp add: replace_f; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "using nodisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 m\n\ngoal (1 subgoal):\n 1. \\<And>spts rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (spts, rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        has_disc disc m; spts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 rst", "by blast"], ["", "lemma normalize_replace_primitive_matchexpr_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and replace_f:\n        \"\\<And>a m'. m' \\<in> set (normalize_match (replace_f a)) \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'\"\n      and nprim: \"normalized_n_primitive (disc2, sel2) f m\"\n      and m': \"m' \\<in> set (normalize_match (replace_primitive_matchexpr (disc,sel) replace_f m))\"\n    shows \"normalized_n_primitive (disc2, sel2) f m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) f m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) f m'", "have x: \"x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as))) \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f x\" for x as"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (normalize_match\n                  (andfold_MatchExp (map replace_f as))) \\<Longrightarrow>\n    normalized_n_primitive (disc2, sel2) f x", "apply(rule normalize_andfold_MatchExp_normalized_n_primitive )"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set (normalize_match\n                  (andfold_MatchExp (map replace_f as))) \\<Longrightarrow>\n    \\<forall>m\\<in>set ?ms.\n       \\<forall>s'\\<in>set (normalize_match m).\n          normalized_n_primitive (disc2, sel2) f s'\n 2. x \\<in> set (normalize_match\n                  (andfold_MatchExp (map replace_f as))) \\<Longrightarrow>\n    x \\<in> set (normalize_match (andfold_MatchExp ?ms))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (normalize_match\n                  (andfold_MatchExp (map replace_f as))) \\<Longrightarrow>\n    \\<forall>m\\<in>set as.\n       \\<forall>x\\<in>set (normalize_match (replace_f m)).\n          normalized_n_primitive (disc2, sel2) f x", "using replace_f"], ["proof (prove)\nusing this:\n  ?m' \\<in> set (normalize_match (replace_f ?a)) \\<Longrightarrow>\n  normalized_n_primitive (disc2, sel2) f ?m'\n\ngoal (1 subgoal):\n 1. x \\<in> set (normalize_match\n                  (andfold_MatchExp (map replace_f as))) \\<Longrightarrow>\n    \\<forall>m\\<in>set as.\n       \\<forall>x\\<in>set (normalize_match (replace_f m)).\n          normalized_n_primitive (disc2, sel2) f x", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> set (normalize_match\n                 (andfold_MatchExp (map replace_f ?as))) \\<Longrightarrow>\n  normalized_n_primitive (disc2, sel2) f ?x\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) f m'", "from m'"], ["proof (chain)\npicking this:\n  m' \\<in> set (normalize_match\n                 (replace_primitive_matchexpr (disc, sel) replace_f m))", "show ?thesis"], ["proof (prove)\nusing this:\n  m' \\<in> set (normalize_match\n                 (replace_primitive_matchexpr (disc, sel) replace_f m))\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) f m'", "apply(simp add: replace_primitive_matchexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (case primitive_extractor (disc, sel) m of\n                    (as, rst) \\<Rightarrow>\n                      if as = [] then m\n                      else MatchAnd (andfold_MatchExp (map replace_f as))\n                            rst)) \\<Longrightarrow>\n    normalized_n_primitive (disc2, sel2) f m'", "apply(case_tac \"primitive_extractor (disc, sel) m\", rename_tac as rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (case primitive_extractor (disc, sel) m of\n                                (as, rst) \\<Rightarrow>\n                                  if as = [] then m\n                                  else MatchAnd\n  (andfold_MatchExp (map replace_f as)) rst));\n        primitive_extractor (disc, sel) m = (as, rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = ([], rst); as = [];\n        m' \\<in> set (normalize_match m)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'\n 2. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "using normalize_match_preserves_normalized_n_primitive nprim"], ["proof (prove)\nusing this:\n  normalized_n_primitive ?disc_sel ?f ?rst \\<Longrightarrow>\n  \\<forall>m\\<in>set (normalize_match ?rst).\n     normalized_n_primitive ?disc_sel ?f m\n  normalized_n_primitive (disc2, sel2) f m\n\ngoal (2 subgoals):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = ([], rst); as = [];\n        m' \\<in> set (normalize_match m)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'\n 2. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "apply(frule_tac P=f in primitive_extractor_correct(5)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst);\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f\n                          (MatchAnd x xa)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f x \\<and>\n                         normalized_n_primitive (disc2, sel2) f xa", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f x\n 2. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f xa", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f xa\n 2. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f x", "using normalize_match_preserves_normalized_n_primitive nprim"], ["proof (prove)\nusing this:\n  normalized_n_primitive ?disc_sel ?f ?rst \\<Longrightarrow>\n  \\<forall>m\\<in>set (normalize_match ?rst).\n     normalized_n_primitive ?disc_sel ?f m\n  normalized_n_primitive (disc2, sel2) f m\n\ngoal (2 subgoals):\n 1. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f xa\n 2. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xa.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) f m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) f rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        xa \\<in> set (normalize_match rst); m' = MatchAnd x xa\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f x", "by(simp add: x)"], ["proof (state)\nthis:\n  normalized_n_primitive (disc2, sel2) f m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_replace_primitive_matchexpr_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" \n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and nodisc: \"\\<not> has_disc disc2 m\"\n      and replace_f: \"\\<And>a. \\<not> has_disc disc2 (replace_f a)\"\n     shows \"m'\\<in> set (normalize_match (replace_primitive_matchexpr (disc,sel) replace_f m))\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr (disc, sel) replace_f\n                     m)) \\<Longrightarrow>\n    \\<not> has_disc disc2 m'", "apply(simp add: replace_primitive_matchexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (case primitive_extractor (disc, sel) m of\n                    (as, rst) \\<Rightarrow>\n                      if as = [] then m\n                      else MatchAnd (andfold_MatchExp (map replace_f as))\n                            rst)) \\<Longrightarrow>\n    \\<not> has_disc disc2 m'", "apply(case_tac \"primitive_extractor (disc, sel) m\", rename_tac as rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (case primitive_extractor (disc, sel) m of\n                                (as, rst) \\<Rightarrow>\n                                  if as = [] then m\n                                  else MatchAnd\n  (andfold_MatchExp (map replace_f as)) rst));\n        primitive_extractor (disc, sel) m = (as, rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = ([], rst); as = [];\n        m' \\<in> set (normalize_match m)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'\n 2. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "using nodisc normalize_match_preserves_nodisc"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 m\n  \\<lbrakk>\\<not> has_disc ?disc ?m;\n   ?m' \\<in> set (normalize_match ?m)\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc ?disc ?m'\n\ngoal (2 subgoals):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = ([], rst); as = [];\n        m' \\<in> set (normalize_match m)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'\n 2. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "apply(frule primitive_extractor_correct(4)[OF n wf_disc_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst);\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "apply(elim bexE, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "apply(erule Set.imageE, rename_tac xright)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "(*m' = MatchAnd x xright*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 x \\<and>\n                         \\<not> has_disc disc2 xright", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 x\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 xright", "apply(rule normalize_match_preserves_nodisc, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2\n                                 (andfold_MatchExp (map replace_f as))\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 xright", "apply(rule andfold_MatchExp_not_discI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set as.\n                            \\<not> has_disc disc2 (replace_f m)\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 xright", "using replace_f"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 (replace_f ?a)\n\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set as.\n                            \\<not> has_disc disc2 (replace_f m)\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 xright", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 xright", "apply(rule normalize_match_preserves_nodisc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 (?m85 as rst x xright)\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> xright\n                         \\<in> set (normalize_match (?m85 as rst x xright))", "apply(insert nodisc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright; xright \\<in> set (normalize_match rst);\n        \\<not> has_disc disc2 m\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 (?m85 as rst x xright)\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright; xright \\<in> set (normalize_match rst);\n        \\<not> has_disc disc2 m\\<rbrakk>\n       \\<Longrightarrow> xright\n                         \\<in> set (normalize_match (?m85 as rst x xright))", "by(simp_all)"], ["", "lemma normalize_replace_primitive_matchexpr_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" \n      and wf_disc_sel: \"wf_disc_sel (disc, sel) C\"\n      and nodisc: \"\\<not> has_disc_negated disc2 neg m\"\n      and replace_f: \"\\<And>a. \\<not> has_disc_negated disc2 neg (replace_f a)\"\n     shows \"m'\\<in> set (normalize_match (replace_primitive_matchexpr (disc,sel) replace_f m))\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr (disc, sel) replace_f\n                     m)) \\<Longrightarrow>\n    \\<not> has_disc_negated disc2 neg m'", "apply(simp add: replace_primitive_matchexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (case primitive_extractor (disc, sel) m of\n                    (as, rst) \\<Rightarrow>\n                      if as = [] then m\n                      else MatchAnd (andfold_MatchExp (map replace_f as))\n                            rst)) \\<Longrightarrow>\n    \\<not> has_disc_negated disc2 neg m'", "apply(case_tac \"primitive_extractor (disc, sel) m\", rename_tac as rst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (case primitive_extractor (disc, sel) m of\n                                (as, rst) \\<Rightarrow>\n                                  if as = [] then m\n                                  else MatchAnd\n  (andfold_MatchExp (map replace_f as)) rst));\n        primitive_extractor (disc, sel) m = (as, rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = ([], rst); as = [];\n        m' \\<in> set (normalize_match m)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'\n 2. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "using nodisc not_has_disc_normalize_match"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc2 neg m\n  \\<lbrakk>\\<not> has_disc_negated ?disc ?neg ?m;\n   ?m' \\<in> set (normalize_match ?m)\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc_negated ?disc ?neg ?m'\n\ngoal (2 subgoals):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = ([], rst); as = [];\n        m' \\<in> set (normalize_match m)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'\n 2. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "apply(frule primitive_extractor_correct(6)[OF n wf_disc_sel, where neg=neg])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<exists>x\\<in>set (normalize_match\n                             (andfold_MatchExp (map replace_f as))).\n           m' \\<in> MatchAnd x ` set (normalize_match rst);\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "apply(elim bexE, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' \\<in> MatchAnd x ` set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "apply(erule Set.imageE, rename_tac xright)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "(*m' = MatchAnd x xright*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg x \\<and>\n                         \\<not> has_disc_negated disc2 neg xright", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg x\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg xright", "apply(rule not_has_disc_normalize_match, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg\n                                 (andfold_MatchExp (map replace_f as))\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg xright", "apply(rule andfold_MatchExp_not_disc_negatedI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set as.\n                            \\<not> has_disc_negated disc2 neg (replace_f m)\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg xright", "using replace_f"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc2 neg (replace_f ?a)\n\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set as.\n                            \\<not> has_disc_negated disc2 neg (replace_f m)\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg xright", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg xright", "apply(rule not_has_disc_normalize_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg\n                                 (?m86 as rst x xright)\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright;\n        xright \\<in> set (normalize_match rst)\\<rbrakk>\n       \\<Longrightarrow> xright\n                         \\<in> set (normalize_match (?m86 as rst x xright))", "apply(insert nodisc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright; xright \\<in> set (normalize_match rst);\n        \\<not> has_disc_negated disc2 neg m\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg\n                                 (?m86 as rst x xright)\n 2. \\<And>as rst x xright.\n       \\<lbrakk>primitive_extractor (disc, sel) m = (as, rst);\n        as \\<noteq> [];\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rst;\n        x \\<in> set (normalize_match (andfold_MatchExp (map replace_f as)));\n        m' = MatchAnd x xright; xright \\<in> set (normalize_match rst);\n        \\<not> has_disc_negated disc2 neg m\\<rbrakk>\n       \\<Longrightarrow> xright\n                         \\<in> set (normalize_match (?m86 as rst x xright))", "by(simp_all)"], ["", "corollary normalize_replace_primitive_matchexpr:\n    assumes n: \"normalized_nnf_match m\"\n    and replace_f:\n      \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> \n      matches \\<gamma> (replace_primitive_matchexpr disc_sel replace_f m) a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n    shows\n        \"match_list \\<gamma> (normalize_match (replace_primitive_matchexpr disc_sel replace_f m)) a p \\<longleftrightarrow>\n          matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list \\<gamma>\n     (normalize_match (replace_primitive_matchexpr disc_sel replace_f m)) a\n     p =\n    matches \\<gamma> m a p", "by(simp add: matches_to_match_list_normalize[symmetric] replace_f n)"], ["", "fun rewrite_MultiportPorts_one\n    :: \"ipt_l4_ports negation_type\\<Rightarrow> 'i::len common_primitive match_expr\" where\n    \"rewrite_MultiportPorts_one (Pos pts) = \n        MatchOr (Match (Src_Ports pts)) (Match (Dst_Ports pts))\" |\n    \"rewrite_MultiportPorts_one (Neg pts) =\n        MatchAnd (MatchNot (Match (Src_Ports pts))) (MatchNot (Match (Dst_Ports pts)))\""], ["", "lemma rewrite_MultiportPorts_one:\n  assumes generic: \"primitive_matcher_generic \\<beta>\" and n: \"normalized_nnf_match m\"\n  shows\n    \"matches (\\<beta>, \\<alpha>) (replace_primitive_matchexpr (is_MultiportPorts, multiportports_sel) rewrite_MultiportPorts_one m) a p \\<longleftrightarrow>\n      matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>)\n     (replace_primitive_matchexpr (is_MultiportPorts, multiportports_sel)\n       rewrite_MultiportPorts_one m)\n     a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(rule replace_primitive_matchexpr[OF n wf_disc_sel_common_primitive(11)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pt.\n       matches (\\<beta>, \\<alpha>) (rewrite_MultiportPorts_one pt) a p =\n       matches (\\<beta>, \\<alpha>)\n        (negation_type_to_match_expr_f MultiportPorts pt) a p", "apply(rule allI, rename_tac pt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pt.\n       matches (\\<beta>, \\<alpha>) (rewrite_MultiportPorts_one pt) a p =\n       matches (\\<beta>, \\<alpha>)\n        (negation_type_to_match_expr_f MultiportPorts pt) a p", "apply(case_tac pt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pt x1.\n       pt = Pos x1 \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (rewrite_MultiportPorts_one pt) a p =\n       matches (\\<beta>, \\<alpha>)\n        (negation_type_to_match_expr_f MultiportPorts pt) a p\n 2. \\<And>pt x2.\n       pt = Neg x2 \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (rewrite_MultiportPorts_one pt) a p =\n       matches (\\<beta>, \\<alpha>)\n        (negation_type_to_match_expr_f MultiportPorts pt) a p", "apply(simp add: primitive_matcher_generic.MultiportPorts_single_rewrite_MatchOr[OF generic]; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pt x2.\n       pt = Neg x2 \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>) (rewrite_MultiportPorts_one pt) a p =\n       matches (\\<beta>, \\<alpha>)\n        (negation_type_to_match_expr_f MultiportPorts pt) a p", "apply(simp add: primitive_matcher_generic.MultiportPorts_single_not_rewrite_MatchAnd[OF generic]; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<forall>a. \\<not> disc (Src_Ports a) \\<Longrightarrow> \\<forall>a. \\<not> disc (Dst_Ports a) \\<Longrightarrow>\n          normalized_n_primitive (disc, sel) f m \\<Longrightarrow>\n         \\<forall>m' \\<in> set (normalize_match (rewrite_MultiportPorts_one a)).\n            normalized_n_primitive (disc, sel) f m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a. \\<not> disc (Src_Ports a);\n     \\<forall>a. \\<not> disc (Dst_Ports a);\n     normalized_n_primitive (disc, sel) f m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m'\\<in>set\n (normalize_match (rewrite_MultiportPorts_one a)).\n                         normalized_n_primitive (disc, sel) f m'", "apply(cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<forall>a. \\<not> disc (Src_Ports a);\n        \\<forall>a. \\<not> disc (Dst_Ports a);\n        normalized_n_primitive (disc, sel) f m; a = Pos x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_match (rewrite_MultiportPorts_one a)).\n                            normalized_n_primitive (disc, sel) f m'\n 2. \\<And>x2.\n       \\<lbrakk>\\<forall>a. \\<not> disc (Src_Ports a);\n        \\<forall>a. \\<not> disc (Dst_Ports a);\n        normalized_n_primitive (disc, sel) f m; a = Neg x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m'\\<in>set\n    (normalize_match (rewrite_MultiportPorts_one a)).\n                            normalized_n_primitive (disc, sel) f m'", "by(simp_all add: MatchOr_def)"], ["", "lemma rewrite_MultiportPorts_one_nodisc: \n    \"\\<forall>a. \\<not> disc (Src_Ports a) \\<Longrightarrow> \\<forall>a. \\<not> disc (Dst_Ports a) \\<Longrightarrow>\n          \\<not> has_disc disc (rewrite_MultiportPorts_one a)\"\n    \"\\<forall>a. \\<not> disc (Src_Ports a) \\<Longrightarrow> \\<forall>a. \\<not> disc (Dst_Ports a) \\<Longrightarrow>\n          \\<not> has_disc_negated disc neg (rewrite_MultiportPorts_one a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>a. \\<not> disc (Src_Ports a);\n      \\<forall>a. \\<not> disc (Dst_Ports a)\\<rbrakk>\n     \\<Longrightarrow> \\<not> has_disc disc\n                               (rewrite_MultiportPorts_one a)) &&&\n    (\\<lbrakk>\\<forall>a. \\<not> disc (Src_Ports a);\n      \\<forall>a. \\<not> disc (Dst_Ports a)\\<rbrakk>\n     \\<Longrightarrow> \\<not> has_disc_negated disc neg\n                               (rewrite_MultiportPorts_one a))", "by(cases a, simp_all add: MatchOr_def)+"], ["", "definition rewrite_MultiportPorts\n    :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr list\" where\n    \"rewrite_MultiportPorts m \\<equiv> normalize_match \n        (replace_primitive_matchexpr (is_MultiportPorts, multiportports_sel) rewrite_MultiportPorts_one m)\""], ["", "lemma rewrite_MultiportPorts:\n    assumes generic: \"primitive_matcher_generic \\<beta>\"\n    and n: \"normalized_nnf_match m\"\n    shows\n        \"match_list (\\<beta>, \\<alpha>) (rewrite_MultiportPorts m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>) (rewrite_MultiportPorts m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "unfolding rewrite_MultiportPorts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list (\\<beta>, \\<alpha>)\n     (normalize_match\n       (replace_primitive_matchexpr (is_MultiportPorts, multiportports_sel)\n         rewrite_MultiportPorts_one m))\n     a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(intro normalize_replace_primitive_matchexpr[OF n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       normalized_nnf_match m \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>)\n        (replace_primitive_matchexpr (is_MultiportPorts, multiportports_sel)\n          rewrite_MultiportPorts_one m)\n        a p =\n       matches (\\<beta>, \\<alpha>) m a p", "by(simp add: rewrite_MultiportPorts_one[OF generic])"], ["", "lemma rewrite_MultiportPorts_normalized_nnf_match:\n      \"m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow> normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow>\n    normalized_nnf_match m'", "apply(simp add: rewrite_MultiportPorts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    normalized_nnf_match m'", "using normalized_nnf_match_normalize_match"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<in>set (normalize_match ?m). normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    normalized_nnf_match m'", "by blast"], ["", "text\\<open>It does nothing of there is not even the primitive in it\\<close>"], ["", "lemma rewrite_MultiportPorts_unchanged_if_not_has_disc:\n  assumes n: \"normalized_nnf_match m\"\n  and noDisc: \"\\<not> has_disc is_MultiportPorts m\"\n  shows \"rewrite_MultiportPorts m = [m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rewrite_MultiportPorts m = [m]", "apply(simp add: rewrite_MultiportPorts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_match\n     (replace_primitive_matchexpr (is_MultiportPorts, multiportports_sel)\n       rewrite_MultiportPorts_one m) =\n    [m]", "apply(subst replace_primitive_matchexpr_unchanged_if_not_has_disc[OF n\n            wf_disc_sel_common_primitive(11) noDisc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_match m = [m]", "using n"], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n\ngoal (1 subgoal):\n 1. normalize_match m = [m]", "by(fact normalize_match_already_normalized)"], ["", "lemma rewrite_MultiportPorts_preserves_normalized_n_primitive:\n    assumes n: \"normalized_nnf_match m\"\n      and disc2_noSrcPorts: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noDstPorts: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n    shows \"m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow>\n         normalized_n_primitive (disc2, sel2) f  m \\<Longrightarrow>\n          normalized_n_primitive (disc2, sel2) f m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (rewrite_MultiportPorts m);\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "unfolding rewrite_MultiportPorts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<in> set (normalize_match\n                            (replace_primitive_matchexpr\n                              (is_MultiportPorts, multiportports_sel)\n                              rewrite_MultiportPorts_one m));\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'", "apply(rule normalize_replace_primitive_matchexpr_preserves_normalized_n_primitive[OF\n                  n wf_disc_sel_common_primitive(11)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a m'a.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        m'a \\<in> set (normalize_match (?replace_f a))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'a\n 2. \\<lbrakk>m' \\<in> set (normalize_match\n                            (replace_primitive_matchexpr\n                              (is_MultiportPorts, multiportports_sel)\n                              rewrite_MultiportPorts_one m));\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m\n 3. \\<lbrakk>m' \\<in> set (normalize_match\n                            (replace_primitive_matchexpr\n                              (is_MultiportPorts, multiportports_sel)\n                              rewrite_MultiportPorts_one m));\n     normalized_n_primitive (disc2, sel2) f m\\<rbrakk>\n    \\<Longrightarrow> m' \\<in> set (normalize_match\n                                     (replace_primitive_matchexpr\n (is_MultiportPorts, multiportports_sel) ?replace_f m))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m'a.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        m'a\n        \\<in> set (normalize_match (rewrite_MultiportPorts_one a))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f m'a", "apply(rename_tac a a')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        a' \\<in> set (normalize_match\n                       (rewrite_MultiportPorts_one a))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a'", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x1.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        a' \\<in> set (normalize_match (rewrite_MultiportPorts_one a));\n        a = Pos x1\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a'\n 2. \\<And>a a' x2.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        a' \\<in> set (normalize_match (rewrite_MultiportPorts_one a));\n        a = Neg x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a'", "apply(simp_all add: MatchOr_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x1.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        a' = Match (Src_Ports x1) \\<or> a' = Match (Dst_Ports x1);\n        a = Pos x1\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a'\n 2. \\<And>a a' x2.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        a' =\n        MatchAnd (MatchNot (Match (Src_Ports x2)))\n         (MatchNot (Match (Dst_Ports x2)));\n        a = Neg x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> disc2 (Src_Ports x2) \\<and>\n                         (\\<not> disc2 (Src_Ports x2) \\<longrightarrow>\n                          \\<not> disc2 (Dst_Ports x2))", "using disc2_noSrcPorts disc2_noDstPorts"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (Src_Ports a)\n  \\<forall>a. \\<not> disc2 (Dst_Ports a)\n\ngoal (2 subgoals):\n 1. \\<And>a a' x1.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        a' = Match (Src_Ports x1) \\<or> a' = Match (Dst_Ports x1);\n        a = Pos x1\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) f a'\n 2. \\<And>a a' x2.\n       \\<lbrakk>m' \\<in> set (normalize_match\n                               (replace_primitive_matchexpr\n                                 (is_MultiportPorts, multiportports_sel)\n                                 rewrite_MultiportPorts_one m));\n        normalized_n_primitive (disc2, sel2) f m;\n        a' =\n        MatchAnd (MatchNot (Match (Src_Ports x2)))\n         (MatchNot (Match (Dst_Ports x2)));\n        a = Neg x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> disc2 (Src_Ports x2) \\<and>\n                         (\\<not> disc2 (Src_Ports x2) \\<longrightarrow>\n                          \\<not> disc2 (Dst_Ports x2))", "by fastforce+"], ["", "lemma rewrite_MultiportPorts_preserves_normalized_not_has_disc:\n    assumes n: \"normalized_nnf_match m\" \n      and nodisc: \"\\<not> has_disc disc2 m\"\n      and disc2_noSrcPorts: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noDstPorts: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n     shows \"m'\\<in> set (rewrite_MultiportPorts m)\n      \\<Longrightarrow> \\<not> has_disc disc2 m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow>\n    \\<not> has_disc disc2 m'", "apply(simp add: rewrite_MultiportPorts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    \\<not> has_disc disc2 m'", "apply(rule normalize_replace_primitive_matchexpr_preserves_normalized_not_has_disc[OF n wf_disc_sel_common_primitive(11) nodisc])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       m' \\<in> set (normalize_match\n                      (replace_primitive_matchexpr\n                        (is_MultiportPorts, multiportports_sel)\n                        rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n       \\<not> has_disc disc2 (?replace_f a)\n 2. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel) ?replace_f m))", "by(simp_all add: rewrite_MultiportPorts_one_nodisc disc2_noSrcPorts disc2_noDstPorts)"], ["", "lemma rewrite_MultiportPorts_preserves_normalized_not_has_disc_negated:\n    assumes n: \"normalized_nnf_match m\" \n      and nodisc: \"\\<not> has_disc_negated disc2 neg m\"\n      and disc2_noSrcPorts: \"\\<forall>a. \\<not> disc2 (Src_Ports a)\"\n      and disc2_noDstPorts: \"\\<forall>a. \\<not> disc2 (Dst_Ports a)\"\n     shows \"m'\\<in> set (rewrite_MultiportPorts m)\n      \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow>\n    \\<not> has_disc_negated disc2 neg m'", "apply(simp add: rewrite_MultiportPorts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    \\<not> has_disc_negated disc2 neg m'", "apply(rule normalize_replace_primitive_matchexpr_preserves_normalized_not_has_disc_negated[OF n wf_disc_sel_common_primitive(11) nodisc])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       m' \\<in> set (normalize_match\n                      (replace_primitive_matchexpr\n                        (is_MultiportPorts, multiportports_sel)\n                        rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n       \\<not> has_disc_negated disc2 neg (?replace_f a)\n 2. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel) ?replace_f m))", "by(simp_all add: rewrite_MultiportPorts_one_nodisc disc2_noSrcPorts disc2_noDstPorts)"], ["", "lemma rewrite_MultiportPorts_removes_MultiportsPorts:\n    assumes n: \"normalized_nnf_match m\"\n    shows \"m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow> \\<not> has_disc is_MultiportPorts m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (rewrite_MultiportPorts m) \\<Longrightarrow>\n    \\<not> has_disc is_MultiportPorts m'", "apply(simp add: rewrite_MultiportPorts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    \\<not> has_disc is_MultiportPorts m'", "apply(rule normalize_match_preserves_nodisc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    \\<not> has_disc is_MultiportPorts ?m\n 2. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    m' \\<in> set (normalize_match ?m)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    \\<not> has_disc is_MultiportPorts\n            (replace_primitive_matchexpr\n              (is_MultiportPorts, multiportports_sel)\n              rewrite_MultiportPorts_one m)", "apply(rule replace_primitive_matchexpr_replaces_disc[OF n wf_disc_sel_common_primitive(11)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> set (normalize_match\n                   (replace_primitive_matchexpr\n                     (is_MultiportPorts, multiportports_sel)\n                     rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n    \\<forall>a.\n       \\<not> has_disc is_MultiportPorts (rewrite_MultiportPorts_one a)", "apply(intro allI, rename_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       m' \\<in> set (normalize_match\n                      (replace_primitive_matchexpr\n                        (is_MultiportPorts, multiportports_sel)\n                        rewrite_MultiportPorts_one m)) \\<Longrightarrow>\n       \\<not> has_disc is_MultiportPorts (rewrite_MultiportPorts_one a)", "by(case_tac a, simp_all add: MatchOr_def)"], ["", "end"]]}