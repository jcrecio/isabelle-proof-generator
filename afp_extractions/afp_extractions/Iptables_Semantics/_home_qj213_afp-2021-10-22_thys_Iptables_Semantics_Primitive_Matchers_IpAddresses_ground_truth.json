{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/IpAddresses.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma \"ipset_from_cidr (ipv4addr_of_dotdecimal (0, 0, 0, 0)) 33 = {0}\"", "lemma all_but_those_ips:\n    \"ipcidr_union_set (set (all_but_those_ips cidrips)) =\n      UNIV - (\\<Union> (ip,n) \\<in> set cidrips. ipset_from_cidr ip n)\"", "lemma ipt_iprange_to_set_nonempty: \"ipt_iprange_to_set ip = {} \\<longleftrightarrow> \n    (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip1 > ip2)\"", "lemma element_ipt_iprange_to_set[code_unfold]: \"(addr::'i::len word) \\<in> ipt_iprange_to_set X = (\n    case X of (IpAddrNetmask pre len) \\<Rightarrow>\n                  (pre AND ((mask len) << (len_of (TYPE('i)) - len))) \\<le> addr \\<and>\n                  addr \\<le> pre OR (mask (len_of (TYPE('i)) - len))\n    | IpAddr ip \\<Rightarrow> (addr = ip)\n    | IpAddrRange ip1 ip2 \\<Rightarrow> ip1 \\<le> addr \\<and> ip2 \\<ge> addr)\"", "lemma ipt_iprange_to_set_uncurry_IpAddrNetmask:\n    \"ipt_iprange_to_set (uncurry IpAddrNetmask a) = uncurry ipset_from_cidr a\"", "lemma ipt_iprange_to_interval: \"ipt_iprange_to_interval ip = (s,e) \\<Longrightarrow> {s .. e} = ipt_iprange_to_set ip\"", "lemma \"wordinterval_to_set (l2wi_intersect (map ipt_iprange_to_interval ips)) =\n            (\\<Inter> ip \\<in> set ips. ipt_iprange_to_set ip)\"", "lemma \"wordinterval_to_set (l2wi (map ipt_iprange_to_interval ips)) = (\\<Union> ip \\<in> set ips. ipt_iprange_to_set ip)\"", "lemma ipt_iprange_negation_type_to_br_intersect: \"wordinterval_to_set (ipt_iprange_negation_type_to_br_intersect l) =\n      (\\<Inter> ip \\<in> set (getPos l). ipt_iprange_to_set ip) - (\\<Union> ip \\<in> set (getNeg l). ipt_iprange_to_set ip)\"", "lemma wi_2_cidr_ipt_iprange_list:\n    \"(\\<Union> ip \\<in> set (wi_2_cidr_ipt_iprange_list r). ipt_iprange_to_set ip) = wordinterval_to_set r\"", "lemma ipt_iprange_compress: \"(\\<Union> ip \\<in> set (ipt_iprange_compress l). ipt_iprange_to_set ip) =\n      (\\<Inter> ip \\<in> set (getPos l). ipt_iprange_to_set ip) - (\\<Union> ip \\<in> set (getNeg l). ipt_iprange_to_set ip)\"", "lemma wi_2_cidr_ipt_iprange_list_normalized_IpAddrNetmask: \n    \"\\<forall>a'\\<in>set (wi_2_cidr_ipt_iprange_list as). normalized_cidr_ip a'\"", "lemma ipt_iprange_compress_normalized_IpAddrNetmask:\n    \"\\<forall>a'\\<in>set (ipt_iprange_compress as). normalized_cidr_ip a'\"", "lemma ipt_ipvange_to_cidr: \"ipcidr_union_set (set (ipt_iprange_to_cidr ips)) = (ipt_iprange_to_set ips)\"", "lemma interval_to_wi_to_ipt_ipv4range: \"ipt_iprange_to_set (interval_to_wi_to_ipt_iprange s e) = {s..e}\"", "lemma wi_to_ipt_ipv4range: \"\\<Union>(set (map ipt_iprange_to_set (wi_to_ipt_iprange wi))) = wordinterval_to_set wi\""], "translations": [["", "lemma \"ipset_from_cidr (ipv4addr_of_dotdecimal (0, 0, 0, 0)) 33 = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr (ipv4addr_of_dotdecimal (0, 0, 0, 0)) 33 = {0}", "by(simp add: ipv4addr_of_dotdecimal.simps ipv4addr_of_nat_def ipset_from_cidr_large_pfxlen)"], ["", "(*helper we use for spoofing protection specification*)"], ["", "definition all_but_those_ips :: \"('i::len word \\<times> nat) list \\<Rightarrow> ('i word \\<times> nat) list\" where\n    \"all_but_those_ips cidrips = cidr_split (wordinterval_invert (l2wi (map ipcidr_to_interval cidrips)))\""], ["", "lemma all_but_those_ips:\n    \"ipcidr_union_set (set (all_but_those_ips cidrips)) =\n      UNIV - (\\<Union> (ip,n) \\<in> set cidrips. ipset_from_cidr ip n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (all_but_those_ips cidrips)) =\n    UNIV - (\\<Union>(ip, n)\\<in>set cidrips. ipset_from_cidr ip n)", "apply(simp add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (all_but_those_ips cidrips)) =\n    UNIV -\n    (\\<Union>x\\<in>set cidrips.\n        case x of (ip, n) \\<Rightarrow> ipset_from_cidr ip n)", "unfolding ipcidr_union_set_uncurry all_but_those_ips_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (uncurry ipset_from_cidr `\n      set (cidr_split\n            (wordinterval_invert\n              (l2wi (map ipcidr_to_interval cidrips))))) =\n    UNIV -\n    (\\<Union>x\\<in>set cidrips.\n        case x of (ip, n) \\<Rightarrow> ipset_from_cidr ip n)", "apply(simp add: cidr_split_prefix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV - wordinterval_to_set (l2wi (map ipcidr_to_interval cidrips)) =\n    UNIV -\n    (\\<Union>x\\<in>set cidrips.\n        case x of (ip, n) \\<Rightarrow> ipset_from_cidr ip n)", "apply(simp add: l2wi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV -\n    (\\<Union>a\\<in>set cidrips.\n        case ipcidr_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n    UNIV -\n    (\\<Union>x\\<in>set cidrips.\n        case x of (ip, n) \\<Rightarrow> ipset_from_cidr ip n)", "apply(simp add: ipcidr_to_interval_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV -\n    (\\<Union>x\\<in>set cidrips.\n        {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) =\n    UNIV -\n    (\\<Union>x\\<in>set cidrips.\n        case x of (ip, n) \\<Rightarrow> ipset_from_cidr ip n)", "using ipset_from_cidr_ipcidr_to_interval"], ["proof (prove)\nusing this:\n  ipset_from_cidr ?base ?len =\n  {ipcidr_to_interval_start\n    (?base, ?len)..ipcidr_to_interval_end (?base, ?len)}\n\ngoal (1 subgoal):\n 1. UNIV -\n    (\\<Union>x\\<in>set cidrips.\n        {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) =\n    UNIV -\n    (\\<Union>x\\<in>set cidrips.\n        case x of (ip, n) \\<Rightarrow> ipset_from_cidr ip n)", "by blast"], ["", "section\\<open>IPv4 Addresses\\<close>"], ["", "subsection\\<open>IPv4 Addresses in IPTables Notation (how we parse it)\\<close>"], ["", "context\n    notes [[typedef_overloaded]]\n  begin"], ["", "datatype 'i ipt_iprange =\n                          \\<comment> \\<open>Singleton IP Address\\<close>\n                          IpAddr \"'i::len word\"\n  \n                          \\<comment> \\<open>CIDR notation: addr/xx\\<close>\n                          | IpAddrNetmask \"'i word\" nat\n  \n                          \\<comment> \\<open>-m iprange --src-range a.b.c.d-e.f.g.h\\<close>\n                          | IpAddrRange  \"'i word\" \"'i word\""], ["", "(*the range is inclusive*)"], ["", "end"], ["", "fun ipt_iprange_to_set :: \"'i::len ipt_iprange \\<Rightarrow> 'i word set\" where\n    \"ipt_iprange_to_set (IpAddrNetmask base m) = ipset_from_cidr base m\" |\n    \"ipt_iprange_to_set (IpAddr ip) = { ip }\" |\n    \"ipt_iprange_to_set (IpAddrRange ip1 ip2) = { ip1 .. ip2 }\""], ["", "text\\<open>@{term ipt_iprange_to_set} can only represent an empty set if it is an empty range.\\<close>"], ["", "lemma ipt_iprange_to_set_nonempty: \"ipt_iprange_to_set ip = {} \\<longleftrightarrow> \n    (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip1 > ip2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipt_iprange_to_set ip = {}) =\n    (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip2 < ip1)", "apply(cases ip)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ip = IpAddr x1 \\<Longrightarrow>\n       (ipt_iprange_to_set ip = {}) =\n       (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip2 < ip1)\n 2. \\<And>x21 x22.\n       ip = IpAddrNetmask x21 x22 \\<Longrightarrow>\n       (ipt_iprange_to_set ip = {}) =\n       (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip2 < ip1)\n 3. \\<And>x31 x32.\n       ip = IpAddrRange x31 x32 \\<Longrightarrow>\n       (ipt_iprange_to_set ip = {}) =\n       (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip2 < ip1)", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       ip = IpAddrNetmask x21 x22 \\<Longrightarrow>\n       (ipt_iprange_to_set ip = {}) =\n       (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip2 < ip1)\n 2. \\<And>x31 x32.\n       ip = IpAddrRange x31 x32 \\<Longrightarrow>\n       (ipt_iprange_to_set ip = {}) =\n       (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip2 < ip1)", "apply(simp add: ipset_from_cidr_alt bitmagic_zeroLast_leq_or1Last; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       ip = IpAddrRange x31 x32 \\<Longrightarrow>\n       (ipt_iprange_to_set ip = {}) =\n       (\\<exists>ip1 ip2. ip = IpAddrRange ip1 ip2 \\<and> ip2 < ip1)", "apply(simp add:linorder_not_le; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>maybe this is necessary as code equation?\\<close>"], ["", "lemma element_ipt_iprange_to_set[code_unfold]: \"(addr::'i::len word) \\<in> ipt_iprange_to_set X = (\n    case X of (IpAddrNetmask pre len) \\<Rightarrow>\n                  (pre AND ((mask len) << (len_of (TYPE('i)) - len))) \\<le> addr \\<and>\n                  addr \\<le> pre OR (mask (len_of (TYPE('i)) - len))\n    | IpAddr ip \\<Rightarrow> (addr = ip)\n    | IpAddrRange ip1 ip2 \\<Rightarrow> ip1 \\<le> addr \\<and> ip2 \\<ge> addr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (addr \\<in> ipt_iprange_to_set X) =\n    (case X of IpAddr ip \\<Rightarrow> addr = ip\n     | IpAddrNetmask pre len \\<Rightarrow>\n         pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n         addr \\<le> pre || mask (LENGTH('i) - len)\n     | IpAddrRange ip1 ip2 \\<Rightarrow>\n         ip1 \\<le> addr \\<and> addr \\<le> ip2)", "apply(cases X)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       X = IpAddr x1 \\<Longrightarrow>\n       (addr \\<in> ipt_iprange_to_set X) =\n       (case X of IpAddr ip \\<Rightarrow> addr = ip\n        | IpAddrNetmask pre len \\<Rightarrow>\n            pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n            addr \\<le> pre || mask (LENGTH('i) - len)\n        | IpAddrRange ip1 ip2 \\<Rightarrow>\n            ip1 \\<le> addr \\<and> addr \\<le> ip2)\n 2. \\<And>x21 x22.\n       X = IpAddrNetmask x21 x22 \\<Longrightarrow>\n       (addr \\<in> ipt_iprange_to_set X) =\n       (case X of IpAddr ip \\<Rightarrow> addr = ip\n        | IpAddrNetmask pre len \\<Rightarrow>\n            pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n            addr \\<le> pre || mask (LENGTH('i) - len)\n        | IpAddrRange ip1 ip2 \\<Rightarrow>\n            ip1 \\<le> addr \\<and> addr \\<le> ip2)\n 3. \\<And>x31 x32.\n       X = IpAddrRange x31 x32 \\<Longrightarrow>\n       (addr \\<in> ipt_iprange_to_set X) =\n       (case X of IpAddr ip \\<Rightarrow> addr = ip\n        | IpAddrNetmask pre len \\<Rightarrow>\n            pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n            addr \\<le> pre || mask (LENGTH('i) - len)\n        | IpAddrRange ip1 ip2 \\<Rightarrow>\n            ip1 \\<le> addr \\<and> addr \\<le> ip2)", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       X = IpAddrNetmask x21 x22 \\<Longrightarrow>\n       (addr \\<in> ipt_iprange_to_set X) =\n       (case X of IpAddr ip \\<Rightarrow> addr = ip\n        | IpAddrNetmask pre len \\<Rightarrow>\n            pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n            addr \\<le> pre || mask (LENGTH('i) - len)\n        | IpAddrRange ip1 ip2 \\<Rightarrow>\n            ip1 \\<le> addr \\<and> addr \\<le> ip2)\n 2. \\<And>x31 x32.\n       X = IpAddrRange x31 x32 \\<Longrightarrow>\n       (addr \\<in> ipt_iprange_to_set X) =\n       (case X of IpAddr ip \\<Rightarrow> addr = ip\n        | IpAddrNetmask pre len \\<Rightarrow>\n            pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n            addr \\<le> pre || mask (LENGTH('i) - len)\n        | IpAddrRange ip1 ip2 \\<Rightarrow>\n            ip1 \\<le> addr \\<and> addr \\<le> ip2)", "apply(simp add: ipset_from_cidr_alt; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       X = IpAddrRange x31 x32 \\<Longrightarrow>\n       (addr \\<in> ipt_iprange_to_set X) =\n       (case X of IpAddr ip \\<Rightarrow> addr = ip\n        | IpAddrNetmask pre len \\<Rightarrow>\n            pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n            addr \\<le> pre || mask (LENGTH('i) - len)\n        | IpAddrRange ip1 ip2 \\<Rightarrow>\n            ip1 \\<le> addr \\<and> addr \\<le> ip2)", "apply(simp; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ipt_iprange_to_set_uncurry_IpAddrNetmask:\n    \"ipt_iprange_to_set (uncurry IpAddrNetmask a) = uncurry ipset_from_cidr a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipt_iprange_to_set (uncurry IpAddrNetmask a) = uncurry ipset_from_cidr a", "by(simp split: uncurry_splits)"], ["", "text\\<open>IP address ranges to \\<open>(start, end)\\<close> notation\\<close>"], ["", "fun ipt_iprange_to_interval :: \"'i::len ipt_iprange \\<Rightarrow> ('i word \\<times> 'i word)\" where\n    \"ipt_iprange_to_interval (IpAddr addr) = (addr, addr)\" |\n    \"ipt_iprange_to_interval (IpAddrNetmask pre len) = ipcidr_to_interval (pre, len)\" |\n    \"ipt_iprange_to_interval (IpAddrRange ip1 ip2) = (ip1, ip2)\""], ["", "lemma ipt_iprange_to_interval: \"ipt_iprange_to_interval ip = (s,e) \\<Longrightarrow> {s .. e} = ipt_iprange_to_set ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipt_iprange_to_interval ip = (s, e) \\<Longrightarrow>\n    {s..e} = ipt_iprange_to_set ip", "apply(cases ip)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ipt_iprange_to_interval ip = (s, e); ip = IpAddr x1\\<rbrakk>\n       \\<Longrightarrow> {s..e} = ipt_iprange_to_set ip\n 2. \\<And>x21 x22.\n       \\<lbrakk>ipt_iprange_to_interval ip = (s, e);\n        ip = IpAddrNetmask x21 x22\\<rbrakk>\n       \\<Longrightarrow> {s..e} = ipt_iprange_to_set ip\n 3. \\<And>x31 x32.\n       \\<lbrakk>ipt_iprange_to_interval ip = (s, e);\n        ip = IpAddrRange x31 x32\\<rbrakk>\n       \\<Longrightarrow> {s..e} = ipt_iprange_to_set ip", "apply(auto simp add: ipcidr_to_interval)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>A list of IP address ranges to a @{typ \"'i::len wordinterval\"}.\n        The nice thing is: the usual set operations are defined on this type.\n        We can use the existing function @{const l2wi_intersect} if we want the intersection of the supplied list\\<close>"], ["", "lemma \"wordinterval_to_set (l2wi_intersect (map ipt_iprange_to_interval ips)) =\n            (\\<Inter> ip \\<in> set ips. ipt_iprange_to_set ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi_intersect (map ipt_iprange_to_interval ips)) =\n    \\<Inter> (ipt_iprange_to_set ` set ips)", "apply(simp add: l2wi_intersect)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>a\\<in>set ips.\n        case ipt_iprange_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n    \\<Inter> (ipt_iprange_to_set ` set ips)", "using ipt_iprange_to_interval"], ["proof (prove)\nusing this:\n  ipt_iprange_to_interval ?ip = (?s, ?e) \\<Longrightarrow>\n  {?s..?e} = ipt_iprange_to_set ?ip\n\ngoal (1 subgoal):\n 1. (\\<Inter>a\\<in>set ips.\n        case ipt_iprange_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n    \\<Inter> (ipt_iprange_to_set ` set ips)", "by blast"], ["", "text\\<open>We can use @{const l2wi} if we want the union of the supplied list\\<close>"], ["", "lemma \"wordinterval_to_set (l2wi (map ipt_iprange_to_interval ips)) = (\\<Union> ip \\<in> set ips. ipt_iprange_to_set ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi (map ipt_iprange_to_interval ips)) =\n    \\<Union> (ipt_iprange_to_set ` set ips)", "apply(simp add: l2wi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>set ips.\n        case ipt_iprange_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n    \\<Union> (ipt_iprange_to_set ` set ips)", "using ipt_iprange_to_interval"], ["proof (prove)\nusing this:\n  ipt_iprange_to_interval ?ip = (?s, ?e) \\<Longrightarrow>\n  {?s..?e} = ipt_iprange_to_set ?ip\n\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>set ips.\n        case ipt_iprange_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n    \\<Union> (ipt_iprange_to_set ` set ips)", "by blast"], ["", "text\\<open>A list of (negated) IP address to a @{typ \"'i::len wordinterval\"}.\\<close>"], ["", "definition ipt_iprange_negation_type_to_br_intersect ::\n    \"'i::len ipt_iprange negation_type list \\<Rightarrow> 'i wordinterval\" where\n    \"ipt_iprange_negation_type_to_br_intersect l = l2wi_negation_type_intersect (NegPos_map ipt_iprange_to_interval l)\""], ["", "lemma ipt_iprange_negation_type_to_br_intersect: \"wordinterval_to_set (ipt_iprange_negation_type_to_br_intersect l) =\n      (\\<Inter> ip \\<in> set (getPos l). ipt_iprange_to_set ip) - (\\<Union> ip \\<in> set (getNeg l). ipt_iprange_to_set ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipt_iprange_negation_type_to_br_intersect l) =\n    \\<Inter> (ipt_iprange_to_set ` set (getPos l)) -\n    \\<Union> (ipt_iprange_to_set ` set (getNeg l))", "apply(simp add: ipt_iprange_negation_type_to_br_intersect_def l2wi_negation_type_intersect NegPos_map_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>a\\<in>set (getPos l).\n        case ipt_iprange_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) -\n    (\\<Union>a\\<in>set (getNeg l).\n        case ipt_iprange_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n    \\<Inter> (ipt_iprange_to_set ` set (getPos l)) -\n    \\<Union> (ipt_iprange_to_set ` set (getNeg l))", "using ipt_iprange_to_interval"], ["proof (prove)\nusing this:\n  ipt_iprange_to_interval ?ip = (?s, ?e) \\<Longrightarrow>\n  {?s..?e} = ipt_iprange_to_set ?ip\n\ngoal (1 subgoal):\n 1. (\\<Inter>a\\<in>set (getPos l).\n        case ipt_iprange_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) -\n    (\\<Union>a\\<in>set (getNeg l).\n        case ipt_iprange_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n    \\<Inter> (ipt_iprange_to_set ` set (getPos l)) -\n    \\<Union> (ipt_iprange_to_set ` set (getNeg l))", "by blast"], ["", "text\\<open>The @{typ \"'i::len wordinterval\"} can be translated back into a list of IP ranges.\n        If a list of intervals is enough, we can use @{const wi2l}.\n        If we need it in @{typ \"'i::len ipt_iprange\"}, we can use this function.\\<close>"], ["", "definition wi_2_cidr_ipt_iprange_list :: \"'i::len wordinterval \\<Rightarrow> 'i ipt_iprange list\" where\n    \"wi_2_cidr_ipt_iprange_list r = map (uncurry IpAddrNetmask) (cidr_split r)\""], ["", "lemma wi_2_cidr_ipt_iprange_list:\n    \"(\\<Union> ip \\<in> set (wi_2_cidr_ipt_iprange_list r). ipt_iprange_to_set ip) = wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n    wordinterval_to_set r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n    wordinterval_to_set r", "have \"(\\<Union> ip \\<in> set (wi_2_cidr_ipt_iprange_list r). ipt_iprange_to_set ip) =\n           (\\<Union>x\\<in>set (cidr_split r). uncurry ipset_from_cidr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n    \\<Union> (uncurry ipset_from_cidr ` set (cidr_split r))", "unfolding wi_2_cidr_ipt_iprange_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (ipt_iprange_to_set `\n      set (map (uncurry IpAddrNetmask) (cidr_split r))) =\n    \\<Union> (uncurry ipset_from_cidr ` set (cidr_split r))", "by force"], ["proof (state)\nthis:\n  \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n  \\<Union> (uncurry ipset_from_cidr ` set (cidr_split r))\n\ngoal (1 subgoal):\n 1. \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n    wordinterval_to_set r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n  \\<Union> (uncurry ipset_from_cidr ` set (cidr_split r))\n\ngoal (1 subgoal):\n 1. \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n    wordinterval_to_set r", "using cidr_split_prefix"], ["proof (prove)\nusing this:\n  \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n  \\<Union> (uncurry ipset_from_cidr ` set (cidr_split r))\n  \\<Union> (uncurry ipset_from_cidr ` set (cidr_split ?r)) =\n  wordinterval_to_set ?r\n\ngoal (1 subgoal):\n 1. \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n    wordinterval_to_set r", "by metis"], ["proof (state)\nthis:\n  \\<Union> (ipt_iprange_to_set ` set (wi_2_cidr_ipt_iprange_list r)) =\n  wordinterval_to_set r\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>For example, this allows the following transformation\\<close>"], ["", "definition ipt_iprange_compress :: \"'i::len ipt_iprange negation_type list \\<Rightarrow> 'i ipt_iprange list\" where\n    \"ipt_iprange_compress = wi_2_cidr_ipt_iprange_list \\<circ> ipt_iprange_negation_type_to_br_intersect\""], ["", "lemma ipt_iprange_compress: \"(\\<Union> ip \\<in> set (ipt_iprange_compress l). ipt_iprange_to_set ip) =\n      (\\<Inter> ip \\<in> set (getPos l). ipt_iprange_to_set ip) - (\\<Union> ip \\<in> set (getNeg l). ipt_iprange_to_set ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (ipt_iprange_to_set ` set (ipt_iprange_compress l)) =\n    \\<Inter> (ipt_iprange_to_set ` set (getPos l)) -\n    \\<Union> (ipt_iprange_to_set ` set (getNeg l))", "by (metis wi_2_cidr_ipt_iprange_list comp_apply ipt_iprange_compress_def ipt_iprange_negation_type_to_br_intersect)"], ["", "definition normalized_cidr_ip :: \"'i::len ipt_iprange \\<Rightarrow> bool\" where\n    \"normalized_cidr_ip ip \\<equiv> case ip of IpAddrNetmask _ _ \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "lemma wi_2_cidr_ipt_iprange_list_normalized_IpAddrNetmask: \n    \"\\<forall>a'\\<in>set (wi_2_cidr_ipt_iprange_list as). normalized_cidr_ip a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (wi_2_cidr_ipt_iprange_list as).\n       normalized_cidr_ip a'", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'.\n       a' \\<in> set (wi_2_cidr_ipt_iprange_list as) \\<Longrightarrow>\n       normalized_cidr_ip a'", "apply(simp add: wi_2_cidr_ipt_iprange_list_def normalized_cidr_ip_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'.\n       a' \\<in> uncurry IpAddrNetmask `\n                set (cidr_split as) \\<Longrightarrow>\n       case a' of IpAddrNetmask x xa \\<Rightarrow> True\n       | _ \\<Rightarrow> False", "by force"], ["", "lemma ipt_iprange_compress_normalized_IpAddrNetmask:\n    \"\\<forall>a'\\<in>set (ipt_iprange_compress as). normalized_cidr_ip a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (ipt_iprange_compress as). normalized_cidr_ip a'", "by(simp add: ipt_iprange_compress_def wi_2_cidr_ipt_iprange_list_normalized_IpAddrNetmask)"], ["", "definition ipt_iprange_to_cidr :: \"'i::len ipt_iprange \\<Rightarrow> ('i word \\<times> nat) list\" where\n    \"ipt_iprange_to_cidr ips = cidr_split (iprange_interval (ipt_iprange_to_interval ips))\""], ["", "lemma ipt_ipvange_to_cidr: \"ipcidr_union_set (set (ipt_iprange_to_cidr ips)) = (ipt_iprange_to_set ips)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (ipt_iprange_to_cidr ips)) =\n    ipt_iprange_to_set ips", "apply(simp add: ipt_iprange_to_cidr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set\n     (set (cidr_split (iprange_interval (ipt_iprange_to_interval ips)))) =\n    ipt_iprange_to_set ips", "apply(simp add: ipcidr_union_set_uncurry)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (uncurry ipset_from_cidr `\n      set (cidr_split (iprange_interval (ipt_iprange_to_interval ips)))) =\n    ipt_iprange_to_set ips", "apply(case_tac \"(ipt_iprange_to_interval ips)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ipt_iprange_to_interval ips = (a, b) \\<Longrightarrow>\n       \\<Union>\n        (uncurry ipset_from_cidr `\n         set (cidr_split\n               (iprange_interval (ipt_iprange_to_interval ips)))) =\n       ipt_iprange_to_set ips", "apply(simp add: ipt_iprange_to_interval cidr_split_prefix_single)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* actually, these are toString pretty printing helpers*)"], ["", "definition interval_to_wi_to_ipt_iprange :: \"'i::len word \\<Rightarrow> 'i word \\<Rightarrow> 'i ipt_iprange\" where\n  \"interval_to_wi_to_ipt_iprange s e \\<equiv>\n    if s = e\n    then IpAddr s\n    else case cidr_split (WordInterval s e) of [(ip,nmask)] \\<Rightarrow> IpAddrNetmask ip nmask\n                                            |   _ \\<Rightarrow> IpAddrRange s e\""], ["", "lemma interval_to_wi_to_ipt_ipv4range: \"ipt_iprange_to_set (interval_to_wi_to_ipt_iprange s e) = {s..e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipt_iprange_to_set (interval_to_wi_to_ipt_iprange s e) = {s..e}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipt_iprange_to_set (interval_to_wi_to_ipt_iprange s e) = {s..e}", "from cidr_split_prefix_single[of s e]"], ["proof (chain)\npicking this:\n  \\<Union>\n   (uncurry ipset_from_cidr ` set (cidr_split (iprange_interval (s, e)))) =\n  {s..e}", "have\n      \"cidr_split (WordInterval s e) = [(a, b)] \\<Longrightarrow> ipset_from_cidr a b = {s..e}\" for a b"], ["proof (prove)\nusing this:\n  \\<Union>\n   (uncurry ipset_from_cidr ` set (cidr_split (iprange_interval (s, e)))) =\n  {s..e}\n\ngoal (1 subgoal):\n 1. cidr_split (WordInterval s e) = [(a, b)] \\<Longrightarrow>\n    ipset_from_cidr a b = {s..e}", "by(simp add: iprange_interval.simps)"], ["proof (state)\nthis:\n  cidr_split (WordInterval s e) = [(?a, ?b)] \\<Longrightarrow>\n  ipset_from_cidr ?a ?b = {s..e}\n\ngoal (1 subgoal):\n 1. ipt_iprange_to_set (interval_to_wi_to_ipt_iprange s e) = {s..e}", "thus ?thesis"], ["proof (prove)\nusing this:\n  cidr_split (WordInterval s e) = [(?a, ?b)] \\<Longrightarrow>\n  ipset_from_cidr ?a ?b = {s..e}\n\ngoal (1 subgoal):\n 1. ipt_iprange_to_set (interval_to_wi_to_ipt_iprange s e) = {s..e}", "by(simp add: interval_to_wi_to_ipt_iprange_def split: list.split)"], ["proof (state)\nthis:\n  ipt_iprange_to_set (interval_to_wi_to_ipt_iprange s e) = {s..e}\n\ngoal:\nNo subgoals!", "qed"], ["", "fun wi_to_ipt_iprange :: \"'i::len wordinterval \\<Rightarrow> 'i ipt_iprange list\" where\n  \"wi_to_ipt_iprange (WordInterval s e) = (if s > e then [] else \n      [interval_to_wi_to_ipt_iprange s e])\" |\n  \"wi_to_ipt_iprange (RangeUnion a b) = wi_to_ipt_iprange a @ wi_to_ipt_iprange b\""], ["", "lemma wi_to_ipt_ipv4range: \"\\<Union>(set (map ipt_iprange_to_set (wi_to_ipt_iprange wi))) = wordinterval_to_set wi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (map ipt_iprange_to_set (wi_to_ipt_iprange wi))) =\n    wordinterval_to_set wi", "apply(induction wi)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<Union>\n        (set (map ipt_iprange_to_set\n               (wi_to_ipt_iprange (WordInterval x1 x2)))) =\n       wordinterval_to_set (WordInterval x1 x2)\n 2. \\<And>wi1 wi2.\n       \\<lbrakk>\\<Union>\n                 (set (map ipt_iprange_to_set (wi_to_ipt_iprange wi1))) =\n                wordinterval_to_set wi1;\n        \\<Union> (set (map ipt_iprange_to_set (wi_to_ipt_iprange wi2))) =\n        wordinterval_to_set wi2\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (set (map ipt_iprange_to_set\n                                 (wi_to_ipt_iprange\n                                   (RangeUnion wi1 wi2)))) =\n                         wordinterval_to_set (RangeUnion wi1 wi2)", "apply(simp add: interval_to_wi_to_ipt_ipv4range)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wi1 wi2.\n       \\<lbrakk>\\<Union>\n                 (set (map ipt_iprange_to_set (wi_to_ipt_iprange wi1))) =\n                wordinterval_to_set wi1;\n        \\<Union> (set (map ipt_iprange_to_set (wi_to_ipt_iprange wi2))) =\n        wordinterval_to_set wi2\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (set (map ipt_iprange_to_set\n                                 (wi_to_ipt_iprange\n                                   (RangeUnion wi1 wi2)))) =\n                         wordinterval_to_set (RangeUnion wi1 wi2)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}