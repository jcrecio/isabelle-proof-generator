{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Semantics_Stateful.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma semantics_stateful_intro_process_one: \"semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma> state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p#ps) ps_processed_old \\<sigma>_old \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>\\<^sub>\\<sigma> \\<sigma>_old,p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain), Rule MatchAny default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n       \\<sigma>' = state_upate \\<sigma>_old X p \\<Longrightarrow>\n       ps_processed = ps_processed_old@[(p, X)] \\<Longrightarrow>\n       semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma> state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps ps_processed \\<sigma>'\"", "lemma semantics_stateful_intro_start: \"\\<sigma>\\<^sub>0 = \\<sigma>' \\<Longrightarrow> ps_processed = [] \\<Longrightarrow>\n       semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma> state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps ps_processed \\<sigma>'\"", "lemma semantics_stateful_packet_tagging_intro_start: \"\\<sigma>\\<^sub>0 = \\<sigma>' \\<Longrightarrow> ps_processed = [] \\<Longrightarrow>\n       semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps ps_processed \\<sigma>'\"", "lemma semantics_stateful_packet_tagging_intro_process_one:\n      \"semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p#ps) ps_processed_old \\<sigma>_old \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,(packet_tagger \\<sigma>_old p)\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain), Rule MatchAny default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n       \\<sigma>' = state_upate \\<sigma>_old X p \\<Longrightarrow>\n       ps_processed = ps_processed_old@[(p, X)] \\<Longrightarrow>\n       semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps ps_processed \\<sigma>'\"", "lemma semantics_bigstep_state_vs_tagged: \n  assumes \"\\<forall>m::'m. stateful_matcher' \\<sigma> m p = stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\" \n  shows \"\\<Gamma>,stateful_matcher' \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n         \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma> p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\"", "theorem semantics_stateful_vs_tagged:\n  assumes \"\\<forall>m \\<sigma> p. stateful_matcher' \\<sigma> m p = stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\" \n  shows \"semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0 start ps ps_processed \\<sigma>' =\n       semantics_stateful_packet_tagging rs stateful_matcher_tagged' packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed \\<sigma>'\"", "lemma \"semantics_stateful ruleset stateful_matcher state_update' (State {}) (''INPUT'', Drop) []\n    [(OtherPacket, FinalDeny)] (State {})\"", "lemma \"semantics_stateful ruleset stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n          []\n          [(SomePacket (22, 1024), FinalAllow)]\n          (State {SomePacket (1024, 22), SomePacket (22, 1024)})\"", "lemma \"semantics_stateful ruleset stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n          []\n          [(SomePacket (22, 1024), FinalAllow), (SomePacket (1024, 22), FinalAllow)]\n          (State {SomePacket (1024, 22), SomePacket (22, 1024)})\"", "lemma \"semantics_stateful ruleset stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n          []\n          [(SomePacket (1024, 22), FinalDeny), (SomePacket (22, 1024), FinalAllow), (SomePacket (1024, 22), FinalAllow)]\n          (State {SomePacket (1024, 22), SomePacket (22, 1024)})\"", "lemma \"semantics_stateful rs stateful_matcher state_update' \\<sigma>\\<^sub>0 start ps ps_processed \\<sigma>' =\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged packet_tagger state_update' \\<sigma>\\<^sub>0 start ps ps_processed \\<sigma>'\""], "translations": [["", "lemma semantics_stateful_intro_process_one: \"semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma> state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p#ps) ps_processed_old \\<sigma>_old \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>\\<^sub>\\<sigma> \\<sigma>_old,p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain), Rule MatchAny default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n       \\<sigma>' = state_upate \\<sigma>_old X p \\<Longrightarrow>\n       ps_processed = ps_processed_old@[(p, X)] \\<Longrightarrow>\n       semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma> state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps ps_processed \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma> state_upate\n              \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n              ps_processed_old \\<sigma>_old;\n     \\<Gamma>,\\<gamma>\\<^sub>\\<sigma>\n               \\<sigma>_old,p\\<turnstile> \\<langle>[Rule MatchAny\n               (Call built_in_chain),\n              Rule MatchAny\n               default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X;\n     \\<sigma>' = state_upate \\<sigma>_old X p;\n     ps_processed = ps_processed_old @ [(p, X)]\\<rbrakk>\n    \\<Longrightarrow> semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma>\n                       state_upate \\<sigma>\\<^sub>0\n                       (built_in_chain, default_policy) ps ps_processed\n                       \\<sigma>'", "by(auto intro: semantics_stateful.intros)"], ["", "lemma semantics_stateful_intro_start: \"\\<sigma>\\<^sub>0 = \\<sigma>' \\<Longrightarrow> ps_processed = [] \\<Longrightarrow>\n       semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma> state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps ps_processed \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma>\\<^sub>0 = \\<sigma>'; ps_processed = []\\<rbrakk>\n    \\<Longrightarrow> semantics_stateful \\<Gamma> \\<gamma>\\<^sub>\\<sigma>\n                       state_upate \\<sigma>\\<^sub>0\n                       (built_in_chain, default_policy) ps ps_processed\n                       \\<sigma>'", "by(auto intro: semantics_stateful.intros)"], ["", "text\\<open>Example below\\<close>"], ["", "subsection\\<open>Model 2 -- Packets Tagged with State Information\\<close>"], ["", "text\\<open>In this model, the matcher is completely stateless but packets are previously tagged with\n      (static) stateful information.\\<close>"], ["", "inductive semantics_stateful_packet_tagging ::\n   \"'a ruleset \\<Rightarrow>\n    ('a, 'ptagged) matcher \\<Rightarrow>\n    ('\\<sigma> \\<Rightarrow> 'p \\<Rightarrow> 'ptagged) \\<Rightarrow> \\<comment> \\<open>taggs the packet accordig to the current state before processing by firewall\\<close>\n    ('\\<sigma> \\<Rightarrow> final_decision \\<Rightarrow> 'p \\<Rightarrow> '\\<sigma>) \\<Rightarrow> \\<comment> \\<open>state updater\\<close>\n    '\\<sigma> \\<Rightarrow> \\<comment> \\<open>Starting state. constant\\<close>\n    (string \\<times> action) \\<Rightarrow>\n    'p list \\<Rightarrow> \\<comment> \\<open>packets to be processed\\<close>\n    ('p \\<times> final_decision) list \\<Rightarrow> \\<comment> \\<open>packets which have been processed\\<close>\n    '\\<sigma> \\<Rightarrow> \\<comment> \\<open>final state\\<close>\n    bool\" for \\<Gamma> and \\<gamma> and packet_tagger and state_update and \\<sigma>\\<^sub>0 where\n  \"semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_update \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps [] \\<sigma>\\<^sub>0\" |\n\n  \"semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_update \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p#ps) ps_processed \\<sigma>' \\<Longrightarrow>\n   \\<Gamma>,\\<gamma>,(packet_tagger \\<sigma>' p)\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain), Rule MatchAny default_policy],Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n    semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_update \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps (ps_processed@[(p, X)]) (state_update \\<sigma>' X p)\""], ["", "lemma semantics_stateful_packet_tagging_intro_start: \"\\<sigma>\\<^sub>0 = \\<sigma>' \\<Longrightarrow> ps_processed = [] \\<Longrightarrow>\n       semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps ps_processed \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma>\\<^sub>0 = \\<sigma>'; ps_processed = []\\<rbrakk>\n    \\<Longrightarrow> semantics_stateful_packet_tagging \\<Gamma> \\<gamma>\n                       packet_tagger state_upate \\<sigma>\\<^sub>0\n                       (built_in_chain, default_policy) ps ps_processed\n                       \\<sigma>'", "by(auto intro: semantics_stateful_packet_tagging.intros)"], ["", "lemma semantics_stateful_packet_tagging_intro_process_one:\n      \"semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p#ps) ps_processed_old \\<sigma>_old \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,(packet_tagger \\<sigma>_old p)\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain), Rule MatchAny default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n       \\<sigma>' = state_upate \\<sigma>_old X p \\<Longrightarrow>\n       ps_processed = ps_processed_old@[(p, X)] \\<Longrightarrow>\n       semantics_stateful_packet_tagging \\<Gamma> \\<gamma> packet_tagger state_upate \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps ps_processed \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>semantics_stateful_packet_tagging \\<Gamma> \\<gamma>\n              packet_tagger state_upate \\<sigma>\\<^sub>0\n              (built_in_chain, default_policy) (p # ps) ps_processed_old\n              \\<sigma>_old;\n     \\<Gamma>,\\<gamma>,packet_tagger \\<sigma>_old\n                        p\\<turnstile> \\<langle>[Rule MatchAny\n           (Call built_in_chain),\n          Rule MatchAny\n           default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X;\n     \\<sigma>' = state_upate \\<sigma>_old X p;\n     ps_processed = ps_processed_old @ [(p, X)]\\<rbrakk>\n    \\<Longrightarrow> semantics_stateful_packet_tagging \\<Gamma> \\<gamma>\n                       packet_tagger state_upate \\<sigma>\\<^sub>0\n                       (built_in_chain, default_policy) ps ps_processed\n                       \\<sigma>'", "by(auto intro: semantics_stateful_packet_tagging.intros)"], ["", "lemma semantics_bigstep_state_vs_tagged: \n  assumes \"\\<forall>m::'m. stateful_matcher' \\<sigma> m p = stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\" \n  shows \"\\<Gamma>,stateful_matcher' \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n         \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma> p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "fix m::\"'m match_expr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>m.\n     stateful_matcher' \\<sigma> m p =\n     stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)", "have\n    \"matches (stateful_matcher' \\<sigma>) m p \\<longleftrightarrow> matches stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\""], ["proof (prove)\nusing this:\n  \\<forall>m.\n     stateful_matcher' \\<sigma> m p =\n     stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\n\ngoal (1 subgoal):\n 1. matches (stateful_matcher' \\<sigma>) m p =\n    matches stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)", "by(induction m) (simp_all)"], ["proof (state)\nthis:\n  matches (stateful_matcher' \\<sigma>) m p =\n  matches stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "}"], ["proof (state)\nthis:\n  matches (stateful_matcher' \\<sigma>) ?m2 p =\n  matches stateful_matcher_tagged' ?m2 (packet_tagger' \\<sigma> p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "note matches_stateful_matcher_stateful_matcher_tagged=this"], ["proof (state)\nthis:\n  matches (stateful_matcher' \\<sigma>) ?m2 p =\n  matches stateful_matcher_tagged' ?m2 (packet_tagger' \\<sigma> p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "show ?thesis (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "assume ?lhs"], ["proof (state)\nthis:\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (2 subgoals):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "thus ?rhs"], ["proof (prove)\nusing this:\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "proof(induction rs Undecided t rule: iptables_bigstep_induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Decision FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>m a.\n       \\<not> matches (stateful_matcher' \\<sigma>) m p \\<Longrightarrow>\n       \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n    p\\<turnstile> \\<langle>[Rule m\n                             a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 6. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        t = Undecided \\<Longrightarrow>\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>2, Undecided\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t'\n 7. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches (stateful_matcher' \\<sigma>) m' p;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 8. \\<And>m a chain rs t.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> t", "case (Seq _ _ _ t)"], ["proof (state)\nthis:\n  rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_\n  t = Undecided \\<Longrightarrow>\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_\n\ngoal (8 subgoals):\n 1. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Decision FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>m a.\n       \\<not> matches (stateful_matcher' \\<sigma>) m p \\<Longrightarrow>\n       \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n    p\\<turnstile> \\<langle>[Rule m\n                             a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 6. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        t = Undecided \\<Longrightarrow>\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>2, Undecided\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t'\n 7. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches (stateful_matcher' \\<sigma>) m' p;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 8. \\<And>m a chain rs t.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_\n  t = Undecided \\<Longrightarrow>\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_", "apply(cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_;\n     \\<Gamma>,stateful_matcher'\n               \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n     \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n  p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n     \\<Gamma>,stateful_matcher'\n               \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_;\n     t = Undecided \\<Longrightarrow>\n     \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n  p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_;\n     t = Undecided\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                   \\<sigma>\n                   p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_\n 2. \\<And>x2.\n       \\<lbrakk>rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_;\n        t = Undecided \\<Longrightarrow>\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_;\n        t = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_", "apply (simp add: seq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_;\n        t = Undecided \\<Longrightarrow>\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_;\n        t = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_", "apply(auto simp add: decision seq dest: decisionD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_\n\ngoal (7 subgoals):\n 1. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Decision FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p;\n        a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>m a.\n       \\<not> matches (stateful_matcher' \\<sigma>) m p \\<Longrightarrow>\n       \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n    p\\<turnstile> \\<langle>[Rule m\n                             a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 6. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches (stateful_matcher' \\<sigma>) m' p;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 7. \\<And>m a chain rs t.\n       \\<lbrakk>matches (stateful_matcher' \\<sigma>) m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher_tagged',packet_tagger'\n                      \\<sigma>\n                      p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> t", "qed(auto intro: iptables_bigstep.intros simp add: matches_stateful_matcher_stateful_matcher_tagged)"], ["proof (state)\nthis:\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "assume ?rhs"], ["proof (state)\nthis:\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "thus ?lhs"], ["proof (prove)\nusing this:\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t", "proof(induction rs Undecided t rule: iptables_bigstep_induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>m a.\n       \\<not> matches stateful_matcher_tagged' m\n               (packet_tagger' \\<sigma> p) \\<Longrightarrow>\n       \\<Gamma>,stateful_matcher'\n                 \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n             a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 6. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        t = Undecided \\<Longrightarrow>\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2, Undecided\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t'\n 7. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches stateful_matcher_tagged' m' (packet_tagger' \\<sigma> p);\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 8. \\<And>m a chain rs t.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Call chain; \\<Gamma> chain = Some rs;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> t", "case (Seq _ _ _ t)"], ["proof (state)\nthis:\n  rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_\n  t = Undecided \\<Longrightarrow>\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_\n\ngoal (8 subgoals):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>m a.\n       \\<not> matches stateful_matcher_tagged' m\n               (packet_tagger' \\<sigma> p) \\<Longrightarrow>\n       \\<Gamma>,stateful_matcher'\n                 \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n             a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 6. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        t = Undecided \\<Longrightarrow>\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2, Undecided\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t'\n 7. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches stateful_matcher_tagged' m' (packet_tagger' \\<sigma> p);\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 8. \\<And>m a chain rs t.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Call chain; \\<Gamma> chain = Some rs;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_\n  t = Undecided \\<Longrightarrow>\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_\n\ngoal (1 subgoal):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_", "apply(cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_;\n     \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n  p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n     \\<Gamma>,stateful_matcher'\n               \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n     \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n  p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_;\n     t = Undecided \\<Longrightarrow>\n     \\<Gamma>,stateful_matcher'\n               \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_;\n     t = Undecided\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                \\<sigma>,p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_\n 2. \\<And>x2.\n       \\<lbrakk>rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_;\n        t = Undecided \\<Longrightarrow>\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_;\n        t = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_", "apply (simp add: seq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>2_, t\\<rangle> \\<Rightarrow> t'_;\n        t = Undecided \\<Longrightarrow>\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, Undecided\\<rangle> \\<Rightarrow> t'_;\n        t = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_", "apply(auto  simp add: decision seq dest: decisionD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t'_\n\ngoal (7 subgoals):\n 1. \\<Gamma>,stateful_matcher'\n              \\<sigma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>m a.\n       \\<not> matches stateful_matcher_tagged' m\n               (packet_tagger' \\<sigma> p) \\<Longrightarrow>\n       \\<Gamma>,stateful_matcher'\n                 \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n             a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 6. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches stateful_matcher_tagged' m' (packet_tagger' \\<sigma> p);\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 7. \\<And>m a chain rs t.\n       \\<lbrakk>matches stateful_matcher_tagged' m\n                 (packet_tagger' \\<sigma> p);\n        a = Call chain; \\<Gamma> chain = Some rs;\n        \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,stateful_matcher'\n                  \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,stateful_matcher'\n                                   \\<sigma>,p\\<turnstile> \\<langle>[Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> t", "qed(auto intro: iptables_bigstep.intros simp add: matches_stateful_matcher_stateful_matcher_tagged)"], ["proof (state)\nthis:\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,stateful_matcher'\n            \\<sigma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,stateful_matcher_tagged',packet_tagger' \\<sigma>\n                                     p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Both semantics are equal\\<close>"], ["", "theorem semantics_stateful_vs_tagged:\n  assumes \"\\<forall>m \\<sigma> p. stateful_matcher' \\<sigma> m p = stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\" \n  shows \"semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0 start ps ps_processed \\<sigma>' =\n       semantics_stateful_packet_tagging rs stateful_matcher_tagged' packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>' =\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>' =\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'", "from semantics_bigstep_state_vs_tagged[of stateful_matcher' _ _ stateful_matcher_tagged' packet_tagger'] assms"], ["proof (chain)\npicking this:\n  \\<forall>m.\n     stateful_matcher' ?\\<sigma> m ?p =\n     stateful_matcher_tagged' m\n      (packet_tagger' ?\\<sigma> ?p) \\<Longrightarrow>\n  ?\\<Gamma>,stateful_matcher'\n             ?\\<sigma>,?p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> ?t =\n  ?\\<Gamma>,stateful_matcher_tagged',packet_tagger' ?\\<sigma>\n?p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> ?t\n  \\<forall>m \\<sigma> p.\n     stateful_matcher' \\<sigma> m p =\n     stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)", "have vs_tagged:\n     \"rs,stateful_matcher' \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain), Rule MatchAny default_policy], Undecided\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n      rs,stateful_matcher_tagged',packet_tagger' \\<sigma>' p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain), Rule MatchAny default_policy], Undecided\\<rangle> \\<Rightarrow> t\"\n      for t p \\<sigma>' built_in_chain default_policy"], ["proof (prove)\nusing this:\n  \\<forall>m.\n     stateful_matcher' ?\\<sigma> m ?p =\n     stateful_matcher_tagged' m\n      (packet_tagger' ?\\<sigma> ?p) \\<Longrightarrow>\n  ?\\<Gamma>,stateful_matcher'\n             ?\\<sigma>,?p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> ?t =\n  ?\\<Gamma>,stateful_matcher_tagged',packet_tagger' ?\\<sigma>\n?p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> ?t\n  \\<forall>m \\<sigma> p.\n     stateful_matcher' \\<sigma> m p =\n     stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\n\ngoal (1 subgoal):\n 1. rs,stateful_matcher'\n        \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n     (Call built_in_chain),\n    Rule MatchAny default_policy], Undecided\\<rangle> \\<Rightarrow> t =\n    rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                 p\\<turnstile> \\<langle>[Rule MatchAny\n                    (Call built_in_chain),\n                   Rule MatchAny\n                    default_policy], Undecided\\<rangle> \\<Rightarrow> t", "by blast"], ["proof (state)\nthis:\n  rs,stateful_matcher'\n      ?\\<sigma>',?p\\<turnstile> \\<langle>[Rule MatchAny\n     (Call ?built_in_chain),\n    Rule MatchAny ?default_policy], Undecided\\<rangle> \\<Rightarrow> ?t =\n  rs,stateful_matcher_tagged',packet_tagger' ?\\<sigma>'\n                               ?p\\<turnstile> \\<langle>[Rule MatchAny\n                   (Call ?built_in_chain),\n                  Rule MatchAny\n                   ?default_policy], Undecided\\<rangle> \\<Rightarrow> ?t\n\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>' =\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>m \\<sigma> p.\n     stateful_matcher' \\<sigma> m p =\n     stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)", "have stateful_matcher_eq:\n    \"(\\<lambda>a b. stateful_matcher_tagged' a (packet_tagger' \\<sigma>' b)) = stateful_matcher' \\<sigma>'\" for \\<sigma>'"], ["proof (prove)\nusing this:\n  \\<forall>m \\<sigma> p.\n     stateful_matcher' \\<sigma> m p =\n     stateful_matcher_tagged' m (packet_tagger' \\<sigma> p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>a b.\n        stateful_matcher_tagged' a (packet_tagger' \\<sigma>' b)) =\n    stateful_matcher' \\<sigma>'", "by presburger"], ["proof (state)\nthis:\n  (\\<lambda>a b. stateful_matcher_tagged' a (packet_tagger' ?\\<sigma>' b)) =\n  stateful_matcher' ?\\<sigma>'\n\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>' =\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'", "show ?thesis (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>' =\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>' \\<Longrightarrow>\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'\n 2. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>' \\<Longrightarrow>\n    semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>'", "assume ?lhs"], ["proof (state)\nthis:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   start ps ps_processed \\<sigma>'\n\ngoal (2 subgoals):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>' \\<Longrightarrow>\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'\n 2. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>' \\<Longrightarrow>\n    semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>'", "thus ?rhs"], ["proof (prove)\nusing this:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   start ps ps_processed \\<sigma>'\n\ngoal (1 subgoal):\n 1. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'", "proof(induction rule: semantics_stateful.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>built_in_chain default_policy ps.\n       semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n        packet_tagger' state_update' \\<sigma>\\<^sub>0\n        (built_in_chain, default_policy) ps [] \\<sigma>\\<^sub>0\n 2. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful rs stateful_matcher' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n         packet_tagger' state_update' \\<sigma>\\<^sub>0\n         (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n        rs,stateful_matcher'\n            \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n         (Call built_in_chain),\n        Rule MatchAny\n         default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                      X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful_packet_tagging rs\n                          stateful_matcher_tagged' packet_tagger'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>built_in_chain default_policy ps.\n       semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n        packet_tagger' state_update' \\<sigma>\\<^sub>0\n        (built_in_chain, default_policy) ps [] \\<sigma>\\<^sub>0\n 2. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful rs stateful_matcher' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n         packet_tagger' state_update' \\<sigma>\\<^sub>0\n         (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n        rs,stateful_matcher'\n            \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n         (Call built_in_chain),\n        Rule MatchAny\n         default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                      X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful_packet_tagging rs\n                          stateful_matcher_tagged' packet_tagger'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0\n     (built_in_chain_, default_policy_) ps_ [] \\<sigma>\\<^sub>0", "by(auto intro: semantics_stateful_packet_tagging_intro_start)[1]"], ["proof (state)\nthis:\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain_, default_policy_) ps_ [] \\<sigma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful rs stateful_matcher' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n         packet_tagger' state_update' \\<sigma>\\<^sub>0\n         (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n        rs,stateful_matcher'\n            \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n         (Call built_in_chain),\n        Rule MatchAny\n         default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                      X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful_packet_tagging rs\n                          stateful_matcher_tagged' packet_tagger'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful rs stateful_matcher' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n         packet_tagger' state_update' \\<sigma>\\<^sub>0\n         (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n        rs,stateful_matcher'\n            \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n         (Call built_in_chain),\n        Rule MatchAny\n         default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                      X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful_packet_tagging rs\n                          stateful_matcher_tagged' packet_tagger'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "case (2 built_in_chain default_policy p ps  ps_processed \\<sigma>')"], ["proof (state)\nthis:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n  rs,stateful_matcher'\n      \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain),\n  Rule MatchAny\n   default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful rs stateful_matcher' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n         packet_tagger' state_update' \\<sigma>\\<^sub>0\n         (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n        rs,stateful_matcher'\n            \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n         (Call built_in_chain),\n        Rule MatchAny\n         default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                      X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful_packet_tagging rs\n                          stateful_matcher_tagged' packet_tagger'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "from 2"], ["proof (chain)\npicking this:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n  rs,stateful_matcher'\n      \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain),\n  Rule MatchAny\n   default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'", "have\n            \"semantics_stateful_packet_tagging rs stateful_matcher_tagged' packet_tagger' state_update' \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\""], ["proof (prove)\nusing this:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n  rs,stateful_matcher'\n      \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain),\n  Rule MatchAny\n   default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n\ngoal (1 subgoal):\n 1. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0\n     (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful rs stateful_matcher' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n         packet_tagger' state_update' \\<sigma>\\<^sub>0\n         (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n        rs,stateful_matcher'\n            \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n         (Call built_in_chain),\n        Rule MatchAny\n         default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                      X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful_packet_tagging rs\n                          stateful_matcher_tagged' packet_tagger'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "with 2(2,3)"], ["proof (chain)\npicking this:\n  rs,stateful_matcher'\n      \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain),\n  Rule MatchAny\n   default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'", "show ?case"], ["proof (prove)\nusing this:\n  rs,stateful_matcher'\n      \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain),\n  Rule MatchAny\n   default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n\ngoal (1 subgoal):\n 1. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0\n     (built_in_chain, default_policy) ps (ps_processed @ [(p, X_)])\n     (state_update' \\<sigma>' X_ p)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs,stateful_matcher'\n                 \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n              (Call built_in_chain),\n             Rule MatchAny\n              default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_;\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> semantics_stateful_packet_tagging rs\n                       stateful_matcher_tagged' packet_tagger' state_update'\n                       \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps\n                       (ps_processed @ [(p, X_)])\n                       (state_update' \\<sigma>' X_ p)", "apply(rule semantics_stateful_packet_tagging_intro_process_one)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>rs,stateful_matcher'\n                 \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n              (Call built_in_chain),\n             Rule MatchAny\n              default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_;\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> semantics_stateful_packet_tagging rs\n                       stateful_matcher_tagged' packet_tagger' state_update'\n                       \\<sigma>\\<^sub>0 (built_in_chain, default_policy)\n                       (?p3 # ps) ?ps_processed_old3 ?\\<sigma>_old3\n 2. \\<lbrakk>rs,stateful_matcher'\n                 \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n              (Call built_in_chain),\n             Rule MatchAny\n              default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_;\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> rs,stateful_matcher_tagged',packet_tagger'\n             ?\\<sigma>_old3\n             ?p3\\<turnstile> \\<langle>[Rule MatchAny (Call built_in_chain),\n Rule MatchAny\n  default_policy], Undecided\\<rangle> \\<Rightarrow> Decision ?X3\n 3. \\<lbrakk>rs,stateful_matcher'\n                 \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n              (Call built_in_chain),\n             Rule MatchAny\n              default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_;\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> state_update' \\<sigma>' X_ p =\n                      state_update' ?\\<sigma>_old3 ?X3 ?p3\n 4. \\<lbrakk>rs,stateful_matcher'\n                 \\<sigma>',p\\<turnstile> \\<langle>[Rule MatchAny\n              (Call built_in_chain),\n             Rule MatchAny\n              default_policy], Undecided\\<rangle> \\<Rightarrow> Decision X_;\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>';\n     semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n      packet_tagger' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> ps_processed @ [(p, X_)] =\n                      ?ps_processed_old3 @ [(?p3, ?X3)]", "apply(simp_all add: vs_tagged)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) ps (ps_processed @ [(p, X_)])\n   (state_update' \\<sigma>' X_ p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n   \\<sigma>'\n\ngoal (1 subgoal):\n 1. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>' \\<Longrightarrow>\n    semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>' \\<Longrightarrow>\n    semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>'", "assume ?rhs"], ["proof (state)\nthis:\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n   \\<sigma>'\n\ngoal (1 subgoal):\n 1. semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n     packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>' \\<Longrightarrow>\n    semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>'", "thus ?lhs"], ["proof (prove)\nusing this:\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n   \\<sigma>'\n\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>'", "proof(induction rule: semantics_stateful_packet_tagging.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>built_in_chain default_policy ps.\n       semantics_stateful rs stateful_matcher' state_update'\n        \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps []\n        \\<sigma>\\<^sub>0\n 2. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful_packet_tagging rs\n                 stateful_matcher_tagged' packet_tagger' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful rs stateful_matcher' state_update'\n         \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n         ps_processed \\<sigma>';\n        rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                     p\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call built_in_chain),\n                       Rule MatchAny\n                        default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                     X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful rs stateful_matcher'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>built_in_chain default_policy ps.\n       semantics_stateful rs stateful_matcher' state_update'\n        \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps []\n        \\<sigma>\\<^sub>0\n 2. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful_packet_tagging rs\n                 stateful_matcher_tagged' packet_tagger' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful rs stateful_matcher' state_update'\n         \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n         ps_processed \\<sigma>';\n        rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                     p\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call built_in_chain),\n                       Rule MatchAny\n                        default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                     X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful rs stateful_matcher'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     (built_in_chain_, default_policy_) ps_ [] \\<sigma>\\<^sub>0", "by(auto intro: semantics_stateful_intro_start)"], ["proof (state)\nthis:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain_, default_policy_) ps_ [] \\<sigma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful_packet_tagging rs\n                 stateful_matcher_tagged' packet_tagger' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful rs stateful_matcher' state_update'\n         \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n         ps_processed \\<sigma>';\n        rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                     p\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call built_in_chain),\n                       Rule MatchAny\n                        default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                     X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful rs stateful_matcher'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful_packet_tagging rs\n                 stateful_matcher_tagged' packet_tagger' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful rs stateful_matcher' state_update'\n         \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n         ps_processed \\<sigma>';\n        rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                     p\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call built_in_chain),\n                       Rule MatchAny\n                        default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                     X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful rs stateful_matcher'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "case (2 built_in_chain default_policy p ps ps_processed \\<sigma>')"], ["proof (state)\nthis:\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n  rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                               p\\<turnstile> \\<langle>[Rule MatchAny\n                  (Call built_in_chain),\n                 Rule MatchAny\n                  default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                               X_\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>built_in_chain default_policy p ps ps_processed \\<sigma>' X.\n       \\<lbrakk>semantics_stateful_packet_tagging rs\n                 stateful_matcher_tagged' packet_tagger' state_update'\n                 \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n                 ps_processed \\<sigma>';\n        semantics_stateful rs stateful_matcher' state_update'\n         \\<sigma>\\<^sub>0 (built_in_chain, default_policy) (p # ps)\n         ps_processed \\<sigma>';\n        rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                     p\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call built_in_chain),\n                       Rule MatchAny\n                        default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                     X\\<rbrakk>\n       \\<Longrightarrow> semantics_stateful rs stateful_matcher'\n                          state_update' \\<sigma>\\<^sub>0\n                          (built_in_chain, default_policy) ps\n                          (ps_processed @ [(p, X)])\n                          (state_update' \\<sigma>' X p)", "thus ?case"], ["proof (prove)\nusing this:\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n  rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                               p\\<turnstile> \\<langle>[Rule MatchAny\n                  (Call built_in_chain),\n                 Rule MatchAny\n                  default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                               X_\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) (p # ps) ps_processed \\<sigma>'\n\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n     (built_in_chain, default_policy) ps (ps_processed @ [(p, X_)])\n     (state_update' \\<sigma>' X_ p)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n              packet_tagger' state_update' \\<sigma>\\<^sub>0\n              (built_in_chain, default_policy) (p # ps) ps_processed\n              \\<sigma>';\n     rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                  p\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call built_in_chain),\n                    Rule MatchAny\n                     default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                  X_;\n     semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> semantics_stateful rs stateful_matcher' state_update'\n                       \\<sigma>\\<^sub>0 (built_in_chain, default_policy) ps\n                       (ps_processed @ [(p, X_)])\n                       (state_update' \\<sigma>' X_ p)", "apply(rule semantics_stateful_intro_process_one)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n              packet_tagger' state_update' \\<sigma>\\<^sub>0\n              (built_in_chain, default_policy) (p # ps) ps_processed\n              \\<sigma>';\n     rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                  p\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call built_in_chain),\n                    Rule MatchAny\n                     default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                  X_;\n     semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> semantics_stateful rs stateful_matcher' state_update'\n                       \\<sigma>\\<^sub>0 (built_in_chain, default_policy)\n                       (?p3 # ps) ?ps_processed_old3 ?\\<sigma>_old3\n 2. \\<lbrakk>semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n              packet_tagger' state_update' \\<sigma>\\<^sub>0\n              (built_in_chain, default_policy) (p # ps) ps_processed\n              \\<sigma>';\n     rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                  p\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call built_in_chain),\n                    Rule MatchAny\n                     default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                  X_;\n     semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> rs,stateful_matcher'\n                          ?\\<sigma>_old3,?p3\\<turnstile> \\<langle>[Rule\n                              MatchAny (Call built_in_chain),\n                             Rule MatchAny\n                              default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n     ?X3\n 3. \\<lbrakk>semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n              packet_tagger' state_update' \\<sigma>\\<^sub>0\n              (built_in_chain, default_policy) (p # ps) ps_processed\n              \\<sigma>';\n     rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                  p\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call built_in_chain),\n                    Rule MatchAny\n                     default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                  X_;\n     semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> state_update' \\<sigma>' X_ p =\n                      state_update' ?\\<sigma>_old3 ?X3 ?p3\n 4. \\<lbrakk>semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n              packet_tagger' state_update' \\<sigma>\\<^sub>0\n              (built_in_chain, default_policy) (p # ps) ps_processed\n              \\<sigma>';\n     rs,stateful_matcher_tagged',packet_tagger' \\<sigma>'\n                                  p\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call built_in_chain),\n                    Rule MatchAny\n                     default_policy], Undecided\\<rangle> \\<Rightarrow> Decision\n                                  X_;\n     semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n      (built_in_chain, default_policy) (p # ps) ps_processed\n      \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> ps_processed @ [(p, X_)] =\n                      ?ps_processed_old3 @ [(?p3, ?X3)]", "apply(simp_all add: stateful_matcher_eq vs_tagged)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   (built_in_chain, default_policy) ps (ps_processed @ [(p, X_)])\n   (state_update' \\<sigma>' X_ p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   start ps ps_processed \\<sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics_stateful rs stateful_matcher' state_update' \\<sigma>\\<^sub>0\n   start ps ps_processed \\<sigma>' =\n  semantics_stateful_packet_tagging rs stateful_matcher_tagged'\n   packet_tagger' state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n   \\<sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Examples\\<close>"], ["", "context\nbegin"], ["", "subsection\\<open>Example: Conntrack with curried matcher\\<close>"], ["", "text\\<open>We illustrate stateful semantics with a simple example. We allow matching on the states New\n  and Established. In addition, we introduce a primitive match to match on outgoing ssh packets (dst port = 22).\n  The state is managed in a state table where accepted connections are remembered.\\<close>"], ["", "text\\<open>SomePacket with source and destination port or something we don't know about\\<close>"], ["", "private"], ["", "datatype packet = SomePacket \"nat \\<times> nat\" | OtherPacket"], ["", "private"], ["", "datatype primitive_matches = New | Established | IsSSH"], ["", "text\\<open>In the state, we remember the packets which belong to an established connection.\\<close>"], ["", "private"], ["", "datatype conntrack_state = State \"packet set\""], ["", "text\\<open>The stateful primitive matcher: It is given the current state table. \n    If match on @{const Established}, the packet must be known in the state table.\n    If match on @{const New}, the packet must not be in the state table.\n    If match on @{const IsSSH}, the dst port of the packet must be 22.\\<close>"], ["", "private"], ["", "fun stateful_matcher :: \"conntrack_state \\<Rightarrow> (primitive_matches, packet) matcher\" where\n    \"stateful_matcher (State state_table) = (\\<lambda>m p. m = Established \\<and> p \\<in> state_table \\<or>\n                                           m = New \\<and> p \\<notin> state_table \\<or>\n                                           m = IsSSH \\<and> (\\<exists>dst_port. p = SomePacket (22, dst_port)))\""], ["", "text\\<open>Connections are always bi-directional.\\<close>"], ["", "private"], ["", "fun reverse_direction :: \"packet \\<Rightarrow> packet\" where\n    \"reverse_direction OtherPacket = OtherPacket\" |\n    \"reverse_direction (SomePacket (src, dst)) = SomePacket (dst,src)\""], ["", "text\\<open>If a packet is accepted, the state for its bi-directional connection is saved in the state table.\\<close>"], ["", "private"], ["", "fun state_update' :: \"conntrack_state \\<Rightarrow> final_decision \\<Rightarrow> packet \\<Rightarrow> conntrack_state\" where\n    \"state_update' (State state_table) FinalAllow p = State (state_table \\<union> {p, reverse_direction p})\" |\n    \"state_update' (State state_table) FinalDeny p = State state_table\""], ["", "text\\<open>Allow everything that is established and allow new ssh connections.\n    Drop everything else (default policy, see below)\\<close>"], ["", "private"], ["", "definition \"ruleset == [''INPUT'' \\<mapsto> [Rule (Match Established) Accept, Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\""], ["", "text\\<open>The @{const ruleset} does not allow @{const OtherPacket}\\<close>"], ["", "lemma \"semantics_stateful ruleset stateful_matcher state_update' (State {}) (''INPUT'', Drop) []\n    [(OtherPacket, FinalDeny)] (State {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful ruleset stateful_matcher state_update' (State {})\n     (''INPUT'', Drop) [] [(OtherPacket, FinalDeny)] (State {})", "unfolding ruleset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop) []\n     [(OtherPacket, FinalDeny)] (State {})", "apply(rule semantics_stateful_intro_process_one)"], ["proof (prove)\ngoal (4 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop) [?p]\n     ?ps_processed_old ?\\<sigma>_old\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,?p\\<turnstile> \\<langle>[Rule MatchAny\n                   (Call ''INPUT''),\n                  Rule MatchAny\n                   Drop], Undecided\\<rangle> \\<Rightarrow> Decision ?X\n 3. State {} = state_update' ?\\<sigma>_old ?X ?p\n 4. [(OtherPacket, FinalDeny)] = ?ps_processed_old @ [(?p, ?X)]", "apply(simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [OtherPacket] [] ?\\<sigma>_old\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,OtherPacket\\<turnstile> \\<langle>[Rule\n                            MatchAny (Call ''INPUT''),\n                           Rule MatchAny\n                            Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 3. State {} = state_update' ?\\<sigma>_old FinalDeny OtherPacket", "apply(rule semantics_stateful_intro_start)"], ["proof (prove)\ngoal (4 subgoals):\n 1. State {} = ?\\<sigma>_old\n 2. [] = []\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,OtherPacket\\<turnstile> \\<langle>[Rule\n                            MatchAny (Call ''INPUT''),\n                           Rule MatchAny\n                            Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. State {} = state_update' ?\\<sigma>_old FinalDeny OtherPacket", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),OtherPacket\\<turnstile> \\<langle>[Rule MatchAny\n                    (Call ''INPUT''),\n                   Rule MatchAny\n                    Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                       FinalDeny\n 2. State {} = state_update' (State {}) FinalDeny OtherPacket", "apply(rule seq_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),OtherPacket\\<turnstile> \\<langle>[Rule MatchAny\n                    (Call ''INPUT'')], Undecided\\<rangle> \\<Rightarrow> ?t14\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),OtherPacket\\<turnstile> \\<langle>[Rule MatchAny\n                    Drop], ?t14\\<rangle> \\<Rightarrow> Decision FinalDeny\n 3. State {} = state_update' (State {}) FinalDeny OtherPacket", "apply(rule call_result)"], ["proof (prove)\ngoal (5 subgoals):\n 1. matches (stateful_matcher (State {})) MatchAny OtherPacket\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     ''INPUT'' =\n    Some ?rs17\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),OtherPacket\\<turnstile> \\<langle>?rs17, Undecided\\<rangle> \\<Rightarrow> ?t14\n 4. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),OtherPacket\\<turnstile> \\<langle>[Rule MatchAny\n                    Drop], ?t14\\<rangle> \\<Rightarrow> Decision FinalDeny\n 5. State {} = state_update' (State {}) FinalDeny OtherPacket", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),OtherPacket\\<turnstile> \\<langle>[Rule\n                                   (Match Established) Accept,\n                                  Rule (MatchAnd (Match IsSSH) (Match New))\n                                   Accept], Undecided\\<rangle> \\<Rightarrow> ?t14\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),OtherPacket\\<turnstile> \\<langle>[Rule\n                                   MatchAny\n                                   Drop], ?t14\\<rangle> \\<Rightarrow> Decision\n                                 FinalDeny", "apply(rule seq_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),OtherPacket\\<turnstile> \\<langle>[Rule\n                                   (Match Established)\n                                   Accept], Undecided\\<rangle> \\<Rightarrow> ?t22\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),OtherPacket\\<turnstile> \\<langle>[Rule\n                                   (MatchAnd (Match IsSSH) (Match New))\n                                   Accept], ?t22\\<rangle> \\<Rightarrow> ?t14\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),OtherPacket\\<turnstile> \\<langle>[Rule\n                                   MatchAny\n                                   Drop], ?t14\\<rangle> \\<Rightarrow> Decision\n                                 FinalDeny", "apply(auto intro: iptables_bigstep.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>The @{const ruleset} allows ssh packets, i.e. any packets with destination port 22 in the @{const New} rule.\n        The state is updated such that everything which belongs to the connection will now be accepted.\\<close>"], ["", "lemma \"semantics_stateful ruleset stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n          []\n          [(SomePacket (22, 1024), FinalAllow)]\n          (State {SomePacket (1024, 22), SomePacket (22, 1024)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful ruleset stateful_matcher state_update' (State {})\n     (''INPUT'', Drop) [] [(SomePacket (22, 1024), FinalAllow)]\n     (State {SomePacket (1024, 22), SomePacket (22, 1024)})", "unfolding ruleset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop) []\n     [(SomePacket (22, 1024), FinalAllow)]\n     (State {SomePacket (1024, 22), SomePacket (22, 1024)})", "apply(rule semantics_stateful_intro_process_one)"], ["proof (prove)\ngoal (4 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop) [?p]\n     ?ps_processed_old ?\\<sigma>_old\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,?p\\<turnstile> \\<langle>[Rule MatchAny\n                   (Call ''INPUT''),\n                  Rule MatchAny\n                   Drop], Undecided\\<rangle> \\<Rightarrow> Decision ?X\n 3. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old ?X ?p\n 4. [(SomePacket (22, 1024), FinalAllow)] = ?ps_processed_old @ [(?p, ?X)]", "apply(simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [SomePacket (22, 1024)] [] ?\\<sigma>_old\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,SomePacket\n                                (22,\n                                 1024)\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call ''INPUT''),\n                       Rule MatchAny\n                        Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                           FinalAllow\n 3. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old FinalAllow (SomePacket (22, 1024))", "apply(rule semantics_stateful_intro_start)"], ["proof (prove)\ngoal (4 subgoals):\n 1. State {} = ?\\<sigma>_old\n 2. [] = []\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,SomePacket\n                                (22,\n                                 1024)\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call ''INPUT''),\n                       Rule MatchAny\n                        Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                           FinalAllow\n 4. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old FinalAllow (SomePacket (22, 1024))", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),SomePacket\n                        (22,\n                         1024)\\<turnstile> \\<langle>[Rule MatchAny\n                (Call ''INPUT''),\n               Rule MatchAny\n                Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow\n 2. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' (State {}) FinalAllow (SomePacket (22, 1024))", "apply(rule seq_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),SomePacket\n                        (22,\n                         1024)\\<turnstile> \\<langle>[Rule MatchAny\n                (Call ''INPUT'')], Undecided\\<rangle> \\<Rightarrow> ?t14\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),SomePacket\n                        (22,\n                         1024)\\<turnstile> \\<langle>[Rule MatchAny\n                Drop], ?t14\\<rangle> \\<Rightarrow> Decision FinalAllow\n 3. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' (State {}) FinalAllow (SomePacket (22, 1024))", "apply(rule call_result)"], ["proof (prove)\ngoal (5 subgoals):\n 1. matches (stateful_matcher (State {})) MatchAny (SomePacket (22, 1024))\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     ''INPUT'' =\n    Some ?rs17\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),SomePacket\n                        (22,\n                         1024)\\<turnstile> \\<langle>?rs17, Undecided\\<rangle> \\<Rightarrow> ?t14\n 4. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),SomePacket\n                        (22,\n                         1024)\\<turnstile> \\<langle>[Rule MatchAny\n                Drop], ?t14\\<rangle> \\<Rightarrow> Decision FinalAllow\n 5. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' (State {}) FinalAllow (SomePacket (22, 1024))", "apply(simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (22,\n  1024)\\<turnstile> \\<langle>[Rule (Match Established) Accept,\n                              Rule (MatchAnd (Match IsSSH) (Match New))\n                               Accept], Undecided\\<rangle> \\<Rightarrow> ?t14\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (22,\n  1024)\\<turnstile> \\<langle>[Rule MatchAny\n                               Drop], ?t14\\<rangle> \\<Rightarrow> Decision\n                             FinalAllow\n 3. {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    {SomePacket (22, 1024), SomePacket (1024, 22)}", "apply(rule seq_cons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (22,\n  1024)\\<turnstile> \\<langle>[Rule (Match Established)\n                               Accept], Undecided\\<rangle> \\<Rightarrow> ?t22\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (22,\n  1024)\\<turnstile> \\<langle>[Rule (MatchAnd (Match IsSSH) (Match New))\n                               Accept], ?t22\\<rangle> \\<Rightarrow> ?t14\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (22,\n  1024)\\<turnstile> \\<langle>[Rule MatchAny\n                               Drop], ?t14\\<rangle> \\<Rightarrow> Decision\n                             FinalAllow\n 4. {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    {SomePacket (22, 1024), SomePacket (1024, 22)}", "apply(auto intro: iptables_bigstep.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>If we continue with this state, answer packets are now allowed\\<close>"], ["", "lemma \"semantics_stateful ruleset stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n          []\n          [(SomePacket (22, 1024), FinalAllow), (SomePacket (1024, 22), FinalAllow)]\n          (State {SomePacket (1024, 22), SomePacket (22, 1024)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful ruleset stateful_matcher state_update' (State {})\n     (''INPUT'', Drop) []\n     [(SomePacket (22, 1024), FinalAllow),\n      (SomePacket (1024, 22), FinalAllow)]\n     (State {SomePacket (1024, 22), SomePacket (22, 1024)})", "unfolding ruleset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop) []\n     [(SomePacket (22, 1024), FinalAllow),\n      (SomePacket (1024, 22), FinalAllow)]\n     (State {SomePacket (1024, 22), SomePacket (22, 1024)})", "apply(rule semantics_stateful_intro_process_one)"], ["proof (prove)\ngoal (4 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop) [?p]\n     ?ps_processed_old ?\\<sigma>_old\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,?p\\<turnstile> \\<langle>[Rule MatchAny\n                   (Call ''INPUT''),\n                  Rule MatchAny\n                   Drop], Undecided\\<rangle> \\<Rightarrow> Decision ?X\n 3. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old ?X ?p\n 4. [(SomePacket (22, 1024), FinalAllow),\n     (SomePacket (1024, 22), FinalAllow)] =\n    ?ps_processed_old @ [(?p, ?X)]", "apply(simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [SomePacket (1024, 22)] [(SomePacket (22, 1024), FinalAllow)]\n     ?\\<sigma>_old\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,SomePacket\n                                (1024,\n                                 22)\\<turnstile> \\<langle>[Rule MatchAny\n                      (Call ''INPUT''),\n                     Rule MatchAny\n                      Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                         FinalAllow\n 3. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old FinalAllow (SomePacket (1024, 22))", "apply(rule semantics_stateful_intro_process_one)"], ["proof (prove)\ngoal (6 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [?p10, SomePacket (1024, 22)] ?ps_processed_old10 ?\\<sigma>_old10\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old10,?p10\\<turnstile> \\<langle>[Rule MatchAny\n                       (Call ''INPUT''),\n                      Rule MatchAny\n                       Drop], Undecided\\<rangle> \\<Rightarrow> Decision ?X10\n 3. ?\\<sigma>_old = state_update' ?\\<sigma>_old10 ?X10 ?p10\n 4. [(SomePacket (22, 1024), FinalAllow)] =\n    ?ps_processed_old10 @ [(?p10, ?X10)]\n 5. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,SomePacket\n                                (1024,\n                                 22)\\<turnstile> \\<langle>[Rule MatchAny\n                      (Call ''INPUT''),\n                     Rule MatchAny\n                      Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                         FinalAllow\n 6. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old FinalAllow (SomePacket (1024, 22))", "apply(simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [SomePacket (22, 1024), SomePacket (1024, 22)] [] ?\\<sigma>_old10\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old10,SomePacket\n                                  (22,\n                                   1024)\\<turnstile> \\<langle>[Rule MatchAny\n                          (Call ''INPUT''),\n                         Rule MatchAny\n                          Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                             FinalAllow\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update' ?\\<sigma>_old10 FinalAllow\n                   (SomePacket\n                     (22,\n                      1024))),SomePacket\n                               (1024,\n                                22)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 4. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update'\n     (state_update' ?\\<sigma>_old10 FinalAllow (SomePacket (22, 1024)))\n     FinalAllow (SomePacket (1024, 22))", "apply(rule semantics_stateful_intro_start)"], ["proof (prove)\ngoal (5 subgoals):\n 1. State {} = ?\\<sigma>_old10\n 2. [] = []\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old10,SomePacket\n                                  (22,\n                                   1024)\\<turnstile> \\<langle>[Rule MatchAny\n                          (Call ''INPUT''),\n                         Rule MatchAny\n                          Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                             FinalAllow\n 4. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update' ?\\<sigma>_old10 FinalAllow\n                   (SomePacket\n                     (22,\n                      1024))),SomePacket\n                               (1024,\n                                22)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 5. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update'\n     (state_update' ?\\<sigma>_old10 FinalAllow (SomePacket (22, 1024)))\n     FinalAllow (SomePacket (1024, 22))", "apply(simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),SomePacket\n                        (22,\n                         1024)\\<turnstile> \\<langle>[Rule MatchAny\n                (Call ''INPUT''),\n               Rule MatchAny\n                Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update' (State {}) FinalAllow\n                   (SomePacket\n                     (22,\n                      1024))),SomePacket\n                               (1024,\n                                22)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 3. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update'\n     (state_update' (State {}) FinalAllow (SomePacket (22, 1024)))\n     FinalAllow (SomePacket (1024, 22))", "apply(rule seq_cons, rule call_result, simp_all, rule seq_cons)"], ["proof (prove)\ngoal (5 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (22,\n  1024)\\<turnstile> \\<langle>[Rule (Match Established)\n                               Accept], Undecided\\<rangle> \\<Rightarrow> ?t33\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (22,\n  1024)\\<turnstile> \\<langle>[Rule (MatchAnd (Match IsSSH) (Match New))\n                               Accept], ?t33\\<rangle> \\<Rightarrow> ?t25\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = New \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (22,\n  1024)\\<turnstile> \\<langle>[Rule MatchAny\n                               Drop], ?t25\\<rangle> \\<Rightarrow> Decision\n                             FinalAllow\n 4. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = Established \\<and>\n                    (p = SomePacket (22, 1024) \\<or>\n                     p = SomePacket (1024, 22)) \\<or>\n                    m = New \\<and>\n                    p \\<noteq> SomePacket (22, 1024) \\<and>\n                    p \\<noteq> SomePacket (1024, 22) \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (1024,\n  22)\\<turnstile> \\<langle>[Rule MatchAny (Call ''INPUT''),\n                            Rule MatchAny\n                             Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                                FinalAllow\n 5. {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    {SomePacket (1024, 22), SomePacket (22, 1024), SomePacket (1024, 22)}", "apply(auto intro: iptables_bigstep.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = Established \\<and>\n                    (p = SomePacket (22, 1024) \\<or>\n                     p = SomePacket (1024, 22)) \\<or>\n                    m = New \\<and>\n                    p \\<noteq> SomePacket (22, 1024) \\<and>\n                    p \\<noteq> SomePacket (1024, 22) \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (1024,\n  22)\\<turnstile> \\<langle>[Rule MatchAny (Call ''INPUT''),\n                            Rule MatchAny\n                             Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                                FinalAllow", "apply(rule seq_cons, rule call_result, simp_all, rule seq_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = Established \\<and>\n                    (p = SomePacket (22, 1024) \\<or>\n                     p = SomePacket (1024, 22)) \\<or>\n                    m = New \\<and>\n                    p \\<noteq> SomePacket (22, 1024) \\<and>\n                    p \\<noteq> SomePacket (1024, 22) \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (1024,\n  22)\\<turnstile> \\<langle>[Rule (Match Established)\n                             Accept], Undecided\\<rangle> \\<Rightarrow> ?t76\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = Established \\<and>\n                    (p = SomePacket (22, 1024) \\<or>\n                     p = SomePacket (1024, 22)) \\<or>\n                    m = New \\<and>\n                    p \\<noteq> SomePacket (22, 1024) \\<and>\n                    p \\<noteq> SomePacket (1024, 22) \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (1024,\n  22)\\<turnstile> \\<langle>[Rule (MatchAnd (Match IsSSH) (Match New))\n                             Accept], ?t76\\<rangle> \\<Rightarrow> ?t68\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],(\\<lambda>m p.\n                    m = Established \\<and>\n                    (p = SomePacket (22, 1024) \\<or>\n                     p = SomePacket (1024, 22)) \\<or>\n                    m = New \\<and>\n                    p \\<noteq> SomePacket (22, 1024) \\<and>\n                    p \\<noteq> SomePacket (1024, 22) \\<or>\n                    m = IsSSH \\<and>\n                    (\\<exists>dst_port.\n                        p =\n                        SomePacket\n                         (22,\n                          dst_port))),SomePacket\n (1024,\n  22)\\<turnstile> \\<langle>[Rule MatchAny\n                             Drop], ?t68\\<rangle> \\<Rightarrow> Decision\n                           FinalAllow", "apply(auto intro: iptables_bigstep.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>In contrast, without having previously established a state, answer packets are prohibited\\<close>"], ["", "text\\<open>If we continue with this state, answer packets are now allowed\\<close>"], ["", "lemma \"semantics_stateful ruleset stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n          []\n          [(SomePacket (1024, 22), FinalDeny), (SomePacket (22, 1024), FinalAllow), (SomePacket (1024, 22), FinalAllow)]\n          (State {SomePacket (1024, 22), SomePacket (22, 1024)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful ruleset stateful_matcher state_update' (State {})\n     (''INPUT'', Drop) []\n     [(SomePacket (1024, 22), FinalDeny),\n      (SomePacket (22, 1024), FinalAllow),\n      (SomePacket (1024, 22), FinalAllow)]\n     (State {SomePacket (1024, 22), SomePacket (22, 1024)})", "unfolding ruleset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop) []\n     [(SomePacket (1024, 22), FinalDeny),\n      (SomePacket (22, 1024), FinalAllow),\n      (SomePacket (1024, 22), FinalAllow)]\n     (State {SomePacket (1024, 22), SomePacket (22, 1024)})", "apply(rule semantics_stateful_intro_process_one)"], ["proof (prove)\ngoal (4 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop) [?p]\n     ?ps_processed_old ?\\<sigma>_old\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,?p\\<turnstile> \\<langle>[Rule MatchAny\n                   (Call ''INPUT''),\n                  Rule MatchAny\n                   Drop], Undecided\\<rangle> \\<Rightarrow> Decision ?X\n 3. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old ?X ?p\n 4. [(SomePacket (1024, 22), FinalDeny),\n     (SomePacket (22, 1024), FinalAllow),\n     (SomePacket (1024, 22), FinalAllow)] =\n    ?ps_processed_old @ [(?p, ?X)]", "apply(simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [SomePacket (1024, 22)]\n     [(SomePacket (1024, 22), FinalDeny),\n      (SomePacket (22, 1024), FinalAllow)]\n     ?\\<sigma>_old\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,SomePacket\n                                (1024,\n                                 22)\\<turnstile> \\<langle>[Rule MatchAny\n                      (Call ''INPUT''),\n                     Rule MatchAny\n                      Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                         FinalAllow\n 3. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old FinalAllow (SomePacket (1024, 22))", "apply(rule semantics_stateful_intro_process_one)"], ["proof (prove)\ngoal (6 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [?p10, SomePacket (1024, 22)] ?ps_processed_old10 ?\\<sigma>_old10\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old10,?p10\\<turnstile> \\<langle>[Rule MatchAny\n                       (Call ''INPUT''),\n                      Rule MatchAny\n                       Drop], Undecided\\<rangle> \\<Rightarrow> Decision ?X10\n 3. ?\\<sigma>_old = state_update' ?\\<sigma>_old10 ?X10 ?p10\n 4. [(SomePacket (1024, 22), FinalDeny),\n     (SomePacket (22, 1024), FinalAllow)] =\n    ?ps_processed_old10 @ [(?p10, ?X10)]\n 5. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old,SomePacket\n                                (1024,\n                                 22)\\<turnstile> \\<langle>[Rule MatchAny\n                      (Call ''INPUT''),\n                     Rule MatchAny\n                      Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                         FinalAllow\n 6. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update' ?\\<sigma>_old FinalAllow (SomePacket (1024, 22))", "apply(simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [SomePacket (22, 1024), SomePacket (1024, 22)]\n     [(SomePacket (1024, 22), FinalDeny)] ?\\<sigma>_old10\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old10,SomePacket\n                                  (22,\n                                   1024)\\<turnstile> \\<langle>[Rule MatchAny\n                          (Call ''INPUT''),\n                         Rule MatchAny\n                          Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                             FinalAllow\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update' ?\\<sigma>_old10 FinalAllow\n                   (SomePacket\n                     (22,\n                      1024))),SomePacket\n                               (1024,\n                                22)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 4. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update'\n     (state_update' ?\\<sigma>_old10 FinalAllow (SomePacket (22, 1024)))\n     FinalAllow (SomePacket (1024, 22))", "apply(rule semantics_stateful_intro_process_one)"], ["proof (prove)\ngoal (7 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [?p21, SomePacket (22, 1024), SomePacket (1024, 22)]\n     ?ps_processed_old21 ?\\<sigma>_old21\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old21,?p21\\<turnstile> \\<langle>[Rule MatchAny\n                       (Call ''INPUT''),\n                      Rule MatchAny\n                       Drop], Undecided\\<rangle> \\<Rightarrow> Decision ?X21\n 3. ?\\<sigma>_old10 = state_update' ?\\<sigma>_old21 ?X21 ?p21\n 4. [(SomePacket (1024, 22), FinalDeny)] =\n    ?ps_processed_old21 @ [(?p21, ?X21)]\n 5. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old10,SomePacket\n                                  (22,\n                                   1024)\\<turnstile> \\<langle>[Rule MatchAny\n                          (Call ''INPUT''),\n                         Rule MatchAny\n                          Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                             FinalAllow\n 6. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update' ?\\<sigma>_old10 FinalAllow\n                   (SomePacket\n                     (22,\n                      1024))),SomePacket\n                               (1024,\n                                22)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 7. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update'\n     (state_update' ?\\<sigma>_old10 FinalAllow (SomePacket (22, 1024)))\n     FinalAllow (SomePacket (1024, 22))", "apply(simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. semantics_stateful\n     [''INPUT'' \\<mapsto>\n      [Rule (Match Established) Accept,\n       Rule (MatchAnd (Match IsSSH) (Match New)) Accept]]\n     stateful_matcher state_update' (State {}) (''INPUT'', Drop)\n     [SomePacket (1024, 22), SomePacket (22, 1024), SomePacket (1024, 22)]\n     [] ?\\<sigma>_old21\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old21,SomePacket\n                                  (1024,\n                                   22)\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call ''INPUT''),\n                       Rule MatchAny\n                        Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                           FinalDeny\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update' ?\\<sigma>_old21 FinalDeny\n                   (SomePacket\n                     (1024,\n                      22))),SomePacket\n                             (22,\n                              1024)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 4. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update'\n                   (state_update' ?\\<sigma>_old21 FinalDeny\n                     (SomePacket (1024, 22)))\n                   FinalAllow\n                   (SomePacket\n                     (22,\n                      1024))),SomePacket\n                               (1024,\n                                22)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 5. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update'\n     (state_update'\n       (state_update' ?\\<sigma>_old21 FinalDeny (SomePacket (1024, 22)))\n       FinalAllow (SomePacket (22, 1024)))\n     FinalAllow (SomePacket (1024, 22))", "apply(rule semantics_stateful_intro_start)"], ["proof (prove)\ngoal (6 subgoals):\n 1. State {} = ?\\<sigma>_old21\n 2. [] = []\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 ?\\<sigma>_old21,SomePacket\n                                  (1024,\n                                   22)\\<turnstile> \\<langle>[Rule MatchAny\n                        (Call ''INPUT''),\n                       Rule MatchAny\n                        Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                           FinalDeny\n 4. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update' ?\\<sigma>_old21 FinalDeny\n                   (SomePacket\n                     (1024,\n                      22))),SomePacket\n                             (22,\n                              1024)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 5. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update'\n                   (state_update' ?\\<sigma>_old21 FinalDeny\n                     (SomePacket (1024, 22)))\n                   FinalAllow\n                   (SomePacket\n                     (22,\n                      1024))),SomePacket\n                               (1024,\n                                22)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 6. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update'\n     (state_update'\n       (state_update' ?\\<sigma>_old21 FinalDeny (SomePacket (1024, 22)))\n       FinalAllow (SomePacket (22, 1024)))\n     FinalAllow (SomePacket (1024, 22))", "apply(simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (State\n                   {}),SomePacket\n                        (1024,\n                         22)\\<turnstile> \\<langle>[Rule MatchAny\n              (Call ''INPUT''),\n             Rule MatchAny\n              Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalDeny\n 2. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update' (State {}) FinalDeny\n                   (SomePacket\n                     (1024,\n                      22))),SomePacket\n                             (22,\n                              1024)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 3. [''INPUT'' \\<mapsto>\n     [Rule (Match Established) Accept,\n      Rule (MatchAnd (Match IsSSH) (Match New))\n       Accept]],stateful_matcher\n                 (state_update'\n                   (state_update' (State {}) FinalDeny\n                     (SomePacket (1024, 22)))\n                   FinalAllow\n                   (SomePacket\n                     (22,\n                      1024))),SomePacket\n                               (1024,\n                                22)\\<turnstile> \\<langle>[Rule MatchAny\n                     (Call ''INPUT''),\n                    Rule MatchAny\n                     Drop], Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow\n 4. State {SomePacket (1024, 22), SomePacket (22, 1024)} =\n    state_update'\n     (state_update'\n       (state_update' (State {}) FinalDeny (SomePacket (1024, 22)))\n       FinalAllow (SomePacket (22, 1024)))\n     FinalAllow (SomePacket (1024, 22))", "apply(rule seq_cons, rule call_result, simp_all, rule seq_cons, auto intro: iptables_bigstep.intros)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Example: Conntrack with packet tagging\\<close>"], ["", "datatype packet_tag = TagNew | TagEstablished"], ["", "datatype packet_tagged = SomePacket_tagged \"nat \\<times> nat \\<times> packet_tag\" | OtherPacket_tagged packet_tag"], ["", "fun get_packet_tag :: \"packet_tagged \\<Rightarrow> packet_tag\" where\n    \"get_packet_tag (SomePacket_tagged (_,_, tag)) = tag\" |\n    \"get_packet_tag (OtherPacket_tagged tag) = tag\""], ["", "definition stateful_matcher_tagged :: \"(primitive_matches, packet_tagged) matcher\" where\n    \"stateful_matcher_tagged \\<equiv> \\<lambda>m p. m = Established \\<and> (get_packet_tag p = TagEstablished) \\<or>\n                                           m = New \\<and> (get_packet_tag p = TagNew) \\<or>\n                                           m = IsSSH \\<and> (\\<exists>dst_port tag. p = SomePacket_tagged (22, dst_port, tag))\""], ["", "fun calculate_packet_tag :: \"conntrack_state \\<Rightarrow> packet \\<Rightarrow> packet_tag\" where\n    \"calculate_packet_tag (State state_table) p = (if p \\<in> state_table then TagEstablished else TagNew)\""], ["", "fun packet_tagger :: \"conntrack_state \\<Rightarrow> packet \\<Rightarrow> packet_tagged\" where\n    \"packet_tagger \\<sigma> (SomePacket (s,d)) = (SomePacket_tagged (s,d, calculate_packet_tag \\<sigma> (SomePacket (s,d))))\" |\n    \"packet_tagger \\<sigma> OtherPacket = (OtherPacket_tagged (calculate_packet_tag \\<sigma> OtherPacket))\""], ["", "text\\<open>If a packet is accepted, the state for its bi-directional connection is saved in the state table.\\<close>"], ["", "fun state_update_tagged :: \"conntrack_state \\<Rightarrow> final_decision \\<Rightarrow> packet \\<Rightarrow> conntrack_state\" where\n    \"state_update_tagged (State state_table) FinalAllow p = State (state_table \\<union> {p, reverse_direction p})\" |\n    \"state_update_tagged (State state_table) FinalDeny p = State state_table\""], ["", "text\\<open>Both semantics are equal\\<close>"], ["", "lemma \"semantics_stateful rs stateful_matcher state_update' \\<sigma>\\<^sub>0 start ps ps_processed \\<sigma>' =\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged packet_tagger state_update' \\<sigma>\\<^sub>0 start ps ps_processed \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics_stateful rs stateful_matcher state_update' \\<sigma>\\<^sub>0\n     start ps ps_processed \\<sigma>' =\n    semantics_stateful_packet_tagging rs stateful_matcher_tagged\n     packet_tagger state_update' \\<sigma>\\<^sub>0 start ps ps_processed\n     \\<sigma>'", "apply(rule semantics_stateful_vs_tagged)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m \\<sigma> p.\n       stateful_matcher \\<sigma> m p =\n       stateful_matcher_tagged m (packet_tagger \\<sigma> p)", "apply(intro allI, rename_tac m \\<sigma> p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m \\<sigma> p.\n       stateful_matcher \\<sigma> m p =\n       stateful_matcher_tagged m (packet_tagger \\<sigma> p)", "apply(case_tac \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m \\<sigma> p x.\n       \\<sigma> = State x \\<Longrightarrow>\n       stateful_matcher \\<sigma> m p =\n       stateful_matcher_tagged m (packet_tagger \\<sigma> p)", "apply(case_tac p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m \\<sigma> p x x1.\n       \\<lbrakk>\\<sigma> = State x; p = SomePacket x1\\<rbrakk>\n       \\<Longrightarrow> stateful_matcher \\<sigma> m p =\n                         stateful_matcher_tagged m\n                          (packet_tagger \\<sigma> p)\n 2. \\<And>m \\<sigma> p x.\n       \\<lbrakk>\\<sigma> = State x; p = OtherPacket\\<rbrakk>\n       \\<Longrightarrow> stateful_matcher \\<sigma> m p =\n                         stateful_matcher_tagged m\n                          (packet_tagger \\<sigma> p)", "apply(simp_all add: stateful_matcher_tagged_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m \\<sigma> p x x1.\n       \\<lbrakk>\\<sigma> = State x; p = SomePacket x1\\<rbrakk>\n       \\<Longrightarrow> (m = Established \\<and> SomePacket x1 \\<in> x \\<or>\n                          m = New \\<and> SomePacket x1 \\<notin> x \\<or>\n                          m = IsSSH \\<and>\n                          (\\<exists>dst_port. x1 = (22, dst_port))) =\n                         (m = Established \\<and>\n                          get_packet_tag\n                           (packet_tagger (State x) (SomePacket x1)) =\n                          TagEstablished \\<or>\n                          m = New \\<and>\n                          get_packet_tag\n                           (packet_tagger (State x) (SomePacket x1)) =\n                          TagNew \\<or>\n                          m = IsSSH \\<and>\n                          (\\<exists>dst_port tag.\n                              packet_tagger (State x) (SomePacket x1) =\n                              SomePacket_tagged (22, dst_port, tag)))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}