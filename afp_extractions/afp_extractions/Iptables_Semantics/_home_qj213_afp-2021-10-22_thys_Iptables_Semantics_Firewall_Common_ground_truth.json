{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Firewall_Common.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma rules_singleton_rev_E:\n  \"[Rule m a] = rs\\<^sub>1 @ rs\\<^sub>2 \\<Longrightarrow>\n   (rs\\<^sub>1 = [Rule m a] \\<Longrightarrow> rs\\<^sub>2 = [] \\<Longrightarrow> P m a) \\<Longrightarrow>\n   (rs\\<^sub>1 = [] \\<Longrightarrow> rs\\<^sub>2 = [Rule m a] \\<Longrightarrow> P m a) \\<Longrightarrow> P m a\"", "lemma rm_LogEmpty_filter: \"rm_LogEmpty rs = filter (\\<lambda>r. get_action r \\<noteq> Log \\<and> get_action r \\<noteq> Empty) rs\"", "lemma rm_LogEmpty_seq: \"rm_LogEmpty (rs1@rs2) = rm_LogEmpty rs1 @ rm_LogEmpty rs2\"", "lemma \"MatchNot (opt_MatchAny_match_expr_once (MatchAnd MatchAny (MatchNot MatchAny))) = MatchNot (MatchNot MatchAny)\"", "lemma \"m = (MatchAnd (MatchAnd MatchAny MatchAny) (MatchAnd MatchAny MatchAny)) \\<Longrightarrow> \n  (opt_MatchAny_match_expr_once^^2) m \\<noteq> opt_MatchAny_match_expr_once m\"", "lemma simple_ruleset_tail: \"simple_ruleset (r#rs) \\<Longrightarrow> simple_ruleset rs\"", "lemma simple_ruleset_append: \"simple_ruleset (rs\\<^sub>1 @ rs\\<^sub>2) \\<longleftrightarrow> simple_ruleset rs\\<^sub>1 \\<and> simple_ruleset rs\\<^sub>2\"", "lemma matachAny_matchNone: \"\\<not> has_primitive m \\<Longrightarrow> matcheq_matchAny m \\<longleftrightarrow> \\<not> matcheq_matchNone m\"", "lemma matcheq_matchNone_no_primitive: \"\\<not> has_primitive m \\<Longrightarrow> matcheq_matchNone (MatchNot m) \\<longleftrightarrow> \\<not> matcheq_matchNone m\"", "lemma optimize_matches_option_simple_ruleset: \"simple_ruleset rs \\<Longrightarrow> simple_ruleset (optimize_matches_option f rs)\"", "lemma optimize_matches_option_preserves:\n  \"(\\<And> r m. r \\<in> set rs \\<Longrightarrow> f (get_match r) = Some m \\<Longrightarrow> P m) \\<Longrightarrow>\n    \\<forall> r \\<in> set (optimize_matches_option f rs). P (get_match r)\"", "lemma optimize_matches_option_append: \"optimize_matches_option f (rs1@rs2) = optimize_matches_option f rs1 @ optimize_matches_option f rs2\"", "lemma optimize_matches_append: \"optimize_matches f (rs1@rs2) = optimize_matches f rs1 @ optimize_matches f rs2\"", "lemma optimize_matches_fst: \"optimize_matches f (r#rs) = optimize_matches f [r]@optimize_matches f rs\"", "lemma optimize_matches_preserves: \"(\\<And> r. r \\<in> set rs \\<Longrightarrow> P (f (get_match r))) \\<Longrightarrow>\n    \\<forall> r \\<in> set (optimize_matches f rs). P (get_match r)\"", "lemma optimize_matches_simple_ruleset: \"simple_ruleset rs \\<Longrightarrow> simple_ruleset (optimize_matches f rs)\"", "lemma optimize_matches_a_simple_ruleset: \"simple_ruleset rs \\<Longrightarrow> simple_ruleset (optimize_matches_a f rs)\"", "lemma optimize_matches_a_simple_ruleset_eq:\n  \"simple_ruleset rs \\<Longrightarrow> (\\<And> m a. a = Accept \\<or> a = Drop \\<Longrightarrow> f1 a m = f2 a m) \\<Longrightarrow> optimize_matches_a f1 rs = optimize_matches_a f2 rs\"", "lemma optimize_matches_a_preserves: \"(\\<And> r. r \\<in> set rs \\<Longrightarrow> P (f (get_action r) (get_match r)))\n    \\<Longrightarrow> \\<forall> r \\<in> set (optimize_matches_a f rs). P (get_match r)\""], "translations": [["", "lemma rules_singleton_rev_E:\n  \"[Rule m a] = rs\\<^sub>1 @ rs\\<^sub>2 \\<Longrightarrow>\n   (rs\\<^sub>1 = [Rule m a] \\<Longrightarrow> rs\\<^sub>2 = [] \\<Longrightarrow> P m a) \\<Longrightarrow>\n   (rs\\<^sub>1 = [] \\<Longrightarrow> rs\\<^sub>2 = [Rule m a] \\<Longrightarrow> P m a) \\<Longrightarrow> P m a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[Rule m a] = rs\\<^sub>1 @ rs\\<^sub>2;\n     \\<lbrakk>rs\\<^sub>1 = [Rule m a]; rs\\<^sub>2 = []\\<rbrakk>\n     \\<Longrightarrow> P m a;\n     \\<lbrakk>rs\\<^sub>1 = []; rs\\<^sub>2 = [Rule m a]\\<rbrakk>\n     \\<Longrightarrow> P m a\\<rbrakk>\n    \\<Longrightarrow> P m a", "by (cases rs\\<^sub>1) auto"], ["", "section\\<open>Basic Algorithms\\<close>"], ["", "text\\<open>These algorithms should be valid for all firewall semantics.\n     The corresponding proofs follow once the semantics are defined.\\<close>"], ["", "text\\<open>The actions Log and Empty do not modify the packet processing in any way. They can be removed.\\<close>"], ["", "fun rm_LogEmpty :: \"'a rule list \\<Rightarrow> 'a rule list\" where\n  \"rm_LogEmpty [] = []\" |\n  \"rm_LogEmpty ((Rule _ Empty)#rs) = rm_LogEmpty rs\" |\n  \"rm_LogEmpty ((Rule _ Log)#rs) = rm_LogEmpty rs\" |\n  \"rm_LogEmpty (r#rs) = r # rm_LogEmpty rs\""], ["", "lemma rm_LogEmpty_filter: \"rm_LogEmpty rs = filter (\\<lambda>r. get_action r \\<noteq> Log \\<and> get_action r \\<noteq> Empty) rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rm_LogEmpty rs =\n    filter\n     (\\<lambda>r.\n         get_action r \\<noteq> Log \\<and> get_action r \\<noteq> Empty)\n     rs", "by(induction rs rule: rm_LogEmpty.induct) (simp_all)"], ["", "lemma rm_LogEmpty_seq: \"rm_LogEmpty (rs1@rs2) = rm_LogEmpty rs1 @ rm_LogEmpty rs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rm_LogEmpty (rs1 @ rs2) = rm_LogEmpty rs1 @ rm_LogEmpty rs2", "by(simp add: rm_LogEmpty_filter)"], ["", "text\\<open>Optimize away MatchAny matches\\<close>"], ["", "fun opt_MatchAny_match_expr_once :: \"'a match_expr \\<Rightarrow> 'a match_expr\" where\n  \"opt_MatchAny_match_expr_once MatchAny = MatchAny\" |\n  \"opt_MatchAny_match_expr_once (Match a) = (Match a)\" |\n  \"opt_MatchAny_match_expr_once (MatchNot (MatchNot m)) = (opt_MatchAny_match_expr_once m)\" |\n  \"opt_MatchAny_match_expr_once (MatchNot m) = MatchNot (opt_MatchAny_match_expr_once m)\" |\n  \"opt_MatchAny_match_expr_once (MatchAnd MatchAny MatchAny) = MatchAny\" |\n  \"opt_MatchAny_match_expr_once (MatchAnd MatchAny m) = (opt_MatchAny_match_expr_once m)\" |\n  (*note: remove recursive call to opt_MatchAny_match_expr_once to make it probably faster*)\n  \"opt_MatchAny_match_expr_once (MatchAnd m MatchAny) = (opt_MatchAny_match_expr_once m)\" |\n  \"opt_MatchAny_match_expr_once (MatchAnd _ (MatchNot MatchAny)) = (MatchNot MatchAny)\" |\n  \"opt_MatchAny_match_expr_once (MatchAnd (MatchNot MatchAny) _) = (MatchNot MatchAny)\" |\n  \"opt_MatchAny_match_expr_once (MatchAnd m1 m2) = MatchAnd (opt_MatchAny_match_expr_once m1) (opt_MatchAny_match_expr_once m2)\""], ["", "(* without recursive call: need to apply multiple times until it stabelizes *)"], ["", "text\\<open>It is still a good idea to apply @{const opt_MatchAny_match_expr_once} multiple times. Example:\\<close>"], ["", "lemma \"MatchNot (opt_MatchAny_match_expr_once (MatchAnd MatchAny (MatchNot MatchAny))) = MatchNot (MatchNot MatchAny)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MatchNot\n     (opt_MatchAny_match_expr_once\n       (MatchAnd MatchAny (MatchNot MatchAny))) =\n    MatchNot (MatchNot MatchAny)", "by simp"], ["", "lemma \"m = (MatchAnd (MatchAnd MatchAny MatchAny) (MatchAnd MatchAny MatchAny)) \\<Longrightarrow> \n  (opt_MatchAny_match_expr_once^^2) m \\<noteq> opt_MatchAny_match_expr_once m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m =\n    MatchAnd (MatchAnd MatchAny MatchAny)\n     (MatchAnd MatchAny MatchAny) \\<Longrightarrow>\n    (opt_MatchAny_match_expr_once ^^ 2) m \\<noteq>\n    opt_MatchAny_match_expr_once m", "by(simp add: funpow_def)"], ["", "definition opt_MatchAny_match_expr :: \"'a match_expr \\<Rightarrow> 'a match_expr\" where\n  \"opt_MatchAny_match_expr m \\<equiv> repeat_stabilize 2 opt_MatchAny_match_expr_once m\""], ["", "text\\<open>Rewrite @{const Reject} actions to @{const Drop} actions.\n      If we just care about the filtering decision (@{const FinalAllow} or @{const FinalDeny}), they should be equal.\\<close>"], ["", "fun rw_Reject :: \"'a rule list \\<Rightarrow> 'a rule list\" where\n  \"rw_Reject [] = []\" |\n  \"rw_Reject ((Rule m Reject)#rs) = (Rule m Drop)#rw_Reject rs\" |\n  \"rw_Reject (r#rs) = r # rw_Reject rs\""], ["", "text\\<open>We call a ruleset simple iff the only actions are @{const Accept} and @{const Drop}\\<close>"], ["", "definition simple_ruleset :: \"'a rule list \\<Rightarrow> bool\" where\n    \"simple_ruleset rs \\<equiv> \\<forall>r \\<in> set rs. get_action r = Accept \\<or> get_action r = Drop\""], ["", "lemma simple_ruleset_tail: \"simple_ruleset (r#rs) \\<Longrightarrow> simple_ruleset rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (r # rs) \\<Longrightarrow> simple_ruleset rs", "by (simp add: simple_ruleset_def)"], ["", "lemma simple_ruleset_append: \"simple_ruleset (rs\\<^sub>1 @ rs\\<^sub>2) \\<longleftrightarrow> simple_ruleset rs\\<^sub>1 \\<and> simple_ruleset rs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs\\<^sub>1 @ rs\\<^sub>2) =\n    (simple_ruleset rs\\<^sub>1 \\<and> simple_ruleset rs\\<^sub>2)", "by(simp add: simple_ruleset_def, blast)"], ["", "text\\<open>Structural properties about match expressions\\<close>"], ["", "fun has_primitive :: \"'a match_expr \\<Rightarrow> bool\" where\n    \"has_primitive MatchAny = False\" |\n    \"has_primitive (Match a) = True\" |\n    \"has_primitive (MatchNot m) = has_primitive m\" |\n    \"has_primitive (MatchAnd m1 m2) = (has_primitive m1 \\<or> has_primitive m2)\""], ["", "text\\<open>Is a match expression equal to the @{const MatchAny} expression?\n        Only applicable if no primitives are in the expression.\\<close>"], ["", "fun matcheq_matchAny :: \"'a match_expr \\<Rightarrow> bool\" where\n    \"matcheq_matchAny MatchAny \\<longleftrightarrow> True\" |\n    \"matcheq_matchAny (MatchNot m) \\<longleftrightarrow> \\<not> (matcheq_matchAny m)\" |\n    \"matcheq_matchAny (MatchAnd m1 m2) \\<longleftrightarrow> matcheq_matchAny m1 \\<and> matcheq_matchAny m2\" |\n    \"matcheq_matchAny (Match _) = undefined\""], ["", "fun matcheq_matchNone :: \"'a match_expr \\<Rightarrow> bool\" where\n    \"matcheq_matchNone MatchAny = False\" |\n    \"matcheq_matchNone (Match _) = False\" |\n    \"matcheq_matchNone (MatchNot MatchAny) = True\" |\n    \"matcheq_matchNone (MatchNot (Match _)) = False\" |\n    \"matcheq_matchNone (MatchNot (MatchNot m)) = matcheq_matchNone m\" |\n    \"matcheq_matchNone (MatchNot (MatchAnd m1 m2)) \\<longleftrightarrow> matcheq_matchNone (MatchNot m1) \\<and> matcheq_matchNone (MatchNot m2)\" |\n    \"matcheq_matchNone (MatchAnd m1 m2) \\<longleftrightarrow>  matcheq_matchNone m1 \\<or> matcheq_matchNone m2\""], ["", "lemma matachAny_matchNone: \"\\<not> has_primitive m \\<Longrightarrow> matcheq_matchAny m \\<longleftrightarrow> \\<not> matcheq_matchNone m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_primitive m \\<Longrightarrow>\n    matcheq_matchAny m = (\\<not> matcheq_matchNone m)", "by(induction m rule: matcheq_matchNone.induct)(simp_all)"], ["", "lemma matcheq_matchNone_no_primitive: \"\\<not> has_primitive m \\<Longrightarrow> matcheq_matchNone (MatchNot m) \\<longleftrightarrow> \\<not> matcheq_matchNone m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_primitive m \\<Longrightarrow>\n    matcheq_matchNone (MatchNot m) = (\\<not> matcheq_matchNone m)", "by(induction m rule: matcheq_matchNone.induct) (simp_all)"], ["", "text\\<open>optimizing match expressions\\<close>"], ["", "fun optimize_matches_option :: \"('a match_expr \\<Rightarrow> 'a match_expr option) \\<Rightarrow> 'a rule list \\<Rightarrow> 'a rule list\" where\n  \"optimize_matches_option _ [] = []\" |\n  \"optimize_matches_option f (Rule m a#rs) = (case f m of None \\<Rightarrow> optimize_matches_option f rs | Some m \\<Rightarrow> (Rule m a)#optimize_matches_option f rs)\""], ["", "lemma optimize_matches_option_simple_ruleset: \"simple_ruleset rs \\<Longrightarrow> simple_ruleset (optimize_matches_option f rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset rs \\<Longrightarrow>\n    simple_ruleset (optimize_matches_option f rs)", "proof(induction rs rule:optimize_matches_option.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       simple_ruleset [] \\<Longrightarrow>\n       simple_ruleset (optimize_matches_option uu_ [])\n 2. \\<And>f m a rs.\n       \\<lbrakk>\\<lbrakk>f m = None; simple_ruleset rs\\<rbrakk>\n                \\<Longrightarrow> simple_ruleset\n                                   (optimize_matches_option f rs);\n        \\<And>x2.\n           \\<lbrakk>f m = Some x2; simple_ruleset rs\\<rbrakk>\n           \\<Longrightarrow> simple_ruleset (optimize_matches_option f rs);\n        simple_ruleset (Rule m a # rs)\\<rbrakk>\n       \\<Longrightarrow> simple_ruleset\n                          (optimize_matches_option f (Rule m a # rs))", "qed(simp_all add: simple_ruleset_def split: option.split)"], ["", "lemma optimize_matches_option_preserves:\n  \"(\\<And> r m. r \\<in> set rs \\<Longrightarrow> f (get_match r) = Some m \\<Longrightarrow> P m) \\<Longrightarrow>\n    \\<forall> r \\<in> set (optimize_matches_option f rs). P (get_match r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r m.\n        \\<lbrakk>r \\<in> set rs; f (get_match r) = Some m\\<rbrakk>\n        \\<Longrightarrow> P m) \\<Longrightarrow>\n    \\<forall>r\\<in>set (optimize_matches_option f rs). P (get_match r)", "apply(induction rs rule: optimize_matches_option.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       (\\<And>r m.\n           \\<lbrakk>r \\<in> set []; uu_ (get_match r) = Some m\\<rbrakk>\n           \\<Longrightarrow> P m) \\<Longrightarrow>\n       \\<forall>r\\<in>set (optimize_matches_option uu_ []). P (get_match r)\n 2. \\<And>f m a rs.\n       \\<lbrakk>\\<lbrakk>f m = None;\n                 \\<And>r m.\n                    \\<lbrakk>r \\<in> set rs;\n                     f (get_match r) = Some m\\<rbrakk>\n                    \\<Longrightarrow> P m\\<rbrakk>\n                \\<Longrightarrow> \\<forall>r\n     \\<in>set (optimize_matches_option f rs).\n                                     P (get_match r);\n        \\<And>x2.\n           \\<lbrakk>f m = Some x2;\n            \\<And>r m.\n               \\<lbrakk>r \\<in> set rs; f (get_match r) = Some m\\<rbrakk>\n               \\<Longrightarrow> P m\\<rbrakk>\n           \\<Longrightarrow> \\<forall>r\n\\<in>set (optimize_matches_option f rs).\n                                P (get_match r);\n        \\<And>r ma.\n           \\<lbrakk>r \\<in> set (Rule m a # rs);\n            f (get_match r) = Some ma\\<rbrakk>\n           \\<Longrightarrow> P ma\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r\\<in>set\n   (optimize_matches_option f (Rule m a # rs)).\n                            P (get_match r)", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f m a rs.\n       \\<lbrakk>\\<lbrakk>f m = None;\n                 \\<And>r m.\n                    \\<lbrakk>r \\<in> set rs;\n                     f (get_match r) = Some m\\<rbrakk>\n                    \\<Longrightarrow> P m\\<rbrakk>\n                \\<Longrightarrow> \\<forall>r\n     \\<in>set (optimize_matches_option f rs).\n                                     P (get_match r);\n        \\<And>x2.\n           \\<lbrakk>f m = Some x2;\n            \\<And>r m.\n               \\<lbrakk>r \\<in> set rs; f (get_match r) = Some m\\<rbrakk>\n               \\<Longrightarrow> P m\\<rbrakk>\n           \\<Longrightarrow> \\<forall>r\n\\<in>set (optimize_matches_option f rs).\n                                P (get_match r);\n        \\<And>r ma.\n           \\<lbrakk>r \\<in> set (Rule m a # rs);\n            f (get_match r) = Some ma\\<rbrakk>\n           \\<Longrightarrow> P ma\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r\\<in>set\n   (optimize_matches_option f (Rule m a # rs)).\n                            P (get_match r)", "apply(simp split: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f m a rs.\n       \\<lbrakk>\\<lbrakk>f m = None;\n                 \\<And>r m.\n                    \\<lbrakk>r \\<in> set rs;\n                     f (get_match r) = Some m\\<rbrakk>\n                    \\<Longrightarrow> P m\\<rbrakk>\n                \\<Longrightarrow> \\<forall>r\n     \\<in>set (optimize_matches_option f rs).\n                                     P (get_match r);\n        \\<And>x2.\n           \\<lbrakk>f m = Some x2;\n            \\<And>r m.\n               \\<lbrakk>r \\<in> set rs; f (get_match r) = Some m\\<rbrakk>\n               \\<Longrightarrow> P m\\<rbrakk>\n           \\<Longrightarrow> \\<forall>r\n\\<in>set (optimize_matches_option f rs).\n                                P (get_match r);\n        \\<And>r ma.\n           \\<lbrakk>r = Rule m a \\<or> r \\<in> set rs;\n            f (get_match r) = Some ma\\<rbrakk>\n           \\<Longrightarrow> P ma\\<rbrakk>\n       \\<Longrightarrow> (f m = None \\<longrightarrow>\n                          (\\<forall>r\\<in>set\n     (optimize_matches_option f rs).\n                              P (get_match r))) \\<and>\n                         (\\<forall>x2.\n                             f m = Some x2 \\<longrightarrow>\n                             P x2 \\<and>\n                             (\\<forall>r\n \\<in>set (optimize_matches_option f rs).\n                                 P (get_match r)))", "by fastforce"], ["", "(*\nlemma optimize_matches_option_preserves':\n  \"\\<forall> m \\<in> set rs. P (get_match m) \\<Longrightarrow> \\<forall>m. P m \\<longrightarrow> (\\<forall>m'. f m = Some m' \\<longrightarrow> P m') \\<Longrightarrow> \\<forall>m \\<in> set (optimize_matches_option f rs). P (get_match m)\"\n  using optimize_matches_option_preserves[simplified] by metis\n*)"], ["", "lemma optimize_matches_option_append: \"optimize_matches_option f (rs1@rs2) = optimize_matches_option f rs1 @ optimize_matches_option f rs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. optimize_matches_option f (rs1 @ rs2) =\n    optimize_matches_option f rs1 @ optimize_matches_option f rs2", "proof(induction rs1 rule: optimize_matches_option.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       optimize_matches_option uu_ ([] @ rs2) =\n       optimize_matches_option uu_ [] @ optimize_matches_option uu_ rs2\n 2. \\<And>f m a rs.\n       \\<lbrakk>f m = None \\<Longrightarrow>\n                optimize_matches_option f (rs @ rs2) =\n                optimize_matches_option f rs @\n                optimize_matches_option f rs2;\n        \\<And>x2.\n           f m = Some x2 \\<Longrightarrow>\n           optimize_matches_option f (rs @ rs2) =\n           optimize_matches_option f rs @\n           optimize_matches_option f rs2\\<rbrakk>\n       \\<Longrightarrow> optimize_matches_option f ((Rule m a # rs) @ rs2) =\n                         optimize_matches_option f (Rule m a # rs) @\n                         optimize_matches_option f rs2", "qed(simp_all split: option.split)"], ["", "definition optimize_matches :: \"('a match_expr \\<Rightarrow> 'a match_expr) \\<Rightarrow> 'a rule list \\<Rightarrow> 'a rule list\" where\n  \"optimize_matches f rs =  optimize_matches_option (\\<lambda>m. (if matcheq_matchNone (f m) then None else Some (f m))) rs\""], ["", "lemma optimize_matches_append: \"optimize_matches f (rs1@rs2) = optimize_matches f rs1 @ optimize_matches f rs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. optimize_matches f (rs1 @ rs2) =\n    optimize_matches f rs1 @ optimize_matches f rs2", "by(simp add: optimize_matches_def optimize_matches_option_append)"], ["", "(*Warning: simplifier loops with this lemma*)"], ["", "lemma optimize_matches_fst: \"optimize_matches f (r#rs) = optimize_matches f [r]@optimize_matches f rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. optimize_matches f (r # rs) =\n    optimize_matches f [r] @ optimize_matches f rs", "by(cases r)(simp add: optimize_matches_def)"], ["", "lemma optimize_matches_preserves: \"(\\<And> r. r \\<in> set rs \\<Longrightarrow> P (f (get_match r))) \\<Longrightarrow>\n    \\<forall> r \\<in> set (optimize_matches f rs). P (get_match r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<in> set rs \\<Longrightarrow>\n        P (f (get_match r))) \\<Longrightarrow>\n    \\<forall>r\\<in>set (optimize_matches f rs). P (get_match r)", "unfolding optimize_matches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<in> set rs \\<Longrightarrow>\n        P (f (get_match r))) \\<Longrightarrow>\n    \\<forall>r\\<in>set (optimize_matches_option\n                         (\\<lambda>m.\n                             if matcheq_matchNone (f m) then None\n                             else Some (f m))\n                         rs).\n       P (get_match r)", "apply(rule optimize_matches_option_preserves)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r m.\n       \\<lbrakk>\\<And>r.\n                   r \\<in> set rs \\<Longrightarrow> P (f (get_match r));\n        r \\<in> set rs;\n        (if matcheq_matchNone (f (get_match r)) then None\n         else Some (f (get_match r))) =\n        Some m\\<rbrakk>\n       \\<Longrightarrow> P m", "by(auto split: if_split_asm)"], ["", "lemma optimize_matches_simple_ruleset: \"simple_ruleset rs \\<Longrightarrow> simple_ruleset (optimize_matches f rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset rs \\<Longrightarrow>\n    simple_ruleset (optimize_matches f rs)", "by(simp add: optimize_matches_def optimize_matches_option_simple_ruleset)"], ["", "definition optimize_matches_a :: \"(action \\<Rightarrow> 'a match_expr \\<Rightarrow> 'a match_expr) \\<Rightarrow> 'a rule list \\<Rightarrow> 'a rule list\" where\n  \"optimize_matches_a f rs = map (\\<lambda>r. Rule (f (get_action r) (get_match r)) (get_action r)) rs\""], ["", "lemma optimize_matches_a_simple_ruleset: \"simple_ruleset rs \\<Longrightarrow> simple_ruleset (optimize_matches_a f rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset rs \\<Longrightarrow>\n    simple_ruleset (optimize_matches_a f rs)", "by(simp add: optimize_matches_a_def simple_ruleset_def)"], ["", "lemma optimize_matches_a_simple_ruleset_eq:\n  \"simple_ruleset rs \\<Longrightarrow> (\\<And> m a. a = Accept \\<or> a = Drop \\<Longrightarrow> f1 a m = f2 a m) \\<Longrightarrow> optimize_matches_a f1 rs = optimize_matches_a f2 rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_ruleset rs;\n     \\<And>m a.\n        a = Accept \\<or> a = Drop \\<Longrightarrow> f1 a m = f2 a m\\<rbrakk>\n    \\<Longrightarrow> optimize_matches_a f1 rs = optimize_matches_a f2 rs", "apply(induction rs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>simple_ruleset [];\n     \\<And>m a.\n        a = Accept \\<or> a = Drop \\<Longrightarrow> f1 a m = f2 a m\\<rbrakk>\n    \\<Longrightarrow> optimize_matches_a f1 [] = optimize_matches_a f2 []\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>simple_ruleset rs;\n                 \\<And>m a.\n                    a = Accept \\<or> a = Drop \\<Longrightarrow>\n                    f1 a m = f2 a m\\<rbrakk>\n                \\<Longrightarrow> optimize_matches_a f1 rs =\n                                  optimize_matches_a f2 rs;\n        simple_ruleset (a # rs);\n        \\<And>m a.\n           a = Accept \\<or> a = Drop \\<Longrightarrow>\n           f1 a m = f2 a m\\<rbrakk>\n       \\<Longrightarrow> optimize_matches_a f1 (a # rs) =\n                         optimize_matches_a f2 (a # rs)", "apply(simp add: optimize_matches_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>simple_ruleset rs;\n                 \\<And>m a.\n                    a = Accept \\<or> a = Drop \\<Longrightarrow>\n                    f1 a m = f2 a m\\<rbrakk>\n                \\<Longrightarrow> optimize_matches_a f1 rs =\n                                  optimize_matches_a f2 rs;\n        simple_ruleset (a # rs);\n        \\<And>m a.\n           a = Accept \\<or> a = Drop \\<Longrightarrow>\n           f1 a m = f2 a m\\<rbrakk>\n       \\<Longrightarrow> optimize_matches_a f1 (a # rs) =\n                         optimize_matches_a f2 (a # rs)", "apply(simp add: optimize_matches_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>simple_ruleset rs \\<Longrightarrow>\n                \\<forall>x\\<in>set rs.\n                   f1 (get_action x) (get_match x) =\n                   f2 (get_action x) (get_match x);\n        simple_ruleset (a # rs);\n        \\<And>m a.\n           a = Accept \\<or> a = Drop \\<Longrightarrow>\n           f1 a m = f2 a m\\<rbrakk>\n       \\<Longrightarrow> f1 (get_action a) (get_match a) =\n                         f2 (get_action a) (get_match a) \\<and>\n                         (\\<forall>x\\<in>set rs.\n                             f1 (get_action x) (get_match x) =\n                             f2 (get_action x) (get_match x))", "apply(simp add: simple_ruleset_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma optimize_matches_a_preserves: \"(\\<And> r. r \\<in> set rs \\<Longrightarrow> P (f (get_action r) (get_match r)))\n    \\<Longrightarrow> \\<forall> r \\<in> set (optimize_matches_a f rs). P (get_match r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<in> set rs \\<Longrightarrow>\n        P (f (get_action r) (get_match r))) \\<Longrightarrow>\n    \\<forall>r\\<in>set (optimize_matches_a f rs). P (get_match r)", "by(induction rs)(simp_all add: optimize_matches_a_def)"], ["", "end"]]}