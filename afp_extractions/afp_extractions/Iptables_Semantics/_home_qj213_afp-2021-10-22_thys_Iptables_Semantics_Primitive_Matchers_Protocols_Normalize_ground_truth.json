{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/Protocols_Normalize.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma compress_pos_protocols_Some: \"compress_pos_protocols ps = Some proto \\<Longrightarrow> \n          match_proto proto p_prot \\<longleftrightarrow> (\\<forall> p \\<in> set ps. match_proto p p_prot)\"", "lemma compress_pos_protocols_None: \"compress_pos_protocols ps = None \\<Longrightarrow> \n          \\<not> (\\<forall> proto \\<in> set ps. match_proto proto p_prot)\"", "lemma \"simple_proto_conjunct (Proto p1) (Proto p2) \\<noteq> None \\<Longrightarrow> \\<forall>pkt. match_proto (Proto p1) pkt \\<longleftrightarrow> match_proto (Proto p2) pkt\"", "lemma \"simple_proto_conjunct p1 (Proto p2) \\<noteq> None \\<Longrightarrow> \\<forall>pkt. match_proto (Proto p2) pkt \\<longrightarrow> match_proto p1 pkt\"", "lemma all_proto_hlp2: \"ProtoAny \\<in> a \\<or> (\\<forall>p \\<in> {0..max_word}. Proto p \\<in> a) \\<longleftrightarrow>\n                               ProtoAny \\<in> a \\<or> a = {p. p \\<noteq> ProtoAny}\"", "lemma set_word8_word_upto: \"{0..(max_word :: 8 word)} = set (word_upto 0 255)\"", "lemma \"(\\<forall>p \\<in> {0..max_word}. Proto p \\<in> set (getNeg ps)) \\<longleftrightarrow>\n         ((\\<forall>p \\<in> set (word_upto 0 255). Proto p \\<in> set (getNeg ps)))\"", "lemma compress_protocols_code[code]:\n    \"compress_protocols ps = (case (compress_pos_protocols (getPos ps))\n        of None \\<Rightarrow> None\n        |  Some proto \\<Rightarrow> if ProtoAny \\<in> set (getNeg ps) \\<or> (\\<forall>p \\<in> set (word_upto 0 255). Proto p \\<in> set (getNeg ps)) then\n                           None\n                         else if proto = ProtoAny then\n                           Some ([], getNeg ps)\n                         else if (\\<exists>p \\<in> set (getNeg ps). simple_proto_conjunct proto p \\<noteq> None) then\n                           None\n                         else\n                           Some ([proto], [])\n        )\"", "lemma \"compress_protocols ps = Some (ps_pos, ps_neg) \\<Longrightarrow>\n    \\<exists> p. ((\\<forall>m\\<in>set ps_pos. match_proto m p) \\<and> (\\<forall>m\\<in>set ps_neg. \\<not> match_proto m p))\"", "lemma (in primitive_matcher_generic) compress_normalize_protocols_step_Some:\n  assumes \"normalized_nnf_match m\" and \"compress_normalize_protocols_step m = Some m'\"\n    shows \"matches (\\<beta>, \\<alpha>) m' a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma (in primitive_matcher_generic) compress_normalize_protocols_step_None:\n  assumes \"normalized_nnf_match m\" and \"compress_normalize_protocols_step m = None\"\n    shows \"\\<not> matches (\\<beta>, \\<alpha>) m a p\"", "lemma compress_normalize_protocols_step_nnf:\n    \"normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n      normalized_nnf_match m'\"", "lemma compress_normalize_protocols_step_not_introduces_Prot:\n    \"\\<not> has_disc is_Prot m \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n     \\<not> has_disc is_Prot m'\"", "lemma compress_normalize_protocols_step_not_introduces_Prot_negated:\n    assumes notdisc: \"\\<not> has_disc_negated is_Prot False m\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_protocols_step m = Some m'\"\n     shows \"\\<not> has_disc_negated is_Prot False m'\"", "lemma compress_normalize_protocols_step_hasdisc:\n    \"\\<not> has_disc disc m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> \\<not> has_disc disc m'\"", "lemma compress_normalize_protocols_step_hasdisc_negated:\n    \"\\<not> has_disc_negated disc neg m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc neg m'\"", "lemma compress_normalize_protocols_step_preserves_normalized_n_primitive:\n    \"normalized_n_primitive (disc, sel) P m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> normalized_n_primitive (disc, sel) P m'\"", "lemma \"case compress_normalize_protocols_step \n    (MatchAnd (MatchAnd (MatchAnd (Match ((Prot (Proto TCP)):: 32 common_primitive)) (MatchNot (Match (Prot (Proto UDP))))) (Match (IIface (Iface ''eth1''))))\n              (Match (Prot (Proto TCP)))) of Some ps \\<Rightarrow> opt_MatchAny_match_expr ps\n  = MatchAnd (Match (Prot (Proto 6))) (Match (IIface (Iface ''eth1'')))\"", "lemma \"compress_normalize_protocols_step (import_protocols_from_ports \n    (MatchAnd (MatchAnd (Match (Prot (Proto TCP):: 32 common_primitive))\n      (Match (Src_Ports (L4Ports UDP [(22,22)])))) (Match (IIface (Iface ''eth1''))))) = None\"", "lemma import_protocols_from_ports_erule: \"normalized_nnf_match m \\<Longrightarrow> P m \\<Longrightarrow>\n    (\\<And>srcpts rst1 dstpts rst2.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<comment> \\<open>\\<open>P m \\<Longrightarrow>\\<close> erule consumes only first argument\\<close>\n       primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1) \\<Longrightarrow>\n       primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 = (dstpts, rst2) \\<Longrightarrow>\n       normalized_nnf_match rst1 \\<Longrightarrow>\n       normalized_nnf_match rst2 \\<Longrightarrow>\n       P (MatchAnd\n           (MatchAnd\n             (MatchAnd\n               (andfold_MatchExp\n                 (map (Match \\<circ> (Prot \\<circ> (case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))) (getPos srcpts)))\n               (andfold_MatchExp\n                 (map (Match \\<circ> (Prot \\<circ> (case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))) (getPos dstpts))))\n             (alist_and' (NegPos_map Src_Ports srcpts @ NegPos_map Dst_Ports dstpts)))\n           rst2)) \\<Longrightarrow>\n    P (import_protocols_from_ports m)\"", "lemma (in primitive_matcher_generic) import_protocols_from_ports:\n  assumes normalized: \"normalized_nnf_match m\"\n  shows \"matches (\\<beta>, \\<alpha>) (import_protocols_from_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma import_protocols_from_ports_nnf:\n    \"normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\"", "lemma import_protocols_from_ports_not_introduces_Prot_negated:\n    \"normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated is_Prot False m \\<Longrightarrow>\n      \\<not> has_disc_negated is_Prot False (import_protocols_from_ports m)\"", "lemma import_protocols_from_ports_hasdisc:\n    \"normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc disc m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow>\n     normalized_nnf_match (import_protocols_from_ports m) \\<and> \\<not> has_disc disc (import_protocols_from_ports m)\"", "lemma import_protocols_from_ports_hasdisc_negated:\n    \"\\<not> has_disc_negated disc False m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow>\n     normalized_nnf_match (import_protocols_from_ports m) \\<and>\n     \\<not> has_disc_negated disc False (import_protocols_from_ports m)\"", "lemma import_protocols_from_ports_preserves_normalized_n_primitive:\n    \"normalized_n_primitive (disc, sel) f m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow>\n     normalized_nnf_match (import_protocols_from_ports m) \\<and> normalized_n_primitive (disc, sel) f (import_protocols_from_ports m)\"", "lemma (in primitive_matcher_generic) compress_normalize_protocols_Some:\n  assumes \"normalized_nnf_match m\" and \"compress_normalize_protocols m = Some m'\"\n    shows \"matches (\\<beta>, \\<alpha>) m' a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\"", "lemma (in primitive_matcher_generic) compress_normalize_protocols_None:\n  assumes \"normalized_nnf_match m\" and \"compress_normalize_protocols m = None\"\n    shows \"\\<not> matches (\\<beta>, \\<alpha>) m a p\"", "lemma compress_normalize_protocols_nnf:\n    \"normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols m = Some m' \\<Longrightarrow>\n      normalized_nnf_match m'\"", "lemma compress_normalize_protocols_not_introduces_Prot_negated:\n    assumes notdisc: \"\\<not> has_disc_negated is_Prot False m\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_protocols m = Some m'\"\n     shows \"\\<not> has_disc_negated is_Prot False m'\"", "lemma compress_normalize_protocols_hasdisc:\n    \"\\<not> has_disc disc m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> \\<not> has_disc disc m'\"", "lemma compress_normalize_protocols_hasdisc_negated:\n    \"\\<not> has_disc_negated disc False m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow>\n     normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc False m'\"", "lemma compress_normalize_protocols_preserves_normalized_n_primitive:\n    \"normalized_n_primitive (disc, sel) P m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> normalized_n_primitive (disc, sel) P m'\"", "lemma \"case compress_normalize_protocols \n    (MatchAnd (MatchAnd (MatchAnd (Match ((Prot (Proto TCP)):: 32 common_primitive)) (MatchNot (Match (Prot (Proto UDP))))) (Match (IIface (Iface ''eth1''))))\n              (Match (Prot (Proto TCP)))) of Some ps \\<Rightarrow> opt_MatchAny_match_expr ps\n  =\n  MatchAnd (Match (Prot (Proto 6))) (Match (IIface (Iface ''eth1'')))\""], "translations": [["", "lemma compress_pos_protocols_Some: \"compress_pos_protocols ps = Some proto \\<Longrightarrow> \n          match_proto proto p_prot \\<longleftrightarrow> (\\<forall> p \\<in> set ps. match_proto p p_prot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_pos_protocols ps = Some proto \\<Longrightarrow>\n    match_proto proto p_prot = (\\<forall>p\\<in>set ps. match_proto p p_prot)", "proof(induction ps rule: compress_pos_protocols.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. compress_pos_protocols [] = Some proto \\<Longrightarrow>\n    match_proto proto p_prot = (\\<forall>p\\<in>set []. match_proto p p_prot)\n 2. \\<And>p.\n       compress_pos_protocols [p] = Some proto \\<Longrightarrow>\n       match_proto proto p_prot =\n       (\\<forall>p\\<in>set [p]. match_proto p p_prot)\n 3. \\<And>p1 p2 ps.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>simple_proto_conjunct p1 p2 = Some x2;\n                    compress_pos_protocols (x2 # ps) = Some proto\\<rbrakk>\n                   \\<Longrightarrow> match_proto proto p_prot =\n                                     (\\<forall>p\\<in>set (x2 # ps).\n   match_proto p p_prot);\n        compress_pos_protocols (p1 # p2 # ps) = Some proto\\<rbrakk>\n       \\<Longrightarrow> match_proto proto p_prot =\n                         (\\<forall>p\\<in>set (p1 # p2 # ps).\n                             match_proto p p_prot)", "case (3 p1 p2 pps)"], ["proof (state)\nthis:\n  \\<lbrakk>simple_proto_conjunct p1 p2 = Some ?x2.0;\n   compress_pos_protocols (?x2.0 # pps) = Some proto\\<rbrakk>\n  \\<Longrightarrow> match_proto proto p_prot =\n                    (\\<forall>p\\<in>set (?x2.0 # pps). match_proto p p_prot)\n  compress_pos_protocols (p1 # p2 # pps) = Some proto\n\ngoal (3 subgoals):\n 1. compress_pos_protocols [] = Some proto \\<Longrightarrow>\n    match_proto proto p_prot = (\\<forall>p\\<in>set []. match_proto p p_prot)\n 2. \\<And>p.\n       compress_pos_protocols [p] = Some proto \\<Longrightarrow>\n       match_proto proto p_prot =\n       (\\<forall>p\\<in>set [p]. match_proto p p_prot)\n 3. \\<And>p1 p2 ps.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>simple_proto_conjunct p1 p2 = Some x2;\n                    compress_pos_protocols (x2 # ps) = Some proto\\<rbrakk>\n                   \\<Longrightarrow> match_proto proto p_prot =\n                                     (\\<forall>p\\<in>set (x2 # ps).\n   match_proto p p_prot);\n        compress_pos_protocols (p1 # p2 # ps) = Some proto\\<rbrakk>\n       \\<Longrightarrow> match_proto proto p_prot =\n                         (\\<forall>p\\<in>set (p1 # p2 # ps).\n                             match_proto p p_prot)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>simple_proto_conjunct p1 p2 = Some ?x2.0;\n   compress_pos_protocols (?x2.0 # pps) = Some proto\\<rbrakk>\n  \\<Longrightarrow> match_proto proto p_prot =\n                    (\\<forall>p\\<in>set (?x2.0 # pps). match_proto p p_prot)\n  compress_pos_protocols (p1 # p2 # pps) = Some proto\n\ngoal (1 subgoal):\n 1. match_proto proto p_prot =\n    (\\<forall>p\\<in>set (p1 # p2 # pps). match_proto p p_prot)", "apply(cases \"simple_proto_conjunct p1 p2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                \\<lbrakk>simple_proto_conjunct p1 p2 = Some x2;\n                 compress_pos_protocols (x2 # pps) = Some proto\\<rbrakk>\n                \\<Longrightarrow> match_proto proto p_prot =\n                                  (\\<forall>p\\<in>set (x2 # pps).\nmatch_proto p p_prot);\n     compress_pos_protocols (p1 # p2 # pps) = Some proto;\n     simple_proto_conjunct p1 p2 = None\\<rbrakk>\n    \\<Longrightarrow> match_proto proto p_prot =\n                      (\\<forall>p\\<in>set (p1 # p2 # pps).\n                          match_proto p p_prot)\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>simple_proto_conjunct p1 p2 = Some x2;\n                    compress_pos_protocols (x2 # pps) = Some proto\\<rbrakk>\n                   \\<Longrightarrow> match_proto proto p_prot =\n                                     (\\<forall>p\\<in>set (x2 # pps).\n   match_proto p p_prot);\n        compress_pos_protocols (p1 # p2 # pps) = Some proto;\n        simple_proto_conjunct p1 p2 = Some a\\<rbrakk>\n       \\<Longrightarrow> match_proto proto p_prot =\n                         (\\<forall>p\\<in>set (p1 # p2 # pps).\n                             match_proto p p_prot)", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>simple_proto_conjunct p1 p2 = Some x2;\n                    compress_pos_protocols (x2 # pps) = Some proto\\<rbrakk>\n                   \\<Longrightarrow> match_proto proto p_prot =\n                                     (\\<forall>p\\<in>set (x2 # pps).\n   match_proto p p_prot);\n        compress_pos_protocols (p1 # p2 # pps) = Some proto;\n        simple_proto_conjunct p1 p2 = Some a\\<rbrakk>\n       \\<Longrightarrow> match_proto proto p_prot =\n                         (\\<forall>p\\<in>set (p1 # p2 # pps).\n                             match_proto p p_prot)", "using simple_proto_conjunct_Some"], ["proof (prove)\nusing this:\n  simple_proto_conjunct ?p1.0 ?p2.0 = Some ?proto \\<Longrightarrow>\n  match_proto ?proto ?pkt =\n  (match_proto ?p1.0 ?pkt \\<and> match_proto ?p2.0 ?pkt)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>simple_proto_conjunct p1 p2 = Some x2;\n                    compress_pos_protocols (x2 # pps) = Some proto\\<rbrakk>\n                   \\<Longrightarrow> match_proto proto p_prot =\n                                     (\\<forall>p\\<in>set (x2 # pps).\n   match_proto p p_prot);\n        compress_pos_protocols (p1 # p2 # pps) = Some proto;\n        simple_proto_conjunct p1 p2 = Some a\\<rbrakk>\n       \\<Longrightarrow> match_proto proto p_prot =\n                         (\\<forall>p\\<in>set (p1 # p2 # pps).\n                             match_proto p p_prot)", "by(simp)"], ["proof (state)\nthis:\n  match_proto proto p_prot =\n  (\\<forall>p\\<in>set (p1 # p2 # pps). match_proto p p_prot)\n\ngoal (2 subgoals):\n 1. compress_pos_protocols [] = Some proto \\<Longrightarrow>\n    match_proto proto p_prot = (\\<forall>p\\<in>set []. match_proto p p_prot)\n 2. \\<And>p.\n       compress_pos_protocols [p] = Some proto \\<Longrightarrow>\n       match_proto proto p_prot =\n       (\\<forall>p\\<in>set [p]. match_proto p p_prot)", "qed(simp)+"], ["", "lemma compress_pos_protocols_None: \"compress_pos_protocols ps = None \\<Longrightarrow> \n          \\<not> (\\<forall> proto \\<in> set ps. match_proto proto p_prot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_pos_protocols ps = None \\<Longrightarrow>\n    \\<not> (\\<forall>proto\\<in>set ps. match_proto proto p_prot)", "proof(induction ps rule: compress_pos_protocols.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. compress_pos_protocols [] = None \\<Longrightarrow>\n    \\<not> (\\<forall>proto\\<in>set []. match_proto proto p_prot)\n 2. \\<And>p.\n       compress_pos_protocols [p] = None \\<Longrightarrow>\n       \\<not> (\\<forall>proto\\<in>set [p]. match_proto proto p_prot)\n 3. \\<And>p1 p2 ps.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>simple_proto_conjunct p1 p2 = Some x2;\n                    compress_pos_protocols (x2 # ps) = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> (\\<forall>proto\n                \\<in>set (x2 # ps).\n          match_proto proto p_prot);\n        compress_pos_protocols (p1 # p2 # ps) = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> (\\<forall>proto\\<in>set (p1 # p2 # ps).\n                                    match_proto proto p_prot)", "case (3 i1 i2 iis)"], ["proof (state)\nthis:\n  \\<lbrakk>simple_proto_conjunct i1 i2 = Some ?x2.0;\n   compress_pos_protocols (?x2.0 # iis) = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> (\\<forall>proto\\<in>set (?x2.0 # iis).\n                               match_proto proto p_prot)\n  compress_pos_protocols (i1 # i2 # iis) = None\n\ngoal (3 subgoals):\n 1. compress_pos_protocols [] = None \\<Longrightarrow>\n    \\<not> (\\<forall>proto\\<in>set []. match_proto proto p_prot)\n 2. \\<And>p.\n       compress_pos_protocols [p] = None \\<Longrightarrow>\n       \\<not> (\\<forall>proto\\<in>set [p]. match_proto proto p_prot)\n 3. \\<And>p1 p2 ps.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>simple_proto_conjunct p1 p2 = Some x2;\n                    compress_pos_protocols (x2 # ps) = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> (\\<forall>proto\n                \\<in>set (x2 # ps).\n          match_proto proto p_prot);\n        compress_pos_protocols (p1 # p2 # ps) = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> (\\<forall>proto\\<in>set (p1 # p2 # ps).\n                                    match_proto proto p_prot)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>simple_proto_conjunct i1 i2 = Some ?x2.0;\n   compress_pos_protocols (?x2.0 # iis) = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> (\\<forall>proto\\<in>set (?x2.0 # iis).\n                               match_proto proto p_prot)\n  compress_pos_protocols (i1 # i2 # iis) = None\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>proto\\<in>set (i1 # i2 # iis).\n               match_proto proto p_prot)", "apply(cases \"simple_proto_conjunct i1 i2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                \\<lbrakk>simple_proto_conjunct i1 i2 = Some x2;\n                 compress_pos_protocols (x2 # iis) = None\\<rbrakk>\n                \\<Longrightarrow> \\<not> (\\<forall>proto\\<in>set (x2 # iis).\n       match_proto proto p_prot);\n     compress_pos_protocols (i1 # i2 # iis) = None;\n     simple_proto_conjunct i1 i2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<forall>proto\\<in>set (i1 # i2 # iis).\n                                 match_proto proto p_prot)\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>simple_proto_conjunct i1 i2 = Some x2;\n                    compress_pos_protocols (x2 # iis) = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> (\\<forall>proto\n                \\<in>set (x2 # iis).\n          match_proto proto p_prot);\n        compress_pos_protocols (i1 # i2 # iis) = None;\n        simple_proto_conjunct i1 i2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not> (\\<forall>proto\\<in>set (i1 # i2 # iis).\n                                    match_proto proto p_prot)", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. simple_proto_conjunct i1 i2 = None \\<Longrightarrow>\n    match_proto i2 p_prot \\<longrightarrow>\n    match_proto i1 p_prot \\<longrightarrow>\n    (\\<exists>proto\\<in>set iis. \\<not> match_proto proto p_prot)\n 2. \\<And>a.\n       \\<lbrakk>match_proto a p_prot \\<longrightarrow>\n                (\\<exists>proto\\<in>set iis.\n                    \\<not> match_proto proto p_prot);\n        compress_pos_protocols (a # iis) = None;\n        simple_proto_conjunct i1 i2 = Some a\\<rbrakk>\n       \\<Longrightarrow> match_proto i2 p_prot \\<longrightarrow>\n                         match_proto i1 p_prot \\<longrightarrow>\n                         (\\<exists>proto\\<in>set iis.\n                             \\<not> match_proto proto p_prot)", "using simple_proto_conjunct_None"], ["proof (prove)\nusing this:\n  simple_proto_conjunct ?p1.0 ?p2.0 = None \\<Longrightarrow>\n  \\<not> (match_proto ?p1.0 ?pkt \\<and> match_proto ?p2.0 ?pkt)\n\ngoal (2 subgoals):\n 1. simple_proto_conjunct i1 i2 = None \\<Longrightarrow>\n    match_proto i2 p_prot \\<longrightarrow>\n    match_proto i1 p_prot \\<longrightarrow>\n    (\\<exists>proto\\<in>set iis. \\<not> match_proto proto p_prot)\n 2. \\<And>a.\n       \\<lbrakk>match_proto a p_prot \\<longrightarrow>\n                (\\<exists>proto\\<in>set iis.\n                    \\<not> match_proto proto p_prot);\n        compress_pos_protocols (a # iis) = None;\n        simple_proto_conjunct i1 i2 = Some a\\<rbrakk>\n       \\<Longrightarrow> match_proto i2 p_prot \\<longrightarrow>\n                         match_proto i1 p_prot \\<longrightarrow>\n                         (\\<exists>proto\\<in>set iis.\n                             \\<not> match_proto proto p_prot)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>match_proto a p_prot \\<longrightarrow>\n                (\\<exists>proto\\<in>set iis.\n                    \\<not> match_proto proto p_prot);\n        compress_pos_protocols (a # iis) = None;\n        simple_proto_conjunct i1 i2 = Some a\\<rbrakk>\n       \\<Longrightarrow> match_proto i2 p_prot \\<longrightarrow>\n                         match_proto i1 p_prot \\<longrightarrow>\n                         (\\<exists>proto\\<in>set iis.\n                             \\<not> match_proto proto p_prot)", "using simple_proto_conjunct_Some"], ["proof (prove)\nusing this:\n  simple_proto_conjunct ?p1.0 ?p2.0 = Some ?proto \\<Longrightarrow>\n  match_proto ?proto ?pkt =\n  (match_proto ?p1.0 ?pkt \\<and> match_proto ?p2.0 ?pkt)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>match_proto a p_prot \\<longrightarrow>\n                (\\<exists>proto\\<in>set iis.\n                    \\<not> match_proto proto p_prot);\n        compress_pos_protocols (a # iis) = None;\n        simple_proto_conjunct i1 i2 = Some a\\<rbrakk>\n       \\<Longrightarrow> match_proto i2 p_prot \\<longrightarrow>\n                         match_proto i1 p_prot \\<longrightarrow>\n                         (\\<exists>proto\\<in>set iis.\n                             \\<not> match_proto proto p_prot)", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<forall>proto\\<in>set (i1 # i2 # iis). match_proto proto p_prot)\n\ngoal (2 subgoals):\n 1. compress_pos_protocols [] = None \\<Longrightarrow>\n    \\<not> (\\<forall>proto\\<in>set []. match_proto proto p_prot)\n 2. \\<And>p.\n       compress_pos_protocols [p] = None \\<Longrightarrow>\n       \\<not> (\\<forall>proto\\<in>set [p]. match_proto proto p_prot)", "qed(simp)+"], ["", "(*the intuition behind the compress_protocols*)"], ["", "lemma \"simple_proto_conjunct (Proto p1) (Proto p2) \\<noteq> None \\<Longrightarrow> \\<forall>pkt. match_proto (Proto p1) pkt \\<longleftrightarrow> match_proto (Proto p2) pkt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct (Proto p1) (Proto p2) \\<noteq>\n    None \\<Longrightarrow>\n    \\<forall>pkt. match_proto (Proto p1) pkt = match_proto (Proto p2) pkt", "apply(subgoal_tac \"p1 = p2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>simple_proto_conjunct (Proto p1) (Proto p2) \\<noteq> None;\n     p1 = p2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pkt.\n                         match_proto (Proto p1) pkt =\n                         match_proto (Proto p2) pkt\n 2. simple_proto_conjunct (Proto p1) (Proto p2) \\<noteq>\n    None \\<Longrightarrow>\n    p1 = p2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct (Proto p1) (Proto p2) \\<noteq>\n    None \\<Longrightarrow>\n    p1 = p2", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"simple_proto_conjunct p1 (Proto p2) \\<noteq> None \\<Longrightarrow> \\<forall>pkt. match_proto (Proto p2) pkt \\<longrightarrow> match_proto p1 pkt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct p1 (Proto p2) \\<noteq> None \\<Longrightarrow>\n    \\<forall>pkt.\n       match_proto (Proto p2) pkt \\<longrightarrow> match_proto p1 pkt", "apply(cases p1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>simple_proto_conjunct p1 (Proto p2) \\<noteq> None;\n     p1 = ProtoAny\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pkt.\n                         match_proto (Proto p2) pkt \\<longrightarrow>\n                         match_proto p1 pkt\n 2. \\<And>x2.\n       \\<lbrakk>simple_proto_conjunct p1 (Proto p2) \\<noteq> None;\n        p1 = Proto x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>pkt.\n                            match_proto (Proto p2) pkt \\<longrightarrow>\n                            match_proto p1 pkt", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>simple_proto_conjunct p1 (Proto p2) \\<noteq> None;\n        p1 = Proto x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>pkt.\n                            match_proto (Proto p2) pkt \\<longrightarrow>\n                            match_proto p1 pkt", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition compress_protocols :: \"protocol negation_type list \\<Rightarrow> (protocol list \\<times> protocol list) option\" where\n    \"compress_protocols ps \\<equiv> case (compress_pos_protocols (getPos ps))\n        of None \\<Rightarrow> None\n        |  Some proto \\<Rightarrow> if ProtoAny \\<in> set (getNeg ps) \\<or> (\\<forall>p \\<in> {0..max_word}. Proto p \\<in> set (getNeg ps)) then\n                           None\n                         else if proto = ProtoAny then\n                           Some ([], getNeg ps)\n                         else if (\\<exists>p \\<in> set (getNeg ps). simple_proto_conjunct proto p \\<noteq> None) then\n                           None\n                         else\n                          \\<comment> \\<open>\\<open>proto\\<close> is a \\<open>primitive_protocol\\<close> here. This is strict equality match, e.g.\\<close>\n                          \\<comment> \\<open>protocol must be TCP. Thus, we can remove all negative matches!\\<close>\n                           Some ([proto], [])\""], ["", "(* It is kind of messy to find a definition that checks whether a match is the exhaustive list\n    and is executable *)"], ["", "lemma all_proto_hlp2: \"ProtoAny \\<in> a \\<or> (\\<forall>p \\<in> {0..max_word}. Proto p \\<in> a) \\<longleftrightarrow>\n                               ProtoAny \\<in> a \\<or> a = {p. p \\<noteq> ProtoAny}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ProtoAny \\<in> a \\<or> (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> a)) =\n    (ProtoAny \\<in> a \\<or> a = {p. p \\<noteq> ProtoAny})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ProtoAny \\<in> a \\<or> (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> a)) =\n    (ProtoAny \\<in> a \\<or> a = {p. p \\<noteq> ProtoAny})", "have all_proto_hlp: \"ProtoAny \\<notin> a \\<Longrightarrow> (\\<forall>p \\<in> {0..max_word}. Proto p \\<in> a) \\<longleftrightarrow> a = {p. p \\<noteq> ProtoAny}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProtoAny \\<notin> a \\<Longrightarrow>\n    (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> a) =\n    (a = {p. p \\<noteq> ProtoAny})", "by(auto intro: protocol.exhaust)"], ["proof (state)\nthis:\n  ProtoAny \\<notin> a \\<Longrightarrow>\n  (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> a) =\n  (a = {p. p \\<noteq> ProtoAny})\n\ngoal (1 subgoal):\n 1. (ProtoAny \\<in> a \\<or> (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> a)) =\n    (ProtoAny \\<in> a \\<or> a = {p. p \\<noteq> ProtoAny})", "thus ?thesis"], ["proof (prove)\nusing this:\n  ProtoAny \\<notin> a \\<Longrightarrow>\n  (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> a) =\n  (a = {p. p \\<noteq> ProtoAny})\n\ngoal (1 subgoal):\n 1. (ProtoAny \\<in> a \\<or> (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> a)) =\n    (ProtoAny \\<in> a \\<or> a = {p. p \\<noteq> ProtoAny})", "by blast"], ["proof (state)\nthis:\n  (ProtoAny \\<in> a \\<or> (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> a)) =\n  (ProtoAny \\<in> a \\<or> a = {p. p \\<noteq> ProtoAny})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_word8_word_upto: \"{0..(max_word :: 8 word)} = set (word_upto 0 255)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..- 1} = set (word_upto 0 255)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {0..- 1} = set (word_upto 0 255)", "have \\<open>0xFF = (max_word :: 8 word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 255 = - 1", "by simp"], ["proof (state)\nthis:\n  255 = - 1\n\ngoal (1 subgoal):\n 1. {0..- 1} = set (word_upto 0 255)", "then"], ["proof (chain)\npicking this:\n  255 = - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  255 = - 1\n\ngoal (1 subgoal):\n 1. {0..- 1} = set (word_upto 0 255)", "by (simp only:) (auto simp add: word_upto_set_eq)"], ["proof (state)\nthis:\n  {0..- 1} = set (word_upto 0 255)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"(\\<forall>p \\<in> {0..max_word}. Proto p \\<in> set (getNeg ps)) \\<longleftrightarrow>\n         ((\\<forall>p \\<in> set (word_upto 0 255). Proto p \\<in> set (getNeg ps)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps)) =\n    (\\<forall>p\\<in>set (word_upto 0 255). Proto p \\<in> set (getNeg ps))", "by(simp add: set_word8_word_upto)"], ["", "lemma compress_protocols_code[code]:\n    \"compress_protocols ps = (case (compress_pos_protocols (getPos ps))\n        of None \\<Rightarrow> None\n        |  Some proto \\<Rightarrow> if ProtoAny \\<in> set (getNeg ps) \\<or> (\\<forall>p \\<in> set (word_upto 0 255). Proto p \\<in> set (getNeg ps)) then\n                           None\n                         else if proto = ProtoAny then\n                           Some ([], getNeg ps)\n                         else if (\\<exists>p \\<in> set (getNeg ps). simple_proto_conjunct proto p \\<noteq> None) then\n                           None\n                         else\n                           Some ([proto], [])\n        )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_protocols ps =\n    (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>set (word_upto 0 255).\n                Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], []))", "unfolding compress_protocols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>set (word_upto 0 255).\n                Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], []))", "using set_word8_word_upto"], ["proof (prove)\nusing this:\n  {0..- 1} = set (word_upto 0 255)\n\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>set (word_upto 0 255).\n                Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], []))", "by presburger"], ["", "(*fully optimized, i.e. we cannot compress it better*)"], ["", "lemma \"compress_protocols ps = Some (ps_pos, ps_neg) \\<Longrightarrow>\n    \\<exists> p. ((\\<forall>m\\<in>set ps_pos. match_proto m p) \\<and> (\\<forall>m\\<in>set ps_neg. \\<not> match_proto m p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_protocols ps = Some (ps_pos, ps_neg) \\<Longrightarrow>\n    \\<exists>p.\n       (\\<forall>m\\<in>set ps_pos. match_proto m p) \\<and>\n       (\\<forall>m\\<in>set ps_neg. \\<not> match_proto m p)", "apply(simp add: compress_protocols_def all_proto_hlp2 split: option.split_asm if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_neg.\n                               \\<not> match_proto m p\n 2. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some x2;\n        x2 \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        set (getNeg ps) \\<noteq> {p. p \\<noteq> ProtoAny};\n        \\<forall>p\\<in>set (getNeg ps). simple_proto_conjunct x2 p = None;\n        [x2] = ps_pos \\<and> [] = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_pos. match_proto m p", "apply(subgoal_tac \"\\<exists>p. (Proto p) \\<notin> set ps_neg\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg;\n        \\<exists>p. Proto p \\<notin> set ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_neg.\n                               \\<not> match_proto m p\n 2. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Proto p \\<notin> set ps_neg\n 3. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some x2;\n        x2 \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        set (getNeg ps) \\<noteq> {p. p \\<noteq> ProtoAny};\n        \\<forall>p\\<in>set (getNeg ps). simple_proto_conjunct x2 p = None;\n        [x2] = ps_pos \\<and> [] = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_pos. match_proto m p", "apply(elim exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2 p.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg;\n        Proto p \\<notin> set ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_neg.\n                               \\<not> match_proto m p\n 2. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Proto p \\<notin> set ps_neg\n 3. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some x2;\n        x2 \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        set (getNeg ps) \\<noteq> {p. p \\<noteq> ProtoAny};\n        \\<forall>p\\<in>set (getNeg ps). simple_proto_conjunct x2 p = None;\n        [x2] = ps_pos \\<and> [] = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_pos. match_proto m p", "apply(rename_tac x2 p)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2 p.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg;\n        Proto p \\<notin> set ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_neg.\n                               \\<not> match_proto m p\n 2. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Proto p \\<notin> set ps_neg\n 3. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some x2;\n        x2 \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        set (getNeg ps) \\<noteq> {p. p \\<noteq> ProtoAny};\n        \\<forall>p\\<in>set (getNeg ps). simple_proto_conjunct x2 p = None;\n        [x2] = ps_pos \\<and> [] = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_pos. match_proto m p", "apply(rule_tac x=p in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2 p.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg;\n        Proto p \\<notin> set ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set ps_neg. \\<not> match_proto m p\n 2. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Proto p \\<notin> set ps_neg\n 3. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some x2;\n        x2 \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        set (getNeg ps) \\<noteq> {p. p \\<noteq> ProtoAny};\n        \\<forall>p\\<in>set (getNeg ps). simple_proto_conjunct x2 p = None;\n        [x2] = ps_pos \\<and> [] = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_pos. match_proto m p", "apply(blast elim: match_proto.elims)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some ProtoAny;\n        x2 = ProtoAny; ProtoAny \\<notin> set ps_neg;\n        set ps_neg \\<noteq> {p. p \\<noteq> ProtoAny};\n        [] = ps_pos \\<and> getNeg ps = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Proto p \\<notin> set ps_neg\n 2. \\<And>x2.\n       \\<lbrakk>compress_pos_protocols (getPos ps) = Some x2;\n        x2 \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        set (getNeg ps) \\<noteq> {p. p \\<noteq> ProtoAny};\n        \\<forall>p\\<in>set (getNeg ps). simple_proto_conjunct x2 p = None;\n        [x2] = ps_pos \\<and> [] = ps_neg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            \\<forall>m\\<in>set ps_pos. match_proto m p", "apply(auto intro: protocol.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition compress_normalize_protocols_step :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr option\" where \n    \"compress_normalize_protocols_step m \\<equiv> compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols m\""], ["", "lemma (in primitive_matcher_generic) compress_normalize_protocols_step_Some:\n  assumes \"normalized_nnf_match m\" and \"compress_normalize_protocols_step m = Some m'\"\n    shows \"matches (\\<beta>, \\<alpha>) m' a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) m' a p = matches (\\<beta>, \\<alpha>) m a p", "proof(rule compress_normalize_primitive_Some[OF assms(1) wf_disc_sel_common_primitive(7), of compress_protocols])"], ["proof (state)\ngoal (2 subgoals):\n 1. compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols\n     m =\n    Some m'\n 2. \\<And>as as_pos as_neg.\n       compress_protocols as = Some (as_pos, as_neg) \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (NegPos_map Prot (map Pos as_pos @ map Neg as_neg))) a\n        p =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a p", "show \"compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols m = Some m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols\n     m =\n    Some m'", "using assms(2)"], ["proof (prove)\nusing this:\n  compress_normalize_protocols_step m = Some m'\n\ngoal (1 subgoal):\n 1. compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols\n     m =\n    Some m'", "by(simp add: compress_normalize_protocols_step_def)"], ["proof (state)\nthis:\n  compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols\n   m =\n  Some m'\n\ngoal (1 subgoal):\n 1. \\<And>as as_pos as_neg.\n       compress_protocols as = Some (as_pos, as_neg) \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (NegPos_map Prot (map Pos as_pos @ map Neg as_neg))) a\n        p =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as as_pos as_neg.\n       compress_protocols as = Some (as_pos, as_neg) \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (NegPos_map Prot (map Pos as_pos @ map Neg as_neg))) a\n        p =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a p", "fix ps ps_pos ps_neg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as as_pos as_neg.\n       compress_protocols as = Some (as_pos, as_neg) \\<Longrightarrow>\n       matches (\\<beta>, \\<alpha>)\n        (alist_and (NegPos_map Prot (map Pos as_pos @ map Neg as_neg))) a\n        p =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a p", "show \"compress_protocols ps = Some (ps_pos, ps_neg) \\<Longrightarrow>\n      matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ((map Pos ps_pos)@(map Neg ps_neg)))) a p \\<longleftrightarrow>\n      matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_protocols ps = Some (ps_pos, ps_neg) \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (NegPos_map Prot (map Pos ps_pos @ map Neg ps_neg))) a p =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p", "apply(simp add: compress_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    Some (ps_pos, ps_neg) \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>)\n     (alist_and (NegPos_map Prot (map Pos ps_pos @ map Neg ps_neg))) a p =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p", "apply(simp add: bunch_of_lemmata_about_matches alist_and_append NegPos_map_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    Some (ps_pos, ps_neg) \\<Longrightarrow>\n    (matches (\\<beta>, \\<alpha>)\n      (alist_and (NegPos_map Prot (map Pos ps_pos))) a p \\<and>\n     matches (\\<beta>, \\<alpha>)\n      (alist_and (NegPos_map Prot (map Neg ps_neg))) a p) =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p", "apply(simp add: nt_match_list_matches[symmetric] nt_match_list_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    Some (ps_pos, ps_neg) \\<Longrightarrow>\n    ((\\<forall>m\\<in>set (getPos (NegPos_map Prot (map Pos ps_pos))).\n         matches (\\<beta>, \\<alpha>) (Match m) a p) \\<and>\n     (\\<forall>m\\<in>set (getNeg (NegPos_map Prot (map Pos ps_pos))).\n         matches (\\<beta>, \\<alpha>) (MatchNot (Match m)) a p) \\<and>\n     (\\<forall>m\\<in>set (getPos (NegPos_map Prot (map Neg ps_neg))).\n         matches (\\<beta>, \\<alpha>) (Match m) a p) \\<and>\n     (\\<forall>m\\<in>set (getNeg (NegPos_map Prot (map Neg ps_neg))).\n         matches (\\<beta>, \\<alpha>) (MatchNot (Match m)) a p)) =\n    ((\\<forall>m\\<in>set (getPos (NegPos_map Prot ps)).\n         matches (\\<beta>, \\<alpha>) (Match m) a p) \\<and>\n     (\\<forall>m\\<in>set (getNeg (NegPos_map Prot ps)).\n         matches (\\<beta>, \\<alpha>) (MatchNot (Match m)) a p))", "apply(simp add: NegPos_map_simps Prot_single Prot_single_not)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    Some (ps_pos, ps_neg) \\<Longrightarrow>\n    ((\\<forall>m\\<in>set ps_pos. match_proto m (p_proto p)) \\<and>\n     (\\<forall>m\\<in>set ps_neg. \\<not> match_proto m (p_proto p))) =\n    ((\\<forall>m\\<in>set (getPos ps). match_proto m (p_proto p)) \\<and>\n     (\\<forall>m\\<in>set (getNeg ps). \\<not> match_proto m (p_proto p)))", "apply(case_tac \"compress_pos_protocols (getPos ps)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case compress_pos_protocols (getPos ps) of\n              None \\<Rightarrow> None\n              | Some proto \\<Rightarrow>\n                  if ProtoAny \\<in> set (getNeg ps) \\<or>\n                     (\\<forall>p\\<in>{0..- 1}.\n                         Proto p \\<in> set (getNeg ps))\n                  then None\n                  else if proto = ProtoAny then Some ([], getNeg ps)\n                       else if \\<exists>p\\<in>set (getNeg ps).\n                                  simple_proto_conjunct proto p \\<noteq>\n                                  None\n                            then None else Some ([proto], [])) =\n             Some (ps_pos, ps_neg);\n     compress_pos_protocols (getPos ps) = None\\<rbrakk>\n    \\<Longrightarrow> ((\\<forall>m\\<in>set ps_pos.\n                           match_proto m (p_proto p)) \\<and>\n                       (\\<forall>m\\<in>set ps_neg.\n                           \\<not> match_proto m (p_proto p))) =\n                      ((\\<forall>m\\<in>set (getPos ps).\n                           match_proto m (p_proto p)) \\<and>\n                       (\\<forall>m\\<in>set (getNeg ps).\n                           \\<not> match_proto m (p_proto p)))\n 2. \\<And>a.\n       \\<lbrakk>(case compress_pos_protocols (getPos ps) of\n                 None \\<Rightarrow> None\n                 | Some proto \\<Rightarrow>\n                     if ProtoAny \\<in> set (getNeg ps) \\<or>\n                        (\\<forall>p\\<in>{0..- 1}.\n                            Proto p \\<in> set (getNeg ps))\n                     then None\n                     else if proto = ProtoAny then Some ([], getNeg ps)\n                          else if \\<exists>p\\<in>set (getNeg ps).\n                                     simple_proto_conjunct proto p \\<noteq>\n                                     None\n                               then None else Some ([proto], [])) =\n                Some (ps_pos, ps_neg);\n        compress_pos_protocols (getPos ps) = Some a\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>m\\<in>set ps_pos.\n                              match_proto m (p_proto p)) \\<and>\n                          (\\<forall>m\\<in>set ps_neg.\n                              \\<not> match_proto m (p_proto p))) =\n                         ((\\<forall>m\\<in>set (getPos ps).\n                              match_proto m (p_proto p)) \\<and>\n                          (\\<forall>m\\<in>set (getNeg ps).\n                              \\<not> match_proto m (p_proto p)))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(if ProtoAny \\<in> set (getNeg ps) \\<or>\n                    (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n                 then None\n                 else if a = ProtoAny then Some ([], getNeg ps)\n                      else if \\<exists>p\\<in>set (getNeg ps).\n                                 simple_proto_conjunct a p \\<noteq> None\n                           then None else Some ([a], [])) =\n                Some (ps_pos, ps_neg);\n        compress_pos_protocols (getPos ps) = Some a\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>m\\<in>set ps_pos.\n                              match_proto m (p_proto p)) \\<and>\n                          (\\<forall>m\\<in>set ps_neg.\n                              \\<not> match_proto m (p_proto p))) =\n                         ((\\<forall>m\\<in>set (getPos ps).\n                              match_proto m (p_proto p)) \\<and>\n                          (\\<forall>m\\<in>set (getNeg ps).\n                              \\<not> match_proto m (p_proto p)))", "apply(drule_tac p_prot=\"p_proto p\" in compress_pos_protocols_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(if ProtoAny \\<in> set (getNeg ps) \\<or>\n                    (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n                 then None\n                 else if a = ProtoAny then Some ([], getNeg ps)\n                      else if \\<exists>p\\<in>set (getNeg ps).\n                                 simple_proto_conjunct a p \\<noteq> None\n                           then None else Some ([a], [])) =\n                Some (ps_pos, ps_neg);\n        match_proto a (p_proto p) =\n        (\\<forall>pa\\<in>set (getPos ps).\n            match_proto pa (p_proto p))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>m\\<in>set ps_pos.\n                              match_proto m (p_proto p)) \\<and>\n                          (\\<forall>m\\<in>set ps_neg.\n                              \\<not> match_proto m (p_proto p))) =\n                         ((\\<forall>m\\<in>set (getPos ps).\n                              match_proto m (p_proto p)) \\<and>\n                          (\\<forall>m\\<in>set (getNeg ps).\n                              \\<not> match_proto m (p_proto p)))", "apply(simp split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        \\<exists>p\\<in>{0..- 1}. Proto p \\<notin> set (getNeg ps);\n        \\<forall>p\\<in>set (getNeg ps). simple_proto_conjunct a p = None;\n        [a] = ps_pos \\<and> [] = ps_neg\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>m\\<in>set ps_pos.\n                             match_proto m (p_proto p)) =\n                         ((\\<forall>m\\<in>set (getPos ps).\n                              match_proto m (p_proto p)) \\<and>\n                          (\\<forall>m\\<in>set (getNeg ps).\n                              \\<not> match_proto m (p_proto p)))", "using simple_proto_conjunct_None"], ["proof (prove)\nusing this:\n  simple_proto_conjunct ?p1.0 ?p2.0 = None \\<Longrightarrow>\n  \\<not> (match_proto ?p1.0 ?pkt \\<and> match_proto ?p2.0 ?pkt)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        \\<exists>p\\<in>{0..- 1}. Proto p \\<notin> set (getNeg ps);\n        \\<forall>p\\<in>set (getNeg ps). simple_proto_conjunct a p = None;\n        [a] = ps_pos \\<and> [] = ps_neg\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>m\\<in>set ps_pos.\n                             match_proto m (p_proto p)) =\n                         ((\\<forall>m\\<in>set (getPos ps).\n                              match_proto m (p_proto p)) \\<and>\n                          (\\<forall>m\\<in>set (getNeg ps).\n                              \\<not> match_proto m (p_proto p)))", "by auto"], ["proof (state)\nthis:\n  compress_protocols ps = Some (ps_pos, ps_neg) \\<Longrightarrow>\n  matches (\\<beta>, \\<alpha>)\n   (alist_and (NegPos_map Prot (map Pos ps_pos @ map Neg ps_neg))) a p =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in primitive_matcher_generic) compress_normalize_protocols_step_None:\n  assumes \"normalized_nnf_match m\" and \"compress_normalize_protocols_step m = None\"\n    shows \"\\<not> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> matches (\\<beta>, \\<alpha>) m a p", "proof(rule compress_normalize_primitive_None[OF assms(1) wf_disc_sel_common_primitive(7), of \"compress_protocols\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols\n     m =\n    None\n 2. \\<And>as.\n       compress_protocols as = None \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a\n               p", "show \"compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols m = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols\n     m =\n    None", "using assms(2)"], ["proof (prove)\nusing this:\n  compress_normalize_protocols_step m = None\n\ngoal (1 subgoal):\n 1. compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols\n     m =\n    None", "by(simp add: compress_normalize_protocols_step_def)"], ["proof (state)\nthis:\n  compress_normalize_primitive (is_Prot, prot_sel) Prot compress_protocols\n   m =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       compress_protocols as = None \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a\n               p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       compress_protocols as = None \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a\n               p", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       compress_protocols as = None \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a\n               p", "have if_option_Some:\n        \"((if P then None else Some x) = Some y) = (\\<not>P \\<and> x = y)\"\n        for P and x::protocol and y"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then None else Some x) = Some y) = (\\<not> P \\<and> x = y)", "by simp"], ["proof (state)\nthis:\n  ((if ?P then None else Some ?x) = Some ?y) = (\\<not> ?P \\<and> ?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       compress_protocols as = None \\<Longrightarrow>\n       \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot as)) a\n               p", "show \"compress_protocols ps = None \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_protocols ps = None \\<Longrightarrow>\n    \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p", "apply(simp add: compress_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    None \\<Longrightarrow>\n    \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p", "apply(simp add: nt_match_list_matches[symmetric] nt_match_list_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    None \\<Longrightarrow>\n    (\\<exists>m\\<in>set (getPos (NegPos_map Prot ps)).\n        \\<not> matches (\\<beta>, \\<alpha>) (Match m) a p) \\<or>\n    (\\<exists>m\\<in>set (getNeg (NegPos_map Prot ps)).\n        \\<not> matches (\\<beta>, \\<alpha>) (MatchNot (Match m)) a p)", "apply(simp add: NegPos_map_simps Prot_single Prot_single_not)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case compress_pos_protocols (getPos ps) of None \\<Rightarrow> None\n     | Some proto \\<Rightarrow>\n         if ProtoAny \\<in> set (getNeg ps) \\<or>\n            (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n         then None\n         else if proto = ProtoAny then Some ([], getNeg ps)\n              else if \\<exists>p\\<in>set (getNeg ps).\n                         simple_proto_conjunct proto p \\<noteq> None\n                   then None else Some ([proto], [])) =\n    None \\<Longrightarrow>\n    (\\<exists>m\\<in>set (getPos ps). \\<not> match_proto m (p_proto p)) \\<or>\n    (\\<exists>m\\<in>set (getNeg ps). match_proto m (p_proto p))", "apply(cases \"compress_pos_protocols (getPos ps)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case compress_pos_protocols (getPos ps) of\n              None \\<Rightarrow> None\n              | Some proto \\<Rightarrow>\n                  if ProtoAny \\<in> set (getNeg ps) \\<or>\n                     (\\<forall>p\\<in>{0..- 1}.\n                         Proto p \\<in> set (getNeg ps))\n                  then None\n                  else if proto = ProtoAny then Some ([], getNeg ps)\n                       else if \\<exists>p\\<in>set (getNeg ps).\n                                  simple_proto_conjunct proto p \\<noteq>\n                                  None\n                            then None else Some ([proto], [])) =\n             None;\n     compress_pos_protocols (getPos ps) = None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                          \\<not> match_proto m (p_proto p)) \\<or>\n                      (\\<exists>m\\<in>set (getNeg ps).\n                          match_proto m (p_proto p))\n 2. \\<And>a.\n       \\<lbrakk>(case compress_pos_protocols (getPos ps) of\n                 None \\<Rightarrow> None\n                 | Some proto \\<Rightarrow>\n                     if ProtoAny \\<in> set (getNeg ps) \\<or>\n                        (\\<forall>p\\<in>{0..- 1}.\n                            Proto p \\<in> set (getNeg ps))\n                     then None\n                     else if proto = ProtoAny then Some ([], getNeg ps)\n                          else if \\<exists>p\\<in>set (getNeg ps).\n                                     simple_proto_conjunct proto p \\<noteq>\n                                     None\n                               then None else Some ([proto], [])) =\n                None;\n        compress_pos_protocols (getPos ps) = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compress_pos_protocols (getPos ps) = None \\<Longrightarrow>\n    (\\<exists>m\\<in>set (getPos ps). \\<not> match_proto m (p_proto p)) \\<or>\n    (\\<exists>m\\<in>set (getNeg ps). match_proto m (p_proto p))\n 2. \\<And>a.\n       \\<lbrakk>(if ProtoAny \\<in> set (getNeg ps) \\<or>\n                    (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n                 then None\n                 else if a = ProtoAny then Some ([], getNeg ps)\n                      else if \\<exists>p\\<in>set (getNeg ps).\n                                 simple_proto_conjunct a p \\<noteq> None\n                           then None else Some ([a], [])) =\n                None;\n        compress_pos_protocols (getPos ps) = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(drule_tac p_prot=\"p_proto p\" in compress_pos_protocols_None)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> (\\<forall>proto\\<in>set (getPos ps).\n               match_proto proto (p_proto p)) \\<Longrightarrow>\n    (\\<exists>m\\<in>set (getPos ps). \\<not> match_proto m (p_proto p)) \\<or>\n    (\\<exists>m\\<in>set (getNeg ps). match_proto m (p_proto p))\n 2. \\<And>a.\n       \\<lbrakk>(if ProtoAny \\<in> set (getNeg ps) \\<or>\n                    (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n                 then None\n                 else if a = ProtoAny then Some ([], getNeg ps)\n                      else if \\<exists>p\\<in>set (getNeg ps).\n                                 simple_proto_conjunct a p \\<noteq> None\n                           then None else Some ([a], [])) =\n                None;\n        compress_pos_protocols (getPos ps) = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(if ProtoAny \\<in> set (getNeg ps) \\<or>\n                    (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n                 then None\n                 else if a = ProtoAny then Some ([], getNeg ps)\n                      else if \\<exists>p\\<in>set (getNeg ps).\n                                 simple_proto_conjunct a p \\<noteq> None\n                           then None else Some ([a], [])) =\n                None;\n        compress_pos_protocols (getPos ps) = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(drule_tac p_prot=\"p_proto p\" in compress_pos_protocols_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(if ProtoAny \\<in> set (getNeg ps) \\<or>\n                    (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\n                 then None\n                 else if a = ProtoAny then Some ([], getNeg ps)\n                      else if \\<exists>p\\<in>set (getNeg ps).\n                                 simple_proto_conjunct a p \\<noteq> None\n                           then None else Some ([a], [])) =\n                None;\n        match_proto a (p_proto p) =\n        (\\<forall>pa\\<in>set (getPos ps).\n            match_proto pa (p_proto p))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(simp split:if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        ProtoAny \\<in> set (getNeg ps) \\<or>\n        (\\<forall>p\\<in>{0..- 1}. Proto p \\<in> set (getNeg ps))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))\n 2. \\<And>a.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        \\<exists>p\\<in>{0..- 1}. Proto p \\<notin> set (getNeg ps);\n        \\<exists>p\\<in>set (getNeg ps).\n           \\<exists>y. simple_proto_conjunct a p = Some y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        \\<exists>p\\<in>{0..- 1}. Proto p \\<notin> set (getNeg ps);\n        \\<exists>p\\<in>set (getNeg ps).\n           \\<exists>y. simple_proto_conjunct a p = Some y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(elim bexE exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a pa paa y.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        pa \\<in> {0..- 1}; Proto pa \\<notin> set (getNeg ps);\n        paa \\<in> set (getNeg ps);\n        simple_proto_conjunct a paa = Some y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a pa paa y.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        Proto pa \\<notin> set (getNeg ps); paa \\<in> set (getNeg ps);\n        simple_proto_conjunct a paa = Some y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(elim simple_proto_conjunct.elims)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a pa paa y proto.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        Proto pa \\<notin> set (getNeg ps); paa \\<in> set (getNeg ps);\n        a = ProtoAny; paa = proto; Some y = Some proto\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))\n 2. \\<And>a pa paa y v.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        Proto pa \\<notin> set (getNeg ps); paa \\<in> set (getNeg ps);\n        a = Proto v; paa = ProtoAny; Some y = Some (Proto v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))\n 3. \\<And>a pa paa y p1 p2.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        Proto pa \\<notin> set (getNeg ps); paa \\<in> set (getNeg ps);\n        a = Proto p1; paa = Proto p2;\n        Some y = (if p1 = p2 then Some (Proto p1) else None)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a pa paa y v.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        Proto pa \\<notin> set (getNeg ps); paa \\<in> set (getNeg ps);\n        a = Proto v; paa = ProtoAny; Some y = Some (Proto v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))\n 2. \\<And>a pa paa y p1 p2.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        Proto pa \\<notin> set (getNeg ps); paa \\<in> set (getNeg ps);\n        a = Proto p1; paa = Proto p2;\n        Some y = (if p1 = p2 then Some (Proto p1) else None)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a pa paa y p1 p2.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        Proto pa \\<notin> set (getNeg ps); paa \\<in> set (getNeg ps);\n        a = Proto p1; paa = Proto p2;\n        Some y = (if p1 = p2 then Some (Proto p1) else None)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "using if_option_Some"], ["proof (prove)\nusing this:\n  ((if ?P then None else Some ?x) = Some ?y) = (\\<not> ?P \\<and> ?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<And>a pa paa y p1 p2.\n       \\<lbrakk>match_proto a (p_proto p) =\n                (\\<forall>pa\\<in>set (getPos ps).\n                    match_proto pa (p_proto p));\n        a \\<noteq> ProtoAny; ProtoAny \\<notin> set (getNeg ps);\n        Proto pa \\<notin> set (getNeg ps); paa \\<in> set (getNeg ps);\n        a = Proto p1; paa = Proto p2;\n        Some y = (if p1 = p2 then Some (Proto p1) else None)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m\\<in>set (getPos ps).\n                             \\<not> match_proto m (p_proto p)) \\<or>\n                         (\\<exists>m\\<in>set (getNeg ps).\n                             match_proto m (p_proto p))", "by metis"], ["proof (state)\nthis:\n  compress_protocols ps = None \\<Longrightarrow>\n  \\<not> matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map Prot ps)) a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compress_normalize_protocols_step_nnf:\n    \"normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n      normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_protocols_step m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m'", "unfolding compress_normalize_protocols_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m'", "using compress_normalize_primitive_nnf[OF wf_disc_sel_common_primitive(7)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m;\n   compress_normalize_primitive (is_Prot, prot_sel) Prot ?f ?m =\n   Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m'", "by blast"], ["", "(*not needed, I want it to introduce prot when I import from L4Ports!*)"], ["", "lemma compress_normalize_protocols_step_not_introduces_Prot:\n    \"\\<not> has_disc is_Prot m \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n     \\<not> has_disc is_Prot m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc is_Prot m; normalized_nnf_match m;\n     compress_normalize_protocols_step m = Some m'\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc is_Prot m'", "apply(simp add: compress_normalize_protocols_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc is_Prot m; normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc is_Prot m'", "apply(drule compress_normalize_primitive_not_introduces_C[where m=m and C'=Prot])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> wf_disc_sel (is_Prot, ?sel) Prot\n 2. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m\n 3. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> compress_normalize_primitive (is_Prot, ?sel) ?C ?f m =\n                      Some ?m'\n 4. \\<And>as_pos as_neg.\n       \\<lbrakk>normalized_nnf_match m;\n        compress_normalize_primitive (is_Prot, prot_sel) Prot\n         compress_protocols m =\n        Some m';\n        ?f [] = Some (as_pos, as_neg)\\<rbrakk>\n       \\<Longrightarrow> as_pos = [] \\<and> as_neg = []\n 5. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m';\n     \\<not> has_disc is_Prot ?m'\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc is_Prot m'", "apply(simp_all add: wf_disc_sel_common_primitive(7))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as_pos as_neg.\n       \\<lbrakk>normalized_nnf_match m;\n        compress_normalize_primitive (is_Prot, prot_sel) Prot\n         compress_protocols m =\n        Some m';\n        compress_protocols [] = Some (as_pos, as_neg)\\<rbrakk>\n       \\<Longrightarrow> as_pos = [] \\<and> as_neg = []", "apply(simp add: compress_protocols_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compress_normalize_protocols_step_not_introduces_Prot_negated:\n    assumes notdisc: \"\\<not> has_disc_negated is_Prot False m\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_protocols_step m = Some m'\"\n     shows \"\\<not> has_disc_negated is_Prot False m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Prot False m'", "apply(rule compress_normalize_primitive_not_introduces_C_negated[OF notdisc wf_disc_sel_common_primitive(7) nm])"], ["proof (prove)\ngoal (2 subgoals):\n 1. compress_normalize_primitive (is_Prot, prot_sel) Prot ?f m = Some m'\n 2. \\<And>as as_pos as_neg.\n       \\<lbrakk>?f as = Some (as_pos, as_neg); getNeg as = []\\<rbrakk>\n       \\<Longrightarrow> as_neg = []", "using some"], ["proof (prove)\nusing this:\n  compress_normalize_protocols_step m = Some m'\n\ngoal (2 subgoals):\n 1. compress_normalize_primitive (is_Prot, prot_sel) Prot ?f m = Some m'\n 2. \\<And>as as_pos as_neg.\n       \\<lbrakk>?f as = Some (as_pos, as_neg); getNeg as = []\\<rbrakk>\n       \\<Longrightarrow> as_neg = []", "apply(simp add: compress_normalize_protocols_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as as_pos as_neg.\n       \\<lbrakk>compress_protocols as = Some (as_pos, as_neg);\n        getNeg as = []\\<rbrakk>\n       \\<Longrightarrow> as_neg = []", "by(simp add: compress_protocols_def split: option.split_asm if_split_asm)"], ["", "lemma compress_normalize_protocols_step_hasdisc:\n    \"\\<not> has_disc disc m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> \\<not> has_disc disc m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     compress_normalize_protocols_step m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and> \\<not> has_disc disc m'", "unfolding compress_normalize_protocols_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and> \\<not> has_disc disc m'", "using compress_normalize_primitive_hasdisc[OF _ wf_disc_sel_common_primitive(7)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> has_disc ?disc2.0 ?m;\n   \\<forall>a. \\<not> ?disc2.0 (Prot a); normalized_nnf_match ?m;\n   compress_normalize_primitive (is_Prot, prot_sel) Prot ?f ?m =\n   Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m' \\<and>\n                    \\<not> has_disc ?disc2.0 ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and> \\<not> has_disc disc m'", "by blast"], ["", "lemma compress_normalize_protocols_step_hasdisc_negated:\n    \"\\<not> has_disc_negated disc neg m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc neg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc neg m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols_step m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      \\<not> has_disc_negated disc neg m'", "unfolding compress_normalize_protocols_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc neg m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      \\<not> has_disc_negated disc neg m'", "using compress_normalize_primitive_hasdisc_negated[OF _ wf_disc_sel_common_primitive(7)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> has_disc_negated ?disc2.0 ?neg ?m;\n   \\<forall>a. \\<not> ?disc2.0 (Prot a); normalized_nnf_match ?m;\n   compress_normalize_primitive (is_Prot, prot_sel) Prot ?f ?m =\n   Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m' \\<and>\n                    \\<not> has_disc_negated ?disc2.0 ?neg ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc neg m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      \\<not> has_disc_negated disc neg m'", "by blast"], ["", "lemma compress_normalize_protocols_step_preserves_normalized_n_primitive:\n    \"normalized_n_primitive (disc, sel) P m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols_step m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> normalized_n_primitive (disc, sel) P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) P m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols_step m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      normalized_n_primitive (disc, sel) P m'", "unfolding compress_normalize_protocols_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) P m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      normalized_n_primitive (disc, sel) P m'", "using compress_normalize_primitve_preserves_normalized_n_primitive[OF _ wf_disc_sel_common_primitive(7)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_n_primitive (?disc2.0, ?sel2.0) ?P ?m;\n   \\<forall>a. \\<not> ?disc2.0 (Prot a); normalized_nnf_match ?m;\n   compress_normalize_primitive (is_Prot, prot_sel) Prot ?f ?m =\n   Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m' \\<and>\n                    normalized_n_primitive (?disc2.0, ?sel2.0) ?P ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) P m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_primitive (is_Prot, prot_sel) Prot\n      compress_protocols m =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      normalized_n_primitive (disc, sel) P m'", "by blast"], ["", "lemma \"case compress_normalize_protocols_step \n    (MatchAnd (MatchAnd (MatchAnd (Match ((Prot (Proto TCP)):: 32 common_primitive)) (MatchNot (Match (Prot (Proto UDP))))) (Match (IIface (Iface ''eth1''))))\n              (Match (Prot (Proto TCP)))) of Some ps \\<Rightarrow> opt_MatchAny_match_expr ps\n  = MatchAnd (Match (Prot (Proto 6))) (Match (IIface (Iface ''eth1'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case compress_normalize_protocols_step\n          (MatchAnd\n            (MatchAnd\n              (MatchAnd (Match (Prot (Proto TCP)))\n                (MatchNot (Match (Prot (Proto UDP)))))\n              (Match (IIface (Iface ''eth1''))))\n            (Match (Prot (Proto TCP)))) of\n    Some ps \\<Rightarrow>\n      opt_MatchAny_match_expr ps =\n      MatchAnd (Match (Prot (Proto 6))) (Match (IIface (Iface ''eth1'')))", "by eval"], ["", "value[code] \"compress_normalize_protocols_step (MatchAny:: 32 common_primitive match_expr)\""], ["", "subsection\\<open>Importing the matches on @{typ primitive_protocol} from @{const L4Ports}\\<close>"], ["", "(* add protocols from positive L4 ports into optimization. *)"], ["", "definition import_protocols_from_ports\n    :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr\" where \n  \"import_protocols_from_ports m \\<equiv>\n    (case primitive_extractor (is_Src_Ports, src_ports_sel) m of (srcpts, rst1) \\<Rightarrow>\n     case primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 of (dstpts, rst2) \\<Rightarrow>\n      MatchAnd\n      (MatchAnd\n       (MatchAnd\n        (andfold_MatchExp (map (Match \\<circ> (Prot \\<circ> (case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))) (getPos srcpts)))\n        (andfold_MatchExp (map (Match \\<circ> (Prot \\<circ> (case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))) (getPos dstpts)))\n       )\n        (alist_and' (NegPos_map Src_Ports srcpts @ NegPos_map Dst_Ports dstpts))\n       )\n         rst2\n     )\""], ["", "text\\<open>The @{const Proto} and @{const L4Ports} match make the following match impossible:\\<close>"], ["", "lemma \"compress_normalize_protocols_step (import_protocols_from_ports \n    (MatchAnd (MatchAnd (Match (Prot (Proto TCP):: 32 common_primitive))\n      (Match (Src_Ports (L4Ports UDP [(22,22)])))) (Match (IIface (Iface ''eth1''))))) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_normalize_protocols_step\n     (import_protocols_from_ports\n       (MatchAnd\n         (MatchAnd (Match (Prot (Proto TCP)))\n           (Match (Src_Ports (L4Ports UDP [(22, 22)]))))\n         (Match (IIface (Iface ''eth1''))))) =\n    None", "by eval"], ["", "(*unfolding the whole primitive_extractor*)"], ["", "lemma import_protocols_from_ports_erule: \"normalized_nnf_match m \\<Longrightarrow> P m \\<Longrightarrow>\n    (\\<And>srcpts rst1 dstpts rst2.\n       normalized_nnf_match m \\<Longrightarrow>\n       \\<comment> \\<open>\\<open>P m \\<Longrightarrow>\\<close> erule consumes only first argument\\<close>\n       primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1) \\<Longrightarrow>\n       primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 = (dstpts, rst2) \\<Longrightarrow>\n       normalized_nnf_match rst1 \\<Longrightarrow>\n       normalized_nnf_match rst2 \\<Longrightarrow>\n       P (MatchAnd\n           (MatchAnd\n             (MatchAnd\n               (andfold_MatchExp\n                 (map (Match \\<circ> (Prot \\<circ> (case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))) (getPos srcpts)))\n               (andfold_MatchExp\n                 (map (Match \\<circ> (Prot \\<circ> (case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))) (getPos dstpts))))\n             (alist_and' (NegPos_map Src_Ports srcpts @ NegPos_map Dst_Ports dstpts)))\n           rst2)) \\<Longrightarrow>\n    P (import_protocols_from_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m; P m;\n     \\<And>srcpts rst1 dstpts rst2.\n        \\<lbrakk>normalized_nnf_match m;\n         primitive_extractor (is_Src_Ports, src_ports_sel) m =\n         (srcpts, rst1);\n         primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n         (dstpts, rst2);\n         normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n        \\<Longrightarrow> P (MatchAnd\n                              (MatchAnd\n                                (MatchAnd\n                                  (andfold_MatchExp\n                                    (map\n(Match \\<circ>\n (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n(getPos srcpts)))\n                                  (andfold_MatchExp\n                                    (map\n(Match \\<circ>\n (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n(getPos dstpts))))\n                                (alist_and'\n                                  (NegPos_map Src_Ports srcpts @\n                                   NegPos_map Dst_Ports dstpts)))\n                              rst2)\\<rbrakk>\n    \\<Longrightarrow> P (import_protocols_from_ports m)", "apply(simp add: import_protocols_from_ports_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m; P m;\n     \\<And>srcpts rst1 dstpts rst2.\n        \\<lbrakk>primitive_extractor (is_Src_Ports, src_ports_sel) m =\n                 (srcpts, rst1);\n         primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n         (dstpts, rst2);\n         normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n        \\<Longrightarrow> P (MatchAnd\n                              (MatchAnd\n                                (MatchAnd\n                                  (andfold_MatchExp\n                                    (map\n(Match \\<circ>\n (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n(getPos srcpts)))\n                                  (andfold_MatchExp\n                                    (map\n(Match \\<circ>\n (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n(getPos dstpts))))\n                                (alist_and'\n                                  (NegPos_map Src_Ports srcpts @\n                                   NegPos_map Dst_Ports dstpts)))\n                              rst2)\\<rbrakk>\n    \\<Longrightarrow> P (case primitive_extractor\n                               (is_Src_Ports, src_ports_sel) m of\n                         (srcpts, rst1) \\<Rightarrow>\n                           case primitive_extractor\n                                 (is_Dst_Ports, dst_ports_sel) rst1 of\n                           (dstpts, rst2) \\<Rightarrow>\n                             MatchAnd\n                              (MatchAnd\n                                (MatchAnd\n                                  (andfold_MatchExp\n                                    (map\n(Match \\<circ>\n (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n(getPos srcpts)))\n                                  (andfold_MatchExp\n                                    (map\n(Match \\<circ>\n (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n(getPos dstpts))))\n                                (alist_and'\n                                  (NegPos_map Src_Ports srcpts @\n                                   NegPos_map Dst_Ports dstpts)))\n                              rst2)", "apply(case_tac \"primitive_extractor (is_Src_Ports, src_ports_sel) m\", rename_tac srcpts rst1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1.\n       \\<lbrakk>normalized_nnf_match m; P m;\n        \\<And>srcpts rst1 dstpts rst2.\n           \\<lbrakk>primitive_extractor (is_Src_Ports, src_ports_sel) m =\n                    (srcpts, rst1);\n            primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n            (dstpts, rst2);\n            normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n           \\<Longrightarrow> P (MatchAnd\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos srcpts)))\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos dstpts))))\n                                   (alist_and'\n                                     (NegPos_map Src_Ports srcpts @\nNegPos_map Dst_Ports dstpts)))\n                                 rst2);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1)\\<rbrakk>\n       \\<Longrightarrow> P (case primitive_extractor\n                                  (is_Src_Ports, src_ports_sel) m of\n                            (srcpts, rst1) \\<Rightarrow>\n                              case primitive_extractor\n                                    (is_Dst_Ports, dst_ports_sel) rst1 of\n                              (dstpts, rst2) \\<Rightarrow>\n                                MatchAnd\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos srcpts)))\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos dstpts))))\n                                   (alist_and'\n                                     (NegPos_map Src_Ports srcpts @\nNegPos_map Dst_Ports dstpts)))\n                                 rst2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1.\n       \\<lbrakk>normalized_nnf_match m; P m;\n        \\<And>srcptsa dstpts rst2.\n           \\<lbrakk>srcpts = srcptsa;\n            primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n            (dstpts, rst2);\n            normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n           \\<Longrightarrow> P (MatchAnd\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos srcptsa)))\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos dstpts))))\n                                   (alist_and'\n                                     (NegPos_map Src_Ports srcptsa @\nNegPos_map Dst_Ports dstpts)))\n                                 rst2);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1)\\<rbrakk>\n       \\<Longrightarrow> P (case primitive_extractor\n                                  (is_Dst_Ports, dst_ports_sel) rst1 of\n                            (dstpts, x) \\<Rightarrow>\n                              MatchAnd\n                               (MatchAnd\n                                 (MatchAnd\n                                   (andfold_MatchExp\n                                     (map\n (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n (getPos srcpts)))\n                                   (andfold_MatchExp\n                                     (map\n (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n (getPos dstpts))))\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts)))\n                               x)", "apply(case_tac \"primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1\", rename_tac dstpts rst2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m; P m;\n        \\<And>srcptsa dstpts rst2.\n           \\<lbrakk>srcpts = srcptsa;\n            primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n            (dstpts, rst2);\n            normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n           \\<Longrightarrow> P (MatchAnd\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos srcptsa)))\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos dstpts))))\n                                   (alist_and'\n                                     (NegPos_map Src_Ports srcptsa @\nNegPos_map Dst_Ports dstpts)))\n                                 rst2);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2)\\<rbrakk>\n       \\<Longrightarrow> P (case primitive_extractor\n                                  (is_Dst_Ports, dst_ports_sel) rst1 of\n                            (dstpts, x) \\<Rightarrow>\n                              MatchAnd\n                               (MatchAnd\n                                 (MatchAnd\n                                   (andfold_MatchExp\n                                     (map\n (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n (getPos srcpts)))\n                                   (andfold_MatchExp\n                                     (map\n (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n (getPos dstpts))))\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts)))\n                               x)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m; P m;\n        \\<And>srcptsa dstptsa.\n           \\<lbrakk>srcpts = srcptsa; dstpts = dstptsa;\n            normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n           \\<Longrightarrow> P (MatchAnd\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos srcptsa)))\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos dstptsa))))\n                                   (alist_and'\n                                     (NegPos_map Src_Ports srcptsa @\nNegPos_map Dst_Ports dstptsa)))\n                                 rst2);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2)\\<rbrakk>\n       \\<Longrightarrow> P (MatchAnd\n                             (MatchAnd\n                               (MatchAnd\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts))))\n                               (alist_and'\n                                 (NegPos_map Src_Ports srcpts @\n                                  NegPos_map Dst_Ports dstpts)))\n                             rst2)", "apply(frule(1) primitive_extractor_correct(2)[OF _ wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m; P m;\n        \\<And>srcptsa dstptsa.\n           \\<lbrakk>srcpts = srcptsa; dstpts = dstptsa;\n            normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n           \\<Longrightarrow> P (MatchAnd\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos srcptsa)))\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos dstptsa))))\n                                   (alist_and'\n                                     (NegPos_map Src_Ports srcptsa @\nNegPos_map Dst_Ports dstptsa)))\n                                 rst2);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1\\<rbrakk>\n       \\<Longrightarrow> P (MatchAnd\n                             (MatchAnd\n                               (MatchAnd\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts))))\n                               (alist_and'\n                                 (NegPos_map Src_Ports srcpts @\n                                  NegPos_map Dst_Ports dstpts)))\n                             rst2)", "apply(frule(1) primitive_extractor_correct(2)[OF _ wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m; P m;\n        \\<And>srcptsa dstptsa.\n           \\<lbrakk>srcpts = srcptsa; dstpts = dstptsa;\n            normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n           \\<Longrightarrow> P (MatchAnd\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos srcptsa)))\n                                     (andfold_MatchExp\n (map (Match \\<circ>\n       (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n   (getPos dstptsa))))\n                                   (alist_and'\n                                     (NegPos_map Src_Ports srcptsa @\nNegPos_map Dst_Ports dstptsa)))\n                                 rst2);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> P (MatchAnd\n                             (MatchAnd\n                               (MatchAnd\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts))))\n                               (alist_and'\n                                 (NegPos_map Src_Ports srcpts @\n                                  NegPos_map Dst_Ports dstpts)))\n                             rst2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in primitive_matcher_generic) import_protocols_from_ports:\n  assumes normalized: \"normalized_nnf_match m\"\n  shows \"matches (\\<beta>, \\<alpha>) (import_protocols_from_ports m) a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (import_protocols_from_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (import_protocols_from_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "have add_protocol:\n    \"matches (\\<beta>, \\<alpha>)\n      (andfold_MatchExp (map (Match \\<circ> (Prot \\<circ> (case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))) (getPos as))) a p \\<and>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p\n     \\<longleftrightarrow>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p\"\n    if C: \"C = Src_Ports \\<or> C = Dst_Ports\" for C as"], ["proof (prove)\ngoal (1 subgoal):\n 1. (matches (\\<beta>, \\<alpha>)\n      (andfold_MatchExp\n        (map (Match \\<circ>\n              (Prot \\<circ>\n               case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n          (getPos as)))\n      a p \\<and>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p) =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p", "proof(induction as)"], ["proof (state)\ngoal (2 subgoals):\n 1. (matches (\\<beta>, \\<alpha>)\n      (andfold_MatchExp\n        (map (Match \\<circ>\n              (Prot \\<circ>\n               (\\<lambda>a.\n                   case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n          (getPos [])))\n      a p \\<and>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C [])) a p) =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C [])) a p\n 2. \\<And>aa as.\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos as)))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a\n        p \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (aa # as))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a p", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (matches (\\<beta>, \\<alpha>)\n      (andfold_MatchExp\n        (map (Match \\<circ>\n              (Prot \\<circ>\n               (\\<lambda>a.\n                   case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n          (getPos [])))\n      a p \\<and>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C [])) a p) =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C [])) a p\n 2. \\<And>aa as.\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos as)))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a\n        p \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (aa # as))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a p", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (matches (\\<beta>, \\<alpha>)\n      (andfold_MatchExp\n        (map (Match \\<circ>\n              (Prot \\<circ>\n               (\\<lambda>a.\n                   case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n          (getPos [])))\n      a p \\<and>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C [])) a p) =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C [])) a p", "by(simp)"], ["proof (state)\nthis:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos [])))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C [])) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C [])) a p\n\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos as)))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a\n        p \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (aa # as))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos as)))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a\n        p \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (aa # as))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a p", "case (Cons x xs)"], ["proof (state)\nthis:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos xs)))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p\n\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos as)))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C as)) a\n        p \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (aa # as))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (aa # as))) a p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (matches (\\<beta>, \\<alpha>)\n      (andfold_MatchExp\n        (map (Match \\<circ>\n              (Prot \\<circ>\n               (\\<lambda>a.\n                   case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n          (getPos (x # xs))))\n      a p \\<and>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p) =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p", "proof(cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Pos x1 \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (x # xs))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p\n 2. \\<And>x2.\n       x = Neg x2 \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (x # xs))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p", "case Neg"], ["proof (state)\nthis:\n  x = Neg x2_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Pos x1 \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (x # xs))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p\n 2. \\<And>x2.\n       x = Neg x2 \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (x # xs))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p", "with Cons.IH"], ["proof (chain)\npicking this:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos xs)))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p\n  x = Neg x2_", "show ?thesis"], ["proof (prove)\nusing this:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos xs)))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p\n  x = Neg x2_\n\ngoal (1 subgoal):\n 1. (matches (\\<beta>, \\<alpha>)\n      (andfold_MatchExp\n        (map (Match \\<circ>\n              (Prot \\<circ>\n               (\\<lambda>a.\n                   case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n          (getPos (x # xs))))\n      a p \\<and>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p) =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p", "apply(simp add: bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(matches (\\<beta>, \\<alpha>)\n               (andfold_MatchExp\n                 (map (\\<lambda>a.\n                          Match\n                           (Prot\n                             (case a of\n                              L4Ports proto x \\<Rightarrow> Proto proto)))\n                   (getPos xs)))\n               a p \\<and>\n              matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a\n               p) =\n             matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p;\n     x = Neg x2_\\<rbrakk>\n    \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                        (andfold_MatchExp\n                          (map (\\<lambda>a.\n                                   Match\n                                    (Prot\n(case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n                            (getPos xs)))\n                        a p \\<and>\n                       matches (\\<beta>, \\<alpha>)\n                        (MatchNot (Match (C x2_))) a p \\<and>\n                       matches (\\<beta>, \\<alpha>)\n                        (alist_and (NegPos_map C xs)) a p) =\n                      (matches (\\<beta>, \\<alpha>)\n                        (MatchNot (Match (C x2_))) a p \\<and>\n                       matches (\\<beta>, \\<alpha>)\n                        (alist_and (NegPos_map C xs)) a p)", "by blast"], ["proof (state)\nthis:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos (x # xs))))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Pos x1 \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (x # xs))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Pos x1 \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (x # xs))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p", "case (Pos portmatch)"], ["proof (state)\nthis:\n  x = Pos portmatch\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Pos x1 \\<Longrightarrow>\n       (matches (\\<beta>, \\<alpha>)\n         (andfold_MatchExp\n           (map (Match \\<circ>\n                 (Prot \\<circ>\n                  (\\<lambda>a.\n                      case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n             (getPos (x # xs))))\n         a p \\<and>\n        matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a\n         p) =\n       matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p", "with Cons.IH"], ["proof (chain)\npicking this:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos xs)))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p\n  x = Pos portmatch", "show ?thesis"], ["proof (prove)\nusing this:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos xs)))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a p\n  x = Pos portmatch\n\ngoal (1 subgoal):\n 1. (matches (\\<beta>, \\<alpha>)\n      (andfold_MatchExp\n        (map (Match \\<circ>\n              (Prot \\<circ>\n               (\\<lambda>a.\n                   case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n          (getPos (x # xs))))\n      a p \\<and>\n     matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p) =\n    matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p", "apply(cases portmatch)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(matches (\\<beta>, \\<alpha>)\n                  (andfold_MatchExp\n                    (map (Match \\<circ>\n                          (Prot \\<circ>\n                           (\\<lambda>a.\n                               case a of\n                               L4Ports proto x \\<Rightarrow> Proto proto)))\n                      (getPos xs)))\n                  a p \\<and>\n                 matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a\n                  p) =\n                matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a\n                 p;\n        x = Pos portmatch; portmatch = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (andfold_MatchExp\n                             (map (Match \\<circ>\n                                   (Prot \\<circ>\n                                    (\\<lambda>a.\n  case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n                               (getPos (x # xs))))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map C (x # xs))) a p) =\n                         matches (\\<beta>, \\<alpha>)\n                          (alist_and (NegPos_map C (x # xs))) a p", "apply(simp add: andfold_MatchExp_matches bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>((\\<forall>m\\<in>set (getPos xs).\n                     matches (\\<beta>, \\<alpha>)\n                      (Match\n                        (Prot\n                          (case m of\n                           L4Ports proto x \\<Rightarrow> Proto proto)))\n                      a p) \\<and>\n                 matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a\n                  p) =\n                matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a\n                 p;\n        x = Pos (L4Ports x1 x2); portmatch = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (Match (Prot (Proto x1))) a p \\<and>\n                          (\\<forall>m\\<in>set (getPos xs).\n                              matches (\\<beta>, \\<alpha>)\n                               (Match\n                                 (Prot\n                                   (case m of\n                                    L4Ports proto x \\<Rightarrow>\nProto proto)))\n                               a p) \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (Match (C (L4Ports x1 x2))) a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map C xs)) a p) =\n                         (matches (\\<beta>, \\<alpha>)\n                           (Match (C (L4Ports x1 x2))) a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map C xs)) a p)", "using Ports_single_rewrite_Prot C"], ["proof (prove)\nusing this:\n  matches (\\<beta>, ?\\<alpha>) (Match (Src_Ports (L4Ports ?proto ?ps))) ?a\n   ?p =\n  (matches (\\<beta>, ?\\<alpha>) (Match (Prot (Proto ?proto))) ?a ?p \\<and>\n   p_sport ?p \\<in> ports_to_set ?ps)\n  matches (\\<beta>, ?\\<alpha>)\n   (MatchNot (Match (Src_Ports (L4Ports ?proto ?ps)))) ?a ?p =\n  (matches (\\<beta>, ?\\<alpha>) (MatchNot (Match (Prot (Proto ?proto)))) ?a\n    ?p \\<or>\n   p_sport ?p \\<notin> ports_to_set ?ps)\n  matches (\\<beta>, ?\\<alpha>) (Match (Dst_Ports (L4Ports ?proto ?ps))) ?a\n   ?p =\n  (matches (\\<beta>, ?\\<alpha>) (Match (Prot (Proto ?proto))) ?a ?p \\<and>\n   p_dport ?p \\<in> ports_to_set ?ps)\n  matches (\\<beta>, ?\\<alpha>)\n   (MatchNot (Match (Dst_Ports (L4Ports ?proto ?ps)))) ?a ?p =\n  (matches (\\<beta>, ?\\<alpha>) (MatchNot (Match (Prot (Proto ?proto)))) ?a\n    ?p \\<or>\n   p_dport ?p \\<notin> ports_to_set ?ps)\n  C = Src_Ports \\<or> C = Dst_Ports\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>((\\<forall>m\\<in>set (getPos xs).\n                     matches (\\<beta>, \\<alpha>)\n                      (Match\n                        (Prot\n                          (case m of\n                           L4Ports proto x \\<Rightarrow> Proto proto)))\n                      a p) \\<and>\n                 matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a\n                  p) =\n                matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C xs)) a\n                 p;\n        x = Pos (L4Ports x1 x2); portmatch = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (Match (Prot (Proto x1))) a p \\<and>\n                          (\\<forall>m\\<in>set (getPos xs).\n                              matches (\\<beta>, \\<alpha>)\n                               (Match\n                                 (Prot\n                                   (case m of\n                                    L4Ports proto x \\<Rightarrow>\nProto proto)))\n                               a p) \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (Match (C (L4Ports x1 x2))) a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map C xs)) a p) =\n                         (matches (\\<beta>, \\<alpha>)\n                           (Match (C (L4Ports x1 x2))) a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map C xs)) a p)", "by blast"], ["proof (state)\nthis:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos (x # xs))))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             (\\<lambda>a.\n                 case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n        (getPos (x # xs))))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map C (x # xs))) a p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?C = Src_Ports \\<or> ?C = Dst_Ports \\<Longrightarrow>\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n        (getPos ?as)))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map ?C ?as)) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map ?C ?as)) a p\n\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (import_protocols_from_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "from normalized"], ["proof (chain)\npicking this:\n  normalized_nnf_match m", "show ?thesis"], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) (import_protocols_from_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    matches (\\<beta>, \\<alpha>) (import_protocols_from_ports m) a p =\n    matches (\\<beta>, \\<alpha>) m a p", "apply(erule import_protocols_from_ports_erule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matches (\\<beta>, \\<alpha>) m a p = matches (\\<beta>, \\<alpha>) m a p\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                          (MatchAnd\n                            (MatchAnd\n                              (MatchAnd\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos srcpts)))\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos dstpts))))\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts)))\n                            rst2)\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                          (MatchAnd\n                            (MatchAnd\n                              (MatchAnd\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos srcpts)))\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos dstpts))))\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts)))\n                            rst2)\n                          a p =\n                         matches (\\<beta>, \\<alpha>) m a p", "apply(subst primitive_extractor_correct(1)[OF normalized wf_disc_sel_common_primitive(1),\n          where \\<gamma>=\"(\\<beta>,\\<alpha>)\" and a=a and p=p, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> primitive_extractor (is_Src_Ports, src_ports_sel)\n                          m =\n                         (?as6 srcpts rst1 dstpts rst2,\n                          ?ms6 srcpts rst1 dstpts rst2)\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                          (MatchAnd\n                            (MatchAnd\n                              (MatchAnd\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos srcpts)))\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos dstpts))))\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts)))\n                            rst2)\n                          a p =\n                         (matches (\\<beta>, \\<alpha>)\n                           (alist_and\n                             (NegPos_map Src_Ports\n                               (?as6 srcpts rst1 dstpts rst2)))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (?ms6 srcpts rst1 dstpts rst2) a p)", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                          (MatchAnd\n                            (MatchAnd\n                              (MatchAnd\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos srcpts)))\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos dstpts))))\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts)))\n                            rst2)\n                          a p =\n                         (matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map Src_Ports srcpts)) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>) rst1 a p)", "apply(drule(1) primitive_extractor_correct(1)[OF _ wf_disc_sel_common_primitive(2),\n          where \\<gamma>=\"(\\<beta>,\\<alpha>)\" and a=a and p=p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst2;\n        (matches (\\<beta>, \\<alpha>)\n          (alist_and (NegPos_map Dst_Ports dstpts)) a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst2 a p) =\n        matches (\\<beta>, \\<alpha>) rst1 a p\\<rbrakk>\n       \\<Longrightarrow> matches (\\<beta>, \\<alpha>)\n                          (MatchAnd\n                            (MatchAnd\n                              (MatchAnd\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos srcpts)))\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos dstpts))))\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts)))\n                            rst2)\n                          a p =\n                         (matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map Src_Ports srcpts)) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>) rst1 a p)", "apply(simp add: bunch_of_lemmata_about_matches matches_alist_and_alist_and' alist_and_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst2;\n        (matches (\\<beta>, \\<alpha>)\n          (alist_and (NegPos_map Dst_Ports dstpts)) a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst2 a p) =\n        matches (\\<beta>, \\<alpha>) rst1 a p\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (andfold_MatchExp\n                             (map (Match \\<circ>\n                                   (Prot \\<circ>\n                                    case_ipt_l4_ports\n                                     (\\<lambda>proto x. Proto proto)))\n                               (getPos srcpts)))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (andfold_MatchExp\n                             (map (Match \\<circ>\n                                   (Prot \\<circ>\n                                    case_ipt_l4_ports\n                                     (\\<lambda>proto x. Proto proto)))\n                               (getPos dstpts)))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map Src_Ports srcpts)) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>) rst1 a p) =\n                         (matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map Src_Ports srcpts)) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>) rst1 a p)", "using add_protocol"], ["proof (prove)\nusing this:\n  ?C = Src_Ports \\<or> ?C = Dst_Ports \\<Longrightarrow>\n  (matches (\\<beta>, \\<alpha>)\n    (andfold_MatchExp\n      (map (Match \\<circ>\n            (Prot \\<circ>\n             case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n        (getPos ?as)))\n    a p \\<and>\n   matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map ?C ?as)) a p) =\n  matches (\\<beta>, \\<alpha>) (alist_and (NegPos_map ?C ?as)) a p\n\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst2;\n        (matches (\\<beta>, \\<alpha>)\n          (alist_and (NegPos_map Dst_Ports dstpts)) a p \\<and>\n         matches (\\<beta>, \\<alpha>) rst2 a p) =\n        matches (\\<beta>, \\<alpha>) rst1 a p\\<rbrakk>\n       \\<Longrightarrow> (matches (\\<beta>, \\<alpha>)\n                           (andfold_MatchExp\n                             (map (Match \\<circ>\n                                   (Prot \\<circ>\n                                    case_ipt_l4_ports\n                                     (\\<lambda>proto x. Proto proto)))\n                               (getPos srcpts)))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (andfold_MatchExp\n                             (map (Match \\<circ>\n                                   (Prot \\<circ>\n                                    case_ipt_l4_ports\n                                     (\\<lambda>proto x. Proto proto)))\n                               (getPos dstpts)))\n                           a p \\<and>\n                          matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map Src_Ports srcpts)) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>) rst1 a p) =\n                         (matches (\\<beta>, \\<alpha>)\n                           (alist_and (NegPos_map Src_Ports srcpts)) a\n                           p \\<and>\n                          matches (\\<beta>, \\<alpha>) rst1 a p)", "by blast"], ["proof (state)\nthis:\n  matches (\\<beta>, \\<alpha>) (import_protocols_from_ports m) a p =\n  matches (\\<beta>, \\<alpha>) m a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma import_protocols_from_ports_nnf:\n    \"normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (import_protocols_from_ports m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (import_protocols_from_ports m)", "have hlp: \"\\<forall>m\\<in>set (map (Match \\<circ> (Prot \\<circ> (case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))) ls).\n          normalized_nnf_match m\" for ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set (map (Match \\<circ>\n                             (Prot \\<circ>\n                              case_ipt_l4_ports\n                               (\\<lambda>proto x. Proto proto)))\n                         ls).\n       normalized_nnf_match m", "apply(induction ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (map (Match \\<circ>\n                             (Prot \\<circ>\n                              (\\<lambda>a.\n                                  case a of\n                                  L4Ports proto x \\<Rightarrow>\n                                    Proto proto)))\n                         []).\n       normalized_nnf_match m\n 2. \\<And>a ls.\n       \\<forall>m\\<in>set (map (Match \\<circ>\n                                (Prot \\<circ>\n                                 (\\<lambda>a.\n                                     case a of\n                                     L4Ports proto x \\<Rightarrow>\n Proto proto)))\n                            ls).\n          normalized_nnf_match m \\<Longrightarrow>\n       \\<forall>m\\<in>set (map (Match \\<circ>\n                                (Prot \\<circ>\n                                 (\\<lambda>a.\n                                     case a of\n                                     L4Ports proto x \\<Rightarrow>\n Proto proto)))\n                            (a # ls)).\n          normalized_nnf_match m", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<forall>m\\<in>set (map (Match \\<circ>\n                                (Prot \\<circ>\n                                 (\\<lambda>a.\n                                     case a of\n                                     L4Ports proto x \\<Rightarrow>\n Proto proto)))\n                            ls).\n          normalized_nnf_match m \\<Longrightarrow>\n       \\<forall>m\\<in>set (map (Match \\<circ>\n                                (Prot \\<circ>\n                                 (\\<lambda>a.\n                                     case a of\n                                     L4Ports proto x \\<Rightarrow>\n Proto proto)))\n                            (a # ls)).\n          normalized_nnf_match m", "apply(rename_tac l ls, case_tac l)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ls x1 x2.\n       \\<lbrakk>\\<forall>m\\<in>set (map (Match \\<circ>\n   (Prot \\<circ>\n    (\\<lambda>a. case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n                                     ls).\n                   normalized_nnf_match m;\n        l = L4Ports x1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set\n   (map (Match \\<circ>\n         (Prot \\<circ>\n          (\\<lambda>a.\n              case a of L4Ports proto x \\<Rightarrow> Proto proto)))\n     (l # ls)).\n                            normalized_nnf_match m", "by(simp)"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set (map (Match \\<circ>\n                           (Prot \\<circ>\n                            case_ipt_l4_ports\n                             (\\<lambda>proto x. Proto proto)))\n                       ?ls1).\n     normalized_nnf_match m\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (import_protocols_from_ports m)", "show \"normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (import_protocols_from_ports m)", "apply(rule import_protocols_from_ports_erule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match m\n 2. normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match m\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m; normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match\n                          (MatchAnd\n                            (MatchAnd\n                              (MatchAnd\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos srcpts)))\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos dstpts))))\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts)))\n                            rst2)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos srcpts))) \\<and>\n                         normalized_nnf_match\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos dstpts))) \\<and>\n                         normalized_nnf_match\n                          (alist_and'\n                            (NegPos_map Src_Ports srcpts @\n                             NegPos_map Dst_Ports dstpts))", "apply(simp add: normalized_nnf_match_alist_and')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos srcpts))) \\<and>\n                         normalized_nnf_match\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos dstpts)))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos srcpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos dstpts)))", "apply(rule andfold_MatchExp_normalized_nnf, simp add: hlp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  normalized_nnf_match m \\<Longrightarrow>\n  normalized_nnf_match (import_protocols_from_ports m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma import_protocols_from_ports_not_introduces_Prot_negated:\n    \"normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated is_Prot False m \\<Longrightarrow>\n      \\<not> has_disc_negated is_Prot False (import_protocols_from_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     \\<not> has_disc_negated is_Prot False m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                              (import_protocols_from_ports m)", "apply(erule(1) import_protocols_from_ports_erule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (MatchAnd\n (andfold_MatchExp\n   (map (Match \\<circ>\n         (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n     (getPos srcpts)))\n (andfold_MatchExp\n   (map (Match \\<circ>\n         (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n     (getPos dstpts))))\n                                     (alist_and'\n (NegPos_map Src_Ports srcpts @ NegPos_map Dst_Ports dstpts)))\n                                   rst2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts))) \\<and>\n                         \\<not> has_disc_negated is_Prot False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts))) \\<and>\n                         \\<not> has_disc_negated is_Prot False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts)) \\<and>\n                         \\<not> has_disc_negated is_Prot False rst2", "apply(intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 4. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "using andfold_MatchExp_not_disc_negated_mapMatch[\n          where C=\"Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)\", simplified]"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated ?disc False\n          (andfold_MatchExp\n            (map (Match \\<circ>\n                  (Prot \\<circ>\n                   case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n              ?ls))\n\ngoal (4 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 4. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "using andfold_MatchExp_not_disc_negated_mapMatch[\n         where C=\"Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)\", simplified]"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated ?disc False\n          (andfold_MatchExp\n            (map (Match \\<circ>\n                  (Prot \\<circ>\n                   case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n              ?ls))\n\ngoal (3 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "apply(simp add: has_disc_negated_alist_and')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a\\<in>set\n   (NegPos_map Src_Ports srcpts) \\<union>\n  set (NegPos_map Dst_Ports dstpts).\n                            \\<not> has_disc_negated is_Prot False\n                                    (negation_type_to_match_expr a)\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "using not_has_disc_negated_NegPos_map[where disc=is_Prot and C=Src_Ports, simplified]\n            not_has_disc_negated_NegPos_map[where disc=is_Prot and C=Dst_Ports, simplified]"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (NegPos_map Src_Ports ?ls).\n     \\<not> has_disc_negated is_Prot False (negation_type_to_match_expr a)\n  \\<forall>a\\<in>set (NegPos_map Dst_Ports ?ls).\n     \\<not> has_disc_negated is_Prot False (negation_type_to_match_expr a)\n\ngoal (2 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a\\<in>set\n   (NegPos_map Src_Ports srcpts) \\<union>\n  set (NegPos_map Dst_Ports dstpts).\n                            \\<not> has_disc_negated is_Prot False\n                                    (negation_type_to_match_expr a)\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "apply(drule(1) primitive_extractor_correct(6)[OF _ wf_disc_sel_common_primitive(1), where neg=False])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2;\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 False m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 False rst1\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "apply(drule(1) primitive_extractor_correct(6)[OF _ wf_disc_sel_common_primitive(2), where neg=False])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst2;\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 False m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 False rst1;\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 False rst1 \\<longrightarrow>\n           \\<not> has_disc_negated disc2 False rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated is_Prot False rst2", "by blast"], ["", "lemma import_protocols_from_ports_hasdisc:\n    \"normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc disc m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow>\n     normalized_nnf_match (import_protocols_from_ports m) \\<and> \\<not> has_disc disc (import_protocols_from_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m; \\<not> has_disc disc m;\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match\n                       (import_protocols_from_ports m) \\<and>\n                      \\<not> has_disc disc (import_protocols_from_ports m)", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_nnf_match m; \\<not> has_disc disc m;\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\n 2. \\<lbrakk>normalized_nnf_match m; \\<not> has_disc disc m;\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc (import_protocols_from_ports m)", "using import_protocols_from_ports_nnf"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  normalized_nnf_match (import_protocols_from_ports ?m)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_nnf_match m; \\<not> has_disc disc m;\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\n 2. \\<lbrakk>normalized_nnf_match m; \\<not> has_disc disc m;\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc (import_protocols_from_ports m)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m; \\<not> has_disc disc m;\n     \\<forall>a. \\<not> disc (Prot a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc (import_protocols_from_ports m)", "apply(erule(1) import_protocols_from_ports_erule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (MatchAnd\n (andfold_MatchExp\n   (map (Match \\<circ>\n         (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n     (getPos srcpts)))\n (andfold_MatchExp\n   (map (Match \\<circ>\n         (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n     (getPos dstpts))))\n                                     (alist_and'\n (NegPos_map Src_Ports srcpts @ NegPos_map Dst_Ports dstpts)))\n                                   rst2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts))) \\<and>\n                         \\<not> has_disc disc\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts))) \\<and>\n                         \\<not> has_disc disc\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts)) \\<and>\n                         \\<not> has_disc disc rst2", "apply(intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 4. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc rst2", "using andfold_MatchExp_not_disc_mapMatch[\n          where C=\"Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)\", simplified]"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     \\<not> ?disc\n             (Prot\n               (case a of\n                L4Ports proto x \\<Rightarrow>\n                  Proto proto)) \\<Longrightarrow>\n  \\<not> has_disc ?disc\n          (andfold_MatchExp\n            (map (Match \\<circ>\n                  (Prot \\<circ>\n                   case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n              ?ls))\n\ngoal (4 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 4. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc rst2", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc rst2", "using andfold_MatchExp_not_disc_mapMatch[\n         where C=\"Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)\", simplified]"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     \\<not> ?disc\n             (Prot\n               (case a of\n                L4Ports proto x \\<Rightarrow>\n                  Proto proto)) \\<Longrightarrow>\n  \\<not> has_disc ?disc\n          (andfold_MatchExp\n            (map (Match \\<circ>\n                  (Prot \\<circ>\n                   case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n              ?ls))\n\ngoal (3 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc rst2", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc rst2", "subgoal for srcpts rst1 dstpts rst2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply(frule(2) primitive_extractor_reassemble_not_has_disc[OF wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc disc\n             (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply(subgoal_tac \"\\<not> has_disc disc rst1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc disc (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc disc rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))\n 2. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc disc\n             (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc rst1", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc disc\n             (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc rst1\n 2. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc disc (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc disc rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply(drule(1) primitive_extractor_correct(4)[OF _ wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc disc (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<forall>disc2.\n        \\<not> has_disc disc2 m \\<longrightarrow>\n        \\<not> has_disc disc2 rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc rst1\n 2. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc disc (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc disc rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc disc (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc disc rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply(drule(2) primitive_extractor_reassemble_not_has_disc[OF wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst2;\n     \\<not> has_disc disc (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc disc rst1;\n     \\<not> has_disc disc\n             (alist_and' (NegPos_map Dst_Ports dstpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "using has_disc_alist_and'_append"], ["proof (prove)\nusing this:\n  has_disc ?disc' (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (has_disc ?disc' (alist_and' ?ls1.0) \\<or>\n   has_disc ?disc' (alist_and' ?ls2.0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst2;\n     \\<not> has_disc disc (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc disc rst1;\n     \\<not> has_disc disc\n             (alist_and' (NegPos_map Dst_Ports dstpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc rst2", "apply(drule(1) primitive_extractor_correct(4)[OF _ wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2;\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst1\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc rst2", "apply(drule(1) primitive_extractor_correct(4)[OF _ wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst2;\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 rst1;\n        \\<forall>disc2.\n           \\<not> has_disc disc2 rst1 \\<longrightarrow>\n           \\<not> has_disc disc2 rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc rst2", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma import_protocols_from_ports_hasdisc_negated:\n    \"\\<not> has_disc_negated disc False m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow>\n     normalized_nnf_match (import_protocols_from_ports m) \\<and>\n     \\<not> has_disc_negated disc False (import_protocols_from_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match\n                       (import_protocols_from_ports m) \\<and>\n                      \\<not> has_disc_negated disc False\n                              (import_protocols_from_ports m)", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\n 2. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (import_protocols_from_ports m)", "using import_protocols_from_ports_nnf"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  normalized_nnf_match (import_protocols_from_ports ?m)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\n 2. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (import_protocols_from_ports m)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (import_protocols_from_ports m)", "apply(erule(1) import_protocols_from_ports_erule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (MatchAnd\n                                   (MatchAnd\n                                     (MatchAnd\n (andfold_MatchExp\n   (map (Match \\<circ>\n         (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n     (getPos srcpts)))\n (andfold_MatchExp\n   (map (Match \\<circ>\n         (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n     (getPos dstpts))))\n                                     (alist_and'\n (NegPos_map Src_Ports srcpts @ NegPos_map Dst_Ports dstpts)))\n                                   rst2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts))) \\<and>\n                         \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts))) \\<and>\n                         \\<not> has_disc_negated disc False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts)) \\<and>\n                         \\<not> has_disc_negated disc False rst2", "apply(intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 4. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst2", "using andfold_MatchExp_not_disc_negated_mapMatch[\n          where C=\"Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)\", simplified]"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated ?disc False\n          (andfold_MatchExp\n            (map (Match \\<circ>\n                  (Prot \\<circ>\n                   case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n              ?ls))\n\ngoal (4 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos srcpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 4. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst2", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst2", "using andfold_MatchExp_not_disc_negated_mapMatch[\n         where C=\"Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)\", simplified]"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated ?disc False\n          (andfold_MatchExp\n            (map (Match \\<circ>\n                  (Prot \\<circ>\n                   case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n              ?ls))\n\ngoal (3 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (andfold_MatchExp\n                                   (map (Match \\<circ>\n   (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                     (getPos dstpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst2", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (alist_and'\n                                   (NegPos_map Src_Ports srcpts @\n                                    NegPos_map Dst_Ports dstpts))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst2", "subgoal for srcpts rst1 dstpts rst2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply(frule(2) primitive_extractor_reassemble_not_has_disc_negated[OF wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply(subgoal_tac \"\\<not> has_disc_negated disc False rst1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc_negated disc False rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))\n 2. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False rst1", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False rst1\n 2. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc_negated disc False rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply(drule(1) primitive_extractor_correct(6)[OF _ wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a);\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<forall>disc2.\n        \\<not> has_disc_negated disc2 ?neg5 m \\<longrightarrow>\n        \\<not> has_disc_negated disc2 ?neg5 rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False rst1\n 2. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc_negated disc False rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc_negated disc False rst1\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "apply(drule(2) primitive_extractor_reassemble_not_has_disc_negated[OF wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc_negated disc False rst1;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Dst_Ports dstpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "using has_disc_negated_alist_and'_append"], ["proof (prove)\nusing this:\n  has_disc_negated ?disc' ?neg (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (has_disc_negated ?disc' ?neg (alist_and' ?ls1.0) \\<or>\n   has_disc_negated ?disc' ?neg (alist_and' ?ls2.0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst2;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<not> has_disc_negated disc False rst1;\n     \\<not> has_disc_negated disc False\n             (alist_and' (NegPos_map Dst_Ports dstpts))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts))", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst2", "apply(drule(1) primitive_extractor_correct(6)[OF _ wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2;\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 (?neg41 srcpts rst1 dstpts rst2)\n                   m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 (?neg41 srcpts rst1 dstpts rst2)\n                   rst1\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst2", "apply(drule(1) primitive_extractor_correct(6)[OF _ wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>\\<not> has_disc_negated disc False m;\n        \\<forall>a. \\<not> disc (Prot a);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst2;\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 (?neg41 srcpts rst1 dstpts rst2)\n                   m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 (?neg41 srcpts rst1 dstpts rst2)\n                   rst1;\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 (?neg44 srcpts rst1 dstpts rst2)\n                   rst1 \\<longrightarrow>\n           \\<not> has_disc_negated disc2 (?neg44 srcpts rst1 dstpts rst2)\n                   rst2\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False rst2", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma import_protocols_from_ports_preserves_normalized_n_primitive:\n    \"normalized_n_primitive (disc, sel) f m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow>\n     normalized_nnf_match (import_protocols_from_ports m) \\<and> normalized_n_primitive (disc, sel) f (import_protocols_from_ports m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match\n                       (import_protocols_from_ports m) \\<and>\n                      normalized_n_primitive (disc, sel) f\n                       (import_protocols_from_ports m)", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\n 2. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (import_protocols_from_ports m)", "using import_protocols_from_ports_nnf"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  normalized_nnf_match (import_protocols_from_ports ?m)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match (import_protocols_from_ports m)\n 2. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (import_protocols_from_ports m)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (import_protocols_from_ports m)", "apply(erule(1) import_protocols_from_ports_erule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                          (MatchAnd\n                            (MatchAnd\n                              (MatchAnd\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos srcpts)))\n                                (andfold_MatchExp\n                                  (map (Match \\<circ>\n  (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n                                    (getPos dstpts))))\n                              (alist_and'\n                                (NegPos_map Src_Ports srcpts @\n                                 NegPos_map Dst_Ports dstpts)))\n                            rst2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos srcpts))) \\<and>\n                         normalized_n_primitive (disc, sel) f\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos dstpts))) \\<and>\n                         normalized_n_primitive (disc, sel) f\n                          (alist_and'\n                            (NegPos_map Src_Ports srcpts @\n                             NegPos_map Dst_Ports dstpts)) \\<and>\n                         normalized_n_primitive (disc, sel) f rst2", "apply(intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos srcpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos dstpts)))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                          (alist_and'\n                            (NegPos_map Src_Ports srcpts @\n                             NegPos_map Dst_Ports dstpts))\n 4. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst2", "subgoal for srcpts rst1 dstpts rst2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (andfold_MatchExp\n                         (map (Match \\<circ>\n                               (Prot \\<circ>\n                                case_ipt_l4_ports\n                                 (\\<lambda>proto x. Proto proto)))\n                           (getPos srcpts)))", "apply(rule andfold_MatchExp_normalized_n_primitive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set\n(map (Match \\<circ>\n      (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n  (getPos srcpts)).\n                         normalized_n_primitive (disc, sel) f m", "using normalized_n_primitive_impossible_map"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> ?disc (?C a) \\<Longrightarrow>\n  \\<forall>m\\<in>set (map (Match \\<circ> (?C \\<circ> ?x)) ?ls).\n     normalized_n_primitive (?disc, ?sel) ?f m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set\n(map (Match \\<circ>\n      (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n  (getPos srcpts)).\n                         normalized_n_primitive (disc, sel) f m", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                          (andfold_MatchExp\n                            (map (Match \\<circ>\n                                  (Prot \\<circ>\n                                   case_ipt_l4_ports\n                                    (\\<lambda>proto x. Proto proto)))\n                              (getPos dstpts)))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                          (alist_and'\n                            (NegPos_map Src_Ports srcpts @\n                             NegPos_map Dst_Ports dstpts))\n 3. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst2", "subgoal for srcpts rst1 dstpts rst2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (andfold_MatchExp\n                         (map (Match \\<circ>\n                               (Prot \\<circ>\n                                case_ipt_l4_ports\n                                 (\\<lambda>proto x. Proto proto)))\n                           (getPos dstpts)))", "apply(rule andfold_MatchExp_normalized_n_primitive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set\n(map (Match \\<circ>\n      (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n  (getPos dstpts)).\n                         normalized_n_primitive (disc, sel) f m", "using normalized_n_primitive_impossible_map"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> ?disc (?C a) \\<Longrightarrow>\n  \\<forall>m\\<in>set (map (Match \\<circ> (?C \\<circ> ?x)) ?ls).\n     normalized_n_primitive (?disc, ?sel) ?f m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set\n(map (Match \\<circ>\n      (Prot \\<circ> case_ipt_l4_ports (\\<lambda>proto x. Proto proto)))\n  (getPos dstpts)).\n                         normalized_n_primitive (disc, sel) f m", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                          (alist_and'\n                            (NegPos_map Src_Ports srcpts @\n                             NegPos_map Dst_Ports dstpts))\n 2. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst2", "subgoal for srcpts rst1 dstpts rst2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (alist_and'\n                         (NegPos_map Src_Ports srcpts @\n                          NegPos_map Dst_Ports dstpts))", "apply(frule(2) primitive_extractor_reassemble_normalized_n_primitive[OF wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (alist_and'\n                         (NegPos_map Src_Ports srcpts @\n                          NegPos_map Dst_Ports dstpts))", "apply(subgoal_tac \"normalized_n_primitive (disc, sel) f rst1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts));\n     normalized_n_primitive (disc, sel) f rst1\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (alist_and'\n                         (NegPos_map Src_Ports srcpts @\n                          NegPos_map Dst_Ports dstpts))\n 2. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst1", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst1\n 2. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts));\n     normalized_n_primitive (disc, sel) f rst1\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (alist_and'\n                         (NegPos_map Src_Ports srcpts @\n                          NegPos_map Dst_Ports dstpts))", "apply(drule(1) primitive_extractor_correct(5)[OF _ wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a);\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts));\n     \\<forall>disc2 sel2.\n        normalized_n_primitive (disc2, sel2) ?P5 m \\<longrightarrow>\n        normalized_n_primitive (disc2, sel2) ?P5 rst1\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst1\n 2. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts));\n     normalized_n_primitive (disc, sel) f rst1\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (alist_and'\n                         (NegPos_map Src_Ports srcpts @\n                          NegPos_map Dst_Ports dstpts))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst1; normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts));\n     normalized_n_primitive (disc, sel) f rst1\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (alist_and'\n                         (NegPos_map Src_Ports srcpts @\n                          NegPos_map Dst_Ports dstpts))", "apply(drule(2) primitive_extractor_reassemble_normalized_n_primitive[OF wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts));\n     normalized_n_primitive (disc, sel) f rst1;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Dst_Ports dstpts))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (alist_and'\n                         (NegPos_map Src_Ports srcpts @\n                          NegPos_map Dst_Ports dstpts))", "using normalized_n_primitive_alist_and'_append"], ["proof (prove)\nusing this:\n  normalized_n_primitive (?disc, ?sel) ?f (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (normalized_n_primitive (?disc, ?sel) ?f (alist_and' ?ls1.0) \\<and>\n   normalized_n_primitive (?disc, ?sel) ?f (alist_and' ?ls2.0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     primitive_extractor (is_Src_Ports, src_ports_sel) m = (srcpts, rst1);\n     primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n     (dstpts, rst2);\n     normalized_nnf_match rst2;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Src_Ports srcpts));\n     normalized_n_primitive (disc, sel) f rst1;\n     normalized_n_primitive (disc, sel) f\n      (alist_and' (NegPos_map Dst_Ports dstpts))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f\n                       (alist_and'\n                         (NegPos_map Src_Ports srcpts @\n                          NegPos_map Dst_Ports dstpts))", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst2", "apply(drule(1) primitive_extractor_correct(5)[OF _ wf_disc_sel_common_primitive(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst1; normalized_nnf_match rst2;\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2)\n            (?P17 srcpts rst1 dstpts rst2) m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2)\n            (?P17 srcpts rst1 dstpts rst2) rst1\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst2", "apply(drule(1) primitive_extractor_correct(5)[OF _ wf_disc_sel_common_primitive(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>srcpts rst1 dstpts rst2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (Prot a);\n        primitive_extractor (is_Src_Ports, src_ports_sel) m =\n        (srcpts, rst1);\n        primitive_extractor (is_Dst_Ports, dst_ports_sel) rst1 =\n        (dstpts, rst2);\n        normalized_nnf_match rst2;\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2)\n            (?P17 srcpts rst1 dstpts rst2) m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2)\n            (?P17 srcpts rst1 dstpts rst2) rst1;\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2)\n            (?P20 srcpts rst1 dstpts rst2) rst1 \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2)\n            (?P20 srcpts rst1 dstpts rst2) rst2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f rst2", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Putting things together\\<close>"], ["", "definition compress_normalize_protocols\n    :: \"'i::len common_primitive match_expr \\<Rightarrow> 'i common_primitive match_expr option\" where \n    \"compress_normalize_protocols m \\<equiv> compress_normalize_protocols_step (import_protocols_from_ports m)\""], ["", "lemma (in primitive_matcher_generic) compress_normalize_protocols_Some:\n  assumes \"normalized_nnf_match m\" and \"compress_normalize_protocols m = Some m'\"\n    shows \"matches (\\<beta>, \\<alpha>) m' a p \\<longleftrightarrow> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) m' a p = matches (\\<beta>, \\<alpha>) m a p", "using assms"], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  compress_normalize_protocols m = Some m'\n\ngoal (1 subgoal):\n 1. matches (\\<beta>, \\<alpha>) m' a p = matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: compress_normalize_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> matches (\\<beta>, \\<alpha>) m' a p =\n                      matches (\\<beta>, \\<alpha>) m a p", "by (metis import_protocols_from_ports import_protocols_from_ports_nnf\n            compress_normalize_protocols_step_Some)"], ["", "lemma (in primitive_matcher_generic) compress_normalize_protocols_None:\n  assumes \"normalized_nnf_match m\" and \"compress_normalize_protocols m = None\"\n    shows \"\\<not> matches (\\<beta>, \\<alpha>) m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> matches (\\<beta>, \\<alpha>) m a p", "using assms"], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  compress_normalize_protocols m = None\n\ngoal (1 subgoal):\n 1. \\<not> matches (\\<beta>, \\<alpha>) m a p", "apply(simp add: compress_normalize_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     None\\<rbrakk>\n    \\<Longrightarrow> \\<not> matches (\\<beta>, \\<alpha>) m a p", "by (metis import_protocols_from_ports import_protocols_from_ports_nnf\n            compress_normalize_protocols_step_None)"], ["", "lemma compress_normalize_protocols_nnf:\n    \"normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols m = Some m' \\<Longrightarrow>\n      normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_protocols m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m'", "apply(simp add: compress_normalize_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m'", "by (metis import_protocols_from_ports_nnf compress_normalize_protocols_step_nnf)"], ["", "lemma compress_normalize_protocols_not_introduces_Prot_negated:\n    assumes notdisc: \"\\<not> has_disc_negated is_Prot False m\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_protocols m = Some m'\"\n     shows \"\\<not> has_disc_negated is_Prot False m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Prot False m'", "using assms"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated is_Prot False m\n  normalized_nnf_match m\n  compress_normalize_protocols m = Some m'\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated is_Prot False m'", "apply(simp add: compress_normalize_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n     normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated is_Prot False m'", "using import_protocols_from_ports_nnf\n          import_protocols_from_ports_not_introduces_Prot_negated\n          compress_normalize_protocols_step_not_introduces_Prot_negated"], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  normalized_nnf_match (import_protocols_from_ports ?m)\n  \\<lbrakk>normalized_nnf_match ?m;\n   \\<not> has_disc_negated is_Prot False ?m\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc_negated is_Prot False\n                            (import_protocols_from_ports ?m)\n  \\<lbrakk>\\<not> has_disc_negated is_Prot False ?m;\n   normalized_nnf_match ?m;\n   compress_normalize_protocols_step ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc_negated is_Prot False ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated is_Prot False m;\n     normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated is_Prot False m'", "by auto"], ["", "lemma compress_normalize_protocols_hasdisc:\n    \"\\<not> has_disc disc m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> \\<not> has_disc disc m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     compress_normalize_protocols m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and> \\<not> has_disc disc m'", "apply(simp add: compress_normalize_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and> \\<not> has_disc disc m'", "using import_protocols_from_ports_hasdisc\n          compress_normalize_protocols_step_hasdisc"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m; \\<not> has_disc ?disc ?m;\n   \\<forall>a. \\<not> ?disc (Prot a)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match\n                     (import_protocols_from_ports ?m) \\<and>\n                    \\<not> has_disc ?disc (import_protocols_from_ports ?m)\n  \\<lbrakk>\\<not> has_disc ?disc ?m; \\<forall>a. \\<not> ?disc (Prot a);\n   normalized_nnf_match ?m;\n   compress_normalize_protocols_step ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m' \\<and>\n                    \\<not> has_disc ?disc ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m; \\<forall>a. \\<not> disc (Prot a);\n     normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and> \\<not> has_disc disc m'", "by blast"], ["", "lemma compress_normalize_protocols_hasdisc_negated:\n    \"\\<not> has_disc_negated disc False m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow>\n     normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc False m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      \\<not> has_disc_negated disc False m'", "(*original lemma allowed arbitrary neg*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      \\<not> has_disc_negated disc False m'", "apply(simp add: compress_normalize_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      \\<not> has_disc_negated disc False m'", "apply(frule(2) import_protocols_from_ports_hasdisc_negated)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m';\n     normalized_nnf_match (import_protocols_from_ports m) \\<and>\n     \\<not> has_disc_negated disc False\n             (import_protocols_from_ports m)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      \\<not> has_disc_negated disc False m'", "using compress_normalize_protocols_step_hasdisc_negated"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> has_disc_negated ?disc ?neg ?m;\n   \\<forall>a. \\<not> ?disc (Prot a); normalized_nnf_match ?m;\n   compress_normalize_protocols_step ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m' \\<and>\n                    \\<not> has_disc_negated ?disc ?neg ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc False m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m';\n     normalized_nnf_match (import_protocols_from_ports m) \\<and>\n     \\<not> has_disc_negated disc False\n             (import_protocols_from_ports m)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      \\<not> has_disc_negated disc False m'", "by blast"], ["", "lemma compress_normalize_protocols_preserves_normalized_n_primitive:\n    \"normalized_n_primitive (disc, sel) P m \\<Longrightarrow> (\\<forall>a. \\<not> disc (Prot a)) \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> compress_normalize_protocols m = Some m' \\<Longrightarrow>\n     normalized_nnf_match m' \\<and> normalized_n_primitive (disc, sel) P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) P m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      normalized_n_primitive (disc, sel) P m'", "apply(simp add: compress_normalize_protocols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) P m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      normalized_n_primitive (disc, sel) P m'", "using import_protocols_from_ports_preserves_normalized_n_primitive\n          compress_normalize_protocols_step_preserves_normalized_n_primitive"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_n_primitive (?disc, ?sel) ?f ?m;\n   \\<forall>a. \\<not> ?disc (Prot a); normalized_nnf_match ?m\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match\n                     (import_protocols_from_ports ?m) \\<and>\n                    normalized_n_primitive (?disc, ?sel) ?f\n                     (import_protocols_from_ports ?m)\n  \\<lbrakk>normalized_n_primitive (?disc, ?sel) ?P ?m;\n   \\<forall>a. \\<not> ?disc (Prot a); normalized_nnf_match ?m;\n   compress_normalize_protocols_step ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m' \\<and>\n                    normalized_n_primitive (?disc, ?sel) ?P ?m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) P m;\n     \\<forall>a. \\<not> disc (Prot a); normalized_nnf_match m;\n     compress_normalize_protocols_step (import_protocols_from_ports m) =\n     Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m' \\<and>\n                      normalized_n_primitive (disc, sel) P m'", "by blast"], ["", "lemma \"case compress_normalize_protocols \n    (MatchAnd (MatchAnd (MatchAnd (Match ((Prot (Proto TCP)):: 32 common_primitive)) (MatchNot (Match (Prot (Proto UDP))))) (Match (IIface (Iface ''eth1''))))\n              (Match (Prot (Proto TCP)))) of Some ps \\<Rightarrow> opt_MatchAny_match_expr ps\n  =\n  MatchAnd (Match (Prot (Proto 6))) (Match (IIface (Iface ''eth1'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case compress_normalize_protocols\n          (MatchAnd\n            (MatchAnd\n              (MatchAnd (Match (Prot (Proto TCP)))\n                (MatchNot (Match (Prot (Proto UDP)))))\n              (Match (IIface (Iface ''eth1''))))\n            (Match (Prot (Proto TCP)))) of\n    Some ps \\<Rightarrow>\n      opt_MatchAny_match_expr ps =\n      MatchAnd (Match (Prot (Proto 6))) (Match (IIface (Iface ''eth1'')))", "by eval"], ["", "(*too many MatchAny!*)"], ["", "value[code] \"compress_normalize_protocols (MatchAny:: 32 common_primitive match_expr)\""], ["", "end"]]}