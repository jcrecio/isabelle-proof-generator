{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Semantics_Ternary/Primitive_Normalization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma \"\\<not> has_disc_negated (\\<lambda>x::nat. x = 0) False (MatchAnd (Match 0) (MatchNot (Match 1)))\"", "lemma \"has_disc_negated (\\<lambda>x::nat. x = 0) False (MatchAnd (Match 0) (MatchNot (Match 0)))\"", "lemma \"has_disc_negated (\\<lambda>x::nat. x = 0) True (MatchAnd (Match 0) (MatchNot (Match 1)))\"", "lemma \"\\<not> has_disc_negated (\\<lambda>x::nat. x = 0) True (MatchAnd (Match 1) (MatchNot (Match 0)))\"", "lemma \"has_disc_negated (\\<lambda>x::nat. x = 0) True (MatchAnd (Match 0) (MatchNot (Match 0)))\"", "lemma has_disc_negated_MatchNot:\n  \"has_disc_negated disc True (MatchNot m) \\<longleftrightarrow> has_disc_negated disc False m\"\n  \"has_disc_negated disc True m \\<longleftrightarrow> has_disc_negated disc False (MatchNot m)\"", "lemma has_disc_negated_has_disc: \"has_disc_negated disc neg m \\<Longrightarrow> has_disc disc m\"", "lemma has_disc_negated_positiv_has_disc: \"has_disc_negated disc neg m \\<or> has_disc_negated disc (\\<not> neg) m \\<longleftrightarrow> has_disc disc m\"", "lemma has_disc_negated_disj_split: \n    \"has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg m \\<longleftrightarrow> has_disc_negated P neg m \\<or> has_disc_negated Q neg m\"", "lemma has_disc_alist_and: \"has_disc disc (alist_and as) \\<longleftrightarrow> (\\<exists> a \\<in> set as. has_disc disc (negation_type_to_match_expr a))\"", "lemma has_disc_negated_alist_and: \"has_disc_negated disc neg (alist_and as) \\<longleftrightarrow> (\\<exists> a \\<in> set as. has_disc_negated disc neg (negation_type_to_match_expr a))\"", "lemma has_disc_alist_and': \"has_disc disc (alist_and' as) \\<longleftrightarrow> (\\<exists> a \\<in> set as. has_disc disc (negation_type_to_match_expr a))\"", "lemma has_disc_negated_alist_and': \"has_disc_negated disc neg (alist_and' as) \\<longleftrightarrow> (\\<exists> a \\<in> set as. has_disc_negated disc neg (negation_type_to_match_expr a))\"", "lemma has_disc_alist_and'_append:\n  \"has_disc disc' (alist_and' (ls1 @ ls2)) \\<longleftrightarrow>\n      has_disc disc' (alist_and' ls1) \\<or> has_disc disc' (alist_and' ls2)\"", "lemma has_disc_negated_alist_and'_append:\n  \"has_disc_negated disc' neg (alist_and' (ls1 @ ls2)) \\<longleftrightarrow>\n      has_disc_negated disc' neg (alist_and' ls1) \\<or> has_disc_negated disc' neg (alist_and' ls2)\"", "lemma match_list_to_match_expr_not_has_disc: \n    \"\\<forall>a. \\<not> disc (X a) \\<Longrightarrow> \\<not> has_disc disc (match_list_to_match_expr (map (Match \\<circ> X) ls))\"", "lemma \"matches ((\\<lambda>x _. bool_to_ternary (disc x)), (\\<lambda>_ _. False)) (Match x) a p \\<longleftrightarrow> has_disc disc (Match x)\"", "lemma normalized_nnf_match_opt_MatchAny_match_expr:\n  \"normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match (opt_MatchAny_match_expr m)\"", "lemma normalized_n_primitive_opt_MatchAny_match_expr:\n  \"normalized_n_primitive disc_sel f m \\<Longrightarrow> normalized_n_primitive disc_sel f (opt_MatchAny_match_expr m)\"", "lemma normalized_n_primitive_imp_not_disc_negated:\n  \"wf_disc_sel (disc,sel) C \\<Longrightarrow> normalized_n_primitive (disc,sel) f m \\<Longrightarrow> \\<not> has_disc_negated disc False m\"", "lemma normalized_n_primitive_alist_and: \"normalized_n_primitive disc_sel P (alist_and as) \\<longleftrightarrow>\n      (\\<forall> a \\<in> set as. normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\"", "lemma normalized_n_primitive_alist_and': \"normalized_n_primitive disc_sel P (alist_and' as) \\<longleftrightarrow>\n      (\\<forall> a \\<in> set as. normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\"", "lemma not_has_disc_NegPos_map: \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> \\<forall>a\\<in>set (NegPos_map C ls).\n        \\<not> has_disc disc (negation_type_to_match_expr a)\"", "lemma not_has_disc_negated_NegPos_map: \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> \\<forall>a\\<in>set (NegPos_map C ls).\n        \\<not> has_disc_negated disc False (negation_type_to_match_expr a)\"", "lemma normalized_n_primitive_impossible_map: \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow>\n  \\<forall>m\\<in>set (map (Match \\<circ> (C \\<circ> x)) ls).\n     normalized_n_primitive (disc, sel) f m\"", "lemma normalized_n_primitive_alist_and'_append:\n  \"normalized_n_primitive (disc, sel) f (alist_and' (ls1 @ ls2)) \\<longleftrightarrow>\n      normalized_n_primitive (disc, sel) f (alist_and' ls1) \\<and> normalized_n_primitive (disc, sel) f (alist_and' ls2)\"", "lemma normalized_n_primitive_if_no_primitive: \"normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc disc m \\<Longrightarrow> \n       normalized_n_primitive (disc, sel) f m\"", "lemma normalized_n_primitive_false_eq_notdisc: \"normalized_nnf_match m \\<Longrightarrow>\n  normalized_n_primitive (disc, sel) (\\<lambda>_. False) m \\<longleftrightarrow> \\<not> has_disc disc m\"", "lemma normalized_n_primitive_MatchAnd_combine_map: \"normalized_n_primitive disc_sel f rst \\<Longrightarrow>\n       \\<forall>m' \\<in> (\\<lambda>spt. Match (C spt)) ` set pts. normalized_n_primitive disc_sel f m' \\<Longrightarrow>\n        m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) ` set pts \\<Longrightarrow> normalized_n_primitive disc_sel f m'\"", "lemma primitive_extractor_fst_simp2:\n  fixes m'::\"'a match_expr \\<Rightarrow> 'a match_expr \\<Rightarrow> 'a match_expr\"\n  shows \"fst (case primitive_extractor (disc, sel) m1 of (a1', ms1') \\<Rightarrow> case primitive_extractor (disc, sel) m2 of (a2', ms2') \\<Rightarrow> (a1' @ a2', m' ms1' ms2')) =\n           fst (primitive_extractor (disc, sel) m1) @ fst (primitive_extractor (disc, sel) m2)\"", "theorem primitive_extractor_correct: assumes \n  \"normalized_nnf_match m\" and \"wf_disc_sel (disc, sel) C\" and \"primitive_extractor (disc, sel) m = (as, ms)\" \n  shows \"matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and> matches \\<gamma> ms a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n  and \"normalized_nnf_match ms\"\n  and \"\\<not> has_disc disc ms\"\n  and \"\\<forall>disc2. \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\"\n  and \"\\<forall>disc2 sel2. normalized_n_primitive (disc2, sel2) P m \\<longrightarrow> normalized_n_primitive (disc2, sel2) P ms\"\n  and \"\\<forall>disc2. \\<not> has_disc_negated disc2 neg m \\<longrightarrow> \\<not> has_disc_negated disc2 neg ms\"\n  and \"\\<not> has_disc disc m \\<longleftrightarrow> as = [] \\<and> ms = m\"\n  and \"\\<not> has_disc_negated disc False m \\<longleftrightarrow> getNeg as = []\"\n  and \"has_disc disc m \\<Longrightarrow> as \\<noteq> []\"", "lemma has_disc_negated_primitive_extractor:\n  assumes \"normalized_nnf_match m\"\n  shows \"has_disc_negated disc False m \\<longleftrightarrow> (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))\"", "lemma primitive_extractor_reassemble_preserves:\n  \"wf_disc_sel (disc, sel) C \\<Longrightarrow>\n   normalized_nnf_match m \\<Longrightarrow>\n   P m \\<Longrightarrow>\n   P MatchAny \\<Longrightarrow>\n   primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow> \\<comment> \\<open>turn eqality around to simplify proof\\<close>\n   (\\<And>m1 m2. P (MatchAnd m1 m2) \\<longleftrightarrow> P m1 \\<and> P m2) \\<Longrightarrow>\n   (\\<And>ls1 ls2. P (alist_and' (ls1 @ ls2)) \\<longleftrightarrow> P (alist_and' ls1) \\<and> P (alist_and' ls2)) \\<Longrightarrow>\n   P (alist_and' (NegPos_map C as))\"", "lemma primitive_extractor_reassemble_not_has_disc:\n  \"wf_disc_sel (disc, sel) C \\<Longrightarrow>\n   normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc disc' m \\<Longrightarrow>\n   primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n     \\<not> has_disc disc' (alist_and' (NegPos_map C as))\"", "lemma primitive_extractor_reassemble_not_has_disc_negated:\n  \"wf_disc_sel (disc, sel) C \\<Longrightarrow>\n   normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated disc' neg m \\<Longrightarrow>\n   primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow> \n     \\<not> has_disc_negated disc' neg (alist_and' (NegPos_map C as))\"", "lemma primitive_extractor_reassemble_normalized_n_primitive:\n  \"wf_disc_sel (disc, sel) C \\<Longrightarrow>\n   normalized_nnf_match m \\<Longrightarrow> normalized_n_primitive (disc1, sel1) f m \\<Longrightarrow>\n   primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n     normalized_n_primitive (disc1, sel1) f (alist_and' (NegPos_map C as))\"", "lemma primitive_extractor_matchesE: \"wf_disc_sel (disc,sel) C \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> primitive_extractor (disc, sel) m = (as, ms)\n  \\<Longrightarrow>\n  (normalized_nnf_match ms \\<Longrightarrow> \\<not> has_disc disc ms \\<Longrightarrow> (\\<forall>disc2. \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms) \\<Longrightarrow> matches_other \\<longleftrightarrow>  matches \\<gamma> ms a p)\n  \\<Longrightarrow>\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and> matches_other \\<longleftrightarrow>  matches \\<gamma> m a p\"", "lemma primitive_extractor_matches_lastE: \"wf_disc_sel (disc,sel) C \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> primitive_extractor (disc, sel) m = (as, ms)\n  \\<Longrightarrow>\n  (normalized_nnf_match ms \\<Longrightarrow> \\<not> has_disc disc ms \\<Longrightarrow> (\\<forall>disc2. \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms) \\<Longrightarrow> matches \\<gamma> ms a p)\n  \\<Longrightarrow>\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p  \\<longleftrightarrow>  matches \\<gamma> m a p\"", "lemma normalize_primitive_extract: assumes \"normalized_nnf_match m\" and \"wf_disc_sel disc_sel C\" and\n        \"\\<forall>ml. (match_list \\<gamma> (map (Match \\<circ> C) (f ml)) a p \\<longleftrightarrow> matches \\<gamma> (alist_and (NegPos_map C ml)) a p)\"\n        shows \"match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p \\<longleftrightarrow> matches \\<gamma> m a p\"", "lemma normalize_primitive_extract_preserves_nnf_normalized:\n  assumes \"normalized_nnf_match m\"\n      and \"wf_disc_sel (disc, sel) C\"\n    shows \"\\<forall>mn \\<in> set (normalize_primitive_extract (disc, sel) C f m). normalized_nnf_match mn\"", "lemma normalize_rules_primitive_extract_preserves_nnf_normalized:\n    \"\\<forall>r \\<in> set rs. normalized_nnf_match (get_match r) \\<Longrightarrow> wf_disc_sel disc_sel C \\<Longrightarrow>\n     \\<forall>r \\<in> set (normalize_rules (normalize_primitive_extract disc_sel C f) rs). normalized_nnf_match (get_match r)\"", "lemma normalize_primitive_extract_preserves_unrelated_normalized_n_primitive:\n  assumes \"normalized_nnf_match m\"\n      and \"normalized_n_primitive (disc2, sel2) P m\"\n      and \"wf_disc_sel (disc1, sel1) C\"\n      and \"\\<forall>a. \\<not> disc2 (C a)\" \\<comment> \\<open>disc1 and disc2 match for different stuff. e.g. @{text Src_Ports} and @{text Dst_Ports}\\<close>\n    shows \"\\<forall>mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f m). normalized_n_primitive (disc2, sel2) P mn\"", "lemma normalize_primitive_extract_normalizes_n_primitive:\n  fixes disc::\"('a \\<Rightarrow> bool)\" and sel::\"('a \\<Rightarrow> 'b)\" and f::\"('b negation_type list \\<Rightarrow> 'b list)\"\n  assumes \"normalized_nnf_match m\"\n      and \"wf_disc_sel (disc, sel) C\"\n      and np: \"\\<forall>as. (\\<forall> a' \\<in> set (f as). P a')\" (*not quite, sel f   \\<forall>as \\<in> {x. disc (v x)}. *)\n    shows \"\\<forall>m' \\<in> set (normalize_primitive_extract (disc, sel) C f m). normalized_n_primitive (disc, sel) P m'\"", "lemma primitive_extractor_negation_type_matching1:\n    assumes wf: \"wf_disc_sel (disc, sel) C\"\n        and normalized: \"normalized_nnf_match m\"\n        and a1: \"primitive_extractor (disc, sel) m = (as, rest)\"\n        and a2: \"matches \\<gamma> m a p\"\n    shows \"(\\<forall>m\\<in>set (map C (getPos as)). matches \\<gamma> (Match m) a p) \\<and> \n           (\\<forall>m\\<in>set (map C (getNeg as)). matches \\<gamma> (MatchNot (Match m)) a p)\"", "lemma \"\\<exists>m. normalized_n_primitive disc_sel f m \\<longrightarrow> \\<not> normalized_nnf_match m\"", "lemma remove_unknowns_generic_not_has_disc: \"\\<not> has_disc C m \\<Longrightarrow> \\<not> has_disc C (remove_unknowns_generic \\<gamma> a m)\"", "lemma remove_unknowns_generic_not_has_disc_negated: \"\\<not> has_disc_negated C neg m \\<Longrightarrow> \\<not> has_disc_negated C neg (remove_unknowns_generic \\<gamma> a m)\"", "lemma remove_unknowns_generic_normalized_n_primitive: \"normalized_n_primitive disc_sel f m \\<Longrightarrow> \n    normalized_n_primitive disc_sel f (remove_unknowns_generic \\<gamma> a m)\"", "lemma normalize_match_preserves_disc_negated: \n    shows \"(\\<exists>m_DNF \\<in> set (normalize_match m). has_disc_negated disc neg m_DNF) \\<Longrightarrow> has_disc_negated disc neg m\"", "lemma not_has_disc_opt_MatchAny_match_expr:\n  \"\\<not> has_disc disc m \\<Longrightarrow> \\<not> has_disc disc (opt_MatchAny_match_expr m)\"", "lemma not_has_disc_negated_opt_MatchAny_match_expr:\n  \"\\<not> has_disc_negated disc neg m \\<Longrightarrow> \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr m)\"", "lemma normalize_match_preserves_nodisc:\n  \"\\<not> has_disc disc m \\<Longrightarrow> m' \\<in> set (normalize_match m) \\<Longrightarrow> \\<not> has_disc disc m'\"", "lemma not_has_disc_normalize_match:\n  \"\\<not> has_disc_negated disc neg  m \\<Longrightarrow> m' \\<in> set (normalize_match m) \\<Longrightarrow> \\<not> has_disc_negated disc neg m'\"", "lemma normalize_match_preserves_normalized_n_primitive:\n  \"normalized_n_primitive disc_sel f rst \\<Longrightarrow>\n        \\<forall> m \\<in> set (normalize_match rst). normalized_n_primitive disc_sel f m\"", "lemma compress_normalize_primitive_nnf: \"wf_disc_sel disc_sel C \\<Longrightarrow> \n      normalized_nnf_match m \\<Longrightarrow> compress_normalize_primitive disc_sel C f m = Some m' \\<Longrightarrow>\n    normalized_nnf_match m'\"", "lemma compress_normalize_primitive_not_introduces_C:\n    assumes notdisc: \"\\<not> has_disc disc m\"\n        and wf: \"wf_disc_sel (disc,sel) C'\" (*C is allowed to be different from C'*)\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n        and f_preserves: \"\\<And>as_pos as_neg. f [] = Some (as_pos, as_neg) \\<Longrightarrow> as_pos = [] \\<and> as_neg = []\"\n     shows \"\\<not> has_disc disc m'\"", "lemma compress_normalize_primitive_not_introduces_C_negated:\n    assumes notdisc: \"\\<not> has_disc_negated disc False m\"\n        and wf: \"wf_disc_sel (disc,sel) C\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n        and f_preserves: \"\\<And>as as_pos as_neg. f as = Some (as_pos, as_neg) \\<Longrightarrow> getNeg as = [] \\<Longrightarrow> as_neg = []\"\n     shows \"\\<not> has_disc_negated disc False m'\"", "lemma compress_normalize_primitive_Some:\n  assumes normalized: \"normalized_nnf_match m\"\n      and wf: \"wf_disc_sel (disc,sel) C\"\n      and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n      and f_correct: \"\\<And>as as_pos as_neg. f as = Some (as_pos, as_neg) \\<Longrightarrow>\n            matches \\<gamma> (alist_and (NegPos_map C ((map Pos as_pos)@(map Neg as_neg)))) a p \\<longleftrightarrow>\n            matches \\<gamma> (alist_and (NegPos_map C as)) a p\"\n    shows \"matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p\"", "lemma compress_normalize_primitive_None:\n  assumes normalized: \"normalized_nnf_match m\"\n      and wf: \"wf_disc_sel (disc,sel) C\"\n      and none: \"compress_normalize_primitive (disc,sel) C f m = None\"\n      and f_correct: \"\\<And>as. f as = None \\<Longrightarrow> \\<not> matches \\<gamma> (alist_and (NegPos_map C as)) a p\"\n    shows \"\\<not> matches \\<gamma> m a p\"", "lemma compress_normalize_primitive_hasdisc:\n    assumes am: \"\\<not> has_disc disc2 m\"\n        and wf: \"wf_disc_sel (disc,sel) C\"\n        and disc: \"(\\<forall>a. \\<not> disc2 (C a))\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n     shows \"normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'\"", "lemma compress_normalize_primitive_hasdisc_negated:\n    assumes am: \"\\<not> has_disc_negated disc2 neg m\"\n        and wf: \"wf_disc_sel (disc,sel) C\"\n        and disc: \"(\\<forall>a. \\<not> disc2 (C a))\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n     shows \"normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'\"", "lemma compress_normalize_primitve_preserves_normalized_n_primitive:\n    assumes am: \"normalized_n_primitive (disc2, sel2) P m\"\n        and wf: \"wf_disc_sel (disc,sel) C\"\n        and disc: \"(\\<forall>a. \\<not> disc2 (C a))\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n     shows \"normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'\"", "lemma compress_normalize_primitive_monad: \n      assumes \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n          and \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> normalized_nnf_match m'\"\n          and \"normalized_nnf_match m\"\n          and \"(compress_normalize_primitive_monad fs m) = Some m'\"\n      shows \"matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p\" (is ?goal1)\n        and \"normalized_nnf_match m'\"              (is ?goal2)", "lemma compress_normalize_primitive_monad_None: \n      assumes \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n          and \"\\<And>m f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = None \\<Longrightarrow> \\<not> matches \\<gamma> m a p\"\n          and \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> normalized_nnf_match m'\"\n          and \"normalized_nnf_match m\"\n          and \"(compress_normalize_primitive_monad fs m) = None\"\n      shows \"\\<not> matches \\<gamma> m a p\"", "lemma compress_normalize_primitive_monad_preserves:\n      assumes \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> normalized_nnf_match m'\"\n          and \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> P m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> P m'\"\n          and \"normalized_nnf_match m\"\n          and \"P m\"\n          and \"(compress_normalize_primitive_monad fs m) = Some m'\"\n      shows \"normalized_nnf_match m' \\<and> P m'\""], "translations": [["", "lemma \"\\<not> has_disc_negated (\\<lambda>x::nat. x = 0) False (MatchAnd (Match 0) (MatchNot (Match 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated (\\<lambda>x. x = 0) False\n            (MatchAnd (Match 0) (MatchNot (Match 1)))", "by eval"], ["", "lemma \"has_disc_negated (\\<lambda>x::nat. x = 0) False (MatchAnd (Match 0) (MatchNot (Match 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated (\\<lambda>x. x = 0) False\n     (MatchAnd (Match 0) (MatchNot (Match 0)))", "by eval"], ["", "lemma \"has_disc_negated (\\<lambda>x::nat. x = 0) True (MatchAnd (Match 0) (MatchNot (Match 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated (\\<lambda>x. x = 0) True\n     (MatchAnd (Match 0) (MatchNot (Match 1)))", "by eval"], ["", "lemma \"\\<not> has_disc_negated (\\<lambda>x::nat. x = 0) True (MatchAnd (Match 1) (MatchNot (Match 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated (\\<lambda>x. x = 0) True\n            (MatchAnd (Match 1) (MatchNot (Match 0)))", "by eval"], ["", "lemma \"has_disc_negated (\\<lambda>x::nat. x = 0) True (MatchAnd (Match 0) (MatchNot (Match 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated (\\<lambda>x. x = 0) True\n     (MatchAnd (Match 0) (MatchNot (Match 0)))", "by eval\n\n\\<comment> \\<open>We want false on the right hand side, because this is how the algorithm should be started\\<close>"], ["", "lemma has_disc_negated_MatchNot:\n  \"has_disc_negated disc True (MatchNot m) \\<longleftrightarrow> has_disc_negated disc False m\"\n  \"has_disc_negated disc True m \\<longleftrightarrow> has_disc_negated disc False (MatchNot m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated disc True (MatchNot m) =\n    has_disc_negated disc False m &&&\n    has_disc_negated disc True m = has_disc_negated disc False (MatchNot m)", "by(induction m) (simp_all)"], ["", "lemma has_disc_negated_has_disc: \"has_disc_negated disc neg m \\<Longrightarrow> has_disc disc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated disc neg m \\<Longrightarrow> has_disc disc m", "apply(induction m arbitrary: neg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x neg.\n       has_disc_negated disc neg (Match x) \\<Longrightarrow>\n       has_disc disc (Match x)\n 2. \\<And>m neg.\n       \\<lbrakk>\\<And>neg.\n                   has_disc_negated disc neg m \\<Longrightarrow>\n                   has_disc disc m;\n        has_disc_negated disc neg (MatchNot m)\\<rbrakk>\n       \\<Longrightarrow> has_disc disc (MatchNot m)\n 3. \\<And>m1 m2 neg.\n       \\<lbrakk>\\<And>neg.\n                   has_disc_negated disc neg m1 \\<Longrightarrow>\n                   has_disc disc m1;\n        \\<And>neg.\n           has_disc_negated disc neg m2 \\<Longrightarrow> has_disc disc m2;\n        has_disc_negated disc neg (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc disc (MatchAnd m1 m2)\n 4. \\<And>neg.\n       has_disc_negated disc neg MatchAny \\<Longrightarrow>\n       has_disc disc MatchAny", "apply(simp_all split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 neg.\n       \\<lbrakk>\\<And>neg.\n                   has_disc_negated disc neg m1 \\<Longrightarrow>\n                   has_disc disc m1;\n        \\<And>neg.\n           has_disc_negated disc neg m2 \\<Longrightarrow> has_disc disc m2;\n        has_disc_negated disc neg m1 \\<or>\n        has_disc_negated disc neg m2\\<rbrakk>\n       \\<Longrightarrow> has_disc disc m1 \\<or> has_disc disc m2", "by blast"], ["", "lemma has_disc_negated_positiv_has_disc: \"has_disc_negated disc neg m \\<or> has_disc_negated disc (\\<not> neg) m \\<longleftrightarrow> has_disc disc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (has_disc_negated disc neg m \\<or>\n     has_disc_negated disc (\\<not> neg) m) =\n    has_disc disc m", "by(induction disc neg m arbitrary: neg rule:has_disc_negated.induct) auto"], ["", "lemma has_disc_negated_disj_split: \n    \"has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg m \\<longleftrightarrow> has_disc_negated P neg m \\<or> has_disc_negated Q neg m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg m =\n    (has_disc_negated P neg m \\<or> has_disc_negated Q neg m)", "apply(induction \"(\\<lambda>a. P a \\<or> Q a)\" neg m rule: has_disc_negated.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>uv_.\n       has_disc_negated (\\<lambda>a. P a \\<or> Q a) uv_ MatchAny =\n       (has_disc_negated P uv_ MatchAny \\<or>\n        has_disc_negated Q uv_ MatchAny)\n 2. \\<And>neg a.\n       has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg (Match a) =\n       (has_disc_negated P neg (Match a) \\<or>\n        has_disc_negated Q neg (Match a))\n 3. \\<And>neg m.\n       has_disc_negated (\\<lambda>a. P a \\<or> Q a) (\\<not> neg) m =\n       (has_disc_negated P (\\<not> neg) m \\<or>\n        has_disc_negated Q (\\<not> neg) m) \\<Longrightarrow>\n       has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg (MatchNot m) =\n       (has_disc_negated P neg (MatchNot m) \\<or>\n        has_disc_negated Q neg (MatchNot m))\n 4. \\<And>neg m1 m2.\n       \\<lbrakk>has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg m1 =\n                (has_disc_negated P neg m1 \\<or> has_disc_negated Q neg m1);\n        has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg m2 =\n        (has_disc_negated P neg m2 \\<or> has_disc_negated Q neg m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg\n                          (MatchAnd m1 m2) =\n                         (has_disc_negated P neg (MatchAnd m1 m2) \\<or>\n                          has_disc_negated Q neg (MatchAnd m1 m2))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>neg m1 m2.\n       \\<lbrakk>has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg m1 =\n                (has_disc_negated P neg m1 \\<or> has_disc_negated Q neg m1);\n        has_disc_negated (\\<lambda>a. P a \\<or> Q a) neg m2 =\n        (has_disc_negated P neg m2 \\<or> has_disc_negated Q neg m2)\\<rbrakk>\n       \\<Longrightarrow> (has_disc_negated P neg m1 \\<or>\n                          has_disc_negated Q neg m1 \\<or>\n                          has_disc_negated P neg m2 \\<or>\n                          has_disc_negated Q neg m2) =\n                         (has_disc_negated P neg m1 \\<or>\n                          has_disc_negated P neg m2 \\<or>\n                          has_disc_negated Q neg m1 \\<or>\n                          has_disc_negated Q neg m2)", "by blast"], ["", "lemma has_disc_alist_and: \"has_disc disc (alist_and as) \\<longleftrightarrow> (\\<exists> a \\<in> set as. has_disc disc (negation_type_to_match_expr a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc disc (alist_and as) =\n    (\\<exists>a\\<in>set as. has_disc disc (negation_type_to_match_expr a))", "proof(induction as rule: alist_and.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. has_disc disc (alist_and []) =\n    (\\<exists>a\\<in>set []. has_disc disc (negation_type_to_match_expr a))\n 2. \\<And>e es.\n       has_disc disc (alist_and es) =\n       (\\<exists>a\\<in>set es.\n           has_disc disc (negation_type_to_match_expr a)) \\<Longrightarrow>\n       has_disc disc (alist_and (Pos e # es)) =\n       (\\<exists>a\\<in>set (Pos e # es).\n           has_disc disc (negation_type_to_match_expr a))\n 3. \\<And>e es.\n       has_disc disc (alist_and es) =\n       (\\<exists>a\\<in>set es.\n           has_disc disc (negation_type_to_match_expr a)) \\<Longrightarrow>\n       has_disc disc (alist_and (Neg e # es)) =\n       (\\<exists>a\\<in>set (Neg e # es).\n           has_disc disc (negation_type_to_match_expr a))", "qed(simp_all add: negation_type_to_match_expr_simps)"], ["", "lemma has_disc_negated_alist_and: \"has_disc_negated disc neg (alist_and as) \\<longleftrightarrow> (\\<exists> a \\<in> set as. has_disc_negated disc neg (negation_type_to_match_expr a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated disc neg (alist_and as) =\n    (\\<exists>a\\<in>set as.\n        has_disc_negated disc neg (negation_type_to_match_expr a))", "proof(induction as rule: alist_and.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. has_disc_negated disc neg (alist_and []) =\n    (\\<exists>a\\<in>set [].\n        has_disc_negated disc neg (negation_type_to_match_expr a))\n 2. \\<And>e es.\n       has_disc_negated disc neg (alist_and es) =\n       (\\<exists>a\\<in>set es.\n           has_disc_negated disc neg\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       has_disc_negated disc neg (alist_and (Pos e # es)) =\n       (\\<exists>a\\<in>set (Pos e # es).\n           has_disc_negated disc neg (negation_type_to_match_expr a))\n 3. \\<And>e es.\n       has_disc_negated disc neg (alist_and es) =\n       (\\<exists>a\\<in>set es.\n           has_disc_negated disc neg\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       has_disc_negated disc neg (alist_and (Neg e # es)) =\n       (\\<exists>a\\<in>set (Neg e # es).\n           has_disc_negated disc neg (negation_type_to_match_expr a))", "qed(simp_all add: negation_type_to_match_expr_simps)"], ["", "lemma has_disc_alist_and': \"has_disc disc (alist_and' as) \\<longleftrightarrow> (\\<exists> a \\<in> set as. has_disc disc (negation_type_to_match_expr a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc disc (alist_and' as) =\n    (\\<exists>a\\<in>set as. has_disc disc (negation_type_to_match_expr a))", "proof(induction as rule: alist_and'.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. has_disc disc (alist_and' []) =\n    (\\<exists>a\\<in>set []. has_disc disc (negation_type_to_match_expr a))\n 2. \\<And>e.\n       has_disc disc (alist_and' [Pos e]) =\n       (\\<exists>a\\<in>set [Pos e].\n           has_disc disc (negation_type_to_match_expr a))\n 3. \\<And>e.\n       has_disc disc (alist_and' [Neg e]) =\n       (\\<exists>a\\<in>set [Neg e].\n           has_disc disc (negation_type_to_match_expr a))\n 4. \\<And>e v va.\n       has_disc disc (alist_and' (v # va)) =\n       (\\<exists>a\\<in>set (v # va).\n           has_disc disc (negation_type_to_match_expr a)) \\<Longrightarrow>\n       has_disc disc (alist_and' (Pos e # v # va)) =\n       (\\<exists>a\\<in>set (Pos e # v # va).\n           has_disc disc (negation_type_to_match_expr a))\n 5. \\<And>e v va.\n       has_disc disc (alist_and' (v # va)) =\n       (\\<exists>a\\<in>set (v # va).\n           has_disc disc (negation_type_to_match_expr a)) \\<Longrightarrow>\n       has_disc disc (alist_and' (Neg e # v # va)) =\n       (\\<exists>a\\<in>set (Neg e # v # va).\n           has_disc disc (negation_type_to_match_expr a))", "qed(simp_all add: negation_type_to_match_expr_simps)"], ["", "lemma has_disc_negated_alist_and': \"has_disc_negated disc neg (alist_and' as) \\<longleftrightarrow> (\\<exists> a \\<in> set as. has_disc_negated disc neg (negation_type_to_match_expr a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated disc neg (alist_and' as) =\n    (\\<exists>a\\<in>set as.\n        has_disc_negated disc neg (negation_type_to_match_expr a))", "proof(induction as rule: alist_and'.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. has_disc_negated disc neg (alist_and' []) =\n    (\\<exists>a\\<in>set [].\n        has_disc_negated disc neg (negation_type_to_match_expr a))\n 2. \\<And>e.\n       has_disc_negated disc neg (alist_and' [Pos e]) =\n       (\\<exists>a\\<in>set [Pos e].\n           has_disc_negated disc neg (negation_type_to_match_expr a))\n 3. \\<And>e.\n       has_disc_negated disc neg (alist_and' [Neg e]) =\n       (\\<exists>a\\<in>set [Neg e].\n           has_disc_negated disc neg (negation_type_to_match_expr a))\n 4. \\<And>e v va.\n       has_disc_negated disc neg (alist_and' (v # va)) =\n       (\\<exists>a\\<in>set (v # va).\n           has_disc_negated disc neg\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       has_disc_negated disc neg (alist_and' (Pos e # v # va)) =\n       (\\<exists>a\\<in>set (Pos e # v # va).\n           has_disc_negated disc neg (negation_type_to_match_expr a))\n 5. \\<And>e v va.\n       has_disc_negated disc neg (alist_and' (v # va)) =\n       (\\<exists>a\\<in>set (v # va).\n           has_disc_negated disc neg\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       has_disc_negated disc neg (alist_and' (Neg e # v # va)) =\n       (\\<exists>a\\<in>set (Neg e # v # va).\n           has_disc_negated disc neg (negation_type_to_match_expr a))", "qed(simp_all add: negation_type_to_match_expr_simps)"], ["", "lemma has_disc_alist_and'_append:\n  \"has_disc disc' (alist_and' (ls1 @ ls2)) \\<longleftrightarrow>\n      has_disc disc' (alist_and' ls1) \\<or> has_disc disc' (alist_and' ls2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc disc' (alist_and' (ls1 @ ls2)) =\n    (has_disc disc' (alist_and' ls1) \\<or> has_disc disc' (alist_and' ls2))", "apply(induction ls1 arbitrary: ls2 rule: alist_and'.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ls2.\n       has_disc disc' (alist_and' ([] @ ls2)) =\n       (has_disc disc' (alist_and' []) \\<or>\n        has_disc disc' (alist_and' ls2))\n 2. \\<And>e ls2.\n       has_disc disc' (alist_and' ([Pos e] @ ls2)) =\n       (has_disc disc' (alist_and' [Pos e]) \\<or>\n        has_disc disc' (alist_and' ls2))\n 3. \\<And>e ls2.\n       has_disc disc' (alist_and' ([Neg e] @ ls2)) =\n       (has_disc disc' (alist_and' [Neg e]) \\<or>\n        has_disc disc' (alist_and' ls2))\n 4. \\<And>e v va ls2.\n       (\\<And>ls2.\n           has_disc disc' (alist_and' ((v # va) @ ls2)) =\n           (has_disc disc' (alist_and' (v # va)) \\<or>\n            has_disc disc' (alist_and' ls2))) \\<Longrightarrow>\n       has_disc disc' (alist_and' ((Pos e # v # va) @ ls2)) =\n       (has_disc disc' (alist_and' (Pos e # v # va)) \\<or>\n        has_disc disc' (alist_and' ls2))\n 5. \\<And>e v va ls2.\n       (\\<And>ls2.\n           has_disc disc' (alist_and' ((v # va) @ ls2)) =\n           (has_disc disc' (alist_and' (v # va)) \\<or>\n            has_disc disc' (alist_and' ls2))) \\<Longrightarrow>\n       has_disc disc' (alist_and' ((Neg e # v # va) @ ls2)) =\n       (has_disc disc' (alist_and' (Neg e # v # va)) \\<or>\n        has_disc disc' (alist_and' ls2))", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e ls2.\n       has_disc disc' (alist_and' (Pos e # ls2)) =\n       (disc' e \\<or> has_disc disc' (alist_and' ls2))\n 2. \\<And>e ls2.\n       has_disc disc' (alist_and' (Neg e # ls2)) =\n       (disc' e \\<or> has_disc disc' (alist_and' ls2))", "apply(case_tac [!] ls2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>e ls2.\n       ls2 = [] \\<Longrightarrow>\n       has_disc disc' (alist_and' (Pos e # ls2)) =\n       (disc' e \\<or> has_disc disc' (alist_and' ls2))\n 2. \\<And>e ls2 a list.\n       ls2 = a # list \\<Longrightarrow>\n       has_disc disc' (alist_and' (Pos e # ls2)) =\n       (disc' e \\<or> has_disc disc' (alist_and' ls2))\n 3. \\<And>e ls2.\n       ls2 = [] \\<Longrightarrow>\n       has_disc disc' (alist_and' (Neg e # ls2)) =\n       (disc' e \\<or> has_disc disc' (alist_and' ls2))\n 4. \\<And>e ls2 a list.\n       ls2 = a # list \\<Longrightarrow>\n       has_disc disc' (alist_and' (Neg e # ls2)) =\n       (disc' e \\<or> has_disc disc' (alist_and' ls2))", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma has_disc_negated_alist_and'_append:\n  \"has_disc_negated disc' neg (alist_and' (ls1 @ ls2)) \\<longleftrightarrow>\n      has_disc_negated disc' neg (alist_and' ls1) \\<or> has_disc_negated disc' neg (alist_and' ls2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated disc' neg (alist_and' (ls1 @ ls2)) =\n    (has_disc_negated disc' neg (alist_and' ls1) \\<or>\n     has_disc_negated disc' neg (alist_and' ls2))", "apply(induction ls1 arbitrary: ls2 rule: alist_and'.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ls2.\n       has_disc_negated disc' neg (alist_and' ([] @ ls2)) =\n       (has_disc_negated disc' neg (alist_and' []) \\<or>\n        has_disc_negated disc' neg (alist_and' ls2))\n 2. \\<And>e ls2.\n       has_disc_negated disc' neg (alist_and' ([Pos e] @ ls2)) =\n       (has_disc_negated disc' neg (alist_and' [Pos e]) \\<or>\n        has_disc_negated disc' neg (alist_and' ls2))\n 3. \\<And>e ls2.\n       has_disc_negated disc' neg (alist_and' ([Neg e] @ ls2)) =\n       (has_disc_negated disc' neg (alist_and' [Neg e]) \\<or>\n        has_disc_negated disc' neg (alist_and' ls2))\n 4. \\<And>e v va ls2.\n       (\\<And>ls2.\n           has_disc_negated disc' neg (alist_and' ((v # va) @ ls2)) =\n           (has_disc_negated disc' neg (alist_and' (v # va)) \\<or>\n            has_disc_negated disc' neg (alist_and' ls2))) \\<Longrightarrow>\n       has_disc_negated disc' neg (alist_and' ((Pos e # v # va) @ ls2)) =\n       (has_disc_negated disc' neg (alist_and' (Pos e # v # va)) \\<or>\n        has_disc_negated disc' neg (alist_and' ls2))\n 5. \\<And>e v va ls2.\n       (\\<And>ls2.\n           has_disc_negated disc' neg (alist_and' ((v # va) @ ls2)) =\n           (has_disc_negated disc' neg (alist_and' (v # va)) \\<or>\n            has_disc_negated disc' neg (alist_and' ls2))) \\<Longrightarrow>\n       has_disc_negated disc' neg (alist_and' ((Neg e # v # va) @ ls2)) =\n       (has_disc_negated disc' neg (alist_and' (Neg e # v # va)) \\<or>\n        has_disc_negated disc' neg (alist_and' ls2))", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e ls2.\n       (disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Pos e # ls2)) =\n        (neg \\<or> has_disc_negated disc' neg (alist_and' ls2))) \\<and>\n       (\\<not> disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Pos e # ls2)) =\n        has_disc_negated disc' neg (alist_and' ls2))\n 2. \\<And>e ls2.\n       (disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Neg e # ls2)) =\n        (neg \\<longrightarrow>\n         has_disc_negated disc' True (alist_and' ls2))) \\<and>\n       (\\<not> disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Neg e # ls2)) =\n        has_disc_negated disc' neg (alist_and' ls2))", "apply(case_tac [!] ls2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>e ls2.\n       ls2 = [] \\<Longrightarrow>\n       (disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Pos e # ls2)) =\n        (neg \\<or> has_disc_negated disc' neg (alist_and' ls2))) \\<and>\n       (\\<not> disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Pos e # ls2)) =\n        has_disc_negated disc' neg (alist_and' ls2))\n 2. \\<And>e ls2 a list.\n       ls2 = a # list \\<Longrightarrow>\n       (disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Pos e # ls2)) =\n        (neg \\<or> has_disc_negated disc' neg (alist_and' ls2))) \\<and>\n       (\\<not> disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Pos e # ls2)) =\n        has_disc_negated disc' neg (alist_and' ls2))\n 3. \\<And>e ls2.\n       ls2 = [] \\<Longrightarrow>\n       (disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Neg e # ls2)) =\n        (neg \\<longrightarrow>\n         has_disc_negated disc' True (alist_and' ls2))) \\<and>\n       (\\<not> disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Neg e # ls2)) =\n        has_disc_negated disc' neg (alist_and' ls2))\n 4. \\<And>e ls2 a list.\n       ls2 = a # list \\<Longrightarrow>\n       (disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Neg e # ls2)) =\n        (neg \\<longrightarrow>\n         has_disc_negated disc' True (alist_and' ls2))) \\<and>\n       (\\<not> disc' e \\<longrightarrow>\n        has_disc_negated disc' neg (alist_and' (Neg e # ls2)) =\n        has_disc_negated disc' neg (alist_and' ls2))", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma match_list_to_match_expr_not_has_disc: \n    \"\\<forall>a. \\<not> disc (X a) \\<Longrightarrow> \\<not> has_disc disc (match_list_to_match_expr (map (Match \\<circ> X) ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. \\<not> disc (X a) \\<Longrightarrow>\n    \\<not> has_disc disc\n            (match_list_to_match_expr (map (Match \\<circ> X) ls))", "apply(induction ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>a. \\<not> disc (X a) \\<Longrightarrow>\n    \\<not> has_disc disc\n            (match_list_to_match_expr (map (Match \\<circ> X) []))\n 2. \\<And>a ls.\n       \\<lbrakk>\\<forall>a. \\<not> disc (X a) \\<Longrightarrow>\n                \\<not> has_disc disc\n                        (match_list_to_match_expr\n                          (map (Match \\<circ> X) ls));\n        \\<forall>a. \\<not> disc (X a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (match_list_to_match_expr\n                                   (map (Match \\<circ> X) (a # ls)))", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>\\<forall>a. \\<not> disc (X a) \\<Longrightarrow>\n                \\<not> has_disc disc\n                        (match_list_to_match_expr\n                          (map (Match \\<circ> X) ls));\n        \\<forall>a. \\<not> disc (X a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (match_list_to_match_expr\n                                   (map (Match \\<circ> X) (a # ls)))", "by(simp add: MatchOr_def)"], ["", "lemma \"matches ((\\<lambda>x _. bool_to_ternary (disc x)), (\\<lambda>_ _. False)) (Match x) a p \\<longleftrightarrow> has_disc disc (Match x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches (\\<lambda>x _. bool_to_ternary (disc x), \\<lambda>_ _. False)\n     (Match x) a p =\n    has_disc disc (Match x)", "by(simp add: match_raw_ternary bool_to_ternary_simps split: ternaryvalue.split )"], ["", "fun normalized_n_primitive :: \"(('a \\<Rightarrow> bool) \\<times> ('a \\<Rightarrow> 'b)) \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> 'a match_expr \\<Rightarrow> bool\" where\n  \"normalized_n_primitive _ _ MatchAny = True\" |\n  \"normalized_n_primitive (disc, sel) n (Match P) = (if disc P then n (sel P) else True)\" |\n  \"normalized_n_primitive (disc, sel) n (MatchNot (Match P)) = (if disc P then False else True)\" |\n  \"normalized_n_primitive (disc, sel) n (MatchAnd m1 m2) = (normalized_n_primitive (disc, sel) n m1 \\<and> normalized_n_primitive (disc, sel) n m2)\" |\n  \"normalized_n_primitive _ _ (MatchNot (MatchAnd _ _)) = False\" |\n  (*\"normalized_n_primitive _ _ (MatchNot _) = True\" *)\n  \"normalized_n_primitive _ _ (MatchNot (MatchNot _)) = False\" | (*not nnf normalized*)\n  \"normalized_n_primitive _ _ (MatchNot MatchAny) = True\""], ["", "lemma normalized_nnf_match_opt_MatchAny_match_expr:\n  \"normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match (opt_MatchAny_match_expr m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (opt_MatchAny_match_expr m)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (opt_MatchAny_match_expr m)", "have \"normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match (opt_MatchAny_match_expr_once m)\"\n  for m :: \"'a match_expr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (opt_MatchAny_match_expr_once m)", "by(induction m rule: opt_MatchAny_match_expr_once.induct) (simp_all)"], ["proof (state)\nthis:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  normalized_nnf_match (opt_MatchAny_match_expr_once ?m)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (opt_MatchAny_match_expr m)", "thus \"normalized_nnf_match m \\<Longrightarrow> normalized_nnf_match (opt_MatchAny_match_expr m)\""], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  normalized_nnf_match (opt_MatchAny_match_expr_once ?m)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_nnf_match (opt_MatchAny_match_expr m)", "apply(simp add: opt_MatchAny_match_expr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m;\n     \\<And>m.\n        normalized_nnf_match m \\<Longrightarrow>\n        normalized_nnf_match (opt_MatchAny_match_expr_once m)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match\n                       (repeat_stabilize 2 opt_MatchAny_match_expr_once m)", "apply(induction rule: repeat_stabilize_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_nnf_match m;\n     \\<And>m.\n        normalized_nnf_match m \\<Longrightarrow>\n        normalized_nnf_match (opt_MatchAny_match_expr_once m)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m\n 2. \\<And>ma.\n       \\<lbrakk>\\<lbrakk>normalized_nnf_match m;\n                 \\<And>m.\n                    normalized_nnf_match m \\<Longrightarrow>\n                    normalized_nnf_match\n                     (opt_MatchAny_match_expr_once m)\\<rbrakk>\n                \\<Longrightarrow> normalized_nnf_match ma;\n        normalized_nnf_match m;\n        \\<And>m.\n           normalized_nnf_match m \\<Longrightarrow>\n           normalized_nnf_match (opt_MatchAny_match_expr_once m)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match\n                          (opt_MatchAny_match_expr_once ma)", "by(simp)+"], ["proof (state)\nthis:\n  normalized_nnf_match m \\<Longrightarrow>\n  normalized_nnf_match (opt_MatchAny_match_expr m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_n_primitive_opt_MatchAny_match_expr:\n  \"normalized_n_primitive disc_sel f m \\<Longrightarrow> normalized_n_primitive disc_sel f (opt_MatchAny_match_expr m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr m)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr m)", "have \"normalized_n_primitive disc_sel f m \\<Longrightarrow> normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)\"\n  for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "fix disc::\"('a \\<Rightarrow> bool)\" and sel::\"('a \\<Rightarrow> 'b)\" and n m1 m2"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "have \"normalized_n_primitive (disc, sel) n (opt_MatchAny_match_expr_once m1) \\<Longrightarrow>\n           normalized_n_primitive (disc, sel) n (opt_MatchAny_match_expr_once m2) \\<Longrightarrow>\n           normalized_n_primitive (disc, sel) n m1 \\<and> normalized_n_primitive (disc, sel) n m2 \\<Longrightarrow>\n           normalized_n_primitive (disc, sel) n (opt_MatchAny_match_expr_once (MatchAnd m1 m2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive (disc, sel) n\n              (opt_MatchAny_match_expr_once m1);\n     normalized_n_primitive (disc, sel) n (opt_MatchAny_match_expr_once m2);\n     normalized_n_primitive (disc, sel) n m1 \\<and>\n     normalized_n_primitive (disc, sel) n m2\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) n\n                       (opt_MatchAny_match_expr_once (MatchAnd m1 m2))", "by(induction \"(MatchAnd m1 m2)\" rule: opt_MatchAny_match_expr_once.induct) (auto)"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_n_primitive (disc, sel) n\n            (opt_MatchAny_match_expr_once m1);\n   normalized_n_primitive (disc, sel) n (opt_MatchAny_match_expr_once m2);\n   normalized_n_primitive (disc, sel) n m1 \\<and>\n   normalized_n_primitive (disc, sel) n m2\\<rbrakk>\n  \\<Longrightarrow> normalized_n_primitive (disc, sel) n\n                     (opt_MatchAny_match_expr_once (MatchAnd m1 m2))\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_n_primitive (?disc2, ?sel2) ?n2\n            (opt_MatchAny_match_expr_once ?m1.2);\n   normalized_n_primitive (?disc2, ?sel2) ?n2\n    (opt_MatchAny_match_expr_once ?m2.2);\n   normalized_n_primitive (?disc2, ?sel2) ?n2 ?m1.2 \\<and>\n   normalized_n_primitive (?disc2, ?sel2) ?n2 ?m2.2\\<rbrakk>\n  \\<Longrightarrow> normalized_n_primitive (?disc2, ?sel2) ?n2\n                     (opt_MatchAny_match_expr_once (MatchAnd ?m1.2 ?m2.2))\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "note x=this"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_n_primitive (?disc2, ?sel2) ?n2\n            (opt_MatchAny_match_expr_once ?m1.2);\n   normalized_n_primitive (?disc2, ?sel2) ?n2\n    (opt_MatchAny_match_expr_once ?m2.2);\n   normalized_n_primitive (?disc2, ?sel2) ?n2 ?m1.2 \\<and>\n   normalized_n_primitive (?disc2, ?sel2) ?n2 ?m2.2\\<rbrakk>\n  \\<Longrightarrow> normalized_n_primitive (?disc2, ?sel2) ?n2\n                     (opt_MatchAny_match_expr_once (MatchAnd ?m1.2 ?m2.2))\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "assume \"normalized_n_primitive disc_sel f m\""], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel f m\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  normalized_n_primitive disc_sel f m\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)", "apply(induction disc_sel f m rule: normalized_n_primitive.induct)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>uu_ uv_.\n       normalized_n_primitive uu_ uv_ MatchAny \\<Longrightarrow>\n       normalized_n_primitive uu_ uv_\n        (opt_MatchAny_match_expr_once MatchAny)\n 2. \\<And>disc sel n P.\n       normalized_n_primitive (disc, sel) n (Match P) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) n\n        (opt_MatchAny_match_expr_once (Match P))\n 3. \\<And>disc sel n P.\n       normalized_n_primitive (disc, sel) n\n        (MatchNot (Match P)) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) n\n        (opt_MatchAny_match_expr_once (MatchNot (Match P)))\n 4. \\<And>disc sel n m1 m2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) n m1 \\<Longrightarrow>\n                normalized_n_primitive (disc, sel) n\n                 (opt_MatchAny_match_expr_once m1);\n        normalized_n_primitive (disc, sel) n m2 \\<Longrightarrow>\n        normalized_n_primitive (disc, sel) n\n         (opt_MatchAny_match_expr_once m2);\n        normalized_n_primitive (disc, sel) n (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) n\n                          (opt_MatchAny_match_expr_once (MatchAnd m1 m2))\n 5. \\<And>uw_ ux_ uy_ uz_.\n       normalized_n_primitive uw_ ux_\n        (MatchNot (MatchAnd uy_ uz_)) \\<Longrightarrow>\n       normalized_n_primitive uw_ ux_\n        (opt_MatchAny_match_expr_once (MatchNot (MatchAnd uy_ uz_)))\n 6. \\<And>va_ vb_ vc_.\n       normalized_n_primitive va_ vb_\n        (MatchNot (MatchNot vc_)) \\<Longrightarrow>\n       normalized_n_primitive va_ vb_\n        (opt_MatchAny_match_expr_once (MatchNot (MatchNot vc_)))\n 7. \\<And>vd_ ve_.\n       normalized_n_primitive vd_ ve_ (MatchNot MatchAny) \\<Longrightarrow>\n       normalized_n_primitive vd_ ve_\n        (opt_MatchAny_match_expr_once (MatchNot MatchAny))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>disc sel n m1 m2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) n\n                 (opt_MatchAny_match_expr_once m1);\n        normalized_n_primitive (disc, sel) n\n         (opt_MatchAny_match_expr_once m2);\n        normalized_n_primitive (disc, sel) n m1 \\<and>\n        normalized_n_primitive (disc, sel) n m2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) n\n                          (opt_MatchAny_match_expr_once (MatchAnd m1 m2))", "using x"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_n_primitive (?disc2, ?sel2) ?n2\n            (opt_MatchAny_match_expr_once ?m1.2);\n   normalized_n_primitive (?disc2, ?sel2) ?n2\n    (opt_MatchAny_match_expr_once ?m2.2);\n   normalized_n_primitive (?disc2, ?sel2) ?n2 ?m1.2 \\<and>\n   normalized_n_primitive (?disc2, ?sel2) ?n2 ?m2.2\\<rbrakk>\n  \\<Longrightarrow> normalized_n_primitive (?disc2, ?sel2) ?n2\n                     (opt_MatchAny_match_expr_once (MatchAnd ?m1.2 ?m2.2))\n\ngoal (1 subgoal):\n 1. \\<And>disc sel n m1 m2.\n       \\<lbrakk>normalized_n_primitive (disc, sel) n\n                 (opt_MatchAny_match_expr_once m1);\n        normalized_n_primitive (disc, sel) n\n         (opt_MatchAny_match_expr_once m2);\n        normalized_n_primitive (disc, sel) n m1 \\<and>\n        normalized_n_primitive (disc, sel) n m2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) n\n                          (opt_MatchAny_match_expr_once (MatchAnd m1 m2))", "by simp"], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel f ?m \\<Longrightarrow>\n  normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once ?m)\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr m)", "from this"], ["proof (chain)\npicking this:\n  normalized_n_primitive disc_sel f ?m \\<Longrightarrow>\n  normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once ?m)", "show\n    \"normalized_n_primitive disc_sel f m \\<Longrightarrow> normalized_n_primitive disc_sel f (opt_MatchAny_match_expr m)\""], ["proof (prove)\nusing this:\n  normalized_n_primitive disc_sel f ?m \\<Longrightarrow>\n  normalized_n_primitive disc_sel f (opt_MatchAny_match_expr_once ?m)\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (opt_MatchAny_match_expr m)", "apply(simp add: opt_MatchAny_match_expr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive disc_sel f m;\n     \\<And>m.\n        normalized_n_primitive disc_sel f m \\<Longrightarrow>\n        normalized_n_primitive disc_sel f\n         (opt_MatchAny_match_expr_once m)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive disc_sel f\n                       (repeat_stabilize 2 opt_MatchAny_match_expr_once m)", "apply(induction rule: repeat_stabilize_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized_n_primitive disc_sel f m;\n     \\<And>m.\n        normalized_n_primitive disc_sel f m \\<Longrightarrow>\n        normalized_n_primitive disc_sel f\n         (opt_MatchAny_match_expr_once m)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive disc_sel f m\n 2. \\<And>ma.\n       \\<lbrakk>\\<lbrakk>normalized_n_primitive disc_sel f m;\n                 \\<And>m.\n                    normalized_n_primitive disc_sel f m \\<Longrightarrow>\n                    normalized_n_primitive disc_sel f\n                     (opt_MatchAny_match_expr_once m)\\<rbrakk>\n                \\<Longrightarrow> normalized_n_primitive disc_sel f ma;\n        normalized_n_primitive disc_sel f m;\n        \\<And>m.\n           normalized_n_primitive disc_sel f m \\<Longrightarrow>\n           normalized_n_primitive disc_sel f\n            (opt_MatchAny_match_expr_once m)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (opt_MatchAny_match_expr_once ma)", "by(simp)+"], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel f m \\<Longrightarrow>\n  normalized_n_primitive disc_sel f (opt_MatchAny_match_expr m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_n_primitive_imp_not_disc_negated:\n  \"wf_disc_sel (disc,sel) C \\<Longrightarrow> normalized_n_primitive (disc,sel) f m \\<Longrightarrow> \\<not> has_disc_negated disc False m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C;\n     normalized_n_primitive (disc, sel) f m\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc False m", "apply(induction \"(disc,sel)\" f m rule: normalized_n_primitive.induct)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>uv_.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_n_primitive (disc, sel) uv_ MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False MatchAny\n 2. \\<And>n P.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_n_primitive (disc, sel) n (Match P)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False (Match P)\n 3. \\<And>n P.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_n_primitive (disc, sel) n (MatchNot (Match P))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (MatchNot (Match P))\n 4. \\<And>n m1 m2.\n       \\<lbrakk>\\<lbrakk>wf_disc_sel (disc, sel) C;\n                 normalized_n_primitive (disc, sel) n m1\\<rbrakk>\n                \\<Longrightarrow> \\<not> has_disc_negated disc False m1;\n        \\<lbrakk>wf_disc_sel (disc, sel) C;\n         normalized_n_primitive (disc, sel) n m2\\<rbrakk>\n        \\<Longrightarrow> \\<not> has_disc_negated disc False m2;\n        wf_disc_sel (disc, sel) C;\n        normalized_n_primitive (disc, sel) n (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False (MatchAnd m1 m2)\n 5. \\<And>ux_ uy_ uz_.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_n_primitive (disc, sel) ux_\n         (MatchNot (MatchAnd uy_ uz_))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (MatchNot (MatchAnd uy_ uz_))\n 6. \\<And>vb_ vc_.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_n_primitive (disc, sel) vb_\n         (MatchNot (MatchNot vc_))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (MatchNot (MatchNot vc_))\n 7. \\<And>ve_.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_n_primitive (disc, sel) ve_ (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc False\n                                 (MatchNot MatchAny)", "by(simp add: wf_disc_sel.simps split: if_split_asm)+"], ["", "lemma normalized_n_primitive_alist_and: \"normalized_n_primitive disc_sel P (alist_and as) \\<longleftrightarrow>\n      (\\<forall> a \\<in> set as. normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel P (alist_and as) =\n    (\\<forall>a\\<in>set as.\n        normalized_n_primitive disc_sel P (negation_type_to_match_expr a))", "proof(induction as)"], ["proof (state)\ngoal (2 subgoals):\n 1. normalized_n_primitive disc_sel P (alist_and []) =\n    (\\<forall>a\\<in>set [].\n        normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\n 2. \\<And>a as.\n       normalized_n_primitive disc_sel P (alist_and as) =\n       (\\<forall>a\\<in>set as.\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and (a # as)) =\n       (\\<forall>a\\<in>set (a # as).\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. normalized_n_primitive disc_sel P (alist_and []) =\n    (\\<forall>a\\<in>set [].\n        normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\n 2. \\<And>a as.\n       normalized_n_primitive disc_sel P (alist_and as) =\n       (\\<forall>a\\<in>set as.\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and (a # as)) =\n       (\\<forall>a\\<in>set (a # as).\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel P (alist_and []) =\n    (\\<forall>a\\<in>set [].\n        normalized_n_primitive disc_sel P (negation_type_to_match_expr a))", "by simp"], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel P (alist_and []) =\n  (\\<forall>a\\<in>set [].\n      normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       normalized_n_primitive disc_sel P (alist_and as) =\n       (\\<forall>a\\<in>set as.\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and (a # as)) =\n       (\\<forall>a\\<in>set (a # as).\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       normalized_n_primitive disc_sel P (alist_and as) =\n       (\\<forall>a\\<in>set as.\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and (a # as)) =\n       (\\<forall>a\\<in>set (a # as).\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))", "case (Cons a as)"], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel P (alist_and as) =\n  (\\<forall>a\\<in>set as.\n      normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       normalized_n_primitive disc_sel P (alist_and as) =\n       (\\<forall>a\\<in>set as.\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a)) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and (a # as)) =\n       (\\<forall>a\\<in>set (a # as).\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_n_primitive disc_sel P (alist_and as) =\n  (\\<forall>a\\<in>set as.\n      normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel P (alist_and (a # as)) =\n    (\\<forall>a\\<in>set (a # as).\n        normalized_n_primitive disc_sel P (negation_type_to_match_expr a))", "apply(cases disc_sel, cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b x1.\n       \\<lbrakk>normalized_n_primitive disc_sel P (alist_and as) =\n                (\\<forall>a\\<in>set as.\n                    normalized_n_primitive disc_sel P\n                     (negation_type_to_match_expr a));\n        disc_sel = (aa, b);\n        normalized_n_primitive disc_sel P (alist_and as) =\n        (\\<forall>a\\<in>set as.\n            normalized_n_primitive disc_sel P\n             (negation_type_to_match_expr a));\n        a = Pos x1\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel P\n                          (alist_and (a # as)) =\n                         (\\<forall>a\\<in>set (a # as).\n                             normalized_n_primitive disc_sel P\n                              (negation_type_to_match_expr a))\n 2. \\<And>aa b x2.\n       \\<lbrakk>normalized_n_primitive disc_sel P (alist_and as) =\n                (\\<forall>a\\<in>set as.\n                    normalized_n_primitive disc_sel P\n                     (negation_type_to_match_expr a));\n        disc_sel = (aa, b);\n        normalized_n_primitive disc_sel P (alist_and as) =\n        (\\<forall>a\\<in>set as.\n            normalized_n_primitive disc_sel P\n             (negation_type_to_match_expr a));\n        a = Neg x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel P\n                          (alist_and (a # as)) =\n                         (\\<forall>a\\<in>set (a # as).\n                             normalized_n_primitive disc_sel P\n                              (negation_type_to_match_expr a))", "by(simp_all add: negation_type_to_match_expr_simps)"], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel P (alist_and (a # as)) =\n  (\\<forall>a\\<in>set (a # as).\n      normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_n_primitive_alist_and': \"normalized_n_primitive disc_sel P (alist_and' as) \\<longleftrightarrow>\n      (\\<forall> a \\<in> set as. normalized_n_primitive disc_sel P (negation_type_to_match_expr a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel P (alist_and' as) =\n    (\\<forall>a\\<in>set as.\n        normalized_n_primitive disc_sel P (negation_type_to_match_expr a))", "apply(cases disc_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       disc_sel = (a, b) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and' as) =\n       (\\<forall>a\\<in>set as.\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))", "apply(induction as rule: alist_and'.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       disc_sel = (a, b) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and' []) =\n       (\\<forall>a\\<in>set [].\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))\n 2. \\<And>e a b.\n       disc_sel = (a, b) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and' [Pos e]) =\n       (\\<forall>a\\<in>set [Pos e].\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))\n 3. \\<And>e a b.\n       disc_sel = (a, b) \\<Longrightarrow>\n       normalized_n_primitive disc_sel P (alist_and' [Neg e]) =\n       (\\<forall>a\\<in>set [Neg e].\n           normalized_n_primitive disc_sel P\n            (negation_type_to_match_expr a))\n 4. \\<And>e v va a b.\n       \\<lbrakk>\\<And>a b.\n                   disc_sel = (a, b) \\<Longrightarrow>\n                   normalized_n_primitive disc_sel P (alist_and' (v # va)) =\n                   (\\<forall>a\\<in>set (v # va).\n                       normalized_n_primitive disc_sel P\n                        (negation_type_to_match_expr a));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel P\n                          (alist_and' (Pos e # v # va)) =\n                         (\\<forall>a\\<in>set (Pos e # v # va).\n                             normalized_n_primitive disc_sel P\n                              (negation_type_to_match_expr a))\n 5. \\<And>e v va a b.\n       \\<lbrakk>\\<And>a b.\n                   disc_sel = (a, b) \\<Longrightarrow>\n                   normalized_n_primitive disc_sel P (alist_and' (v # va)) =\n                   (\\<forall>a\\<in>set (v # va).\n                       normalized_n_primitive disc_sel P\n                        (negation_type_to_match_expr a));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel P\n                          (alist_and' (Neg e # v # va)) =\n                         (\\<forall>a\\<in>set (Neg e # v # va).\n                             normalized_n_primitive disc_sel P\n                              (negation_type_to_match_expr a))", "by(simp_all add: negation_type_to_match_expr_simps)"], ["", "lemma not_has_disc_NegPos_map: \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> \\<forall>a\\<in>set (NegPos_map C ls).\n        \\<not> has_disc disc (negation_type_to_match_expr a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. \\<not> disc (C a) \\<Longrightarrow>\n    \\<forall>a\\<in>set (NegPos_map C ls).\n       \\<not> has_disc disc (negation_type_to_match_expr a)", "by(induction C ls rule: NegPos_map.induct) (simp add: negation_type_to_match_expr_def)+"], ["", "lemma not_has_disc_negated_NegPos_map: \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow> \\<forall>a\\<in>set (NegPos_map C ls).\n        \\<not> has_disc_negated disc False (negation_type_to_match_expr a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. \\<not> disc (C a) \\<Longrightarrow>\n    \\<forall>a\\<in>set (NegPos_map C ls).\n       \\<not> has_disc_negated disc False (negation_type_to_match_expr a)", "by(induction C ls rule: NegPos_map.induct) (simp add: negation_type_to_match_expr_def)+"], ["", "lemma normalized_n_primitive_impossible_map: \"\\<forall>a. \\<not> disc (C a) \\<Longrightarrow>\n  \\<forall>m\\<in>set (map (Match \\<circ> (C \\<circ> x)) ls).\n     normalized_n_primitive (disc, sel) f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. \\<not> disc (C a) \\<Longrightarrow>\n    \\<forall>m\\<in>set (map (Match \\<circ> (C \\<circ> x)) ls).\n       normalized_n_primitive (disc, sel) f m", "apply(intro ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n        m \\<in> set (map (Match \\<circ> (C \\<circ> x)) ls)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f m", "apply(induction ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n        m \\<in> set (map (Match \\<circ> (C \\<circ> x)) [])\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f m\n 2. \\<And>a ls m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n                    m \\<in> set (map (Match \\<circ> (C \\<circ> x))\n                                  ls)\\<rbrakk>\n                   \\<Longrightarrow> normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (C a);\n        m \\<in> set (map (Match \\<circ> (C \\<circ> x)) (a # ls))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f m", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ls m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<forall>a. \\<not> disc (C a);\n                    m \\<in> set (map (Match \\<circ> (C \\<circ> x))\n                                  ls)\\<rbrakk>\n                   \\<Longrightarrow> normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (C a);\n        m \\<in> set (map (Match \\<circ> (C \\<circ> x)) (a # ls))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f m", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ls m.\n       \\<lbrakk>\\<And>m.\n                   m \\<in> (\\<lambda>xa. Match (C (x xa))) `\n                           set ls \\<Longrightarrow>\n                   normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (C a);\n        m = Match (C (x a)) \\<or>\n        m \\<in> (\\<lambda>xa. Match (C (x xa))) ` set ls\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f m", "apply(case_tac m, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ls m x1.\n       \\<lbrakk>\\<And>m.\n                   m \\<in> (\\<lambda>xa. Match (C (x xa))) `\n                           set ls \\<Longrightarrow>\n                   normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (C a);\n        x1 = C (x a) \\<or>\n        Match x1 \\<in> (\\<lambda>xa. Match (C (x xa))) ` set ls;\n        m = Match x1\\<rbrakk>\n       \\<Longrightarrow> disc x1 \\<longrightarrow> f (sel x1)\n 2. \\<And>ls m x31 x32.\n       \\<lbrakk>\\<And>m.\n                   m \\<in> (\\<lambda>xa. Match (C (x xa))) `\n                           set ls \\<Longrightarrow>\n                   normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (C a);\n        MatchAnd x31 x32 \\<in> (\\<lambda>xa. Match (C (x xa))) ` set ls;\n        m = MatchAnd x31 x32\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f x31 \\<and>\n                         normalized_n_primitive (disc, sel) f x32", "(*3 cases are impossible*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ls m x1.\n       \\<lbrakk>\\<And>m.\n                   m \\<in> (\\<lambda>xa. Match (C (x xa))) `\n                           set ls \\<Longrightarrow>\n                   normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (C a);\n        x1 = C (x a) \\<or>\n        Match x1 \\<in> (\\<lambda>xa. Match (C (x xa))) ` set ls;\n        m = Match x1\\<rbrakk>\n       \\<Longrightarrow> disc x1 \\<longrightarrow> f (sel x1)\n 2. \\<And>ls m x31 x32.\n       \\<lbrakk>\\<And>m.\n                   m \\<in> (\\<lambda>xa. Match (C (x xa))) `\n                           set ls \\<Longrightarrow>\n                   normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (C a);\n        MatchAnd x31 x32 \\<in> (\\<lambda>xa. Match (C (x xa))) ` set ls;\n        m = MatchAnd x31 x32\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f x31 \\<and>\n                         normalized_n_primitive (disc, sel) f x32", "apply(fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls m x31 x32.\n       \\<lbrakk>\\<And>m.\n                   m \\<in> (\\<lambda>xa. Match (C (x xa))) `\n                           set ls \\<Longrightarrow>\n                   normalized_n_primitive (disc, sel) f m;\n        \\<forall>a. \\<not> disc (C a);\n        MatchAnd x31 x32 \\<in> (\\<lambda>xa. Match (C (x xa))) ` set ls;\n        m = MatchAnd x31 x32\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc, sel) f x31 \\<and>\n                         normalized_n_primitive (disc, sel) f x32", "by force"], ["", "lemma normalized_n_primitive_alist_and'_append:\n  \"normalized_n_primitive (disc, sel) f (alist_and' (ls1 @ ls2)) \\<longleftrightarrow>\n      normalized_n_primitive (disc, sel) f (alist_and' ls1) \\<and> normalized_n_primitive (disc, sel) f (alist_and' ls2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc, sel) f (alist_and' (ls1 @ ls2)) =\n    (normalized_n_primitive (disc, sel) f (alist_and' ls1) \\<and>\n     normalized_n_primitive (disc, sel) f (alist_and' ls2))", "apply(induction ls1 arbitrary: ls2 rule: alist_and'.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ls2.\n       normalized_n_primitive (disc, sel) f (alist_and' ([] @ ls2)) =\n       (normalized_n_primitive (disc, sel) f (alist_and' []) \\<and>\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))\n 2. \\<And>e ls2.\n       normalized_n_primitive (disc, sel) f (alist_and' ([Pos e] @ ls2)) =\n       (normalized_n_primitive (disc, sel) f (alist_and' [Pos e]) \\<and>\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))\n 3. \\<And>e ls2.\n       normalized_n_primitive (disc, sel) f (alist_and' ([Neg e] @ ls2)) =\n       (normalized_n_primitive (disc, sel) f (alist_and' [Neg e]) \\<and>\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))\n 4. \\<And>e v va ls2.\n       (\\<And>ls2.\n           normalized_n_primitive (disc, sel) f\n            (alist_and' ((v # va) @ ls2)) =\n           (normalized_n_primitive (disc, sel) f\n             (alist_and' (v # va)) \\<and>\n            normalized_n_primitive (disc, sel) f\n             (alist_and' ls2))) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) f\n        (alist_and' ((Pos e # v # va) @ ls2)) =\n       (normalized_n_primitive (disc, sel) f\n         (alist_and' (Pos e # v # va)) \\<and>\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))\n 5. \\<And>e v va ls2.\n       (\\<And>ls2.\n           normalized_n_primitive (disc, sel) f\n            (alist_and' ((v # va) @ ls2)) =\n           (normalized_n_primitive (disc, sel) f\n             (alist_and' (v # va)) \\<and>\n            normalized_n_primitive (disc, sel) f\n             (alist_and' ls2))) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) f\n        (alist_and' ((Neg e # v # va) @ ls2)) =\n       (normalized_n_primitive (disc, sel) f\n         (alist_and' (Neg e # v # va)) \\<and>\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e ls2.\n       (disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Pos e # ls2)) =\n        (f (sel e) \\<and>\n         normalized_n_primitive (disc, sel) f (alist_and' ls2))) \\<and>\n       (\\<not> disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Pos e # ls2)) =\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))\n 2. \\<And>e ls2.\n       (disc e \\<longrightarrow>\n        \\<not> normalized_n_primitive (disc, sel) f\n                (alist_and' (Neg e # ls2))) \\<and>\n       (\\<not> disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Neg e # ls2)) =\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))", "apply(case_tac [!] ls2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>e ls2.\n       ls2 = [] \\<Longrightarrow>\n       (disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Pos e # ls2)) =\n        (f (sel e) \\<and>\n         normalized_n_primitive (disc, sel) f (alist_and' ls2))) \\<and>\n       (\\<not> disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Pos e # ls2)) =\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))\n 2. \\<And>e ls2 a list.\n       ls2 = a # list \\<Longrightarrow>\n       (disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Pos e # ls2)) =\n        (f (sel e) \\<and>\n         normalized_n_primitive (disc, sel) f (alist_and' ls2))) \\<and>\n       (\\<not> disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Pos e # ls2)) =\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))\n 3. \\<And>e ls2.\n       ls2 = [] \\<Longrightarrow>\n       (disc e \\<longrightarrow>\n        \\<not> normalized_n_primitive (disc, sel) f\n                (alist_and' (Neg e # ls2))) \\<and>\n       (\\<not> disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Neg e # ls2)) =\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))\n 4. \\<And>e ls2 a list.\n       ls2 = a # list \\<Longrightarrow>\n       (disc e \\<longrightarrow>\n        \\<not> normalized_n_primitive (disc, sel) f\n                (alist_and' (Neg e # ls2))) \\<and>\n       (\\<not> disc e \\<longrightarrow>\n        normalized_n_primitive (disc, sel) f (alist_and' (Neg e # ls2)) =\n        normalized_n_primitive (disc, sel) f (alist_and' ls2))", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma normalized_n_primitive_if_no_primitive: \"normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc disc m \\<Longrightarrow> \n       normalized_n_primitive (disc, sel) f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m; \\<not> has_disc disc m\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc, sel) f m", "by(induction \"(disc, sel)\" f m rule: normalized_n_primitive.induct) (simp)+"], ["", "lemma normalized_n_primitive_false_eq_notdisc: \"normalized_nnf_match m \\<Longrightarrow>\n  normalized_n_primitive (disc, sel) (\\<lambda>_. False) m \\<longleftrightarrow> \\<not> has_disc disc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) (\\<lambda>_. False) m =\n    (\\<not> has_disc disc m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) (\\<lambda>_. False) m =\n    (\\<not> has_disc disc m)", "have \"normalized_nnf_match m \\<Longrightarrow> false = (\\<lambda>_. False) \\<Longrightarrow>\n  \\<not> has_disc disc m \\<longleftrightarrow> normalized_n_primitive (disc, sel) false m\" for false"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_nnf_match m; false = (\\<lambda>_. False)\\<rbrakk>\n    \\<Longrightarrow> (\\<not> has_disc disc m) =\n                      normalized_n_primitive (disc, sel) false m", "by(induction \"(disc, sel)\" false m rule: normalized_n_primitive.induct)\n  (simp)+"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match m; ?false = (\\<lambda>_. False)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc disc m) =\n                    normalized_n_primitive (disc, sel) ?false m\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) (\\<lambda>_. False) m =\n    (\\<not> has_disc disc m)", "thus \"normalized_nnf_match m \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match m; ?false = (\\<lambda>_. False)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc disc m) =\n                    normalized_n_primitive (disc, sel) ?false m\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) (\\<lambda>_. False) m =\n    (\\<not> has_disc disc m)", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m \\<Longrightarrow>\n  normalized_n_primitive (disc, sel) (\\<lambda>_. False) m =\n  (\\<not> has_disc disc m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_n_primitive_MatchAnd_combine_map: \"normalized_n_primitive disc_sel f rst \\<Longrightarrow>\n       \\<forall>m' \\<in> (\\<lambda>spt. Match (C spt)) ` set pts. normalized_n_primitive disc_sel f m' \\<Longrightarrow>\n        m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) ` set pts \\<Longrightarrow> normalized_n_primitive disc_sel f m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized_n_primitive disc_sel f rst;\n     \\<forall>m'\\<in>(\\<lambda>spt. Match (C spt)) ` set pts.\n        normalized_n_primitive disc_sel f m';\n     m' \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) rst) `\n              set pts\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive disc_sel f m'", "by(induction disc_sel f m' rule: normalized_n_primitive.induct)\n     fastforce+"], ["", "subsection\\<open>Primitive Extractor\\<close>"], ["", "text\\<open>\n  The following function takes a tuple of functions (@{typ \"(('a \\<Rightarrow> bool) \\<times> ('a \\<Rightarrow> 'b))\"}) and a @{typ \"'a match_expr\"}.\n  The passed function tuple must be the discriminator and selector of the datatype package.\n  \\<open>primitive_extractor\\<close> filters the @{typ \"'a match_expr\"} and returns a tuple.\n  The first element of the returned tuple is the filtered primitive matches, the second element is the remaining match expression.\n\n  It requires a @{const normalized_nnf_match}.\n\\<close>"], ["", "fun primitive_extractor :: \"(('a \\<Rightarrow> bool) \\<times> ('a \\<Rightarrow> 'b)) \\<Rightarrow> 'a match_expr \\<Rightarrow> ('b negation_type list \\<times> 'a match_expr)\" where\n \"primitive_extractor _ MatchAny = ([], MatchAny)\" |\n \"primitive_extractor (disc,sel) (Match a) = (if disc a then ([Pos (sel a)], MatchAny) else ([], Match a))\" |\n \"primitive_extractor (disc,sel) (MatchNot (Match a)) = (if disc a then ([Neg (sel a)], MatchAny) else ([], MatchNot (Match a)))\" |\n \"primitive_extractor C (MatchAnd ms1 ms2) = (\n        let (a1', ms1') = primitive_extractor C ms1; \n            (a2', ms2') = primitive_extractor C ms2\n        in (a1'@a2', MatchAnd ms1' ms2'))\" |\n \"primitive_extractor _ _ = undefined\""], ["", "text\\<open>\n  The first part returned by @{const primitive_extractor}, here \\<open>as\\<close>:\n    A list of primitive match expressions.\n    For example, let \\<open>m = MatchAnd (Src ip1) (Dst ip2)\\<close> then, using the src \\<open>(disc, sel)\\<close>, the result is \\<open>[ip1]\\<close>.\n    Note that \\<open>Src\\<close> is stripped from the result.\n\n    The second part, here \\<open>ms\\<close> is the match expression which was not extracted.\n\n    Together, the first and second part match iff \\<open>m\\<close> matches.\n\\<close>"], ["", "(*unused*)"], ["", "lemma primitive_extractor_fst_simp2:\n  fixes m'::\"'a match_expr \\<Rightarrow> 'a match_expr \\<Rightarrow> 'a match_expr\"\n  shows \"fst (case primitive_extractor (disc, sel) m1 of (a1', ms1') \\<Rightarrow> case primitive_extractor (disc, sel) m2 of (a2', ms2') \\<Rightarrow> (a1' @ a2', m' ms1' ms2')) =\n           fst (primitive_extractor (disc, sel) m1) @ fst (primitive_extractor (disc, sel) m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case primitive_extractor (disc, sel) m1 of\n         (a1', ms1') \\<Rightarrow>\n           case primitive_extractor (disc, sel) m2 of\n           (a2', ms2') \\<Rightarrow> (a1' @ a2', m' ms1' ms2')) =\n    fst (primitive_extractor (disc, sel) m1) @\n    fst (primitive_extractor (disc, sel) m2)", "apply(cases \"primitive_extractor (disc, sel) m1\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       primitive_extractor (disc, sel) m1 = (a, b) \\<Longrightarrow>\n       fst (case primitive_extractor (disc, sel) m2 of\n            (a2', ms2') \\<Rightarrow> (a @ a2', m' b ms2')) =\n       a @ fst (primitive_extractor (disc, sel) m2)", "apply(cases \"primitive_extractor (disc, sel) m2\", simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem primitive_extractor_correct: assumes \n  \"normalized_nnf_match m\" and \"wf_disc_sel (disc, sel) C\" and \"primitive_extractor (disc, sel) m = (as, ms)\" \n  shows \"matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and> matches \\<gamma> ms a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n  and \"normalized_nnf_match ms\"\n  and \"\\<not> has_disc disc ms\"\n  and \"\\<forall>disc2. \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\"\n  and \"\\<forall>disc2 sel2. normalized_n_primitive (disc2, sel2) P m \\<longrightarrow> normalized_n_primitive (disc2, sel2) P ms\"\n  and \"\\<forall>disc2. \\<not> has_disc_negated disc2 neg m \\<longrightarrow> \\<not> has_disc_negated disc2 neg ms\"\n  and \"\\<not> has_disc disc m \\<longleftrightarrow> as = [] \\<and> ms = m\"\n  and \"\\<not> has_disc_negated disc False m \\<longleftrightarrow> getNeg as = []\"\n  and \"has_disc disc m \\<Longrightarrow> as \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n       matches \\<gamma> ms a p) =\n      matches \\<gamma> m a p &&&\n      normalized_nnf_match ms) &&&\n     \\<not> has_disc disc ms &&&\n     \\<forall>disc2.\n        \\<not> has_disc disc2 m \\<longrightarrow>\n        \\<not> has_disc disc2 ms) &&&\n    (\\<forall>disc2 sel2.\n        normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n        normalized_n_primitive (disc2, sel2) P ms &&&\n     \\<forall>disc2.\n        \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n        \\<not> has_disc_negated disc2 neg ms) &&&\n    (\\<not> has_disc disc m) = (as = [] \\<and> ms = m) &&&\n    (\\<not> has_disc_negated disc False m) = (getNeg as = []) &&&\n    (has_disc disc m \\<Longrightarrow> as \\<noteq> [])", "proof -\n  \\<comment> \\<open>better simplification rule\\<close>"], ["proof (state)\ngoal (9 subgoals):\n 1. (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n     matches \\<gamma> ms a p) =\n    matches \\<gamma> m a p\n 2. normalized_nnf_match ms\n 3. \\<not> has_disc disc ms\n 4. \\<forall>disc2.\n       \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n 5. \\<forall>disc2 sel2.\n       normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n       normalized_n_primitive (disc2, sel2) P ms\n 6. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms\n 7. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n 8. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 9. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  wf_disc_sel (disc, sel) C\n  primitive_extractor (disc, sel) m = (as, ms)", "have assm3': \"(as, ms) = primitive_extractor (disc, sel) m\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  wf_disc_sel (disc, sel) C\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. (as, ms) = primitive_extractor (disc, sel) m", "by simp"], ["proof (state)\nthis:\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (9 subgoals):\n 1. (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n     matches \\<gamma> ms a p) =\n    matches \\<gamma> m a p\n 2. normalized_nnf_match ms\n 3. \\<not> has_disc disc ms\n 4. \\<forall>disc2.\n       \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n 5. \\<forall>disc2 sel2.\n       normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n       normalized_n_primitive (disc2, sel2) P ms\n 6. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms\n 7. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n 8. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 9. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "with assms(1) assms(2)"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  wf_disc_sel (disc, sel) C\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and> matches \\<gamma> ms a p \\<longleftrightarrow> matches \\<gamma> m a p\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  wf_disc_sel (disc, sel) C\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n     matches \\<gamma> ms a p) =\n    matches \\<gamma> m a p", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny; wf_disc_sel (disc, sel) C;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> MatchAny a p\n 2. \\<And>aa as ms.\n       \\<lbrakk>normalized_nnf_match (Match aa); wf_disc_sel (disc, sel) C;\n        (as, ms) = primitive_extractor (disc, sel) (Match aa)\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (Match aa) a p\n 3. \\<And>aa as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match aa));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match aa))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (Match aa)) a p\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    wf_disc_sel (disc, sel) C;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (matches \\<gamma>\n (alist_and (NegPos_map C as)) a p \\<and>\nmatches \\<gamma> ms a p) =\n                                     matches \\<gamma> ms1 a p;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2; wf_disc_sel (disc, sel) C;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as))\n                               a p \\<and>\n                              matches \\<gamma> ms a p) =\n                             matches \\<gamma> ms2 a p;\n        normalized_nnf_match (MatchAnd ms1 ms2); wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchAnd ms1 ms2) a p\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (MatchNot va)) a p\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (MatchAnd va vb)) a p\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot MatchAny) a p", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match ms1_; wf_disc_sel (disc, sel) C;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C ?as)) a\n                      p \\<and>\n                     matches \\<gamma> ?ms a p) =\n                    matches \\<gamma> ms1_ a p\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_; wf_disc_sel (disc, sel) C;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C ?as)) a\n                      p \\<and>\n                     matches \\<gamma> ?ms a p) =\n                    matches \\<gamma> ms2_ a p\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  wf_disc_sel (disc, sel) C\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny; wf_disc_sel (disc, sel) C;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> MatchAny a p\n 2. \\<And>aa as ms.\n       \\<lbrakk>normalized_nnf_match (Match aa); wf_disc_sel (disc, sel) C;\n        (as, ms) = primitive_extractor (disc, sel) (Match aa)\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (Match aa) a p\n 3. \\<And>aa as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match aa));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match aa))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (Match aa)) a p\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    wf_disc_sel (disc, sel) C;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (matches \\<gamma>\n (alist_and (NegPos_map C as)) a p \\<and>\nmatches \\<gamma> ms a p) =\n                                     matches \\<gamma> ms1 a p;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2; wf_disc_sel (disc, sel) C;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as))\n                               a p \\<and>\n                              matches \\<gamma> ms a p) =\n                             matches \\<gamma> ms2 a p;\n        normalized_nnf_match (MatchAnd ms1 ms2); wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchAnd ms1 ms2) a p\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (MatchNot va)) a p\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (MatchAnd va vb)) a p\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot MatchAny) a p", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ms1_; wf_disc_sel (disc, sel) C;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C ?as)) a\n                      p \\<and>\n                     matches \\<gamma> ?ms a p) =\n                    matches \\<gamma> ms1_ a p\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_; wf_disc_sel (disc, sel) C;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C ?as)) a\n                      p \\<and>\n                     matches \\<gamma> ?ms a p) =\n                    matches \\<gamma> ms2_ a p\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  wf_disc_sel (disc, sel) C\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (1 subgoal):\n 1. (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n     matches \\<gamma> ms a p) =\n    matches \\<gamma> (MatchAnd ms1_ ms2_) a p", "apply(simp split: if_split_asm prod.split_asm add: NegPos_map_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>(matches \\<gamma> (alist_and (NegPos_map C x1)) a p \\<and>\n                 matches \\<gamma> x2 a p) =\n                matches \\<gamma> ms1_ a p;\n        \\<And>x xa as.\n           \\<lbrakk>x = (x1, x2); xa = x1; as = x1a\\<rbrakk>\n           \\<Longrightarrow> (matches \\<gamma>\n                               (alist_and (NegPos_map C x1a)) a p \\<and>\n                              matches \\<gamma> x2a a p) =\n                             matches \\<gamma> ms2_ a p;\n        wf_disc_sel (disc, sel) C; normalized_nnf_match ms1_;\n        normalized_nnf_match ms2_;\n        primitive_extractor (disc, sel) ms1_ = (x1, x2);\n        primitive_extractor (disc, sel) ms2_ = (x1a, x2a);\n        as = x1 @ x1a \\<and> ms = MatchAnd x2 x2a\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma>\n                           (alist_and (NegPos_map C x1 @ NegPos_map C x1a))\n                           a p \\<and>\n                          matches \\<gamma> (MatchAnd x2 x2a) a p) =\n                         matches \\<gamma> (MatchAnd ms1_ ms2_) a p", "apply(auto simp add: alist_and_append bunch_of_lemmata_about_matches)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n   matches \\<gamma> ms a p) =\n  matches \\<gamma> (MatchAnd ms1_ ms2_) a p\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny; wf_disc_sel (disc, sel) C;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> MatchAny a p\n 2. \\<And>aa as ms.\n       \\<lbrakk>normalized_nnf_match (Match aa); wf_disc_sel (disc, sel) C;\n        (as, ms) = primitive_extractor (disc, sel) (Match aa)\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (Match aa) a p\n 3. \\<And>aa as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match aa));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match aa))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (Match aa)) a p\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (MatchNot va)) a p\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot (MatchAnd va vb)) a p\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        wf_disc_sel (disc, sel) C;\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                           p \\<and>\n                          matches \\<gamma> ms a p) =\n                         matches \\<gamma> (MatchNot MatchAny) a p", "qed(simp_all add: bunch_of_lemmata_about_matches wf_disc_sel.simps split: if_split_asm)"], ["proof (state)\nthis:\n  (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n   matches \\<gamma> ms a p) =\n  matches \\<gamma> m a p\n\ngoal (8 subgoals):\n 1. normalized_nnf_match ms\n 2. \\<not> has_disc disc ms\n 3. \\<forall>disc2.\n       \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n 4. \\<forall>disc2 sel2.\n       normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n       normalized_n_primitive (disc2, sel2) P ms\n 5. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms\n 6. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n 7. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 8. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms(1) assm3'"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"normalized_nnf_match ms\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. normalized_nnf_match ms", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "case 2"], ["proof (state)\nthis:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match ms", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  normalized_nnf_match ms\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "case 3"], ["proof (state)\nthis:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match ms", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  normalized_nnf_match ms\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?ms\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?ms\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?ms\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?ms\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match ms", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as ms.\n                \\<lbrakk>normalized_nnf_match ms1_;\n                 (as, ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n                \\<Longrightarrow> normalized_nnf_match ms;\n     \\<And>a b xa y as ms.\n        \\<lbrakk>(a, b) = primitive_extractor (disc, sel) ms1_;\n         (xa, y) = (a, b); normalized_nnf_match ms2_;\n         (as, ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n        \\<Longrightarrow> normalized_nnf_match ms;\n     normalized_nnf_match (MatchAnd ms1_ ms2_);\n     (as, ms) =\n     primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ms", "(*if i don't clarify, the simplifier loops*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as ms.\n                \\<lbrakk>normalized_nnf_match ms1_;\n                 (as, ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n                \\<Longrightarrow> normalized_nnf_match ms;\n     \\<And>a b xa y as ms.\n        \\<lbrakk>(a, b) = primitive_extractor (disc, sel) ms1_;\n         (xa, y) = (a, b); normalized_nnf_match ms2_;\n         (as, ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n        \\<Longrightarrow> normalized_nnf_match ms;\n     normalized_nnf_match (MatchAnd ms1_ ms2_);\n     (as, ms) =\n     primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ms", "apply(simp split: prod.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  normalized_nnf_match ms\n\ngoal (4 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 2. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 3. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms\n 4. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match ms", "qed(simp_all)"], ["proof (state)\nthis:\n  normalized_nnf_match ms\n\ngoal (7 subgoals):\n 1. \\<not> has_disc disc ms\n 2. \\<forall>disc2.\n       \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n 3. \\<forall>disc2 sel2.\n       normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n       normalized_n_primitive (disc2, sel2) P ms\n 4. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms\n 5. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n 6. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 7. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms(1) assm3'"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"\\<not> has_disc disc ms\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc ms", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc ms\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc ms\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<not> has_disc disc ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<not> has_disc disc ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc ms\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc ms\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc ms\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc ms", "qed(simp_all split: if_split_asm prod.split_asm)"], ["proof (state)\nthis:\n  \\<not> has_disc disc ms\n\ngoal (6 subgoals):\n 1. \\<forall>disc2.\n       \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n 2. \\<forall>disc2 sel2.\n       normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n       normalized_n_primitive (disc2, sel2) P ms\n 3. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms\n 4. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n 5. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 6. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms(1) assm3'"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"\\<forall>disc2. \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. \\<forall>disc2.\n       \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (Match a) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc disc2 ms1 \\<longrightarrow> \\<not> has_disc disc2 ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc disc2 ms2 \\<longrightarrow>\n                                \\<not> has_disc disc2 ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "case 2"], ["proof (state)\nthis:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (Match a) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc disc2 ms1 \\<longrightarrow> \\<not> has_disc disc2 ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc disc2 ms2 \\<longrightarrow>\n                                \\<not> has_disc disc2 ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (1 subgoal):\n 1. \\<forall>disc2.\n       \\<not> has_disc disc2 (Match a_) \\<longrightarrow>\n       \\<not> has_disc disc2 ms", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>disc2.\n     \\<not> has_disc disc2 (Match a_) \\<longrightarrow>\n     \\<not> has_disc disc2 ms\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc disc2 ms1 \\<longrightarrow> \\<not> has_disc disc2 ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc disc2 ms2 \\<longrightarrow>\n                                \\<not> has_disc disc2 ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc disc2 ms1 \\<longrightarrow> \\<not> has_disc disc2 ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc disc2 ms2 \\<longrightarrow>\n                                \\<not> has_disc disc2 ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "case 3"], ["proof (state)\nthis:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc disc2 ms1 \\<longrightarrow> \\<not> has_disc disc2 ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc disc2 ms2 \\<longrightarrow>\n                                \\<not> has_disc disc2 ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (1 subgoal):\n 1. \\<forall>disc2.\n       \\<not> has_disc disc2 (MatchNot (Match a_)) \\<longrightarrow>\n       \\<not> has_disc disc2 ms", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>disc2.\n     \\<not> has_disc disc2 (MatchNot (Match a_)) \\<longrightarrow>\n     \\<not> has_disc disc2 ms\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc disc2 ms1 \\<longrightarrow> \\<not> has_disc disc2 ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc disc2 ms2 \\<longrightarrow>\n                                \\<not> has_disc disc2 ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc disc2 ms1 \\<longrightarrow> \\<not> has_disc disc2 ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc disc2 ms2 \\<longrightarrow>\n                                \\<not> has_disc disc2 ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc disc2 ms1_ \\<longrightarrow>\n                       \\<not> has_disc disc2 ?ms\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc disc2 ms2_ \\<longrightarrow>\n                       \\<not> has_disc disc2 ?ms\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc disc2 ms1 \\<longrightarrow> \\<not> has_disc disc2 ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc disc2 ms2 \\<longrightarrow>\n                                \\<not> has_disc disc2 ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc disc2 ms1_ \\<longrightarrow>\n                       \\<not> has_disc disc2 ?ms\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc disc2 ms2_ \\<longrightarrow>\n                       \\<not> has_disc disc2 ?ms\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (1 subgoal):\n 1. \\<forall>disc2.\n       \\<not> has_disc disc2 (MatchAnd ms1_ ms2_) \\<longrightarrow>\n       \\<not> has_disc disc2 ms", "by(simp split: prod.split_asm)"], ["proof (state)\nthis:\n  \\<forall>disc2.\n     \\<not> has_disc disc2 (MatchAnd ms1_ ms2_) \\<longrightarrow>\n     \\<not> has_disc disc2 ms\n\ngoal (4 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2 MatchAny \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 2. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 3. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms\n 4. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc disc2\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc disc2 ms", "qed(simp_all)"], ["proof (state)\nthis:\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n\ngoal (5 subgoals):\n 1. \\<forall>disc2 sel2.\n       normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n       normalized_n_primitive (disc2, sel2) P ms\n 2. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms\n 3. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n 4. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 5. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms(1) assm3'"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"\\<forall>disc2. \\<not> has_disc_negated disc2 neg m \\<longrightarrow> \\<not> has_disc_negated disc2 neg ms\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (Match a) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc_negated disc2 neg ms1 \\<longrightarrow>\n  \\<not> has_disc_negated disc2 neg ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc_negated disc2 neg\n  ms2 \\<longrightarrow>\n                                \\<not> has_disc_negated disc2 neg ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "case 2"], ["proof (state)\nthis:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (Match a) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc_negated disc2 neg ms1 \\<longrightarrow>\n  \\<not> has_disc_negated disc2 neg ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc_negated disc2 neg\n  ms2 \\<longrightarrow>\n                                \\<not> has_disc_negated disc2 neg ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (1 subgoal):\n 1. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg (Match a_) \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 neg (Match a_) \\<longrightarrow>\n     \\<not> has_disc_negated disc2 neg ms\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc_negated disc2 neg ms1 \\<longrightarrow>\n  \\<not> has_disc_negated disc2 neg ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc_negated disc2 neg\n  ms2 \\<longrightarrow>\n                                \\<not> has_disc_negated disc2 neg ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc_negated disc2 neg ms1 \\<longrightarrow>\n  \\<not> has_disc_negated disc2 neg ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc_negated disc2 neg\n  ms2 \\<longrightarrow>\n                                \\<not> has_disc_negated disc2 neg ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "case 3"], ["proof (state)\nthis:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot (Match a)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc_negated disc2 neg ms1 \\<longrightarrow>\n  \\<not> has_disc_negated disc2 neg ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc_negated disc2 neg\n  ms2 \\<longrightarrow>\n                                \\<not> has_disc_negated disc2 neg ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (1 subgoal):\n 1. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg\n               (MatchNot (Match a_)) \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 neg\n             (MatchNot (Match a_)) \\<longrightarrow>\n     \\<not> has_disc_negated disc2 neg ms\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc_negated disc2 neg ms1 \\<longrightarrow>\n  \\<not> has_disc_negated disc2 neg ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc_negated disc2 neg\n  ms2 \\<longrightarrow>\n                                \\<not> has_disc_negated disc2 neg ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc_negated disc2 neg ms1 \\<longrightarrow>\n  \\<not> has_disc_negated disc2 neg ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc_negated disc2 neg\n  ms2 \\<longrightarrow>\n                                \\<not> has_disc_negated disc2 neg ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc_negated disc2 neg\n                               ms1_ \\<longrightarrow>\n                       \\<not> has_disc_negated disc2 neg ?ms\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc_negated disc2 neg\n                               ms2_ \\<longrightarrow>\n                       \\<not> has_disc_negated disc2 neg ?ms\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2.\n  \\<not> has_disc_negated disc2 neg ms1 \\<longrightarrow>\n  \\<not> has_disc_negated disc2 neg ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2.\n                                \\<not> has_disc_negated disc2 neg\n  ms2 \\<longrightarrow>\n                                \\<not> has_disc_negated disc2 neg ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchAnd ms1 ms2) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc_negated disc2 neg\n                               ms1_ \\<longrightarrow>\n                       \\<not> has_disc_negated disc2 neg ?ms\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc_negated disc2 neg\n                               ms2_ \\<longrightarrow>\n                       \\<not> has_disc_negated disc2 neg ?ms\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (1 subgoal):\n 1. \\<forall>disc2.\n       \\<not> has_disc_negated disc2 neg\n               (MatchAnd ms1_ ms2_) \\<longrightarrow>\n       \\<not> has_disc_negated disc2 neg ms", "by(simp split: prod.split_asm)"], ["proof (state)\nthis:\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 neg\n             (MatchAnd ms1_ ms2_) \\<longrightarrow>\n     \\<not> has_disc_negated disc2 neg ms\n\ngoal (4 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    MatchAny \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 2. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchNot va)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 3. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot\n(MatchAnd va vb)) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms\n 4. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2.\n                            \\<not> has_disc_negated disc2 neg\n                                    (MatchNot MatchAny) \\<longrightarrow>\n                            \\<not> has_disc_negated disc2 neg ms", "qed(simp_all)"], ["proof (state)\nthis:\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 neg ms\n\ngoal (4 subgoals):\n 1. \\<forall>disc2 sel2.\n       normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n       normalized_n_primitive (disc2, sel2) P ms\n 2. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n 3. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 4. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms(1) assm3'"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"\\<forall>disc2 sel2. normalized_n_primitive (disc2, sel2) P m \\<longrightarrow> normalized_n_primitive (disc2, sel2) P ms\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. \\<forall>disc2 sel2.\n       normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n       normalized_n_primitive (disc2, sel2) P ms", "apply(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             MatchAny \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (Match a) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (Match a)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2 sel2.\n  normalized_n_primitive (disc2, sel2) P ms1 \\<longrightarrow>\n  normalized_n_primitive (disc2, sel2) P ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2 sel2.\n                                normalized_n_primitive (disc2, sel2) P\n                                 ms2 \\<longrightarrow>\n                                normalized_n_primitive (disc2, sel2) P ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchAnd ms1 ms2) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchNot va)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchAnd va vb)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot MatchAny) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms", "apply(simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (Match a) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (Match a)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2 sel2.\n  normalized_n_primitive (disc2, sel2) P ms1 \\<longrightarrow>\n  normalized_n_primitive (disc2, sel2) P ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2 sel2.\n                                normalized_n_primitive (disc2, sel2) P\n                                 ms2 \\<longrightarrow>\n                                normalized_n_primitive (disc2, sel2) P ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchAnd ms1 ms2) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchNot va)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchAnd va vb)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot MatchAny) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (Match a)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2 sel2.\n  normalized_n_primitive (disc2, sel2) P ms1 \\<longrightarrow>\n  normalized_n_primitive (disc2, sel2) P ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2 sel2.\n                                normalized_n_primitive (disc2, sel2) P\n                                 ms2 \\<longrightarrow>\n                                normalized_n_primitive (disc2, sel2) P ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchAnd ms1 ms2) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchNot va)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchAnd va vb)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot MatchAny) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>disc2 sel2.\n  normalized_n_primitive (disc2, sel2) P ms1 \\<longrightarrow>\n  normalized_n_primitive (disc2, sel2) P ms;\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>disc2 sel2.\n                                normalized_n_primitive (disc2, sel2) P\n                                 ms2 \\<longrightarrow>\n                                normalized_n_primitive (disc2, sel2) P ms;\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchAnd ms1 ms2) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 2. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchNot va)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 3. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchAnd va vb)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 4. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot MatchAny) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms", "apply(simp split: prod.split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchNot va)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 2. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot (MatchAnd va vb)) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms\n 3. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>disc2 sel2.\n                            normalized_n_primitive (disc2, sel2) P\n                             (MatchNot MatchAny) \\<longrightarrow>\n                            normalized_n_primitive (disc2, sel2) P ms", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) P ms\n\ngoal (3 subgoals):\n 1. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n 2. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 3. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms(1) assm3'"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"\\<not> has_disc disc m \\<longleftrightarrow> as = [] \\<and> ms = m\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (Match a)) =\n                         (as = [] \\<and> ms = Match a)\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (Match a))) =\n                         (as = [] \\<and> ms = MatchNot (Match a))\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc disc ms1) =\n                                     (as = [] \\<and> ms = ms1);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc disc ms2) =\n                             (as = [] \\<and> ms = ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchAnd ms1 ms2)) =\n                         (as = [] \\<and> ms = MatchAnd ms1 ms2)\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "case 2"], ["proof (state)\nthis:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (Match a)) =\n                         (as = [] \\<and> ms = Match a)\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (Match a))) =\n                         (as = [] \\<and> ms = MatchNot (Match a))\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc disc ms1) =\n                                     (as = [] \\<and> ms = ms1);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc disc ms2) =\n                             (as = [] \\<and> ms = ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchAnd ms1 ms2)) =\n                         (as = [] \\<and> ms = MatchAnd ms1 ms2)\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc disc (Match a_)) = (as = [] \\<and> ms = Match a_)", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  (\\<not> has_disc disc (Match a_)) = (as = [] \\<and> ms = Match a_)\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (Match a))) =\n                         (as = [] \\<and> ms = MatchNot (Match a))\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc disc ms1) =\n                                     (as = [] \\<and> ms = ms1);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc disc ms2) =\n                             (as = [] \\<and> ms = ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchAnd ms1 ms2)) =\n                         (as = [] \\<and> ms = MatchAnd ms1 ms2)\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (Match a))) =\n                         (as = [] \\<and> ms = MatchNot (Match a))\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc disc ms1) =\n                                     (as = [] \\<and> ms = ms1);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc disc ms2) =\n                             (as = [] \\<and> ms = ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchAnd ms1 ms2)) =\n                         (as = [] \\<and> ms = MatchAnd ms1 ms2)\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "case 3"], ["proof (state)\nthis:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (Match a))) =\n                         (as = [] \\<and> ms = MatchNot (Match a))\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc disc ms1) =\n                                     (as = [] \\<and> ms = ms1);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc disc ms2) =\n                             (as = [] \\<and> ms = ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchAnd ms1 ms2)) =\n                         (as = [] \\<and> ms = MatchAnd ms1 ms2)\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc disc (MatchNot (Match a_))) =\n    (as = [] \\<and> ms = MatchNot (Match a_))", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  (\\<not> has_disc disc (MatchNot (Match a_))) =\n  (as = [] \\<and> ms = MatchNot (Match a_))\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc disc ms1) =\n                                     (as = [] \\<and> ms = ms1);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc disc ms2) =\n                             (as = [] \\<and> ms = ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchAnd ms1 ms2)) =\n                         (as = [] \\<and> ms = MatchAnd ms1 ms2)\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc disc ms1) =\n                                     (as = [] \\<and> ms = ms1);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc disc ms2) =\n                             (as = [] \\<and> ms = ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchAnd ms1 ms2)) =\n                         (as = [] \\<and> ms = MatchAnd ms1 ms2)\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc disc ms1_) =\n                    (?as = [] \\<and> ?ms = ms1_)\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc disc ms2_) =\n                    (?as = [] \\<and> ?ms = ms2_)\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc disc ms1) =\n                                     (as = [] \\<and> ms = ms1);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc disc ms2) =\n                             (as = [] \\<and> ms = ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchAnd ms1 ms2)) =\n                         (as = [] \\<and> ms = MatchAnd ms1 ms2)\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc disc ms1_) =\n                    (?as = [] \\<and> ?ms = ms1_)\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc disc ms2_) =\n                    (?as = [] \\<and> ?ms = ms2_)\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc disc (MatchAnd ms1_ ms2_)) =\n    (as = [] \\<and> ms = MatchAnd ms1_ ms2_)", "by(auto split: prod.split_asm)"], ["proof (state)\nthis:\n  (\\<not> has_disc disc (MatchAnd ms1_ ms2_)) =\n  (as = [] \\<and> ms = MatchAnd ms1_ ms2_)\n\ngoal (4 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc MatchAny) =\n                         (as = [] \\<and> ms = MatchAny)\n 2. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot (MatchNot va))) =\n                         (as = [] \\<and> ms = MatchNot (MatchNot va))\n 3. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc\n                                  (MatchNot (MatchAnd va vb))) =\n                         (as = [] \\<and> ms = MatchNot (MatchAnd va vb))\n 4. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc (MatchNot MatchAny)) =\n                         (as = [] \\<and> ms = MatchNot MatchAny)", "qed(simp_all)"], ["proof (state)\nthis:\n  (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n\ngoal (2 subgoals):\n 1. (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n 2. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms(1) assm3'"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"\\<not> has_disc_negated disc False m \\<longleftrightarrow> getNeg as = []\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc_negated disc False m) = (getNeg as = [])", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False (Match a)) =\n                         (getNeg as = [])\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (Match a))) =\n                         (getNeg as = [])\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc_negated disc False\n        ms1) =\n                                     (getNeg as = []);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2) =\n                             (getNeg as = []);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchAnd ms1 ms2)) =\n                         (getNeg as = [])\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "case 2"], ["proof (state)\nthis:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False (Match a)) =\n                         (getNeg as = [])\n 3. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (Match a))) =\n                         (getNeg as = [])\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc_negated disc False\n        ms1) =\n                                     (getNeg as = []);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2) =\n                             (getNeg as = []);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchAnd ms1 ms2)) =\n                         (getNeg as = [])\n 5. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 6. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 7. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (Match a_)\n  (as, ms) = primitive_extractor (disc, sel) (Match a_)\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc_negated disc False (Match a_)) = (getNeg as = [])", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  (\\<not> has_disc_negated disc False (Match a_)) = (getNeg as = [])\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (Match a))) =\n                         (getNeg as = [])\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc_negated disc False\n        ms1) =\n                                     (getNeg as = []);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2) =\n                             (getNeg as = []);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchAnd ms1 ms2)) =\n                         (getNeg as = [])\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (Match a))) =\n                         (getNeg as = [])\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc_negated disc False\n        ms1) =\n                                     (getNeg as = []);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2) =\n                             (getNeg as = []);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchAnd ms1 ms2)) =\n                         (getNeg as = [])\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "case 3"], ["proof (state)\nthis:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>a as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (Match a))) =\n                         (getNeg as = [])\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc_negated disc False\n        ms1) =\n                                     (getNeg as = []);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2) =\n                             (getNeg as = []);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchAnd ms1 ms2)) =\n                         (getNeg as = [])\n 4. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 5. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 6. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_nnf_match (MatchNot (Match a_))\n  (as, ms) = primitive_extractor (disc, sel) (MatchNot (Match a_))\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc_negated disc False (MatchNot (Match a_))) =\n    (getNeg as = [])", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  (\\<not> has_disc_negated disc False (MatchNot (Match a_))) =\n  (getNeg as = [])\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc_negated disc False\n        ms1) =\n                                     (getNeg as = []);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2) =\n                             (getNeg as = []);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchAnd ms1 ms2)) =\n                         (getNeg as = [])\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc_negated disc False\n        ms1) =\n                                     (getNeg as = []);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2) =\n                             (getNeg as = []);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchAnd ms1 ms2)) =\n                         (getNeg as = [])\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc_negated disc False ms1_) =\n                    (getNeg ?as = [])\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2_) =\n                    (getNeg ?as = [])\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> (\\<not> has_disc_negated disc False\n        ms1) =\n                                     (getNeg as = []);\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2) =\n                             (getNeg as = []);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchAnd ms1 ms2)) =\n                         (getNeg as = [])\n 3. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 4. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 5. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc_negated disc False ms1_) =\n                    (getNeg ?as = [])\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> (\\<not> has_disc_negated disc False ms2_) =\n                    (getNeg ?as = [])\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (1 subgoal):\n 1. (\\<not> has_disc_negated disc False (MatchAnd ms1_ ms2_)) =\n    (getNeg as = [])", "by(simp add: getNeg_append split: prod.split_asm)"], ["proof (state)\nthis:\n  (\\<not> has_disc_negated disc False (MatchAnd ms1_ ms2_)) =\n  (getNeg as = [])\n\ngoal (4 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False MatchAny) =\n                         (getNeg as = [])\n 2. \\<And>va as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchNot va))) =\n                         (getNeg as = [])\n 3. \\<And>va vb as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot (MatchAnd va vb))) =\n                         (getNeg as = [])\n 4. \\<And>as ms.\n       \\<lbrakk>normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc False\n                                  (MatchNot MatchAny)) =\n                         (getNeg as = [])", "qed(simp_all)"], ["proof (state)\nthis:\n  (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n\ngoal (1 subgoal):\n 1. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "from assms(1) assm3'"], ["proof (chain)\npicking this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m", "show \"has_disc disc m \\<Longrightarrow> as \\<noteq> []\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m\n  (as, ms) = primitive_extractor (disc, sel) m\n\ngoal (1 subgoal):\n 1. has_disc disc m \\<Longrightarrow> as \\<noteq> []", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>has_disc disc MatchAny; normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 2. \\<And>a as ms.\n       \\<lbrakk>has_disc disc (Match a); normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 3. \\<And>a as ms.\n       \\<lbrakk>has_disc disc (MatchNot (Match a));\n        normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>has_disc disc ms1; normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> as \\<noteq> [];\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            has_disc disc ms2; normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> as \\<noteq> [];\n        has_disc disc (MatchAnd ms1 ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 5. \\<And>va as ms.\n       \\<lbrakk>has_disc disc (MatchNot (MatchNot va));\n        normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 6. \\<And>va vb as ms.\n       \\<lbrakk>has_disc disc (MatchNot (MatchAnd va vb));\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 7. \\<And>as ms.\n       \\<lbrakk>has_disc disc (MatchNot MatchAny);\n        normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>has_disc disc ms1_; normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> ?as \\<noteq> []\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   has_disc disc ms2_; normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> ?as \\<noteq> []\n  has_disc disc (MatchAnd ms1_ ms2_)\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>has_disc disc MatchAny; normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 2. \\<And>a as ms.\n       \\<lbrakk>has_disc disc (Match a); normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 3. \\<And>a as ms.\n       \\<lbrakk>has_disc disc (MatchNot (Match a));\n        normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>has_disc disc ms1; normalized_nnf_match ms1;\n                    (as, ms) = primitive_extractor (disc, sel) ms1\\<rbrakk>\n                   \\<Longrightarrow> as \\<noteq> [];\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            has_disc disc ms2; normalized_nnf_match ms2;\n            (as, ms) = primitive_extractor (disc, sel) ms2\\<rbrakk>\n           \\<Longrightarrow> as \\<noteq> [];\n        has_disc disc (MatchAnd ms1 ms2);\n        normalized_nnf_match (MatchAnd ms1 ms2);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2)\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 5. \\<And>va as ms.\n       \\<lbrakk>has_disc disc (MatchNot (MatchNot va));\n        normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 6. \\<And>va vb as ms.\n       \\<lbrakk>has_disc disc (MatchNot (MatchAnd va vb));\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 7. \\<And>as ms.\n       \\<lbrakk>has_disc disc (MatchNot MatchAny);\n        normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>has_disc disc ms1_; normalized_nnf_match ms1_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms1_\\<rbrakk>\n  \\<Longrightarrow> ?as \\<noteq> []\n  \\<lbrakk>?x = primitive_extractor (disc, sel) ms1_; (?xa, ?y) = ?x;\n   has_disc disc ms2_; normalized_nnf_match ms2_;\n   (?as, ?ms) = primitive_extractor (disc, sel) ms2_\\<rbrakk>\n  \\<Longrightarrow> ?as \\<noteq> []\n  has_disc disc (MatchAnd ms1_ ms2_)\n  normalized_nnf_match (MatchAnd ms1_ ms2_)\n  (as, ms) = primitive_extractor (disc, sel) (MatchAnd ms1_ ms2_)\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "apply(simp split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>as.\n                   \\<lbrakk>has_disc disc ms1_; as = x1\\<rbrakk>\n                   \\<Longrightarrow> x1 \\<noteq> [];\n        \\<And>x xa as.\n           \\<lbrakk>x = (x1, x2); xa = x1; has_disc disc ms2_;\n            as = x1a\\<rbrakk>\n           \\<Longrightarrow> x1a \\<noteq> [];\n        has_disc disc ms1_ \\<or> has_disc disc ms2_;\n        normalized_nnf_match ms1_; normalized_nnf_match ms2_;\n        primitive_extractor (disc, sel) ms1_ = (x1, x2);\n        primitive_extractor (disc, sel) ms2_ = (x1a, x2a);\n        as = x1 @ x1a \\<and> ms = MatchAnd x2 x2a\\<rbrakk>\n       \\<Longrightarrow> x1 = [] \\<longrightarrow> x1a \\<noteq> []", "by metis"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>has_disc disc MatchAny; normalized_nnf_match MatchAny;\n        (as, ms) = primitive_extractor (disc, sel) MatchAny\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 2. \\<And>a as ms.\n       \\<lbrakk>has_disc disc (Match a); normalized_nnf_match (Match a);\n        (as, ms) = primitive_extractor (disc, sel) (Match a)\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 3. \\<And>a as ms.\n       \\<lbrakk>has_disc disc (MatchNot (Match a));\n        normalized_nnf_match (MatchNot (Match a));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (Match a))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 4. \\<And>va as ms.\n       \\<lbrakk>has_disc disc (MatchNot (MatchNot va));\n        normalized_nnf_match (MatchNot (MatchNot va));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 5. \\<And>va vb as ms.\n       \\<lbrakk>has_disc disc (MatchNot (MatchAnd va vb));\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb))\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []\n 6. \\<And>as ms.\n       \\<lbrakk>has_disc disc (MatchNot MatchAny);\n        normalized_nnf_match (MatchNot MatchAny);\n        (as, ms) =\n        primitive_extractor (disc, sel) (MatchNot MatchAny)\\<rbrakk>\n       \\<Longrightarrow> as \\<noteq> []", "qed(simp_all)"], ["proof (state)\nthis:\n  has_disc disc m \\<Longrightarrow> as \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_disc_negated_primitive_extractor:\n  assumes \"normalized_nnf_match m\"\n  shows \"has_disc_negated disc False m \\<longleftrightarrow> (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_disc_negated disc False m =\n    (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_disc_negated disc False m =\n    (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))", "obtain as ms where asms: \"primitive_extractor (disc, sel) m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False m =\n    (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))", "hence \"has_disc_negated disc False m \\<longleftrightarrow> (\\<exists>a. Neg a \\<in> set as)\""], ["proof (prove)\nusing this:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False m = (\\<exists>a. Neg a \\<in> set as)", "using assms"], ["proof (prove)\nusing this:\n  primitive_extractor (disc, sel) m = (as, ms)\n  normalized_nnf_match m\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False m = (\\<exists>a. Neg a \\<in> set as)", "proof(induction m arbitrary: as ms)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) (Match x) = (as, ms);\n        normalized_nnf_match (Match x)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (Match x) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>m as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m = (as, ms);\n                    normalized_nnf_match m\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n        normalized_nnf_match (MatchNot m)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 3. \\<And>m1 m2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 4. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "case Match"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) (Match x_) = (as, ms)\n  normalized_nnf_match (Match x_)\n\ngoal (4 subgoals):\n 1. \\<And>x as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) (Match x) = (as, ms);\n        normalized_nnf_match (Match x)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (Match x) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>m as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m = (as, ms);\n                    normalized_nnf_match m\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n        normalized_nnf_match (MatchNot m)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 3. \\<And>m1 m2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 4. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "thus ?case"], ["proof (prove)\nusing this:\n  primitive_extractor (disc, sel) (Match x_) = (as, ms)\n  normalized_nnf_match (Match x_)\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False (Match x_) =\n    (\\<exists>a. Neg a \\<in> set as)", "by(simp split: if_split_asm) fastforce"], ["proof (state)\nthis:\n  has_disc_negated disc False (Match x_) = (\\<exists>a. Neg a \\<in> set as)\n\ngoal (3 subgoals):\n 1. \\<And>m as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m = (as, ms);\n                    normalized_nnf_match m\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n        normalized_nnf_match (MatchNot m)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>m1 m2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 3. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m = (as, ms);\n                    normalized_nnf_match m\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n        normalized_nnf_match (MatchNot m)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>m1 m2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 3. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "case (MatchNot m)"], ["proof (state)\nthis:\n  \\<lbrakk>primitive_extractor (disc, sel) m = (?as, ?ms);\n   normalized_nnf_match m\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc False m =\n                    (\\<exists>a. Neg a \\<in> set ?as)\n  primitive_extractor (disc, sel) (MatchNot m) = (as, ms)\n  normalized_nnf_match (MatchNot m)\n\ngoal (3 subgoals):\n 1. \\<And>m as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m = (as, ms);\n                    normalized_nnf_match m\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n        normalized_nnf_match (MatchNot m)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>m1 m2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 3. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>primitive_extractor (disc, sel) m = (?as, ?ms);\n   normalized_nnf_match m\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc False m =\n                    (\\<exists>a. Neg a \\<in> set ?as)\n  primitive_extractor (disc, sel) (MatchNot m) = (as, ms)\n  normalized_nnf_match (MatchNot m)\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False (MatchNot m) =\n    (\\<exists>a. Neg a \\<in> set as)", "proof(induction m)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) (Match x) =\n                            (as, ms);\n                    normalized_nnf_match (Match x)\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False (Match x) =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot (Match x)) = (as, ms);\n        normalized_nnf_match (MatchNot (Match x))\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchNot (Match x)) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>as ms.\n                            \\<lbrakk>primitive_extractor (disc, sel) m =\n                                     (as, ms);\n                             normalized_nnf_match m\\<rbrakk>\n                            \\<Longrightarrow> has_disc_negated disc False\n         m =\n        (\\<exists>a. Neg a \\<in> set as);\n                 primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n                 normalized_nnf_match (MatchNot m)\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                                  (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n            normalized_nnf_match (MatchNot m)\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot (MatchNot m)) = (as, ms);\n        normalized_nnf_match (MatchNot (MatchNot m))\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False\n                          (MatchNot (MatchNot m)) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 3. \\<And>m1 m2.\n       \\<lbrakk>\\<lbrakk>\\<And>as ms.\n                            \\<lbrakk>primitive_extractor (disc, sel) m1 =\n                                     (as, ms);\n                             normalized_nnf_match m1\\<rbrakk>\n                            \\<Longrightarrow> has_disc_negated disc False\n         m1 =\n        (\\<exists>a. Neg a \\<in> set as);\n                 primitive_extractor (disc, sel) (MatchNot m1) = (as, ms);\n                 normalized_nnf_match (MatchNot m1)\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False\n                                   (MatchNot m1) =\n                                  (\\<exists>a. Neg a \\<in> set as);\n        \\<lbrakk>\\<And>as ms.\n                    \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n                     normalized_nnf_match m2\\<rbrakk>\n                    \\<Longrightarrow> has_disc_negated disc False m2 =\n(\\<exists>a. Neg a \\<in> set as);\n         primitive_extractor (disc, sel) (MatchNot m2) = (as, ms);\n         normalized_nnf_match (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> has_disc_negated disc False (MatchNot m2) =\n                          (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) (MatchAnd m1 m2) =\n                    (as, ms);\n            normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd m1 m2)) =\n        (as, ms);\n        normalized_nnf_match (MatchNot (MatchAnd m1 m2))\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False\n                          (MatchNot (MatchAnd m1 m2)) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 4. \\<lbrakk>\\<And>as ms.\n                \\<lbrakk>primitive_extractor (disc, sel) MatchAny =\n                         (as, ms);\n                 normalized_nnf_match MatchAny\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                                  (\\<exists>a. Neg a \\<in> set as);\n     primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n     normalized_nnf_match (MatchNot MatchAny)\\<rbrakk>\n    \\<Longrightarrow> has_disc_negated disc False (MatchNot MatchAny) =\n                      (\\<exists>a. Neg a \\<in> set as)", "case Match"], ["proof (state)\nthis:\n  \\<lbrakk>primitive_extractor (disc, sel) (Match x_) = (?as, ?ms);\n   normalized_nnf_match (Match x_)\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc False (Match x_) =\n                    (\\<exists>a. Neg a \\<in> set ?as)\n  primitive_extractor (disc, sel) (MatchNot (Match x_)) = (as, ms)\n  normalized_nnf_match (MatchNot (Match x_))\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) (Match x) =\n                            (as, ms);\n                    normalized_nnf_match (Match x)\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False (Match x) =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot (Match x)) = (as, ms);\n        normalized_nnf_match (MatchNot (Match x))\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchNot (Match x)) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>as ms.\n                            \\<lbrakk>primitive_extractor (disc, sel) m =\n                                     (as, ms);\n                             normalized_nnf_match m\\<rbrakk>\n                            \\<Longrightarrow> has_disc_negated disc False\n         m =\n        (\\<exists>a. Neg a \\<in> set as);\n                 primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n                 normalized_nnf_match (MatchNot m)\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                                  (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n            normalized_nnf_match (MatchNot m)\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot (MatchNot m)) = (as, ms);\n        normalized_nnf_match (MatchNot (MatchNot m))\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False\n                          (MatchNot (MatchNot m)) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 3. \\<And>m1 m2.\n       \\<lbrakk>\\<lbrakk>\\<And>as ms.\n                            \\<lbrakk>primitive_extractor (disc, sel) m1 =\n                                     (as, ms);\n                             normalized_nnf_match m1\\<rbrakk>\n                            \\<Longrightarrow> has_disc_negated disc False\n         m1 =\n        (\\<exists>a. Neg a \\<in> set as);\n                 primitive_extractor (disc, sel) (MatchNot m1) = (as, ms);\n                 normalized_nnf_match (MatchNot m1)\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False\n                                   (MatchNot m1) =\n                                  (\\<exists>a. Neg a \\<in> set as);\n        \\<lbrakk>\\<And>as ms.\n                    \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n                     normalized_nnf_match m2\\<rbrakk>\n                    \\<Longrightarrow> has_disc_negated disc False m2 =\n(\\<exists>a. Neg a \\<in> set as);\n         primitive_extractor (disc, sel) (MatchNot m2) = (as, ms);\n         normalized_nnf_match (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> has_disc_negated disc False (MatchNot m2) =\n                          (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) (MatchAnd m1 m2) =\n                    (as, ms);\n            normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd m1 m2)) =\n        (as, ms);\n        normalized_nnf_match (MatchNot (MatchAnd m1 m2))\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False\n                          (MatchNot (MatchAnd m1 m2)) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 4. \\<lbrakk>\\<And>as ms.\n                \\<lbrakk>primitive_extractor (disc, sel) MatchAny =\n                         (as, ms);\n                 normalized_nnf_match MatchAny\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                                  (\\<exists>a. Neg a \\<in> set as);\n     primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n     normalized_nnf_match (MatchNot MatchAny)\\<rbrakk>\n    \\<Longrightarrow> has_disc_negated disc False (MatchNot MatchAny) =\n                      (\\<exists>a. Neg a \\<in> set as)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>primitive_extractor (disc, sel) (Match x_) = (?as, ?ms);\n   normalized_nnf_match (Match x_)\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc False (Match x_) =\n                    (\\<exists>a. Neg a \\<in> set ?as)\n  primitive_extractor (disc, sel) (MatchNot (Match x_)) = (as, ms)\n  normalized_nnf_match (MatchNot (Match x_))\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False (MatchNot (Match x_)) =\n    (\\<exists>a. Neg a \\<in> set as)", "by (simp, fastforce)"], ["proof (state)\nthis:\n  has_disc_negated disc False (MatchNot (Match x_)) =\n  (\\<exists>a. Neg a \\<in> set as)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>as ms.\n                            \\<lbrakk>primitive_extractor (disc, sel) m =\n                                     (as, ms);\n                             normalized_nnf_match m\\<rbrakk>\n                            \\<Longrightarrow> has_disc_negated disc False\n         m =\n        (\\<exists>a. Neg a \\<in> set as);\n                 primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n                 normalized_nnf_match (MatchNot m)\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                                  (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) (MatchNot m) = (as, ms);\n            normalized_nnf_match (MatchNot m)\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False (MatchNot m) =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot (MatchNot m)) = (as, ms);\n        normalized_nnf_match (MatchNot (MatchNot m))\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False\n                          (MatchNot (MatchNot m)) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>m1 m2.\n       \\<lbrakk>\\<lbrakk>\\<And>as ms.\n                            \\<lbrakk>primitive_extractor (disc, sel) m1 =\n                                     (as, ms);\n                             normalized_nnf_match m1\\<rbrakk>\n                            \\<Longrightarrow> has_disc_negated disc False\n         m1 =\n        (\\<exists>a. Neg a \\<in> set as);\n                 primitive_extractor (disc, sel) (MatchNot m1) = (as, ms);\n                 normalized_nnf_match (MatchNot m1)\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False\n                                   (MatchNot m1) =\n                                  (\\<exists>a. Neg a \\<in> set as);\n        \\<lbrakk>\\<And>as ms.\n                    \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n                     normalized_nnf_match m2\\<rbrakk>\n                    \\<Longrightarrow> has_disc_negated disc False m2 =\n(\\<exists>a. Neg a \\<in> set as);\n         primitive_extractor (disc, sel) (MatchNot m2) = (as, ms);\n         normalized_nnf_match (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> has_disc_negated disc False (MatchNot m2) =\n                          (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) (MatchAnd m1 m2) =\n                    (as, ms);\n            normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd m1 m2)) =\n        (as, ms);\n        normalized_nnf_match (MatchNot (MatchAnd m1 m2))\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False\n                          (MatchNot (MatchAnd m1 m2)) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 3. \\<lbrakk>\\<And>as ms.\n                \\<lbrakk>primitive_extractor (disc, sel) MatchAny =\n                         (as, ms);\n                 normalized_nnf_match MatchAny\\<rbrakk>\n                \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                                  (\\<exists>a. Neg a \\<in> set as);\n     primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n     normalized_nnf_match (MatchNot MatchAny)\\<rbrakk>\n    \\<Longrightarrow> has_disc_negated disc False (MatchNot MatchAny) =\n                      (\\<exists>a. Neg a \\<in> set as)", "qed(simp_all)"], ["proof (state)\nthis:\n  has_disc_negated disc False (MatchNot m) =\n  (\\<exists>a. Neg a \\<in> set as)\n\ngoal (2 subgoals):\n 1. \\<And>m1 m2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "case (MatchAnd m1 m2)"], ["proof (state)\nthis:\n  \\<lbrakk>primitive_extractor (disc, sel) m1 = (?as, ?ms);\n   normalized_nnf_match m1\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc False m1 =\n                    (\\<exists>a. Neg a \\<in> set ?as)\n  \\<lbrakk>primitive_extractor (disc, sel) m2 = (?as, ?ms);\n   normalized_nnf_match m2\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc False m2 =\n                    (\\<exists>a. Neg a \\<in> set ?as)\n  primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms)\n  normalized_nnf_match (MatchAnd m1 m2)\n\ngoal (2 subgoals):\n 1. \\<And>m1 m2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)\n 2. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>primitive_extractor (disc, sel) m1 = (?as, ?ms);\n   normalized_nnf_match m1\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc False m1 =\n                    (\\<exists>a. Neg a \\<in> set ?as)\n  \\<lbrakk>primitive_extractor (disc, sel) m2 = (?as, ?ms);\n   normalized_nnf_match m2\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc False m2 =\n                    (\\<exists>a. Neg a \\<in> set ?as)\n  primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms)\n  normalized_nnf_match (MatchAnd m1 m2)\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False (MatchAnd m1 m2) =\n    (\\<exists>a. Neg a \\<in> set as)", "apply(cases \"primitive_extractor (disc, sel) m1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2);\n        primitive_extractor (disc, sel) m1 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)", "apply(cases \"primitive_extractor (disc, sel) m2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>primitive_extractor (disc, sel) m1 = (as, ms);\n                    normalized_nnf_match m1\\<rbrakk>\n                   \\<Longrightarrow> has_disc_negated disc False m1 =\n                                     (\\<exists>a. Neg a \\<in> set as);\n        \\<And>as ms.\n           \\<lbrakk>primitive_extractor (disc, sel) m2 = (as, ms);\n            normalized_nnf_match m2\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc False m2 =\n                             (\\<exists>a. Neg a \\<in> set as);\n        primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms);\n        normalized_nnf_match (MatchAnd m1 m2);\n        primitive_extractor (disc, sel) m1 = (a, b);\n        primitive_extractor (disc, sel) m2 = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False (MatchAnd m1 m2) =\n                         (\\<exists>a. Neg a \\<in> set as)", "by auto"], ["proof (state)\nthis:\n  has_disc_negated disc False (MatchAnd m1 m2) =\n  (\\<exists>a. Neg a \\<in> set as)\n\ngoal (1 subgoal):\n 1. \\<And>as ms.\n       \\<lbrakk>primitive_extractor (disc, sel) MatchAny = (as, ms);\n        normalized_nnf_match MatchAny\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc False MatchAny =\n                         (\\<exists>a. Neg a \\<in> set as)", "qed(simp_all split: if_split_asm)"], ["proof (state)\nthis:\n  has_disc_negated disc False m = (\\<exists>a. Neg a \\<in> set as)\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False m =\n    (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  has_disc_negated disc False m = (\\<exists>a. Neg a \\<in> set as)\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False m =\n    (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))", "using asms"], ["proof (prove)\nusing this:\n  has_disc_negated disc False m = (\\<exists>a. Neg a \\<in> set as)\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. has_disc_negated disc False m =\n    (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))", "by simp"], ["proof (state)\nthis:\n  has_disc_negated disc False m =\n  (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*if i extract something and put it together again unchanged, things do not change*)"], ["", "lemma primitive_extractor_reassemble_preserves:\n  \"wf_disc_sel (disc, sel) C \\<Longrightarrow>\n   normalized_nnf_match m \\<Longrightarrow>\n   P m \\<Longrightarrow>\n   P MatchAny \\<Longrightarrow>\n   primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow> \\<comment> \\<open>turn eqality around to simplify proof\\<close>\n   (\\<And>m1 m2. P (MatchAnd m1 m2) \\<longleftrightarrow> P m1 \\<and> P m2) \\<Longrightarrow>\n   (\\<And>ls1 ls2. P (alist_and' (ls1 @ ls2)) \\<longleftrightarrow> P (alist_and' ls1) \\<and> P (alist_and' ls2)) \\<Longrightarrow>\n   P (alist_and' (NegPos_map C as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m; P m;\n     P MatchAny; primitive_extractor (disc, sel) m = (as, ms);\n     \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n     \\<And>ls1 ls2.\n        P (alist_and' (ls1 @ ls2)) =\n        (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n    \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "proof(induction \"(disc, sel)\" m  arbitrary: as ms rule: primitive_extractor.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>a as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match (Match a);\n        P (Match a); P MatchAny;\n        primitive_extractor (disc, sel) (Match a) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>a as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (Match a)); P (MatchNot (Match a));\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (Match a)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    normalized_nnf_match ms1; P ms1; P MatchAny;\n                    primitive_extractor (disc, sel) ms1 = (as, ms);\n                    \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n                    \\<And>ls1 ls2.\n                       P (alist_and' (ls1 @ ls2)) =\n                       (P (alist_and' ls1) \\<and>\n                        P (alist_and' ls2))\\<rbrakk>\n                   \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            wf_disc_sel (disc, sel) C; normalized_nnf_match ms2; P ms2;\n            P MatchAny; primitive_extractor (disc, sel) ms2 = (as, ms);\n            \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n            \\<And>ls1 ls2.\n               P (alist_and' (ls1 @ ls2)) =\n               (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; normalized_nnf_match (MatchAnd ms1 ms2);\n        P (MatchAnd ms1 ms2); P MatchAny;\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 5. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 6. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 7. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "case 2"], ["proof (state)\nthis:\n  wf_disc_sel (disc, sel) C\n  normalized_nnf_match (Match a_)\n  P (Match a_)\n  P MatchAny\n  primitive_extractor (disc, sel) (Match a_) = (as, ms)\n  P (MatchAnd ?m1.0 ?m2.0) = (P ?m1.0 \\<and> P ?m2.0)\n  P (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (P (alist_and' ?ls1.0) \\<and> P (alist_and' ?ls2.0))\n\ngoal (7 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>a as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match (Match a);\n        P (Match a); P MatchAny;\n        primitive_extractor (disc, sel) (Match a) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>a as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (Match a)); P (MatchNot (Match a));\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (Match a)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    normalized_nnf_match ms1; P ms1; P MatchAny;\n                    primitive_extractor (disc, sel) ms1 = (as, ms);\n                    \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n                    \\<And>ls1 ls2.\n                       P (alist_and' (ls1 @ ls2)) =\n                       (P (alist_and' ls1) \\<and>\n                        P (alist_and' ls2))\\<rbrakk>\n                   \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            wf_disc_sel (disc, sel) C; normalized_nnf_match ms2; P ms2;\n            P MatchAny; primitive_extractor (disc, sel) ms2 = (as, ms);\n            \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n            \\<And>ls1 ls2.\n               P (alist_and' (ls1 @ ls2)) =\n               (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; normalized_nnf_match (MatchAnd ms1 ms2);\n        P (MatchAnd ms1 ms2); P MatchAny;\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 5. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 6. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 7. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "thus ?case"], ["proof (prove)\nusing this:\n  wf_disc_sel (disc, sel) C\n  normalized_nnf_match (Match a_)\n  P (Match a_)\n  P MatchAny\n  primitive_extractor (disc, sel) (Match a_) = (as, ms)\n  P (MatchAnd ?m1.0 ?m2.0) = (P ?m1.0 \\<and> P ?m2.0)\n  P (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (P (alist_and' ?ls1.0) \\<and> P (alist_and' ?ls2.0))\n\ngoal (1 subgoal):\n 1. P (alist_and' (NegPos_map C as))", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n     \\<And>ls1 ls2.\n        P (alist_and' (ls1 @ ls2)) =\n        (P (alist_and' ls1) \\<and> P (alist_and' ls2));\n     wf_disc_sel (disc, sel) C; P (Match a_); P MatchAny; disc a_;\n     [Pos (sel a_)] = as \\<and> MatchAny = ms\\<rbrakk>\n    \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n     \\<And>ls1 ls2.\n        P (alist_and' (ls1 @ ls2)) =\n        (P (alist_and' ls1) \\<and> P (alist_and' ls2));\n     wf_disc_sel (disc, sel) C; P (Match a_); P MatchAny; disc a_;\n     as = [Pos (sel a_)]; ms = MatchAny\\<rbrakk>\n    \\<Longrightarrow> P (alist_and' (NegPos_map C [Pos (sel a_)]))", "by(simp add: wf_disc_sel.simps)"], ["proof (state)\nthis:\n  P (alist_and' (NegPos_map C as))\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>a as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (Match a)); P (MatchNot (Match a));\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (Match a)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    normalized_nnf_match ms1; P ms1; P MatchAny;\n                    primitive_extractor (disc, sel) ms1 = (as, ms);\n                    \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n                    \\<And>ls1 ls2.\n                       P (alist_and' (ls1 @ ls2)) =\n                       (P (alist_and' ls1) \\<and>\n                        P (alist_and' ls2))\\<rbrakk>\n                   \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            wf_disc_sel (disc, sel) C; normalized_nnf_match ms2; P ms2;\n            P MatchAny; primitive_extractor (disc, sel) ms2 = (as, ms);\n            \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n            \\<And>ls1 ls2.\n               P (alist_and' (ls1 @ ls2)) =\n               (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; normalized_nnf_match (MatchAnd ms1 ms2);\n        P (MatchAnd ms1 ms2); P MatchAny;\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 5. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 6. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>a as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (Match a)); P (MatchNot (Match a));\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (Match a)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    normalized_nnf_match ms1; P ms1; P MatchAny;\n                    primitive_extractor (disc, sel) ms1 = (as, ms);\n                    \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n                    \\<And>ls1 ls2.\n                       P (alist_and' (ls1 @ ls2)) =\n                       (P (alist_and' ls1) \\<and>\n                        P (alist_and' ls2))\\<rbrakk>\n                   \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            wf_disc_sel (disc, sel) C; normalized_nnf_match ms2; P ms2;\n            P MatchAny; primitive_extractor (disc, sel) ms2 = (as, ms);\n            \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n            \\<And>ls1 ls2.\n               P (alist_and' (ls1 @ ls2)) =\n               (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; normalized_nnf_match (MatchAnd ms1 ms2);\n        P (MatchAnd ms1 ms2); P MatchAny;\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 5. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 6. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "case 3"], ["proof (state)\nthis:\n  wf_disc_sel (disc, sel) C\n  normalized_nnf_match (MatchNot (Match a_))\n  P (MatchNot (Match a_))\n  P MatchAny\n  primitive_extractor (disc, sel) (MatchNot (Match a_)) = (as, ms)\n  P (MatchAnd ?m1.0 ?m2.0) = (P ?m1.0 \\<and> P ?m2.0)\n  P (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (P (alist_and' ?ls1.0) \\<and> P (alist_and' ?ls2.0))\n\ngoal (6 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>a as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (Match a)); P (MatchNot (Match a));\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (Match a)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    normalized_nnf_match ms1; P ms1; P MatchAny;\n                    primitive_extractor (disc, sel) ms1 = (as, ms);\n                    \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n                    \\<And>ls1 ls2.\n                       P (alist_and' (ls1 @ ls2)) =\n                       (P (alist_and' ls1) \\<and>\n                        P (alist_and' ls2))\\<rbrakk>\n                   \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            wf_disc_sel (disc, sel) C; normalized_nnf_match ms2; P ms2;\n            P MatchAny; primitive_extractor (disc, sel) ms2 = (as, ms);\n            \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n            \\<And>ls1 ls2.\n               P (alist_and' (ls1 @ ls2)) =\n               (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; normalized_nnf_match (MatchAnd ms1 ms2);\n        P (MatchAnd ms1 ms2); P MatchAny;\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 5. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 6. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "thus ?case"], ["proof (prove)\nusing this:\n  wf_disc_sel (disc, sel) C\n  normalized_nnf_match (MatchNot (Match a_))\n  P (MatchNot (Match a_))\n  P MatchAny\n  primitive_extractor (disc, sel) (MatchNot (Match a_)) = (as, ms)\n  P (MatchAnd ?m1.0 ?m2.0) = (P ?m1.0 \\<and> P ?m2.0)\n  P (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (P (alist_and' ?ls1.0) \\<and> P (alist_and' ?ls2.0))\n\ngoal (1 subgoal):\n 1. P (alist_and' (NegPos_map C as))", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n     \\<And>ls1 ls2.\n        P (alist_and' (ls1 @ ls2)) =\n        (P (alist_and' ls1) \\<and> P (alist_and' ls2));\n     wf_disc_sel (disc, sel) C; P (MatchNot (Match a_)); P MatchAny;\n     disc a_; [Neg (sel a_)] = as \\<and> MatchAny = ms\\<rbrakk>\n    \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n     \\<And>ls1 ls2.\n        P (alist_and' (ls1 @ ls2)) =\n        (P (alist_and' ls1) \\<and> P (alist_and' ls2));\n     wf_disc_sel (disc, sel) C; P (MatchNot (Match a_)); P MatchAny;\n     disc a_; as = [Neg (sel a_)]; ms = MatchAny\\<rbrakk>\n    \\<Longrightarrow> P (alist_and' (NegPos_map C [Neg (sel a_)]))", "by(simp add: wf_disc_sel.simps)"], ["proof (state)\nthis:\n  P (alist_and' (NegPos_map C as))\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    normalized_nnf_match ms1; P ms1; P MatchAny;\n                    primitive_extractor (disc, sel) ms1 = (as, ms);\n                    \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n                    \\<And>ls1 ls2.\n                       P (alist_and' (ls1 @ ls2)) =\n                       (P (alist_and' ls1) \\<and>\n                        P (alist_and' ls2))\\<rbrakk>\n                   \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            wf_disc_sel (disc, sel) C; normalized_nnf_match ms2; P ms2;\n            P MatchAny; primitive_extractor (disc, sel) ms2 = (as, ms);\n            \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n            \\<And>ls1 ls2.\n               P (alist_and' (ls1 @ ls2)) =\n               (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; normalized_nnf_match (MatchAnd ms1 ms2);\n        P (MatchAnd ms1 ms2); P MatchAny;\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 5. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    normalized_nnf_match ms1; P ms1; P MatchAny;\n                    primitive_extractor (disc, sel) ms1 = (as, ms);\n                    \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n                    \\<And>ls1 ls2.\n                       P (alist_and' (ls1 @ ls2)) =\n                       (P (alist_and' ls1) \\<and>\n                        P (alist_and' ls2))\\<rbrakk>\n                   \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            wf_disc_sel (disc, sel) C; normalized_nnf_match ms2; P ms2;\n            P MatchAny; primitive_extractor (disc, sel) ms2 = (as, ms);\n            \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n            \\<And>ls1 ls2.\n               P (alist_and' (ls1 @ ls2)) =\n               (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; normalized_nnf_match (MatchAnd ms1 ms2);\n        P (MatchAnd ms1 ms2); P MatchAny;\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 5. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "case (4 m1 m2 as ms)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m1; P m1;\n   P MatchAny; primitive_extractor (disc, sel) m1 = (?as, ?ms);\n   \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n   \\<And>ls1 ls2.\n      P (alist_and' (ls1 @ ls2)) =\n      (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n  \\<Longrightarrow> P (alist_and' (NegPos_map C ?as))\n  \\<lbrakk>?x = primitive_extractor (disc, sel) m1; (?xa, ?y) = ?x;\n   wf_disc_sel (disc, sel) C; normalized_nnf_match m2; P m2; P MatchAny;\n   primitive_extractor (disc, sel) m2 = (?as, ?ms);\n   \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n   \\<And>ls1 ls2.\n      P (alist_and' (ls1 @ ls2)) =\n      (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n  \\<Longrightarrow> P (alist_and' (NegPos_map C ?as))\n  wf_disc_sel (disc, sel) C\n  normalized_nnf_match (MatchAnd m1 m2)\n  P (MatchAnd m1 m2)\n  P MatchAny\n  primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms)\n  P (MatchAnd ?m1.0 ?m2.0) = (P ?m1.0 \\<and> P ?m2.0)\n  P (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (P (alist_and' ?ls1.0) \\<and> P (alist_and' ?ls2.0))\n\ngoal (5 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>ms1 ms2 as ms.\n       \\<lbrakk>\\<And>as ms.\n                   \\<lbrakk>wf_disc_sel (disc, sel) C;\n                    normalized_nnf_match ms1; P ms1; P MatchAny;\n                    primitive_extractor (disc, sel) ms1 = (as, ms);\n                    \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n                    \\<And>ls1 ls2.\n                       P (alist_and' (ls1 @ ls2)) =\n                       (P (alist_and' ls1) \\<and>\n                        P (alist_and' ls2))\\<rbrakk>\n                   \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        \\<And>x xa y as ms.\n           \\<lbrakk>x = primitive_extractor (disc, sel) ms1; (xa, y) = x;\n            wf_disc_sel (disc, sel) C; normalized_nnf_match ms2; P ms2;\n            P MatchAny; primitive_extractor (disc, sel) ms2 = (as, ms);\n            \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n            \\<And>ls1 ls2.\n               P (alist_and' (ls1 @ ls2)) =\n               (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; normalized_nnf_match (MatchAnd ms1 ms2);\n        P (MatchAnd ms1 ms2); P MatchAny;\n        primitive_extractor (disc, sel) (MatchAnd ms1 ms2) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 5. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "from 4"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m1; P m1;\n   P MatchAny; primitive_extractor (disc, sel) m1 = (?as, ?ms);\n   \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n   \\<And>ls1 ls2.\n      P (alist_and' (ls1 @ ls2)) =\n      (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n  \\<Longrightarrow> P (alist_and' (NegPos_map C ?as))\n  \\<lbrakk>?x = primitive_extractor (disc, sel) m1; (?xa, ?y) = ?x;\n   wf_disc_sel (disc, sel) C; normalized_nnf_match m2; P m2; P MatchAny;\n   primitive_extractor (disc, sel) m2 = (?as, ?ms);\n   \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n   \\<And>ls1 ls2.\n      P (alist_and' (ls1 @ ls2)) =\n      (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n  \\<Longrightarrow> P (alist_and' (NegPos_map C ?as))\n  wf_disc_sel (disc, sel) C\n  normalized_nnf_match (MatchAnd m1 m2)\n  P (MatchAnd m1 m2)\n  P MatchAny\n  primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms)\n  P (MatchAnd ?m1.0 ?m2.0) = (P ?m1.0 \\<and> P ?m2.0)\n  P (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (P (alist_and' ?ls1.0) \\<and> P (alist_and' ?ls2.0))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m1; P m1;\n   P MatchAny; primitive_extractor (disc, sel) m1 = (?as, ?ms);\n   \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n   \\<And>ls1 ls2.\n      P (alist_and' (ls1 @ ls2)) =\n      (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n  \\<Longrightarrow> P (alist_and' (NegPos_map C ?as))\n  \\<lbrakk>?x = primitive_extractor (disc, sel) m1; (?xa, ?y) = ?x;\n   wf_disc_sel (disc, sel) C; normalized_nnf_match m2; P m2; P MatchAny;\n   primitive_extractor (disc, sel) m2 = (?as, ?ms);\n   \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n   \\<And>ls1 ls2.\n      P (alist_and' (ls1 @ ls2)) =\n      (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n  \\<Longrightarrow> P (alist_and' (NegPos_map C ?as))\n  wf_disc_sel (disc, sel) C\n  normalized_nnf_match (MatchAnd m1 m2)\n  P (MatchAnd m1 m2)\n  P MatchAny\n  primitive_extractor (disc, sel) (MatchAnd m1 m2) = (as, ms)\n  P (MatchAnd ?m1.0 ?m2.0) = (P ?m1.0 \\<and> P ?m2.0)\n  P (alist_and' (?ls1.0 @ ?ls2.0)) =\n  (P (alist_and' ?ls1.0) \\<and> P (alist_and' ?ls2.0))\n\ngoal (1 subgoal):\n 1. P (alist_and' (NegPos_map C as))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as ms.\n                primitive_extractor (disc, sel) m1 =\n                (as, ms) \\<Longrightarrow>\n                P (alist_and' (NegPos_map C as));\n     \\<And>x xa y as ms.\n        \\<lbrakk>x = primitive_extractor (disc, sel) m1;\n         (xa, y) = primitive_extractor (disc, sel) m1;\n         primitive_extractor (disc, sel) m2 = (as, ms)\\<rbrakk>\n        \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n     wf_disc_sel (disc, sel) C;\n     normalized_nnf_match m1 \\<and> normalized_nnf_match m2;\n     P m1 \\<and> P m2; P MatchAny;\n     (case primitive_extractor (disc, sel) m1 of\n      (a1', ms1') \\<Rightarrow>\n        case primitive_extractor (disc, sel) m2 of\n        (a2', ms2') \\<Rightarrow> (a1' @ a2', MatchAnd ms1' ms2')) =\n     (as, ms);\n     \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n     \\<And>ls1 ls2.\n        P (alist_and' (ls1 @ ls2)) =\n        (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n    \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "apply(simp split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2));\n        P (alist_and' (NegPos_map C x1));\n        \\<And>x xa as.\n           \\<lbrakk>x = (x1, x2); xa = x1; x1a = as\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; P MatchAny; normalized_nnf_match m1;\n        normalized_nnf_match m2; P m1; P m2;\n        primitive_extractor (disc, sel) m1 = (x1, x2);\n        primitive_extractor (disc, sel) m2 = (x1a, x2a);\n        x1 @ x1a = as \\<and> MatchAnd x2 x2a = ms\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2));\n        P (alist_and' (NegPos_map C x1));\n        \\<And>a b xa as.\n           \\<lbrakk>(a, b) = (x1, x2); xa = x1; x1a = as\\<rbrakk>\n           \\<Longrightarrow> P (alist_and' (NegPos_map C as));\n        wf_disc_sel (disc, sel) C; P MatchAny; normalized_nnf_match m1;\n        normalized_nnf_match m2; P m1; P m2;\n        primitive_extractor (disc, sel) m1 = (x1, x2);\n        primitive_extractor (disc, sel) m2 = (x1a, x2a); as = x1 @ x1a;\n        ms = MatchAnd x2 x2a\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C (x1 @ x1a)))", "apply(simp add: NegPos_map_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (alist_and' (NegPos_map C as))\n\ngoal (4 subgoals):\n 1. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match MatchAny;\n        P MatchAny; P MatchAny;\n        primitive_extractor (disc, sel) MatchAny = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 2. \\<And>va as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchNot va));\n        P (MatchNot (MatchNot va)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchNot va)) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 3. \\<And>va vb as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot (MatchAnd va vb));\n        P (MatchNot (MatchAnd va vb)); P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot (MatchAnd va vb)) =\n        (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))\n 4. \\<And>as ms.\n       \\<lbrakk>wf_disc_sel (disc, sel) C;\n        normalized_nnf_match (MatchNot MatchAny); P (MatchNot MatchAny);\n        P MatchAny;\n        primitive_extractor (disc, sel) (MatchNot MatchAny) = (as, ms);\n        \\<And>m1 m2. P (MatchAnd m1 m2) = (P m1 \\<and> P m2);\n        \\<And>ls1 ls2.\n           P (alist_and' (ls1 @ ls2)) =\n           (P (alist_and' ls1) \\<and> P (alist_and' ls2))\\<rbrakk>\n       \\<Longrightarrow> P (alist_and' (NegPos_map C as))", "qed(simp_all split: if_split_asm)"], ["", "lemma primitive_extractor_reassemble_not_has_disc:\n  \"wf_disc_sel (disc, sel) C \\<Longrightarrow>\n   normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc disc' m \\<Longrightarrow>\n   primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n     \\<not> has_disc disc' (alist_and' (NegPos_map C as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc disc' m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc' (alist_and' (NegPos_map C as))", "apply(rule primitive_extractor_reassemble_preserves)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc disc' m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> wf_disc_sel (?disc, ?sel) C\n 2. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc disc' m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ?m\n 3. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc disc' m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc' ?m\n 4. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc disc' m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc' MatchAny\n 5. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc disc' m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> primitive_extractor (?disc, ?sel) ?m = (as, ?ms)\n 6. \\<And>m1 m2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n        \\<not> has_disc disc' m;\n        primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc' (MatchAnd m1 m2)) =\n                         (\\<not> has_disc disc' m1 \\<and>\n                          \\<not> has_disc disc' m2)\n 7. \\<And>ls1 ls2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n        \\<not> has_disc disc' m;\n        primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc disc' (alist_and' (ls1 @ ls2))) =\n                         (\\<not> has_disc disc' (alist_and' ls1) \\<and>\n                          \\<not> has_disc disc' (alist_and' ls2))", "by(simp_all add: NegPos_map_append has_disc_alist_and'_append)"], ["", "lemma primitive_extractor_reassemble_not_has_disc_negated:\n  \"wf_disc_sel (disc, sel) C \\<Longrightarrow>\n   normalized_nnf_match m \\<Longrightarrow> \\<not> has_disc_negated disc' neg m \\<Longrightarrow>\n   primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow> \n     \\<not> has_disc_negated disc' neg (alist_and' (NegPos_map C as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc_negated disc' neg m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc' neg\n                              (alist_and' (NegPos_map C as))", "apply(rule primitive_extractor_reassemble_preserves)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc_negated disc' neg m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> wf_disc_sel (?disc, ?sel) C\n 2. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc_negated disc' neg m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ?m\n 3. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc_negated disc' neg m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc' neg ?m\n 4. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc_negated disc' neg m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc' neg MatchAny\n 5. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     \\<not> has_disc_negated disc' neg m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> primitive_extractor (?disc, ?sel) ?m = (as, ?ms)\n 6. \\<And>m1 m2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n        \\<not> has_disc_negated disc' neg m;\n        primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc' neg\n                                  (MatchAnd m1 m2)) =\n                         (\\<not> has_disc_negated disc' neg m1 \\<and>\n                          \\<not> has_disc_negated disc' neg m2)\n 7. \\<And>ls1 ls2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n        \\<not> has_disc_negated disc' neg m;\n        primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc_negated disc' neg\n                                  (alist_and' (ls1 @ ls2))) =\n                         (\\<not> has_disc_negated disc' neg\n                                  (alist_and' ls1) \\<and>\n                          \\<not> has_disc_negated disc' neg\n                                  (alist_and' ls2))", "by(simp_all add: NegPos_map_append has_disc_negated_alist_and'_append)"], ["", "lemma primitive_extractor_reassemble_normalized_n_primitive:\n  \"wf_disc_sel (disc, sel) C \\<Longrightarrow>\n   normalized_nnf_match m \\<Longrightarrow> normalized_n_primitive (disc1, sel1) f m \\<Longrightarrow>\n   primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n     normalized_n_primitive (disc1, sel1) f (alist_and' (NegPos_map C as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     normalized_n_primitive (disc1, sel1) f m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc1, sel1) f\n                       (alist_and' (NegPos_map C as))", "apply(rule primitive_extractor_reassemble_preserves)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     normalized_n_primitive (disc1, sel1) f m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> wf_disc_sel (?disc, ?sel) C\n 2. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     normalized_n_primitive (disc1, sel1) f m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match ?m\n 3. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     normalized_n_primitive (disc1, sel1) f m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc1, sel1) f ?m\n 4. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     normalized_n_primitive (disc1, sel1) f m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc1, sel1) f MatchAny\n 5. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     normalized_n_primitive (disc1, sel1) f m;\n     primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n    \\<Longrightarrow> primitive_extractor (?disc, ?sel) ?m = (as, ?ms)\n 6. \\<And>m1 m2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n        normalized_n_primitive (disc1, sel1) f m;\n        primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc1, sel1) f\n                          (MatchAnd m1 m2) =\n                         (normalized_n_primitive (disc1, sel1) f m1 \\<and>\n                          normalized_n_primitive (disc1, sel1) f m2)\n 7. \\<And>ls1 ls2.\n       \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n        normalized_n_primitive (disc1, sel1) f m;\n        primitive_extractor (disc, sel) m = (as, ms)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc1, sel1) f\n                          (alist_and' (ls1 @ ls2)) =\n                         (normalized_n_primitive (disc1, sel1) f\n                           (alist_and' ls1) \\<and>\n                          normalized_n_primitive (disc1, sel1) f\n                           (alist_and' ls2))", "by(simp_all add: NegPos_map_append normalized_n_primitive_alist_and'_append)"], ["", "lemma primitive_extractor_matchesE: \"wf_disc_sel (disc,sel) C \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> primitive_extractor (disc, sel) m = (as, ms)\n  \\<Longrightarrow>\n  (normalized_nnf_match ms \\<Longrightarrow> \\<not> has_disc disc ms \\<Longrightarrow> (\\<forall>disc2. \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms) \\<Longrightarrow> matches_other \\<longleftrightarrow>  matches \\<gamma> ms a p)\n  \\<Longrightarrow>\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and> matches_other \\<longleftrightarrow>  matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     primitive_extractor (disc, sel) m = (as, ms);\n     \\<lbrakk>normalized_nnf_match ms; \\<not> has_disc disc ms;\n      \\<forall>disc2.\n         \\<not> has_disc disc2 m \\<longrightarrow>\n         \\<not> has_disc disc2 ms\\<rbrakk>\n     \\<Longrightarrow> matches_other = matches \\<gamma> ms a p\\<rbrakk>\n    \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                        p \\<and>\n                       matches_other) =\n                      matches \\<gamma> m a p", "using primitive_extractor_correct(1,2,3,4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> (matches ?\\<gamma> (alist_and (NegPos_map ?C ?as)) ?a\n                      ?p \\<and>\n                     matches ?\\<gamma> ?ms ?a ?p) =\n                    matches ?\\<gamma> ?m ?a ?p\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?ms\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc ?disc ?ms\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc disc2 ?m \\<longrightarrow>\n                       \\<not> has_disc disc2 ?ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     primitive_extractor (disc, sel) m = (as, ms);\n     \\<lbrakk>normalized_nnf_match ms; \\<not> has_disc disc ms;\n      \\<forall>disc2.\n         \\<not> has_disc disc2 m \\<longrightarrow>\n         \\<not> has_disc disc2 ms\\<rbrakk>\n     \\<Longrightarrow> matches_other = matches \\<gamma> ms a p\\<rbrakk>\n    \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map C as)) a\n                        p \\<and>\n                       matches_other) =\n                      matches \\<gamma> m a p", "by metis"], ["", "lemma primitive_extractor_matches_lastE: \"wf_disc_sel (disc,sel) C \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> primitive_extractor (disc, sel) m = (as, ms)\n  \\<Longrightarrow>\n  (normalized_nnf_match ms \\<Longrightarrow> \\<not> has_disc disc ms \\<Longrightarrow> (\\<forall>disc2. \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms) \\<Longrightarrow> matches \\<gamma> ms a p)\n  \\<Longrightarrow>\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p  \\<longleftrightarrow>  matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     primitive_extractor (disc, sel) m = (as, ms);\n     \\<lbrakk>normalized_nnf_match ms; \\<not> has_disc disc ms;\n      \\<forall>disc2.\n         \\<not> has_disc disc2 m \\<longrightarrow>\n         \\<not> has_disc disc2 ms\\<rbrakk>\n     \\<Longrightarrow> matches \\<gamma> ms a p\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> (alist_and (NegPos_map C as)) a p =\n                      matches \\<gamma> m a p", "using primitive_extractor_correct(1,2,3,4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> (matches ?\\<gamma> (alist_and (NegPos_map ?C ?as)) ?a\n                      ?p \\<and>\n                     matches ?\\<gamma> ?ms ?a ?p) =\n                    matches ?\\<gamma> ?m ?a ?p\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?ms\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc ?disc ?ms\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>disc2.\n                       \\<not> has_disc disc2 ?m \\<longrightarrow>\n                       \\<not> has_disc disc2 ?ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel (disc, sel) C; normalized_nnf_match m;\n     primitive_extractor (disc, sel) m = (as, ms);\n     \\<lbrakk>normalized_nnf_match ms; \\<not> has_disc disc ms;\n      \\<forall>disc2.\n         \\<not> has_disc disc2 m \\<longrightarrow>\n         \\<not> has_disc disc2 ms\\<rbrakk>\n     \\<Longrightarrow> matches \\<gamma> ms a p\\<rbrakk>\n    \\<Longrightarrow> matches \\<gamma> (alist_and (NegPos_map C as)) a p =\n                      matches \\<gamma> m a p", "by metis"], ["", "text\\<open>The lemmas @{thm primitive_extractor_matchesE} and @{thm primitive_extractor_matches_lastE} can be used as\n  erule to solve goals about consecutive application of @{const primitive_extractor}.\n  They should be used as \\<open>primitive_extractor_matchesE[OF wf_disc_sel_for_first_extracted_thing]\\<close>.\n\\<close>"], ["", "subsection\\<open>Normalizing and Optimizing Primitives\\<close>"], ["", "text\\<open>\n    Normalize primitives by a function \\<open>f\\<close> with type @{typ \"'b negation_type list \\<Rightarrow> 'b list\"}.\n    @{typ \"'b\"} is a primitive type, e.g. ipt-ipv4range.\n    \\<open>f\\<close> takes a conjunction list of negated primitives and must compress them such that:\n    \\begin{enumerate}\n      \\item no negation occurs in the output\n      \\item the output is a disjunction of the primitives, i.e. multiple primitives in one rule are compressed to at most one primitive (leading to multiple rules)\n    \\end{enumerate}\n    Example with IP addresses:\n    \\begin{verbatim}\n      f [10.8.0.0/16, 10.0.0.0/8] = [10.0.0.0/8]  f compresses to one range\n      f [10.0.0.0, 192.168.0.01] = []    range is empty, rule can be dropped\n      f [Neg 41] = [{0..40}, {42..ipv4max}]   one rule is translated into multiple rules to translate negation\n      f [Neg 41, {20..50}, {30..50}] = [{30..40}, {42..50}]   input: conjunction list, output disjunction list!\n    \\end{verbatim}\n\\<close>"], ["", "definition normalize_primitive_extract :: \"(('a \\<Rightarrow> bool) \\<times> ('a \\<Rightarrow> 'b)) \\<Rightarrow>\n                               ('b \\<Rightarrow> 'a) \\<Rightarrow>\n                               ('b negation_type list \\<Rightarrow> 'b list) \\<Rightarrow>\n                               'a match_expr \\<Rightarrow> \n                               'a match_expr list\" where \n    \"normalize_primitive_extract (disc_sel) C f m \\<equiv> (case primitive_extractor (disc_sel) m \n                of (spts, rst) \\<Rightarrow> map (\\<lambda>spt. (MatchAnd (Match (C spt))) rst) (f spts))\""], ["", "(*if f spts is empty, we get back an empty list. *)"], ["", "text\\<open>\n    If \\<open>f\\<close> has the properties described above, then @{const normalize_primitive_extract} is a valid transformation of a match expression\\<close>"], ["", "lemma normalize_primitive_extract: assumes \"normalized_nnf_match m\" and \"wf_disc_sel disc_sel C\" and\n        \"\\<forall>ml. (match_list \\<gamma> (map (Match \\<circ> C) (f ml)) a p \\<longleftrightarrow> matches \\<gamma> (alist_and (NegPos_map C ml)) a p)\"\n        shows \"match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p \\<longleftrightarrow> matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "obtain as ms where pe: \"primitive_extractor disc_sel m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor disc_sel m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor disc_sel m = (as, ms)\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "from pe primitive_extractor_correct(1)[OF assms(1), where \\<gamma>=\\<gamma> and  a=a and p=p] assms(2)"], ["proof (chain)\npicking this:\n  primitive_extractor disc_sel m = (as, ms)\n  \\<lbrakk>wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map ?C ?as)) a\n                      p \\<and>\n                     matches \\<gamma> ?ms a p) =\n                    matches \\<gamma> m a p\n  wf_disc_sel disc_sel C", "have \n        \"matches \\<gamma> m a p \\<longleftrightarrow> matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and> matches \\<gamma> ms a p\""], ["proof (prove)\nusing this:\n  primitive_extractor disc_sel m = (as, ms)\n  \\<lbrakk>wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> (matches \\<gamma> (alist_and (NegPos_map ?C ?as)) a\n                      p \\<and>\n                     matches \\<gamma> ?ms a p) =\n                    matches \\<gamma> m a p\n  wf_disc_sel disc_sel C\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m a p =\n    (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n     matches \\<gamma> ms a p)", "by(cases disc_sel, blast)"], ["proof (state)\nthis:\n  matches \\<gamma> m a p =\n  (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n   matches \\<gamma> ms a p)\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "also"], ["proof (state)\nthis:\n  matches \\<gamma> m a p =\n  (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n   matches \\<gamma> ms a p)\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "have \"\\<dots> \\<longleftrightarrow> match_list \\<gamma> (map (Match \\<circ> C) (f as)) a p \\<and> matches \\<gamma> ms a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n     matches \\<gamma> ms a p) =\n    (match_list \\<gamma> (map (Match \\<circ> C) (f as)) a p \\<and>\n     matches \\<gamma> ms a p)", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<forall>ml.\n     match_list \\<gamma> (map (Match \\<circ> C) (f ml)) a p =\n     matches \\<gamma> (alist_and (NegPos_map C ml)) a p\n\ngoal (1 subgoal):\n 1. (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n     matches \\<gamma> ms a p) =\n    (match_list \\<gamma> (map (Match \\<circ> C) (f as)) a p \\<and>\n     matches \\<gamma> ms a p)", "by simp"], ["proof (state)\nthis:\n  (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n   matches \\<gamma> ms a p) =\n  (match_list \\<gamma> (map (Match \\<circ> C) (f as)) a p \\<and>\n   matches \\<gamma> ms a p)\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "also"], ["proof (state)\nthis:\n  (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n   matches \\<gamma> ms a p) =\n  (match_list \\<gamma> (map (Match \\<circ> C) (f as)) a p \\<and>\n   matches \\<gamma> ms a p)\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "have \"\\<dots> \\<longleftrightarrow> match_list \\<gamma> (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (match_list \\<gamma> (map (Match \\<circ> C) (f as)) a p \\<and>\n     matches \\<gamma> ms a p) =\n    match_list \\<gamma>\n     (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as)) a p", "by(simp add: match_list_matches bunch_of_lemmata_about_matches)"], ["proof (state)\nthis:\n  (match_list \\<gamma> (map (Match \\<circ> C) (f as)) a p \\<and>\n   matches \\<gamma> ms a p) =\n  match_list \\<gamma>\n   (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as)) a p\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "also"], ["proof (state)\nthis:\n  (match_list \\<gamma> (map (Match \\<circ> C) (f as)) a p \\<and>\n   matches \\<gamma> ms a p) =\n  match_list \\<gamma>\n   (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as)) a p\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "have \"... \\<longleftrightarrow> match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_list \\<gamma>\n     (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as)) a p =\n    match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p", "by(simp add: normalize_primitive_extract_def pe)"], ["proof (state)\nthis:\n  match_list \\<gamma>\n   (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as)) a p =\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "finally"], ["proof (chain)\npicking this:\n  matches \\<gamma> m a p =\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p", "show ?thesis"], ["proof (prove)\nusing this:\n  matches \\<gamma> m a p =\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "by simp"], ["proof (state)\nthis:\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  matches \\<gamma> m a p\n\ngoal:\nNo subgoals!", "qed"], ["", "thm match_list_semantics[of \\<gamma> \"(map (Match \\<circ> C) (f ml))\" a p \"[(alist_and (NegPos_map C ml))]\"]"], ["", "corollary normalize_primitive_extract_semantics:  assumes \"normalized_nnf_match m\" and \"wf_disc_sel disc_sel C\" and\n        \"\\<forall>ml. (match_list \\<gamma> (map (Match \\<circ> C) (f ml)) a p \\<longleftrightarrow> matches \\<gamma> (alist_and (NegPos_map C ml)) a p)\"\n        shows \"approximating_bigstep_fun \\<gamma> p (map (\\<lambda>m. Rule m a) (normalize_primitive_extract disc_sel C f m)) s = \n              approximating_bigstep_fun \\<gamma> p [Rule m a] s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. approximating_bigstep_fun \\<gamma> p\n     (map (\\<lambda>m. Rule m a)\n       (normalize_primitive_extract disc_sel C f m))\n     s =\n    approximating_bigstep_fun \\<gamma> p [Rule m a] s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. approximating_bigstep_fun \\<gamma> p\n     (map (\\<lambda>m. Rule m a)\n       (normalize_primitive_extract disc_sel C f m))\n     s =\n    approximating_bigstep_fun \\<gamma> p [Rule m a] s", "from normalize_primitive_extract[OF assms(1) assms(2) assms(3)]"], ["proof (chain)\npicking this:\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  matches \\<gamma> m a p", "have\n      \"match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p = matches \\<gamma> m a p\""], ["proof (prove)\nusing this:\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n    matches \\<gamma> m a p", "."], ["proof (state)\nthis:\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. approximating_bigstep_fun \\<gamma> p\n     (map (\\<lambda>m. Rule m a)\n       (normalize_primitive_extract disc_sel C f m))\n     s =\n    approximating_bigstep_fun \\<gamma> p [Rule m a] s", "also"], ["proof (state)\nthis:\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. approximating_bigstep_fun \\<gamma> p\n     (map (\\<lambda>m. Rule m a)\n       (normalize_primitive_extract disc_sel C f m))\n     s =\n    approximating_bigstep_fun \\<gamma> p [Rule m a] s", "have \"\\<dots> \\<longleftrightarrow> match_list \\<gamma> [m] a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m a p = match_list \\<gamma> [m] a p", "by simp"], ["proof (state)\nthis:\n  matches \\<gamma> m a p = match_list \\<gamma> [m] a p\n\ngoal (1 subgoal):\n 1. approximating_bigstep_fun \\<gamma> p\n     (map (\\<lambda>m. Rule m a)\n       (normalize_primitive_extract disc_sel C f m))\n     s =\n    approximating_bigstep_fun \\<gamma> p [Rule m a] s", "finally"], ["proof (chain)\npicking this:\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  match_list \\<gamma> [m] a p", "show ?thesis"], ["proof (prove)\nusing this:\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  match_list \\<gamma> [m] a p\n\ngoal (1 subgoal):\n 1. approximating_bigstep_fun \\<gamma> p\n     (map (\\<lambda>m. Rule m a)\n       (normalize_primitive_extract disc_sel C f m))\n     s =\n    approximating_bigstep_fun \\<gamma> p [Rule m a] s", "using match_list_semantics[of \\<gamma> \"(normalize_primitive_extract disc_sel C f m)\" a p \"[m]\"]"], ["proof (prove)\nusing this:\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  match_list \\<gamma> [m] a p\n  match_list \\<gamma> (normalize_primitive_extract disc_sel C f m) a p =\n  match_list \\<gamma> [m] a p \\<Longrightarrow>\n  approximating_bigstep_fun \\<gamma> p\n   (map (\\<lambda>m. Rule m a) (normalize_primitive_extract disc_sel C f m))\n   ?s =\n  approximating_bigstep_fun \\<gamma> p (map (\\<lambda>m. Rule m a) [m]) ?s\n\ngoal (1 subgoal):\n 1. approximating_bigstep_fun \\<gamma> p\n     (map (\\<lambda>m. Rule m a)\n       (normalize_primitive_extract disc_sel C f m))\n     s =\n    approximating_bigstep_fun \\<gamma> p [Rule m a] s", "by simp"], ["proof (state)\nthis:\n  approximating_bigstep_fun \\<gamma> p\n   (map (\\<lambda>m. Rule m a) (normalize_primitive_extract disc_sel C f m))\n   s =\n  approximating_bigstep_fun \\<gamma> p [Rule m a] s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_primitive_extract_preserves_nnf_normalized:\n  assumes \"normalized_nnf_match m\"\n      and \"wf_disc_sel (disc, sel) C\"\n    shows \"\\<forall>mn \\<in> set (normalize_primitive_extract (disc, sel) C f m). normalized_nnf_match mn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>mn\\<in>set (normalize_primitive_extract (disc, sel) C f m).\n       normalized_nnf_match mn", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_nnf_match mn", "fix mn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_nnf_match mn", "assume assm2: \"mn \\<in> set (normalize_primitive_extract (disc, sel) C f m)\""], ["proof (state)\nthis:\n  mn \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_nnf_match mn", "obtain as ms where as_ms: \"primitive_extractor (disc, sel) m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_nnf_match mn", "from primitive_extractor_correct(2)[OF assms(1) assms(2) as_ms]"], ["proof (chain)\npicking this:\n  normalized_nnf_match ms", "have \"normalized_nnf_match ms\""], ["proof (prove)\nusing this:\n  normalized_nnf_match ms\n\ngoal (1 subgoal):\n 1. normalized_nnf_match ms", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match ms\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_nnf_match mn", "from assm2 as_ms"], ["proof (chain)\npicking this:\n  mn \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n  primitive_extractor (disc, sel) m = (as, ms)", "have normalize_primitive_extract_unfolded: \"mn \\<in> ((\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as))\""], ["proof (prove)\nusing this:\n  mn \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)", "unfolding normalize_primitive_extract_def"], ["proof (prove)\nusing this:\n  mn \\<in> set (case primitive_extractor (disc, sel) m of\n                (spts, rst) \\<Rightarrow>\n                  map (\\<lambda>spt. MatchAnd (Match (C spt)) rst) (f spts))\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)", "by force"], ["proof (state)\nthis:\n  mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_nnf_match mn", "with \\<open>normalized_nnf_match ms\\<close>"], ["proof (chain)\npicking this:\n  normalized_nnf_match ms\n  mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)", "show \"normalized_nnf_match mn\""], ["proof (prove)\nusing this:\n  normalized_nnf_match ms\n  mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match mn", "by fastforce"], ["proof (state)\nthis:\n  normalized_nnf_match mn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_rules_primitive_extract_preserves_nnf_normalized:\n    \"\\<forall>r \\<in> set rs. normalized_nnf_match (get_match r) \\<Longrightarrow> wf_disc_sel disc_sel C \\<Longrightarrow>\n     \\<forall>r \\<in> set (normalize_rules (normalize_primitive_extract disc_sel C f) rs). normalized_nnf_match (get_match r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     wf_disc_sel disc_sel C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r\\<in>set\n(normalize_rules (normalize_primitive_extract disc_sel C f) rs).\n                         normalized_nnf_match (get_match r)", "apply(rule normalize_rules_preserves[where P=\"normalized_nnf_match\" and f=\"(normalize_primitive_extract disc_sel C f)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     wf_disc_sel disc_sel C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r\\<in>set rs.\n                         normalized_nnf_match (get_match r)\n 2. \\<lbrakk>\\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     wf_disc_sel disc_sel C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m.\n                         normalized_nnf_match m \\<longrightarrow>\n                         (\\<forall>m'\\<in>set\n     (normalize_primitive_extract disc_sel C f m).\n                             normalized_nnf_match m')", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     wf_disc_sel disc_sel C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m.\n                         normalized_nnf_match m \\<longrightarrow>\n                         (\\<forall>m'\\<in>set\n     (normalize_primitive_extract disc_sel C f m).\n                             normalized_nnf_match m')", "apply(cases disc_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n        wf_disc_sel disc_sel C; disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m.\n                            normalized_nnf_match m \\<longrightarrow>\n                            (\\<forall>m'\n\\<in>set (normalize_primitive_extract disc_sel C f m).\n                                normalized_nnf_match m')", "using normalize_primitive_extract_preserves_nnf_normalized"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C\\<rbrakk>\n  \\<Longrightarrow> \\<forall>mn\\<in>set (normalize_primitive_extract\n    (?disc, ?sel) ?C ?f ?m).\n                       normalized_nnf_match mn\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n        wf_disc_sel disc_sel C; disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m.\n                            normalized_nnf_match m \\<longrightarrow>\n                            (\\<forall>m'\n\\<in>set (normalize_primitive_extract disc_sel C f m).\n                                normalized_nnf_match m')", "by fast"], ["", "text\\<open>If something is normalized for disc2 and disc2 \\<open>\\<noteq>\\<close> disc1 and we do something on disc1, then disc2 remains normalized\\<close>"], ["", "lemma normalize_primitive_extract_preserves_unrelated_normalized_n_primitive:\n  assumes \"normalized_nnf_match m\"\n      and \"normalized_n_primitive (disc2, sel2) P m\"\n      and \"wf_disc_sel (disc1, sel1) C\"\n      and \"\\<forall>a. \\<not> disc2 (C a)\" \\<comment> \\<open>disc1 and disc2 match for different stuff. e.g. @{text Src_Ports} and @{text Dst_Ports}\\<close>\n    shows \"\\<forall>mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f m). normalized_n_primitive (disc2, sel2) P mn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>mn\\<in>set (normalize_primitive_extract (disc1, sel1) C f m).\n       normalized_n_primitive (disc2, sel2) P mn", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc2, sel2) P mn", "fix mn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc2, sel2) P mn", "assume assm2: \"mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f m)\""], ["proof (state)\nthis:\n  mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f m)\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc2, sel2) P mn", "obtain as ms where as_ms: \"primitive_extractor (disc1, sel1) m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc1, sel1) m = (as, ms)\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc2, sel2) P mn", "from as_ms primitive_extractor_correct[OF assms(1) assms(3)]"], ["proof (chain)\npicking this:\n  primitive_extractor (disc1, sel1) m = (as, ms)\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  (matches ?\\<gamma> (alist_and (NegPos_map C ?as)) ?a ?p \\<and>\n   matches ?\\<gamma> ?ms ?a ?p) =\n  matches ?\\<gamma> m ?a ?p\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  normalized_nnf_match ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  \\<not> has_disc disc1 ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) ?P m \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) ?P ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  (\\<not> has_disc disc1 m) = (?as = [] \\<and> ?ms = m)\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  (\\<not> has_disc_negated disc1 False m) = (getNeg ?as = [])\n  \\<lbrakk>primitive_extractor (disc1, sel1) m = (?as, ?ms);\n   has_disc disc1 m\\<rbrakk>\n  \\<Longrightarrow> ?as \\<noteq> []", "have \n                      \"\\<not> has_disc disc1 ms\"\n                  and \"normalized_n_primitive (disc2, sel2) P ms\""], ["proof (prove)\nusing this:\n  primitive_extractor (disc1, sel1) m = (as, ms)\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  (matches ?\\<gamma> (alist_and (NegPos_map C ?as)) ?a ?p \\<and>\n   matches ?\\<gamma> ?ms ?a ?p) =\n  matches ?\\<gamma> m ?a ?p\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  normalized_nnf_match ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  \\<not> has_disc disc1 ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) ?P m \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) ?P ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg ?ms\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  (\\<not> has_disc disc1 m) = (?as = [] \\<and> ?ms = m)\n  primitive_extractor (disc1, sel1) m = (?as, ?ms) \\<Longrightarrow>\n  (\\<not> has_disc_negated disc1 False m) = (getNeg ?as = [])\n  \\<lbrakk>primitive_extractor (disc1, sel1) m = (?as, ?ms);\n   has_disc disc1 m\\<rbrakk>\n  \\<Longrightarrow> ?as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc1 ms &&& normalized_n_primitive (disc2, sel2) P ms", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>primitive_extractor (disc1, sel1) m = (as, ms);\n     \\<And>as ms \\<gamma> a p.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n         matches \\<gamma> ms a p) =\n        matches \\<gamma> m a p;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        normalized_nnf_match ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<not> has_disc disc1 ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 ms;\n     \\<And>as ms P.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) P ms;\n     \\<And>as ms neg.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (\\<not> has_disc disc1 m) = (as = [] \\<and> ms = m);\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (\\<not> has_disc_negated disc1 False m) = (getNeg as = []);\n     \\<And>as ms.\n        \\<lbrakk>primitive_extractor (disc1, sel1) m = (as, ms);\n         has_disc disc1 m\\<rbrakk>\n        \\<Longrightarrow> as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc1 ms\n 2. \\<lbrakk>primitive_extractor (disc1, sel1) m = (as, ms);\n     \\<And>as ms \\<gamma> a p.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n         matches \\<gamma> ms a p) =\n        matches \\<gamma> m a p;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        normalized_nnf_match ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<not> has_disc disc1 ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 ms;\n     \\<And>as ms P.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) P ms;\n     \\<And>as ms neg.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (\\<not> has_disc disc1 m) = (as = [] \\<and> ms = m);\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (\\<not> has_disc_negated disc1 False m) = (getNeg as = []);\n     \\<And>as ms.\n        \\<lbrakk>primitive_extractor (disc1, sel1) m = (as, ms);\n         has_disc disc1 m\\<rbrakk>\n        \\<Longrightarrow> as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P ms", "apply(fast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primitive_extractor (disc1, sel1) m = (as, ms);\n     \\<And>as ms \\<gamma> a p.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n         matches \\<gamma> ms a p) =\n        matches \\<gamma> m a p;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        normalized_nnf_match ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<not> has_disc disc1 ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 ms;\n     \\<And>as ms P.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) P ms;\n     \\<And>as ms neg.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (\\<not> has_disc disc1 m) = (as = [] \\<and> ms = m);\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (\\<not> has_disc_negated disc1 False m) = (getNeg as = []);\n     \\<And>as ms.\n        \\<lbrakk>primitive_extractor (disc1, sel1) m = (as, ms);\n         has_disc disc1 m\\<rbrakk>\n        \\<Longrightarrow> as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P ms", "using assms(2)"], ["proof (prove)\nusing this:\n  normalized_n_primitive (disc2, sel2) P m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>primitive_extractor (disc1, sel1) m = (as, ms);\n     \\<And>as ms \\<gamma> a p.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n         matches \\<gamma> ms a p) =\n        matches \\<gamma> m a p;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        normalized_nnf_match ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<not> has_disc disc1 ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2.\n           \\<not> has_disc disc2 m \\<longrightarrow>\n           \\<not> has_disc disc2 ms;\n     \\<And>as ms P.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) P ms;\n     \\<And>as ms neg.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg ms;\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (\\<not> has_disc disc1 m) = (as = [] \\<and> ms = m);\n     \\<And>as ms.\n        primitive_extractor (disc1, sel1) m = (as, ms) \\<Longrightarrow>\n        (\\<not> has_disc_negated disc1 False m) = (getNeg as = []);\n     \\<And>as ms.\n        \\<lbrakk>primitive_extractor (disc1, sel1) m = (as, ms);\n         has_disc disc1 m\\<rbrakk>\n        \\<Longrightarrow> as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P ms", "by(fast)"], ["proof (state)\nthis:\n  \\<not> has_disc disc1 ms\n  normalized_n_primitive (disc2, sel2) P ms\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc2, sel2) P mn", "from assm2 as_ms"], ["proof (chain)\npicking this:\n  mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f m)\n  primitive_extractor (disc1, sel1) m = (as, ms)", "have normalize_primitive_extract_unfolded: \"mn \\<in> ((\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as))\""], ["proof (prove)\nusing this:\n  mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f m)\n  primitive_extractor (disc1, sel1) m = (as, ms)\n\ngoal (1 subgoal):\n 1. mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)", "unfolding normalize_primitive_extract_def"], ["proof (prove)\nusing this:\n  mn \\<in> set (case primitive_extractor (disc1, sel1) m of\n                (spts, rst) \\<Rightarrow>\n                  map (\\<lambda>spt. MatchAnd (Match (C spt)) rst) (f spts))\n  primitive_extractor (disc1, sel1) m = (as, ms)\n\ngoal (1 subgoal):\n 1. mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)", "by force"], ["proof (state)\nthis:\n  mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc2, sel2) P mn", "from normalize_primitive_extract_unfolded"], ["proof (chain)\npicking this:\n  mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)", "obtain Casms where Casms: \"mn = (MatchAnd (Match (C Casms)) ms)\""], ["proof (prove)\nusing this:\n  mn \\<in> (\\<lambda>spt. MatchAnd (Match (C spt)) ms) ` set (f as)\n\ngoal (1 subgoal):\n 1. (\\<And>Casms.\n        mn = MatchAnd (Match (C Casms)) ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mn = MatchAnd (Match (C Casms)) ms\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc2, sel2) P mn", "from \\<open>normalized_n_primitive (disc2, sel2) P ms\\<close> assms(4)"], ["proof (chain)\npicking this:\n  normalized_n_primitive (disc2, sel2) P ms\n  \\<forall>a. \\<not> disc2 (C a)", "have \"normalized_n_primitive (disc2, sel2) P (MatchAnd (Match (C Casms)) ms)\""], ["proof (prove)\nusing this:\n  normalized_n_primitive (disc2, sel2) P ms\n  \\<forall>a. \\<not> disc2 (C a)\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) P (MatchAnd (Match (C Casms)) ms)", "by(simp)"], ["proof (state)\nthis:\n  normalized_n_primitive (disc2, sel2) P (MatchAnd (Match (C Casms)) ms)\n\ngoal (1 subgoal):\n 1. \\<And>mn.\n       mn \\<in> set (normalize_primitive_extract (disc1, sel1) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc2, sel2) P mn", "with Casms"], ["proof (chain)\npicking this:\n  mn = MatchAnd (Match (C Casms)) ms\n  normalized_n_primitive (disc2, sel2) P (MatchAnd (Match (C Casms)) ms)", "show \"normalized_n_primitive (disc2, sel2) P mn\""], ["proof (prove)\nusing this:\n  mn = MatchAnd (Match (C Casms)) ms\n  normalized_n_primitive (disc2, sel2) P (MatchAnd (Match (C Casms)) ms)\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) P mn", "by blast"], ["proof (state)\nthis:\n  normalized_n_primitive (disc2, sel2) P mn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_primitive_extract_normalizes_n_primitive:\n  fixes disc::\"('a \\<Rightarrow> bool)\" and sel::\"('a \\<Rightarrow> 'b)\" and f::\"('b negation_type list \\<Rightarrow> 'b list)\"\n  assumes \"normalized_nnf_match m\"\n      and \"wf_disc_sel (disc, sel) C\"\n      and np: \"\\<forall>as. (\\<forall> a' \\<in> set (f as). P a')\" (*not quite, sel f   \\<forall>as \\<in> {x. disc (v x)}. *)\n    shows \"\\<forall>m' \\<in> set (normalize_primitive_extract (disc, sel) C f m). normalized_n_primitive (disc, sel) P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_primitive_extract (disc, sel) C f m).\n       normalized_n_primitive (disc, sel) P m'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) P m'", "fix m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) P m'", "assume a: \"m'\\<in>set (normalize_primitive_extract (disc, sel) C f m)\""], ["proof (state)\nthis:\n  m' \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) P m'", "have nnf: \"\\<forall>m' \\<in> set (normalize_primitive_extract (disc, sel) C f m). normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_primitive_extract (disc, sel) C f m).\n       normalized_nnf_match m'", "using normalize_primitive_extract_preserves_nnf_normalized assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C\\<rbrakk>\n  \\<Longrightarrow> \\<forall>mn\\<in>set (normalize_primitive_extract\n    (?disc, ?sel) ?C ?f ?m).\n                       normalized_nnf_match mn\n  normalized_nnf_match m\n  wf_disc_sel (disc, sel) C\n  \\<forall>as. \\<forall>a'\\<in>set (f as). P a'\n\ngoal (1 subgoal):\n 1. \\<forall>m'\\<in>set (normalize_primitive_extract (disc, sel) C f m).\n       normalized_nnf_match m'", "by blast"], ["proof (state)\nthis:\n  \\<forall>m'\\<in>set (normalize_primitive_extract (disc, sel) C f m).\n     normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) P m'", "with a"], ["proof (chain)\npicking this:\n  m' \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n  \\<forall>m'\\<in>set (normalize_primitive_extract (disc, sel) C f m).\n     normalized_nnf_match m'", "have normalized_m': \"normalized_nnf_match m'\""], ["proof (prove)\nusing this:\n  m' \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n  \\<forall>m'\\<in>set (normalize_primitive_extract (disc, sel) C f m).\n     normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m'", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) P m'", "from a"], ["proof (chain)\npicking this:\n  m' \\<in> set (normalize_primitive_extract (disc, sel) C f m)", "obtain as ms where as_ms: \"primitive_extractor (disc, sel) m = (as, ms)\""], ["proof (prove)\nusing this:\n  m' \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding normalize_primitive_extract_def"], ["proof (prove)\nusing this:\n  m' \\<in> set (case primitive_extractor (disc, sel) m of\n                (spts, rst) \\<Rightarrow>\n                  map (\\<lambda>spt. MatchAnd (Match (C spt)) rst) (f spts))\n\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) P m'", "with a"], ["proof (chain)\npicking this:\n  m' \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n  primitive_extractor (disc, sel) m = (as, ms)", "have prems: \"m' \\<in> set (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as))\""], ["proof (prove)\nusing this:\n  m' \\<in> set (normalize_primitive_extract (disc, sel) C f m)\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. m' \\<in> set (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as))", "unfolding normalize_primitive_extract_def"], ["proof (prove)\nusing this:\n  m' \\<in> set (case primitive_extractor (disc, sel) m of\n                (spts, rst) \\<Rightarrow>\n                  map (\\<lambda>spt. MatchAnd (Match (C spt)) rst) (f spts))\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. m' \\<in> set (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as))", "by simp"], ["proof (state)\nthis:\n  m' \\<in> set (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as))\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) P m'", "from primitive_extractor_correct(2)[OF assms(1) assms(2) as_ms]"], ["proof (chain)\npicking this:\n  normalized_nnf_match ms", "have \"normalized_nnf_match ms\""], ["proof (prove)\nusing this:\n  normalized_nnf_match ms\n\ngoal (1 subgoal):\n 1. normalized_nnf_match ms", "."], ["proof (state)\nthis:\n  normalized_nnf_match ms\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       m' \\<in> set (normalize_primitive_extract (disc, sel) C f\n                      m) \\<Longrightarrow>\n       normalized_n_primitive (disc, sel) P m'", "show \"normalized_n_primitive (disc, sel) P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc, sel) P m'", "proof(cases \"f as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f as = [] \\<Longrightarrow> normalized_n_primitive (disc, sel) P m'\n 2. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "case True"], ["proof (state)\nthis:\n  f as = []\n\ngoal (2 subgoals):\n 1. f as = [] \\<Longrightarrow> normalized_n_primitive (disc, sel) P m'\n 2. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "thus \"normalized_n_primitive (disc, sel) P m'\""], ["proof (prove)\nusing this:\n  f as = []\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc, sel) P m'", "using prems"], ["proof (prove)\nusing this:\n  f as = []\n  m' \\<in> set (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as))\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc, sel) P m'", "by simp"], ["proof (state)\nthis:\n  normalized_n_primitive (disc, sel) P m'\n\ngoal (1 subgoal):\n 1. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "case False"], ["proof (state)\nthis:\n  f as \\<noteq> []\n\ngoal (1 subgoal):\n 1. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "with prems"], ["proof (chain)\npicking this:\n  m' \\<in> set (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as))\n  f as \\<noteq> []", "obtain spt where \"m' = MatchAnd (Match (C spt)) ms\" and \"spt \\<in> set (f as)\""], ["proof (prove)\nusing this:\n  m' \\<in> set (map (\\<lambda>spt. MatchAnd (Match (C spt)) ms) (f as))\n  f as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>spt.\n        \\<lbrakk>m' = MatchAnd (Match (C spt)) ms;\n         spt \\<in> set (f as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m' = MatchAnd (Match (C spt)) ms\n  spt \\<in> set (f as)\n\ngoal (1 subgoal):\n 1. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "from primitive_extractor_correct(3)[OF assms(1) assms(2) as_ms]"], ["proof (chain)\npicking this:\n  \\<not> has_disc disc ms", "have \"\\<not> has_disc disc ms\""], ["proof (prove)\nusing this:\n  \\<not> has_disc disc ms\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc ms", "."], ["proof (state)\nthis:\n  \\<not> has_disc disc ms\n\ngoal (1 subgoal):\n 1. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "with \\<open>normalized_nnf_match ms\\<close>"], ["proof (chain)\npicking this:\n  normalized_nnf_match ms\n  \\<not> has_disc disc ms", "have \"normalized_n_primitive (disc, sel) P ms\""], ["proof (prove)\nusing this:\n  normalized_nnf_match ms\n  \\<not> has_disc disc ms\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc, sel) P ms", "by(induction \"(disc, sel)\" P ms rule: normalized_n_primitive.induct) simp_all"], ["proof (state)\nthis:\n  normalized_n_primitive (disc, sel) P ms\n\ngoal (1 subgoal):\n 1. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "from \\<open>wf_disc_sel (disc, sel) C\\<close>"], ["proof (chain)\npicking this:\n  wf_disc_sel (disc, sel) C", "have \"(sel (C spt)) = spt\""], ["proof (prove)\nusing this:\n  wf_disc_sel (disc, sel) C\n\ngoal (1 subgoal):\n 1. sel (C spt) = spt", "by(simp add: wf_disc_sel.simps)"], ["proof (state)\nthis:\n  sel (C spt) = spt\n\ngoal (1 subgoal):\n 1. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "with np \\<open>spt \\<in> set (f as)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as. \\<forall>a'\\<in>set (f as). P a'\n  spt \\<in> set (f as)\n  sel (C spt) = spt", "have \"P (sel (C spt))\""], ["proof (prove)\nusing this:\n  \\<forall>as. \\<forall>a'\\<in>set (f as). P a'\n  spt \\<in> set (f as)\n  sel (C spt) = spt\n\ngoal (1 subgoal):\n 1. P (sel (C spt))", "by simp"], ["proof (state)\nthis:\n  P (sel (C spt))\n\ngoal (1 subgoal):\n 1. f as \\<noteq> [] \\<Longrightarrow>\n    normalized_n_primitive (disc, sel) P m'", "show \"normalized_n_primitive (disc, sel) P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc, sel) P m'", "apply(simp add: \\<open>m' = MatchAnd (Match (C spt)) ms\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (disc (C spt) \\<longrightarrow>\n     P (sel (C spt)) \\<and> normalized_n_primitive (disc, sel) P ms) \\<and>\n    (\\<not> disc (C spt) \\<longrightarrow>\n     normalized_n_primitive (disc, sel) P ms)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. disc (C spt) \\<longrightarrow>\n    P (sel (C spt)) \\<and> normalized_n_primitive (disc, sel) P ms\n 2. \\<not> disc (C spt) \\<longrightarrow>\n    normalized_n_primitive (disc, sel) P ms", "apply(simp_all add: \\<open>normalized_n_primitive (disc, sel) P ms\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. disc (C spt) \\<longrightarrow> P (sel (C spt))", "apply(simp add: \\<open>P (sel (C spt))\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  normalized_n_primitive (disc, sel) P m'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normalized_n_primitive (disc, sel) P m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma primitive_extractor_negation_type_matching1:\n    assumes wf: \"wf_disc_sel (disc, sel) C\"\n        and normalized: \"normalized_nnf_match m\"\n        and a1: \"primitive_extractor (disc, sel) m = (as, rest)\"\n        and a2: \"matches \\<gamma> m a p\"\n    shows \"(\\<forall>m\\<in>set (map C (getPos as)). matches \\<gamma> (Match m) a p) \\<and> \n           (\\<forall>m\\<in>set (map C (getNeg as)). matches \\<gamma> (MatchNot (Match m)) a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set (map C (getPos as)).\n        matches \\<gamma> (Match m) a p) \\<and>\n    (\\<forall>m\\<in>set (map C (getNeg as)).\n        matches \\<gamma> (MatchNot (Match m)) a p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set (map C (getPos as)).\n        matches \\<gamma> (Match m) a p) \\<and>\n    (\\<forall>m\\<in>set (map C (getNeg as)).\n        matches \\<gamma> (MatchNot (Match m)) a p)", "from primitive_extractor_correct(1)[OF normalized wf a1] a2"], ["proof (chain)\npicking this:\n  (matches ?\\<gamma> (alist_and (NegPos_map C as)) ?a ?p \\<and>\n   matches ?\\<gamma> rest ?a ?p) =\n  matches ?\\<gamma> m ?a ?p\n  matches \\<gamma> m a p", "have\n        \"matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and> matches \\<gamma> rest a p\""], ["proof (prove)\nusing this:\n  (matches ?\\<gamma> (alist_and (NegPos_map C as)) ?a ?p \\<and>\n   matches ?\\<gamma> rest ?a ?p) =\n  matches ?\\<gamma> m ?a ?p\n  matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n    matches \\<gamma> rest a p", "by fast"], ["proof (state)\nthis:\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n  matches \\<gamma> rest a p\n\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set (map C (getPos as)).\n        matches \\<gamma> (Match m) a p) \\<and>\n    (\\<forall>m\\<in>set (map C (getNeg as)).\n        matches \\<gamma> (MatchNot (Match m)) a p)", "hence \"matches \\<gamma> (alist_and (NegPos_map C as)) a p\""], ["proof (prove)\nusing this:\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n  matches \\<gamma> rest a p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> (alist_and (NegPos_map C as)) a p", "by blast"], ["proof (state)\nthis:\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p\n\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set (map C (getPos as)).\n        matches \\<gamma> (Match m) a p) \\<and>\n    (\\<forall>m\\<in>set (map C (getNeg as)).\n        matches \\<gamma> (MatchNot (Match m)) a p)", "with Negation_Type_Matching.matches_alist_and"], ["proof (chain)\npicking this:\n  matches ?\\<gamma> (alist_and ?l) ?a ?p =\n  ((\\<forall>m\\<in>set (getPos ?l).\n       matches ?\\<gamma> (Match m) ?a ?p) \\<and>\n   (\\<forall>m\\<in>set (getNeg ?l).\n       matches ?\\<gamma> (MatchNot (Match m)) ?a ?p))\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p", "have\n        \"(\\<forall>m\\<in>set (getPos (NegPos_map C as)). matches \\<gamma> (Match m) a p) \\<and> \n         (\\<forall>m\\<in>set (getNeg (NegPos_map C as)). matches \\<gamma> (MatchNot (Match m)) a p)\""], ["proof (prove)\nusing this:\n  matches ?\\<gamma> (alist_and ?l) ?a ?p =\n  ((\\<forall>m\\<in>set (getPos ?l).\n       matches ?\\<gamma> (Match m) ?a ?p) \\<and>\n   (\\<forall>m\\<in>set (getNeg ?l).\n       matches ?\\<gamma> (MatchNot (Match m)) ?a ?p))\n  matches \\<gamma> (alist_and (NegPos_map C as)) a p\n\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set (getPos (NegPos_map C as)).\n        matches \\<gamma> (Match m) a p) \\<and>\n    (\\<forall>m\\<in>set (getNeg (NegPos_map C as)).\n        matches \\<gamma> (MatchNot (Match m)) a p)", "by metis"], ["proof (state)\nthis:\n  (\\<forall>m\\<in>set (getPos (NegPos_map C as)).\n      matches \\<gamma> (Match m) a p) \\<and>\n  (\\<forall>m\\<in>set (getNeg (NegPos_map C as)).\n      matches \\<gamma> (MatchNot (Match m)) a p)\n\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set (map C (getPos as)).\n        matches \\<gamma> (Match m) a p) \\<and>\n    (\\<forall>m\\<in>set (map C (getNeg as)).\n        matches \\<gamma> (MatchNot (Match m)) a p)", "with getPos_NegPos_map_simp2 getNeg_NegPos_map_simp2"], ["proof (chain)\npicking this:\n  getPos (NegPos_map ?X ?src) = map ?X (getPos ?src)\n  getNeg (NegPos_map ?X ?src) = map ?X (getNeg ?src)\n  (\\<forall>m\\<in>set (getPos (NegPos_map C as)).\n      matches \\<gamma> (Match m) a p) \\<and>\n  (\\<forall>m\\<in>set (getNeg (NegPos_map C as)).\n      matches \\<gamma> (MatchNot (Match m)) a p)", "show ?thesis"], ["proof (prove)\nusing this:\n  getPos (NegPos_map ?X ?src) = map ?X (getPos ?src)\n  getNeg (NegPos_map ?X ?src) = map ?X (getNeg ?src)\n  (\\<forall>m\\<in>set (getPos (NegPos_map C as)).\n      matches \\<gamma> (Match m) a p) \\<and>\n  (\\<forall>m\\<in>set (getNeg (NegPos_map C as)).\n      matches \\<gamma> (MatchNot (Match m)) a p)\n\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set (map C (getPos as)).\n        matches \\<gamma> (Match m) a p) \\<and>\n    (\\<forall>m\\<in>set (map C (getNeg as)).\n        matches \\<gamma> (MatchNot (Match m)) a p)", "by metis"], ["proof (state)\nthis:\n  (\\<forall>m\\<in>set (map C (getPos as)).\n      matches \\<gamma> (Match m) a p) \\<and>\n  (\\<forall>m\\<in>set (map C (getNeg as)).\n      matches \\<gamma> (MatchNot (Match m)) a p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>@{const normalized_n_primitive} does NOT imply @{const normalized_nnf_match}\\<close>"], ["", "lemma \"\\<exists>m. normalized_n_primitive disc_sel f m \\<longrightarrow> \\<not> normalized_nnf_match m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       normalized_n_primitive disc_sel f m \\<longrightarrow>\n       \\<not> normalized_nnf_match m", "by(rule_tac x=\"MatchNot MatchAny\" in exI) (simp)"], ["", "lemma remove_unknowns_generic_not_has_disc: \"\\<not> has_disc C m \\<Longrightarrow> \\<not> has_disc C (remove_unknowns_generic \\<gamma> a m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc C m \\<Longrightarrow>\n    \\<not> has_disc C (remove_unknowns_generic \\<gamma> a m)", "by(induction \\<gamma> a m rule: remove_unknowns_generic.induct) (simp_all add: remove_unknowns_generic_simps2)"], ["", "lemma remove_unknowns_generic_not_has_disc_negated: \"\\<not> has_disc_negated C neg m \\<Longrightarrow> \\<not> has_disc_negated C neg (remove_unknowns_generic \\<gamma> a m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated C neg m \\<Longrightarrow>\n    \\<not> has_disc_negated C neg (remove_unknowns_generic \\<gamma> a m)", "by(induction \\<gamma> a m rule: remove_unknowns_generic.induct) (simp_all add: remove_unknowns_generic_simps2)"], ["", "lemma remove_unknowns_generic_normalized_n_primitive: \"normalized_n_primitive disc_sel f m \\<Longrightarrow> \n    normalized_n_primitive disc_sel f (remove_unknowns_generic \\<gamma> a m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f m \\<Longrightarrow>\n    normalized_n_primitive disc_sel f (remove_unknowns_generic \\<gamma> a m)", "proof(induction \\<gamma> a m rule: remove_unknowns_generic.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>uu_ uv_.\n       normalized_n_primitive disc_sel f MatchAny \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic uu_ uv_ MatchAny)\n 2. \\<And>uw_ ux_.\n       normalized_n_primitive disc_sel f\n        (MatchNot MatchAny) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic uw_ ux_ (MatchNot MatchAny))\n 3. \\<And>\\<beta> \\<alpha> a A.\n       normalized_n_primitive disc_sel f (Match A) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic (\\<beta>, \\<alpha>) a (Match A))\n 4. \\<And>\\<beta> \\<alpha> a A.\n       normalized_n_primitive disc_sel f\n        (MatchNot (Match A)) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot (Match A)))\n 5. \\<And>\\<beta> \\<alpha> a m.\n       \\<lbrakk>normalized_n_primitive disc_sel f m \\<Longrightarrow>\n                normalized_n_primitive disc_sel f\n                 (remove_unknowns_generic (\\<beta>, \\<alpha>) a m);\n        normalized_n_primitive disc_sel f (MatchNot (MatchNot m))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                            (MatchNot (MatchNot m)))\n 6. \\<And>\\<beta> \\<alpha> a m1 m2.\n       \\<lbrakk>normalized_n_primitive disc_sel f m1 \\<Longrightarrow>\n                normalized_n_primitive disc_sel f\n                 (remove_unknowns_generic (\\<beta>, \\<alpha>) a m1);\n        normalized_n_primitive disc_sel f m2 \\<Longrightarrow>\n        normalized_n_primitive disc_sel f\n         (remove_unknowns_generic (\\<beta>, \\<alpha>) a m2);\n        normalized_n_primitive disc_sel f (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                            (MatchAnd m1 m2))\n 7. \\<And>\\<beta> \\<alpha> a m1 m2.\n       \\<lbrakk>normalized_n_primitive disc_sel f\n                 (MatchNot m1) \\<Longrightarrow>\n                normalized_n_primitive disc_sel f\n                 (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                   (MatchNot m1));\n        normalized_n_primitive disc_sel f (MatchNot m2) \\<Longrightarrow>\n        normalized_n_primitive disc_sel f\n         (remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m1) =\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m2) =\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m2) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m2) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        normalized_n_primitive disc_sel f\n         (MatchNot (MatchAnd m1 m2))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                            (MatchNot (MatchAnd m1 m2)))", "case 6"], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel f m1_ \\<Longrightarrow>\n  normalized_n_primitive disc_sel f\n   (remove_unknowns_generic (\\<beta>_, \\<alpha>_) a_ m1_)\n  normalized_n_primitive disc_sel f m2_ \\<Longrightarrow>\n  normalized_n_primitive disc_sel f\n   (remove_unknowns_generic (\\<beta>_, \\<alpha>_) a_ m2_)\n  normalized_n_primitive disc_sel f (MatchAnd m1_ m2_)\n\ngoal (7 subgoals):\n 1. \\<And>uu_ uv_.\n       normalized_n_primitive disc_sel f MatchAny \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic uu_ uv_ MatchAny)\n 2. \\<And>uw_ ux_.\n       normalized_n_primitive disc_sel f\n        (MatchNot MatchAny) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic uw_ ux_ (MatchNot MatchAny))\n 3. \\<And>\\<beta> \\<alpha> a A.\n       normalized_n_primitive disc_sel f (Match A) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic (\\<beta>, \\<alpha>) a (Match A))\n 4. \\<And>\\<beta> \\<alpha> a A.\n       normalized_n_primitive disc_sel f\n        (MatchNot (Match A)) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot (Match A)))\n 5. \\<And>\\<beta> \\<alpha> a m.\n       \\<lbrakk>normalized_n_primitive disc_sel f m \\<Longrightarrow>\n                normalized_n_primitive disc_sel f\n                 (remove_unknowns_generic (\\<beta>, \\<alpha>) a m);\n        normalized_n_primitive disc_sel f (MatchNot (MatchNot m))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                            (MatchNot (MatchNot m)))\n 6. \\<And>\\<beta> \\<alpha> a m1 m2.\n       \\<lbrakk>normalized_n_primitive disc_sel f m1 \\<Longrightarrow>\n                normalized_n_primitive disc_sel f\n                 (remove_unknowns_generic (\\<beta>, \\<alpha>) a m1);\n        normalized_n_primitive disc_sel f m2 \\<Longrightarrow>\n        normalized_n_primitive disc_sel f\n         (remove_unknowns_generic (\\<beta>, \\<alpha>) a m2);\n        normalized_n_primitive disc_sel f (MatchAnd m1 m2)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                            (MatchAnd m1 m2))\n 7. \\<And>\\<beta> \\<alpha> a m1 m2.\n       \\<lbrakk>normalized_n_primitive disc_sel f\n                 (MatchNot m1) \\<Longrightarrow>\n                normalized_n_primitive disc_sel f\n                 (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                   (MatchNot m1));\n        normalized_n_primitive disc_sel f (MatchNot m2) \\<Longrightarrow>\n        normalized_n_primitive disc_sel f\n         (remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m1) =\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m2) =\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m2) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m2) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        normalized_n_primitive disc_sel f\n         (MatchNot (MatchAnd m1 m2))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                            (MatchNot (MatchAnd m1 m2)))", "thus ?case"], ["proof (prove)\nusing this:\n  normalized_n_primitive disc_sel f m1_ \\<Longrightarrow>\n  normalized_n_primitive disc_sel f\n   (remove_unknowns_generic (\\<beta>_, \\<alpha>_) a_ m1_)\n  normalized_n_primitive disc_sel f m2_ \\<Longrightarrow>\n  normalized_n_primitive disc_sel f\n   (remove_unknowns_generic (\\<beta>_, \\<alpha>_) a_ m2_)\n  normalized_n_primitive disc_sel f (MatchAnd m1_ m2_)\n\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f\n     (remove_unknowns_generic (\\<beta>_, \\<alpha>_) a_ (MatchAnd m1_ m2_))", "by(case_tac disc_sel, simp add: remove_unknowns_generic_simps2)"], ["proof (state)\nthis:\n  normalized_n_primitive disc_sel f\n   (remove_unknowns_generic (\\<beta>_, \\<alpha>_) a_ (MatchAnd m1_ m2_))\n\ngoal (6 subgoals):\n 1. \\<And>uu_ uv_.\n       normalized_n_primitive disc_sel f MatchAny \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic uu_ uv_ MatchAny)\n 2. \\<And>uw_ ux_.\n       normalized_n_primitive disc_sel f\n        (MatchNot MatchAny) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic uw_ ux_ (MatchNot MatchAny))\n 3. \\<And>\\<beta> \\<alpha> a A.\n       normalized_n_primitive disc_sel f (Match A) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic (\\<beta>, \\<alpha>) a (Match A))\n 4. \\<And>\\<beta> \\<alpha> a A.\n       normalized_n_primitive disc_sel f\n        (MatchNot (Match A)) \\<Longrightarrow>\n       normalized_n_primitive disc_sel f\n        (remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot (Match A)))\n 5. \\<And>\\<beta> \\<alpha> a m.\n       \\<lbrakk>normalized_n_primitive disc_sel f m \\<Longrightarrow>\n                normalized_n_primitive disc_sel f\n                 (remove_unknowns_generic (\\<beta>, \\<alpha>) a m);\n        normalized_n_primitive disc_sel f (MatchNot (MatchNot m))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                            (MatchNot (MatchNot m)))\n 6. \\<And>\\<beta> \\<alpha> a m1 m2.\n       \\<lbrakk>normalized_n_primitive disc_sel f\n                 (MatchNot m1) \\<Longrightarrow>\n                normalized_n_primitive disc_sel f\n                 (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                   (MatchNot m1));\n        normalized_n_primitive disc_sel f (MatchNot m2) \\<Longrightarrow>\n        normalized_n_primitive disc_sel f\n         (remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m1) =\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a (MatchNot m2) =\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m2) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m1)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m1));\n        \\<lbrakk>\\<not> (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m1) =\n                         MatchAny \\<or>\n                         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                          (MatchNot m2) =\n                         MatchAny);\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m1) \\<noteq>\n         MatchNot MatchAny;\n         remove_unknowns_generic (\\<beta>, \\<alpha>) a\n          (MatchNot m2) \\<noteq>\n         MatchNot MatchAny;\n         normalized_n_primitive disc_sel f (MatchNot m2)\\<rbrakk>\n        \\<Longrightarrow> normalized_n_primitive disc_sel f\n                           (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                             (MatchNot m2));\n        normalized_n_primitive disc_sel f\n         (MatchNot (MatchAnd m1 m2))\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive disc_sel f\n                          (remove_unknowns_generic (\\<beta>, \\<alpha>) a\n                            (MatchNot (MatchAnd m1 m2)))", "qed(simp_all add: remove_unknowns_generic_simps2)"], ["", "lemma normalize_match_preserves_disc_negated: \n    shows \"(\\<exists>m_DNF \\<in> set (normalize_match m). has_disc_negated disc neg m_DNF) \\<Longrightarrow> has_disc_negated disc neg m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m_DNF\\<in>set (normalize_match m).\n       has_disc_negated disc neg m_DNF \\<Longrightarrow>\n    has_disc_negated disc neg m", "proof(induction m rule: normalize_match.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. Bex (set (normalize_match MatchAny))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg MatchAny\n 2. \\<And>m.\n       Bex (set (normalize_match (Match m)))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (Match m)\n 3. \\<And>m1 m2.\n       \\<lbrakk>Bex (set (normalize_match m1))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg m1;\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (normalize_match m1);\n            Bex (set (normalize_match m2))\n             (has_disc_negated disc neg)\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc neg m2;\n        Bex (set (normalize_match (MatchAnd m1 m2)))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg (MatchAnd m1 m2)\n 4. \\<And>m1 m2.\n       \\<lbrakk>Bex (set (normalize_match (MatchNot m1)))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg (MatchNot m1);\n        Bex (set (normalize_match (MatchNot m2)))\n         (has_disc_negated disc neg) \\<Longrightarrow>\n        has_disc_negated disc neg (MatchNot m2);\n        Bex (set (normalize_match (MatchNot (MatchAnd m1 m2))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg\n                          (MatchNot (MatchAnd m1 m2))\n 5. \\<And>m.\n       \\<lbrakk>Bex (set (normalize_match m))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg m;\n        Bex (set (normalize_match (MatchNot (MatchNot m))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg (MatchNot (MatchNot m))\n 6. Bex (set (normalize_match (MatchNot MatchAny)))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg (MatchNot MatchAny)\n 7. \\<And>m.\n       Bex (set (normalize_match (MatchNot (Match m))))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (MatchNot (Match m))", "case 3"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (normalize_match m1_).\n     has_disc_negated disc neg a \\<Longrightarrow>\n  has_disc_negated disc neg m1_\n  \\<lbrakk>?x \\<in> set (normalize_match m1_);\n   \\<exists>a\\<in>set (normalize_match m2_).\n      has_disc_negated disc neg a\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc neg m2_\n  \\<exists>a\\<in>set (normalize_match (MatchAnd m1_ m2_)).\n     has_disc_negated disc neg a\n\ngoal (7 subgoals):\n 1. Bex (set (normalize_match MatchAny))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg MatchAny\n 2. \\<And>m.\n       Bex (set (normalize_match (Match m)))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (Match m)\n 3. \\<And>m1 m2.\n       \\<lbrakk>Bex (set (normalize_match m1))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg m1;\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (normalize_match m1);\n            Bex (set (normalize_match m2))\n             (has_disc_negated disc neg)\\<rbrakk>\n           \\<Longrightarrow> has_disc_negated disc neg m2;\n        Bex (set (normalize_match (MatchAnd m1 m2)))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg (MatchAnd m1 m2)\n 4. \\<And>m1 m2.\n       \\<lbrakk>Bex (set (normalize_match (MatchNot m1)))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg (MatchNot m1);\n        Bex (set (normalize_match (MatchNot m2)))\n         (has_disc_negated disc neg) \\<Longrightarrow>\n        has_disc_negated disc neg (MatchNot m2);\n        Bex (set (normalize_match (MatchNot (MatchAnd m1 m2))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg\n                          (MatchNot (MatchAnd m1 m2))\n 5. \\<And>m.\n       \\<lbrakk>Bex (set (normalize_match m))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg m;\n        Bex (set (normalize_match (MatchNot (MatchNot m))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg (MatchNot (MatchNot m))\n 6. Bex (set (normalize_match (MatchNot MatchAny)))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg (MatchNot MatchAny)\n 7. \\<And>m.\n       Bex (set (normalize_match (MatchNot (Match m))))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (MatchNot (Match m))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set (normalize_match m1_).\n     has_disc_negated disc neg a \\<Longrightarrow>\n  has_disc_negated disc neg m1_\n  \\<lbrakk>?x \\<in> set (normalize_match m1_);\n   \\<exists>a\\<in>set (normalize_match m2_).\n      has_disc_negated disc neg a\\<rbrakk>\n  \\<Longrightarrow> has_disc_negated disc neg m2_\n  \\<exists>a\\<in>set (normalize_match (MatchAnd m1_ m2_)).\n     has_disc_negated disc neg a\n\ngoal (1 subgoal):\n 1. has_disc_negated disc neg (MatchAnd m1_ m2_)", "by (simp) blast"], ["proof (state)\nthis:\n  has_disc_negated disc neg (MatchAnd m1_ m2_)\n\ngoal (6 subgoals):\n 1. Bex (set (normalize_match MatchAny))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg MatchAny\n 2. \\<And>m.\n       Bex (set (normalize_match (Match m)))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (Match m)\n 3. \\<And>m1 m2.\n       \\<lbrakk>Bex (set (normalize_match (MatchNot m1)))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg (MatchNot m1);\n        Bex (set (normalize_match (MatchNot m2)))\n         (has_disc_negated disc neg) \\<Longrightarrow>\n        has_disc_negated disc neg (MatchNot m2);\n        Bex (set (normalize_match (MatchNot (MatchAnd m1 m2))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg\n                          (MatchNot (MatchAnd m1 m2))\n 4. \\<And>m.\n       \\<lbrakk>Bex (set (normalize_match m))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg m;\n        Bex (set (normalize_match (MatchNot (MatchNot m))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg (MatchNot (MatchNot m))\n 5. Bex (set (normalize_match (MatchNot MatchAny)))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg (MatchNot MatchAny)\n 6. \\<And>m.\n       Bex (set (normalize_match (MatchNot (Match m))))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (MatchNot (Match m))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. Bex (set (normalize_match MatchAny))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg MatchAny\n 2. \\<And>m.\n       Bex (set (normalize_match (Match m)))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (Match m)\n 3. \\<And>m1 m2.\n       \\<lbrakk>Bex (set (normalize_match (MatchNot m1)))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg (MatchNot m1);\n        Bex (set (normalize_match (MatchNot m2)))\n         (has_disc_negated disc neg) \\<Longrightarrow>\n        has_disc_negated disc neg (MatchNot m2);\n        Bex (set (normalize_match (MatchNot (MatchAnd m1 m2))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg\n                          (MatchNot (MatchAnd m1 m2))\n 4. \\<And>m.\n       \\<lbrakk>Bex (set (normalize_match m))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg m;\n        Bex (set (normalize_match (MatchNot (MatchNot m))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg (MatchNot (MatchNot m))\n 5. Bex (set (normalize_match (MatchNot MatchAny)))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg (MatchNot MatchAny)\n 6. \\<And>m.\n       Bex (set (normalize_match (MatchNot (Match m))))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (MatchNot (Match m))", "case 4"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (normalize_match (MatchNot m1_)).\n     has_disc_negated disc neg a \\<Longrightarrow>\n  has_disc_negated disc neg (MatchNot m1_)\n  \\<exists>a\\<in>set (normalize_match (MatchNot m2_)).\n     has_disc_negated disc neg a \\<Longrightarrow>\n  has_disc_negated disc neg (MatchNot m2_)\n  \\<exists>a\\<in>set (normalize_match (MatchNot (MatchAnd m1_ m2_))).\n     has_disc_negated disc neg a\n\ngoal (6 subgoals):\n 1. Bex (set (normalize_match MatchAny))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg MatchAny\n 2. \\<And>m.\n       Bex (set (normalize_match (Match m)))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (Match m)\n 3. \\<And>m1 m2.\n       \\<lbrakk>Bex (set (normalize_match (MatchNot m1)))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg (MatchNot m1);\n        Bex (set (normalize_match (MatchNot m2)))\n         (has_disc_negated disc neg) \\<Longrightarrow>\n        has_disc_negated disc neg (MatchNot m2);\n        Bex (set (normalize_match (MatchNot (MatchAnd m1 m2))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg\n                          (MatchNot (MatchAnd m1 m2))\n 4. \\<And>m.\n       \\<lbrakk>Bex (set (normalize_match m))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg m;\n        Bex (set (normalize_match (MatchNot (MatchNot m))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg (MatchNot (MatchNot m))\n 5. Bex (set (normalize_match (MatchNot MatchAny)))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg (MatchNot MatchAny)\n 6. \\<And>m.\n       Bex (set (normalize_match (MatchNot (Match m))))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (MatchNot (Match m))", "from 4"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>set (normalize_match (MatchNot m1_)).\n     has_disc_negated disc neg a \\<Longrightarrow>\n  has_disc_negated disc neg (MatchNot m1_)\n  \\<exists>a\\<in>set (normalize_match (MatchNot m2_)).\n     has_disc_negated disc neg a \\<Longrightarrow>\n  has_disc_negated disc neg (MatchNot m2_)\n  \\<exists>a\\<in>set (normalize_match (MatchNot (MatchAnd m1_ m2_))).\n     has_disc_negated disc neg a", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set (normalize_match (MatchNot m1_)).\n     has_disc_negated disc neg a \\<Longrightarrow>\n  has_disc_negated disc neg (MatchNot m1_)\n  \\<exists>a\\<in>set (normalize_match (MatchNot m2_)).\n     has_disc_negated disc neg a \\<Longrightarrow>\n  has_disc_negated disc neg (MatchNot m2_)\n  \\<exists>a\\<in>set (normalize_match (MatchNot (MatchAnd m1_ m2_))).\n     has_disc_negated disc neg a\n\ngoal (1 subgoal):\n 1. has_disc_negated disc neg (MatchNot (MatchAnd m1_ m2_))", "by(simp) blast"], ["proof (state)\nthis:\n  has_disc_negated disc neg (MatchNot (MatchAnd m1_ m2_))\n\ngoal (5 subgoals):\n 1. Bex (set (normalize_match MatchAny))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg MatchAny\n 2. \\<And>m.\n       Bex (set (normalize_match (Match m)))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (Match m)\n 3. \\<And>m.\n       \\<lbrakk>Bex (set (normalize_match m))\n                 (has_disc_negated disc neg) \\<Longrightarrow>\n                has_disc_negated disc neg m;\n        Bex (set (normalize_match (MatchNot (MatchNot m))))\n         (has_disc_negated disc neg)\\<rbrakk>\n       \\<Longrightarrow> has_disc_negated disc neg (MatchNot (MatchNot m))\n 4. Bex (set (normalize_match (MatchNot MatchAny)))\n     (has_disc_negated disc neg) \\<Longrightarrow>\n    has_disc_negated disc neg (MatchNot MatchAny)\n 5. \\<And>m.\n       Bex (set (normalize_match (MatchNot (Match m))))\n        (has_disc_negated disc neg) \\<Longrightarrow>\n       has_disc_negated disc neg (MatchNot (Match m))", "qed(simp_all)"], ["", "text\\<open>@{const has_disc_negated} is a structural property and @{const normalize_match} is a semantical property.\n  @{const normalize_match} removes subexpressions which cannot match. Thus, we cannot show (without complicated assumptions)\n  the opposite direction of @{thm normalize_match_preserves_disc_negated}, because a negated primitive\n  might occur in a subexpression which will be optimized away.\\<close>"], ["", "corollary i_m_giving_this_a_funny_name_so_i_can_thank_my_future_me_when_sledgehammer_will_find_this_one_day:\n  \"\\<not> has_disc_negated disc neg m \\<Longrightarrow> \\<forall> m_DNF \\<in> set (normalize_match m). \\<not> has_disc_negated disc neg m_DNF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n    \\<forall>m_DNF\\<in>set (normalize_match m).\n       \\<not> has_disc_negated disc neg m_DNF", "using normalize_match_preserves_disc_negated"], ["proof (prove)\nusing this:\n  \\<exists>m_DNF\\<in>set (normalize_match ?m).\n     has_disc_negated ?disc ?neg m_DNF \\<Longrightarrow>\n  has_disc_negated ?disc ?neg ?m\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n    \\<forall>m_DNF\\<in>set (normalize_match m).\n       \\<not> has_disc_negated disc neg m_DNF", "by blast"], ["", "lemma not_has_disc_opt_MatchAny_match_expr:\n  \"\\<not> has_disc disc m \\<Longrightarrow> \\<not> has_disc disc (opt_MatchAny_match_expr m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m \\<Longrightarrow>\n    \\<not> has_disc disc (opt_MatchAny_match_expr m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m \\<Longrightarrow>\n    \\<not> has_disc disc (opt_MatchAny_match_expr m)", "have \"\\<not> has_disc disc m \\<Longrightarrow> \\<not> has_disc disc (opt_MatchAny_match_expr_once m)\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m \\<Longrightarrow>\n    \\<not> has_disc disc (opt_MatchAny_match_expr_once m)", "by(induction m rule: opt_MatchAny_match_expr_once.induct) simp_all"], ["proof (state)\nthis:\n  \\<not> has_disc disc ?m \\<Longrightarrow>\n  \\<not> has_disc disc (opt_MatchAny_match_expr_once ?m)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m \\<Longrightarrow>\n    \\<not> has_disc disc (opt_MatchAny_match_expr m)", "thus \"\\<not> has_disc disc m \\<Longrightarrow> \\<not> has_disc disc (opt_MatchAny_match_expr m)\""], ["proof (prove)\nusing this:\n  \\<not> has_disc disc ?m \\<Longrightarrow>\n  \\<not> has_disc disc (opt_MatchAny_match_expr_once ?m)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m \\<Longrightarrow>\n    \\<not> has_disc disc (opt_MatchAny_match_expr m)", "apply(simp add: opt_MatchAny_match_expr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m;\n     \\<And>m.\n        \\<not> has_disc disc m \\<Longrightarrow>\n        \\<not> has_disc disc (opt_MatchAny_match_expr_once m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc\n                              (repeat_stabilize 2\n                                opt_MatchAny_match_expr_once m)", "apply(rule repeat_stabilize_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc disc m;\n     \\<And>m.\n        \\<not> has_disc disc m \\<Longrightarrow>\n        \\<not> has_disc disc (opt_MatchAny_match_expr_once m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m\n 2. \\<And>ma.\n       \\<lbrakk>\\<not> has_disc disc m;\n        \\<And>m.\n           \\<not> has_disc disc m \\<Longrightarrow>\n           \\<not> has_disc disc (opt_MatchAny_match_expr_once m);\n        \\<not> has_disc disc ma\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc\n                                 (opt_MatchAny_match_expr_once ma)", "by(simp)+"], ["proof (state)\nthis:\n  \\<not> has_disc disc m \\<Longrightarrow>\n  \\<not> has_disc disc (opt_MatchAny_match_expr m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_has_disc_negated_opt_MatchAny_match_expr:\n  \"\\<not> has_disc_negated disc neg m \\<Longrightarrow> \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n    \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n    \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr m)", "have \"\\<not> has_disc_negated disc neg m \\<Longrightarrow> \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr_once m)\"\n    for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n    \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr_once m)", "by(induction m arbitrary: neg rule:opt_MatchAny_match_expr_once.induct) (simp_all)"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc neg ?m \\<Longrightarrow>\n  \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr_once ?m)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n    \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr m)", "thus \"\\<not> has_disc_negated disc neg m \\<Longrightarrow> \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr m)\""], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc neg ?m \\<Longrightarrow>\n  \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr_once ?m)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n    \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr m)", "apply(simp add: opt_MatchAny_match_expr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc neg m;\n     \\<And>m.\n        \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n        \\<not> has_disc_negated disc neg\n                (opt_MatchAny_match_expr_once m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc neg\n                              (repeat_stabilize 2\n                                opt_MatchAny_match_expr_once m)", "apply(rule repeat_stabilize_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> has_disc_negated disc neg m;\n     \\<And>m.\n        \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n        \\<not> has_disc_negated disc neg\n                (opt_MatchAny_match_expr_once m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc neg m\n 2. \\<And>ma.\n       \\<lbrakk>\\<not> has_disc_negated disc neg m;\n        \\<And>m.\n           \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n           \\<not> has_disc_negated disc neg\n                   (opt_MatchAny_match_expr_once m);\n        \\<not> has_disc_negated disc neg ma\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc neg\n                                 (opt_MatchAny_match_expr_once ma)", "by(simp)+"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc neg m \\<Longrightarrow>\n  \\<not> has_disc_negated disc neg (opt_MatchAny_match_expr m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_match_preserves_nodisc:\n  \"\\<not> has_disc disc m \\<Longrightarrow> m' \\<in> set (normalize_match m) \\<Longrightarrow> \\<not> has_disc disc m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m;\n     m' \\<in> set (normalize_match m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m;\n     m' \\<in> set (normalize_match m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m'", "(*no idea why this statement is necessary*)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m;\n     m' \\<in> set (normalize_match m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m'", "have \"\\<not> has_disc disc m \\<longrightarrow> (\\<forall>m' \\<in> set (normalize_match m). \\<not> has_disc disc m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m \\<longrightarrow>\n    (\\<forall>m'\\<in>set (normalize_match m). \\<not> has_disc disc m')", "by(induction m rule: normalize_match.induct) (safe,auto) \\<comment> \\<open>need safe, otherwise simplifier loops\\<close>"], ["proof (state)\nthis:\n  \\<not> has_disc disc m \\<longrightarrow>\n  (\\<forall>m'\\<in>set (normalize_match m). \\<not> has_disc disc m')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m;\n     m' \\<in> set (normalize_match m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m'", "thus \"\\<not> has_disc disc m \\<Longrightarrow> m' \\<in> set (normalize_match m) \\<Longrightarrow> \\<not> has_disc disc m'\""], ["proof (prove)\nusing this:\n  \\<not> has_disc disc m \\<longrightarrow>\n  (\\<forall>m'\\<in>set (normalize_match m). \\<not> has_disc disc m')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc disc m;\n     m' \\<in> set (normalize_match m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc m'", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> has_disc disc m; m' \\<in> set (normalize_match m)\\<rbrakk>\n  \\<Longrightarrow> \\<not> has_disc disc m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_has_disc_normalize_match:\n  \"\\<not> has_disc_negated disc neg  m \\<Longrightarrow> m' \\<in> set (normalize_match m) \\<Longrightarrow> \\<not> has_disc_negated disc neg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc neg m;\n     m' \\<in> set (normalize_match m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc neg m'", "using i_m_giving_this_a_funny_name_so_i_can_thank_my_future_me_when_sledgehammer_will_find_this_one_day"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated ?disc ?neg ?m \\<Longrightarrow>\n  \\<forall>m_DNF\\<in>set (normalize_match ?m).\n     \\<not> has_disc_negated ?disc ?neg m_DNF\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_disc_negated disc neg m;\n     m' \\<in> set (normalize_match m)\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc neg m'", "by blast"], ["", "lemma normalize_match_preserves_normalized_n_primitive:\n  \"normalized_n_primitive disc_sel f rst \\<Longrightarrow>\n        \\<forall> m \\<in> set (normalize_match rst). normalized_n_primitive disc_sel f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_n_primitive disc_sel f rst \\<Longrightarrow>\n    \\<forall>m\\<in>set (normalize_match rst).\n       normalized_n_primitive disc_sel f m", "apply(cases disc_sel, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f rst;\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (normalize_match rst).\n                            normalized_n_primitive (a, b) f m", "apply(induction rst rule: normalize_match.induct)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f MatchAny;\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match MatchAny))\n                          (normalized_n_primitive (a, b) f)\n 2. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (Match m);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (Match m)))\n                          (normalized_n_primitive (a, b) f)\n 3. \\<And>m1 m2 a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m1;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m1))\n(normalized_n_primitive (a, b) f);\n        \\<And>x a b.\n           \\<lbrakk>x \\<in> set (normalize_match m1);\n            normalized_n_primitive (a, b) f m2; disc_sel = (a, b)\\<rbrakk>\n           \\<Longrightarrow> Ball (set (normalize_match m2))\n                              (normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchAnd m1 m2);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchAnd m1 m2)))\n                          (normalized_n_primitive (a, b) f)\n 4. \\<And>m1 m2 a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m1);\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball\n(set (normalize_match (MatchNot m1))) (normalized_n_primitive (a, b) f);\n        \\<And>a b.\n           \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m2);\n            disc_sel = (a, b)\\<rbrakk>\n           \\<Longrightarrow> Ball (set (normalize_match (MatchNot m2)))\n                              (normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchAnd m1 m2));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match\n                                 (MatchNot (MatchAnd m1 m2))))\n                          (normalized_n_primitive (a, b) f)\n 5. \\<And>m a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m))\n(normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchNot m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match (MatchNot (MatchNot m))))\n                          (normalized_n_primitive (a, b) f)\n 6. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot MatchAny);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot MatchAny)))\n                          (normalized_n_primitive (a, b) f)\n 7. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot (Match m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot (Match m))))\n                          (normalized_n_primitive (a, b) f)", "apply(simp; fail)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (Match m);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (Match m)))\n                          (normalized_n_primitive (a, b) f)\n 2. \\<And>m1 m2 a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m1;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m1))\n(normalized_n_primitive (a, b) f);\n        \\<And>x a b.\n           \\<lbrakk>x \\<in> set (normalize_match m1);\n            normalized_n_primitive (a, b) f m2; disc_sel = (a, b)\\<rbrakk>\n           \\<Longrightarrow> Ball (set (normalize_match m2))\n                              (normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchAnd m1 m2);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchAnd m1 m2)))\n                          (normalized_n_primitive (a, b) f)\n 3. \\<And>m1 m2 a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m1);\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball\n(set (normalize_match (MatchNot m1))) (normalized_n_primitive (a, b) f);\n        \\<And>a b.\n           \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m2);\n            disc_sel = (a, b)\\<rbrakk>\n           \\<Longrightarrow> Ball (set (normalize_match (MatchNot m2)))\n                              (normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchAnd m1 m2));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match\n                                 (MatchNot (MatchAnd m1 m2))))\n                          (normalized_n_primitive (a, b) f)\n 4. \\<And>m a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m))\n(normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchNot m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match (MatchNot (MatchNot m))))\n                          (normalized_n_primitive (a, b) f)\n 5. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot MatchAny);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot MatchAny)))\n                          (normalized_n_primitive (a, b) f)\n 6. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot (Match m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot (Match m))))\n                          (normalized_n_primitive (a, b) f)", "apply(simp; fail)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m1 m2 a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m1;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m1))\n(normalized_n_primitive (a, b) f);\n        \\<And>x a b.\n           \\<lbrakk>x \\<in> set (normalize_match m1);\n            normalized_n_primitive (a, b) f m2; disc_sel = (a, b)\\<rbrakk>\n           \\<Longrightarrow> Ball (set (normalize_match m2))\n                              (normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchAnd m1 m2);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchAnd m1 m2)))\n                          (normalized_n_primitive (a, b) f)\n 2. \\<And>m1 m2 a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m1);\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball\n(set (normalize_match (MatchNot m1))) (normalized_n_primitive (a, b) f);\n        \\<And>a b.\n           \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m2);\n            disc_sel = (a, b)\\<rbrakk>\n           \\<Longrightarrow> Ball (set (normalize_match (MatchNot m2)))\n                              (normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchAnd m1 m2));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match\n                                 (MatchNot (MatchAnd m1 m2))))\n                          (normalized_n_primitive (a, b) f)\n 3. \\<And>m a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m))\n(normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchNot m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match (MatchNot (MatchNot m))))\n                          (normalized_n_primitive (a, b) f)\n 4. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot MatchAny);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot MatchAny)))\n                          (normalized_n_primitive (a, b) f)\n 5. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot (Match m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot (Match m))))\n                          (normalized_n_primitive (a, b) f)", "apply(simp; fail)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m1 m2 a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m1);\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball\n(set (normalize_match (MatchNot m1))) (normalized_n_primitive (a, b) f);\n        \\<And>a b.\n           \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m2);\n            disc_sel = (a, b)\\<rbrakk>\n           \\<Longrightarrow> Ball (set (normalize_match (MatchNot m2)))\n                              (normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchAnd m1 m2));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match\n                                 (MatchNot (MatchAnd m1 m2))))\n                          (normalized_n_primitive (a, b) f)\n 2. \\<And>m a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m))\n(normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchNot m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match (MatchNot (MatchNot m))))\n                          (normalized_n_primitive (a, b) f)\n 3. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot MatchAny);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot MatchAny)))\n                          (normalized_n_primitive (a, b) f)\n 4. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot (Match m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot (Match m))))\n                          (normalized_n_primitive (a, b) f)", "using normalized_n_primitive.simps(5)"], ["proof (prove)\nusing this:\n  normalized_n_primitive ?uw ?ux (MatchNot (MatchAnd ?uy ?uz)) = False\n\ngoal (4 subgoals):\n 1. \\<And>m1 m2 a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m1);\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball\n(set (normalize_match (MatchNot m1))) (normalized_n_primitive (a, b) f);\n        \\<And>a b.\n           \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot m2);\n            disc_sel = (a, b)\\<rbrakk>\n           \\<Longrightarrow> Ball (set (normalize_match (MatchNot m2)))\n                              (normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchAnd m1 m2));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match\n                                 (MatchNot (MatchAnd m1 m2))))\n                          (normalized_n_primitive (a, b) f)\n 2. \\<And>m a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m))\n(normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchNot m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match (MatchNot (MatchNot m))))\n                          (normalized_n_primitive (a, b) f)\n 3. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot MatchAny);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot MatchAny)))\n                          (normalized_n_primitive (a, b) f)\n 4. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot (Match m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot (Match m))))\n                          (normalized_n_primitive (a, b) f)", "apply metis"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m))\n(normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchNot m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match (MatchNot (MatchNot m))))\n                          (normalized_n_primitive (a, b) f)\n 2. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot MatchAny);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot MatchAny)))\n                          (normalized_n_primitive (a, b) f)\n 3. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot (Match m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot (Match m))))\n                          (normalized_n_primitive (a, b) f)", "(*simp loops*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>normalized_n_primitive (a, b) f m;\n                    disc_sel = (a, b)\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (normalize_match m))\n(normalized_n_primitive (a, b) f);\n        normalized_n_primitive (a, b) f (MatchNot (MatchNot m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (normalize_match (MatchNot (MatchNot m))))\n                          (normalized_n_primitive (a, b) f)\n 2. \\<And>a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot MatchAny);\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot MatchAny)))\n                          (normalized_n_primitive (a, b) f)\n 3. \\<And>m a b.\n       \\<lbrakk>normalized_n_primitive (a, b) f (MatchNot (Match m));\n        disc_sel = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (normalize_match (MatchNot (Match m))))\n                          (normalized_n_primitive (a, b) f)", "by simp+"], ["", "subsection\\<open>Optimizing a match expression\\<close>"], ["", "text\\<open>Optimizes a match expression with a function that takes @{typ \"'b negation_type list\"}\n  and returns @{typ \"('b list \\<times> 'b list) option\"}.\n  The function should return @{const None} if the match expression cannot match.\n  It returns @{term \"Some (as_pos, as_neg)\"} where @{term as_pos} and @{term as_neg} are lists of\n  primitives. Positive and Negated.\n  The result is one match expression.\n\n  In contrast @{const normalize_primitive_extract} returns a list of match expression, to be read es their disjunction.\\<close>"], ["", "definition compress_normalize_primitive :: \"(('a \\<Rightarrow> bool) \\<times> ('a \\<Rightarrow> 'b)) \\<Rightarrow> ('b \\<Rightarrow> 'a) \\<Rightarrow>\n                                              ('b negation_type list \\<Rightarrow> ('b list \\<times> 'b list) option) \\<Rightarrow> \n                                              'a match_expr \\<Rightarrow> 'a match_expr option\" where \n    \"compress_normalize_primitive disc_sel C f m \\<equiv> (case primitive_extractor disc_sel m of (as, rst) \\<Rightarrow>\n      (map_option (\\<lambda>(as_pos, as_neg). MatchAnd\n                                       (alist_and' (NegPos_map C ((map Pos as_pos)@(map Neg as_neg))))\n                                       rst\n                  ) (f as)))\""], ["", "lemma compress_normalize_primitive_nnf: \"wf_disc_sel disc_sel C \\<Longrightarrow> \n      normalized_nnf_match m \\<Longrightarrow> compress_normalize_primitive disc_sel C f m = Some m' \\<Longrightarrow>\n    normalized_nnf_match m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_disc_sel disc_sel C; normalized_nnf_match m;\n     compress_normalize_primitive disc_sel C f m = Some m'\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match m'", "apply(case_tac \"primitive_extractor disc_sel m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_disc_sel disc_sel C; normalized_nnf_match m;\n        compress_normalize_primitive disc_sel C f m = Some m';\n        primitive_extractor disc_sel m = (a, b)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply(simp add: compress_normalize_primitive_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_disc_sel disc_sel C; normalized_nnf_match m;\n        \\<exists>aa ba.\n           f a = Some (aa, ba) \\<and>\n           MatchAnd (alist_and' (NegPos_map C (map Pos aa @ map Neg ba)))\n            b =\n           m';\n        primitive_extractor disc_sel m = (a, b)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>wf_disc_sel disc_sel C; normalized_nnf_match m;\n        primitive_extractor disc_sel m = (a, b); f a = Some (aa, ba);\n        m' =\n        MatchAnd (alist_and' (NegPos_map C (map Pos aa @ map Neg ba)))\n         b\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match\n                          (MatchAnd\n                            (alist_and'\n                              (NegPos_map C (map Pos aa @ map Neg ba)))\n                            b)", "apply (simp add: normalized_nnf_match_alist_and')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>wf_disc_sel disc_sel C; normalized_nnf_match m;\n        primitive_extractor disc_sel m = (a, b); f a = Some (aa, ba);\n        m' =\n        MatchAnd (alist_and' (NegPos_map C (map Pos aa @ map Neg ba)))\n         b\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match b", "apply(cases disc_sel, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>wf_disc_sel (ab, bb) C; normalized_nnf_match m;\n        primitive_extractor (ab, bb) m = (a, b); f a = Some (aa, ba);\n        m' =\n        MatchAnd (alist_and' (NegPos_map C (map Pos aa @ map Neg ba))) b;\n        disc_sel = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match b", "using primitive_extractor_correct(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized_nnf_match ?m; wf_disc_sel (?disc, ?sel) ?C;\n   primitive_extractor (?disc, ?sel) ?m = (?as, ?ms)\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?ms\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>wf_disc_sel (ab, bb) C; normalized_nnf_match m;\n        primitive_extractor (ab, bb) m = (a, b); f a = Some (aa, ba);\n        m' =\n        MatchAnd (alist_and' (NegPos_map C (map Pos aa @ map Neg ba))) b;\n        disc_sel = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match b", "by blast"], ["", "lemma compress_normalize_primitive_not_introduces_C:\n    assumes notdisc: \"\\<not> has_disc disc m\"\n        and wf: \"wf_disc_sel (disc,sel) C'\" (*C is allowed to be different from C'*)\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n        and f_preserves: \"\\<And>as_pos as_neg. f [] = Some (as_pos, as_neg) \\<Longrightarrow> as_pos = [] \\<and> as_neg = []\"\n     shows \"\\<not> has_disc disc m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m'", "obtain as ms where asms: \"primitive_extractor (disc, sel) m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m'", "from notdisc primitive_extractor_correct(4)[OF nm wf asms]"], ["proof (chain)\npicking this:\n  \\<not> has_disc disc m\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms", "have 1: \"\\<not> has_disc disc ms\""], ["proof (prove)\nusing this:\n  \\<not> has_disc disc m\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc ms", "by simp"], ["proof (state)\nthis:\n  \\<not> has_disc disc ms\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m'", "from notdisc primitive_extractor_correct(7)[OF nm wf asms]"], ["proof (chain)\npicking this:\n  \\<not> has_disc disc m\n  (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)", "have 2: \"as = [] \\<and> ms = m\""], ["proof (prove)\nusing this:\n  \\<not> has_disc disc m\n  (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n\ngoal (1 subgoal):\n 1. as = [] \\<and> ms = m", "by simp"], ["proof (state)\nthis:\n  as = [] \\<and> ms = m\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m'", "from 1 2 some"], ["proof (chain)\npicking this:\n  \\<not> has_disc disc ms\n  as = [] \\<and> ms = m\n  compress_normalize_primitive (disc, sel) C f m = Some m'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc ms\n  as = [] \\<and> ms = m\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc m'", "by(auto dest: f_preserves simp add: compress_normalize_primitive_def asms)"], ["proof (state)\nthis:\n  \\<not> has_disc disc m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compress_normalize_primitive_not_introduces_C_negated:\n    assumes notdisc: \"\\<not> has_disc_negated disc False m\"\n        and wf: \"wf_disc_sel (disc,sel) C\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n        and f_preserves: \"\\<And>as as_pos as_neg. f as = Some (as_pos, as_neg) \\<Longrightarrow> getNeg as = [] \\<Longrightarrow> as_neg = []\"\n     shows \"\\<not> has_disc_negated disc False m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "obtain as ms where asms: \"primitive_extractor (disc,sel) m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "from notdisc primitive_extractor_correct(6)[OF nm wf asms]"], ["proof (chain)\npicking this:\n  \\<not> has_disc_negated disc False m\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg ms", "have 1: \"\\<not> has_disc_negated disc False ms\""], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc False m\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg ms\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False ms", "by simp"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc False ms\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "from asms notdisc has_disc_negated_primitive_extractor[OF nm, where disc=disc and sel=sel]"], ["proof (chain)\npicking this:\n  primitive_extractor (disc, sel) m = (as, ms)\n  \\<not> has_disc_negated disc False m\n  has_disc_negated disc False m =\n  (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))", "have\n          \"\\<forall>a. Neg a \\<notin> set as\""], ["proof (prove)\nusing this:\n  primitive_extractor (disc, sel) m = (as, ms)\n  \\<not> has_disc_negated disc False m\n  has_disc_negated disc False m =\n  (\\<exists>a. Neg a \\<in> set (fst (primitive_extractor (disc, sel) m)))\n\ngoal (1 subgoal):\n 1. \\<forall>a. Neg a \\<notin> set as", "by(simp)"], ["proof (state)\nthis:\n  \\<forall>a. Neg a \\<notin> set as\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "hence \"getNeg as = []\""], ["proof (prove)\nusing this:\n  \\<forall>a. Neg a \\<notin> set as\n\ngoal (1 subgoal):\n 1. getNeg as = []", "by (meson NegPos_set(5) image_subset_iff last_in_set)"], ["proof (state)\nthis:\n  getNeg as = []\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "with f_preserves"], ["proof (chain)\npicking this:\n  \\<lbrakk>f ?as = Some (?as_pos, ?as_neg); getNeg ?as = []\\<rbrakk>\n  \\<Longrightarrow> ?as_neg = []\n  getNeg as = []", "have f_preserves': \"\\<And>as_pos as_neg. f as = Some (as_pos, as_neg) \\<Longrightarrow> as_neg = []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>f ?as = Some (?as_pos, ?as_neg); getNeg ?as = []\\<rbrakk>\n  \\<Longrightarrow> ?as_neg = []\n  getNeg as = []\n\ngoal (1 subgoal):\n 1. \\<And>as_pos as_neg.\n       f as = Some (as_pos, as_neg) \\<Longrightarrow> as_neg = []", "by simp"], ["proof (state)\nthis:\n  f as = Some (?as_pos, ?as_neg) \\<Longrightarrow> ?as_neg = []\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "from 1"], ["proof (chain)\npicking this:\n  \\<not> has_disc_negated disc False ms", "have \"\\<And> a b.\\<not> has_disc_negated disc False (MatchAnd (alist_and' (NegPos_map C (map Pos a))) ms)\""], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc False ms\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<not> has_disc_negated disc False\n               (MatchAnd (alist_and' (NegPos_map C (map Pos a))) ms)", "by(simp add: has_disc_negated_alist_and' NegPos_map_map_Pos negation_type_to_match_expr_simps)"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc False\n          (MatchAnd (alist_and' (NegPos_map C (map Pos ?a))) ms)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "with some"], ["proof (chain)\npicking this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n  \\<not> has_disc_negated disc False\n          (MatchAnd (alist_and' (NegPos_map C (map Pos ?a))) ms)", "show ?thesis"], ["proof (prove)\nusing this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n  \\<not> has_disc_negated disc False\n          (MatchAnd (alist_and' (NegPos_map C (map Pos ?a))) ms)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc False m'", "by(auto dest: f_preserves' simp add: compress_normalize_primitive_def asms)"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc False m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compress_normalize_primitive_Some:\n  assumes normalized: \"normalized_nnf_match m\"\n      and wf: \"wf_disc_sel (disc,sel) C\"\n      and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n      and f_correct: \"\\<And>as as_pos as_neg. f as = Some (as_pos, as_neg) \\<Longrightarrow>\n            matches \\<gamma> (alist_and (NegPos_map C ((map Pos as_pos)@(map Neg as_neg)))) a p \\<longleftrightarrow>\n            matches \\<gamma> (alist_and (NegPos_map C as)) a p\"\n    shows \"matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p", "using some"], ["proof (prove)\nusing this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p", "apply(simp add: compress_normalize_primitive_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case primitive_extractor (disc, sel) m of\n     (as, rst) \\<Rightarrow>\n       map_option\n        (\\<lambda>(as_pos, as_neg).\n            MatchAnd\n             (alist_and' (NegPos_map C (map Pos as_pos @ map Neg as_neg)))\n             rst)\n        (f as)) =\n    Some m' \\<Longrightarrow>\n    matches \\<gamma> m' a p = matches \\<gamma> m a p", "apply(case_tac \"primitive_extractor (disc,sel) m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(case primitive_extractor (disc, sel) m of\n                 (as, rst) \\<Rightarrow>\n                   map_option\n                    (\\<lambda>(as_pos, as_neg).\n                        MatchAnd\n                         (alist_and'\n                           (NegPos_map C (map Pos as_pos @ map Neg as_neg)))\n                         rst)\n                    (f as)) =\n                Some m';\n        primitive_extractor (disc, sel) m = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p", "apply(rename_tac as rst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>\\<exists>a b.\n                   f as = Some (a, b) \\<and>\n                   MatchAnd\n                    (alist_and' (NegPos_map C (map Pos a @ map Neg b)))\n                    rst =\n                   m';\n        primitive_extractor (disc, sel) m = (as, rst)\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p", "apply(drule primitive_extractor_correct(1)[OF normalized wf, where \\<gamma>=\\<gamma> and a=a and p=p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst.\n       \\<lbrakk>\\<exists>a b.\n                   f as = Some (a, b) \\<and>\n                   MatchAnd\n                    (alist_and' (NegPos_map C (map Pos a @ map Neg b)))\n                    rst =\n                   m';\n        (matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n         matches \\<gamma> rst a p) =\n        matches \\<gamma> m a p\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p", "apply(elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst aa b.\n       \\<lbrakk>(matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n                 matches \\<gamma> rst a p) =\n                matches \\<gamma> m a p;\n        f as = Some (aa, b);\n        MatchAnd (alist_and' (NegPos_map C (map Pos aa @ map Neg b))) rst =\n        m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p", "apply(drule f_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as rst aa b.\n       \\<lbrakk>(matches \\<gamma> (alist_and (NegPos_map C as)) a p \\<and>\n                 matches \\<gamma> rst a p) =\n                matches \\<gamma> m a p;\n        MatchAnd (alist_and' (NegPos_map C (map Pos aa @ map Neg b))) rst =\n        m';\n        matches \\<gamma> (alist_and (NegPos_map C (map Pos aa @ map Neg b)))\n         a p =\n        matches \\<gamma> (alist_and (NegPos_map C as)) a p\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p", "by (meson matches_alist_and_alist_and' bunch_of_lemmata_about_matches(1))"], ["", "lemma compress_normalize_primitive_None:\n  assumes normalized: \"normalized_nnf_match m\"\n      and wf: \"wf_disc_sel (disc,sel) C\"\n      and none: \"compress_normalize_primitive (disc,sel) C f m = None\"\n      and f_correct: \"\\<And>as. f as = None \\<Longrightarrow> \\<not> matches \\<gamma> (alist_and (NegPos_map C as)) a p\"\n    shows \"\\<not> matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "using none"], ["proof (prove)\nusing this:\n  compress_normalize_primitive (disc, sel) C f m = None\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "apply(simp add: compress_normalize_primitive_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case primitive_extractor (disc, sel) m of\n     (as, rst) \\<Rightarrow>\n       map_option\n        (\\<lambda>(as_pos, as_neg).\n            MatchAnd\n             (alist_and' (NegPos_map C (map Pos as_pos @ map Neg as_neg)))\n             rst)\n        (f as)) =\n    None \\<Longrightarrow>\n    \\<not> matches \\<gamma> m a p", "apply(case_tac \"primitive_extractor (disc, sel) m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(case primitive_extractor (disc, sel) m of\n                 (as, rst) \\<Rightarrow>\n                   map_option\n                    (\\<lambda>(as_pos, as_neg).\n                        MatchAnd\n                         (alist_and'\n                           (NegPos_map C (map Pos as_pos @ map Neg as_neg)))\n                         rst)\n                    (f as)) =\n                None;\n        primitive_extractor (disc, sel) m = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "apply(auto dest: primitive_extractor_correct(1)[OF assms(1) wf] f_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* only for arbitrary discs that do not match C*)"], ["", "lemma compress_normalize_primitive_hasdisc:\n    assumes am: \"\\<not> has_disc disc2 m\"\n        and wf: \"wf_disc_sel (disc,sel) C\"\n        and disc: \"(\\<forall>a. \\<not> disc2 (C a))\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n     shows \"normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "from compress_normalize_primitive_nnf[OF wf nm some]"], ["proof (chain)\npicking this:\n  normalized_nnf_match m'", "have goal1: \"normalized_nnf_match m'\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m'", "."], ["proof (state)\nthis:\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "obtain as ms where asms: \"primitive_extractor (disc, sel) m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "from am primitive_extractor_correct(4)[OF nm wf asms]"], ["proof (chain)\npicking this:\n  \\<not> has_disc disc2 m\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms", "have 1: \"\\<not> has_disc disc2 ms\""], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 m\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2 ms", "by simp"], ["proof (state)\nthis:\n  \\<not> has_disc disc2 ms\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "{"], ["proof (state)\nthis:\n  \\<not> has_disc disc2 ms\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "fix is_pos is_neg"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "from disc"], ["proof (chain)\npicking this:\n  \\<forall>a. \\<not> disc2 (C a)", "have x1: \"\\<not> has_disc disc2 (alist_and' (NegPos_map C (map Pos is_pos)))\""], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (C a)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2 (alist_and' (NegPos_map C (map Pos is_pos)))", "by(simp add: has_disc_alist_and' NegPos_map_map_Pos negation_type_to_match_expr_simps)"], ["proof (state)\nthis:\n  \\<not> has_disc disc2 (alist_and' (NegPos_map C (map Pos is_pos)))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "from disc"], ["proof (chain)\npicking this:\n  \\<forall>a. \\<not> disc2 (C a)", "have x2: \"\\<not> has_disc disc2 (alist_and' (NegPos_map C (map Neg is_neg)))\""], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (C a)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2 (alist_and' (NegPos_map C (map Neg is_neg)))", "by(simp add: has_disc_alist_and' NegPos_map_map_Neg negation_type_to_match_expr_simps)"], ["proof (state)\nthis:\n  \\<not> has_disc disc2 (alist_and' (NegPos_map C (map Neg is_neg)))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "from x1 x2"], ["proof (chain)\npicking this:\n  \\<not> has_disc disc2 (alist_and' (NegPos_map C (map Pos is_pos)))\n  \\<not> has_disc disc2 (alist_and' (NegPos_map C (map Neg is_neg)))", "have \"\\<not> has_disc disc2 (alist_and' (NegPos_map C (map Pos is_pos @ map Neg is_neg)))\""], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 (alist_and' (NegPos_map C (map Pos is_pos)))\n  \\<not> has_disc disc2 (alist_and' (NegPos_map C (map Neg is_neg)))\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2\n            (alist_and' (NegPos_map C (map Pos is_pos @ map Neg is_neg)))", "apply(simp add: NegPos_map_append has_disc_alist_and')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>set (NegPos_map C (map Pos is_pos)).\n                \\<not> has_disc disc2 (negation_type_to_match_expr a);\n     \\<forall>a\\<in>set (NegPos_map C (map Neg is_neg)).\n        \\<not> has_disc disc2 (negation_type_to_match_expr a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set\n(NegPos_map C (map Pos is_pos)) \\<union>\n                                     set (NegPos_map C (map Neg is_neg)).\n                         \\<not> has_disc disc2\n                                 (negation_type_to_match_expr a)", "by blast"], ["proof (state)\nthis:\n  \\<not> has_disc disc2\n          (alist_and' (NegPos_map C (map Pos is_pos @ map Neg is_neg)))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "}"], ["proof (state)\nthis:\n  \\<not> has_disc disc2\n          (alist_and' (NegPos_map C (map Pos ?is_pos2 @ map Neg ?is_neg2)))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "with some"], ["proof (chain)\npicking this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n  \\<not> has_disc disc2\n          (alist_and' (NegPos_map C (map Pos ?is_pos2 @ map Neg ?is_neg2)))", "have \"\\<not> has_disc disc2 m'\""], ["proof (prove)\nusing this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n  \\<not> has_disc disc2\n          (alist_and' (NegPos_map C (map Pos ?is_pos2 @ map Neg ?is_neg2)))\n\ngoal (1 subgoal):\n 1. \\<not> has_disc disc2 m'", "apply(simp add: compress_normalize_primitive_def asms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b.\n                f as = Some (a, b) \\<and>\n                MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b)))\n                 ms =\n                m';\n     \\<And>is_pos is_neg.\n        \\<not> has_disc disc2\n                (alist_and'\n                  (NegPos_map C (map Pos is_pos @ map Neg is_neg)))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc disc2 m'", "apply(elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>is_pos is_neg.\n                   \\<not> has_disc disc2\n                           (alist_and'\n                             (NegPos_map C\n                               (map Pos is_pos @ map Neg is_neg)));\n        f as = Some (a, b);\n        MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b))) ms =\n        m'\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "using 1"], ["proof (prove)\nusing this:\n  \\<not> has_disc disc2 ms\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>is_pos is_neg.\n                   \\<not> has_disc disc2\n                           (alist_and'\n                             (NegPos_map C\n                               (map Pos is_pos @ map Neg is_neg)));\n        f as = Some (a, b);\n        MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b))) ms =\n        m'\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc disc2 m'", "by fastforce"], ["proof (state)\nthis:\n  \\<not> has_disc disc2 m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "with goal1"], ["proof (chain)\npicking this:\n  normalized_nnf_match m'\n  \\<not> has_disc disc2 m'", "show ?thesis"], ["proof (prove)\nusing this:\n  normalized_nnf_match m'\n  \\<not> has_disc disc2 m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m' \\<and> \\<not> has_disc disc2 m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compress_normalize_primitive_hasdisc_negated:\n    assumes am: \"\\<not> has_disc_negated disc2 neg m\"\n        and wf: \"wf_disc_sel (disc,sel) C\"\n        and disc: \"(\\<forall>a. \\<not> disc2 (C a))\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n     shows \"normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "from compress_normalize_primitive_nnf[OF wf nm some]"], ["proof (chain)\npicking this:\n  normalized_nnf_match m'", "have goal1: \"normalized_nnf_match m'\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m'", "."], ["proof (state)\nthis:\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "obtain as ms where asms: \"primitive_extractor (disc, sel) m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "from am primitive_extractor_correct(6)[OF nm wf asms]"], ["proof (chain)\npicking this:\n  \\<not> has_disc_negated disc2 neg m\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg ms", "have 1: \"\\<not> has_disc_negated disc2 neg ms\""], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc2 neg m\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg ms\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc2 neg ms", "by simp"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc2 neg ms\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "{"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc2 neg ms\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "fix is_pos is_neg"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "from disc"], ["proof (chain)\npicking this:\n  \\<forall>a. \\<not> disc2 (C a)", "have x1: \"\\<not> has_disc_negated disc2 neg (alist_and' (NegPos_map C (map Pos is_pos)))\""], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (C a)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc2 neg\n            (alist_and' (NegPos_map C (map Pos is_pos)))", "by(simp add: has_disc_negated_alist_and' NegPos_map_map_Pos negation_type_to_match_expr_simps)"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Pos is_pos)))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "from disc"], ["proof (chain)\npicking this:\n  \\<forall>a. \\<not> disc2 (C a)", "have x2: \"\\<not> has_disc_negated disc2 neg (alist_and' (NegPos_map C (map Neg is_neg)))\""], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (C a)\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc2 neg\n            (alist_and' (NegPos_map C (map Neg is_neg)))", "by(simp add: has_disc_negated_alist_and' NegPos_map_map_Neg negation_type_to_match_expr_simps)"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Neg is_neg)))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "from x1 x2"], ["proof (chain)\npicking this:\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Pos is_pos)))\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Neg is_neg)))", "have \"\\<not> has_disc_negated disc2 neg (alist_and' (NegPos_map C (map Pos is_pos @ map Neg is_neg)))\""], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Pos is_pos)))\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Neg is_neg)))\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc2 neg\n            (alist_and' (NegPos_map C (map Pos is_pos @ map Neg is_neg)))", "apply(simp add: NegPos_map_append has_disc_negated_alist_and')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>set (NegPos_map C (map Pos is_pos)).\n                \\<not> has_disc_negated disc2 neg\n                        (negation_type_to_match_expr a);\n     \\<forall>a\\<in>set (NegPos_map C (map Neg is_neg)).\n        \\<not> has_disc_negated disc2 neg\n                (negation_type_to_match_expr a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set\n(NegPos_map C (map Pos is_pos)) \\<union>\n                                     set (NegPos_map C (map Neg is_neg)).\n                         \\<not> has_disc_negated disc2 neg\n                                 (negation_type_to_match_expr a)", "by blast"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Pos is_pos @ map Neg is_neg)))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "}"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Pos ?is_pos2 @ map Neg ?is_neg2)))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "with some"], ["proof (chain)\npicking this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Pos ?is_pos2 @ map Neg ?is_neg2)))", "have \"\\<not> has_disc_negated disc2 neg m'\""], ["proof (prove)\nusing this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n  \\<not> has_disc_negated disc2 neg\n          (alist_and' (NegPos_map C (map Pos ?is_pos2 @ map Neg ?is_neg2)))\n\ngoal (1 subgoal):\n 1. \\<not> has_disc_negated disc2 neg m'", "apply(simp add: compress_normalize_primitive_def asms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b.\n                f as = Some (a, b) \\<and>\n                MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b)))\n                 ms =\n                m';\n     \\<And>is_pos is_neg.\n        \\<not> has_disc_negated disc2 neg\n                (alist_and'\n                  (NegPos_map C (map Pos is_pos @ map Neg is_neg)))\\<rbrakk>\n    \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "apply(elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>is_pos is_neg.\n                   \\<not> has_disc_negated disc2 neg\n                           (alist_and'\n                             (NegPos_map C\n                               (map Pos is_pos @ map Neg is_neg)));\n        f as = Some (a, b);\n        MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b))) ms =\n        m'\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "using 1"], ["proof (prove)\nusing this:\n  \\<not> has_disc_negated disc2 neg ms\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>is_pos is_neg.\n                   \\<not> has_disc_negated disc2 neg\n                           (alist_and'\n                             (NegPos_map C\n                               (map Pos is_pos @ map Neg is_neg)));\n        f as = Some (a, b);\n        MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b))) ms =\n        m'\\<rbrakk>\n       \\<Longrightarrow> \\<not> has_disc_negated disc2 neg m'", "by fastforce"], ["proof (state)\nthis:\n  \\<not> has_disc_negated disc2 neg m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "with goal1"], ["proof (chain)\npicking this:\n  normalized_nnf_match m'\n  \\<not> has_disc_negated disc2 neg m'", "show ?thesis"], ["proof (prove)\nusing this:\n  normalized_nnf_match m'\n  \\<not> has_disc_negated disc2 neg m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m' \\<and> \\<not> has_disc_negated disc2 neg m'\n\ngoal:\nNo subgoals!", "qed"], ["", "thm normalize_primitive_extract_preserves_unrelated_normalized_n_primitive"], ["", "(*is similar*)"], ["", "lemma compress_normalize_primitve_preserves_normalized_n_primitive:\n    assumes am: \"normalized_n_primitive (disc2, sel2) P m\"\n        and wf: \"wf_disc_sel (disc,sel) C\"\n        and disc: \"(\\<forall>a. \\<not> disc2 (C a))\"\n        and nm: \"normalized_nnf_match m\"\n        and some: \"compress_normalize_primitive (disc,sel) C f m = Some m'\"\n     shows \"normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "from compress_normalize_primitive_nnf[OF wf nm some]"], ["proof (chain)\npicking this:\n  normalized_nnf_match m'", "have goal1: \"normalized_nnf_match m'\""], ["proof (prove)\nusing this:\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m'", "."], ["proof (state)\nthis:\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "obtain as ms where asms: \"primitive_extractor (disc, sel) m = (as, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as ms.\n        primitive_extractor (disc, sel) m = (as, ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (disc, sel) m = (as, ms)\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "from am primitive_extractor_correct[OF nm wf asms]"], ["proof (chain)\npicking this:\n  normalized_n_primitive (disc2, sel2) P m\n  (matches ?\\<gamma> (alist_and (NegPos_map C as)) ?a ?p \\<and>\n   matches ?\\<gamma> ms ?a ?p) =\n  matches ?\\<gamma> m ?a ?p\n  normalized_nnf_match ms\n  \\<not> has_disc disc ms\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) ?P m \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) ?P ms\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg ms\n  (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n  (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n  has_disc disc m \\<Longrightarrow> as \\<noteq> []", "have 1: \"normalized_n_primitive (disc2, sel2) P ms\""], ["proof (prove)\nusing this:\n  normalized_n_primitive (disc2, sel2) P m\n  (matches ?\\<gamma> (alist_and (NegPos_map C as)) ?a ?p \\<and>\n   matches ?\\<gamma> ms ?a ?p) =\n  matches ?\\<gamma> m ?a ?p\n  normalized_nnf_match ms\n  \\<not> has_disc disc ms\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 ms\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) ?P m \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) ?P ms\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg ms\n  (\\<not> has_disc disc m) = (as = [] \\<and> ms = m)\n  (\\<not> has_disc_negated disc False m) = (getNeg as = [])\n  has_disc disc m \\<Longrightarrow> as \\<noteq> []\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) P ms", "by fast"], ["proof (state)\nthis:\n  normalized_n_primitive (disc2, sel2) P ms\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "{"], ["proof (state)\nthis:\n  normalized_n_primitive (disc2, sel2) P ms\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "fix iss"], ["proof (state)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "from disc"], ["proof (chain)\npicking this:\n  \\<forall>a. \\<not> disc2 (C a)", "have \"normalized_n_primitive (disc2, sel2) P (alist_and (NegPos_map C iss))\""], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> disc2 (C a)\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) P (alist_and (NegPos_map C iss))", "apply(induction iss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>a. \\<not> disc2 (C a) \\<Longrightarrow>\n    normalized_n_primitive (disc2, sel2) P (alist_and (NegPos_map C []))\n 2. \\<And>a iss.\n       \\<lbrakk>\\<forall>a. \\<not> disc2 (C a) \\<Longrightarrow>\n                normalized_n_primitive (disc2, sel2) P\n                 (alist_and (NegPos_map C iss));\n        \\<forall>a. \\<not> disc2 (C a)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P\n                          (alist_and (NegPos_map C (a # iss)))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a iss.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) P\n                 (alist_and (NegPos_map C iss));\n        \\<forall>a. \\<not> disc2 (C a)\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P\n                          (alist_and (NegPos_map C (a # iss)))", "apply(rename_tac i iss, case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i iss x1.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) P\n                 (alist_and (NegPos_map C iss));\n        \\<forall>a. \\<not> disc2 (C a); i = Pos x1\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P\n                          (alist_and (NegPos_map C (i # iss)))\n 2. \\<And>i iss x2.\n       \\<lbrakk>normalized_n_primitive (disc2, sel2) P\n                 (alist_and (NegPos_map C iss));\n        \\<forall>a. \\<not> disc2 (C a); i = Neg x2\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P\n                          (alist_and (NegPos_map C (i # iss)))", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  normalized_n_primitive (disc2, sel2) P (alist_and (NegPos_map C iss))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "}"], ["proof (state)\nthis:\n  normalized_n_primitive (disc2, sel2) P (alist_and (NegPos_map C ?iss2))\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "with some"], ["proof (chain)\npicking this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n  normalized_n_primitive (disc2, sel2) P (alist_and (NegPos_map C ?iss2))", "have \"normalized_n_primitive (disc2, sel2) P m'\""], ["proof (prove)\nusing this:\n  compress_normalize_primitive (disc, sel) C f m = Some m'\n  normalized_n_primitive (disc2, sel2) P (alist_and (NegPos_map C ?iss2))\n\ngoal (1 subgoal):\n 1. normalized_n_primitive (disc2, sel2) P m'", "apply(simp add: compress_normalize_primitive_def asms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b.\n                f as = Some (a, b) \\<and>\n                MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b)))\n                 ms =\n                m';\n     \\<And>iss.\n        normalized_n_primitive (disc2, sel2) P\n         (alist_and (NegPos_map C iss))\\<rbrakk>\n    \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P m'", "apply(elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>iss.\n                   normalized_n_primitive (disc2, sel2) P\n                    (alist_and (NegPos_map C iss));\n        f as = Some (a, b);\n        MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b))) ms =\n        m'\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P m'", "using 1 normalized_n_primitive_alist_and' normalized_n_primitive_alist_and\n                 normalized_n_primitive.simps(4)"], ["proof (prove)\nusing this:\n  normalized_n_primitive (disc2, sel2) P ms\n  normalized_n_primitive ?disc_sel ?P (alist_and' ?as) =\n  (\\<forall>a\\<in>set ?as.\n      normalized_n_primitive ?disc_sel ?P (negation_type_to_match_expr a))\n  normalized_n_primitive ?disc_sel ?P (alist_and ?as) =\n  (\\<forall>a\\<in>set ?as.\n      normalized_n_primitive ?disc_sel ?P (negation_type_to_match_expr a))\n  normalized_n_primitive (?disc, ?sel) ?n (MatchAnd ?m1.0 ?m2.0) =\n  (normalized_n_primitive (?disc, ?sel) ?n ?m1.0 \\<and>\n   normalized_n_primitive (?disc, ?sel) ?n ?m2.0)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>iss.\n                   normalized_n_primitive (disc2, sel2) P\n                    (alist_and (NegPos_map C iss));\n        f as = Some (a, b);\n        MatchAnd (alist_and' (NegPos_map C (map Pos a @ map Neg b))) ms =\n        m'\\<rbrakk>\n       \\<Longrightarrow> normalized_n_primitive (disc2, sel2) P m'", "by blast"], ["proof (state)\nthis:\n  normalized_n_primitive (disc2, sel2) P m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "with goal1"], ["proof (chain)\npicking this:\n  normalized_nnf_match m'\n  normalized_n_primitive (disc2, sel2) P m'", "show ?thesis"], ["proof (prove)\nusing this:\n  normalized_nnf_match m'\n  normalized_n_primitive (disc2, sel2) P m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m' \\<and> normalized_n_primitive (disc2, sel2) P m'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Processing a list of normalization functions\\<close>"], ["", "fun compress_normalize_primitive_monad :: \"('a match_expr \\<Rightarrow> 'a match_expr option) list \\<Rightarrow> 'a match_expr \\<Rightarrow> 'a match_expr option\" where\n  \"compress_normalize_primitive_monad [] m = Some m\" |\n  \"compress_normalize_primitive_monad (f#fs) m = (case f m of None \\<Rightarrow> None\n                                                           |  Some m' \\<Rightarrow> compress_normalize_primitive_monad fs m')\""], ["", "lemma compress_normalize_primitive_monad: \n      assumes \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n          and \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> normalized_nnf_match m'\"\n          and \"normalized_nnf_match m\"\n          and \"(compress_normalize_primitive_monad fs m) = Some m'\"\n      shows \"matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p\" (is ?goal1)\n        and \"normalized_nnf_match m'\"              (is ?goal2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p &&&\n    normalized_nnf_match m'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p\n 2. normalized_nnf_match m'", "(*everything in one big induction*)"], ["proof (state)\ngoal (2 subgoals):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p\n 2. normalized_nnf_match m'", "have goals: \"?goal1 \\<and> ?goal2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad fs m = Some m'\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'", "proof(induction fs arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<And>f m m'.\n                   \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n                    f m = Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad [] m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'\n 2. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p \\<and>\n                                     normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad [] m = Some m'\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<And>f m m'.\n                   \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n                    f m = Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad [] m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'\n 2. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p \\<and>\n                                     normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad [] m = Some m'\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'", "by simp"], ["proof (state)\nthis:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p \\<and>\n                                     normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p \\<and>\n                                     normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "case (Cons f fs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>f m m'.\n              \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n               f m = Some m'\\<rbrakk>\n              \\<Longrightarrow> matches \\<gamma> m' a p =\n                                matches \\<gamma> m a p;\n   \\<And>f m m'.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n       f m = Some m'\\<rbrakk>\n      \\<Longrightarrow> normalized_nnf_match m';\n   normalized_nnf_match ?m;\n   compress_normalize_primitive_monad fs ?m = Some m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> ?m a p \\<and>\n                    normalized_nnf_match m'\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad (f # fs) m = Some m'\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p \\<and>\n                                     normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p", "have IH_prem1:\n        \"(\\<And>f m m'. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n\ngoal (1 subgoal):\n 1. \\<And>f m m'.\n       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n        f m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p \\<and>\n                                     normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'", "have IH_prem2:\n        \"(\\<And>f m m'. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> normalized_nnf_match m')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (1 subgoal):\n 1. \\<And>f m m'.\n       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n        f m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p \\<and>\n                                     normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "from Cons.IH IH_prem1 IH_prem2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>f m m'.\n              \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n               f m = Some m'\\<rbrakk>\n              \\<Longrightarrow> matches \\<gamma> m' a p =\n                                matches \\<gamma> m a p;\n   \\<And>f m m'.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n       f m = Some m'\\<rbrakk>\n      \\<Longrightarrow> normalized_nnf_match m';\n   normalized_nnf_match ?m;\n   compress_normalize_primitive_monad fs ?m = Some m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> ?m a p \\<and>\n                    normalized_nnf_match m'\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'", "have\n        IH: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> compress_normalize_primitive_monad fs m = Some m' \\<Longrightarrow>\n                  (matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p) \\<and> ?goal2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>f m m'.\n              \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n               f m = Some m'\\<rbrakk>\n              \\<Longrightarrow> matches \\<gamma> m' a p =\n                                matches \\<gamma> m a p;\n   \\<And>f m m'.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n       f m = Some m'\\<rbrakk>\n      \\<Longrightarrow> normalized_nnf_match m';\n   normalized_nnf_match ?m;\n   compress_normalize_primitive_monad fs ?m = Some m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> ?m a p \\<and>\n                    normalized_nnf_match m'\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>normalized_nnf_match m;\n        compress_normalize_primitive_monad fs m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match ?m;\n   compress_normalize_primitive_monad fs ?m = Some m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> ?m a p \\<and>\n                    normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p \\<and>\n                                     normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p =\n                         matches \\<gamma> m a p \\<and>\n                         normalized_nnf_match m'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'", "proof(cases \"f m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f m = None \\<Longrightarrow>\n    matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'\n 2. \\<And>aa.\n       f m = Some aa \\<Longrightarrow>\n       matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n       normalized_nnf_match m'", "case None"], ["proof (state)\nthis:\n  f m = None\n\ngoal (2 subgoals):\n 1. f m = None \\<Longrightarrow>\n    matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'\n 2. \\<And>aa.\n       f m = Some aa \\<Longrightarrow>\n       matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n       normalized_nnf_match m'", "thus ?thesis"], ["proof (prove)\nusing this:\n  f m = None\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'", "using Cons.prems"], ["proof (prove)\nusing this:\n  f m = None\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad (f # fs) m = Some m'\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'", "by auto"], ["proof (state)\nthis:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       f m = Some aa \\<Longrightarrow>\n       matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n       normalized_nnf_match m'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       f m = Some aa \\<Longrightarrow>\n       matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n       normalized_nnf_match m'", "case(Some m'')"], ["proof (state)\nthis:\n  f m = Some m''\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       f m = Some aa \\<Longrightarrow>\n       matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n       normalized_nnf_match m'", "from Some Cons.prems(1)[of f] Cons.prems(3)"], ["proof (chain)\npicking this:\n  f m = Some m''\n  \\<lbrakk>f \\<in> set (f # fs); normalized_nnf_match ?m;\n   f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  normalized_nnf_match m", "have 1: \"matches \\<gamma> m'' a p = matches \\<gamma> m a p\""], ["proof (prove)\nusing this:\n  f m = Some m''\n  \\<lbrakk>f \\<in> set (f # fs); normalized_nnf_match ?m;\n   f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  normalized_nnf_match m\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m'' a p = matches \\<gamma> m a p", "by simp"], ["proof (state)\nthis:\n  matches \\<gamma> m'' a p = matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       f m = Some aa \\<Longrightarrow>\n       matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n       normalized_nnf_match m'", "from Some Cons.prems(2)[of f] Cons.prems(3)"], ["proof (chain)\npicking this:\n  f m = Some m''\n  \\<lbrakk>f \\<in> set (f # fs); normalized_nnf_match ?m;\n   f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m", "have 2: \"normalized_nnf_match m''\""], ["proof (prove)\nusing this:\n  f m = Some m''\n  \\<lbrakk>f \\<in> set (f # fs); normalized_nnf_match ?m;\n   f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m''", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m''\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       f m = Some aa \\<Longrightarrow>\n       matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n       normalized_nnf_match m'", "from Some"], ["proof (chain)\npicking this:\n  f m = Some m''", "have \"compress_normalize_primitive_monad (f # fs) m = compress_normalize_primitive_monad fs m''\""], ["proof (prove)\nusing this:\n  f m = Some m''\n\ngoal (1 subgoal):\n 1. compress_normalize_primitive_monad (f # fs) m =\n    compress_normalize_primitive_monad fs m''", "by simp"], ["proof (state)\nthis:\n  compress_normalize_primitive_monad (f # fs) m =\n  compress_normalize_primitive_monad fs m''\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       f m = Some aa \\<Longrightarrow>\n       matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n       normalized_nnf_match m'", "thus ?thesis"], ["proof (prove)\nusing this:\n  compress_normalize_primitive_monad (f # fs) m =\n  compress_normalize_primitive_monad fs m''\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'", "using Cons.prems(4) IH 1 2"], ["proof (prove)\nusing this:\n  compress_normalize_primitive_monad (f # fs) m =\n  compress_normalize_primitive_monad fs m''\n  compress_normalize_primitive_monad (f # fs) m = Some m'\n  \\<lbrakk>normalized_nnf_match ?m;\n   compress_normalize_primitive_monad fs ?m = Some m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> ?m a p \\<and>\n                    normalized_nnf_match m'\n  matches \\<gamma> m'' a p = matches \\<gamma> m a p\n  normalized_nnf_match m''\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n    normalized_nnf_match m'", "by auto"], ["proof (state)\nthis:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'\n\ngoal (2 subgoals):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p\n 2. normalized_nnf_match m'", "from goals"], ["proof (chain)\npicking this:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'", "show ?goal1"], ["proof (prove)\nusing this:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m' a p = matches \\<gamma> m a p", "by simp"], ["proof (state)\nthis:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m'", "from goals"], ["proof (chain)\npicking this:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'", "show ?goal2"], ["proof (prove)\nusing this:\n  matches \\<gamma> m' a p = matches \\<gamma> m a p \\<and>\n  normalized_nnf_match m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m'", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m'\n\ngoal:\nNo subgoals!", "qed"], ["", "(*proof is a bit sledgehammered*)"], ["", "lemma compress_normalize_primitive_monad_None: \n      assumes \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> matches \\<gamma> m' a p \\<longleftrightarrow> matches \\<gamma> m a p\"\n          and \"\\<And>m f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = None \\<Longrightarrow> \\<not> matches \\<gamma> m a p\"\n          and \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> normalized_nnf_match m'\"\n          and \"normalized_nnf_match m\"\n          and \"(compress_normalize_primitive_monad fs m) = None\"\n      shows \"\\<not> matches \\<gamma> m a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m; ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad fs m = None\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "proof(induction fs arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<And>f m m'.\n                   \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n                    f m = Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad [] m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p\n 2. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m; ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad [] m = None\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<And>f m m'.\n                   \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n                    f m = Some m'\\<rbrakk>\n                   \\<Longrightarrow> matches \\<gamma> m' a p =\n                                     matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad [] m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p\n 2. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m; ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad [] m = None\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "by simp"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "case (Cons f fs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>f m m'.\n              \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n               f m = Some m'\\<rbrakk>\n              \\<Longrightarrow> matches \\<gamma> m' a p =\n                                matches \\<gamma> m a p;\n   \\<And>f m.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; f m = None\\<rbrakk>\n      \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n   \\<And>f m m'.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n       f m = Some m'\\<rbrakk>\n      \\<Longrightarrow> normalized_nnf_match m';\n   normalized_nnf_match ?m;\n   compress_normalize_primitive_monad fs ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n  compress_normalize_primitive_monad (f # fs) m = None\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p", "have IH_prem1:\n        \"(\\<And>f m m'. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n\ngoal (1 subgoal):\n 1. \\<And>f m m'.\n       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n        f m = Some m'\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> m' a p = matches \\<gamma> m a p", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p", "have IH_prem2:\n        \"(\\<And>f m m'. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = None \\<Longrightarrow> \\<not> matches \\<gamma> m a p)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n\ngoal (1 subgoal):\n 1. \\<And>f m m'.\n       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; f m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m; ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "from Cons.prems(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'", "have IH_prem3:\n        \"(\\<And>f m m'. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> normalized_nnf_match m')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (1 subgoal):\n 1. \\<And>f m m'.\n       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n        f m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m'", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?f1 \\<in> set fs; normalized_nnf_match ?m1;\n   ?f1 ?m1 = Some ?m'1\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'1\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "from Cons.IH IH_prem1 IH_prem2 IH_prem3"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>f m m'.\n              \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n               f m = Some m'\\<rbrakk>\n              \\<Longrightarrow> matches \\<gamma> m' a p =\n                                matches \\<gamma> m a p;\n   \\<And>f m.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; f m = None\\<rbrakk>\n      \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n   \\<And>f m m'.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n       f m = Some m'\\<rbrakk>\n      \\<Longrightarrow> normalized_nnf_match m';\n   normalized_nnf_match ?m;\n   compress_normalize_primitive_monad fs ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m; ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f1 \\<in> set fs; normalized_nnf_match ?m1;\n   ?f1 ?m1 = Some ?m'1\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'1", "have\n        IH: \"\\<And>m. normalized_nnf_match m \\<Longrightarrow> compress_normalize_primitive_monad fs m = None \\<Longrightarrow> \\<not>  matches \\<gamma> m a p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>f m m'.\n              \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n               f m = Some m'\\<rbrakk>\n              \\<Longrightarrow> matches \\<gamma> m' a p =\n                                matches \\<gamma> m a p;\n   \\<And>f m.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; f m = None\\<rbrakk>\n      \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n   \\<And>f m m'.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n       f m = Some m'\\<rbrakk>\n      \\<Longrightarrow> normalized_nnf_match m';\n   normalized_nnf_match ?m;\n   compress_normalize_primitive_monad fs ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m; ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f1 \\<in> set fs; normalized_nnf_match ?m1;\n   ?f1 ?m1 = Some ?m'1\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'1\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>normalized_nnf_match m;\n        compress_normalize_primitive_monad fs m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>normalized_nnf_match ?m1;\n   compress_normalize_primitive_monad fs ?m1 = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m1 a p\n\ngoal (1 subgoal):\n 1. \\<And>aa fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> matches \\<gamma> m' a p =\n           matches \\<gamma> m a p;\n                    \\<And>f m.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = None\\<rbrakk>\n                       \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> normalized_nnf_match m';\n                    normalized_nnf_match m;\n                    compress_normalize_primitive_monad fs m = None\\<rbrakk>\n                   \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> matches \\<gamma> m' a p =\n                             matches \\<gamma> m a p;\n        \\<And>f m.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = None\\<rbrakk>\n           \\<Longrightarrow> \\<not> matches \\<gamma> m a p;\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (aa # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        normalized_nnf_match m;\n        compress_normalize_primitive_monad (aa # fs) m = None\\<rbrakk>\n       \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "proof(cases \"f m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f m = None \\<Longrightarrow> \\<not> matches \\<gamma> m a p\n 2. \\<And>aa. f m = Some aa \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "case None"], ["proof (state)\nthis:\n  f m = None\n\ngoal (2 subgoals):\n 1. f m = None \\<Longrightarrow> \\<not> matches \\<gamma> m a p\n 2. \\<And>aa. f m = Some aa \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "thus ?thesis"], ["proof (prove)\nusing this:\n  f m = None\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "using Cons.prems(4) Cons.prems(2) Cons.prems(3)"], ["proof (prove)\nusing this:\n  f m = None\n  normalized_nnf_match m\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m a p\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "by auto"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m a p\n\ngoal (1 subgoal):\n 1. \\<And>aa. f m = Some aa \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa. f m = Some aa \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "case(Some m'')"], ["proof (state)\nthis:\n  f m = Some m''\n\ngoal (1 subgoal):\n 1. \\<And>aa. f m = Some aa \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "from Some Cons.prems(3)[of f] Cons.prems(4)"], ["proof (chain)\npicking this:\n  f m = Some m''\n  \\<lbrakk>f \\<in> set (f # fs); normalized_nnf_match ?m;\n   f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m", "have 2: \"normalized_nnf_match m''\""], ["proof (prove)\nusing this:\n  f m = Some m''\n  \\<lbrakk>f \\<in> set (f # fs); normalized_nnf_match ?m;\n   f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  normalized_nnf_match m\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m''", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m''\n\ngoal (1 subgoal):\n 1. \\<And>aa. f m = Some aa \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "from Some"], ["proof (chain)\npicking this:\n  f m = Some m''", "have \"compress_normalize_primitive_monad (f # fs) m = compress_normalize_primitive_monad fs m''\""], ["proof (prove)\nusing this:\n  f m = Some m''\n\ngoal (1 subgoal):\n 1. compress_normalize_primitive_monad (f # fs) m =\n    compress_normalize_primitive_monad fs m''", "by simp"], ["proof (state)\nthis:\n  compress_normalize_primitive_monad (f # fs) m =\n  compress_normalize_primitive_monad fs m''\n\ngoal (1 subgoal):\n 1. \\<And>aa. f m = Some aa \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "hence \"\\<not> matches \\<gamma> m'' a p\""], ["proof (prove)\nusing this:\n  compress_normalize_primitive_monad (f # fs) m =\n  compress_normalize_primitive_monad fs m''\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m'' a p", "using Cons.prems(5) IH 2"], ["proof (prove)\nusing this:\n  compress_normalize_primitive_monad (f # fs) m =\n  compress_normalize_primitive_monad fs m''\n  compress_normalize_primitive_monad (f # fs) m = None\n  \\<lbrakk>normalized_nnf_match ?m1;\n   compress_normalize_primitive_monad fs ?m1 = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> matches \\<gamma> ?m1 a p\n  normalized_nnf_match m''\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m'' a p", "by simp"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m'' a p\n\ngoal (1 subgoal):\n 1. \\<And>aa. f m = Some aa \\<Longrightarrow> \\<not> matches \\<gamma> m a p", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m'' a p\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "using Cons.prems(1) Cons.prems(4) Some"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m'' a p\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> matches \\<gamma> ?m' a p = matches \\<gamma> ?m a p\n  normalized_nnf_match m\n  f m = Some m''\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m a p", "by auto"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m a p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compress_normalize_primitive_monad_preserves:\n      assumes \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> normalized_nnf_match m'\"\n          and \"\\<And>m m' f. f \\<in> set fs \\<Longrightarrow> normalized_nnf_match m \\<Longrightarrow> P m \\<Longrightarrow> f m = Some m' \\<Longrightarrow> P m'\"\n          and \"normalized_nnf_match m\"\n          and \"P m\"\n          and \"(compress_normalize_primitive_monad fs m) = Some m'\"\n      shows \"normalized_nnf_match m' \\<and> P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> P m'", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  \\<lbrakk>?f \\<in> set fs; normalized_nnf_match ?m; P ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> P ?m'\n  normalized_nnf_match m\n  P m\n  compress_normalize_primitive_monad fs m = Some m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> P m'", "proof(induction fs arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<And>f m m'.\n                   \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n                    f m = Some m'\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set []; normalized_nnf_match m; P m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> P m';\n        normalized_nnf_match m; P m;\n        compress_normalize_primitive_monad [] m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'\n 2. \\<And>a fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> normalized_nnf_match m';\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; P m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> P m';\n                    normalized_nnf_match m; P m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match m' \\<and> P m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m; P m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> P m';\n        normalized_nnf_match m; P m;\n        compress_normalize_primitive_monad (a # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m; P ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> P ?m'\n  normalized_nnf_match m\n  P m\n  compress_normalize_primitive_monad [] m = Some m'\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<And>f m m'.\n                   \\<lbrakk>f \\<in> set []; normalized_nnf_match m;\n                    f m = Some m'\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set []; normalized_nnf_match m; P m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> P m';\n        normalized_nnf_match m; P m;\n        compress_normalize_primitive_monad [] m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'\n 2. \\<And>a fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> normalized_nnf_match m';\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; P m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> P m';\n                    normalized_nnf_match m; P m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match m' \\<and> P m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m; P m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> P m';\n        normalized_nnf_match m; P m;\n        compress_normalize_primitive_monad (a # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  \\<lbrakk>?f \\<in> set []; normalized_nnf_match ?m; P ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> P ?m'\n  normalized_nnf_match m\n  P m\n  compress_normalize_primitive_monad [] m = Some m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> P m'", "by simp"], ["proof (state)\nthis:\n  normalized_nnf_match m' \\<and> P m'\n\ngoal (1 subgoal):\n 1. \\<And>a fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> normalized_nnf_match m';\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; P m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> P m';\n                    normalized_nnf_match m; P m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match m' \\<and> P m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m; P m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> P m';\n        normalized_nnf_match m; P m;\n        compress_normalize_primitive_monad (a # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> normalized_nnf_match m';\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; P m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> P m';\n                    normalized_nnf_match m; P m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match m' \\<and> P m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m; P m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> P m';\n        normalized_nnf_match m; P m;\n        compress_normalize_primitive_monad (a # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'", "case (Cons f fs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>f m m'.\n              \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n               f m = Some m'\\<rbrakk>\n              \\<Longrightarrow> normalized_nnf_match m';\n   \\<And>f m m'.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; P m;\n       f m = Some m'\\<rbrakk>\n      \\<Longrightarrow> P m';\n   normalized_nnf_match ?m; P ?m;\n   compress_normalize_primitive_monad fs ?m = Some m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m; P ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> P ?m'\n  normalized_nnf_match m\n  P m\n  compress_normalize_primitive_monad (f # fs) m = Some m'\n\ngoal (1 subgoal):\n 1. \\<And>a fs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>\\<And>f m m'.\n                               \\<lbrakk>f \\<in> set fs;\n                                normalized_nnf_match m;\n                                f m = Some m'\\<rbrakk>\n                               \\<Longrightarrow> normalized_nnf_match m';\n                    \\<And>f m m'.\n                       \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; P m;\n                        f m = Some m'\\<rbrakk>\n                       \\<Longrightarrow> P m';\n                    normalized_nnf_match m; P m;\n                    compress_normalize_primitive_monad fs m =\n                    Some m'\\<rbrakk>\n                   \\<Longrightarrow> normalized_nnf_match m' \\<and> P m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> normalized_nnf_match m';\n        \\<And>f m m'.\n           \\<lbrakk>f \\<in> set (a # fs); normalized_nnf_match m; P m;\n            f m = Some m'\\<rbrakk>\n           \\<Longrightarrow> P m';\n        normalized_nnf_match m; P m;\n        compress_normalize_primitive_monad (a # fs) m = Some m'\\<rbrakk>\n       \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>f m m'.\n              \\<lbrakk>f \\<in> set fs; normalized_nnf_match m;\n               f m = Some m'\\<rbrakk>\n              \\<Longrightarrow> normalized_nnf_match m';\n   \\<And>f m m'.\n      \\<lbrakk>f \\<in> set fs; normalized_nnf_match m; P m;\n       f m = Some m'\\<rbrakk>\n      \\<Longrightarrow> P m';\n   normalized_nnf_match ?m; P ?m;\n   compress_normalize_primitive_monad fs ?m = Some m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match m' \\<and> P m'\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> normalized_nnf_match ?m'\n  \\<lbrakk>?f \\<in> set (f # fs); normalized_nnf_match ?m; P ?m;\n   ?f ?m = Some ?m'\\<rbrakk>\n  \\<Longrightarrow> P ?m'\n  normalized_nnf_match m\n  P m\n  compress_normalize_primitive_monad (f # fs) m = Some m'\n\ngoal (1 subgoal):\n 1. normalized_nnf_match m' \\<and> P m'", "by(simp split: option.split_asm) blast"], ["proof (state)\nthis:\n  normalized_nnf_match m' \\<and> P m'\n\ngoal:\nNo subgoals!", "(*1s*)"], ["proof (state)\nthis:\n  normalized_nnf_match m' \\<and> P m'\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: move to generic place and use? ? ? *)"], ["", "datatype 'a match_compress = CannotMatch | MatchesAll | MatchExpr 'a"], ["", "end"]]}