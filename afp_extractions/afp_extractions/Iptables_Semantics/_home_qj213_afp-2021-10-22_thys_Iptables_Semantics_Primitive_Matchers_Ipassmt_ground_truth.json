{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/Ipassmt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma[code_unfold]: \"ipassmt_sanity_nowildcards (map_of ipassmt) \\<longleftrightarrow> (\\<forall> iface \\<in> fst` set ipassmt. \\<not> iface_is_wildcard iface)\"", "lemma ipassmt_sanity_nowildcards_match_iface:\n      \"ipassmt_sanity_nowildcards ipassmt \\<Longrightarrow>\n       ipassmt (Iface ifce2) = None \\<Longrightarrow>\n       ipassmt ifce = Some a \\<Longrightarrow>\n       \\<not> match_iface ifce ifce2\"", "lemma[code_unfold]: \"ipassmt_sanity_disjoint (map_of ipassmt) \\<longleftrightarrow>\n    (let Is = fst` set ipassmt in \n      (\\<forall> i1 \\<in> Is. \\<forall> i2 \\<in> Is. i1 \\<noteq> i2 \\<longrightarrow> wordinterval_empty (wordinterval_intersection (l2wi (map ipcidr_to_interval (the ((map_of ipassmt) i1))))  (l2wi (map ipcidr_to_interval (the ((map_of ipassmt) i2)))))))\"", "lemma[code_unfold]: \"ipassmt_sanity_complete ipassmt \\<longleftrightarrow> distinct (map fst ipassmt) \\<and> (let range = map snd ipassmt in \n        wordinterval_eq (wordinterval_Union (map (l2wi \\<circ> (map ipcidr_to_interval)) range)) wordinterval_UNIV\n        )\"", "lemma \"set (collect_ifaces rs) = set (collect_ifaces' rs)\"", "lemma[code]: \"ipassmt_sanity_defined rs ipassmt \\<longleftrightarrow> (\\<forall> iface \\<in> set (collect_ifaces rs). ipassmt iface \\<noteq> None)\"", "lemma \"ipassmt_sanity_defined [\n         Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (Match (IIface (Iface ''eth1.1017'')))) action.Accept,\n         Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (Match (IIface (ifaceAny)))) action.Accept,\n         Rule MatchAny action.Drop]\n             (map_of [(Iface ''eth1.1017'', [(ipv4addr_of_dotdecimal (131,159,14,240), 28)])])\"", "lemma ipassmt_ignore_wildcard_le: \"ipassmt_ignore_wildcard ipassmt \\<subseteq>\\<^sub>m ipassmt\"", "lemma \"distinct (map fst ipassmt) \\<Longrightarrow>\n    map_of (ipassmt_ignore_wildcard_list ipassmt) = ipassmt_ignore_wildcard (map_of ipassmt)\"", "lemma dom_ipassmt_ignore_wildcard:\n    \"i\\<in>dom (ipassmt_ignore_wildcard ipassmt) \\<longleftrightarrow> i \\<in> dom ipassmt \\<and> ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV\"", "lemma ipassmt_ignore_wildcard_the:\n    \"ipassmt i = Some ips \\<Longrightarrow> ipcidr_union_set (set ips) \\<noteq> UNIV \\<Longrightarrow> (the (ipassmt_ignore_wildcard ipassmt i)) = ips\"\n    \"ipassmt_ignore_wildcard ipassmt i = Some ips \\<Longrightarrow> the (ipassmt i) = ips\"\n    \"ipassmt_ignore_wildcard ipassmt i = Some ips \\<Longrightarrow> ipcidr_union_set (set ips) \\<noteq> UNIV\"", "lemma ipassmt_sanity_disjoint_ignore_wildcards:\n        \"ipassmt_sanity_disjoint (ipassmt_ignore_wildcard ipassmt) \\<longleftrightarrow>\n         (\\<forall>i1\\<in>dom ipassmt.\n          \\<forall>i2\\<in>dom ipassmt.\n            ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n            ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n            i1 \\<noteq> i2 \n            \\<longrightarrow> ipcidr_union_set (set (the (ipassmt i1))) \\<inter> ipcidr_union_set (set (the (ipassmt i2))) = {})\"", "lemma ipassmt_sanity_nowildcards_ignore_wildcardD:\n    \"ipassmt_sanity_nowildcards ipassmt \\<Longrightarrow> ipassmt_sanity_nowildcards (ipassmt_ignore_wildcard ipassmt)\"", "lemma ipassmt_disjoint_nonempty_inj:\n     assumes ipassmt_disjoint: \"ipassmt_sanity_disjoint ipassmt\"\n        and ifce: \"ipassmt ifce = Some i_ips\"\n        and a: \"ipcidr_union_set (set i_ips) \\<noteq> {}\"\n        and k: \"ipassmt k = Some i_ips\"\n     shows \"k = ifce\"", "lemma ipassmt_ignore_wildcard_None_Some:\n    \"ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> ipassmt ifce = Some ips \\<Longrightarrow> ipcidr_union_set (set ips) = UNIV\"", "lemma ipassmt_disjoint_ignore_wildcard_nonempty_inj:\n     assumes ipassmt_disjoint: \"ipassmt_sanity_disjoint (ipassmt_ignore_wildcard ipassmt)\"\n        and ifce: \"ipassmt ifce = Some i_ips\"\n        and a: \"ipcidr_union_set (set i_ips) \\<noteq> {}\"\n        and k: \"(ipassmt_ignore_wildcard ipassmt) k = Some i_ips\"\n     shows \"k = ifce\"", "lemma ipassmt_disjoint_inj_k: \n     assumes ipassmt_disjoint: \"ipassmt_sanity_disjoint ipassmt\"\n        and ifce: \"ipassmt ifce = Some ips\"\n        and k: \"ipassmt k = Some ips'\"\n        and a: \"p \\<in> ipcidr_union_set (set ips)\"\n        and b: \"p \\<in> ipcidr_union_set (set ips')\"\n     shows \"k = ifce\"", "lemma ipassmt_disjoint_matcheq_iifce_srcip:\n        assumes ipassmt_nowild: \"ipassmt_sanity_nowildcards ipassmt\"\n            and ipassmt_disjoint: \"ipassmt_sanity_disjoint ipassmt\"\n            and ifce: \"ipassmt ifce = Some i_ips\"\n            and p_ifce: \"ipassmt (Iface (p_iiface p)) = Some p_ips \\<and> p_src p \\<in> ipcidr_union_set (set p_ips)\"\n        shows   \"match_iface ifce (p_iiface p) \\<longleftrightarrow> p_src p \\<in> ipcidr_union_set (set i_ips)\"", "lemma ipassmt_diff_ifce_equal: \"(ifce, [], []) \\<in> set (ipassmt_diff ipassmt1 ipassmt2)  \\<Longrightarrow>\n         ifce \\<in> dom (map_of ipassmt1) \\<Longrightarrow> ifce \\<in> dom (map_of ipassmt2) \\<Longrightarrow>\n           ipcidr_union_set (set (the ((map_of ipassmt1) ifce))) =\n           ipcidr_union_set (set (the ((map_of ipassmt2) ifce)))\"", "lemma ipcidr_union_cidr_split[simp]: \"ipcidr_union_set (set (cidr_split a)) = wordinterval_to_set a\"", "lemma \n    defines \"assmt as ifce \\<equiv> ipcidr_union_set (set (the ((map_of as ifce))))\"\n    assumes diffs: \"(ifce, d1, d2) \\<in> set (ipassmt_diff ipassmt1 ipassmt2)\"\n        and  doms: \"ifce \\<in> dom (map_of ipassmt1)\" \"ifce \\<in> dom (map_of ipassmt2)\"\n    shows \"ipcidr_union_set (set d1) = assmt ipassmt1 ifce - assmt ipassmt2 ifce\"\n          \"ipcidr_union_set (set d2) = assmt ipassmt2 ifce - assmt ipassmt1 ifce\"", "lemma \"ipassmt_diff (ipassmt_generic_ipv4 @ [(Iface ''a'', [(4,30)])])\n                       (ipassmt_generic_ipv4 @ [(Iface ''a'', [(6,32), (0,30)]), (Iface ''b'', [(42,32)])]) =\n    [(Iface ''lo'', [], []),\n     (Iface ''a'', [(4, 31),(7, 32)],\n                   [(0, 30)]\n     ),\n     (Iface ''b'', [], [(42, 32)])]\""], "translations": [["", "lemma[code_unfold]: \"ipassmt_sanity_nowildcards (map_of ipassmt) \\<longleftrightarrow> (\\<forall> iface \\<in> fst` set ipassmt. \\<not> iface_is_wildcard iface)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_sanity_nowildcards (map_of ipassmt) =\n    (\\<forall>iface\\<in>fst ` set ipassmt. \\<not> iface_is_wildcard iface)", "by(simp add: ipassmt_sanity_nowildcards_def Map.dom_map_of_conv_image_fst)"], ["", "lemma ipassmt_sanity_nowildcards_match_iface:\n      \"ipassmt_sanity_nowildcards ipassmt \\<Longrightarrow>\n       ipassmt (Iface ifce2) = None \\<Longrightarrow>\n       ipassmt ifce = Some a \\<Longrightarrow>\n       \\<not> match_iface ifce ifce2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipassmt_sanity_nowildcards ipassmt;\n     ipassmt (Iface ifce2) = None; ipassmt ifce = Some a\\<rbrakk>\n    \\<Longrightarrow> \\<not> match_iface ifce ifce2", "unfolding ipassmt_sanity_nowildcards_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>iface\\<in>dom ipassmt. \\<not> iface_is_wildcard iface;\n     ipassmt (Iface ifce2) = None; ipassmt ifce = Some a\\<rbrakk>\n    \\<Longrightarrow> \\<not> match_iface ifce ifce2", "using iface_is_wildcard_def match_iface_case_nowildcard"], ["proof (prove)\nusing this:\n  iface_is_wildcard ?ifce \\<equiv> iface_name_is_wildcard (iface_sel ?ifce)\n  \\<not> iface_name_is_wildcard ?i \\<Longrightarrow>\n  match_iface (Iface ?i) ?p_i = (?i = ?p_i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>iface\\<in>dom ipassmt. \\<not> iface_is_wildcard iface;\n     ipassmt (Iface ifce2) = None; ipassmt ifce = Some a\\<rbrakk>\n    \\<Longrightarrow> \\<not> match_iface ifce ifce2", "by fastforce"], ["", "(* use this in all exported code*)\n  (*TODO: generate useful error message in exported code*)"], ["", "definition map_of_ipassmt :: \"(iface \\<times> ('i word \\<times> nat) list) list \\<Rightarrow> iface \\<rightharpoonup> ('i word \\<times> nat) list\" where\n    \"map_of_ipassmt ipassmt = (\n      if\n        distinct (map fst ipassmt) \\<and> ipassmt_sanity_nowildcards (map_of ipassmt)\n      then\n        map_of ipassmt\n      else undefined \\<^cancel>\\<open>undefined_ipassmt_must_be_distinct_and_dont_have_wildcard_interfaces\\<close>)\""], ["", "text\\<open>some additional (optional) sanity checks\\<close>"], ["", "text\\<open>sanity check that there are no zone-spanning interfaces\\<close>"], ["", "definition ipassmt_sanity_disjoint :: \"'i::len ipassignment \\<Rightarrow> bool\" where\n    \"ipassmt_sanity_disjoint ipassmt \\<equiv> \\<forall> i1 \\<in> dom ipassmt. \\<forall> i2 \\<in> dom ipassmt. i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set (set (the (ipassmt i1))) \\<inter> ipcidr_union_set (set (the (ipassmt i2))) = {}\""], ["", "lemma[code_unfold]: \"ipassmt_sanity_disjoint (map_of ipassmt) \\<longleftrightarrow>\n    (let Is = fst` set ipassmt in \n      (\\<forall> i1 \\<in> Is. \\<forall> i2 \\<in> Is. i1 \\<noteq> i2 \\<longrightarrow> wordinterval_empty (wordinterval_intersection (l2wi (map ipcidr_to_interval (the ((map_of ipassmt) i1))))  (l2wi (map ipcidr_to_interval (the ((map_of ipassmt) i2)))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_sanity_disjoint (map_of ipassmt) =\n    (let Is = fst ` set ipassmt\n     in \\<forall>i1\\<in>Is.\n           \\<forall>i2\\<in>Is.\n              i1 \\<noteq> i2 \\<longrightarrow>\n              wordinterval_empty\n               (wordinterval_intersection\n                 (l2wi (map ipcidr_to_interval (the (map_of ipassmt i1))))\n                 (l2wi (map ipcidr_to_interval (the (map_of ipassmt i2))))))", "apply(simp add: ipassmt_sanity_disjoint_def Map.dom_map_of_conv_image_fst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           ipcidr_union_set (set (the (map_of ipassmt (fst i1)))) \\<inter>\n           ipcidr_union_set (set (the (map_of ipassmt (fst i2)))) =\n           {}) =\n    (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           wordinterval_to_set\n            (l2wi\n              (map ipcidr_to_interval\n                (the (map_of ipassmt (fst i1))))) \\<inter>\n           wordinterval_to_set\n            (l2wi\n              (map ipcidr_to_interval (the (map_of ipassmt (fst i2))))) =\n           {})", "apply(simp add: ipcidr_union_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i1))).\n               case x of\n               (base, len) \\<Rightarrow> ipset_from_cidr base len) \\<inter>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i2))).\n               case x of\n               (base, len) \\<Rightarrow> ipset_from_cidr base len) =\n           {}) =\n    (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           wordinterval_to_set\n            (l2wi\n              (map ipcidr_to_interval\n                (the (map_of ipassmt (fst i1))))) \\<inter>\n           wordinterval_to_set\n            (l2wi\n              (map ipcidr_to_interval (the (map_of ipassmt (fst i2))))) =\n           {})", "apply(simp add: l2wi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i1))).\n               case x of\n               (base, len) \\<Rightarrow> ipset_from_cidr base len) \\<inter>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i2))).\n               case x of\n               (base, len) \\<Rightarrow> ipset_from_cidr base len) =\n           {}) =\n    (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           (\\<Union>a\\<in>set (the (map_of ipassmt (fst i1))).\n               case ipcidr_to_interval a of\n               (x, xa) \\<Rightarrow> {x..xa}) \\<inter>\n           (\\<Union>a\\<in>set (the (map_of ipassmt (fst i2))).\n               case ipcidr_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n           {})", "apply(simp add: ipcidr_to_interval_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i1))).\n               case x of\n               (base, len) \\<Rightarrow> ipset_from_cidr base len) \\<inter>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i2))).\n               case x of\n               (base, len) \\<Rightarrow> ipset_from_cidr base len) =\n           {}) =\n    (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i1))).\n               {ipcidr_to_interval_start\n                 x..ipcidr_to_interval_end x}) \\<inter>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i2))).\n               {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) =\n           {})", "using ipset_from_cidr_ipcidr_to_interval"], ["proof (prove)\nusing this:\n  ipset_from_cidr ?base ?len =\n  {ipcidr_to_interval_start\n    (?base, ?len)..ipcidr_to_interval_end (?base, ?len)}\n\ngoal (1 subgoal):\n 1. (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i1))).\n               case x of\n               (base, len) \\<Rightarrow> ipset_from_cidr base len) \\<inter>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i2))).\n               case x of\n               (base, len) \\<Rightarrow> ipset_from_cidr base len) =\n           {}) =\n    (\\<forall>i1\\<in>set ipassmt.\n        \\<forall>i2\\<in>set ipassmt.\n           fst i1 \\<noteq> fst i2 \\<longrightarrow>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i1))).\n               {ipcidr_to_interval_start\n                 x..ipcidr_to_interval_end x}) \\<inter>\n           (\\<Union>x\\<in>set (the (map_of ipassmt (fst i2))).\n               {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) =\n           {})", "by blast"], ["", "text\\<open>Checking that the ipassmt covers the complete ipv4 address space.\\<close>"], ["", "definition ipassmt_sanity_complete :: \"(iface \\<times> ('i::len word \\<times> nat) list) list \\<Rightarrow> bool\" where\n    \"ipassmt_sanity_complete ipassmt \\<equiv> distinct (map fst ipassmt) \\<and> (\\<Union>(ipcidr_union_set ` set ` (ran (map_of ipassmt)))) = UNIV\""], ["", "lemma[code_unfold]: \"ipassmt_sanity_complete ipassmt \\<longleftrightarrow> distinct (map fst ipassmt) \\<and> (let range = map snd ipassmt in \n        wordinterval_eq (wordinterval_Union (map (l2wi \\<circ> (map ipcidr_to_interval)) range)) wordinterval_UNIV\n        )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))", "apply(cases \"distinct (map fst ipassmt)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))\n 2. \\<not> distinct (map fst ipassmt) \\<Longrightarrow>\n    ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))", "apply(simp add: ipassmt_sanity_complete_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    ((\\<Union>a\\<in>ran (map_of ipassmt). ipcidr_union_set (set a)) =\n     UNIV) =\n    wordinterval_eq\n     (wordinterval_Union\n       (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval \\<circ> snd)\n         ipassmt))\n     wordinterval_UNIV\n 2. \\<not> distinct (map fst ipassmt) \\<Longrightarrow>\n    ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))", "apply(simp add: Map.ran_distinct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    ((\\<Union>x\\<in>set ipassmt. ipcidr_union_set (set (snd x))) = UNIV) =\n    wordinterval_eq\n     (wordinterval_Union\n       (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval \\<circ> snd)\n         ipassmt))\n     wordinterval_UNIV\n 2. \\<not> distinct (map fst ipassmt) \\<Longrightarrow>\n    ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))", "apply(simp add: wordinterval_eq_set_eq wordinterval_Union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    ((\\<Union>x\\<in>set ipassmt. ipcidr_union_set (set (snd x))) = UNIV) =\n    ((\\<Union>x\\<in>set ipassmt.\n         wordinterval_to_set (l2wi (map ipcidr_to_interval (snd x)))) =\n     UNIV)\n 2. \\<not> distinct (map fst ipassmt) \\<Longrightarrow>\n    ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))", "apply(simp add: l2wi)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    ((\\<Union>x\\<in>set ipassmt. ipcidr_union_set (set (snd x))) = UNIV) =\n    ((\\<Union>x\\<in>set ipassmt.\n         \\<Union>a\\<in>set (snd x).\n            case ipcidr_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n     UNIV)\n 2. \\<not> distinct (map fst ipassmt) \\<Longrightarrow>\n    ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))", "apply(simp add: ipcidr_to_interval_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    ((\\<Union>x\\<in>set ipassmt. ipcidr_union_set (set (snd x))) = UNIV) =\n    ((\\<Union>x\\<in>set ipassmt.\n         \\<Union>x\\<in>set (snd x).\n            {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) =\n     UNIV)\n 2. \\<not> distinct (map fst ipassmt) \\<Longrightarrow>\n    ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))", "apply(simp add: ipcidr_union_set_def ipset_from_cidr_ipcidr_to_interval; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (map fst ipassmt) \\<Longrightarrow>\n    ipassmt_sanity_complete ipassmt =\n    (distinct (map fst ipassmt) \\<and>\n     (let range = map snd ipassmt\n      in wordinterval_eq\n          (wordinterval_Union\n            (map ((l2wi \\<circ>\\<circ> map) ipcidr_to_interval) range))\n          wordinterval_UNIV))", "apply(simp add: ipassmt_sanity_complete_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "value[code] \"ipassmt_sanity_nowildcards (map_of [(Iface ''eth1.1017'', [(ipv4addr_of_dotdecimal (131,159,14,240), 28)])])\""], ["", "fun collect_ifaces' :: \"'i::len common_primitive rule list \\<Rightarrow> iface list\" where\n    \"collect_ifaces' [] = []\" |\n    \"collect_ifaces' ((Rule m a)#rs) = filter (\\<lambda>iface. iface \\<noteq> ifaceAny) (\n                                      (map (\\<lambda>x. case x of Pos i \\<Rightarrow> i | Neg i \\<Rightarrow> i) (fst (primitive_extractor (is_Iiface, iiface_sel) m))) @\n                                      (map (\\<lambda>x. case x of Pos i \\<Rightarrow> i | Neg i \\<Rightarrow> i) (fst (primitive_extractor (is_Oiface, oiface_sel) m))) @ collect_ifaces' rs)\""], ["", "definition collect_ifaces :: \"'i::len common_primitive rule list \\<Rightarrow> iface list\" where\n    \"collect_ifaces rs \\<equiv> mergesort_remdups (collect_ifaces' rs)\""], ["", "lemma \"set (collect_ifaces rs) = set (collect_ifaces' rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (collect_ifaces rs) = set (collect_ifaces' rs)", "by(simp add: collect_ifaces_def mergesort_remdups_correct)"], ["", "text\\<open>sanity check that all interfaces mentioned in the ruleset are also listed in the ipassmt. May fail for wildcard interfaces in the ruleset.\\<close>"], ["", "(*primitive_extractor requires normalized_nnf_primitives*)"], ["", "definition ipassmt_sanity_defined :: \"'i::len common_primitive rule list \\<Rightarrow> 'i ipassignment \\<Rightarrow> bool\" where\n    \"ipassmt_sanity_defined rs ipassmt \\<equiv> \\<forall> iface \\<in> set (collect_ifaces rs). iface \\<in> dom ipassmt\""], ["", "lemma[code]: \"ipassmt_sanity_defined rs ipassmt \\<longleftrightarrow> (\\<forall> iface \\<in> set (collect_ifaces rs). ipassmt iface \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_sanity_defined rs ipassmt =\n    (\\<forall>iface\\<in>set (collect_ifaces rs).\n        ipassmt iface \\<noteq> None)", "by(simp add: ipassmt_sanity_defined_def Map.domIff)"], ["", "lemma \"ipassmt_sanity_defined [\n         Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (Match (IIface (Iface ''eth1.1017'')))) action.Accept,\n         Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (Match (IIface (ifaceAny)))) action.Accept,\n         Rule MatchAny action.Drop]\n             (map_of [(Iface ''eth1.1017'', [(ipv4addr_of_dotdecimal (131,159,14,240), 28)])])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_sanity_defined\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (Match (IIface (Iface ''eth1.1017''))))\n       Accept,\n      Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (Match (IIface ifaceAny)))\n       Accept,\n      Rule MatchAny Drop]\n     (map_of\n       [(Iface ''eth1.1017'',\n         [(ipv4addr_of_dotdecimal (131, 159, 14, 240), 28)])])", "by eval"], ["", "(*TODO: use and add code equation*)"], ["", "definition ipassmt_ignore_wildcard :: \"'i::len ipassignment \\<Rightarrow> 'i ipassignment\" where\n    \"ipassmt_ignore_wildcard ipassmt \\<equiv> \\<lambda>k. case ipassmt k of None \\<Rightarrow> None \n                                                           | Some ips \\<Rightarrow> if ipcidr_union_set (set ips) = UNIV then None else Some ips\""], ["", "lemma ipassmt_ignore_wildcard_le: \"ipassmt_ignore_wildcard ipassmt \\<subseteq>\\<^sub>m ipassmt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_ignore_wildcard ipassmt \\<subseteq>\\<^sub>m ipassmt", "apply(simp add: ipassmt_ignore_wildcard_def map_le_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (\\<lambda>k.\n                           case ipassmt k of None \\<Rightarrow> None\n                           | Some ips \\<Rightarrow>\n                               if ipcidr_union_set (set ips) = UNIV\n                               then None else Some ips).\n       (case ipassmt a of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips) =\n       ipassmt a", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       (case ipassmt a of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips) =\n       Some y \\<Longrightarrow>\n       (case ipassmt a of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips) =\n       ipassmt a", "apply(simp split: option.split_asm if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition ipassmt_ignore_wildcard_list:: \"(iface \\<times> ('i::len word \\<times> nat) list) list \\<Rightarrow> (iface \\<times> ('i word \\<times> nat) list) list\" where\n    \"ipassmt_ignore_wildcard_list ipassmt = filter (\\<lambda>(_,ips).  \\<not> wordinterval_eq (l2wi (map ipcidr_to_interval ips)) wordinterval_UNIV) ipassmt\""], ["", "(*distinct fst ipassmt notwendig?*)"], ["", "lemma \"distinct (map fst ipassmt) \\<Longrightarrow>\n    map_of (ipassmt_ignore_wildcard_list ipassmt) = ipassmt_ignore_wildcard (map_of ipassmt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    map_of (ipassmt_ignore_wildcard_list ipassmt) =\n    ipassmt_ignore_wildcard (map_of ipassmt)", "apply(simp add: ipassmt_ignore_wildcard_list_def ipassmt_ignore_wildcard_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    map_of\n     (filter\n       (\\<lambda>(uu_, ips).\n           \\<not> wordinterval_eq (l2wi (map ipcidr_to_interval ips))\n                   wordinterval_UNIV)\n       ipassmt) =\n    (\\<lambda>k.\n        case map_of ipassmt k of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips)", "apply(simp add: wordinterval_eq_set_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    map_of\n     (filter\n       (\\<lambda>(uu_, ips).\n           wordinterval_to_set (l2wi (map ipcidr_to_interval ips)) \\<noteq>\n           UNIV)\n       ipassmt) =\n    (\\<lambda>k.\n        case map_of ipassmt k of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips)", "apply(simp add: l2wi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    map_of\n     (filter\n       (\\<lambda>(uu_, ips).\n           (\\<Union>a\\<in>set ips.\n               case ipcidr_to_interval a of\n               (x, xa) \\<Rightarrow> {x..xa}) \\<noteq>\n           UNIV)\n       ipassmt) =\n    (\\<lambda>k.\n        case map_of ipassmt k of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips)", "apply(simp add: ipcidr_to_interval_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    map_of\n     (filter\n       (\\<lambda>(uu_, ips).\n           (\\<Union>x\\<in>set ips.\n               {ipcidr_to_interval_start\n                 x..ipcidr_to_interval_end x}) \\<noteq>\n           UNIV)\n       ipassmt) =\n    (\\<lambda>k.\n        case map_of ipassmt k of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips)", "apply(simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ipassmt) \\<Longrightarrow>\n    \\<forall>x.\n       map_of\n        (filter\n          (\\<lambda>(uu_, ips).\n              (\\<Union>x\\<in>set ips.\n                  {ipcidr_to_interval_start\n                    x..ipcidr_to_interval_end x}) \\<noteq>\n              UNIV)\n          ipassmt)\n        x =\n       (case map_of ipassmt x of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct (map fst ipassmt) \\<Longrightarrow>\n       map_of\n        (filter\n          (\\<lambda>(uu_, ips).\n              (\\<Union>x\\<in>set ips.\n                  {ipcidr_to_interval_start\n                    x..ipcidr_to_interval_end x}) \\<noteq>\n              UNIV)\n          ipassmt)\n        x =\n       (case map_of ipassmt x of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips)", "apply(induction ipassmt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       distinct (map fst []) \\<Longrightarrow>\n       map_of\n        (filter\n          (\\<lambda>(uu_, ips).\n              (\\<Union>x\\<in>set ips.\n                  {ipcidr_to_interval_start\n                    x..ipcidr_to_interval_end x}) \\<noteq>\n              UNIV)\n          [])\n        x =\n       (case map_of [] x of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips)\n 2. \\<And>a ipassmt x.\n       \\<lbrakk>\\<And>x.\n                   distinct (map fst ipassmt) \\<Longrightarrow>\n                   map_of\n                    (filter\n                      (\\<lambda>(uu_, ips).\n                          (\\<Union>x\\<in>set ips.\n                              {ipcidr_to_interval_start\n                                x..ipcidr_to_interval_end x}) \\<noteq>\n                          UNIV)\n                      ipassmt)\n                    x =\n                   (case map_of ipassmt x of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips);\n        distinct (map fst (a # ipassmt))\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (filter\n                            (\\<lambda>(uu_, ips).\n                                (\\<Union>x\\<in>set ips.\n                                    {ipcidr_to_interval_start\nx..ipcidr_to_interval_end x}) \\<noteq>\n                                UNIV)\n                            (a # ipassmt))\n                          x =\n                         (case map_of (a # ipassmt) x of\n                          None \\<Rightarrow> None\n                          | Some ips \\<Rightarrow>\n                              if ipcidr_union_set (set ips) = UNIV then None\n                              else Some ips)", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ipassmt x.\n       \\<lbrakk>\\<And>x.\n                   distinct (map fst ipassmt) \\<Longrightarrow>\n                   map_of\n                    (filter\n                      (\\<lambda>(uu_, ips).\n                          (\\<Union>x\\<in>set ips.\n                              {ipcidr_to_interval_start\n                                x..ipcidr_to_interval_end x}) \\<noteq>\n                          UNIV)\n                      ipassmt)\n                    x =\n                   (case map_of ipassmt x of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips);\n        distinct (map fst (a # ipassmt))\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (filter\n                            (\\<lambda>(uu_, ips).\n                                (\\<Union>x\\<in>set ips.\n                                    {ipcidr_to_interval_start\nx..ipcidr_to_interval_end x}) \\<noteq>\n                                UNIV)\n                            (a # ipassmt))\n                          x =\n                         (case map_of (a # ipassmt) x of\n                          None \\<Rightarrow> None\n                          | Some ips \\<Rightarrow>\n                              if ipcidr_union_set (set ips) = UNIV then None\n                              else Some ips)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ipassmt x.\n       \\<lbrakk>\\<And>x.\n                   map_of\n                    (filter\n                      (\\<lambda>(uu_, ips).\n                          (\\<Union>x\\<in>set ips.\n                              {ipcidr_to_interval_start\n                                x..ipcidr_to_interval_end x}) \\<noteq>\n                          UNIV)\n                      ipassmt)\n                    x =\n                   (case map_of ipassmt x of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips);\n        fst a \\<notin> fst ` set ipassmt \\<and>\n        distinct (map fst ipassmt)\\<rbrakk>\n       \\<Longrightarrow> ((case a of\n                           (uu_, ips) \\<Rightarrow>\n                             (\\<Union>x\\<in>set ips.\n                                 {ipcidr_to_interval_start\n                                   x..ipcidr_to_interval_end x}) \\<noteq>\n                             UNIV) \\<longrightarrow>\n                          ipcidr_union_set (set (snd a)) =\n                          UNIV \\<longrightarrow>\n                          x \\<noteq> fst a) \\<and>\n                         (\\<not> (case a of\n                                  (uu_, ips) \\<Rightarrow>\n                                    (\\<Union>x\\<in>set ips.\n  {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n                                    UNIV) \\<longrightarrow>\n                          (ipcidr_union_set (set (snd a)) =\n                           UNIV \\<longrightarrow>\n                           x = fst a \\<longrightarrow>\n                           (case map_of ipassmt (fst a) of\n                            None \\<Rightarrow> None\n                            | Some ips \\<Rightarrow>\n                                if ipcidr_union_set (set ips) = UNIV\n                                then None else Some ips) =\n                           None) \\<and>\n                          (ipcidr_union_set (set (snd a)) \\<noteq>\n                           UNIV \\<longrightarrow>\n                           x = fst a \\<longrightarrow>\n                           (case map_of ipassmt (fst a) of\n                            None \\<Rightarrow> None\n                            | Some ips \\<Rightarrow>\n                                if ipcidr_union_set (set ips) = UNIV\n                                then None else Some ips) =\n                           Some (snd a)))", "apply(simp split:option.split option.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ipassmt x.\n       \\<lbrakk>\\<And>x.\n                   map_of\n                    (filter\n                      (\\<lambda>(uu_, ips).\n                          (\\<Union>x\\<in>set ips.\n                              {ipcidr_to_interval_start\n                                x..ipcidr_to_interval_end x}) \\<noteq>\n                          UNIV)\n                      ipassmt)\n                    x =\n                   (case map_of ipassmt x of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips);\n        fst a \\<notin> fst ` set ipassmt \\<and>\n        distinct (map fst ipassmt)\\<rbrakk>\n       \\<Longrightarrow> (map_of ipassmt (fst a) = None \\<longrightarrow>\n                          ((case a of\n                            (uu_, ips) \\<Rightarrow>\n                              (\\<Union>x\\<in>set ips.\n                                  {ipcidr_to_interval_start\n                                    x..ipcidr_to_interval_end x}) \\<noteq>\n                              UNIV) \\<longrightarrow>\n                           ipcidr_union_set (set (snd a)) =\n                           UNIV \\<longrightarrow>\n                           x \\<noteq> fst a) \\<and>\n                          (\\<not> (case a of\n                                   (uu_, ips) \\<Rightarrow>\n                                     (\\<Union>x\\<in>set ips.\n   {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n                                     UNIV) \\<longrightarrow>\n                           ipcidr_union_set (set (snd a)) \\<noteq>\n                           UNIV \\<longrightarrow>\n                           x \\<noteq> fst a)) \\<and>\n                         (\\<forall>x2.\n                             (ipcidr_union_set (set x2) =\n                              UNIV \\<longrightarrow>\n                              (fst a, x2)\n                              \\<in> set ipassmt \\<longrightarrow>\n                              ((case a of\n                                (uu_, ips) \\<Rightarrow>\n                                  (\\<Union>x\\<in>set ips.\n{ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n                                  UNIV) \\<longrightarrow>\n                               ipcidr_union_set (set (snd a)) =\n                               UNIV \\<longrightarrow>\n                               x \\<noteq> fst a) \\<and>\n                              (\\<not> (case a of\n (uu_, ips) \\<Rightarrow>\n   (\\<Union>x\\<in>set ips.\n       {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n   UNIV) \\<longrightarrow>\n                               ipcidr_union_set (set (snd a)) \\<noteq>\n                               UNIV \\<longrightarrow>\n                               x \\<noteq> fst a)) \\<and>\n                             (ipcidr_union_set (set x2) \\<noteq>\n                              UNIV \\<longrightarrow>\n                              (fst a, x2)\n                              \\<in> set ipassmt \\<longrightarrow>\n                              ((case a of\n                                (uu_, ips) \\<Rightarrow>\n                                  (\\<Union>x\\<in>set ips.\n{ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n                                  UNIV) \\<longrightarrow>\n                               ipcidr_union_set (set (snd a)) =\n                               UNIV \\<longrightarrow>\n                               x \\<noteq> fst a) \\<and>\n                              (\\<not> (case a of\n (uu_, ips) \\<Rightarrow>\n   (\\<Union>x\\<in>set ips.\n       {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n   UNIV) \\<longrightarrow>\n                               (ipcidr_union_set (set (snd a)) =\n                                UNIV \\<longrightarrow>\n                                x \\<noteq> fst a) \\<and>\n                               (ipcidr_union_set (set (snd a)) \\<noteq>\n                                UNIV \\<longrightarrow>\n                                x = fst a \\<longrightarrow> x2 = snd a))))", "apply(simp add: ipcidr_union_set_def ipset_from_cidr_ipcidr_to_interval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ipassmt x.\n       \\<lbrakk>\\<And>x.\n                   map_of\n                    (filter\n                      (\\<lambda>(uu_, ips).\n                          (\\<Union>x\\<in>set ips.\n                              {ipcidr_to_interval_start\n                                x..ipcidr_to_interval_end x}) \\<noteq>\n                          UNIV)\n                      ipassmt)\n                    x =\n                   (case map_of ipassmt x of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips);\n        fst a \\<notin> fst ` set ipassmt \\<and>\n        distinct (map fst ipassmt)\\<rbrakk>\n       \\<Longrightarrow> (map_of ipassmt (fst a) = None \\<longrightarrow>\n                          ((case a of\n                            (uu_, ips) \\<Rightarrow>\n                              (\\<Union>x\\<in>set ips.\n                                  {ipcidr_to_interval_start\n                                    x..ipcidr_to_interval_end x}) \\<noteq>\n                              UNIV) \\<longrightarrow>\n                           (\\<Union>x\\<in>set (snd a).\n                               {ipcidr_to_interval_start\n                                 x..ipcidr_to_interval_end x}) =\n                           UNIV \\<longrightarrow>\n                           x \\<noteq> fst a) \\<and>\n                          (\\<not> (case a of\n                                   (uu_, ips) \\<Rightarrow>\n                                     (\\<Union>x\\<in>set ips.\n   {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n                                     UNIV) \\<longrightarrow>\n                           (\\<Union>x\\<in>set (snd a).\n                               {ipcidr_to_interval_start\n                                 x..ipcidr_to_interval_end x}) \\<noteq>\n                           UNIV \\<longrightarrow>\n                           x \\<noteq> fst a)) \\<and>\n                         (\\<forall>x2.\n                             ((\\<Union>x\\<in>set x2.\n                                  {ipcidr_to_interval_start\n                                    x..ipcidr_to_interval_end x}) =\n                              UNIV \\<longrightarrow>\n                              (fst a, x2)\n                              \\<in> set ipassmt \\<longrightarrow>\n                              ((case a of\n                                (uu_, ips) \\<Rightarrow>\n                                  (\\<Union>x\\<in>set ips.\n{ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n                                  UNIV) \\<longrightarrow>\n                               (\\<Union>x\\<in>set (snd a).\n                                   {ipcidr_to_interval_start\n                                     x..ipcidr_to_interval_end x}) =\n                               UNIV \\<longrightarrow>\n                               x \\<noteq> fst a) \\<and>\n                              (\\<not> (case a of\n (uu_, ips) \\<Rightarrow>\n   (\\<Union>x\\<in>set ips.\n       {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n   UNIV) \\<longrightarrow>\n                               (\\<Union>x\\<in>set (snd a).\n                                   {ipcidr_to_interval_start\n                                     x..ipcidr_to_interval_end x}) \\<noteq>\n                               UNIV \\<longrightarrow>\n                               x \\<noteq> fst a)) \\<and>\n                             ((\\<Union>x\\<in>set x2.\n                                  {ipcidr_to_interval_start\n                                    x..ipcidr_to_interval_end x}) \\<noteq>\n                              UNIV \\<longrightarrow>\n                              (fst a, x2)\n                              \\<in> set ipassmt \\<longrightarrow>\n                              ((case a of\n                                (uu_, ips) \\<Rightarrow>\n                                  (\\<Union>x\\<in>set ips.\n{ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n                                  UNIV) \\<longrightarrow>\n                               (\\<Union>x\\<in>set (snd a).\n                                   {ipcidr_to_interval_start\n                                     x..ipcidr_to_interval_end x}) =\n                               UNIV \\<longrightarrow>\n                               x \\<noteq> fst a) \\<and>\n                              (\\<not> (case a of\n (uu_, ips) \\<Rightarrow>\n   (\\<Union>x\\<in>set ips.\n       {ipcidr_to_interval_start x..ipcidr_to_interval_end x}) \\<noteq>\n   UNIV) \\<longrightarrow>\n                               ((\\<Union>x\\<in>set (snd a).\n                                    {ipcidr_to_interval_start\nx..ipcidr_to_interval_end x}) =\n                                UNIV \\<longrightarrow>\n                                x \\<noteq> fst a) \\<and>\n                               ((\\<Union>x\\<in>set (snd a).\n                                    {ipcidr_to_interval_start\nx..ipcidr_to_interval_end x}) \\<noteq>\n                                UNIV \\<longrightarrow>\n                                x = fst a \\<longrightarrow> x2 = snd a))))", "apply(simp add: case_prod_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ipassmt x.\n       \\<lbrakk>\\<And>x.\n                   map_of\n                    (filter\n                      (\\<lambda>p.\n                          (\\<Union>x\\<in>set (snd p).\n                              {ipcidr_to_interval_start\n                                x..ipcidr_to_interval_end x}) \\<noteq>\n                          UNIV)\n                      ipassmt)\n                    x =\n                   (case map_of ipassmt x of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips);\n        fst a \\<notin> fst ` set ipassmt \\<and>\n        distinct (map fst ipassmt)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            (\\<Union>x\\<in>set x2.\n                                {ipcidr_to_interval_start\n                                  x..ipcidr_to_interval_end x}) \\<noteq>\n                            UNIV \\<longrightarrow>\n                            (fst a, x2) \\<in> set ipassmt \\<longrightarrow>\n                            (\\<Union>x\\<in>set (snd a).\n                                {ipcidr_to_interval_start\n                                  x..ipcidr_to_interval_end x}) =\n                            UNIV \\<longrightarrow>\n                            x \\<noteq> fst a", "by blast"], ["", "(*apply(safe)\n                       apply(simp_all)\n      by (simp add: rev_image_eqI)*)"], ["", "text\\<open>Debug algorithm with human-readable output\\<close>"], ["", "definition debug_ipassmt_generic\n    :: \"('i::len wordinterval \\<Rightarrow> string) \\<Rightarrow>\n          (iface \\<times> ('i word \\<times> nat) list) list \\<Rightarrow> 'i common_primitive rule list \\<Rightarrow> string list\" where\n    \"debug_ipassmt_generic toStr ipassmt rs \\<equiv> let ifaces = (map fst ipassmt) in [\n      ''distinct: '' @ (if distinct ifaces then ''passed'' else ''FAIL!'')\n      , ''ipassmt_sanity_nowildcards: '' @\n          (if ipassmt_sanity_nowildcards (map_of ipassmt)\n           then ''passed'' else ''fail: ''@list_toString iface_sel (filter iface_is_wildcard ifaces))\n      , ''ipassmt_sanity_defined (interfaces defined in the ruleset are also in ipassmt): '' @ \n          (if ipassmt_sanity_defined rs (map_of ipassmt)\n           then ''passed'' else ''fail: ''@list_toString iface_sel [i \\<leftarrow> (collect_ifaces rs). i \\<notin> set ifaces])\n      , ''ipassmt_sanity_disjoint (no zone-spanning interfaces): '' @\n          (if ipassmt_sanity_disjoint (map_of ipassmt)\n           then ''passed'' else ''fail: ''@list_toString (\\<lambda>(i1,i2). ''('' @ iface_sel i1 @ '','' @ iface_sel i2 @ '')'')\n               [(i1,i2) \\<leftarrow> List.product ifaces ifaces. i1 \\<noteq> i2 \\<and>\n                \\<not> wordinterval_empty (wordinterval_intersection\n                                        (l2wi (map ipcidr_to_interval (the ((map_of ipassmt) i1))))\n                                        (l2wi (map ipcidr_to_interval (the ((map_of ipassmt) i2)))))\n          ])\n      , ''ipassmt_sanity_disjoint excluding UNIV interfaces: '' @\n          (let ipassmt = ipassmt_ignore_wildcard_list ipassmt;\n               ifaces = (map fst ipassmt)\n           in\n          (if ipassmt_sanity_disjoint (map_of ipassmt)\n           then ''passed'' else ''fail: ''@list_toString (\\<lambda>(i1,i2). ''('' @ iface_sel i1 @ '','' @ iface_sel i2 @ '')'')\n               [(i1,i2) \\<leftarrow> List.product ifaces ifaces. i1 \\<noteq> i2 \\<and>\n                \\<not> wordinterval_empty (wordinterval_intersection\n                                        (l2wi (map ipcidr_to_interval (the ((map_of ipassmt) i1))))\n                                        (l2wi (map ipcidr_to_interval (the ((map_of ipassmt) i2)))))\n          ]))\n       , ''ipassmt_sanity_complete: '' @ \n          (if ipassmt_sanity_complete ipassmt\n           then ''passed''\n           else ''the following is not covered: '' @ \n            toStr (wordinterval_setminus wordinterval_UNIV (wordinterval_Union (map (l2wi \\<circ> (map ipcidr_to_interval)) (map snd ipassmt)))))\n      , ''ipassmt_sanity_complete excluding UNIV interfaces: '' @\n          (let ipassmt = ipassmt_ignore_wildcard_list ipassmt\n           in\n          (if ipassmt_sanity_complete ipassmt\n           then ''passed''\n           else ''the following is not covered: '' @\n            toStr (wordinterval_setminus wordinterval_UNIV (wordinterval_Union (map (l2wi \\<circ> (map ipcidr_to_interval)) (map snd ipassmt))))))\n      ]\""], ["", "definition \"debug_ipassmt_ipv4 \\<equiv> debug_ipassmt_generic ipv4addr_wordinterval_toString\""], ["", "definition \"debug_ipassmt_ipv6 \\<equiv> debug_ipassmt_generic ipv6addr_wordinterval_toString\""], ["", "lemma dom_ipassmt_ignore_wildcard:\n    \"i\\<in>dom (ipassmt_ignore_wildcard ipassmt) \\<longleftrightarrow> i \\<in> dom ipassmt \\<and> ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> dom (ipassmt_ignore_wildcard ipassmt)) =\n    (i \\<in> dom ipassmt \\<and>\n     ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV)", "apply(simp add: ipassmt_ignore_wildcard_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> dom (\\<lambda>k.\n                     case ipassmt k of None \\<Rightarrow> None\n                     | Some ips \\<Rightarrow>\n                         if ipcidr_union_set (set ips) = UNIV then None\n                         else Some ips)) =\n    (i \\<in> dom ipassmt \\<and>\n     ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV)", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i \\<in> dom (\\<lambda>k.\n                    case ipassmt k of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips) \\<Longrightarrow>\n    i \\<in> dom ipassmt \\<and>\n    ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV\n 2. i \\<in> dom ipassmt \\<and>\n    ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV \\<Longrightarrow>\n    i \\<in> dom (\\<lambda>k.\n                    case ipassmt k of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips)", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       (case ipassmt i of None \\<Rightarrow> None\n        | Some ips \\<Rightarrow>\n            if ipcidr_union_set (set ips) = UNIV then None else Some ips) =\n       Some y \\<Longrightarrow>\n       i \\<in> dom ipassmt \\<and>\n       ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV\n 2. i \\<in> dom ipassmt \\<and>\n    ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV \\<Longrightarrow>\n    i \\<in> dom (\\<lambda>k.\n                    case ipassmt k of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips)", "apply(simp split: option.split_asm if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y x2.\n       \\<lbrakk>ipassmt i = Some y; ipcidr_union_set (set y) \\<noteq> UNIV;\n        x2 = y\\<rbrakk>\n       \\<Longrightarrow> i \\<in> dom ipassmt\n 2. i \\<in> dom ipassmt \\<and>\n    ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV \\<Longrightarrow>\n    i \\<in> dom (\\<lambda>k.\n                    case ipassmt k of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> dom ipassmt \\<and>\n    ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV \\<Longrightarrow>\n    i \\<in> dom (\\<lambda>k.\n                    case ipassmt k of None \\<Rightarrow> None\n                    | Some ips \\<Rightarrow>\n                        if ipcidr_union_set (set ips) = UNIV then None\n                        else Some ips)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>ipcidr_union_set (set (the (ipassmt i))) \\<noteq> UNIV;\n        ipassmt i = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case ipassmt i of None \\<Rightarrow> None\n                             | Some ips \\<Rightarrow>\n                                 if ipcidr_union_set (set ips) = UNIV\n                                 then None else Some ips) =\n                            Some y", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ipassmt_ignore_wildcard_the:\n    \"ipassmt i = Some ips \\<Longrightarrow> ipcidr_union_set (set ips) \\<noteq> UNIV \\<Longrightarrow> (the (ipassmt_ignore_wildcard ipassmt i)) = ips\"\n    \"ipassmt_ignore_wildcard ipassmt i = Some ips \\<Longrightarrow> the (ipassmt i) = ips\"\n    \"ipassmt_ignore_wildcard ipassmt i = Some ips \\<Longrightarrow> ipcidr_union_set (set ips) \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>ipassmt i = Some ips;\n      ipcidr_union_set (set ips) \\<noteq> UNIV\\<rbrakk>\n     \\<Longrightarrow> the (ipassmt_ignore_wildcard ipassmt i) = ips) &&&\n    (ipassmt_ignore_wildcard ipassmt i = Some ips \\<Longrightarrow>\n     the (ipassmt i) = ips) &&&\n    (ipassmt_ignore_wildcard ipassmt i = Some ips \\<Longrightarrow>\n     ipcidr_union_set (set ips) \\<noteq> UNIV)", "by (simp_all add: ipassmt_ignore_wildcard_def split: option.split_asm if_split_asm)"], ["", "lemma ipassmt_sanity_disjoint_ignore_wildcards:\n        \"ipassmt_sanity_disjoint (ipassmt_ignore_wildcard ipassmt) \\<longleftrightarrow>\n         (\\<forall>i1\\<in>dom ipassmt.\n          \\<forall>i2\\<in>dom ipassmt.\n            ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n            ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n            i1 \\<noteq> i2 \n            \\<longrightarrow> ipcidr_union_set (set (the (ipassmt i1))) \\<inter> ipcidr_union_set (set (the (ipassmt i2))) = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_sanity_disjoint (ipassmt_ignore_wildcard ipassmt) =\n    (\\<forall>i1\\<in>dom ipassmt.\n        \\<forall>i2\\<in>dom ipassmt.\n           ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n           ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n           i1 \\<noteq> i2 \\<longrightarrow>\n           ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n           ipcidr_union_set (set (the (ipassmt i2))) =\n           {})", "apply(simp add: ipassmt_sanity_disjoint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n        \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n           i1 \\<noteq> i2 \\<longrightarrow>\n           ipcidr_union_set\n            (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n           ipcidr_union_set\n            (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n           {}) =\n    (\\<forall>i1\\<in>dom ipassmt.\n        \\<forall>i2\\<in>dom ipassmt.\n           ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n           ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n           i1 \\<noteq> i2 \\<longrightarrow>\n           ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n           ipcidr_union_set (set (the (ipassmt i2))) =\n           {})", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n       \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n          {} \\<Longrightarrow>\n    \\<forall>i1\\<in>dom ipassmt.\n       \\<forall>i2\\<in>dom ipassmt.\n          ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n          ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n          ipcidr_union_set (set (the (ipassmt i2))) =\n          {}\n 2. \\<forall>i1\\<in>dom ipassmt.\n       \\<forall>i2\\<in>dom ipassmt.\n          ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n          ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n          ipcidr_union_set (set (the (ipassmt i2))) =\n          {} \\<Longrightarrow>\n    \\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n       \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n          {}", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i1 i2 y ya.\n       \\<lbrakk>\\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n                   \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n                      i1 \\<noteq> i2 \\<longrightarrow>\n                      ipcidr_union_set\n                       (set (the (ipassmt_ignore_wildcard ipassmt\n                                   i1))) \\<inter>\n                      ipcidr_union_set\n                       (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n                      {};\n        ipassmt i1 = Some y; ipassmt i2 = Some ya;\n        ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV;\n        ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV;\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n                         ipcidr_union_set (set (the (ipassmt i2))) =\n                         {}\n 2. \\<forall>i1\\<in>dom ipassmt.\n       \\<forall>i2\\<in>dom ipassmt.\n          ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n          ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n          ipcidr_union_set (set (the (ipassmt i2))) =\n          {} \\<Longrightarrow>\n    \\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n       \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n          {}", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i1 i2 y ya.\n       \\<lbrakk>\\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n                   \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n                      i1 \\<noteq> i2 \\<longrightarrow>\n                      ipcidr_union_set\n                       (set (the (ipassmt_ignore_wildcard ipassmt\n                                   i1))) \\<inter>\n                      ipcidr_union_set\n                       (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n                      {};\n        ipassmt i1 = Some y; ipassmt i2 = Some ya;\n        ipcidr_union_set (set y) \\<noteq> UNIV;\n        ipcidr_union_set (set ya) \\<noteq> UNIV; i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> ipcidr_union_set (set y) \\<inter>\n                         ipcidr_union_set (set ya) =\n                         {}\n 2. \\<forall>i1\\<in>dom ipassmt.\n       \\<forall>i2\\<in>dom ipassmt.\n          ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n          ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n          ipcidr_union_set (set (the (ipassmt i2))) =\n          {} \\<Longrightarrow>\n    \\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n       \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n          {}", "subgoal for i1 i2 ips1 ips2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n                \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n                   i1 \\<noteq> i2 \\<longrightarrow>\n                   ipcidr_union_set\n                    (set (the (ipassmt_ignore_wildcard ipassmt\n                                i1))) \\<inter>\n                   ipcidr_union_set\n                    (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n                   {};\n     ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "apply(erule_tac x=i1 in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set\n         (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i1 \\<notin> dom (ipassmt_ignore_wildcard ipassmt)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i1 \\<notin> dom (ipassmt_ignore_wildcard ipassmt)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set\n         (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "using dom_ipassmt_ignore_wildcard"], ["proof (prove)\nusing this:\n  (?i \\<in> dom (ipassmt_ignore_wildcard ?ipassmt)) =\n  (?i \\<in> dom ?ipassmt \\<and>\n   ipcidr_union_set (set (the (?ipassmt ?i))) \\<noteq> UNIV)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i1 \\<notin> dom (ipassmt_ignore_wildcard ipassmt)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set\n         (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "apply (metis domI option.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set\n         (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "apply(erule_tac x=i2 in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i1 \\<noteq> i2 \\<longrightarrow>\n     ipcidr_union_set\n      (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n     ipcidr_union_set (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i2 \\<notin> dom (ipassmt_ignore_wildcard ipassmt)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i2 \\<notin> dom (ipassmt_ignore_wildcard ipassmt)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i1 \\<noteq> i2 \\<longrightarrow>\n     ipcidr_union_set\n      (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n     ipcidr_union_set (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "using dom_ipassmt_ignore_wildcard"], ["proof (prove)\nusing this:\n  (?i \\<in> dom (ipassmt_ignore_wildcard ?ipassmt)) =\n  (?i \\<in> dom ?ipassmt \\<and>\n   ipcidr_union_set (set (the (?ipassmt ?i))) \\<noteq> UNIV)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i2 \\<notin> dom (ipassmt_ignore_wildcard ipassmt)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i1 \\<noteq> i2 \\<longrightarrow>\n     ipcidr_union_set\n      (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n     ipcidr_union_set (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "apply (metis domI domIff option.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipassmt i1 = Some ips1; ipassmt i2 = Some ips2;\n     ipcidr_union_set (set ips1) \\<noteq> UNIV;\n     ipcidr_union_set (set ips2) \\<noteq> UNIV; i1 \\<noteq> i2;\n     i1 \\<noteq> i2 \\<longrightarrow>\n     ipcidr_union_set\n      (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n     ipcidr_union_set (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "by(simp add: ipassmt_ignore_wildcard_the; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i1\\<in>dom ipassmt.\n       \\<forall>i2\\<in>dom ipassmt.\n          ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n          ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n          ipcidr_union_set (set (the (ipassmt i2))) =\n          {} \\<Longrightarrow>\n    \\<forall>i1\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n       \\<forall>i2\\<in>dom (ipassmt_ignore_wildcard ipassmt).\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i1))) \\<inter>\n          ipcidr_union_set\n           (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n          {}", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i1 i2 y ya.\n       \\<lbrakk>\\<forall>i1\\<in>dom ipassmt.\n                   \\<forall>i2\\<in>dom ipassmt.\n                      ipcidr_union_set (set (the (ipassmt i1))) \\<noteq>\n                      UNIV \\<and>\n                      ipcidr_union_set (set (the (ipassmt i2))) \\<noteq>\n                      UNIV \\<and>\n                      i1 \\<noteq> i2 \\<longrightarrow>\n                      ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n                      ipcidr_union_set (set (the (ipassmt i2))) =\n                      {};\n        ipassmt_ignore_wildcard ipassmt i1 = Some y;\n        ipassmt_ignore_wildcard ipassmt i2 = Some ya;\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> ipcidr_union_set\n                          (set (the (ipassmt_ignore_wildcard ipassmt\ni1))) \\<inter>\n                         ipcidr_union_set\n                          (set (the (ipassmt_ignore_wildcard ipassmt i2))) =\n                         {}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i1 i2 y ya.\n       \\<lbrakk>\\<forall>i1\\<in>dom ipassmt.\n                   \\<forall>i2\\<in>dom ipassmt.\n                      ipcidr_union_set (set (the (ipassmt i1))) \\<noteq>\n                      UNIV \\<and>\n                      ipcidr_union_set (set (the (ipassmt i2))) \\<noteq>\n                      UNIV \\<and>\n                      i1 \\<noteq> i2 \\<longrightarrow>\n                      ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n                      ipcidr_union_set (set (the (ipassmt i2))) =\n                      {};\n        ipassmt_ignore_wildcard ipassmt i1 = Some y;\n        ipassmt_ignore_wildcard ipassmt i2 = Some ya;\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> ipcidr_union_set (set y) \\<inter>\n                         ipcidr_union_set (set ya) =\n                         {}", "subgoal for i1 i2 ips1 ips2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i1\\<in>dom ipassmt.\n                \\<forall>i2\\<in>dom ipassmt.\n                   ipcidr_union_set (set (the (ipassmt i1))) \\<noteq>\n                   UNIV \\<and>\n                   ipcidr_union_set (set (the (ipassmt i2))) \\<noteq>\n                   UNIV \\<and>\n                   i1 \\<noteq> i2 \\<longrightarrow>\n                   ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n                   ipcidr_union_set (set (the (ipassmt i2))) =\n                   {};\n     ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "apply(erule_tac x=i1 in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     \\<forall>i2\\<in>dom ipassmt.\n        ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n        ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt i2))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     i1 \\<notin> dom ipassmt\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     i1 \\<notin> dom ipassmt\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     \\<forall>i2\\<in>dom ipassmt.\n        ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n        ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt i2))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "using dom_ipassmt_ignore_wildcard"], ["proof (prove)\nusing this:\n  (?i \\<in> dom (ipassmt_ignore_wildcard ?ipassmt)) =\n  (?i \\<in> dom ?ipassmt \\<and>\n   ipcidr_union_set (set (the (?ipassmt ?i))) \\<noteq> UNIV)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     i1 \\<notin> dom ipassmt\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     \\<forall>i2\\<in>dom ipassmt.\n        ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n        ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt i2))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     \\<forall>i2\\<in>dom ipassmt.\n        ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n        ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt i2))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "apply(erule_tac x=i2 in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n     ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n     i1 \\<noteq> i2 \\<longrightarrow>\n     ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n     ipcidr_union_set (set (the (ipassmt i2))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     i2 \\<notin> dom ipassmt\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     i2 \\<notin> dom ipassmt\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n     ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n     i1 \\<noteq> i2 \\<longrightarrow>\n     ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n     ipcidr_union_set (set (the (ipassmt i2))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "using dom_ipassmt_ignore_wildcard"], ["proof (prove)\nusing this:\n  (?i \\<in> dom (ipassmt_ignore_wildcard ?ipassmt)) =\n  (?i \\<in> dom ?ipassmt \\<and>\n   ipcidr_union_set (set (the (?ipassmt ?i))) \\<noteq> UNIV)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     i2 \\<notin> dom ipassmt\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}\n 2. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n     ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n     i1 \\<noteq> i2 \\<longrightarrow>\n     ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n     ipcidr_union_set (set (the (ipassmt i2))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt i1 = Some ips1;\n     ipassmt_ignore_wildcard ipassmt i2 = Some ips2; i1 \\<noteq> i2;\n     ipcidr_union_set (set (the (ipassmt i1))) \\<noteq> UNIV \\<and>\n     ipcidr_union_set (set (the (ipassmt i2))) \\<noteq> UNIV \\<and>\n     i1 \\<noteq> i2 \\<longrightarrow>\n     ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n     ipcidr_union_set (set (the (ipassmt i2))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips1) \\<inter>\n                      ipcidr_union_set (set ips2) =\n                      {}", "by(simp add: ipassmt_ignore_wildcard_the)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Confusing names: @{const ipassmt_sanity_nowildcards} refers to wildcard interfaces.\n       @{const ipassmt_ignore_wildcard} refers to the UNIV ip range.\n\\<close>"], ["", "lemma ipassmt_sanity_nowildcards_ignore_wildcardD:\n    \"ipassmt_sanity_nowildcards ipassmt \\<Longrightarrow> ipassmt_sanity_nowildcards (ipassmt_ignore_wildcard ipassmt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_sanity_nowildcards ipassmt \\<Longrightarrow>\n    ipassmt_sanity_nowildcards (ipassmt_ignore_wildcard ipassmt)", "by (simp add: dom_ipassmt_ignore_wildcard ipassmt_sanity_nowildcards_def)"], ["", "lemma ipassmt_disjoint_nonempty_inj:\n     assumes ipassmt_disjoint: \"ipassmt_sanity_disjoint ipassmt\"\n        and ifce: \"ipassmt ifce = Some i_ips\"\n        and a: \"ipcidr_union_set (set i_ips) \\<noteq> {}\"\n        and k: \"ipassmt k = Some i_ips\"\n     shows \"k = ifce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = ifce", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "assume \"k \\<noteq> ifce\""], ["proof (state)\nthis:\n  k \\<noteq> ifce\n\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "with ifce k ipassmt_disjoint"], ["proof (chain)\npicking this:\n  ipassmt ifce = Some i_ips\n  ipassmt k = Some i_ips\n  ipassmt_sanity_disjoint ipassmt\n  k \\<noteq> ifce", "have \"ipcidr_union_set (set (the (ipassmt k))) \\<inter> ipcidr_union_set (set (the (ipassmt ifce))) = {}\""], ["proof (prove)\nusing this:\n  ipassmt ifce = Some i_ips\n  ipassmt k = Some i_ips\n  ipassmt_sanity_disjoint ipassmt\n  k \\<noteq> ifce\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n    ipcidr_union_set (set (the (ipassmt ifce))) =\n    {}", "unfolding ipassmt_sanity_disjoint_def"], ["proof (prove)\nusing this:\n  ipassmt ifce = Some i_ips\n  ipassmt k = Some i_ips\n  \\<forall>i1\\<in>dom ipassmt.\n     \\<forall>i2\\<in>dom ipassmt.\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt i2))) =\n        {}\n  k \\<noteq> ifce\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n    ipcidr_union_set (set (the (ipassmt ifce))) =\n    {}", "by fastforce"], ["proof (state)\nthis:\n  ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n  ipcidr_union_set (set (the (ipassmt ifce))) =\n  {}\n\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n  ipcidr_union_set (set (the (ipassmt ifce))) =\n  {}\n\ngoal (1 subgoal):\n 1. False", "using a ifce k"], ["proof (prove)\nusing this:\n  ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n  ipcidr_union_set (set (the (ipassmt ifce))) =\n  {}\n  ipcidr_union_set (set i_ips) \\<noteq> {}\n  ipassmt ifce = Some i_ips\n  ipassmt k = Some i_ips\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipassmt_ignore_wildcard_None_Some:\n    \"ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> ipassmt ifce = Some ips \\<Longrightarrow> ipcidr_union_set (set ips) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipassmt_ignore_wildcard ipassmt ifce = None;\n     ipassmt ifce = Some ips\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set ips) = UNIV", "by (metis domI domIff dom_ipassmt_ignore_wildcard option.sel)"], ["", "(*can this lemma be somehow useful?\n   maybe when rewriting, we can try to rewrite in the ignore_wildcard space and just constrain the the other area?*)"], ["", "lemma ipassmt_disjoint_ignore_wildcard_nonempty_inj:\n     assumes ipassmt_disjoint: \"ipassmt_sanity_disjoint (ipassmt_ignore_wildcard ipassmt)\"\n        and ifce: \"ipassmt ifce = Some i_ips\"\n        and a: \"ipcidr_union_set (set i_ips) \\<noteq> {}\"\n        and k: \"(ipassmt_ignore_wildcard ipassmt) k = Some i_ips\"\n     shows \"k = ifce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = ifce", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "assume \"k \\<noteq> ifce\""], ["proof (state)\nthis:\n  k \\<noteq> ifce\n\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"(ipassmt_ignore_wildcard ipassmt) ifce\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False\n 2. \\<And>a.\n       ipassmt_ignore_wildcard ipassmt ifce = Some a \\<Longrightarrow> False", "case (Some i_ips')"], ["proof (state)\nthis:\n  ipassmt_ignore_wildcard ipassmt ifce = Some i_ips'\n\ngoal (2 subgoals):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False\n 2. \\<And>a.\n       ipassmt_ignore_wildcard ipassmt ifce = Some a \\<Longrightarrow> False", "(*proofs mainly by sledgehammer*)"], ["proof (state)\nthis:\n  ipassmt_ignore_wildcard ipassmt ifce = Some i_ips'\n\ngoal (2 subgoals):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False\n 2. \\<And>a.\n       ipassmt_ignore_wildcard ipassmt ifce = Some a \\<Longrightarrow> False", "hence \"i_ips' = i_ips\""], ["proof (prove)\nusing this:\n  ipassmt_ignore_wildcard ipassmt ifce = Some i_ips'\n\ngoal (1 subgoal):\n 1. i_ips' = i_ips", "using ifce ipassmt_ignore_wildcard_the(2)"], ["proof (prove)\nusing this:\n  ipassmt_ignore_wildcard ipassmt ifce = Some i_ips'\n  ipassmt ifce = Some i_ips\n  ipassmt_ignore_wildcard ?ipassmt ?i = Some ?ips \\<Longrightarrow>\n  the (?ipassmt ?i) = ?ips\n\ngoal (1 subgoal):\n 1. i_ips' = i_ips", "by fastforce"], ["proof (state)\nthis:\n  i_ips' = i_ips\n\ngoal (2 subgoals):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False\n 2. \\<And>a.\n       ipassmt_ignore_wildcard ipassmt ifce = Some a \\<Longrightarrow> False", "hence \"(ipassmt_ignore_wildcard ipassmt) k = Some i_ips\""], ["proof (prove)\nusing this:\n  i_ips' = i_ips\n\ngoal (1 subgoal):\n 1. ipassmt_ignore_wildcard ipassmt k = Some i_ips", "using Some ifce ipassmt_ignore_wildcard_def k"], ["proof (prove)\nusing this:\n  i_ips' = i_ips\n  ipassmt_ignore_wildcard ipassmt ifce = Some i_ips'\n  ipassmt ifce = Some i_ips\n  ipassmt_ignore_wildcard ?ipassmt \\<equiv>\n  \\<lambda>k.\n     case ?ipassmt k of None \\<Rightarrow> None\n     | Some ips \\<Rightarrow>\n         if ipcidr_union_set (set ips) = UNIV then None else Some ips\n  ipassmt_ignore_wildcard ipassmt k = Some i_ips\n\ngoal (1 subgoal):\n 1. ipassmt_ignore_wildcard ipassmt k = Some i_ips", "by auto"], ["proof (state)\nthis:\n  ipassmt_ignore_wildcard ipassmt k = Some i_ips\n\ngoal (2 subgoals):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False\n 2. \\<And>a.\n       ipassmt_ignore_wildcard ipassmt ifce = Some a \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ipassmt_ignore_wildcard ipassmt k = Some i_ips\n\ngoal (1 subgoal):\n 1. False", "using Some \\<open>i_ips' = i_ips\\<close> \\<open>k \\<noteq> ifce\\<close> a ipassmt_disjoint ipassmt_disjoint_nonempty_inj"], ["proof (prove)\nusing this:\n  ipassmt_ignore_wildcard ipassmt k = Some i_ips\n  ipassmt_ignore_wildcard ipassmt ifce = Some i_ips'\n  i_ips' = i_ips\n  k \\<noteq> ifce\n  ipcidr_union_set (set i_ips) \\<noteq> {}\n  ipassmt_sanity_disjoint (ipassmt_ignore_wildcard ipassmt)\n  \\<lbrakk>ipassmt_sanity_disjoint ?ipassmt; ?ipassmt ?ifce = Some ?i_ips;\n   ipcidr_union_set (set ?i_ips) \\<noteq> {};\n   ?ipassmt ?k = Some ?i_ips\\<rbrakk>\n  \\<Longrightarrow> ?k = ?ifce\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False", "case None"], ["proof (state)\nthis:\n  ipassmt_ignore_wildcard ipassmt ifce = None\n\ngoal (1 subgoal):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False", "with ipassmt_ignore_wildcard_None_Some"], ["proof (chain)\npicking this:\n  \\<lbrakk>ipassmt_ignore_wildcard ?ipassmt ?ifce = None;\n   ?ipassmt ?ifce = Some ?ips\\<rbrakk>\n  \\<Longrightarrow> ipcidr_union_set (set ?ips) = UNIV\n  ipassmt_ignore_wildcard ipassmt ifce = None", "have \"ipcidr_union_set (set i_ips) = UNIV\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ipassmt_ignore_wildcard ?ipassmt ?ifce = None;\n   ?ipassmt ?ifce = Some ?ips\\<rbrakk>\n  \\<Longrightarrow> ipcidr_union_set (set ?ips) = UNIV\n  ipassmt_ignore_wildcard ipassmt ifce = None\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set i_ips) = UNIV", "using ifce"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipassmt_ignore_wildcard ?ipassmt ?ifce = None;\n   ?ipassmt ?ifce = Some ?ips\\<rbrakk>\n  \\<Longrightarrow> ipcidr_union_set (set ?ips) = UNIV\n  ipassmt_ignore_wildcard ipassmt ifce = None\n  ipassmt ifce = Some i_ips\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set i_ips) = UNIV", "by auto"], ["proof (state)\nthis:\n  ipcidr_union_set (set i_ips) = UNIV\n\ngoal (1 subgoal):\n 1. ipassmt_ignore_wildcard ipassmt ifce = None \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ipcidr_union_set (set i_ips) = UNIV\n\ngoal (1 subgoal):\n 1. False", "using ipassmt_ignore_wildcard_the(3) k"], ["proof (prove)\nusing this:\n  ipcidr_union_set (set i_ips) = UNIV\n  ipassmt_ignore_wildcard ?ipassmt ?i = Some ?ips \\<Longrightarrow>\n  ipcidr_union_set (set ?ips) \\<noteq> UNIV\n  ipassmt_ignore_wildcard ipassmt k = Some i_ips\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipassmt_disjoint_inj_k: \n     assumes ipassmt_disjoint: \"ipassmt_sanity_disjoint ipassmt\"\n        and ifce: \"ipassmt ifce = Some ips\"\n        and k: \"ipassmt k = Some ips'\"\n        and a: \"p \\<in> ipcidr_union_set (set ips)\"\n        and b: \"p \\<in> ipcidr_union_set (set ips')\"\n     shows \"k = ifce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = ifce", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "assume \"k \\<noteq> ifce\""], ["proof (state)\nthis:\n  k \\<noteq> ifce\n\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "with ipassmt_disjoint"], ["proof (chain)\npicking this:\n  ipassmt_sanity_disjoint ipassmt\n  k \\<noteq> ifce", "have\n          \"ipcidr_union_set (set (the (ipassmt k))) \\<inter> ipcidr_union_set (set (the (ipassmt ifce))) = {}\""], ["proof (prove)\nusing this:\n  ipassmt_sanity_disjoint ipassmt\n  k \\<noteq> ifce\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n    ipcidr_union_set (set (the (ipassmt ifce))) =\n    {}", "unfolding ipassmt_sanity_disjoint_def"], ["proof (prove)\nusing this:\n  \\<forall>i1\\<in>dom ipassmt.\n     \\<forall>i2\\<in>dom ipassmt.\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt i2))) =\n        {}\n  k \\<noteq> ifce\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n    ipcidr_union_set (set (the (ipassmt ifce))) =\n    {}", "using ifce k"], ["proof (prove)\nusing this:\n  \\<forall>i1\\<in>dom ipassmt.\n     \\<forall>i2\\<in>dom ipassmt.\n        i1 \\<noteq> i2 \\<longrightarrow>\n        ipcidr_union_set (set (the (ipassmt i1))) \\<inter>\n        ipcidr_union_set (set (the (ipassmt i2))) =\n        {}\n  k \\<noteq> ifce\n  ipassmt ifce = Some ips\n  ipassmt k = Some ips'\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n    ipcidr_union_set (set (the (ipassmt ifce))) =\n    {}", "by blast"], ["proof (state)\nthis:\n  ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n  ipcidr_union_set (set (the (ipassmt ifce))) =\n  {}\n\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "hence \"ipcidr_union_set (set ips') \\<inter> ipcidr_union_set (set ips) = {}\""], ["proof (prove)\nusing this:\n  ipcidr_union_set (set (the (ipassmt k))) \\<inter>\n  ipcidr_union_set (set (the (ipassmt ifce))) =\n  {}\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set ips') \\<inter> ipcidr_union_set (set ips) = {}", "by(simp add: k ifce)"], ["proof (state)\nthis:\n  ipcidr_union_set (set ips') \\<inter> ipcidr_union_set (set ips) = {}\n\ngoal (1 subgoal):\n 1. k \\<noteq> ifce \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ipcidr_union_set (set ips') \\<inter> ipcidr_union_set (set ips) = {}\n\ngoal (1 subgoal):\n 1. False", "using a b"], ["proof (prove)\nusing this:\n  ipcidr_union_set (set ips') \\<inter> ipcidr_union_set (set ips) = {}\n  p \\<in> ipcidr_union_set (set ips)\n  p \\<in> ipcidr_union_set (set ips')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(*might also work when we ignore UNIVs in the ipassmt? (not tested)*)"], ["", "lemma ipassmt_disjoint_matcheq_iifce_srcip:\n        assumes ipassmt_nowild: \"ipassmt_sanity_nowildcards ipassmt\"\n            and ipassmt_disjoint: \"ipassmt_sanity_disjoint ipassmt\"\n            and ifce: \"ipassmt ifce = Some i_ips\"\n            and p_ifce: \"ipassmt (Iface (p_iiface p)) = Some p_ips \\<and> p_src p \\<in> ipcidr_union_set (set p_ips)\"\n        shows   \"match_iface ifce (p_iiface p) \\<longleftrightarrow> p_src p \\<in> ipcidr_union_set (set i_ips)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_iface ifce (p_iiface p) =\n    (p_src p \\<in> ipcidr_union_set (set i_ips))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. match_iface ifce (p_iiface p) \\<Longrightarrow>\n    p_src p \\<in> ipcidr_union_set (set i_ips)\n 2. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "assume \"match_iface ifce (p_iiface p)\""], ["proof (state)\nthis:\n  match_iface ifce (p_iiface p)\n\ngoal (2 subgoals):\n 1. match_iface ifce (p_iiface p) \\<Longrightarrow>\n    p_src p \\<in> ipcidr_union_set (set i_ips)\n 2. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "thus \"p_src p \\<in> ipcidr_union_set (set i_ips)\""], ["proof (prove)\nusing this:\n  match_iface ifce (p_iiface p)\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set i_ips)", "apply(cases \"ifce = Iface (p_iiface p)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>match_iface ifce (p_iiface p);\n     ifce = Iface (p_iiface p)\\<rbrakk>\n    \\<Longrightarrow> p_src p \\<in> ipcidr_union_set (set i_ips)\n 2. \\<lbrakk>match_iface ifce (p_iiface p);\n     ifce \\<noteq> Iface (p_iiface p)\\<rbrakk>\n    \\<Longrightarrow> p_src p \\<in> ipcidr_union_set (set i_ips)", "using ifce p_ifce"], ["proof (prove)\nusing this:\n  ipassmt ifce = Some i_ips\n  ipassmt (Iface (p_iiface p)) = Some p_ips \\<and>\n  p_src p \\<in> ipcidr_union_set (set p_ips)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>match_iface ifce (p_iiface p);\n     ifce = Iface (p_iiface p)\\<rbrakk>\n    \\<Longrightarrow> p_src p \\<in> ipcidr_union_set (set i_ips)\n 2. \\<lbrakk>match_iface ifce (p_iiface p);\n     ifce \\<noteq> Iface (p_iiface p)\\<rbrakk>\n    \\<Longrightarrow> p_src p \\<in> ipcidr_union_set (set i_ips)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match_iface ifce (p_iiface p);\n     ifce \\<noteq> Iface (p_iiface p)\\<rbrakk>\n    \\<Longrightarrow> p_src p \\<in> ipcidr_union_set (set i_ips)", "by (metis domI iface.sel iface_is_wildcard_def ifce ipassmt_nowild ipassmt_sanity_nowildcards_def match_iface.elims(2) match_iface_case_nowildcard)"], ["proof (state)\nthis:\n  p_src p \\<in> ipcidr_union_set (set i_ips)\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "assume a: \"p_src p \\<in> ipcidr_union_set (set i_ips)\"\n     \\<comment> \\<open>basically, we need to reverse the map @{term ipassmt}\\<close>"], ["proof (state)\nthis:\n  p_src p \\<in> ipcidr_union_set (set i_ips)\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "from ipassmt_disjoint_nonempty_inj[OF ipassmt_disjoint ifce] a"], ["proof (chain)\npicking this:\n  \\<lbrakk>ipcidr_union_set (set i_ips) \\<noteq> {};\n   ipassmt ?k = Some i_ips\\<rbrakk>\n  \\<Longrightarrow> ?k = ifce\n  p_src p \\<in> ipcidr_union_set (set i_ips)", "have ipassmt_inj: \"\\<forall>k. ipassmt k = Some i_ips \\<longrightarrow> k = ifce\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ipcidr_union_set (set i_ips) \\<noteq> {};\n   ipassmt ?k = Some i_ips\\<rbrakk>\n  \\<Longrightarrow> ?k = ifce\n  p_src p \\<in> ipcidr_union_set (set i_ips)\n\ngoal (1 subgoal):\n 1. \\<forall>k. ipassmt k = Some i_ips \\<longrightarrow> k = ifce", "by blast"], ["proof (state)\nthis:\n  \\<forall>k. ipassmt k = Some i_ips \\<longrightarrow> k = ifce\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "from ipassmt_disjoint_inj_k[OF ipassmt_disjoint ifce _ a]"], ["proof (chain)\npicking this:\n  \\<lbrakk>ipassmt ?k = Some ?ips';\n   p_src p \\<in> ipcidr_union_set (set ?ips')\\<rbrakk>\n  \\<Longrightarrow> ?k = ifce", "have ipassmt_inj_k:\n      \"\\<And>k ips'. ipassmt k = Some ips' \\<Longrightarrow> p_src p \\<in> ipcidr_union_set (set ips') \\<Longrightarrow> k = ifce\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ipassmt ?k = Some ?ips';\n   p_src p \\<in> ipcidr_union_set (set ?ips')\\<rbrakk>\n  \\<Longrightarrow> ?k = ifce\n\ngoal (1 subgoal):\n 1. \\<And>k ips'.\n       \\<lbrakk>ipassmt k = Some ips';\n        p_src p \\<in> ipcidr_union_set (set ips')\\<rbrakk>\n       \\<Longrightarrow> k = ifce", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>ipassmt ?k = Some ?ips';\n   p_src p \\<in> ipcidr_union_set (set ?ips')\\<rbrakk>\n  \\<Longrightarrow> ?k = ifce\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "have ipassmt_inj_p: \"\\<forall>ips'. p_src p \\<in> ipcidr_union_set (set ips') \\<and> (\\<exists>k. ipassmt k = Some ips') \\<longrightarrow> ips' = i_ips\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ips'.\n       p_src p \\<in> ipcidr_union_set (set ips') \\<and>\n       (\\<exists>k. ipassmt k = Some ips') \\<longrightarrow>\n       ips' = i_ips", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ips' k.\n       \\<lbrakk>p_src p \\<in> ipcidr_union_set (set ips');\n        ipassmt k = Some ips'\\<rbrakk>\n       \\<Longrightarrow> ips' = i_ips", "apply(rename_tac ips' k)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ips' k.\n       \\<lbrakk>p_src p \\<in> ipcidr_union_set (set ips');\n        ipassmt k = Some ips'\\<rbrakk>\n       \\<Longrightarrow> ips' = i_ips", "apply(subgoal_tac \"k = ifce\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ips' k.\n       \\<lbrakk>p_src p \\<in> ipcidr_union_set (set ips');\n        ipassmt k = Some ips'; k = ifce\\<rbrakk>\n       \\<Longrightarrow> ips' = i_ips\n 2. \\<And>ips' k.\n       \\<lbrakk>p_src p \\<in> ipcidr_union_set (set ips');\n        ipassmt k = Some ips'\\<rbrakk>\n       \\<Longrightarrow> k = ifce", "using ifce"], ["proof (prove)\nusing this:\n  ipassmt ifce = Some i_ips\n\ngoal (2 subgoals):\n 1. \\<And>ips' k.\n       \\<lbrakk>p_src p \\<in> ipcidr_union_set (set ips');\n        ipassmt k = Some ips'; k = ifce\\<rbrakk>\n       \\<Longrightarrow> ips' = i_ips\n 2. \\<And>ips' k.\n       \\<lbrakk>p_src p \\<in> ipcidr_union_set (set ips');\n        ipassmt k = Some ips'\\<rbrakk>\n       \\<Longrightarrow> k = ifce", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ips' k.\n       \\<lbrakk>p_src p \\<in> ipcidr_union_set (set ips');\n        ipassmt k = Some ips'\\<rbrakk>\n       \\<Longrightarrow> k = ifce", "using ipassmt_inj_k"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipassmt ?k = Some ?ips';\n   p_src p \\<in> ipcidr_union_set (set ?ips')\\<rbrakk>\n  \\<Longrightarrow> ?k = ifce\n\ngoal (1 subgoal):\n 1. \\<And>ips' k.\n       \\<lbrakk>p_src p \\<in> ipcidr_union_set (set ips');\n        ipassmt k = Some ips'\\<rbrakk>\n       \\<Longrightarrow> k = ifce", "by simp"], ["proof (state)\nthis:\n  \\<forall>ips'.\n     p_src p \\<in> ipcidr_union_set (set ips') \\<and>\n     (\\<exists>k. ipassmt k = Some ips') \\<longrightarrow>\n     ips' = i_ips\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "from p_ifce"], ["proof (chain)\npicking this:\n  ipassmt (Iface (p_iiface p)) = Some p_ips \\<and>\n  p_src p \\<in> ipcidr_union_set (set p_ips)", "have \"(Iface (p_iiface p)) = ifce\""], ["proof (prove)\nusing this:\n  ipassmt (Iface (p_iiface p)) = Some p_ips \\<and>\n  p_src p \\<in> ipcidr_union_set (set p_ips)\n\ngoal (1 subgoal):\n 1. Iface (p_iiface p) = ifce", "using ipassmt_inj_p ipassmt_inj"], ["proof (prove)\nusing this:\n  ipassmt (Iface (p_iiface p)) = Some p_ips \\<and>\n  p_src p \\<in> ipcidr_union_set (set p_ips)\n  \\<forall>ips'.\n     p_src p \\<in> ipcidr_union_set (set ips') \\<and>\n     (\\<exists>k. ipassmt k = Some ips') \\<longrightarrow>\n     ips' = i_ips\n  \\<forall>k. ipassmt k = Some i_ips \\<longrightarrow> k = ifce\n\ngoal (1 subgoal):\n 1. Iface (p_iiface p) = ifce", "by blast"], ["proof (state)\nthis:\n  Iface (p_iiface p) = ifce\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set i_ips) \\<Longrightarrow>\n    match_iface ifce (p_iiface p)", "thus \"match_iface ifce (p_iiface p)\""], ["proof (prove)\nusing this:\n  Iface (p_iiface p) = ifce\n\ngoal (1 subgoal):\n 1. match_iface ifce (p_iiface p)", "using match_iface_refl"], ["proof (prove)\nusing this:\n  Iface (p_iiface p) = ifce\n  match_iface (Iface ?x) ?x\n\ngoal (1 subgoal):\n 1. match_iface ifce (p_iiface p)", "by blast"], ["proof (state)\nthis:\n  match_iface ifce (p_iiface p)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ipassmt_generic_ipv4 :: \"(iface \\<times> (32 word \\<times> nat) list) list\" where\n    \"ipassmt_generic_ipv4 = [(Iface ''lo'', [(ipv4addr_of_dotdecimal (127,0,0,0),8)])]\""], ["", "definition ipassmt_generic_ipv6 :: \"(iface \\<times> (128 word \\<times> nat) list) list\" where\n    \"ipassmt_generic_ipv6 = [(Iface ''lo'', [(1,128)])]\""], ["", "(*::1/128*)"], ["", "subsection\\<open>IP Assignment difference\\<close>"], ["", "text\\<open>Compare two ipassmts. Returns a list of tuples\n    First entry of the tuple: things which are in the left ipassmt but not in the right.\n    Second entry of the tupls: things which are in the right ipassmt but not in the left.\\<close>"], ["", "definition ipassmt_diff\n    :: \"(iface \\<times> ('i::len word \\<times> nat) list) list \\<Rightarrow> (iface \\<times> ('i::len word \\<times> nat) list) list\n        \\<Rightarrow> (iface \\<times> ('i word \\<times> nat) list \\<times> ('i word \\<times> nat) list) list\"\n  where\n  \"ipassmt_diff a b \\<equiv> let\n      t = \\<lambda>s. (case s of None \\<Rightarrow> Empty_WordInterval\n                       | Some s \\<Rightarrow> wordinterval_Union (map ipcidr_tuple_to_wordinterval s));\n      k = \\<lambda>x y d. cidr_split (wordinterval_setminus (t (map_of x d)) (t (map_of y d)))\n    in\n      [(d, (k a b d, k b a d)). d \\<leftarrow> remdups (map fst (a @ b))]\""], ["", "text\\<open>If an interface is defined in both ipassignments and there is no difference\n       then the two ipassignements describe the same IP range for this interface.\\<close>"], ["", "lemma ipassmt_diff_ifce_equal: \"(ifce, [], []) \\<in> set (ipassmt_diff ipassmt1 ipassmt2)  \\<Longrightarrow>\n         ifce \\<in> dom (map_of ipassmt1) \\<Longrightarrow> ifce \\<in> dom (map_of ipassmt2) \\<Longrightarrow>\n           ipcidr_union_set (set (the ((map_of ipassmt1) ifce))) =\n           ipcidr_union_set (set (the ((map_of ipassmt2) ifce)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ifce, [], []) \\<in> set (ipassmt_diff ipassmt1 ipassmt2);\n     ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set (the (map_of ipassmt1 ifce))) =\n                      ipcidr_union_set (set (the (map_of ipassmt2 ifce)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ifce, [], []) \\<in> set (ipassmt_diff ipassmt1 ipassmt2);\n     ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set (the (map_of ipassmt1 ifce))) =\n                      ipcidr_union_set (set (the (map_of ipassmt2 ifce)))", "have cidr_empty: \"[] = cidr_split r \\<Longrightarrow> wordinterval_to_set r = {}\" for r :: \"'a wordinterval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = cidr_split r \\<Longrightarrow> wordinterval_to_set r = {}", "apply(subst cidr_split_prefix[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = cidr_split r \\<Longrightarrow>\n    \\<Union> (uncurry ipset_from_cidr ` set (cidr_split r)) = {}", "by(simp)"], ["proof (state)\nthis:\n  [] = cidr_split ?r \\<Longrightarrow> wordinterval_to_set ?r = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(ifce, [], []) \\<in> set (ipassmt_diff ipassmt1 ipassmt2);\n     ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set (the (map_of ipassmt1 ifce))) =\n                      ipcidr_union_set (set (the (map_of ipassmt2 ifce)))", "show \"(ifce, [], []) \\<in> set (ipassmt_diff ipassmt1 ipassmt2)  \\<Longrightarrow>\n         ifce \\<in> dom (map_of ipassmt1) \\<Longrightarrow> ifce \\<in> dom (map_of ipassmt2) \\<Longrightarrow>\n           ipcidr_union_set (set (the ((map_of ipassmt1) ifce))) =\n           ipcidr_union_set (set (the ((map_of ipassmt2) ifce)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ifce, [], []) \\<in> set (ipassmt_diff ipassmt1 ipassmt2);\n     ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2)\\<rbrakk>\n    \\<Longrightarrow> ipcidr_union_set (set (the (map_of ipassmt1 ifce))) =\n                      ipcidr_union_set (set (the (map_of ipassmt2 ifce)))", "apply(simp add: ipassmt_diff_def Let_def ipcidr_union_set_uncurry)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ifce, [], [])\n             \\<in> (\\<lambda>x.\n                       (x, cidr_split\n                            (wordinterval_setminus\n                              (case map_of ipassmt1 x of\n                               None \\<Rightarrow> Empty_WordInterval\n                               | Some s \\<Rightarrow>\n                                   wordinterval_Union\n                                    (map ipcidr_tuple_to_wordinterval s))\n                              (case map_of ipassmt2 x of\n                               None \\<Rightarrow> Empty_WordInterval\n                               | Some s \\<Rightarrow>\n                                   wordinterval_Union\n                                    (map ipcidr_tuple_to_wordinterval s))),\n                        cidr_split\n                         (wordinterval_setminus\n                           (case map_of ipassmt2 x of\n                            None \\<Rightarrow> Empty_WordInterval\n                            | Some s \\<Rightarrow>\n                                wordinterval_Union\n                                 (map ipcidr_tuple_to_wordinterval s))\n                           (case map_of ipassmt1 x of\n                            None \\<Rightarrow> Empty_WordInterval\n                            | Some s \\<Rightarrow>\n                                wordinterval_Union\n                                 (map ipcidr_tuple_to_wordinterval s))))) `\n                   (fst ` set ipassmt1 \\<union> fst ` set ipassmt2);\n     ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2)\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt1 ifce))) =\n                      \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt2 ifce)))", "apply(simp add: Set.image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<exists>x\\<in>set ipassmt1. ifce = fst x) \\<or>\n              (\\<exists>x\\<in>set ipassmt2. ifce = fst x)) \\<and>\n             [] =\n             cidr_split\n              (wordinterval_setminus\n                (case map_of ipassmt1 ifce of\n                 None \\<Rightarrow> Empty_WordInterval\n                 | Some s \\<Rightarrow>\n                     wordinterval_Union\n                      (map ipcidr_tuple_to_wordinterval s))\n                (case map_of ipassmt2 ifce of\n                 None \\<Rightarrow> Empty_WordInterval\n                 | Some s \\<Rightarrow>\n                     wordinterval_Union\n                      (map ipcidr_tuple_to_wordinterval s))) \\<and>\n             [] =\n             cidr_split\n              (wordinterval_setminus\n                (case map_of ipassmt2 ifce of\n                 None \\<Rightarrow> Empty_WordInterval\n                 | Some s \\<Rightarrow>\n                     wordinterval_Union\n                      (map ipcidr_tuple_to_wordinterval s))\n                (case map_of ipassmt1 ifce of\n                 None \\<Rightarrow> Empty_WordInterval\n                 | Some s \\<Rightarrow>\n                     wordinterval_Union\n                      (map ipcidr_tuple_to_wordinterval s)));\n     ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2)\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt1 ifce))) =\n                      \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt2 ifce)))", "apply(elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2);\n     (\\<exists>x\\<in>set ipassmt1. ifce = fst x) \\<or>\n     (\\<exists>x\\<in>set ipassmt2. ifce = fst x);\n     [] =\n     cidr_split\n      (wordinterval_setminus\n        (case map_of ipassmt1 ifce of None \\<Rightarrow> Empty_WordInterval\n         | Some s \\<Rightarrow>\n             wordinterval_Union (map ipcidr_tuple_to_wordinterval s))\n        (case map_of ipassmt2 ifce of None \\<Rightarrow> Empty_WordInterval\n         | Some s \\<Rightarrow>\n             wordinterval_Union (map ipcidr_tuple_to_wordinterval s)));\n     [] =\n     cidr_split\n      (wordinterval_setminus\n        (case map_of ipassmt2 ifce of None \\<Rightarrow> Empty_WordInterval\n         | Some s \\<Rightarrow>\n             wordinterval_Union (map ipcidr_tuple_to_wordinterval s))\n        (case map_of ipassmt1 ifce of None \\<Rightarrow> Empty_WordInterval\n         | Some s \\<Rightarrow>\n             wordinterval_Union\n              (map ipcidr_tuple_to_wordinterval s)))\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt1 ifce))) =\n                      \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt2 ifce)))", "apply(drule cidr_empty)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2);\n     (\\<exists>x\\<in>set ipassmt1. ifce = fst x) \\<or>\n     (\\<exists>x\\<in>set ipassmt2. ifce = fst x);\n     wordinterval_to_set\n      (wordinterval_setminus\n        (case map_of ipassmt1 ifce of None \\<Rightarrow> Empty_WordInterval\n         | Some s \\<Rightarrow>\n             wordinterval_Union (map ipcidr_tuple_to_wordinterval s))\n        (case map_of ipassmt2 ifce of None \\<Rightarrow> Empty_WordInterval\n         | Some s \\<Rightarrow>\n             wordinterval_Union (map ipcidr_tuple_to_wordinterval s))) =\n     {};\n     wordinterval_to_set\n      (wordinterval_setminus\n        (case map_of ipassmt2 ifce of None \\<Rightarrow> Empty_WordInterval\n         | Some s \\<Rightarrow>\n             wordinterval_Union (map ipcidr_tuple_to_wordinterval s))\n        (case map_of ipassmt1 ifce of None \\<Rightarrow> Empty_WordInterval\n         | Some s \\<Rightarrow>\n             wordinterval_Union (map ipcidr_tuple_to_wordinterval s))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt1 ifce))) =\n                      \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt2 ifce)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ifce \\<in> dom (map_of ipassmt1);\n     ifce \\<in> dom (map_of ipassmt2);\n     (\\<exists>x\\<in>set ipassmt1. ifce = fst x) \\<or>\n     (\\<exists>x\\<in>set ipassmt2. ifce = fst x);\n     wordinterval_to_set\n      (case map_of ipassmt2 ifce of None \\<Rightarrow> Empty_WordInterval\n       | Some s \\<Rightarrow>\n           wordinterval_Union (map ipcidr_tuple_to_wordinterval s)) =\n     wordinterval_to_set\n      (case map_of ipassmt1 ifce of None \\<Rightarrow> Empty_WordInterval\n       | Some s \\<Rightarrow>\n           wordinterval_Union (map ipcidr_tuple_to_wordinterval s))\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt1 ifce))) =\n                      \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt2 ifce)))", "apply(simp add: domIff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>y. map_of ipassmt1 ifce = Some y;\n     \\<exists>y. map_of ipassmt2 ifce = Some y;\n     (\\<exists>x\\<in>set ipassmt1. ifce = fst x) \\<or>\n     (\\<exists>x\\<in>set ipassmt2. ifce = fst x);\n     wordinterval_to_set\n      (case map_of ipassmt2 ifce of None \\<Rightarrow> Empty_WordInterval\n       | Some s \\<Rightarrow>\n           wordinterval_Union (map ipcidr_tuple_to_wordinterval s)) =\n     wordinterval_to_set\n      (case map_of ipassmt1 ifce of None \\<Rightarrow> Empty_WordInterval\n       | Some s \\<Rightarrow>\n           wordinterval_Union (map ipcidr_tuple_to_wordinterval s))\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt1 ifce))) =\n                      \\<Union>\n                       (uncurry ipset_from_cidr `\n                        set (the (map_of ipassmt2 ifce)))", "apply(elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya.\n       \\<lbrakk>(\\<exists>x\\<in>set ipassmt1. ifce = fst x) \\<or>\n                (\\<exists>x\\<in>set ipassmt2. ifce = fst x);\n        wordinterval_to_set\n         (case map_of ipassmt2 ifce of None \\<Rightarrow> Empty_WordInterval\n          | Some s \\<Rightarrow>\n              wordinterval_Union (map ipcidr_tuple_to_wordinterval s)) =\n        wordinterval_to_set\n         (case map_of ipassmt1 ifce of None \\<Rightarrow> Empty_WordInterval\n          | Some s \\<Rightarrow>\n              wordinterval_Union (map ipcidr_tuple_to_wordinterval s));\n        map_of ipassmt1 ifce = Some y;\n        map_of ipassmt2 ifce = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (uncurry ipset_from_cidr `\n                           set (the (map_of ipassmt1 ifce))) =\n                         \\<Union>\n                          (uncurry ipset_from_cidr `\n                           set (the (map_of ipassmt2 ifce)))", "apply(simp add: wordinterval_Union wordinterval_to_set_ipcidr_tuple_to_wordinterval_uncurry)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>(ifce, [], []) \\<in> set (ipassmt_diff ipassmt1 ipassmt2);\n   ifce \\<in> dom (map_of ipassmt1);\n   ifce \\<in> dom (map_of ipassmt2)\\<rbrakk>\n  \\<Longrightarrow> ipcidr_union_set (set (the (map_of ipassmt1 ifce))) =\n                    ipcidr_union_set (set (the (map_of ipassmt2 ifce)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipcidr_union_cidr_split[simp]: \"ipcidr_union_set (set (cidr_split a)) = wordinterval_to_set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (cidr_split a)) = wordinterval_to_set a", "by(simp add: ipcidr_union_set_uncurry cidr_split_prefix)"], ["", "lemma \n    defines \"assmt as ifce \\<equiv> ipcidr_union_set (set (the ((map_of as ifce))))\"\n    assumes diffs: \"(ifce, d1, d2) \\<in> set (ipassmt_diff ipassmt1 ipassmt2)\"\n        and  doms: \"ifce \\<in> dom (map_of ipassmt1)\" \"ifce \\<in> dom (map_of ipassmt2)\"\n    shows \"ipcidr_union_set (set d1) = assmt ipassmt1 ifce - assmt ipassmt2 ifce\"\n          \"ipcidr_union_set (set d2) = assmt ipassmt2 ifce - assmt ipassmt1 ifce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set (set d1) =\n    assmt ipassmt1 ifce - assmt ipassmt2 ifce &&&\n    ipcidr_union_set (set d2) = assmt ipassmt2 ifce - assmt ipassmt1 ifce", "using assms"], ["proof (prove)\nusing this:\n  assmt ?as ?ifce \\<equiv> ipcidr_union_set (set (the (map_of ?as ?ifce)))\n  (ifce, d1, d2) \\<in> set (ipassmt_diff ipassmt1 ipassmt2)\n  ifce \\<in> dom (map_of ipassmt1)\n  ifce \\<in> dom (map_of ipassmt2)\n\ngoal (1 subgoal):\n 1. ipcidr_union_set (set d1) =\n    assmt ipassmt1 ifce - assmt ipassmt2 ifce &&&\n    ipcidr_union_set (set d2) = assmt ipassmt2 ifce - assmt ipassmt1 ifce", "by (clarsimp simp add: ipassmt_diff_def Let_def assmt_def wordinterval_Union; simp add: ipcidr_union_set_uncurry uncurry_def wordinterval_to_set_ipcidr_tuple_to_wordinterval_uncurry)+"], ["", "text\\<open>Explanation for interface @{term \"Iface ''a''\"}: \n          Left ipassmt: The IP range 4/30 contains the addresses 4,5,6,7\n          Diff: right ipassmt contains 6/32, so 4,5,7 is only in the left ipassmt.\n          IP addresses 4,5 correspond to subnet 4/30.\\<close>"], ["", "lemma \"ipassmt_diff (ipassmt_generic_ipv4 @ [(Iface ''a'', [(4,30)])])\n                       (ipassmt_generic_ipv4 @ [(Iface ''a'', [(6,32), (0,30)]), (Iface ''b'', [(42,32)])]) =\n    [(Iface ''lo'', [], []),\n     (Iface ''a'', [(4, 31),(7, 32)],\n                   [(0, 30)]\n     ),\n     (Iface ''b'', [], [(42, 32)])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipassmt_diff (ipassmt_generic_ipv4 @ [(Iface ''a'', [(4, 30)])])\n     (ipassmt_generic_ipv4 @\n      [(Iface ''a'', [(6, 32), (0, 30)]), (Iface ''b'', [(42, 32)])]) =\n    [(Iface ''lo'', [], []), (Iface ''a'', [(4, 31), (7, 32)], [(0, 30)]),\n     (Iface ''b'', [], [(42, 32)])]", "by eval"], ["", "end"]]}