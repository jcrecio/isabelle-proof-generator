{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Example_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma[simp]: \"Semantics.matches applies_Yes MatchAny p\"", "lemma[simp]: \"Semantics.matches applies_Yes (Match e) p\"", "lemma[simp]: \"Semantics.matches applies_Yes m p\"", "lemma \"[''FORWARD'' \\<mapsto> [(Rule m Log), (Rule m Accept), (Rule m Drop)]],applies_Yes,p\\<turnstile>\n      \\<langle>[Rule MatchAny (Call ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> (Decision FinalAllow)\"", "lemma \"[''FORWARD'' \\<mapsto> [(Rule m Log), (Rule m (Call ''foo'')), (Rule m Accept)],\n          ''foo'' \\<mapsto> [(Rule m Log), (Rule m Return)]],applies_Yes,p\\<turnstile>\n      \\<langle>[Rule MatchAny (Call ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> (Decision FinalAllow)\"", "lemma \"[''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \\<mapsto> []],applies_Yes,p\\<turnstile>\n            \\<langle>[Rule MatchAny (Call ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> (Decision FinalDeny)\"", "lemma \"((\\<lambda>rs. process_call [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \\<mapsto> []] rs)^^2)\n                    [Rule MatchAny (Call ''FORWARD'')]\n         = [Rule (MatchAnd MatchAny m) Drop]\"", "lemma \"[''FORWARD'' \\<mapsto> [ Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0)))) Reject, \n                          Rule (Match (Dst (IpAddr 0))) Log, \n                          Rule (Match (Prot (Proto TCP))) Accept,\n                          Rule (Match (Prot (Proto TCP))) Drop]\n         ],applies_exampleMatchExact, pkt\\<lparr>p_src:=(ipv4addr_of_dotdecimal (1,2,3,4)), p_dst:=(ipv4addr_of_dotdecimal (0,0,0,0))\\<rparr>\\<turnstile>\n            \\<langle>[Rule MatchAny (Call ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> (Decision FinalAllow)\""], "translations": [["", "lemma[simp]: \"Semantics.matches applies_Yes MatchAny p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Semantics.matches applies_Yes MatchAny p", "by simp"], ["", "lemma[simp]: \"Semantics.matches applies_Yes (Match e) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Semantics.matches applies_Yes (Match e) p", "by simp"], ["", "definition \"m=Match (Src (IpAddr (0::ipv4addr)))\""], ["", "lemma[simp]: \"Semantics.matches applies_Yes m p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Semantics.matches applies_Yes m p", "by (simp add: m_def)"], ["", "lemma \"[''FORWARD'' \\<mapsto> [(Rule m Log), (Rule m Accept), (Rule m Drop)]],applies_Yes,p\\<turnstile>\n      \\<langle>[Rule MatchAny (Call ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> (Decision FinalAllow)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>[Rule MatchAny\n             (Call\n               ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> Decision\n                          FinalAllow", "apply(rule call_result)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Semantics.matches applies_Yes MatchAny p\n 2. [''FORWARD'' \\<mapsto> [Rule m Log, Rule m Accept, Rule m Drop]]\n     ''FORWARD'' =\n    Some ?rs\n 3. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> Decision\n            FinalAllow", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>[Rule m Log, Rule m Accept,\n            Rule m\n             Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n             Log], Undecided\\<rangle> \\<Rightarrow> ?t5\n 2. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>[Rule m Accept,\n            Rule m Drop], ?t5\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto intro:Semantics.log)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>[Rule m Accept,\n            Rule m\n             Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n             Accept], Undecided\\<rangle> \\<Rightarrow> ?t11\n 2. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n             Drop], ?t11\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto intro: Semantics.accept)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m Accept,\n      Rule m\n       Drop]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n             Drop], Decision\n                     FinalAllow\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule Semantics.decision)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"[''FORWARD'' \\<mapsto> [(Rule m Log), (Rule m (Call ''foo'')), (Rule m Accept)],\n          ''foo'' \\<mapsto> [(Rule m Log), (Rule m Return)]],applies_Yes,p\\<turnstile>\n      \\<langle>[Rule MatchAny (Call ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> (Decision FinalAllow)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule MatchAny\n               (Call\n                 ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> Decision\n                            FinalAllow", "apply(rule call_result)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Semantics.matches applies_Yes MatchAny p\n 2. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log, Rule m Return]]\n     ''FORWARD'' =\n    Some ?rs\n 3. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m Log,\n              Rule m (Call ''foo''),\n              Rule m\n               Accept], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n               Log], Undecided\\<rangle> \\<Rightarrow> ?t5\n 2. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m (Call ''foo''),\n              Rule m Accept], ?t5\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto intro: Semantics.log)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m (Call ''foo''),\n              Rule m\n               Accept], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n               (Call ''foo'')], Undecided\\<rangle> \\<Rightarrow> ?t11\n 2. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n               Accept], ?t11\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule Semantics.call_return[where rs\\<^sub>1=\"[Rule m Log]\" and rs\\<^sub>2=\"[]\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. Semantics.matches applies_Yes m p\n 2. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log, Rule m Return]]\n     ''foo'' =\n    Some ([Rule m Log] @ [Rule ?m'14 Return] @ [])\n 3. Semantics.matches applies_Yes ?m'14 p\n 4. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n               Log], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n               Accept], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n               Log], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n               Accept], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto intro: Semantics.log)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule m Log, Rule m (Call ''foo''), Rule m Accept], ''foo'' \\<mapsto>\n     [Rule m Log,\n      Rule m\n       Return]],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n               Accept], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto intro: Semantics.accept)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"[''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \\<mapsto> []],applies_Yes,p\\<turnstile>\n            \\<langle>[Rule MatchAny (Call ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> (Decision FinalDeny)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>[Rule MatchAny\n        (Call\n          ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> Decision FinalDeny", "apply(rule call_result)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Semantics.matches applies_Yes MatchAny p\n 2. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto> []]\n     ''FORWARD'' =\n    Some ?rs\n 3. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalDeny", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>[Rule m (Call ''foo''),\n       Rule m Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalDeny", "apply(rule Semantics.seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n        (Call ''foo'')], Undecided\\<rangle> \\<Rightarrow> ?t5\n 2. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n        Drop], ?t5\\<rangle> \\<Rightarrow> Decision FinalDeny", "apply(rule Semantics.call_result)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Semantics.matches applies_Yes m p\n 2. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto> []]\n     ''foo'' =\n    Some ?rs8\n 3. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>?rs8, Undecided\\<rangle> \\<Rightarrow> ?t5\n 4. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n        Drop], ?t5\\<rangle> \\<Rightarrow> Decision FinalDeny", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> ?t5\n 2. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n        Drop], ?t5\\<rangle> \\<Rightarrow> Decision FinalDeny", "apply(rule Semantics.skip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n     \\<mapsto>\n     []],applies_Yes,p\\<turnstile> \\<langle>[Rule m\n        Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalDeny", "apply(auto intro: deny)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"((\\<lambda>rs. process_call [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \\<mapsto> []] rs)^^2)\n                    [Rule MatchAny (Call ''FORWARD'')]\n         = [Rule (MatchAnd MatchAny m) Drop]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (process_call\n      [''FORWARD'' \\<mapsto> [Rule m (Call ''foo''), Rule m Drop], ''foo'' \n       \\<mapsto> []] ^^\n     2)\n     [Rule MatchAny (Call ''FORWARD'')] =\n    [Rule (MatchAnd MatchAny m) Drop]", "by eval"], ["", "hide_const m"], ["", "definition \"pkt=\\<lparr>p_iiface=''+'', p_oiface=''+'', p_src=0, p_dst=0,\n                   p_proto=TCP, p_sport=0, p_dport=0, p_tcp_flags = {TCP_SYN},\n                   p_payload='''',p_tag_ctstate= CT_New\\<rparr>\""], ["", "text\\<open>We tune the primitive matcher to support everything we need in the example. Note that the undefined cases cannot be handled with these exact semantics!\\<close>"], ["", "fun applies_exampleMatchExact :: \"(32 common_primitive, 32 tagged_packet) matcher\" where\n  \"applies_exampleMatchExact (Src (IpAddr addr)) p \\<longleftrightarrow> p_src p = addr\" |\n  \"applies_exampleMatchExact (Dst (IpAddr addr)) p \\<longleftrightarrow> p_dst p = addr\" |\n  \"applies_exampleMatchExact (Prot ProtoAny) p \\<longleftrightarrow> True\" |\n  \"applies_exampleMatchExact (Prot (Proto pr)) p \\<longleftrightarrow> p_proto p = pr\""], ["", "(* not exhaustive, only an example!!*)"], ["", "lemma \"[''FORWARD'' \\<mapsto> [ Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0)))) Reject, \n                          Rule (Match (Dst (IpAddr 0))) Log, \n                          Rule (Match (Prot (Proto TCP))) Accept,\n                          Rule (Match (Prot (Proto TCP))) Drop]\n         ],applies_exampleMatchExact, pkt\\<lparr>p_src:=(ipv4addr_of_dotdecimal (1,2,3,4)), p_dst:=(ipv4addr_of_dotdecimal (0,0,0,0))\\<rparr>\\<turnstile>\n            \\<langle>[Rule MatchAny (Call ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> (Decision FinalAllow)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := ipv4addr_of_dotdecimal (1, 2, 3, 4),\n       p_dst :=\n         ipv4addr_of_dotdecimal\n          (0, 0, 0,\n           0)\\<rparr>\\<turnstile> \\<langle>[Rule MatchAny\n       (Call\n         ''FORWARD'')], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule call_result)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Semantics.matches applies_exampleMatchExact MatchAny\n     (pkt\\<lparr>p_src := ipv4addr_of_dotdecimal (1, 2, 3, 4),\n            p_dst := ipv4addr_of_dotdecimal (0, 0, 0, 0)\\<rparr>)\n 2. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]]\n     ''FORWARD'' =\n    Some ?rs\n 3. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := ipv4addr_of_dotdecimal (1, 2, 3, 4),\n       p_dst :=\n         ipv4addr_of_dotdecimal\n          (0, 0, 0,\n           0)\\<rparr>\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> Decision\n      FinalAllow", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := ipv4addr_of_dotdecimal (Suc 0, 2, 3, 4),\n       p_dst :=\n         ipv4addr_of_dotdecimal\n          (0, 0, 0,\n           0)\\<rparr>\\<turnstile> \\<langle>[Rule\n       (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0)))) Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP)))\n       Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule Semantics.seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := ipv4addr_of_dotdecimal (Suc 0, 2, 3, 4),\n       p_dst :=\n         ipv4addr_of_dotdecimal\n          (0, 0, 0,\n           0)\\<rparr>\\<turnstile> \\<langle>[Rule\n       (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject], Undecided\\<rangle> \\<Rightarrow> ?t5\n 2. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := ipv4addr_of_dotdecimal (Suc 0, 2, 3, 4),\n       p_dst :=\n         ipv4addr_of_dotdecimal\n          (0, 0, 0,\n           0)\\<rparr>\\<turnstile> \\<langle>[Rule (Match (Dst (IpAddr 0)))\n       Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP)))\n       Drop], ?t5\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto intro: Semantics.nomatch simp add: ipv4addr_of_dotdecimal.simps ipv4addr_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := 16909060,\n       p_dst :=\n         0\\<rparr>\\<turnstile> \\<langle>[Rule (Match (Dst (IpAddr 0))) Log,\n   Rule (Match (Prot (Proto TCP))) Accept,\n   Rule (Match (Prot (Proto TCP)))\n    Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule Semantics.seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := 16909060,\n       p_dst :=\n         0\\<rparr>\\<turnstile> \\<langle>[Rule (Match (Dst (IpAddr 0)))\n    Log], Undecided\\<rangle> \\<Rightarrow> ?t12\n 2. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := 16909060,\n       p_dst :=\n         0\\<rparr>\\<turnstile> \\<langle>[Rule (Match (Prot (Proto TCP)))\n    Accept,\n   Rule (Match (Prot (Proto TCP)))\n    Drop], ?t12\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto intro: Semantics.log simp add: ipv4addr_of_dotdecimal.simps ipv4addr_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := 16909060,\n       p_dst :=\n         0\\<rparr>\\<turnstile> \\<langle>[Rule (Match (Prot (Proto TCP)))\n    Accept,\n   Rule (Match (Prot (Proto TCP)))\n    Drop], Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(rule Semantics.seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := 16909060,\n       p_dst :=\n         0\\<rparr>\\<turnstile> \\<langle>[Rule (Match (Prot (Proto TCP)))\n    Accept], Undecided\\<rangle> \\<Rightarrow> ?t18\n 2. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP))) Drop]],applies_exampleMatchExact,pkt\n    \\<lparr>p_src := 16909060,\n       p_dst :=\n         0\\<rparr>\\<turnstile> \\<langle>[Rule (Match (Prot (Proto TCP)))\n    Drop], ?t18\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto simp add: pkt_def intro: Semantics.accept)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''FORWARD'' \\<mapsto>\n     [Rule (MatchAnd (Match (Src (IpAddr 0))) (Match (Dst (IpAddr 0))))\n       Reject,\n      Rule (Match (Dst (IpAddr 0))) Log,\n      Rule (Match (Prot (Proto TCP))) Accept,\n      Rule (Match (Prot (Proto TCP)))\n       Drop]],applies_exampleMatchExact,\\<lparr>p_iiface = ''+'',\n     p_oiface = ''+'', p_src = 16909060, p_dst = 0, p_proto = TCP,\n     p_sport = 0, p_dport = 0, p_tcp_flags = {TCP_SYN}, p_payload = [],\n     p_tag_ctstate =\n       CT_New\\<rparr>\\<turnstile> \\<langle>[Rule (Match (Prot (Proto TCP)))\n       Drop], Decision FinalAllow\\<rangle> \\<Rightarrow> Decision FinalAllow", "apply(auto intro: Semantics.decision)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}