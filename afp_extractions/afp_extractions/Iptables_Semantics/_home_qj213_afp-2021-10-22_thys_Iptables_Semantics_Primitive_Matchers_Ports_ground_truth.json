{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/Ports.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma ports_to_set: \"ports_to_set pts = \\<Union> {{s..e} | s e . (s,e) \\<in> set pts}\"", "lemma ports_to_set_wordinterval: \"ports_to_set ps = wordinterval_to_set (l2wi ps)\"", "lemma raw_ports_invert: \"ports_to_set (raw_ports_invert ps) = - ports_to_set ps\""], "translations": [["", "lemma ports_to_set: \"ports_to_set pts = \\<Union> {{s..e} | s e . (s,e) \\<in> set pts}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ports_to_set pts = \\<Union> {{s..e} |s e. (s, e) \\<in> set pts}", "proof(induction pts)"], ["proof (state)\ngoal (2 subgoals):\n 1. ports_to_set [] = \\<Union> {{s..e} |s e. (s, e) \\<in> set []}\n 2. \\<And>a pts.\n       ports_to_set pts =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set pts} \\<Longrightarrow>\n       ports_to_set (a # pts) =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set (a # pts)}", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ports_to_set [] = \\<Union> {{s..e} |s e. (s, e) \\<in> set []}\n 2. \\<And>a pts.\n       ports_to_set pts =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set pts} \\<Longrightarrow>\n       ports_to_set (a # pts) =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set (a # pts)}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ports_to_set [] = \\<Union> {{s..e} |s e. (s, e) \\<in> set []}", "by simp"], ["proof (state)\nthis:\n  ports_to_set [] = \\<Union> {{s..e} |s e. (s, e) \\<in> set []}\n\ngoal (1 subgoal):\n 1. \\<And>a pts.\n       ports_to_set pts =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set pts} \\<Longrightarrow>\n       ports_to_set (a # pts) =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set (a # pts)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a pts.\n       ports_to_set pts =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set pts} \\<Longrightarrow>\n       ports_to_set (a # pts) =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set (a # pts)}", "case (Cons p pts)"], ["proof (state)\nthis:\n  ports_to_set pts = \\<Union> {{s..e} |s e. (s, e) \\<in> set pts}\n\ngoal (1 subgoal):\n 1. \\<And>a pts.\n       ports_to_set pts =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set pts} \\<Longrightarrow>\n       ports_to_set (a # pts) =\n       \\<Union> {{s..e} |s e. (s, e) \\<in> set (a # pts)}", "thus ?case"], ["proof (prove)\nusing this:\n  ports_to_set pts = \\<Union> {{s..e} |s e. (s, e) \\<in> set pts}\n\ngoal (1 subgoal):\n 1. ports_to_set (p # pts) =\n    \\<Union> {{s..e} |s e. (s, e) \\<in> set (p # pts)}", "by(cases p, simp, blast)"], ["proof (state)\nthis:\n  ports_to_set (p # pts) =\n  \\<Union> {{s..e} |s e. (s, e) \\<in> set (p # pts)}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We can reuse the wordinterval theory to reason about ports\\<close>"], ["", "lemma ports_to_set_wordinterval: \"ports_to_set ps = wordinterval_to_set (l2wi ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ports_to_set ps = wordinterval_to_set (l2wi ps)", "by(induction ps rule: l2wi.induct) (auto)"], ["", "text\\<open>inverting a raw listing of ports\\<close>"], ["", "definition \"raw_ports_invert\" :: \"raw_ports \\<Rightarrow> raw_ports\" where\n  \"raw_ports_invert ps = wi2l (wordinterval_invert (l2wi ps))\""], ["", "lemma raw_ports_invert: \"ports_to_set (raw_ports_invert ps) = - ports_to_set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ports_to_set (raw_ports_invert ps) = - ports_to_set ps", "by(auto simp add: raw_ports_invert_def l2wi_wi2l ports_to_set_wordinterval)"], ["", "text\\<open>A port always belongs to a protocol! We must not lose this information.\n You should never use @{typ raw_ports} directly\\<close>"], ["", "datatype ipt_l4_ports = L4Ports primitive_protocol raw_ports"], ["", "end"]]}