{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Common/Negation_Type.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma getPos_append: \"getPos (as@bs) = getPos as @ getPos bs\"", "lemma getNeg_append: \"getNeg (as@bs) = getNeg as @ getNeg bs\"", "lemma \"NegPos_map (\\<lambda>x::nat. x+1) [Pos 0, Neg 1] = [Pos 1, Neg 2]\"", "lemma getPos_NegPos_map_simp: \"(getPos (NegPos_map X (map Pos src))) = map X src\"", "lemma getNeg_NegPos_map_simp: \"(getNeg (NegPos_map X (map Neg src))) = map X src\"", "lemma getNeg_Pos_empty: \"(getNeg (NegPos_map X (map Pos src))) = []\"", "lemma getNeg_Neg_empty: \"(getPos (NegPos_map X (map Neg src))) = []\"", "lemma getPos_NegPos_map_simp2: \"(getPos (NegPos_map X src)) = map X (getPos src)\"", "lemma getNeg_NegPos_map_simp2: \"(getNeg (NegPos_map X src)) = map X (getNeg src)\"", "lemma getPos_id: \"getPos (map Pos xs) = xs\"", "lemma getNeg_id: \"getNeg (map Neg xs) = xs\"", "lemma getPos_empty2: \"(getPos (map Neg src)) = []\"", "lemma getNeg_empty2: \"(getNeg (map Pos src)) = []\"", "lemmas NegPos_map_simps = getPos_NegPos_map_simp getNeg_NegPos_map_simp getNeg_Pos_empty getNeg_Neg_empty getPos_NegPos_map_simp2 \n                          getNeg_NegPos_map_simp2 getPos_id getNeg_id getPos_empty2 getNeg_empty2", "lemma NegPos_map_map_Neg: \"NegPos_map C (map Neg as) = map Neg (map C as)\"", "lemma NegPos_map_map_Pos: \"NegPos_map C (map Pos as) = map Pos (map C as)\"", "lemma NegPos_map_append: \"NegPos_map C (as @ bs) = NegPos_map C as @ NegPos_map C bs\"", "lemma getPos_set: \"Pos a \\<in> set x \\<longleftrightarrow> a \\<in> set (getPos x)\"", "lemma getNeg_set: \"Neg a \\<in> set x \\<longleftrightarrow> a \\<in> set (getNeg x)\"", "lemma getPosgetNeg_subset: \"set x \\<subseteq> set x' \\<longleftrightarrow>  set (getPos x) \\<subseteq> set (getPos x') \\<and> set (getNeg x) \\<subseteq> set (getNeg x')\"", "lemma set_Pos_getPos_subset: \"Pos ` set (getPos x) \\<subseteq> set x\"", "lemma set_Neg_getNeg_subset: \"Neg ` set (getNeg x) \\<subseteq> set x\"", "lemmas NegPos_set = getPos_set getNeg_set getPosgetNeg_subset set_Pos_getPos_subset set_Neg_getNeg_subset", "lemma negation_type_forall_split: \"(\\<forall>is\\<in>set Ms. case is of Pos i \\<Rightarrow> P i | Neg i \\<Rightarrow> Q i) \\<longleftrightarrow> (\\<forall>i\\<in>set (getPos Ms). P i) \\<and> (\\<forall>i\\<in>set (getNeg Ms). Q i)\"", "lemma invert_invert_id: \"invert \\<circ> invert = id\""], "translations": [["", "lemma getPos_append: \"getPos (as@bs) = getPos as @ getPos bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getPos (as @ bs) = getPos as @ getPos bs", "by(induct as rule: getPos.induct) simp+"], ["", "lemma getNeg_append: \"getNeg (as@bs) = getNeg as @ getNeg bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getNeg (as @ bs) = getNeg as @ getNeg bs", "by(induct as rule: getNeg.induct) simp+"], ["", "text\\<open>If there is @{typ \"'a negation_type\"}, then apply a @{term map} only to @{typ 'a}.\nI.e. keep @{term Neg} and @{term Pos}\\<close>"], ["", "fun NegPos_map :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a negation_type list \\<Rightarrow> 'b negation_type list\" where\n  \"NegPos_map _ [] = []\" |\n  \"NegPos_map f ((Pos a)#as) = (Pos (f a))#NegPos_map f as\" |\n  \"NegPos_map f ((Neg a)#as) = (Neg (f a))#NegPos_map f as\""], ["", "text\\<open>Example\\<close>"], ["", "lemma \"NegPos_map (\\<lambda>x::nat. x+1) [Pos 0, Neg 1] = [Pos 1, Neg 2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NegPos_map (\\<lambda>x. x + 1) [Pos 0, Neg 1] = [Pos 1, Neg 2]", "by eval"], ["", "lemma getPos_NegPos_map_simp: \"(getPos (NegPos_map X (map Pos src))) = map X src\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getPos (NegPos_map X (map Pos src)) = map X src", "by(induction src) (simp_all)"], ["", "lemma getNeg_NegPos_map_simp: \"(getNeg (NegPos_map X (map Neg src))) = map X src\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getNeg (NegPos_map X (map Neg src)) = map X src", "by(induction src) (simp_all)"], ["", "lemma getNeg_Pos_empty: \"(getNeg (NegPos_map X (map Pos src))) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getNeg (NegPos_map X (map Pos src)) = []", "by(induction src) (simp_all)"], ["", "lemma getNeg_Neg_empty: \"(getPos (NegPos_map X (map Neg src))) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getPos (NegPos_map X (map Neg src)) = []", "by(induction src) (simp_all)"], ["", "lemma getPos_NegPos_map_simp2: \"(getPos (NegPos_map X src)) = map X (getPos src)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getPos (NegPos_map X src) = map X (getPos src)", "by(induction src rule: getPos.induct) (simp_all)"], ["", "lemma getNeg_NegPos_map_simp2: \"(getNeg (NegPos_map X src)) = map X (getNeg src)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getNeg (NegPos_map X src) = map X (getNeg src)", "by(induction src rule: getPos.induct) (simp_all)"], ["", "lemma getPos_id: \"getPos (map Pos xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getPos (map Pos xs) = xs", "by(induction xs) (simp_all)"], ["", "lemma getNeg_id: \"getNeg (map Neg xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getNeg (map Neg xs) = xs", "by(induction xs) (simp_all)"], ["", "lemma getPos_empty2: \"(getPos (map Neg src)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getPos (map Neg src) = []", "by(induction src) (simp_all)"], ["", "lemma getNeg_empty2: \"(getNeg (map Pos src)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getNeg (map Pos src) = []", "by(induction src) (simp_all)"], ["", "lemmas NegPos_map_simps = getPos_NegPos_map_simp getNeg_NegPos_map_simp getNeg_Pos_empty getNeg_Neg_empty getPos_NegPos_map_simp2 \n                          getNeg_NegPos_map_simp2 getPos_id getNeg_id getPos_empty2 getNeg_empty2"], ["", "lemma NegPos_map_map_Neg: \"NegPos_map C (map Neg as) = map Neg (map C as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NegPos_map C (map Neg as) = map Neg (map C as)", "by(induction as) (simp_all)"], ["", "lemma NegPos_map_map_Pos: \"NegPos_map C (map Pos as) = map Pos (map C as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NegPos_map C (map Pos as) = map Pos (map C as)", "by(induction as) (simp_all)"], ["", "lemma NegPos_map_append: \"NegPos_map C (as @ bs) = NegPos_map C as @ NegPos_map C bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NegPos_map C (as @ bs) = NegPos_map C as @ NegPos_map C bs", "by(induction as rule: getNeg.induct) (simp_all)"], ["", "lemma getPos_set: \"Pos a \\<in> set x \\<longleftrightarrow> a \\<in> set (getPos x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pos a \\<in> set x) = (a \\<in> set (getPos x))", "apply(induction x rule: getPos.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (Pos a \\<in> set []) = (a \\<in> set (getPos []))\n 2. \\<And>x xs.\n       (Pos a \\<in> set xs) = (a \\<in> set (getPos xs)) \\<Longrightarrow>\n       (Pos a \\<in> set (Pos x # xs)) = (a \\<in> set (getPos (Pos x # xs)))\n 3. \\<And>v xs.\n       (Pos a \\<in> set xs) = (a \\<in> set (getPos xs)) \\<Longrightarrow>\n       (Pos a \\<in> set (Neg v # xs)) = (a \\<in> set (getPos (Neg v # xs)))", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma getNeg_set: \"Neg a \\<in> set x \\<longleftrightarrow> a \\<in> set (getNeg x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Neg a \\<in> set x) = (a \\<in> set (getNeg x))", "apply(induction x rule: getPos.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (Neg a \\<in> set []) = (a \\<in> set (getNeg []))\n 2. \\<And>x xs.\n       (Neg a \\<in> set xs) = (a \\<in> set (getNeg xs)) \\<Longrightarrow>\n       (Neg a \\<in> set (Pos x # xs)) = (a \\<in> set (getNeg (Pos x # xs)))\n 3. \\<And>v xs.\n       (Neg a \\<in> set xs) = (a \\<in> set (getNeg xs)) \\<Longrightarrow>\n       (Neg a \\<in> set (Neg v # xs)) = (a \\<in> set (getNeg (Neg v # xs)))", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma getPosgetNeg_subset: \"set x \\<subseteq> set x' \\<longleftrightarrow>  set (getPos x) \\<subseteq> set (getPos x') \\<and> set (getNeg x) \\<subseteq> set (getNeg x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set x \\<subseteq> set x') =\n    (set (getPos x) \\<subseteq> set (getPos x') \\<and>\n     set (getNeg x) \\<subseteq> set (getNeg x'))", "apply(induction x rule: getPos.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (set [] \\<subseteq> set x') =\n    (set (getPos []) \\<subseteq> set (getPos x') \\<and>\n     set (getNeg []) \\<subseteq> set (getNeg x'))\n 2. \\<And>x xs.\n       (set xs \\<subseteq> set x') =\n       (set (getPos xs) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg xs) \\<subseteq> set (getNeg x')) \\<Longrightarrow>\n       (set (Pos x # xs) \\<subseteq> set x') =\n       (set (getPos (Pos x # xs)) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg (Pos x # xs)) \\<subseteq> set (getNeg x'))\n 3. \\<And>v xs.\n       (set xs \\<subseteq> set x') =\n       (set (getPos xs) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg xs) \\<subseteq> set (getNeg x')) \\<Longrightarrow>\n       (set (Neg v # xs) \\<subseteq> set x') =\n       (set (getPos (Neg v # xs)) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg (Neg v # xs)) \\<subseteq> set (getNeg x'))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       (set xs \\<subseteq> set x') =\n       (set (getPos xs) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg xs) \\<subseteq> set (getNeg x')) \\<Longrightarrow>\n       (set (Pos x # xs) \\<subseteq> set x') =\n       (set (getPos (Pos x # xs)) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg (Pos x # xs)) \\<subseteq> set (getNeg x'))\n 2. \\<And>v xs.\n       (set xs \\<subseteq> set x') =\n       (set (getPos xs) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg xs) \\<subseteq> set (getNeg x')) \\<Longrightarrow>\n       (set (Neg v # xs) \\<subseteq> set x') =\n       (set (getPos (Neg v # xs)) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg (Neg v # xs)) \\<subseteq> set (getNeg x'))", "apply(simp add: getPos_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v xs.\n       (set xs \\<subseteq> set x') =\n       (set (getPos xs) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg xs) \\<subseteq> set (getNeg x')) \\<Longrightarrow>\n       (set (Neg v # xs) \\<subseteq> set x') =\n       (set (getPos (Neg v # xs)) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg (Neg v # xs)) \\<subseteq> set (getNeg x'))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v xs.\n       \\<lbrakk>(set xs \\<subseteq> set x') =\n                (set (getPos xs) \\<subseteq> set (getPos x') \\<and>\n                 set (getNeg xs) \\<subseteq> set (getNeg x'));\n        set (Neg v # xs) \\<subseteq> set x'\\<rbrakk>\n       \\<Longrightarrow> set (getPos (Neg v # xs))\n                         \\<subseteq> set (getPos x') \\<and>\n                         set (getNeg (Neg v # xs))\n                         \\<subseteq> set (getNeg x')\n 2. \\<And>v xs.\n       \\<lbrakk>(set xs \\<subseteq> set x') =\n                (set (getPos xs) \\<subseteq> set (getPos x') \\<and>\n                 set (getNeg xs) \\<subseteq> set (getNeg x'));\n        set (getPos (Neg v # xs)) \\<subseteq> set (getPos x') \\<and>\n        set (getNeg (Neg v # xs)) \\<subseteq> set (getNeg x')\\<rbrakk>\n       \\<Longrightarrow> set (Neg v # xs) \\<subseteq> set x'", "apply(simp_all add: getPos_set getNeg_set)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_Pos_getPos_subset: \"Pos ` set (getPos x) \\<subseteq> set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pos ` set (getPos x) \\<subseteq> set x", "apply(induction x rule: getPos.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Pos ` set (getPos []) \\<subseteq> set []\n 2. \\<And>x xs.\n       Pos ` set (getPos xs) \\<subseteq> set xs \\<Longrightarrow>\n       Pos ` set (getPos (Pos x # xs)) \\<subseteq> set (Pos x # xs)\n 3. \\<And>v xs.\n       Pos ` set (getPos xs) \\<subseteq> set xs \\<Longrightarrow>\n       Pos ` set (getPos (Neg v # xs)) \\<subseteq> set (Neg v # xs)", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       Pos ` set (getPos xs) \\<subseteq> set xs \\<Longrightarrow>\n       Pos ` set (getPos xs) \\<subseteq> insert (Pos x) (set xs)\n 2. \\<And>v xs.\n       Pos ` set (getPos xs) \\<subseteq> set xs \\<Longrightarrow>\n       Pos ` set (getPos xs) \\<subseteq> insert (Neg v) (set xs)", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_Neg_getNeg_subset: \"Neg ` set (getNeg x) \\<subseteq> set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg ` set (getNeg x) \\<subseteq> set x", "apply(induction x rule: getNeg.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Neg ` set (getNeg []) \\<subseteq> set []\n 2. \\<And>x xs.\n       Neg ` set (getNeg xs) \\<subseteq> set xs \\<Longrightarrow>\n       Neg ` set (getNeg (Neg x # xs)) \\<subseteq> set (Neg x # xs)\n 3. \\<And>v xs.\n       Neg ` set (getNeg xs) \\<subseteq> set xs \\<Longrightarrow>\n       Neg ` set (getNeg (Pos v # xs)) \\<subseteq> set (Pos v # xs)", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       Neg ` set (getNeg xs) \\<subseteq> set xs \\<Longrightarrow>\n       Neg ` set (getNeg xs) \\<subseteq> insert (Neg x) (set xs)\n 2. \\<And>v xs.\n       Neg ` set (getNeg xs) \\<subseteq> set xs \\<Longrightarrow>\n       Neg ` set (getNeg xs) \\<subseteq> insert (Pos v) (set xs)", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas NegPos_set = getPos_set getNeg_set getPosgetNeg_subset set_Pos_getPos_subset set_Neg_getNeg_subset"], ["", "hide_fact getPos_set getNeg_set getPosgetNeg_subset set_Pos_getPos_subset set_Neg_getNeg_subset"], ["", "lemma negation_type_forall_split: \"(\\<forall>is\\<in>set Ms. case is of Pos i \\<Rightarrow> P i | Neg i \\<Rightarrow> Q i) \\<longleftrightarrow> (\\<forall>i\\<in>set (getPos Ms). P i) \\<and> (\\<forall>i\\<in>set (getNeg Ms). Q i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>is\\<in>set Ms.\n        case is of Pos i \\<Rightarrow> P i | Neg i \\<Rightarrow> Q i) =\n    ((\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n     (\\<forall>i\\<in>set (getNeg Ms). Q i))", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>is\\<in>set Ms.\n       case is of Pos i \\<Rightarrow> P i\n       | Neg i \\<Rightarrow> Q i \\<Longrightarrow>\n    (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i)\n 2. (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i) \\<Longrightarrow>\n    \\<forall>is\\<in>set Ms.\n       case is of Pos i \\<Rightarrow> P i | Neg i \\<Rightarrow> Q i", "apply(simp split: negation_type.split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>is\\<in>set Ms.\n       (\\<forall>x1. is = Pos x1 \\<longrightarrow> P x1) \\<and>\n       (\\<forall>x2. is = Neg x2 \\<longrightarrow> Q x2) \\<Longrightarrow>\n    (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i)\n 2. (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i) \\<Longrightarrow>\n    \\<forall>is\\<in>set Ms.\n       case is of Pos i \\<Rightarrow> P i | Neg i \\<Rightarrow> Q i", "using NegPos_set(1) NegPos_set(2)"], ["proof (prove)\nusing this:\n  (Pos ?a \\<in> set ?x) = (?a \\<in> set (getPos ?x))\n  (Neg ?a \\<in> set ?x) = (?a \\<in> set (getNeg ?x))\n\ngoal (2 subgoals):\n 1. \\<forall>is\\<in>set Ms.\n       (\\<forall>x1. is = Pos x1 \\<longrightarrow> P x1) \\<and>\n       (\\<forall>x2. is = Neg x2 \\<longrightarrow> Q x2) \\<Longrightarrow>\n    (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i)\n 2. (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i) \\<Longrightarrow>\n    \\<forall>is\\<in>set Ms.\n       case is of Pos i \\<Rightarrow> P i | Neg i \\<Rightarrow> Q i", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i) \\<Longrightarrow>\n    \\<forall>is\\<in>set Ms.\n       case is of Pos i \\<Rightarrow> P i | Neg i \\<Rightarrow> Q i", "apply(simp split: negation_type.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i) \\<Longrightarrow>\n    \\<forall>is\\<in>set Ms.\n       (\\<forall>x1. is = Pos x1 \\<longrightarrow> P x1) \\<and>\n       (\\<forall>x2. is = Neg x2 \\<longrightarrow> Q x2)", "using NegPos_set(1) NegPos_set(2)"], ["proof (prove)\nusing this:\n  (Pos ?a \\<in> set ?x) = (?a \\<in> set (getPos ?x))\n  (Neg ?a \\<in> set ?x) = (?a \\<in> set (getNeg ?x))\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>set (getPos Ms). P i) \\<and>\n    (\\<forall>i\\<in>set (getNeg Ms). Q i) \\<Longrightarrow>\n    \\<forall>is\\<in>set Ms.\n       (\\<forall>x1. is = Pos x1 \\<longrightarrow> P x1) \\<and>\n       (\\<forall>x2. is = Neg x2 \\<longrightarrow> Q x2)", "by fastforce"], ["", "fun invert :: \"'a negation_type \\<Rightarrow> 'a negation_type\" where\n  \"invert (Pos x) = Neg x\" |\n  \"invert (Neg x) = Pos x\""], ["", "lemma invert_invert_id: \"invert \\<circ> invert = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invert \\<circ> invert = id", "apply(clarsimp simp add: fun_eq_iff, rename_tac x, case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1. x = Pos x1 \\<Longrightarrow> invert (invert x) = x\n 2. \\<And>x x2. x = Neg x2 \\<Longrightarrow> invert (invert x) = x", "by simp+"], ["", "end"]]}