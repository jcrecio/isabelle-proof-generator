{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Examples/Fail/Ports_Fail.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma \"unfold_ruleset_FORWARD action.Accept\n                      (map_of_string_ipv4 allow_only_tcpsport_22_and_udp_dport80) =\n  [Rule (MatchAnd (MatchNot (MatchAnd (Match (Prot (Proto TCP))) (Match (Src_Ports (L4Ports TCP [(0x16, 0x16)])))))\n         (MatchNot (MatchAnd (Match (Prot (Proto UDP))) (Match (Dst_Ports (L4Ports UDP [(0x50, 0x50)]))))))\n   action.Drop,\n  Rule MatchAny action.Accept]\"", "lemma \"map simple_rule_ipv4_toString\n              (to_simple_firewall (upper_closure\n                (optimize_matches abstract_for_simple_firewall\n                  (upper_closure (packet_assume_new\n                    (unfold_ruleset_FORWARD action.Accept\n                      (map_of_string_ipv4 allow_only_tcpsport_22_and_udp_dport80))))))) =\n[ ''DROP     udp  --  0.0.0.0/0            0.0.0.0/0    dports: 0:79'',\n  ''DROP     udp  --  0.0.0.0/0            0.0.0.0/0    dports: 81:65535'',\n  ''DROP     tcp  --  0.0.0.0/0            0.0.0.0/0   sports: 0:21 '',\n  ''DROP     tcp  --  0.0.0.0/0            0.0.0.0/0   sports: 23:65535 '',\n  ''ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0    '']\"", "lemma \"map simple_rule_ipv4_toString\n              (to_simple_firewall (upper_closure\n                (optimize_matches abstract_for_simple_firewall\n                  (upper_closure (packet_assume_new\n                    (unfold_ruleset_FORWARD action.Accept\n                      (map_of_string_ipv4 only_allow_tcp_and_udp))))))) =\n  [''ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0    '']\""], "translations": [["", "lemma \"unfold_ruleset_FORWARD action.Accept\n                      (map_of_string_ipv4 allow_only_tcpsport_22_and_udp_dport80) =\n  [Rule (MatchAnd (MatchNot (MatchAnd (Match (Prot (Proto TCP))) (Match (Src_Ports (L4Ports TCP [(0x16, 0x16)])))))\n         (MatchNot (MatchAnd (Match (Prot (Proto UDP))) (Match (Dst_Ports (L4Ports UDP [(0x50, 0x50)]))))))\n   action.Drop,\n  Rule MatchAny action.Accept]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_ruleset_FORWARD action.Accept\n     (map_of_string_ipv4 allow_only_tcpsport_22_and_udp_dport80) =\n    [Rule\n      (MatchAnd\n        (MatchNot\n          (MatchAnd (Match (Prot (Proto TCP)))\n            (Match (Src_Ports (L4Ports TCP [(22, 22)])))))\n        (MatchNot\n          (MatchAnd (Match (Prot (Proto UDP)))\n            (Match (Dst_Ports (L4Ports UDP [(80, 80)]))))))\n      action.Drop,\n     Rule MatchAny action.Accept]", "by eval"], ["", "text\\<open>\nWithout having the protocol again in the type for ports, the nnf normalization would mix up\ntcp and udp ports and we would end up with a firewall which\naccepts everything for every protocol from source port 22 to dst port 80 and drop everything else. \nThis was wrong. Now it is correct. Here is exactly how it should (and does) look like:\\<close>"], ["", "lemma \"map simple_rule_ipv4_toString\n              (to_simple_firewall (upper_closure\n                (optimize_matches abstract_for_simple_firewall\n                  (upper_closure (packet_assume_new\n                    (unfold_ruleset_FORWARD action.Accept\n                      (map_of_string_ipv4 allow_only_tcpsport_22_and_udp_dport80))))))) =\n[ ''DROP     udp  --  0.0.0.0/0            0.0.0.0/0    dports: 0:79'',\n  ''DROP     udp  --  0.0.0.0/0            0.0.0.0/0    dports: 81:65535'',\n  ''DROP     tcp  --  0.0.0.0/0            0.0.0.0/0   sports: 0:21 '',\n  ''DROP     tcp  --  0.0.0.0/0            0.0.0.0/0   sports: 23:65535 '',\n  ''ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0    '']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map simple_rule_ipv4_toString\n     (to_simple_firewall\n       (upper_closure\n         (optimize_matches abstract_for_simple_firewall\n           (upper_closure\n             (packet_assume_new\n               (unfold_ruleset_FORWARD action.Accept\n                 (map_of_string_ipv4\n                   allow_only_tcpsport_22_and_udp_dport80))))))) =\n    [''DROP     udp  --  0.0.0.0/0            0.0.0.0/0    dports: 0:79'',\n     ''DROP     udp  --  0.0.0.0/0            0.0.0.0/0    dports: 81:65535'',\n     ''DROP     tcp  --  0.0.0.0/0            0.0.0.0/0   sports: 0:21 '',\n     ''DROP     tcp  --  0.0.0.0/0            0.0.0.0/0   sports: 23:65535 '',\n     ''ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0    '']", "by eval"], ["", "text\\<open>Before the fix, we had:\n@{term \"[''DROP     all  --  0.0.0.0/0            0.0.0.0/0   sports: 0:21 dports: 0:79'',\n         ''DROP     all  --  0.0.0.0/0            0.0.0.0/0   sports: 0:21 dports: 81:65535'',\n         ''DROP     all  --  0.0.0.0/0            0.0.0.0/0   sports: 23:65535 dports: 0:79'',\n         ''DROP     all  --  0.0.0.0/0            0.0.0.0/0   sports: 23:65535 dports: 81:65535'',\n         ''ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0    '']\"}\nNote that we completely lost the protocols!\n\nIn a transition period, we had a firewall which accepts everything, which is a sound overapproximation.\n(Sound, but useless).\n\\<close>"], ["", "subsection\\<open>Things the Simple Firewall Cannot Express\\<close>"], ["", "text\\<open>This example is based on the same pattern as above. \nIt does not cause an error but is a minimal example of what the simple firewall just cannot express \n(and approximation is occurs).\\<close>"], ["", "text\\<open>\nDescription: \nLet's assume we want to write a firewall which first makes sure than only @{const TCP} and @{const UDP} \nis allowed and continues with more fine-grained filtering afterwards.\nBasically, we want a first rule which drops everything which is not tcp or udp.\nThe @{const simple_fw} just cannot express this (other firewall systems can't express this neither).\nIt needs a bit of work to get this behavior in iptables.\n\\<close>"], ["", "definition only_allow_tcp_and_udp :: \"(string \\<times> 32 common_primitive rule list) list\"\n  where\n  \"only_allow_tcp_and_udp \\<equiv>\n    [(''FORWARD'',\n      [Rule MatchAny (Call ''OnlyTCPandUDP''),\n       Rule (Match (Extra ''more fine-grained filtering'')) action.Drop\n      \\<comment> \\<open>now further more fine-grained filtering rules here\\<close>]),\n     (''OnlyTCPandUDP'',\n      [Rule (Match (Prot (Proto TCP))) Return,\n       Rule (Match (Prot (Proto UDP))) Return,\n       Rule MatchAny Log,\n       Rule MatchAny Reject])\n    ]\""], ["", "text\\<open>Overapproximation removes the check for tcp and udp because the simple firewall cannot\nmatch on negated protocols. This particular example could be expressed by the simple firewall\nbut the pattern to check for tcp/udp first and do more fine-grained filtering afterwards cannot be \ndirectly expressed.\\<close>"], ["", "lemma \"map simple_rule_ipv4_toString\n              (to_simple_firewall (upper_closure\n                (optimize_matches abstract_for_simple_firewall\n                  (upper_closure (packet_assume_new\n                    (unfold_ruleset_FORWARD action.Accept\n                      (map_of_string_ipv4 only_allow_tcp_and_udp))))))) =\n  [''ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0    '']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map simple_rule_ipv4_toString\n     (to_simple_firewall\n       (upper_closure\n         (optimize_matches abstract_for_simple_firewall\n           (upper_closure\n             (packet_assume_new\n               (unfold_ruleset_FORWARD action.Accept\n                 (map_of_string_ipv4 only_allow_tcp_and_udp))))))) =\n    [''ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0    '']", "by eval"], ["", "end"]]}