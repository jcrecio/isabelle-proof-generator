{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/No_Spoof_Embeddings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma approximating_imp_booloan_semantics_nospoofing: \n      assumes \"matcher_agree_on_exact_matches \\<gamma> common_matcher\"\n      and \"simple_ruleset rs\"\n      and no_spoofing: \"no_spoofing TYPE('pkt_ext) ipassmt rs\"\n      shows \"\\<forall> iface \\<in> dom ipassmt. \\<forall>p::('i::len,'pkt_ext) tagged_packet_scheme.\n                (\\<Gamma>,\\<gamma>,p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow) \\<longrightarrow>\n                    p_src p \\<in> (ipcidr_union_set (set (the (ipassmt iface))))\""], "translations": [["", "lemma approximating_imp_booloan_semantics_nospoofing: \n      assumes \"matcher_agree_on_exact_matches \\<gamma> common_matcher\"\n      and \"simple_ruleset rs\"\n      and no_spoofing: \"no_spoofing TYPE('pkt_ext) ipassmt rs\"\n      shows \"\\<forall> iface \\<in> dom ipassmt. \\<forall>p::('i::len,'pkt_ext) tagged_packet_scheme.\n                (\\<Gamma>,\\<gamma>,p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow) \\<longrightarrow>\n                    p_src p \\<in> (ipcidr_union_set (set (the (ipassmt iface))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>iface\\<in>dom ipassmt.\n       \\<forall>p.\n          \\<Gamma>,\\<gamma>,p\n          \\<lparr>p_iiface :=\n                    iface_sel\n                     iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                  FinalAllow \\<longrightarrow>\n          p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "unfolding no_spoofing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>iface\\<in>dom ipassmt.\n       \\<forall>p.\n          \\<Gamma>,\\<gamma>,p\n          \\<lparr>p_iiface :=\n                    iface_sel\n                     iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                  FinalAllow \\<longrightarrow>\n          p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "proof(intro ballI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iface p.\n       \\<lbrakk>iface \\<in> dom ipassmt;\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow\\<rbrakk>\n       \\<Longrightarrow> p_src p\n                         \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "fix iface p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iface p.\n       \\<lbrakk>iface \\<in> dom ipassmt;\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow\\<rbrakk>\n       \\<Longrightarrow> p_src p\n                         \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "assume i: \"iface \\<in> dom ipassmt\"\n           and a: \"\\<Gamma>,\\<gamma>,p\\<lparr>p_iiface := iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow\""], ["proof (state)\nthis:\n  iface \\<in> dom ipassmt\n  \\<Gamma>,\\<gamma>,p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n          FinalAllow\n\ngoal (1 subgoal):\n 1. \\<And>iface p.\n       \\<lbrakk>iface \\<in> dom ipassmt;\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow\\<rbrakk>\n       \\<Longrightarrow> p_src p\n                         \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "from no_spoofing[unfolded no_spoofing_def] i"], ["proof (chain)\npicking this:\n  \\<forall>iface\\<in>dom ipassmt.\n     \\<forall>p.\n        (common_matcher, in_doubt_allow),p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow \\<longrightarrow>\n        p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n  iface \\<in> dom ipassmt", "have no_spoofing':\n          \"(common_matcher, in_doubt_allow),p\\<lparr>p_iiface := iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\nusing this:\n  \\<forall>iface\\<in>dom ipassmt.\n     \\<forall>p.\n        (common_matcher, in_doubt_allow),p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow \\<longrightarrow>\n        p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n  iface \\<in> dom ipassmt\n\ngoal (1 subgoal):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_iiface :=\n              iface_sel\n               iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                           FinalAllow \\<longrightarrow>\n    p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "by blast"], ["proof (state)\nthis:\n  (common_matcher, in_doubt_allow),p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                         FinalAllow \\<longrightarrow>\n  p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. \\<And>iface p.\n       \\<lbrakk>iface \\<in> dom ipassmt;\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow\\<rbrakk>\n       \\<Longrightarrow> p_src p\n                         \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "from assms simple_imp_good_ruleset FinalAllows_subseteq_in_doubt_allow[where rs=rs]"], ["proof (chain)\npicking this:\n  matcher_agree_on_exact_matches \\<gamma> common_matcher\n  simple_ruleset rs\n  no_spoofing TYPE('pkt_ext) ipassmt rs\n  simple_ruleset ?rs \\<Longrightarrow> good_ruleset ?rs\n  \\<lbrakk>matcher_agree_on_exact_matches ?\\<gamma> ?\\<beta>;\n   good_ruleset rs\\<rbrakk>\n  \\<Longrightarrow> _Collect p\n                     (?\\<Gamma>,?\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                           FinalAllow)\n                    \\<subseteq> _Collect p\n                                 ((?\\<beta>,\n                                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n             FinalAllow)", "have\n          \"{p. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow} \\<subseteq> {p. (common_matcher, in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow}\""], ["proof (prove)\nusing this:\n  matcher_agree_on_exact_matches \\<gamma> common_matcher\n  simple_ruleset rs\n  no_spoofing TYPE('pkt_ext) ipassmt rs\n  simple_ruleset ?rs \\<Longrightarrow> good_ruleset ?rs\n  \\<lbrakk>matcher_agree_on_exact_matches ?\\<gamma> ?\\<beta>;\n   good_ruleset rs\\<rbrakk>\n  \\<Longrightarrow> _Collect p\n                     (?\\<Gamma>,?\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                           FinalAllow)\n                    \\<subseteq> _Collect p\n                                 ((?\\<beta>,\n                                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n             FinalAllow)\n\ngoal (1 subgoal):\n 1. _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                   FinalAllow)", "by blast"], ["proof (state)\nthis:\n  _Collect p\n   (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                 FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>iface p.\n       \\<lbrakk>iface \\<in> dom ipassmt;\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow\\<rbrakk>\n       \\<Longrightarrow> p_src p\n                         \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "with a"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n          FinalAllow\n  _Collect p\n   (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                 FinalAllow)", "have \"(common_matcher, in_doubt_allow),p\\<lparr>p_iiface := iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n          FinalAllow\n  _Collect p\n   (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                 FinalAllow)\n\ngoal (1 subgoal):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_iiface :=\n              iface_sel\n               iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                           FinalAllow", "by blast"], ["proof (state)\nthis:\n  (common_matcher, in_doubt_allow),p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                         FinalAllow\n\ngoal (1 subgoal):\n 1. \\<And>iface p.\n       \\<lbrakk>iface \\<in> dom ipassmt;\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow\\<rbrakk>\n       \\<Longrightarrow> p_src p\n                         \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "with no_spoofing'"], ["proof (chain)\npicking this:\n  (common_matcher, in_doubt_allow),p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                         FinalAllow \\<longrightarrow>\n  p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n  (common_matcher, in_doubt_allow),p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                         FinalAllow", "show \"p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\nusing this:\n  (common_matcher, in_doubt_allow),p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                         FinalAllow \\<longrightarrow>\n  p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n  (common_matcher, in_doubt_allow),p\n  \\<lparr>p_iiface :=\n            iface_sel\n             iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                         FinalAllow\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "by blast"], ["proof (state)\nthis:\n  p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*expressed as set*)"], ["", "corollary\n      assumes \"matcher_agree_on_exact_matches \\<gamma> common_matcher\" and \"simple_ruleset rs\"\n          and no_spoofing: \"no_spoofing TYPE('pkt_ext) ipassmt rs\" and \"iface \\<in> dom ipassmt\"\n      shows \"{p_src p | p :: ('i::len,'pkt_ext) tagged_packet_scheme. (\\<Gamma>,\\<gamma>,p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow)} \\<subseteq>\n                 ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "using approximating_imp_booloan_semantics_nospoofing[OF assms(1) assms(2) assms(3), where \\<Gamma>=\\<Gamma>]"], ["proof (prove)\nusing this:\n  \\<forall>iface\\<in>dom ipassmt.\n     \\<forall>p.\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow \\<longrightarrow>\n        p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "using assms(4)"], ["proof (prove)\nusing this:\n  \\<forall>iface\\<in>dom ipassmt.\n     \\<forall>p.\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow \\<longrightarrow>\n        p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n  iface \\<in> dom ipassmt\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "by blast"], ["", "(*expressed as set*)"], ["", "corollary no_spoofing_executable_set:\n      assumes \"matcher_agree_on_exact_matches \\<gamma> common_matcher\"\n          and \"simple_ruleset rs\"\n          and \"\\<forall>r\\<in>set rs. normalized_nnf_match (get_match r)\"\n          and no_spoofing_executable: \"\\<forall>iface \\<in> dom ipassmt. no_spoofing_iface iface ipassmt rs\"\n          and \"iface \\<in> dom ipassmt\"\n      shows \"{p_src p | p :: ('i::len,'pkt_ext) tagged_packet_scheme. (\\<Gamma>,\\<gamma>,p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow)} \\<subseteq>\n                 ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "assume no_spoofing: \"no_spoofing TYPE('pkt_ext) ipassmt rs\""], ["proof (state)\nthis:\n  no_spoofing TYPE('pkt_ext) ipassmt rs\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "have \"{p_src p | p :: ('i,'pkt_ext) tagged_packet_scheme. (\\<Gamma>,\\<gamma>,p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow)} \\<subseteq>\n                 ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "using approximating_imp_booloan_semantics_nospoofing[OF assms(1) assms(2) no_spoofing, where \\<Gamma>=\\<Gamma>]"], ["proof (prove)\nusing this:\n  \\<forall>iface\\<in>dom ipassmt.\n     \\<forall>p.\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow \\<longrightarrow>\n        p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "using assms(5)"], ["proof (prove)\nusing this:\n  \\<forall>iface\\<in>dom ipassmt.\n     \\<forall>p.\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow \\<longrightarrow>\n        p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n  iface \\<in> dom ipassmt\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "by blast"], ["proof (state)\nthis:\n  _Collect (p_src p)\n   (\\<Gamma>,\\<gamma>,p\n    \\<lparr>p_iiface :=\n              iface_sel\n               iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n            FinalAllow)\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "}"], ["proof (state)\nthis:\n  no_spoofing TYPE('pkt_ext) ipassmt rs \\<Longrightarrow>\n  _Collect (p_src p)\n   (\\<Gamma>,\\<gamma>,p\n    \\<lparr>p_iiface :=\n              iface_sel\n               iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n            FinalAllow)\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "with no_spoofing_iface[OF assms(2) assms(3) no_spoofing_executable]"], ["proof (chain)\npicking this:\n  no_spoofing TYPE(?'pkt_ext) ipassmt rs\n  no_spoofing TYPE('pkt_ext) ipassmt rs \\<Longrightarrow>\n  _Collect (p_src p)\n   (\\<Gamma>,\\<gamma>,p\n    \\<lparr>p_iiface :=\n              iface_sel\n               iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n            FinalAllow)\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "show ?thesis"], ["proof (prove)\nusing this:\n  no_spoofing TYPE(?'pkt_ext) ipassmt rs\n  no_spoofing TYPE('pkt_ext) ipassmt rs \\<Longrightarrow>\n  _Collect (p_src p)\n   (\\<Gamma>,\\<gamma>,p\n    \\<lparr>p_iiface :=\n              iface_sel\n               iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n            FinalAllow)\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (\\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "by blast"], ["proof (state)\nthis:\n  _Collect (p_src p)\n   (\\<Gamma>,\\<gamma>,p\n    \\<lparr>p_iiface :=\n              iface_sel\n               iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n            FinalAllow)\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary no_spoofing_executable_set_preprocessed:\n      fixes ipassmt :: \"'i::len ipassignment\"\n      defines \"preprocess rs \\<equiv> upper_closure (packet_assume_new rs)\"\n          and \"newpkt p \\<equiv> match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and> p_tag_ctstate p = CT_New\"\n      assumes \"matcher_agree_on_exact_matches \\<gamma> common_matcher\"\n          and simplers: \"simple_ruleset rs\"\n          and no_spoofing_executable: \"\\<forall>iface \\<in> dom ipassmt. no_spoofing_iface iface ipassmt (preprocess rs)\"\n          and \"iface \\<in> dom ipassmt\"\n      shows \"{p_src p | p :: ('i::len,'pkt_ext) tagged_packet_scheme. newpkt p \\<and> \\<Gamma>,\\<gamma>,p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow} \\<subseteq>\n                 ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "have newpktD: \"newpkt p \\<Longrightarrow> newpkt (p\\<lparr>p_iiface := iface_sel iface\\<rparr>)\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. newpkt p \\<Longrightarrow>\n    newpkt (p\\<lparr>p_iiface := iface_sel iface\\<rparr>)", "by(simp add: newpkt_def)"], ["proof (state)\nthis:\n  newpkt ?p \\<Longrightarrow>\n  newpkt (?p\\<lparr>p_iiface := iface_sel iface\\<rparr>)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "from packet_assume_new_simple_ruleset[OF simplers]"], ["proof (chain)\npicking this:\n  simple_ruleset (packet_assume_new rs)", "have s1: \"simple_ruleset (packet_assume_new rs)\""], ["proof (prove)\nusing this:\n  simple_ruleset (packet_assume_new rs)\n\ngoal (1 subgoal):\n 1. simple_ruleset (packet_assume_new rs)", "."], ["proof (state)\nthis:\n  simple_ruleset (packet_assume_new rs)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "from transform_upper_closure(2)[OF s1]"], ["proof (chain)\npicking this:\n  simple_ruleset (upper_closure (packet_assume_new rs))", "have s2: \"simple_ruleset (upper_closure (packet_assume_new rs))\""], ["proof (prove)\nusing this:\n  simple_ruleset (upper_closure (packet_assume_new rs))\n\ngoal (1 subgoal):\n 1. simple_ruleset (upper_closure (packet_assume_new rs))", "."], ["proof (state)\nthis:\n  simple_ruleset (upper_closure (packet_assume_new rs))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "hence s2': \"simple_ruleset (preprocess rs)\""], ["proof (prove)\nusing this:\n  simple_ruleset (upper_closure (packet_assume_new rs))\n\ngoal (1 subgoal):\n 1. simple_ruleset (preprocess rs)", "unfolding preprocess_def"], ["proof (prove)\nusing this:\n  simple_ruleset (upper_closure (packet_assume_new rs))\n\ngoal (1 subgoal):\n 1. simple_ruleset (upper_closure (packet_assume_new rs))", "by simp"], ["proof (state)\nthis:\n  simple_ruleset (preprocess rs)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "have \"\\<forall>r\\<in>set (preprocess rs). normalized_nnf_match (get_match r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set (preprocess rs). normalized_nnf_match (get_match r)", "unfolding preprocess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set (upper_closure (packet_assume_new rs)).\n       normalized_nnf_match (get_match r)", "using transform_upper_closure(3)[OF s1]"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (upper_closure (packet_assume_new rs)).\n     normalized_nnf_match (get_match r) \\<and>\n     normalized_src_ports (get_match r) \\<and>\n     normalized_dst_ports (get_match r) \\<and>\n     normalized_src_ips (get_match r) \\<and>\n     normalized_dst_ips (get_match r) \\<and>\n     \\<not> has_disc is_MultiportPorts (get_match r) \\<and>\n     \\<not> has_disc is_Extra (get_match r)\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set (upper_closure (packet_assume_new rs)).\n       normalized_nnf_match (get_match r)", "by simp"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set (preprocess rs). normalized_nnf_match (get_match r)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "from no_spoofing_iface[OF s2' this no_spoofing_executable]"], ["proof (chain)\npicking this:\n  no_spoofing TYPE(?'pkt_ext) ipassmt (preprocess rs)", "have nospoof: \"no_spoofing TYPE('a) ipassmt (preprocess rs)\""], ["proof (prove)\nusing this:\n  no_spoofing TYPE(?'pkt_ext) ipassmt (preprocess rs)\n\ngoal (1 subgoal):\n 1. no_spoofing TYPE('a) ipassmt (preprocess rs)", "."], ["proof (state)\nthis:\n  no_spoofing TYPE(?'a1) ipassmt (preprocess rs)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "from assms(3)"], ["proof (chain)\npicking this:\n  matcher_agree_on_exact_matches \\<gamma> common_matcher", "have 1: \"{p. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow \\<and> newpkt p} \\<subseteq>\n                       {p. (common_matcher, in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow \\<and> newpkt p}\""], ["proof (prove)\nusing this:\n  matcher_agree_on_exact_matches \\<gamma> common_matcher\n\ngoal (1 subgoal):\n 1. _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow \\<and>\n      newpkt p)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                   FinalAllow \\<and>\n                  newpkt p)", "apply(drule_tac rs=rs and \\<Gamma>=\\<Gamma> in FinalAllows_subseteq_in_doubt_allow)"], ["proof (prove)\ngoal (2 subgoals):\n 1. good_ruleset rs\n 2. _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                   FinalAllow) \\<Longrightarrow>\n    _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow \\<and>\n      newpkt p)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                   FinalAllow \\<and>\n                  newpkt p)", "using simple_imp_good_ruleset assms(4)"], ["proof (prove)\nusing this:\n  simple_ruleset ?rs \\<Longrightarrow> good_ruleset ?rs\n  simple_ruleset rs\n\ngoal (2 subgoals):\n 1. good_ruleset rs\n 2. _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                   FinalAllow) \\<Longrightarrow>\n    _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow \\<and>\n      newpkt p)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                   FinalAllow \\<and>\n                  newpkt p)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                   FinalAllow) \\<Longrightarrow>\n    _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow \\<and>\n      newpkt p)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                   FinalAllow \\<and>\n                  newpkt p)", "by blast"], ["proof (state)\nthis:\n  _Collect p\n   (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow \\<and>\n    newpkt p)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                 FinalAllow \\<and>\n                newpkt p)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "have 2: \"{p. (common_matcher, in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow \\<and> newpkt p} \\<subseteq>\n         {p. (common_matcher, in_doubt_allow),p\\<turnstile> \\<langle>preprocess rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow \\<and> newpkt p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect p\n     ((common_matcher,\n       in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                       FinalAllow \\<and>\n      newpkt p)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>preprocess\n                     rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                    FinalAllow \\<and>\n                  newpkt p)", "unfolding newpkt_def preprocess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect p\n     ((common_matcher,\n       in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                       FinalAllow \\<and>\n      match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n      p_tag_ctstate p = CT_New)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>upper_closure\n                     (packet_assume_new\n                       rs), Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n FinalAllow \\<and>\n                  match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n                  p_tag_ctstate p = CT_New)", "apply(subst transform_upper_closure(1)[OF s1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect p\n     ((common_matcher,\n       in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                       FinalAllow \\<and>\n      match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n      p_tag_ctstate p = CT_New)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>packet_assume_new\n                     rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                    FinalAllow \\<and>\n                  match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n                  p_tag_ctstate p = CT_New)", "apply(subst approximating_semantics_iff_fun_good_ruleset[OF simple_imp_good_ruleset[OF s1]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect p\n     ((common_matcher,\n       in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                       FinalAllow \\<and>\n      match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n      p_tag_ctstate p = CT_New)\n    \\<subseteq> _Collect p\n                 (approximating_bigstep_fun (common_matcher, in_doubt_allow)\n                   p (packet_assume_new rs) Undecided =\n                  Decision FinalAllow \\<and>\n                  match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n                  p_tag_ctstate p = CT_New)", "apply(subst approximating_semantics_iff_fun_good_ruleset[OF simple_imp_good_ruleset[OF simplers]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect p\n     (approximating_bigstep_fun (common_matcher, in_doubt_allow) p rs\n       Undecided =\n      Decision FinalAllow \\<and>\n      match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n      p_tag_ctstate p = CT_New)\n    \\<subseteq> _Collect p\n                 (approximating_bigstep_fun (common_matcher, in_doubt_allow)\n                   p (packet_assume_new rs) Undecided =\n                  Decision FinalAllow \\<and>\n                  match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n                  p_tag_ctstate p = CT_New)", "using packet_assume_new newpkt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>match_tcp_flags ipt_tcp_syn (p_tcp_flags ?p);\n   p_tag_ctstate ?p = CT_New\\<rbrakk>\n  \\<Longrightarrow> approximating_bigstep_fun (common_matcher, ?\\<alpha>) ?p\n                     (packet_assume_new ?rs) ?s =\n                    approximating_bigstep_fun (common_matcher, ?\\<alpha>) ?p\n                     ?rs ?s\n  newpkt ?p \\<equiv>\n  match_tcp_flags ipt_tcp_syn (p_tcp_flags ?p) \\<and>\n  p_tag_ctstate ?p = CT_New\n\ngoal (1 subgoal):\n 1. _Collect p\n     (approximating_bigstep_fun (common_matcher, in_doubt_allow) p rs\n       Undecided =\n      Decision FinalAllow \\<and>\n      match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n      p_tag_ctstate p = CT_New)\n    \\<subseteq> _Collect p\n                 (approximating_bigstep_fun (common_matcher, in_doubt_allow)\n                   p (packet_assume_new rs) Undecided =\n                  Decision FinalAllow \\<and>\n                  match_tcp_flags ipt_tcp_syn (p_tcp_flags p) \\<and>\n                  p_tag_ctstate p = CT_New)", "by force"], ["proof (state)\nthis:\n  _Collect p\n   ((common_matcher,\n     in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                     FinalAllow \\<and>\n    newpkt p)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>preprocess\n                   rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<and>\n                newpkt p)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "from 1 2"], ["proof (chain)\npicking this:\n  _Collect p\n   (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow \\<and>\n    newpkt p)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                 FinalAllow \\<and>\n                newpkt p)\n  _Collect p\n   ((common_matcher,\n     in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                     FinalAllow \\<and>\n    newpkt p)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>preprocess\n                   rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<and>\n                newpkt p)", "have \"{p. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow \\<and> newpkt p} \\<subseteq>\n         {p. (common_matcher, in_doubt_allow),p\\<turnstile> \\<langle>preprocess rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow \\<and> newpkt p}\""], ["proof (prove)\nusing this:\n  _Collect p\n   (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow \\<and>\n    newpkt p)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                 FinalAllow \\<and>\n                newpkt p)\n  _Collect p\n   ((common_matcher,\n     in_doubt_allow),p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                     FinalAllow \\<and>\n    newpkt p)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>preprocess\n                   rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<and>\n                newpkt p)\n\ngoal (1 subgoal):\n 1. _Collect p\n     (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n         FinalAllow \\<and>\n      newpkt p)\n    \\<subseteq> _Collect p\n                 ((common_matcher,\n                   in_doubt_allow),p\\<turnstile> \\<langle>preprocess\n                     rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                    FinalAllow \\<and>\n                  newpkt p)", "by simp"], ["proof (state)\nthis:\n  _Collect p\n   (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow \\<and>\n    newpkt p)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>preprocess\n                   rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<and>\n                newpkt p)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "hence p: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow \\<and> newpkt p \\<Longrightarrow>\n           (common_matcher, in_doubt_allow),p\\<turnstile> \\<langle>preprocess rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow \\<and> newpkt p\" for p"], ["proof (prove)\nusing this:\n  _Collect p\n   (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow \\<and>\n    newpkt p)\n  \\<subseteq> _Collect p\n               ((common_matcher,\n                 in_doubt_allow),p\\<turnstile> \\<langle>preprocess\n                   rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<and>\n                newpkt p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow \\<and>\n    newpkt p \\<Longrightarrow>\n    (common_matcher,\n     in_doubt_allow),p\\<turnstile> \\<langle>preprocess\n       rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                      FinalAllow \\<and>\n    newpkt p", "by blast"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,?p1\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow \\<and>\n  newpkt ?p1 \\<Longrightarrow>\n  (common_matcher,\n   in_doubt_allow),?p1\\<turnstile> \\<langle>preprocess\n       rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                      FinalAllow \\<and>\n  newpkt ?p1\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "have x: \"{p_src p | p . newpkt p \\<and> (\\<Gamma>,\\<gamma>,p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision FinalAllow)} \\<subseteq>\n            {p_src p | p . newpkt p \\<and> (common_matcher, in_doubt_allow),p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>preprocess rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> _Collect (p_src p)\n                 (newpkt p \\<and> (common_matcher, in_doubt_allow),p\n                  \\<lparr>p_iiface :=\n                            iface_sel\n                             iface\\<rparr>\\<turnstile> \\<langle>preprocess\n                           rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n    FinalAllow)", "apply(safe, rename_tac p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>newpkt p;\n        \\<Gamma>,\\<gamma>,p\n        \\<lparr>p_iiface :=\n                  iface_sel\n                   iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pa.\n                            p_src p = p_src pa \\<and>\n                            newpkt pa \\<and>\n                            (common_matcher, in_doubt_allow),pa\n                            \\<lparr>p_iiface :=\niface_sel\n iface\\<rparr>\\<turnstile> \\<langle>preprocess\n                                     rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n              FinalAllow", "apply(drule newpktD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\n                \\<lparr>p_iiface :=\n                          iface_sel\n                           iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow;\n        newpkt (p\\<lparr>p_iiface := iface_sel iface\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pa.\n                            p_src p = p_src pa \\<and>\n                            newpkt pa \\<and>\n                            (common_matcher, in_doubt_allow),pa\n                            \\<lparr>p_iiface :=\niface_sel\n iface\\<rparr>\\<turnstile> \\<langle>preprocess\n                                     rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n              FinalAllow", "apply(rule_tac x=\"p\\<lparr>p_iiface := iface_sel iface\\<rparr>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\n                \\<lparr>p_iiface :=\n                          iface_sel\n                           iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow;\n        newpkt (p\\<lparr>p_iiface := iface_sel iface\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> p_src p =\n                         p_src\n                          (p\\<lparr>p_iiface :=\niface_sel iface\\<rparr>) \\<and>\n                         newpkt\n                          (p\\<lparr>p_iiface :=\niface_sel iface\\<rparr>) \\<and>\n                         (common_matcher, in_doubt_allow),p\n                         \\<lparr>p_iiface := iface_sel iface,\n                            p_iiface :=\n                              iface_sel\n                               iface\\<rparr>\\<turnstile> \\<langle>preprocess\n                             rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n      FinalAllow", "using p"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,?p1\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n       FinalAllow \\<and>\n  newpkt ?p1 \\<Longrightarrow>\n  (common_matcher,\n   in_doubt_allow),?p1\\<turnstile> \\<langle>preprocess\n       rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                      FinalAllow \\<and>\n  newpkt ?p1\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\n                \\<lparr>p_iiface :=\n                          iface_sel\n                           iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n                        FinalAllow;\n        newpkt (p\\<lparr>p_iiface := iface_sel iface\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> p_src p =\n                         p_src\n                          (p\\<lparr>p_iiface :=\niface_sel iface\\<rparr>) \\<and>\n                         newpkt\n                          (p\\<lparr>p_iiface :=\niface_sel iface\\<rparr>) \\<and>\n                         (common_matcher, in_doubt_allow),p\n                         \\<lparr>p_iiface := iface_sel iface,\n                            p_iiface :=\n                              iface_sel\n                               iface\\<rparr>\\<turnstile> \\<langle>preprocess\n                             rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n      FinalAllow", "by simp"], ["proof (state)\nthis:\n  _Collect (p_src p)\n   (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n    \\<lparr>p_iiface :=\n              iface_sel\n               iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n            FinalAllow)\n  \\<subseteq> _Collect (p_src p)\n               (newpkt p \\<and> (common_matcher, in_doubt_allow),p\n                \\<lparr>p_iiface :=\n                          iface_sel\n                           iface\\<rparr>\\<turnstile> \\<langle>preprocess\n                         rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n  FinalAllow)\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "note[[show_types]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\nvariables:\n  ipassmt :: iface \\<Rightarrow> ('i word \\<times> nat) list option\n  rs :: 'i common_primitive rule list\n  iface :: iface\n  \\<gamma> ::\n    'i common_primitive\n    \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool\n  \\<Gamma> :: char list \\<Rightarrow> 'i common_primitive rule list option\n  newpkt :: ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool", "with nospoof"], ["proof (chain)\npicking this:\n  no_spoofing TYPE(?'a1)\n   (ipassmt::iface \\<Rightarrow> ('i word \\<times> nat) list option)\n   ((preprocess::'i common_primitive rule list\n                 \\<Rightarrow> 'i common_primitive rule list)\n     (rs::'i common_primitive rule list))", "have y: \n    \"{p_src p | p :: ('i::len,'pkt_ext) tagged_packet_scheme. newpkt p \\<and> (common_matcher, in_doubt_allow),p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>preprocess rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow}\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\nusing this:\n  no_spoofing TYPE(?'a1)\n   (ipassmt::iface \\<Rightarrow> ('i word \\<times> nat) list option)\n   ((preprocess::'i common_primitive rule list\n                 \\<Rightarrow> 'i common_primitive rule list)\n     (rs::'i common_primitive rule list))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> (common_matcher, in_doubt_allow),p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>preprocess\n               rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\nvariables:\n  ipassmt :: iface \\<Rightarrow> ('i word \\<times> nat) list option\n  rs :: 'i common_primitive rule list\n  preprocess ::\n    'i common_primitive rule list\n    \\<Rightarrow> 'i common_primitive rule list\n  iface :: iface\n  newpkt :: ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool", "apply(simp add: no_spoofing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>iface::iface\\<in>dom ipassmt.\n       \\<forall>p::('i, ?'a1) tagged_packet_scheme.\n          (common_matcher, in_doubt_allow),p\n          \\<lparr>p_iiface :=\n                    iface_sel\n                     iface\\<rparr>\\<turnstile> \\<langle>preprocess\n                   rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<longrightarrow>\n          p_src p\n          \\<in> ipcidr_union_set\n                 (set (the (ipassmt iface))) \\<Longrightarrow>\n    _Collect (p_src p)\n     (newpkt p \\<and> (common_matcher, in_doubt_allow),p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>preprocess\n               rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\nvariables:\n  iface :: iface\n  newpkt :: ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool\n  rs :: 'i common_primitive rule list\n  preprocess ::\n    'i common_primitive rule list\n    \\<Rightarrow> 'i common_primitive rule list\n  ipassmt :: iface \\<Rightarrow> ('i word \\<times> nat) list option", "by(blast dest: bspec[OF _ assms(6)])"], ["proof (state)\nthis:\n  _Collect (p_src p)\n   ((newpkt::('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool)\n     p \\<and>\n    (common_matcher, in_doubt_allow),p\n    \\<lparr>p_iiface :=\n              iface_sel\n               (iface::iface)\\<rparr>\\<turnstile> \\<langle>(preprocess::'i common_primitive rule list\n                                  \\<Rightarrow> 'i common_primitive rule list)\n                      (rs::'i common_primitive rule list), Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                FinalAllow)\n  \\<subseteq> ipcidr_union_set\n               (set (the ((ipassmt::iface\n                                    \\<Rightarrow> ('i word \\<times>\n             nat) list option)\n                           iface)))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\nvariables:\n  ipassmt :: iface \\<Rightarrow> ('i word \\<times> nat) list option\n  rs :: 'i common_primitive rule list\n  iface :: iface\n  \\<gamma> ::\n    'i common_primitive\n    \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool\n  \\<Gamma> :: char list \\<Rightarrow> 'i common_primitive rule list option\n  newpkt :: ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool", "from x y"], ["proof (chain)\npicking this:\n  _Collect (p_src p)\n   ((newpkt::('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool)\n     p \\<and>\n    (\\<Gamma>::char list\n               \\<Rightarrow> 'i common_primitive rule list option),(\\<gamma>::'i common_primitive\n  \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool),p\n    \\<lparr>p_iiface :=\n              iface_sel\n               (iface::iface)\\<rparr>\\<turnstile> \\<langle>(rs::'i common_primitive rule list), Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow)\n  \\<subseteq> _Collect (p_src p)\n               (newpkt p \\<and> (common_matcher, in_doubt_allow),p\n                \\<lparr>p_iiface :=\n                          iface_sel\n                           iface\\<rparr>\\<turnstile> \\<langle>(preprocess::'i common_primitive rule list\n                                     \\<Rightarrow> 'i common_primitive rule list)\n                         rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n  FinalAllow)\n  _Collect (p_src p)\n   ((newpkt::('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool)\n     p \\<and>\n    (common_matcher, in_doubt_allow),p\n    \\<lparr>p_iiface :=\n              iface_sel\n               (iface::iface)\\<rparr>\\<turnstile> \\<langle>(preprocess::'i common_primitive rule list\n                                  \\<Rightarrow> 'i common_primitive rule list)\n                      (rs::'i common_primitive rule list), Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                FinalAllow)\n  \\<subseteq> ipcidr_union_set\n               (set (the ((ipassmt::iface\n                                    \\<Rightarrow> ('i word \\<times>\n             nat) list option)\n                           iface)))", "show ?thesis"], ["proof (prove)\nusing this:\n  _Collect (p_src p)\n   ((newpkt::('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool)\n     p \\<and>\n    (\\<Gamma>::char list\n               \\<Rightarrow> 'i common_primitive rule list option),(\\<gamma>::'i common_primitive\n  \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool),p\n    \\<lparr>p_iiface :=\n              iface_sel\n               (iface::iface)\\<rparr>\\<turnstile> \\<langle>(rs::'i common_primitive rule list), Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow)\n  \\<subseteq> _Collect (p_src p)\n               (newpkt p \\<and> (common_matcher, in_doubt_allow),p\n                \\<lparr>p_iiface :=\n                          iface_sel\n                           iface\\<rparr>\\<turnstile> \\<langle>(preprocess::'i common_primitive rule list\n                                     \\<Rightarrow> 'i common_primitive rule list)\n                         rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n  FinalAllow)\n  _Collect (p_src p)\n   ((newpkt::('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool)\n     p \\<and>\n    (common_matcher, in_doubt_allow),p\n    \\<lparr>p_iiface :=\n              iface_sel\n               (iface::iface)\\<rparr>\\<turnstile> \\<langle>(preprocess::'i common_primitive rule list\n                                  \\<Rightarrow> 'i common_primitive rule list)\n                      (rs::'i common_primitive rule list), Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                FinalAllow)\n  \\<subseteq> ipcidr_union_set\n               (set (the ((ipassmt::iface\n                                    \\<Rightarrow> ('i word \\<times>\n             nat) list option)\n                           iface)))\n\ngoal (1 subgoal):\n 1. _Collect (p_src p)\n     (newpkt p \\<and> \\<Gamma>,\\<gamma>,p\n      \\<lparr>p_iiface :=\n                iface_sel\n                 iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Decision\n              FinalAllow)\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\nvariables:\n  ipassmt :: iface \\<Rightarrow> ('i word \\<times> nat) list option\n  rs :: 'i common_primitive rule list\n  iface :: iface\n  \\<gamma> ::\n    'i common_primitive\n    \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool\n  \\<Gamma> :: char list \\<Rightarrow> 'i common_primitive rule list option\n  newpkt :: ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool", "by simp"], ["proof (state)\nthis:\n  _Collect (p_src p)\n   ((newpkt::('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool)\n     p \\<and>\n    (\\<Gamma>::char list\n               \\<Rightarrow> 'i common_primitive rule list option),(\\<gamma>::'i common_primitive\n  \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool),p\n    \\<lparr>p_iiface :=\n              iface_sel\n               (iface::iface)\\<rparr>\\<turnstile> \\<langle>(rs::'i common_primitive rule list), Undecided\\<rangle> \\<Rightarrow> Decision\n                FinalAllow)\n  \\<subseteq> ipcidr_union_set\n               (set (the ((ipassmt::iface\n                                    \\<Rightarrow> ('i word \\<times>\n             nat) list option)\n                           iface)))\n\ngoal:\nNo subgoals!\nvariables:\n  ipassmt :: iface \\<Rightarrow> ('i word \\<times> nat) list option\n  rs :: 'i common_primitive rule list\n  iface :: iface\n  \\<gamma> ::\n    'i common_primitive\n    \\<Rightarrow> ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool\n  \\<Gamma> :: char list \\<Rightarrow> 'i common_primitive rule list option\n  newpkt :: ('i, 'pkt_ext) tagged_packet_scheme \\<Rightarrow> bool", "qed"], ["", "end"]]}