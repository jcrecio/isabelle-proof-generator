{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Call_Return_Unfolding.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma process_ret_split_fst_Return:\n  \"a = Return \\<Longrightarrow> process_ret (Rule m a # rs) = add_match (MatchNot m) (process_ret rs)\"", "lemma process_ret_split_fst_NeqReturn:\n  \"a \\<noteq> Return \\<Longrightarrow> process_ret((Rule m a) # rs) = (Rule m a) # (process_ret rs)\"", "lemma add_match_simp: \"add_match m = map (\\<lambda>r. Rule (MatchAnd m (get_match r)) (get_action r))\"", "lemma add_match_add_match_MatchAnd_foldr:\n  \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (add_match_MatchAnd_foldr ms rs2), s\\<rangle> \\<Rightarrow> t = \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchAnd_foldr (m#ms)) rs2, s\\<rangle> \\<Rightarrow> t\"", "lemma add_match_MatchAnd_foldr_empty_rs2: \"add_match_MatchAnd_foldr ms [] = []\"", "lemma add_missing_ret_unfoldings_alt: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs1 rs2, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(add_match_MatchAnd_foldr (map (\\<lambda>r. MatchNot (get_match r)) [r\\<leftarrow>rs1. get_action r = Return])) rs2, s \\<rangle> \\<Rightarrow> t\"", "lemma add_match_add_missing_ret_unfoldings_rot:\n  \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (add_missing_ret_unfoldings rs1 rs2), s\\<rangle> \\<Rightarrow> t =  \n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings (Rule (MatchNot m) Return#rs1) rs2, s\\<rangle> \\<Rightarrow> t\"", "lemma process_ret_split_obvious: \"process_ret (rs\\<^sub>1 @ rs\\<^sub>2) = \n  (process_ret rs\\<^sub>1) @ (add_missing_ret_unfoldings rs\\<^sub>1 (process_ret rs\\<^sub>2))\"", "lemma add_missing_ret_unfoldings_emptyrs2: \"add_missing_ret_unfoldings rs1 [] = []\"", "lemma process_call_split: \"process_call \\<Gamma> (rs1 @ rs2) = process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2\"", "lemma process_call_split_fst: \"process_call \\<Gamma> (a # rs) = process_call \\<Gamma> [a] @ process_call \\<Gamma> rs\"", "lemma iptables_bigstep_process_ret_undecided: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> t\"", "lemma add_match_rot_add_missing_ret_unfoldings:\n  \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (add_missing_ret_unfoldings rs1 rs2), Undecided\\<rangle> \\<Rightarrow> Undecided =\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs1 (add_match m rs2), Undecided\\<rangle> \\<Rightarrow> Undecided\"", "theorem unfolding_complete: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs,s\\<rangle> \\<Rightarrow> t  \\<Longrightarrow>  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma> rs,s\\<rangle> \\<Rightarrow> t\"", "lemma process_ret_cases:\n  \"process_ret rs = rs \\<or> (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. rs = rs\\<^sub>1@[Rule m Return]@rs\\<^sub>2 \\<and> (process_ret rs) = rs\\<^sub>1@(process_ret ([Rule m Return]@rs\\<^sub>2)))\"", "lemma process_ret_splitcases:\n  obtains (id) \"process_ret rs = rs\"\n        | (split) rs\\<^sub>1 rs\\<^sub>2 m where \"rs = rs\\<^sub>1@[Rule m Return]@rs\\<^sub>2\" and \"process_ret rs = rs\\<^sub>1@(process_ret ([Rule m Return]@rs\\<^sub>2))\"", "lemma iptables_bigstep_process_ret_cases3:\n  assumes \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\"\n  obtains (noreturn) \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\"\n        | (return) rs\\<^sub>1 rs\\<^sub>2 m where \"rs = rs\\<^sub>1@[Rule m Return]@rs\\<^sub>2\" \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\" \"matches \\<gamma> m p\"", "lemma iptables_bigstep_process_ret_DecisionD: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision X\"", "lemma process_ret_add_match_dist1: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t\"", "lemma process_ret_add_match_dist2: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t\"", "lemma process_ret_add_match_dist: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t\"", "lemma process_ret_Undecided_sound:\n  assumes \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Undecided\"\n  shows \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\"", "lemma process_ret_Decision_sound:\n  assumes \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Decision X\"\n  shows \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\"", "lemma process_ret_result_empty: \"[] = process_ret rs \\<Longrightarrow> \\<forall>r \\<in> set rs. get_action r = Return\"", "lemma process_ret_sound':\n  assumes \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), Undecided\\<rangle> \\<Rightarrow> t\"\n  shows \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> t\"", "lemma wf_chain_process_ret: \"wf_chain \\<Gamma> rs \\<Longrightarrow> wf_chain \\<Gamma> (process_ret rs)\"", "lemma wf_chain_add_match: \"wf_chain \\<Gamma> rs \\<Longrightarrow> wf_chain \\<Gamma> (add_match m rs)\"", "theorem unfolding_sound: \"wf_chain \\<Gamma> rs \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\"", "lemma \"process_call [''X'' \\<mapsto> [Rule (Match b) Return, Rule (Match c) Accept]] [Rule (Match a) (Call ''X'')] =\n       [Rule (MatchAnd (Match a) (MatchAnd (MatchNot (Match b)) (Match c))) Accept]\"", "theorem repeat_stabilize_process_call:\n    assumes \"sanity_wf_ruleset \\<Gamma>\" and \"chain_name \\<in> set (map fst \\<Gamma>)\" and \"default_action = Accept \\<or> default_action = Drop\"\n    shows \"(map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n (process_call (map_of \\<Gamma>)) [Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n           (map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\"", "lemma unfold_optimize_ruleset_CHAIN:\n    assumes \"sanity_wf_ruleset \\<Gamma>\" and \"chain_name \\<in> set (map fst \\<Gamma>)\"\n    and \"default_action = Accept \\<or> default_action = Drop\"\n    and \"\\<And>m. matches \\<gamma> (optimize m) p = matches \\<gamma> m p\"\n    and \"unfold_optimize_ruleset_CHAIN optimize chain_name default_action (map_of \\<Gamma>) = Some rs\"\n    shows \"(map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n           (map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\""], "translations": [["", "lemma process_ret_split_fst_Return:\n  \"a = Return \\<Longrightarrow> process_ret (Rule m a # rs) = add_match (MatchNot m) (process_ret rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = Return \\<Longrightarrow>\n    process_ret (Rule m a # rs) = add_match (MatchNot m) (process_ret rs)", "by auto"], ["", "lemma process_ret_split_fst_NeqReturn:\n  \"a \\<noteq> Return \\<Longrightarrow> process_ret((Rule m a) # rs) = (Rule m a) # (process_ret rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> Return \\<Longrightarrow>\n    process_ret (Rule m a # rs) = Rule m a # process_ret rs", "by (cases a) auto"], ["", "lemma add_match_simp: \"add_match m = map (\\<lambda>r. Rule (MatchAnd m (get_match r)) (get_action r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_match m =\n    map (\\<lambda>r. Rule (MatchAnd m (get_match r)) (get_action r))", "by (auto simp: add_match_def cong: map_cong split: rule.split)"], ["", "definition add_missing_ret_unfoldings :: \"'a rule list \\<Rightarrow> 'a rule list \\<Rightarrow> 'a rule list\" where\n  \"add_missing_ret_unfoldings rs1 rs2 \\<equiv> \n  foldr (\\<lambda>rf acc. add_match (MatchNot (get_match rf)) \\<circ> acc) [r\\<leftarrow>rs1. get_action r = Return] id rs2\""], ["", "fun MatchAnd_foldr :: \"'a match_expr list \\<Rightarrow> 'a match_expr\" where\n  \"MatchAnd_foldr [] = undefined\" | (*error, semantically, MatchAny would match*)\n  \"MatchAnd_foldr [e] = e\" |\n  \"MatchAnd_foldr (e # es) = MatchAnd e (MatchAnd_foldr es)\""], ["", "fun add_match_MatchAnd_foldr :: \"'a match_expr list \\<Rightarrow> ('a rule list \\<Rightarrow> 'a rule list)\" where\n  \"add_match_MatchAnd_foldr [] = id\" |\n  \"add_match_MatchAnd_foldr es = add_match (MatchAnd_foldr es)\""], ["", "lemma add_match_add_match_MatchAnd_foldr:\n  \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (add_match_MatchAnd_foldr ms rs2), s\\<rangle> \\<Rightarrow> t = \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchAnd_foldr (m#ms)) rs2, s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_match_MatchAnd_foldr ms rs2), s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n        (MatchAnd_foldr (m # ms)) rs2, s\\<rangle> \\<Rightarrow> t", "proof (induction ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_match_MatchAnd_foldr [] rs2), s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchAnd_foldr [m])\n        rs2, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>a ms.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr ms rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # ms))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr (a # ms)\n             rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # a # ms)) rs2, s\\<rangle> \\<Rightarrow> t", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_match_MatchAnd_foldr [] rs2), s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchAnd_foldr [m])\n        rs2, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>a ms.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr ms rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # ms))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr (a # ms)\n             rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # a # ms)) rs2, s\\<rangle> \\<Rightarrow> t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_match_MatchAnd_foldr [] rs2), s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchAnd_foldr [m])\n        rs2, s\\<rangle> \\<Rightarrow> t", "by (simp add: add_match_def)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n      (add_match_MatchAnd_foldr [] rs2), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchAnd_foldr [m])\n      rs2, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr ms rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # ms))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr (a # ms)\n             rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # a # ms)) rs2, s\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr ms rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # ms))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr (a # ms)\n             rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # a # ms)) rs2, s\\<rangle> \\<Rightarrow> t", "case Cons"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n      (add_match_MatchAnd_foldr ms_ rs2), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n      (MatchAnd_foldr (m # ms_)) rs2, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr ms rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # ms))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr (a # ms)\n             rs2), s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n           (MatchAnd_foldr (m # a # ms)) rs2, s\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n      (add_match_MatchAnd_foldr ms_ rs2), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n      (MatchAnd_foldr (m # ms_)) rs2, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_match_MatchAnd_foldr (a_ # ms_)\n          rs2), s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n        (MatchAnd_foldr (m # a_ # ms_)) rs2, s\\<rangle> \\<Rightarrow> t", "by (simp add: iptables_bigstep_add_match_and)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n      (add_match_MatchAnd_foldr (a_ # ms_)\n        rs2), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n      (MatchAnd_foldr (m # a_ # ms_)) rs2, s\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_match_MatchAnd_foldr_empty_rs2: \"add_match_MatchAnd_foldr ms [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_match_MatchAnd_foldr ms [] = []", "by (induction ms) (simp_all add: add_match_def)"], ["", "lemma add_missing_ret_unfoldings_alt: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs1 rs2, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(add_match_MatchAnd_foldr (map (\\<lambda>r. MatchNot (get_match r)) [r\\<leftarrow>rs1. get_action r = Return])) rs2, s \\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs1\n        rs2, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) rs1))\n        rs2, s\\<rangle> \\<Rightarrow> t", "proof(induction rs1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings []\n        rs2, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) []))\n        rs2, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>a rs1.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           rs1 rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) rs1))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           (a # rs1) rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) (a # rs1)))\n           rs2, s\\<rangle> \\<Rightarrow> t", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings []\n        rs2, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) []))\n        rs2, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>a rs1.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           rs1 rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) rs1))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           (a # rs1) rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) (a # rs1)))\n           rs2, s\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings []\n        rs2, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) []))\n        rs2, s\\<rangle> \\<Rightarrow> t", "unfolding add_missing_ret_unfoldings_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>foldr\n        (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) []) id\n        rs2, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) []))\n        rs2, s\\<rangle> \\<Rightarrow> t", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings []\n      rs2, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n      (map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) []))\n      rs2, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>a rs1.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           rs1 rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) rs1))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           (a # rs1) rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) (a # rs1)))\n           rs2, s\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs1.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           rs1 rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) rs1))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           (a # rs1) rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) (a # rs1)))\n           rs2, s\\<rangle> \\<Rightarrow> t", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs\n      rs2, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n      (map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) rs))\n      rs2, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>a rs1.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           rs1 rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) rs1))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           (a # rs1) rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) (a # rs1)))\n           rs2, s\\<rangle> \\<Rightarrow> t", "from Cons"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs\n      rs2, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n      (map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) rs))\n      rs2, s\\<rangle> \\<Rightarrow> t", "obtain m a where \"r = Rule m a\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs\n      rs2, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n      (map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) rs))\n      rs2, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. (\\<And>m a. r = Rule m a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases r) (simp)"], ["proof (state)\nthis:\n  r = Rule m a\n\ngoal (1 subgoal):\n 1. \\<And>a rs1.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           rs1 rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) rs1))\n           rs2, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n           (a # rs1) rs2, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) (a # rs1)))\n           rs2, s\\<rangle> \\<Rightarrow> t", "with Cons"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs\n      rs2, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n      (map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) rs))\n      rs2, s\\<rangle> \\<Rightarrow> t\n  r = Rule m a", "show ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs\n      rs2, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n      (map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) rs))\n      rs2, s\\<rangle> \\<Rightarrow> t\n  r = Rule m a\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n        (r # rs) rs2, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) (r # rs)))\n        rs2, s\\<rangle> \\<Rightarrow> t", "unfolding add_missing_ret_unfoldings_def"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>foldr\n      (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n      (filter (\\<lambda>r. get_action r = Return) rs) id\n      rs2, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n      (map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) rs))\n      rs2, s\\<rangle> \\<Rightarrow> t\n  r = Rule m a\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>foldr\n        (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) (r # rs)) id\n        rs2, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) (r # rs)))\n        rs2, s\\<rangle> \\<Rightarrow> t", "apply(cases \"matches \\<gamma> m p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 rs2, s\\<rangle> \\<Rightarrow> t =\n             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n                 (map (\\<lambda>r. MatchNot (get_match r))\n                   (filter (\\<lambda>r. get_action r = Return) rs))\n                 rs2, s\\<rangle> \\<Rightarrow> t;\n     r = Rule m a; matches \\<gamma> m p\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>foldr\n                          (\\<lambda>rf.\n                              (\\<circ>)\n                               (add_match (MatchNot (get_match rf))))\n                          (filter (\\<lambda>r. get_action r = Return)\n                            (r # rs))\n                          id rs2, s\\<rangle> \\<Rightarrow> t =\n                      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n                          (map (\\<lambda>r. MatchNot (get_match r))\n                            (filter (\\<lambda>r. get_action r = Return)\n                              (r # rs)))\n                          rs2, s\\<rangle> \\<Rightarrow> t\n 2. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 rs2, s\\<rangle> \\<Rightarrow> t =\n             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n                 (map (\\<lambda>r. MatchNot (get_match r))\n                   (filter (\\<lambda>r. get_action r = Return) rs))\n                 rs2, s\\<rangle> \\<Rightarrow> t;\n     r = Rule m a; \\<not> matches \\<gamma> m p\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>foldr\n                          (\\<lambda>rf.\n                              (\\<circ>)\n                               (add_match (MatchNot (get_match rf))))\n                          (filter (\\<lambda>r. get_action r = Return)\n                            (r # rs))\n                          id rs2, s\\<rangle> \\<Rightarrow> t =\n                      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n                          (map (\\<lambda>r. MatchNot (get_match r))\n                            (filter (\\<lambda>r. get_action r = Return)\n                              (r # rs)))\n                          rs2, s\\<rangle> \\<Rightarrow> t", "apply (simp_all add: matches_add_match_simp matches_add_match_MatchNot_simp add_match_add_match_MatchAnd_foldr[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n      (r # rs) rs2, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n      (map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) (r # rs)))\n      rs2, s\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_match_add_missing_ret_unfoldings_rot:\n  \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (add_missing_ret_unfoldings rs1 rs2), s\\<rangle> \\<Rightarrow> t =  \n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings (Rule (MatchNot m) Return#rs1) rs2, s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_missing_ret_unfoldings rs1 rs2), s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings\n        (Rule (MatchNot m) Return # rs1) rs2, s\\<rangle> \\<Rightarrow> t", "by(simp add: add_missing_ret_unfoldings_def iptables_bigstep_add_match_notnot_simp)"], ["", "subsection\\<open>Completeness\\<close>"], ["", "lemma process_ret_split_obvious: \"process_ret (rs\\<^sub>1 @ rs\\<^sub>2) = \n  (process_ret rs\\<^sub>1) @ (add_missing_ret_unfoldings rs\\<^sub>1 (process_ret rs\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_ret (rs\\<^sub>1 @ rs\\<^sub>2) =\n    process_ret rs\\<^sub>1 @\n    add_missing_ret_unfoldings rs\\<^sub>1 (process_ret rs\\<^sub>2)", "unfolding add_missing_ret_unfoldings_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. process_ret (rs\\<^sub>1 @ rs\\<^sub>2) =\n    process_ret rs\\<^sub>1 @\n    foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n     (filter (\\<lambda>r. get_action r = Return) rs\\<^sub>1) id\n     (process_ret rs\\<^sub>2)", "proof (induction rs\\<^sub>1 arbitrary: rs\\<^sub>2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rs\\<^sub>2.\n       process_ret ([] @ rs\\<^sub>2) =\n       process_ret [] @\n       foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) []) id\n        (process_ret rs\\<^sub>2)\n 2. \\<And>a rs\\<^sub>1 rs\\<^sub>2.\n       (\\<And>rs\\<^sub>2.\n           process_ret (rs\\<^sub>1 @ rs\\<^sub>2) =\n           process_ret rs\\<^sub>1 @\n           foldr\n            (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n            (filter (\\<lambda>r. get_action r = Return) rs\\<^sub>1) id\n            (process_ret rs\\<^sub>2)) \\<Longrightarrow>\n       process_ret ((a # rs\\<^sub>1) @ rs\\<^sub>2) =\n       process_ret (a # rs\\<^sub>1) @\n       foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) (a # rs\\<^sub>1)) id\n        (process_ret rs\\<^sub>2)", "case (Cons r rs)"], ["proof (state)\nthis:\n  process_ret (rs @ ?rs\\<^sub>2) =\n  process_ret rs @\n  foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n   (filter (\\<lambda>r. get_action r = Return) rs) id\n   (process_ret ?rs\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>rs\\<^sub>2.\n       process_ret ([] @ rs\\<^sub>2) =\n       process_ret [] @\n       foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) []) id\n        (process_ret rs\\<^sub>2)\n 2. \\<And>a rs\\<^sub>1 rs\\<^sub>2.\n       (\\<And>rs\\<^sub>2.\n           process_ret (rs\\<^sub>1 @ rs\\<^sub>2) =\n           process_ret rs\\<^sub>1 @\n           foldr\n            (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n            (filter (\\<lambda>r. get_action r = Return) rs\\<^sub>1) id\n            (process_ret rs\\<^sub>2)) \\<Longrightarrow>\n       process_ret ((a # rs\\<^sub>1) @ rs\\<^sub>2) =\n       process_ret (a # rs\\<^sub>1) @\n       foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) (a # rs\\<^sub>1)) id\n        (process_ret rs\\<^sub>2)", "from Cons"], ["proof (chain)\npicking this:\n  process_ret (rs @ ?rs\\<^sub>2) =\n  process_ret rs @\n  foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n   (filter (\\<lambda>r. get_action r = Return) rs) id\n   (process_ret ?rs\\<^sub>2)", "obtain m a where \"r = Rule m a\""], ["proof (prove)\nusing this:\n  process_ret (rs @ ?rs\\<^sub>2) =\n  process_ret rs @\n  foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n   (filter (\\<lambda>r. get_action r = Return) rs) id\n   (process_ret ?rs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>m a. r = Rule m a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) simp"], ["proof (state)\nthis:\n  r = Rule m a\n\ngoal (2 subgoals):\n 1. \\<And>rs\\<^sub>2.\n       process_ret ([] @ rs\\<^sub>2) =\n       process_ret [] @\n       foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) []) id\n        (process_ret rs\\<^sub>2)\n 2. \\<And>a rs\\<^sub>1 rs\\<^sub>2.\n       (\\<And>rs\\<^sub>2.\n           process_ret (rs\\<^sub>1 @ rs\\<^sub>2) =\n           process_ret rs\\<^sub>1 @\n           foldr\n            (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n            (filter (\\<lambda>r. get_action r = Return) rs\\<^sub>1) id\n            (process_ret rs\\<^sub>2)) \\<Longrightarrow>\n       process_ret ((a # rs\\<^sub>1) @ rs\\<^sub>2) =\n       process_ret (a # rs\\<^sub>1) @\n       foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) (a # rs\\<^sub>1)) id\n        (process_ret rs\\<^sub>2)", "with Cons.IH"], ["proof (chain)\npicking this:\n  process_ret (rs @ ?rs\\<^sub>2) =\n  process_ret rs @\n  foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n   (filter (\\<lambda>r. get_action r = Return) rs) id\n   (process_ret ?rs\\<^sub>2)\n  r = Rule m a", "show ?case"], ["proof (prove)\nusing this:\n  process_ret (rs @ ?rs\\<^sub>2) =\n  process_ret rs @\n  foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n   (filter (\\<lambda>r. get_action r = Return) rs) id\n   (process_ret ?rs\\<^sub>2)\n  r = Rule m a\n\ngoal (1 subgoal):\n 1. process_ret ((r # rs) @ rs\\<^sub>2) =\n    process_ret (r # rs) @\n    foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n     (filter (\\<lambda>r. get_action r = Return) (r # rs)) id\n     (process_ret rs\\<^sub>2)", "apply(cases a)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<And>rs\\<^sub>2.\n                process_ret (rs @ rs\\<^sub>2) =\n                process_ret rs @\n                foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 (process_ret rs\\<^sub>2);\n     r = Rule m a; a = Accept\\<rbrakk>\n    \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                      process_ret (r # rs) @\n                      foldr\n                       (\\<lambda>rf.\n                           (\\<circ>) (add_match (MatchNot (get_match rf))))\n                       (filter (\\<lambda>r. get_action r = Return) (r # rs))\n                       id (process_ret rs\\<^sub>2)\n 2. \\<lbrakk>\\<And>rs\\<^sub>2.\n                process_ret (rs @ rs\\<^sub>2) =\n                process_ret rs @\n                foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 (process_ret rs\\<^sub>2);\n     r = Rule m a; a = Drop\\<rbrakk>\n    \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                      process_ret (r # rs) @\n                      foldr\n                       (\\<lambda>rf.\n                           (\\<circ>) (add_match (MatchNot (get_match rf))))\n                       (filter (\\<lambda>r. get_action r = Return) (r # rs))\n                       id (process_ret rs\\<^sub>2)\n 3. \\<lbrakk>\\<And>rs\\<^sub>2.\n                process_ret (rs @ rs\\<^sub>2) =\n                process_ret rs @\n                foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 (process_ret rs\\<^sub>2);\n     r = Rule m a; a = Log\\<rbrakk>\n    \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                      process_ret (r # rs) @\n                      foldr\n                       (\\<lambda>rf.\n                           (\\<circ>) (add_match (MatchNot (get_match rf))))\n                       (filter (\\<lambda>r. get_action r = Return) (r # rs))\n                       id (process_ret rs\\<^sub>2)\n 4. \\<lbrakk>\\<And>rs\\<^sub>2.\n                process_ret (rs @ rs\\<^sub>2) =\n                process_ret rs @\n                foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 (process_ret rs\\<^sub>2);\n     r = Rule m a; a = Reject\\<rbrakk>\n    \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                      process_ret (r # rs) @\n                      foldr\n                       (\\<lambda>rf.\n                           (\\<circ>) (add_match (MatchNot (get_match rf))))\n                       (filter (\\<lambda>r. get_action r = Return) (r # rs))\n                       id (process_ret rs\\<^sub>2)\n 5. \\<And>x5.\n       \\<lbrakk>\\<And>rs\\<^sub>2.\n                   process_ret (rs @ rs\\<^sub>2) =\n                   process_ret rs @\n                   foldr\n                    (\\<lambda>rf.\n                        (\\<circ>) (add_match (MatchNot (get_match rf))))\n                    (filter (\\<lambda>r. get_action r = Return) rs) id\n                    (process_ret rs\\<^sub>2);\n        r = Rule m a; a = Call x5\\<rbrakk>\n       \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                         process_ret (r # rs) @\n                         foldr\n                          (\\<lambda>rf.\n                              (\\<circ>)\n                               (add_match (MatchNot (get_match rf))))\n                          (filter (\\<lambda>r. get_action r = Return)\n                            (r # rs))\n                          id (process_ret rs\\<^sub>2)\n 6. \\<lbrakk>\\<And>rs\\<^sub>2.\n                process_ret (rs @ rs\\<^sub>2) =\n                process_ret rs @\n                foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 (process_ret rs\\<^sub>2);\n     r = Rule m a; a = Return\\<rbrakk>\n    \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                      process_ret (r # rs) @\n                      foldr\n                       (\\<lambda>rf.\n                           (\\<circ>) (add_match (MatchNot (get_match rf))))\n                       (filter (\\<lambda>r. get_action r = Return) (r # rs))\n                       id (process_ret rs\\<^sub>2)\n 7. \\<And>x7.\n       \\<lbrakk>\\<And>rs\\<^sub>2.\n                   process_ret (rs @ rs\\<^sub>2) =\n                   process_ret rs @\n                   foldr\n                    (\\<lambda>rf.\n                        (\\<circ>) (add_match (MatchNot (get_match rf))))\n                    (filter (\\<lambda>r. get_action r = Return) rs) id\n                    (process_ret rs\\<^sub>2);\n        r = Rule m a; a = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                         process_ret (r # rs) @\n                         foldr\n                          (\\<lambda>rf.\n                              (\\<circ>)\n                               (add_match (MatchNot (get_match rf))))\n                          (filter (\\<lambda>r. get_action r = Return)\n                            (r # rs))\n                          id (process_ret rs\\<^sub>2)\n 8. \\<lbrakk>\\<And>rs\\<^sub>2.\n                process_ret (rs @ rs\\<^sub>2) =\n                process_ret rs @\n                foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 (process_ret rs\\<^sub>2);\n     r = Rule m a; a = Empty\\<rbrakk>\n    \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                      process_ret (r # rs) @\n                      foldr\n                       (\\<lambda>rf.\n                           (\\<circ>) (add_match (MatchNot (get_match rf))))\n                       (filter (\\<lambda>r. get_action r = Return) (r # rs))\n                       id (process_ret rs\\<^sub>2)\n 9. \\<lbrakk>\\<And>rs\\<^sub>2.\n                process_ret (rs @ rs\\<^sub>2) =\n                process_ret rs @\n                foldr\n                 (\\<lambda>rf.\n                     (\\<circ>) (add_match (MatchNot (get_match rf))))\n                 (filter (\\<lambda>r. get_action r = Return) rs) id\n                 (process_ret rs\\<^sub>2);\n     r = Rule m a; a = Unknown\\<rbrakk>\n    \\<Longrightarrow> process_ret ((r # rs) @ rs\\<^sub>2) =\n                      process_ret (r # rs) @\n                      foldr\n                       (\\<lambda>rf.\n                           (\\<circ>) (add_match (MatchNot (get_match rf))))\n                       (filter (\\<lambda>r. get_action r = Return) (r # rs))\n                       id (process_ret rs\\<^sub>2)", "apply(simp_all add: add_match_split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  process_ret ((r # rs) @ rs\\<^sub>2) =\n  process_ret (r # rs) @\n  foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n   (filter (\\<lambda>r. get_action r = Return) (r # rs)) id\n   (process_ret rs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>rs\\<^sub>2.\n       process_ret ([] @ rs\\<^sub>2) =\n       process_ret [] @\n       foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n        (filter (\\<lambda>r. get_action r = Return) []) id\n        (process_ret rs\\<^sub>2)", "qed simp"], ["", "lemma add_missing_ret_unfoldings_emptyrs2: \"add_missing_ret_unfoldings rs1 [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_missing_ret_unfoldings rs1 [] = []", "unfolding add_missing_ret_unfoldings_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>rf. (\\<circ>) (add_match (MatchNot (get_match rf))))\n     (filter (\\<lambda>r. get_action r = Return) rs1) id [] =\n    []", "by (induction rs1) (simp_all add: add_match_def)"], ["", "lemma process_call_split: \"process_call \\<Gamma> (rs1 @ rs2) = process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_call \\<Gamma> (rs1 @ rs2) =\n    process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2", "proof (induction rs1)"], ["proof (state)\ngoal (2 subgoals):\n 1. process_call \\<Gamma> ([] @ rs2) =\n    process_call \\<Gamma> [] @ process_call \\<Gamma> rs2\n 2. \\<And>a rs1.\n       process_call \\<Gamma> (rs1 @ rs2) =\n       process_call \\<Gamma> rs1 @\n       process_call \\<Gamma> rs2 \\<Longrightarrow>\n       process_call \\<Gamma> ((a # rs1) @ rs2) =\n       process_call \\<Gamma> (a # rs1) @ process_call \\<Gamma> rs2", "case (Cons r rs1)"], ["proof (state)\nthis:\n  process_call \\<Gamma> (rs1 @ rs2) =\n  process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2\n\ngoal (2 subgoals):\n 1. process_call \\<Gamma> ([] @ rs2) =\n    process_call \\<Gamma> [] @ process_call \\<Gamma> rs2\n 2. \\<And>a rs1.\n       process_call \\<Gamma> (rs1 @ rs2) =\n       process_call \\<Gamma> rs1 @\n       process_call \\<Gamma> rs2 \\<Longrightarrow>\n       process_call \\<Gamma> ((a # rs1) @ rs2) =\n       process_call \\<Gamma> (a # rs1) @ process_call \\<Gamma> rs2", "thus ?case"], ["proof (prove)\nusing this:\n  process_call \\<Gamma> (rs1 @ rs2) =\n  process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2\n\ngoal (1 subgoal):\n 1. process_call \\<Gamma> ((r # rs1) @ rs2) =\n    process_call \\<Gamma> (r # rs1) @ process_call \\<Gamma> rs2", "apply(cases r, rename_tac m a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2", "apply(case_tac a)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2\n 2. \\<And>m a.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Drop\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2\n 3. \\<And>m a.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Log\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2\n 4. \\<And>m a.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Reject\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2\n 5. \\<And>m a x5.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Call x5\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2\n 6. \\<And>m a.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Return\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2\n 7. \\<And>m a x7.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2\n 8. \\<And>m a.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Empty\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2\n 9. \\<And>m a.\n       \\<lbrakk>process_call \\<Gamma> (rs1 @ rs2) =\n                process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        r = Rule m a;\n        process_call \\<Gamma> (rs1 @ rs2) =\n        process_call \\<Gamma> rs1 @ process_call \\<Gamma> rs2;\n        a = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_call \\<Gamma> ((r # rs1) @ rs2) =\n                         process_call \\<Gamma> (r # rs1) @\n                         process_call \\<Gamma> rs2", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  process_call \\<Gamma> ((r # rs1) @ rs2) =\n  process_call \\<Gamma> (r # rs1) @ process_call \\<Gamma> rs2\n\ngoal (1 subgoal):\n 1. process_call \\<Gamma> ([] @ rs2) =\n    process_call \\<Gamma> [] @ process_call \\<Gamma> rs2", "qed simp"], ["", "lemma process_call_split_fst: \"process_call \\<Gamma> (a # rs) = process_call \\<Gamma> [a] @ process_call \\<Gamma> rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_call \\<Gamma> (a # rs) =\n    process_call \\<Gamma> [a] @ process_call \\<Gamma> rs", "by (simp add: process_call_split[symmetric])"], ["", "lemma iptables_bigstep_process_ret_undecided: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs, Undecided\\<rangle> \\<Rightarrow> t", "proof (induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        [], Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                    rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n           rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (a # rs), Undecided\\<rangle> \\<Rightarrow> t", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        [], Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                    rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n           rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (a # rs), Undecided\\<rangle> \\<Rightarrow> t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "proof (cases r)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       r = Rule x1 x2 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case (Rule m' a')"], ["proof (state)\nthis:\n  r = Rule m' a'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       r = Rule x1 x2 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "show \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret (r # rs), Undecided\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "proof (cases a')"], ["proof (state)\ngoal (9 subgoals):\n 1. a' = Accept \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Drop \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Log \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 7. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 8. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 9. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Accept"], ["proof (state)\nthis:\n  a' = Accept\n\ngoal (9 subgoals):\n 1. a' = Accept \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Drop \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Log \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 7. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 8. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 9. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "with Cons Rule"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Accept", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Accept\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by simp (metis acceptD decision decisionD nomatchD seqE_cons seq_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (8 subgoals):\n 1. a' = Drop \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Log \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 7. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 8. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. a' = Drop \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Log \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 7. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 8. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Drop"], ["proof (state)\nthis:\n  a' = Drop\n\ngoal (8 subgoals):\n 1. a' = Drop \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Log \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 7. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 8. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "with Cons Rule"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Drop", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Drop\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by simp (metis decision decisionD dropD nomatchD seqE_cons seq_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (7 subgoals):\n 1. a' = Log \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 7. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. a' = Log \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 7. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Log"], ["proof (state)\nthis:\n  a' = Log\n\ngoal (7 subgoals):\n 1. a' = Log \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 7. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "with Cons Rule"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Log", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Log\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by simp (metis logD nomatchD seqE_cons seq_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (6 subgoals):\n 1. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Reject"], ["proof (state)\nthis:\n  a' = Reject\n\ngoal (6 subgoals):\n 1. a' = Reject \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 6. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "with Cons Rule"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Reject", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Reject\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by simp (metis decision decisionD nomatchD rejectD seqE_cons seq_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (5 subgoals):\n 1. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case (Call chain)"], ["proof (state)\nthis:\n  a' = Call chain\n\ngoal (5 subgoals):\n 1. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "from Cons.prems"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t", "obtain ti where 1:\"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti\" and 2: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. (\\<And>ti.\n        \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using seqE_cons"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r #\n                 ?rs, ?s\\<rangle> \\<Rightarrow> ?t;\n   \\<And>ti.\n      \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>[?r], ?s\\<rangle> \\<Rightarrow> ti;\n       ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ti\\<rangle> \\<Rightarrow> ?t\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ti.\n        \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\n\ngoal (5 subgoals):\n 1. \\<And>x5.\n       a' = Call x5 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 5. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "proof(cases ti)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n     ti = Undecided\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                          (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Undecided"], ["proof (state)\nthis:\n  ti = Undecided\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n     ti = Undecided\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                          (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "with Cons.IH 2"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\n  ti = Undecided", "have IH: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\n  ti = Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs, Undecided\\<rangle> \\<Rightarrow> t", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n     ti = Undecided\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                          (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "from Undecided 1 Call Rule"], ["proof (chain)\npicking this:\n  ti = Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti\n  a' = Call chain\n  r = Rule m' a'", "have \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m' (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  ti = Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti\n  a' = Call chain\n  r = Rule m' a'\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n         (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n     ti = Undecided\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                          (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "with IH"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "have\" \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call chain) # process_ret rs, Undecided\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call chain) #\n       process_ret rs, Undecided\\<rangle> \\<Rightarrow> t", "using seq'_cons"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>[?r], ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r #\n                          ?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call chain) #\n       process_ret rs, Undecided\\<rangle> \\<Rightarrow> t", "by fast"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call chain) #\n     process_ret rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n     ti = Undecided\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                          (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call chain) #\n     process_ret rs, Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "using Rule Call"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call chain) #\n     process_ret rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Call chain\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by force"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case (Decision X)"], ["proof (state)\nthis:\n  ti = Decision X\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "with 1 Rule Call"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti\n  r = Rule m' a'\n  a' = Call chain\n  ti = Decision X", "have \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m' (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti\n  r = Rule m' a'\n  a' = Call chain\n  ti = Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n         (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "moreover"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "from 2 Decision"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\n  ti = Decision X", "have \"t = Decision X\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\n  ti = Decision X\n\ngoal (1 subgoal):\n 1. t = Decision X", "using decisionD"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\n  ti = Decision X\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?s = Decision ?X\\<rbrakk>\n  \\<Longrightarrow> ?t = Decision ?X\n\ngoal (1 subgoal):\n 1. t = Decision X", "by fast"], ["proof (state)\nthis:\n  t = Decision X\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "moreover"], ["proof (state)\nthis:\n  t = Decision X\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "from decision"], ["proof (chain)\npicking this:\n  ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, Decision\n              ?X\\<rangle> \\<Rightarrow> Decision ?X", "have \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Decision X\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\nusing this:\n  ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, Decision\n              ?X\\<rangle> \\<Rightarrow> Decision ?X\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs, Decision X\\<rangle> \\<Rightarrow> Decision X", "by fast"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "ultimately"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n  t = Decision X\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Decision X\\<rangle> \\<Rightarrow> Decision X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n  t = Decision X\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "using seq_cons"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n       (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n  t = Decision X\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>[?r], Undecided\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r #\n                          ?rs, Undecided\\<rangle> \\<Rightarrow> ?t'\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by (metis Call Rule process_ret.simps(7))"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (4 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Return"], ["proof (state)\nthis:\n  a' = Return\n\ngoal (4 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 4. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "with Cons Rule"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Return", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> t\n  r = Rule m' a'\n  a' = Return\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by simp (metis matches.simps(2) matches_add_match_simp no_free_return nomatchD seqE_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (3 subgoals):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Empty"], ["proof (state)\nthis:\n  a' = Empty\n\ngoal (3 subgoals):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Empty \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 3. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "apply (insert Empty Cons Rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a' = Empty;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> t;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n        rs, Undecided\\<rangle> \\<Rightarrow> t;\n     r = Rule m' a'\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                          (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti.\n       \\<lbrakk>a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            rs, Undecided\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "apply (rename_tac ti)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti.\n       \\<lbrakk>a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            rs, Undecided\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "apply(case_tac ti)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ti.\n       \\<lbrakk>a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            rs, Undecided\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>ti x2.\n       \\<lbrakk>a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            rs, Undecided\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "apply (simp add: seq_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti x2.\n       \\<lbrakk>a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            rs, Undecided\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[r], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t;\n        ti = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "apply (metis Rule_DecisionE emptyD state.distinct(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (2 subgoals):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Unknown"], ["proof (state)\nthis:\n  a' = Unknown\n\ngoal (2 subgoals):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n 2. a' = Unknown \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "using Unknown_actions_False"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r #\n                 ?rs, Undecided\\<rangle> \\<Rightarrow> ?t;\n   ?r = Rule ?m ?a; matches ?\\<gamma> ?m ?p;\n   ?a = Unknown \\<or> (\\<exists>chain. ?a = Goto chain)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by (metis Cons.IH Cons.prems Rule Unknown nomatchD process_ret.simps(10) seqE_cons seq_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "case Goto"], ["proof (state)\nthis:\n  a' = Goto x7_\n\ngoal (1 subgoal):\n 1. \\<And>x7.\n       a' = Goto x7 \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "thus ?thesis"], ["proof (prove)\nusing this:\n  a' = Goto x7_\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "using Unknown_actions_False"], ["proof (prove)\nusing this:\n  a' = Goto x7_\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r #\n                 ?rs, Undecided\\<rangle> \\<Rightarrow> ?t;\n   ?r = Rule ?m ?a; matches ?\\<gamma> ?m ?p;\n   ?a = Unknown \\<or> (\\<exists>chain. ?a = Goto chain)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (r # rs), Undecided\\<rangle> \\<Rightarrow> t", "by (metis Cons.IH Cons.prems Rule Goto nomatchD process_ret.simps(8) seqE_cons seq_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        [], Undecided\\<rangle> \\<Rightarrow> t", "qed simp"], ["", "lemma add_match_rot_add_missing_ret_unfoldings:\n  \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (add_missing_ret_unfoldings rs1 rs2), Undecided\\<rangle> \\<Rightarrow> Undecided =\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs1 (add_match m rs2), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_missing_ret_unfoldings rs1\n          rs2), Undecided\\<rangle> \\<Rightarrow> Undecided =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_missing_ret_unfoldings rs1\n        (add_match m rs2), Undecided\\<rangle> \\<Rightarrow> Undecided", "apply(simp add: add_missing_ret_unfoldings_alt add_match_add_missing_ret_unfoldings_rot add_match_add_match_MatchAnd_foldr[symmetric] iptables_bigstep_add_match_notnot_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_match_MatchAnd_foldr\n          (map (\\<lambda>r. MatchNot (get_match r))\n            (filter (\\<lambda>r. get_action r = Return) rs1))\n          rs2), Undecided\\<rangle> \\<Rightarrow> Undecided =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) rs1))\n        (add_match m rs2), Undecided\\<rangle> \\<Rightarrow> Undecided", "apply(cases \"map (\\<lambda>r. MatchNot (get_match r)) [r\\<leftarrow>rs1 . (get_action r) = Return]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. map (\\<lambda>r. MatchNot (get_match r))\n     (filter (\\<lambda>r. get_action r = Return) rs1) =\n    [] \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (add_match_MatchAnd_foldr\n          (map (\\<lambda>r. MatchNot (get_match r))\n            (filter (\\<lambda>r. get_action r = Return) rs1))\n          rs2), Undecided\\<rangle> \\<Rightarrow> Undecided =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n        (map (\\<lambda>r. MatchNot (get_match r))\n          (filter (\\<lambda>r. get_action r = Return) rs1))\n        (add_match m rs2), Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>a list.\n       map (\\<lambda>r. MatchNot (get_match r))\n        (filter (\\<lambda>r. get_action r = Return) rs1) =\n       a # list \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (add_match_MatchAnd_foldr\n             (map (\\<lambda>r. MatchNot (get_match r))\n               (filter (\\<lambda>r. get_action r = Return) rs1))\n             rs2), Undecided\\<rangle> \\<Rightarrow> Undecided =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match_MatchAnd_foldr\n           (map (\\<lambda>r. MatchNot (get_match r))\n             (filter (\\<lambda>r. get_action r = Return) rs1))\n           (add_match m rs2), Undecided\\<rangle> \\<Rightarrow> Undecided", "apply(simp_all add: add_match_distrib)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Completeness\\<close>"], ["", "theorem unfolding_complete: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs,s\\<rangle> \\<Rightarrow> t  \\<Longrightarrow>  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma> rs,s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n        rs, s\\<rangle> \\<Rightarrow> t", "proof (induction rule: iptables_bigstep_induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>m a.\n       \\<not> matches \\<gamma> m p \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [Rule m a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 6. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 7. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             rs, Undecided\\<rangle> \\<Rightarrow> t'\n 8. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 9. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "case (Nomatch m a)"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m p\n\ngoal (9 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>m a.\n       \\<not> matches \\<gamma> m p \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [Rule m a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 6. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 7. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             rs, Undecided\\<rangle> \\<Rightarrow> t'\n 8. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 9. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n        [Rule m a], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (cases a) (auto intro: iptables_bigstep.intros simp add: not_matches_add_match_simp skip)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      [Rule m a], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (8 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             rs, Undecided\\<rangle> \\<Rightarrow> t'\n 7. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 8. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             rs, Undecided\\<rangle> \\<Rightarrow> t'\n 7. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 8. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "case Seq"], ["proof (state)\nthis:\n  rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, t_\\<rangle> \\<Rightarrow> t'_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>2_, t_\\<rangle> \\<Rightarrow> t'_\n\ngoal (8 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>rs rs\\<^sub>1 rs\\<^sub>2 t t'.\n       \\<lbrakk>rs = rs\\<^sub>1 @ rs\\<^sub>2;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t';\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>2, t\\<rangle> \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             rs, Undecided\\<rangle> \\<Rightarrow> t'\n 7. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 8. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  rs_ = rs\\<^sub>1_ @ rs\\<^sub>2_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>2_, t_\\<rangle> \\<Rightarrow> t'_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>1_, Undecided\\<rangle> \\<Rightarrow> t_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>2_, t_\\<rangle> \\<Rightarrow> t'_\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n        rs_, Undecided\\<rangle> \\<Rightarrow> t'_", "by(simp add: process_call_split seq')"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs_, Undecided\\<rangle> \\<Rightarrow> t'_\n\ngoal (7 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 7. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 7. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "case (Call_return m a chain rs\\<^sub>1 m' rs\\<^sub>2)"], ["proof (state)\nthis:\n  matches \\<gamma> m p\n  a = Call chain\n  \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2)\n  matches \\<gamma> m' p\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (7 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 7. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "hence \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n  a = Call chain\n  \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2)\n  matches \\<gamma> m' p\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (7 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 7. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "hence \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (rule iptables_bigstep_process_ret_undecided)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (7 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 7. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "with Call_return"], ["proof (chain)\npicking this:\n  matches \\<gamma> m p\n  a = Call chain\n  \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2)\n  matches \\<gamma> m' p\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs\\<^sub>1 @ add_missing_ret_unfoldings rs\\<^sub>1 (add_match (MatchNot m') (process_ret rs\\<^sub>2)), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n  a = Call chain\n  \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2)\n  matches \\<gamma> m' p\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs\\<^sub>1 @\n       add_missing_ret_unfoldings rs\\<^sub>1\n        (add_match (MatchNot m')\n          (process_ret\n            rs\\<^sub>2)), Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis matches_add_match_MatchNot_simp skip add_match_rot_add_missing_ret_unfoldings seq')"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs\\<^sub>1 @\n     add_missing_ret_unfoldings rs\\<^sub>1\n      (add_match (MatchNot m')\n        (process_ret\n          rs\\<^sub>2)), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (7 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs\\<^sub>1 m' rs\\<^sub>2.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2);\n        matches \\<gamma> m' p;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 7. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "with Call_return"], ["proof (chain)\npicking this:\n  matches \\<gamma> m p\n  a = Call chain\n  \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2)\n  matches \\<gamma> m' p\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs\\<^sub>1 @\n     add_missing_ret_unfoldings rs\\<^sub>1\n      (add_match (MatchNot m')\n        (process_ret\n          rs\\<^sub>2)), Undecided\\<rangle> \\<Rightarrow> Undecided", "show ?case"], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n  a = Call chain\n  \\<Gamma> chain = Some (rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2)\n  matches \\<gamma> m' p\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs\\<^sub>1 @\n     add_missing_ret_unfoldings rs\\<^sub>1\n      (add_match (MatchNot m')\n        (process_ret\n          rs\\<^sub>2)), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n        [Rule m a], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (simp add: matches_add_match_simp process_ret_split_obvious)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      [Rule m a], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (6 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "case Call_result"], ["proof (state)\nthis:\n  matches \\<gamma> m_ p\n  a_ = Call chain_\n  \\<Gamma> chain_ = Some rs_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs_, Undecided\\<rangle> \\<Rightarrow> t_\n\ngoal (6 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X\n 6. \\<And>m a chain rs t.\n       \\<lbrakk>matches \\<gamma> m p; a = Call chain;\n        \\<Gamma> chain = Some rs;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, Undecided\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m a], Undecided\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  matches \\<gamma> m_ p\n  a_ = Call chain_\n  \\<Gamma> chain_ = Some rs_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs_, Undecided\\<rangle> \\<Rightarrow> t_\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs_, Undecided\\<rangle> \\<Rightarrow> t_\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n        [Rule m_ a_], Undecided\\<rangle> \\<Rightarrow> t_", "by (simp add: matches_add_match_simp iptables_bigstep_process_ret_undecided)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      [Rule m_ a_], Undecided\\<rangle> \\<Rightarrow> t_\n\ngoal (5 subgoals):\n 1. \\<And>t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           [], t\\<rangle> \\<Rightarrow> t\n 2. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalAllow\n 3. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Drop \\<or> a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Decision\n                               FinalDeny\n 4. \\<And>m a.\n       \\<lbrakk>matches \\<gamma> m p; a = Log \\<or> a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                             \\<Gamma>\n                             [Rule m\n                               a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 5. \\<And>rs X.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n           rs, Decision X\\<rangle> \\<Rightarrow> Decision X", "qed (auto intro: iptables_bigstep.intros)"], ["", "lemma process_ret_cases:\n  \"process_ret rs = rs \\<or> (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. rs = rs\\<^sub>1@[Rule m Return]@rs\\<^sub>2 \\<and> (process_ret rs) = rs\\<^sub>1@(process_ret ([Rule m Return]@rs\\<^sub>2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_ret rs = rs \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        process_ret rs =\n        rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))", "proof (induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. process_ret [] = [] \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        [] = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        process_ret [] =\n        rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))\n 2. \\<And>a rs.\n       process_ret rs = rs \\<or>\n       (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n           rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n           process_ret rs =\n           rs\\<^sub>1 @\n           process_ret ([Rule m Return] @ rs\\<^sub>2)) \\<Longrightarrow>\n       process_ret (a # rs) = a # rs \\<or>\n       (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n           a # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n           process_ret (a # rs) =\n           rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))", "case (Cons r rs)"], ["proof (state)\nthis:\n  process_ret rs = rs \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      process_ret rs =\n      rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))\n\ngoal (2 subgoals):\n 1. process_ret [] = [] \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        [] = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        process_ret [] =\n        rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))\n 2. \\<And>a rs.\n       process_ret rs = rs \\<or>\n       (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n           rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n           process_ret rs =\n           rs\\<^sub>1 @\n           process_ret ([Rule m Return] @ rs\\<^sub>2)) \\<Longrightarrow>\n       process_ret (a # rs) = a # rs \\<or>\n       (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n           a # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n           process_ret (a # rs) =\n           rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))", "thus ?case"], ["proof (prove)\nusing this:\n  process_ret rs = rs \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      process_ret rs =\n      rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))\n\ngoal (1 subgoal):\n 1. process_ret (r # rs) = r # rs \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        process_ret (r # rs) =\n        rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))", "apply(cases r, rename_tac m' a')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @\n            process_ret ([Rule m Return] @ rs\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))", "apply(case_tac a')"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Accept\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))\n 2. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Drop\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))\n 3. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Log\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))\n 4. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Reject\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))\n 5. \\<And>m' a' x5.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))\n 6. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Return\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))\n 7. \\<And>m' a' x7.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))\n 8. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Empty\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))\n 9. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    process_ret ([Rule m Return] @ rs\\<^sub>2));\n        r = Rule m' a';\n        process_ret rs = rs \\<or>\n        (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n            rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n            process_ret rs =\n            rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2));\n        a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_ret (r # rs) = r # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             r # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             process_ret (r # rs) =\n                             rs\\<^sub>1 @\n                             process_ret ([Rule m Return] @ rs\\<^sub>2))", "apply(simp_all)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Accept; a' = Accept\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Accept # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Accept # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 2. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Drop # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Drop # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 3. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Log # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Log # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 4. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Reject # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Reject # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 5. \\<And>m' a' x5.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' (Call x5) # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' (Call x5) # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 6. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> add_match (MatchNot m') (process_ret rs) =\n                         Rule m' Return # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Return # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             add_match (MatchNot m') (process_ret rs) =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 7. \\<And>m' a' x7.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' (Goto x7) # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' (Goto x7) # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 8. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Empty # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Empty # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 9. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Unknown # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Unknown # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))", "apply(erule disjE,simp,rule disjI2,elim exE,simp add: process_ret_split_obvious,\n                metis append_Cons process_ret_split_obvious process_ret.simps(2))+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> add_match (MatchNot m') (process_ret rs) =\n                         Rule m' Return # rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Return # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             add_match (MatchNot m') (process_ret rs) =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 2. \\<And>m' a' x7.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' (Goto x7) # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' (Goto x7) # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 3. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Empty # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Empty # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 4. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Unknown # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Unknown # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))", "apply(rule disjI2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                            Rule m' Return # rs =\n                            rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                            add_match (MatchNot m') (process_ret rs) =\n                            rs\\<^sub>1 @\n                            add_match (MatchNot m) (process_ret rs\\<^sub>2)\n 2. \\<And>m' a' x7.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' (Goto x7) # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' (Goto x7) # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 3. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Empty # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Empty # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 4. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Unknown # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Unknown # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs\\<^sub>2 m.\n                            Rule m' Return # rs =\n                            [] @ Rule m Return # rs\\<^sub>2 \\<and>\n                            add_match (MatchNot m') (process_ret rs) =\n                            [] @\n                            add_match (MatchNot m) (process_ret rs\\<^sub>2)\n 2. \\<And>m' a' x7.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' (Goto x7) # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' (Goto x7) # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 3. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Empty # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Empty # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 4. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Unknown # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Unknown # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))", "apply(rule_tac x=\"rs\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            Rule m' Return # rs =\n                            [] @ Rule m Return # rs \\<and>\n                            add_match (MatchNot m') (process_ret rs) =\n                            [] @ add_match (MatchNot m) (process_ret rs)\n 2. \\<And>m' a' x7.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' (Goto x7) # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' (Goto x7) # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 3. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Empty # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Empty # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 4. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Unknown # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Unknown # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))", "apply(rule_tac x=\"m'\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> Rule m' Return # rs =\n                         [] @ Rule m' Return # rs \\<and>\n                         add_match (MatchNot m') (process_ret rs) =\n                         [] @ add_match (MatchNot m') (process_ret rs)\n 2. \\<And>m' a' x7.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' (Goto x7) # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' (Goto x7) # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 3. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Empty # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Empty # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 4. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Unknown # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Unknown # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m' a' x7.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' (Goto x7) # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' (Goto x7) # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 2. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Empty # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Empty # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))\n 3. \\<And>m' a'.\n       \\<lbrakk>process_ret rs = rs \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                    process_ret rs =\n                    rs\\<^sub>1 @\n                    add_match (MatchNot m) (process_ret rs\\<^sub>2));\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> process_ret rs = rs \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             Rule m' Unknown # rs =\n                             rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n                             Rule m' Unknown # process_ret rs =\n                             rs\\<^sub>1 @\n                             add_match (MatchNot m)\n                              (process_ret rs\\<^sub>2))", "apply(erule disjE,simp,rule disjI2,elim exE,simp add: process_ret_split_obvious,\n           metis append_Cons process_ret_split_obvious process_ret.simps(2))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  process_ret (r # rs) = r # rs \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      process_ret (r # rs) =\n      rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))\n\ngoal (1 subgoal):\n 1. process_ret [] = [] \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        [] = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        process_ret [] =\n        rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2))", "qed simp"], ["", "lemma process_ret_splitcases:\n  obtains (id) \"process_ret rs = rs\"\n        | (split) rs\\<^sub>1 rs\\<^sub>2 m where \"rs = rs\\<^sub>1@[Rule m Return]@rs\\<^sub>2\" and \"process_ret rs = rs\\<^sub>1@(process_ret ([Rule m Return]@rs\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>process_ret rs = rs \\<Longrightarrow> thesis;\n     \\<And>rs\\<^sub>1 m rs\\<^sub>2.\n        \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2;\n         process_ret rs =\n         rs\\<^sub>1 @ process_ret ([Rule m Return] @ rs\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis process_ret_cases)"], ["", "lemma iptables_bigstep_process_ret_cases3:\n  assumes \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\"\n  obtains (noreturn) \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\"\n        | (return) rs\\<^sub>1 rs\\<^sub>2 m where \"rs = rs\\<^sub>1@[Rule m Return]@rs\\<^sub>2\" \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\" \"matches \\<gamma> m p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n             thesis;\n     \\<And>rs\\<^sub>1 m rs\\<^sub>2.\n        \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2;\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n         matches \\<gamma> m p\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n             thesis;\n     \\<And>rs\\<^sub>1 m rs\\<^sub>2.\n        \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2;\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n         matches \\<gamma> m p\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow> \n    (\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided) \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. rs = rs\\<^sub>1@[Rule m Return]@rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "proof (induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        [], Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        [] = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                    rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                    matches \\<gamma> m p);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (a # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             a # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                             matches \\<gamma> m p)", "case Nil"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      [], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        [], Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        [] = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                    rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                    matches \\<gamma> m p);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (a # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             a # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                             matches \\<gamma> m p)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      [], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        [] = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      [] = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                    rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                    matches \\<gamma> m p);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (a # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             a # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                             matches \\<gamma> m p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                    rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                    matches \\<gamma> m p);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (a # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             a # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                             matches \\<gamma> m p)", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                    rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                    matches \\<gamma> m p);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (a # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             a # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                             matches \\<gamma> m p)", "from Cons"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "obtain m a where r: \"r = Rule m a\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. (\\<And>m a. r = Rule m a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) simp"], ["proof (state)\nthis:\n  r = Rule m a\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                    rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                    rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                    matches \\<gamma> m p);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (a # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                         (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                             a # rs =\n                             rs\\<^sub>1 @\n                             [Rule m Return] @ rs\\<^sub>2 \\<and>\n                             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                             matches \\<gamma> m p)", "from r Cons"], ["proof (chain)\npicking this:\n  r = Rule m a\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "show ?case"], ["proof (prove)\nusing this:\n  r = Rule m a\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "proof(cases \"a \\<noteq> Return\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)\n 2. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "case True"], ["proof (state)\nthis:\n  a \\<noteq> Return\n\ngoal (2 subgoals):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)\n 2. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "with r Cons.prems"], ["proof (chain)\npicking this:\n  r = Rule m a\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n  a \\<noteq> Return", "have prems_r: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m a], Undecided\\<rangle> \\<Rightarrow> Undecided \" and prems_rs: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  r = Rule m a\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n  a \\<noteq> Return\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n         a], Undecided\\<rangle> \\<Rightarrow> Undecided &&&\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "apply(simp_all add: process_ret_split_fst_NeqReturn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n        process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                           a], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n        process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                          rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "apply(erule seqE_cons, frule iptables_bigstep_to_undecided, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n       a], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)\n 2. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "from prems_rs Cons.IH"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)", "have \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p)\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)\n 2. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "thus \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r # rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or> (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p)\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "proof(elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "assume \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "hence \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r # rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "using prems_r"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n       a], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis r seq'_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "assume \"(\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p)\""], ["proof (state)\nthis:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p", "obtain rs\\<^sub>1 rs\\<^sub>2 m' where \"rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2\" and \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\" and \"matches \\<gamma> m' p\""], ["proof (prove)\nusing this:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. (\\<And>rs\\<^sub>1 m' rs\\<^sub>2.\n        \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2;\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n         matches \\<gamma> m' p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "hence \"\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p\""], ["proof (prove)\nusing this:\n  rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p", "apply(rule_tac x=\"Rule m a # rs\\<^sub>1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     matches \\<gamma> m' p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs\\<^sub>2 ma.\n                         r # rs =\n                         (Rule m a # rs\\<^sub>1) @\n                         [Rule ma Return] @ rs\\<^sub>2 \\<and>\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                         matches \\<gamma> ma p", "apply(rule_tac x=rs\\<^sub>2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     matches \\<gamma> m' p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ma.\n                         r # rs =\n                         (Rule m a # rs\\<^sub>1) @\n                         [Rule ma Return] @ rs\\<^sub>2 \\<and>\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                         matches \\<gamma> ma p", "apply(rule_tac x=m' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     matches \\<gamma> m' p\\<rbrakk>\n    \\<Longrightarrow> r # rs =\n                      (Rule m a # rs\\<^sub>1) @\n                      [Rule m' Return] @ rs\\<^sub>2 \\<and>\n                      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                         rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                      matches \\<gamma> m' p", "apply(simp add: r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = rs\\<^sub>1 @ Rule m' Return # rs\\<^sub>2;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     matches \\<gamma> m' p\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                         rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided", "using prems_r seq'_cons"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n       a], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>[?r], ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r #\n                          ?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = rs\\<^sub>1 @ Rule m' Return # rs\\<^sub>2;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     matches \\<gamma> m' p\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                         rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided", "by fast"], ["proof (state)\nthis:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "case False"], ["proof (state)\nthis:\n  \\<not> a \\<noteq> Return\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "hence \"a = Return\""], ["proof (prove)\nusing this:\n  \\<not> a \\<noteq> Return\n\ngoal (1 subgoal):\n 1. a = Return", "by simp"], ["proof (state)\nthis:\n  a = Return\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "with Cons.prems r"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n  r = Rule m a\n  a = Return", "have prems: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m) (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n  r = Rule m a\n  a = Return\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n        (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n      (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r = Rule m a;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n     (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n         rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n         matches \\<gamma> m p);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n         (r # rs), Undecided\\<rangle> \\<Rightarrow> Undecided;\n     \\<not> a \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n                      (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n                          r # rs =\n                          rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n                          \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                          matches \\<gamma> m p)", "show \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r # rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or> (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "proof(cases \"matches \\<gamma> m p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "case True"], ["proof (state)\nthis:\n  matches \\<gamma> m p\n\ngoal (2 subgoals):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "(*the Cons premises are useless in this case*)"], ["proof (state)\nthis:\n  matches \\<gamma> m p\n\ngoal (2 subgoals):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "hence \"\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. r # rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p\""], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       r # rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<exists>rs\\<^sub>2 m.\n       r # rs = [] @ Rule m Return # rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p", "apply(rule_tac x=\"rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<exists>m.\n       r # rs = [] @ Rule m Return # rs \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p", "apply(rule_tac x=\"m\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    r # rs = [] @ Rule m Return # rs \\<and>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n    matches \\<gamma> m p", "apply(simp add: skip r \\<open>a = Return\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     r # rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (2 subgoals):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     r # rs = rs\\<^sub>1 @ Rule m Return # rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "case False"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "with nomatch seq_cons False r"], ["proof (chain)\npicking this:\n  \\<not> matches ?\\<gamma> ?m ?p \\<Longrightarrow>\n  ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>[Rule ?m\n          ?a], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>[?r], Undecided\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r #\n                          ?rs, Undecided\\<rangle> \\<Rightarrow> ?t'\n  \\<not> matches \\<gamma> m p\n  r = Rule m a\n  \\<not> matches \\<gamma> m p", "have r_nomatch: \"\\<And>rs. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r # rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<not> matches ?\\<gamma> ?m ?p \\<Longrightarrow>\n  ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>[Rule ?m\n          ?a], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<lbrakk>?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>[?r], Undecided\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?r #\n                          ?rs, Undecided\\<rangle> \\<Rightarrow> ?t'\n  \\<not> matches \\<gamma> m p\n  r = Rule m a\n  \\<not> matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n          rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by fast"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     ?rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "note r_nomatch'=r_nomatch[simplified r \\<open>a = Return\\<close>] \\<comment> \\<open>r unfolded\\<close>"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m Return #\n     ?rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "from False not_matches_add_matchNot_simp prems"], ["proof (chain)\npicking this:\n  \\<not> matches \\<gamma> m p\n  \\<not> matches ?\\<gamma> ?m ?p \\<Longrightarrow>\n  ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>add_match (MatchNot ?m)\n         ?rs, ?s\\<rangle> \\<Rightarrow> ?t =\n  ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n      (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m p\n  \\<not> matches ?\\<gamma> ?m ?p \\<Longrightarrow>\n  ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>add_match (MatchNot ?m)\n         ?rs, ?s\\<rangle> \\<Rightarrow> ?t =\n  ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n      (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by fast"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "with Cons.IH"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "have IH: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or> (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p)\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "."], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "proof(elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "assume \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "hence \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r # rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "using r_nomatch"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     ?rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)\n 2. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "assume \"\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p\""], ["proof (state)\nthis:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p", "obtain rs\\<^sub>1 rs\\<^sub>2 m' where \"rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2\" and \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\" and \"matches \\<gamma> m' p\""], ["proof (prove)\nusing this:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. (\\<And>rs\\<^sub>1 m' rs\\<^sub>2.\n        \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2;\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n         matches \\<gamma> m' p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "hence \"\\<exists>rs\\<^sub>1 rs\\<^sub>2 m. r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and> matches \\<gamma> m p\""], ["proof (prove)\nusing this:\n  rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p", "apply(rule_tac x=\"Rule m Return # rs\\<^sub>1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     matches \\<gamma> m' p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs\\<^sub>2 ma.\n                         r # rs =\n                         (Rule m Return # rs\\<^sub>1) @\n                         [Rule ma Return] @ rs\\<^sub>2 \\<and>\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                         matches \\<gamma> ma p", "apply(rule_tac x=\"rs\\<^sub>2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     matches \\<gamma> m' p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ma.\n                         r # rs =\n                         (Rule m Return # rs\\<^sub>1) @\n                         [Rule ma Return] @ rs\\<^sub>2 \\<and>\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                         matches \\<gamma> ma p", "apply(rule_tac x=\"m'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m' Return] @ rs\\<^sub>2;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n     matches \\<gamma> m' p\\<rbrakk>\n    \\<Longrightarrow> r # rs =\n                      (Rule m Return # rs\\<^sub>1) @\n                      [Rule m' Return] @ rs\\<^sub>2 \\<and>\n                      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                          Return #\n                         rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n                      matches \\<gamma> m' p", "by(simp add:  \\<open>a = Return\\<close> False r r_nomatch')"], ["proof (state)\nthis:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n       rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n       matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n     r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n     matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n    (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n        r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n        matches \\<gamma> m p)", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      r # rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n             thesis;\n     \\<And>rs\\<^sub>1 m rs\\<^sub>2.\n        \\<lbrakk>rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2;\n         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n         matches \\<gamma> m p\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms noreturn return"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  thesis\n  \\<lbrakk>rs = ?rs\\<^sub>1 @ [Rule ?m Return] @ ?rs\\<^sub>2;\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n   matches \\<gamma> ?m p\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  thesis\n  \\<lbrakk>rs = ?rs\\<^sub>1 @ [Rule ?m Return] @ ?rs\\<^sub>2;\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n   matches \\<gamma> ?m p\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<or>\n  (\\<exists>rs\\<^sub>1 rs\\<^sub>2 m.\n      rs = rs\\<^sub>1 @ [Rule m Return] @ rs\\<^sub>2 \\<and>\n      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided \\<and>\n      matches \\<gamma> m p)\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iptables_bigstep_process_ret_DecisionD: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n                                     X", "proof (induction rs arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           [], s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], s\\<rangle> \\<Rightarrow> Decision\n  X\n 2. \\<And>a rs s.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (a # rs), s\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, ?s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ?s\\<rangle> \\<Rightarrow> Decision\n                                    X\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), s\\<rangle> \\<Rightarrow> Decision X\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           [], s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], s\\<rangle> \\<Rightarrow> Decision\n  X\n 2. \\<And>a rs s.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (a # rs), s\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      rs, ?s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ?s\\<rangle> \\<Rightarrow> Decision\n                                    X\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n      (r # rs), s\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(cases r, rename_tac m a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (r # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m a;\n        \\<And>s.\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n      X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (r # rs), s\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        \\<And>s.\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n      X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m a\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(case_tac \"a \\<noteq> Return\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        \\<And>s.\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n      X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m a; a \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        \\<And>s.\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n      X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m a; \\<not> a \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(simp add: process_ret_split_fst_NeqReturn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                   process_ret rs, s\\<rangle> \\<Rightarrow> Decision X;\n        \\<And>s.\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n      X;\n        r = Rule m a; a \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        \\<And>s.\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n      X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m a; \\<not> a \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a ti.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        r = Rule m a; a \\<noteq> Return;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n             a], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            rs, ti\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        \\<And>s.\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n      X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m a; \\<not> a \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(simp add: seq'_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        \\<And>s.\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               rs, s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n           \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n      X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (Rule m a # rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m a; \\<not> a \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m a #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n            (process_ret rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "(*case a = AReturn*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n            (process_ret rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(case_tac \"matches \\<gamma> m p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n            (process_ret rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return; matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n            (process_ret rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return; \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(simp add: matches_add_match_MatchNot_simp skip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], s\\<rangle> \\<Rightarrow> Decision\n   X;\n        r = Rule m Return; a = Return; matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n            (process_ret rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return; \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "(*the prems becomes useless in this case*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], s\\<rangle> \\<Rightarrow> Decision\n   X;\n        r = Rule m Return; a = Return; matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n            (process_ret rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return; \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply (metis decision skipD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n            (process_ret rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return; \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "(*case \\<not> matches*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m)\n            (process_ret rs), s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return; \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "apply(simp add: not_matches_add_matchNot_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            rs, s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return; \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "(*get IH*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>s.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       rs, s\\<rangle> \\<Rightarrow> Decision\n               X \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> Decision\n              X;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            rs, s\\<rangle> \\<Rightarrow> Decision X;\n        r = Rule m Return; a = Return; \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             Return #\n                            rs, s\\<rangle> \\<Rightarrow> Decision X", "by (metis decision state.exhaust nomatch seq'_cons)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, s\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           [], s\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], s\\<rangle> \\<Rightarrow> Decision\n  X", "qed simp"], ["", "subsection\\<open>@{const process_ret} correctness\\<close>"], ["", "lemma process_ret_add_match_dist1: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (add_match m rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(induction rs arbitrary: s t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (add_match m []), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (process_ret []), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>a rs s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (a # rs)), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (a # rs)), s\\<rangle> \\<Rightarrow> t", "apply(simp add: add_match_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (a # rs)), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (a # rs)), s\\<rangle> \\<Rightarrow> t", "apply(rename_tac r rs s t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (r # rs)), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (r # rs)), s\\<rangle> \\<Rightarrow> t", "apply(case_tac r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t x1 x2.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (r # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule x1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (r # rs)), s\\<rangle> \\<Rightarrow> t", "apply(rename_tac m' a')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (r # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (r # rs)), s\\<rangle> \\<Rightarrow> t", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t", "apply(case_tac a')"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t\n 9. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (process_ret\n                                 (Rule m' a' #\n                                  rs)), s\\<rangle> \\<Rightarrow> t", "apply(simp_all add: add_match_split_fst)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Accept #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Accept; a' = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Accept #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Drop #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 9. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Accept; a' = Accept;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Accept], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Accept #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Drop #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 9. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (9 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Accept; a' = Accept;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Accept], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Accept #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Drop #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 9. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Drop #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Drop], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (8 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Drop], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Log], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (7 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Log], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Reject], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (6 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Reject], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>r rs s t m' a' x5 ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             (Call x5)], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (5 subgoals):\n 1. \\<And>r rs s t m' a' x5 ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             (Call x5)], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r rs s t m' a' x7 ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             (Goto x7)], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (4 subgoals):\n 1. \\<And>r rs s t m' a' x7 ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             (Goto x7)], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Empty], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Empty], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            (add_match m rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "apply(case_tac \"matches \\<gamma> (MatchNot (MatchAnd m m')) p\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        matches \\<gamma> (MatchNot (MatchAnd m m')) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        \\<not> matches \\<gamma> (MatchNot (MatchAnd m m')) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        matches \\<gamma> m p \\<longrightarrow>\n        \\<not> matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        \\<not> matches \\<gamma> (MatchNot (MatchAnd m m')) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "apply (meson seq'_cons seqE_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        \\<not> matches \\<gamma> (MatchNot (MatchAnd m m')) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            add_match m\n                             (process_ret rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "apply (meson seq'_cons seqE_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n            (MatchNot (MatchAnd m m'))\n            (process_ret (add_match m rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             m (add_match (MatchNot m')\n                                 (process_ret\n                                   rs)), s\\<rangle> \\<Rightarrow> t", "by (metis decision decisionD matches.simps(1) matches_add_match_MatchNot_simp matches_add_match_simp\n  not_matches_add_matchNot_simp not_matches_add_match_simp state.exhaust)"], ["", "lemma process_ret_add_match_dist2: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (process_ret rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(induction rs arbitrary: s t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n           (process_ret []), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n           (add_match m []), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>a rs s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (a # rs)), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (a # rs)), s\\<rangle> \\<Rightarrow> t", "apply(simp add: add_match_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (a # rs)), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (a # rs)), s\\<rangle> \\<Rightarrow> t", "apply(rename_tac r rs s t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (r # rs)), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (r # rs)), s\\<rangle> \\<Rightarrow> t", "apply(case_tac r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t x1 x2.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (r # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule x1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (r # rs)), s\\<rangle> \\<Rightarrow> t", "apply(rename_tac m' a')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (r # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (r # rs)), s\\<rangle> \\<Rightarrow> t", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t", "apply(case_tac a')"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t\n 9. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (Rule m' a' # rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' a'; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                             (add_match m\n                               (Rule m' a' #\n                                rs)), s\\<rangle> \\<Rightarrow> t", "apply(simp_all add: add_match_split_fst)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Accept #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Accept; a' = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Accept #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Drop #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 9. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Accept; a' = Accept;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Accept], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Accept #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Drop #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 9. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (9 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Accept; a' = Accept;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Accept], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Accept #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Drop #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 9. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Drop #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Drop], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (8 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Drop; a' = Drop;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Drop], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Drop #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 8. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m') Log #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Log], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (7 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Log; a' = Log;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Log], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Log #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 7. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Reject #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Reject], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (6 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Reject; a' = Reject;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Reject], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Reject #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 6. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>r rs s t m' a' x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Call x5) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>r rs s t m' a' x5 ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             (Call x5)], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (5 subgoals):\n 1. \\<And>r rs s t m' a' x5 ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Call x5); a' = Call x5;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             (Call x5)], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Call x5) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 5. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r rs s t m' a' x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            (Goto x7) #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r rs s t m' a' x7 ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             (Goto x7)], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (4 subgoals):\n 1. \\<And>r rs s t m' a' x7 ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' (Goto x7); a' = Goto x7;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             (Goto x7)], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') (Goto x7) #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 4. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Empty #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "apply(erule seqE_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Empty], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "using seq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs = ?rs\\<^sub>1 @ ?rs\\<^sub>2;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>1, ?s\\<rangle> \\<Rightarrow> ?t;\n   ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs\\<^sub>2, ?t\\<rangle> \\<Rightarrow> ?t'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>,?\\<gamma>,?p\\<turnstile> \\<langle>?rs, ?s\\<rangle> \\<Rightarrow> ?t'\n\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a' ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Empty; a' = Empty;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule (MatchAnd m m')\n             Empty], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret rs), ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Empty #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "apply(fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "apply(case_tac \"matches \\<gamma> (MatchNot (MatchAnd m m')) p\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        matches \\<gamma> (MatchNot (MatchAnd m m')) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        \\<not> matches \\<gamma> (MatchNot (MatchAnd m m')) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        matches \\<gamma> m p \\<longrightarrow>\n        \\<not> matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        \\<not> matches \\<gamma> (MatchNot (MatchAnd m m')) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 3. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "apply (meson seq'_cons seqE_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule (MatchAnd m m')\n            Unknown #\n           add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Unknown; a' = Unknown;\n        \\<not> matches \\<gamma> (MatchNot (MatchAnd m m')) p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule\n                             (MatchAnd m m') Unknown #\n                            process_ret\n                             (add_match m rs), s\\<rangle> \\<Rightarrow> t\n 2. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "apply (meson seq'_cons seqE_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r rs s t m' a'.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n                       (process_ret\n                         rs), s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                       (add_match m rs), s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (add_match (MatchNot m')\n              (process_ret rs)), s\\<rangle> \\<Rightarrow> t;\n        r = Rule m' Return; a' = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match\n                             (MatchNot (MatchAnd m m'))\n                             (process_ret\n                               (add_match m rs)), s\\<rangle> \\<Rightarrow> t", "by (metis decision decisionD matches.simps(1) matches_add_match_MatchNot_simp matches_add_match_simp\n  not_matches_add_matchNot_simp not_matches_add_match_simp state.exhaust)"], ["", "(*such fuckup*)"], ["", "lemma process_ret_add_match_dist: \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m (process_ret rs), s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        (add_match m rs), s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n        (process_ret rs), s\\<rangle> \\<Rightarrow> t", "by (metis process_ret_add_match_dist1 process_ret_add_match_dist2)"], ["", "lemma process_ret_Undecided_sound:\n  assumes \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Undecided\"\n  shows \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "proof (cases \"matches \\<gamma> m p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case False"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m p\n\ngoal (2 subgoals):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis nomatch)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case True"], ["proof (state)\nthis:\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "note matches = this"], ["proof (state)\nthis:\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "proof (induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m\n     []), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case Nil"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m []), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m\n     []), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "from call_result[OF matches, where \\<Gamma>=\"\\<Gamma>(chain \\<mapsto> [])\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(\\<Gamma>(chain \\<mapsto> [])) ?chain = Some ?rs;\n   \\<Gamma>(chain \\<mapsto>\n   []),\\<gamma>,p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> ?t\\<rbrakk>\n  \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                    (Call ?chain)], Undecided\\<rangle> \\<Rightarrow> ?t", "have \"(\\<Gamma>(chain \\<mapsto> [])) chain = Some [] \\<Longrightarrow> \\<Gamma>(chain \\<mapsto> []),\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow> \\<Gamma>(chain \\<mapsto> []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Gamma>(chain \\<mapsto> [])) ?chain = Some ?rs;\n   \\<Gamma>(chain \\<mapsto>\n   []),\\<gamma>,p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow> ?t\\<rbrakk>\n  \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                    (Call ?chain)], Undecided\\<rangle> \\<Rightarrow> ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Gamma>(chain \\<mapsto> [])) chain = Some [];\n     \\<Gamma>(chain \\<mapsto>\n     []),\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                      []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                      (Call\n                        chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Gamma>(chain \\<mapsto> [])) chain = Some [];\n   \\<Gamma>(chain \\<mapsto>\n   []),\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n  \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                    (Call\n                      chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m\n     []), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Gamma>(chain \\<mapsto> [])) chain = Some [];\n   \\<Gamma>(chain \\<mapsto>\n   []),\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n  \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                    (Call\n                      chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (fastforce intro: skip)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>(chain \\<mapsto>\n  r #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (r # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "obtain m' a' where r: \"r = Rule m' a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m' a'. r = Rule m' a' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) blast"], ["proof (state)\nthis:\n  r = Rule m' a'\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with Cons.prems"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  r #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (r # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\n  r = Rule m' a'", "have prems: \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  r #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (r # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\n  r = Rule m' a'\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m\n     (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided", "by fast"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "hence prems_simplified: \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "using matches"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis matches_add_match_simp process_ret_add_match_dist)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "proof (cases \"a' = Return\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case True"], ["proof (state)\nthis:\n  a' = Return\n\ngoal (2 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "note a' = this"], ["proof (state)\nthis:\n  a' = Return\n\ngoal (2 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"\\<Gamma>(chain \\<mapsto> Rule m' Return # rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "proof (cases \"matches \\<gamma> m' p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case True"], ["proof (state)\nthis:\n  matches \\<gamma> m' p\n\ngoal (2 subgoals):\n 1. matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with matches"], ["proof (chain)\npicking this:\n  matches \\<gamma> m p\n  matches \\<gamma> m' p", "show ?thesis"], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (fastforce intro: call_return skip)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case False"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "note matches' = this"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "hence \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis prems_simplified update_Gamma_nomatch)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with a'"], ["proof (chain)\npicking this:\n  a' = Return\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m') (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  a' = Return\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m')\n   (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m')\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with matches matches'"], ["proof (chain)\npicking this:\n  matches \\<gamma> m p\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m')\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match (MatchNot m')\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m\n   (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "by (simp add: matches_add_match_simp not_matches_add_matchNot_simp)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with matches' Cons.IH"], ["proof (chain)\npicking this:\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (fastforce simp: update_Gamma_nomatch process_ret_add_match_dist)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with a'"], ["proof (chain)\npicking this:\n  a' = Return\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "show ?thesis"], ["proof (prove)\nusing this:\n  a' = Return\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case False"], ["proof (state)\nthis:\n  a' \\<noteq> Return\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "note a' = this"], ["proof (state)\nthis:\n  a' \\<noteq> Return\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with prems_simplified"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n  a' \\<noteq> Return", "have \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' a' # process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n  a' \\<noteq> Return\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' a' #\n  process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (simp add: process_ret_split_fst_NeqReturn)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' a' #\nprocess_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "hence step: \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m' a'], Undecided\\<rangle> \\<Rightarrow> Undecided\"\n            and   IH_pre: \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' a' #\nprocess_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n    a'], Undecided\\<rangle> \\<Rightarrow> Undecided &&&\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis seqE_cons iptables_bigstep_to_undecided)+"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "from step"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "proof (cases rule: Rule_UndecidedE)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. a' = Log \\<or> a' = Empty \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n 3. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                        rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "case log"], ["proof (state)\nthis:\n  a' = Log \\<or> a' = Empty\n\ngoal (3 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. a' = Log \\<or> a' = Empty \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n 3. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                        rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "thus ?thesis"], ["proof (prove)\nusing this:\n  a' = Log \\<or> a' = Empty\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "using IH_pre"], ["proof (prove)\nusing this:\n  a' = Log \\<or> a' = Empty\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis empty iptables_bigstep.log update_Gamma_nochange1 update_Gamma_nomatch)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                        rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                        rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "case call"], ["proof (state)\nthis:\n  a' = Call c_\n  matches \\<gamma> m' p\n\ngoal (2 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n                        rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "thus ?thesis"], ["proof (prove)\nusing this:\n  a' = Call c_\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "using IH_pre"], ["proof (prove)\nusing this:\n  a' = Call c_\n  matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis update_Gamma_remove_call_undecided)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "case nomatch"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "using IH_pre"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis update_Gamma_nomatch)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "hence \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis matches matches_add_match_simp process_ret_add_match_dist)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with Cons.IH"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Undecided", "have IH: \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by fast"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "from step"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> Undecided", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "proof (cases rule: Rule_UndecidedE)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. a' = Log \\<or> a' = Empty \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 3. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case log"], ["proof (state)\nthis:\n  a' = Log \\<or> a' = Empty\n\ngoal (3 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. a' = Log \\<or> a' = Empty \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 3. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "thus ?thesis"], ["proof (prove)\nusing this:\n  a' = Log \\<or> a' = Empty\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "using IH"], ["proof (prove)\nusing this:\n  a' = Log \\<or> a' = Empty\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (simp add: update_Gamma_log_empty)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case nomatch"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m' p\n\ngoal (2 subgoals):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "using IH"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis update_Gamma_nomatch)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case (call c)"], ["proof (state)\nthis:\n  a' = Call c\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "let ?\\<Gamma>' = \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>a' = Call c; matches \\<gamma> m' p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "from IH_pre"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "proof (cases rule: iptables_bigstep_process_ret_cases3)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case noreturn"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with call"], ["proof (chain)\npicking this:\n  a' = Call c\n  matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"?\\<Gamma>',\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call c) # rs, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  a' = Call c\n  matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call c) #\n  rs, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis step seq_cons)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call c) #\nrs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "from call"], ["proof (chain)\npicking this:\n  a' = Call c\n  matches \\<gamma> m' p", "have \"?\\<Gamma>' chain = Some (Rule m' (Call c) # rs)\""], ["proof (prove)\nusing this:\n  a' = Call c\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. (\\<Gamma>(chain \\<mapsto> Rule m' a' # rs)) chain =\n    Some (Rule m' (Call c) # rs)", "by simp"], ["proof (state)\nthis:\n  (\\<Gamma>(chain \\<mapsto> Rule m' a' # rs)) chain =\n  Some (Rule m' (Call c) # rs)\n\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n 2. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "from matches"], ["proof (chain)\npicking this:\n  matches \\<gamma> m p", "show ?thesis"], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (rule call_result) fact+"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "case (return rs\\<^sub>1 rs\\<^sub>2 new_m')"], ["proof (state)\nthis:\n  rs = rs\\<^sub>1 @ [Rule new_m' Return] @ rs\\<^sub>2\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> new_m' p\n\ngoal (1 subgoal):\n 1. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "with call"], ["proof (chain)\npicking this:\n  a' = Call c\n  matches \\<gamma> m' p\n  rs = rs\\<^sub>1 @ [Rule new_m' Return] @ rs\\<^sub>2\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> new_m' p", "have \"?\\<Gamma>' chain = Some ((Rule m' (Call c) # rs\\<^sub>1) @ [Rule new_m' Return] @ rs\\<^sub>2)\""], ["proof (prove)\nusing this:\n  a' = Call c\n  matches \\<gamma> m' p\n  rs = rs\\<^sub>1 @ [Rule new_m' Return] @ rs\\<^sub>2\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> new_m' p\n\ngoal (1 subgoal):\n 1. (\\<Gamma>(chain \\<mapsto> Rule m' a' # rs)) chain =\n    Some\n     ((Rule m' (Call c) # rs\\<^sub>1) @ [Rule new_m' Return] @ rs\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  (\\<Gamma>(chain \\<mapsto> Rule m' a' # rs)) chain =\n  Some ((Rule m' (Call c) # rs\\<^sub>1) @ [Rule new_m' Return] @ rs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "from call return step"], ["proof (chain)\npicking this:\n  a' = Call c\n  matches \\<gamma> m' p\n  rs = rs\\<^sub>1 @ [Rule new_m' Return] @ rs\\<^sub>2\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> new_m' p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> Undecided", "have \"?\\<Gamma>',\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call c) # rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\""], ["proof (prove)\nusing this:\n  a' = Call c\n  matches \\<gamma> m' p\n  rs = rs\\<^sub>1 @ [Rule new_m' Return] @ rs\\<^sub>2\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> new_m' p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call c) #\n  rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided", "using IH_pre"], ["proof (prove)\nusing this:\n  a' = Call c\n  matches \\<gamma> m' p\n  rs = rs\\<^sub>1 @ [Rule new_m' Return] @ rs\\<^sub>2\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n  matches \\<gamma> new_m' p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> Undecided\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call c) #\n  rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided", "by (auto intro: seq_cons)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>Rule m' (Call c) #\nrs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>rs\\<^sub>1 rs\\<^sub>2 ma.\n       \\<lbrakk>rs = rs\\<^sub>1 @ [Rule ma Return] @ rs\\<^sub>2;\n        \\<Gamma>(chain \\<mapsto>\n        Rule m' a' #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>rs\\<^sub>1, Undecided\\<rangle> \\<Rightarrow> Undecided;\n        matches \\<gamma> ma p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         Rule m' a' #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "from matches"], ["proof (chain)\npicking this:\n  matches \\<gamma> m p", "show ?thesis"], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (rule call_return) fact+"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Undecided \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    r #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided", "by (metis r)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  r #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Undecided\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma process_ret_Decision_sound:\n  assumes \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Decision X\"\n  shows \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "proof (cases \"matches \\<gamma> m p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "case False"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m p\n\ngoal (2 subgoals):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. \\<not> matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "by (metis assms state.distinct(1) not_matches_add_match_simp process_ret_add_match_dist1 skipD)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "case True"], ["proof (state)\nthis:\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "note matches = this"], ["proof (state)\nthis:\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. matches \\<gamma> m p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "proof (induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m\n     []), Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "case Nil"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m []), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m\n     []), Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "hence False"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m []), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. False", "by (metis add_match_split append_self_conv state.distinct(1) process_ret.simps(1) skipD)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m\n     []), Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  []),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   rs), Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n  \\<Gamma>(chain \\<mapsto>\n  r #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (r # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "obtain m' a' where r: \"r = Rule m' a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m' a'. r = Rule m' a' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) blast"], ["proof (state)\nthis:\n  r = Rule m' a'\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "with Cons.prems"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  r #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (r # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\n  r = Rule m' a'", "have prems: \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  r #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m (r # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\n  r = Rule m' a'\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (add_match m\n     (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X", "by fast"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "hence prems_simplified: \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X", "using matches"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   (Rule m' a' # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\n  matches \\<gamma> m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X", "by (metis matches_add_match_simp process_ret_add_match_dist)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "have \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "proof (cases \"a' = Return\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "case True"], ["proof (state)\nthis:\n  a' = Return\n\ngoal (2 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "note a' = this"], ["proof (state)\nthis:\n  a' = Return\n\ngoal (2 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "have \"\\<Gamma>(chain \\<mapsto> Rule m' Return # rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "proof (cases \"matches \\<gamma> m' p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "case True"], ["proof (state)\nthis:\n  matches \\<gamma> m' p\n\ngoal (2 subgoals):\n 1. matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "with matches prems_simplified a'"], ["proof (chain)\npicking this:\n  matches \\<gamma> m p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n  a' = Return\n  matches \\<gamma> m' p", "show ?thesis"], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n  a' = Return\n  matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "by (auto simp: not_matches_add_match_simp dest: skipD)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "case False"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "note matches' = this"], ["proof (state)\nthis:\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "with prems_simplified"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n  \\<not> matches \\<gamma> m' p", "have \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n  \\<not> matches \\<gamma> m' p\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n   (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X", "by (metis update_Gamma_nomatch)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "with a' matches matches'"], ["proof (chain)\npicking this:\n  a' = Return\n  matches \\<gamma> m p\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X", "have \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\nusing this:\n  a' = Return\n  matches \\<gamma> m p\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m\n   (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Decision X", "by (simp add: matches_add_match_simp not_matches_add_matchNot_simp)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<not> matches \\<gamma> m' p \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "with matches matches' Cons.IH"], ["proof (chain)\npicking this:\n  matches \\<gamma> m p\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   rs), Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Decision X", "show ?thesis"], ["proof (prove)\nusing this:\n  matches \\<gamma> m p\n  \\<not> matches \\<gamma> m' p\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m\n   rs), Undecided\\<rangle> \\<Rightarrow> Decision X \\<Longrightarrow>\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>add_match m\n (process_ret rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' Return #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "by (fastforce simp: update_Gamma_nomatch process_ret_add_match_dist matches_add_match_simp not_matches_add_matchNot_simp)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (2 subgoals):\n 1. a' = Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n 2. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "with a'"], ["proof (chain)\npicking this:\n  a' = Return\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "show ?thesis"], ["proof (prove)\nusing this:\n  a' = Return\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' Return #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "case False"], ["proof (state)\nthis:\n  a' \\<noteq> Return\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "with prems_simplified"], ["proof (chain)\npicking this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n  a' \\<noteq> Return", "obtain ti\n              where step: \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m' a'], Undecided\\<rangle> \\<Rightarrow> ti\"\n                and IH_pre: \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret rs, ti\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (Rule m' a' # rs), Undecided\\<rangle> \\<Rightarrow> Decision X\n  a' \\<noteq> Return\n\ngoal (1 subgoal):\n 1. (\\<And>ti.\n        \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                 Rule m' a' #\n                 rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n                 a'], Undecided\\<rangle> \\<Rightarrow> ti;\n         \\<Gamma>(chain \\<mapsto>\n         Rule m' a' #\n         rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n        rs, ti\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: process_ret_split_fst_NeqReturn elim: seqE_cons)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> ti\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, ti\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "hence \"\\<Gamma>(chain \\<mapsto> Rule m' a' # rs),\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> Decision X\""], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> ti\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n rs, ti\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> Decision\n                                 X", "by (metis iptables_bigstep_process_ret_DecisionD)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> Decision\n                               X\n\ngoal (1 subgoal):\n 1. a' \\<noteq> Return \\<Longrightarrow>\n    \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> Decision\n                               X\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "using matches step"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> Decision\n                               X\n  matches \\<gamma> m p\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m'\n  a'], Undecided\\<rangle> \\<Rightarrow> ti\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    Rule m' a' #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "by (force intro: call_result seq'_cons)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n               (add_match m\n                 rs), Undecided\\<rangle> \\<Rightarrow> Decision\n                  X \\<Longrightarrow>\n                \\<Gamma>(chain \\<mapsto>\n                rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X;\n        \\<Gamma>(chain \\<mapsto>\n        a #\n        rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n       (add_match m\n         (a # rs)), Undecided\\<rangle> \\<Rightarrow> Decision X\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>(chain \\<mapsto>\n                         a #\n                         rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                         (Call\n                           chain)], Undecided\\<rangle> \\<Rightarrow> Decision\n                                X", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  Rule m' a' #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    r #\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X", "by (metis r)"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  r #\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n  (Call chain)], Undecided\\<rangle> \\<Rightarrow> Decision X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma process_ret_result_empty: \"[] = process_ret rs \\<Longrightarrow> \\<forall>r \\<in> set rs. get_action r = Return\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = process_ret rs \\<Longrightarrow>\n    \\<forall>r\\<in>set rs. get_action r = Return", "proof (induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] = process_ret [] \\<Longrightarrow>\n    \\<forall>r\\<in>set []. get_action r = Return\n 2. \\<And>a rs.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (a # rs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r\\<in>set (a # rs). get_action r = Return", "case (Cons r rs)"], ["proof (state)\nthis:\n  [] = process_ret rs \\<Longrightarrow>\n  \\<forall>r\\<in>set rs. get_action r = Return\n  [] = process_ret (r # rs)\n\ngoal (2 subgoals):\n 1. [] = process_ret [] \\<Longrightarrow>\n    \\<forall>r\\<in>set []. get_action r = Return\n 2. \\<And>a rs.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (a # rs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r\\<in>set (a # rs). get_action r = Return", "thus ?case"], ["proof (prove)\nusing this:\n  [] = process_ret rs \\<Longrightarrow>\n  \\<forall>r\\<in>set rs. get_action r = Return\n  [] = process_ret (r # rs)\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set (r # rs). get_action r = Return", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n             \\<forall>r\\<in>set rs. get_action r = Return;\n     [] = process_ret (r # rs)\\<rbrakk>\n    \\<Longrightarrow> get_action r = Return \\<and>\n                      (\\<forall>r\\<in>set rs. get_action r = Return)", "apply(case_tac r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule x1 x2\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)", "apply(rename_tac m a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)", "apply(case_tac a)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Accept\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)\n 2. \\<And>m a.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Drop\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)\n 3. \\<And>m a.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Log\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)\n 4. \\<And>m a.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Reject\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)\n 5. \\<And>m a x5.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Call x5\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)\n 6. \\<And>m a.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Return\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)\n 7. \\<And>m a x7.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Goto x7\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)\n 8. \\<And>m a.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Empty\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)\n 9. \\<And>m a.\n       \\<lbrakk>[] = process_ret rs \\<Longrightarrow>\n                \\<forall>r\\<in>set rs. get_action r = Return;\n        [] = process_ret (r # rs); r = Rule m a; a = Unknown\\<rbrakk>\n       \\<Longrightarrow> get_action r = Return \\<and>\n                         (\\<forall>r\\<in>set rs. get_action r = Return)", "apply(simp_all add: add_match_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set (r # rs). get_action r = Return\n\ngoal (1 subgoal):\n 1. [] = process_ret [] \\<Longrightarrow>\n    \\<forall>r\\<in>set []. get_action r = Return", "qed simp"], ["", "lemma process_ret_sound':\n  assumes \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret (add_match m rs), Undecided\\<rangle> \\<Rightarrow> t\"\n  shows \"\\<Gamma>(chain \\<mapsto> rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m (Call chain)], Undecided\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> t", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma>(chain \\<mapsto>\n  rs),\\<gamma>,p\\<turnstile> \\<langle>process_ret\n (add_match m rs), Undecided\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>(chain \\<mapsto>\n    rs),\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n    (Call chain)], Undecided\\<rangle> \\<Rightarrow> t", "by (metis state.exhaust process_ret_Undecided_sound process_ret_Decision_sound)"], ["", "lemma wf_chain_process_ret: \"wf_chain \\<Gamma> rs \\<Longrightarrow> wf_chain \\<Gamma> (process_ret rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> rs \\<Longrightarrow>\n    wf_chain \\<Gamma> (process_ret rs)", "apply(induction rs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_chain \\<Gamma> [] \\<Longrightarrow>\n    wf_chain \\<Gamma> (process_ret [])\n 2. \\<And>a rs.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (a # rs)\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (a # rs))", "apply(simp add: wf_chain_def add_match_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (a # rs)\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (a # rs))", "apply(case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (a # rs); a = Rule x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (a # rs))", "apply(case_tac \"x2 \\<noteq> Return\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (a # rs); a = Rule x1 x2;\n        x2 \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (a # rs))\n 2. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (a # rs); a = Rule x1 x2;\n        \\<not> x2 \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (a # rs))", "apply(simp add: process_ret_split_fst_NeqReturn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (Rule x1 x2 # rs); a = Rule x1 x2;\n        x2 \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (Rule x1 x2 # process_ret rs)\n 2. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (a # rs); a = Rule x1 x2;\n        \\<not> x2 \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (a # rs))", "using wf_chain_append"], ["proof (prove)\nusing this:\n  wf_chain ?\\<Gamma> (?rs1.0 @ ?rs2.0) =\n  (wf_chain ?\\<Gamma> ?rs1.0 \\<and> wf_chain ?\\<Gamma> ?rs2.0)\n\ngoal (2 subgoals):\n 1. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (Rule x1 x2 # rs); a = Rule x1 x2;\n        x2 \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (Rule x1 x2 # process_ret rs)\n 2. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (a # rs); a = Rule x1 x2;\n        \\<not> x2 \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (a # rs))", "apply (metis Cons_eq_appendI append_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (a # rs); a = Rule x1 x2;\n        \\<not> x2 \\<noteq> Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (a # rs))", "apply(simp add: process_ret_split_fst_Return)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> rs \\<Longrightarrow>\n                wf_chain \\<Gamma> (process_ret rs);\n        wf_chain \\<Gamma> (Rule x1 Return # rs); a = Rule x1 Return;\n        x2 = Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (add_match (MatchNot x1) (process_ret rs))", "apply(simp add: wf_chain_def add_match_def get_action_case_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_chain_add_match: \"wf_chain \\<Gamma> rs \\<Longrightarrow> wf_chain \\<Gamma> (add_match m rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> rs \\<Longrightarrow>\n    wf_chain \\<Gamma> (add_match m rs)", "by(induction rs) (simp_all add: wf_chain_def add_match_def get_action_case_simp)"], ["", "subsection\\<open>Soundness\\<close>"], ["", "theorem unfolding_sound: \"wf_chain \\<Gamma> rs \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_chain \\<Gamma> rs;\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n         rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "proof (induction rs arbitrary: s t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>wf_chain \\<Gamma> [];\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [], s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], s\\<rangle> \\<Rightarrow> t\n 2. \\<And>a rs s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>wf_chain \\<Gamma> rs;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        wf_chain \\<Gamma> (a # rs);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            (a # rs), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, s\\<rangle> \\<Rightarrow> t", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_chain \\<Gamma> rs;\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n       rs, ?s\\<rangle> \\<Rightarrow> ?t\\<rbrakk>\n  \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ?s\\<rangle> \\<Rightarrow> ?t\n  wf_chain \\<Gamma> (r # rs)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      (r # rs), s\\<rangle> \\<Rightarrow> t\n\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>wf_chain \\<Gamma> [];\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [], s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], s\\<rangle> \\<Rightarrow> t\n 2. \\<And>a rs s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>wf_chain \\<Gamma> rs;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        wf_chain \\<Gamma> (a # rs);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            (a # rs), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>a #\n                            rs, s\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_chain \\<Gamma> rs;\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n       rs, ?s\\<rangle> \\<Rightarrow> ?t\\<rbrakk>\n  \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ?s\\<rangle> \\<Rightarrow> ?t\n  wf_chain \\<Gamma> (r # rs)\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      (r # rs), s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n       rs, s\\<rangle> \\<Rightarrow> t", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s t.\n                \\<lbrakk>wf_chain \\<Gamma> rs;\n                 \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                     \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n     wf_chain \\<Gamma> (r # rs);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n         (r # rs), s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, s\\<rangle> \\<Rightarrow> t", "apply(subst(asm) process_call_split_fst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s t.\n                \\<lbrakk>wf_chain \\<Gamma> rs;\n                 \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                     \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n     wf_chain \\<Gamma> (r # rs);\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma> [r] @\n        process_call \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                         rs, s\\<rangle> \\<Rightarrow> t", "apply(erule seqE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>wf_chain \\<Gamma> rs;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        wf_chain \\<Gamma> (r # rs);\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t", "unfolding wf_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply(case_tac r, rename_tac m a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti m a.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply(case_tac a)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>ti m a.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>ti m a.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 3. \\<And>ti m a.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Log\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 4. \\<And>ti m a.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Reject\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 5. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 6. \\<And>ti m a.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 7. \\<And>ti m a x7.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Goto x7\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 8. \\<And>ti m a.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Empty\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 9. \\<And>ti m a.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>\\<forall>r\\<in>set rs.\n                               \\<forall>chain.\n                                  get_action r =\n                                  Call chain \\<longrightarrow>\n                                  \\<Gamma> chain \\<noteq> None;\n                    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                        \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<forall>r\\<in>set (r # rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              \\<Gamma> chain \\<noteq> None;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [r], s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m a; a = Unknown\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply(simp_all add: seq'_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply(case_tac s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>ti m a x5 x2.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ti m a x5 x2.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Decision x2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply (metis decision decisionD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply(case_tac \"matches \\<gamma> m p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply(simp add: not_matches_add_match_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        \\<not> matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply(drule skipD, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        \\<not> matches \\<gamma> m p; Undecided = ti\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, Undecided\\<rangle> \\<Rightarrow> t\n 2. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply (metis nomatch seq_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti m a x5.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        (\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n        (\\<forall>r\\<in>set rs.\n            \\<forall>chain.\n               get_action r = Call chain \\<longrightarrow>\n               (\\<exists>y. \\<Gamma> chain = Some y));\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret (the (\\<Gamma> x5))), s\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); a = Call x5; s = Undecided;\n        matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, s\\<rangle> \\<Rightarrow> t", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti m a x5 y.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>add_match m\n            (process_ret\n              (the (\\<Gamma> x5))), Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); s = Undecided; matches \\<gamma> m p;\n        \\<forall>r\\<in>set rs.\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<Gamma> x5 = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, Undecided\\<rangle> \\<Rightarrow> t", "apply(simp add: matches_add_match_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti m x5 y.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            y, Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); s = Undecided; matches \\<gamma> m p;\n        \\<forall>r\\<in>set rs.\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<Gamma> x5 = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>Rule m\n                             (Call x5) #\n                            rs, Undecided\\<rangle> \\<Rightarrow> t", "apply(rule_tac t=ti in seq_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ti m x5 y.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            y, Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); s = Undecided; matches \\<gamma> m p;\n        \\<forall>r\\<in>set rs.\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<Gamma> x5 = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                              (Call\n                                x5)], Undecided\\<rangle> \\<Rightarrow> ti\n 2. \\<And>ti m x5 y.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            y, Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); s = Undecided; matches \\<gamma> m p;\n        \\<forall>r\\<in>set rs.\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<Gamma> x5 = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, ti\\<rangle> \\<Rightarrow> t", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ti m x5 y.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            y, Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); s = Undecided; matches \\<gamma> m p;\n        \\<forall>r\\<in>set rs.\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<Gamma> x5 = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                              (Call\n                                x5)], Undecided\\<rangle> \\<Rightarrow> ti", "using process_ret_sound'"], ["proof (prove)\nusing this:\n  ?\\<Gamma>(?chain \\<mapsto>\n  ?rs),?\\<gamma>,?p\\<turnstile> \\<langle>process_ret\n    (add_match ?m\n      ?rs), Undecided\\<rangle> \\<Rightarrow> ?t \\<Longrightarrow>\n  ?\\<Gamma>(?chain \\<mapsto>\n  ?rs),?\\<gamma>,?p\\<turnstile> \\<langle>[Rule ?m\n     (Call ?chain)], Undecided\\<rangle> \\<Rightarrow> ?t\n\ngoal (1 subgoal):\n 1. \\<And>ti m x5 y.\n       \\<lbrakk>\\<And>s t.\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call\n                       \\<Gamma>\n                       rs, s\\<rangle> \\<Rightarrow> t \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_ret\n            y, Undecided\\<rangle> \\<Rightarrow> ti;\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            rs, ti\\<rangle> \\<Rightarrow> t;\n        r = Rule m (Call x5); s = Undecided; matches \\<gamma> m p;\n        \\<forall>r\\<in>set rs.\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<Gamma> x5 = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule m\n                              (Call\n                                x5)], Undecided\\<rangle> \\<Rightarrow> ti", "by (metis fun_upd_triv matches_add_match_simp process_ret_add_match_dist)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>r #\n     rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>wf_chain \\<Gamma> [];\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n            [], s\\<rangle> \\<Rightarrow> t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[], s\\<rangle> \\<Rightarrow> t", "qed simp"], ["", "corollary unfolding_sound_complete: \"wf_chain \\<Gamma> rs \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> rs \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "by (metis unfolding_complete unfolding_sound)"], ["", "corollary unfolding_n_sound_complete: \"\\<forall>rsg \\<in> ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> rsg \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>((process_call \\<Gamma>)^^n) rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>rsg\\<in>ran \\<Gamma> \\<union> {rs}.\n       wf_chain \\<Gamma> rsg \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "proof(induction n arbitrary: rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rs.\n       Ball (ran \\<Gamma> \\<union> {rs})\n        (wf_chain \\<Gamma>) \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ 0)\n           rs, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   Ball (ran \\<Gamma> \\<union> {rs})\n                    (wf_chain \\<Gamma>) \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                        \\<Gamma> ^^\n                       n)\n                       rs, s\\<rangle> \\<Rightarrow> t =\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        Ball (ran \\<Gamma> \\<union> {rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                              \\<Gamma> ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "case 0"], ["proof (state)\nthis:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> a\n\ngoal (2 subgoals):\n 1. \\<And>rs.\n       Ball (ran \\<Gamma> \\<union> {rs})\n        (wf_chain \\<Gamma>) \\<Longrightarrow>\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ 0)\n           rs, s\\<rangle> \\<Rightarrow> t =\n       \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   Ball (ran \\<Gamma> \\<union> {rs})\n                    (wf_chain \\<Gamma>) \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                        \\<Gamma> ^^\n                       n)\n                       rs, s\\<rangle> \\<Rightarrow> t =\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        Ball (ran \\<Gamma> \\<union> {rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                              \\<Gamma> ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ 0)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ 0)\n      rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   Ball (ran \\<Gamma> \\<union> {rs})\n                    (wf_chain \\<Gamma>) \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                        \\<Gamma> ^^\n                       n)\n                       rs, s\\<rangle> \\<Rightarrow> t =\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        Ball (ran \\<Gamma> \\<union> {rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                              \\<Gamma> ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   Ball (ran \\<Gamma> \\<union> {rs})\n                    (wf_chain \\<Gamma>) \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                        \\<Gamma> ^^\n                       n)\n                       rs, s\\<rangle> \\<Rightarrow> t =\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        Ball (ran \\<Gamma> \\<union> {rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                              \\<Gamma> ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {?rs}.\n     wf_chain \\<Gamma> a \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      ?rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, s\\<rangle> \\<Rightarrow> t\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   Ball (ran \\<Gamma> \\<union> {rs})\n                    (wf_chain \\<Gamma>) \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                        \\<Gamma> ^^\n                       n)\n                       rs, s\\<rangle> \\<Rightarrow> t =\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        Ball (ran \\<Gamma> \\<union> {rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                              \\<Gamma> ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "from Suc"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {?rs}.\n     wf_chain \\<Gamma> a \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      ?rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, s\\<rangle> \\<Rightarrow> t\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> a", "have \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n) rs, s\\<rangle> \\<Rightarrow> t = \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {?rs}.\n     wf_chain \\<Gamma> a \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      ?rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, s\\<rangle> \\<Rightarrow> t\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "by blast"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   Ball (ran \\<Gamma> \\<union> {rs})\n                    (wf_chain \\<Gamma>) \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                        \\<Gamma> ^^\n                       n)\n                       rs, s\\<rangle> \\<Rightarrow> t =\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        Ball (ran \\<Gamma> \\<union> {rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                              \\<Gamma> ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "from Suc.prems"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> a", "have \"\\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}. wf_chain \\<Gamma> a\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n       wf_chain \\<Gamma> a", "proof(induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball (ran \\<Gamma> \\<union> {[]}) (wf_chain \\<Gamma>) \\<Longrightarrow>\n    Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> []})\n     (wf_chain \\<Gamma>)\n 2. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {[]}. wf_chain \\<Gamma> a\n\ngoal (2 subgoals):\n 1. Ball (ran \\<Gamma> \\<union> {[]}) (wf_chain \\<Gamma>) \\<Longrightarrow>\n    Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> []})\n     (wf_chain \\<Gamma>)\n 2. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {[]}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> []}.\n       wf_chain \\<Gamma> a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> []}.\n     wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "case(Cons r rs)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}.\n     wf_chain \\<Gamma> a \\<Longrightarrow>\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n     wf_chain \\<Gamma> a\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "from Cons.prems"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a", "have \"\\<forall>a\\<in>ran \\<Gamma>. wf_chain \\<Gamma> a\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>ran \\<Gamma>. wf_chain \\<Gamma> a", "by blast"], ["proof (state)\nthis:\n  \\<forall>a\\<in>ran \\<Gamma>. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "from Cons.prems"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a", "have \"wf_chain \\<Gamma> [r]\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> [r]", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> (r # rs) \\<and>\n    (\\<forall>x\\<in>ran \\<Gamma>. wf_chain \\<Gamma> x) \\<Longrightarrow>\n    wf_chain \\<Gamma> [r]", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_chain \\<Gamma> (r # rs);\n     \\<forall>x\\<in>ran \\<Gamma>. wf_chain \\<Gamma> x\\<rbrakk>\n    \\<Longrightarrow> wf_chain \\<Gamma> [r]", "apply(simp add: wf_chain_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wf_chain \\<Gamma> [r]\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "from Cons.prems"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a", "have \"wf_chain \\<Gamma> rs\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> rs", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> (r # rs) \\<and>\n    (\\<forall>x\\<in>ran \\<Gamma>. wf_chain \\<Gamma> x) \\<Longrightarrow>\n    wf_chain \\<Gamma> rs", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_chain \\<Gamma> (r # rs);\n     \\<forall>x\\<in>ran \\<Gamma>. wf_chain \\<Gamma> x\\<rbrakk>\n    \\<Longrightarrow> wf_chain \\<Gamma> rs", "apply(simp add: wf_chain_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wf_chain \\<Gamma> rs\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "from this Cons.prems Cons.IH"], ["proof (chain)\npicking this:\n  wf_chain \\<Gamma> rs\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}.\n     wf_chain \\<Gamma> a \\<Longrightarrow>\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n     wf_chain \\<Gamma> a", "have \"wf_chain \\<Gamma> (process_call \\<Gamma> rs)\""], ["proof (prove)\nusing this:\n  wf_chain \\<Gamma> rs\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {rs}.\n     wf_chain \\<Gamma> a \\<Longrightarrow>\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n     wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> (process_call \\<Gamma> rs)", "by blast"], ["proof (state)\nthis:\n  wf_chain \\<Gamma> (process_call \\<Gamma> rs)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "from this \\<open>wf_chain \\<Gamma> [r]\\<close>"], ["proof (chain)\npicking this:\n  wf_chain \\<Gamma> (process_call \\<Gamma> rs)\n  wf_chain \\<Gamma> [r]", "have \"wf_chain \\<Gamma> (r # (process_call \\<Gamma> rs))\""], ["proof (prove)\nusing this:\n  wf_chain \\<Gamma> (process_call \\<Gamma> rs)\n  wf_chain \\<Gamma> [r]\n\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> (r # process_call \\<Gamma> rs)", "by(simp add: wf_chain_def)"], ["proof (state)\nthis:\n  wf_chain \\<Gamma> (r # process_call \\<Gamma> rs)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "from this Cons.prems"], ["proof (chain)\npicking this:\n  wf_chain \\<Gamma> (r # process_call \\<Gamma> rs)\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a", "have \"wf_chain \\<Gamma> (process_call \\<Gamma> (r#rs))\""], ["proof (prove)\nusing this:\n  wf_chain \\<Gamma> (r # process_call \\<Gamma> rs)\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. wf_chain \\<Gamma> (process_call \\<Gamma> (r # rs))", "apply(cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wf_chain \\<Gamma> (r # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {r # rs}. wf_chain \\<Gamma> a;\n        r = Rule x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_call \\<Gamma> (r # rs))", "apply(rename_tac m a, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))", "apply(case_tac a)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Accept\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))\n 2. \\<And>m a.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Drop\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))\n 3. \\<And>m a.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Log\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))\n 4. \\<And>m a.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Reject\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))\n 5. \\<And>m a x5.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Call x5\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))\n 6. \\<And>m a.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Return\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))\n 7. \\<And>m a x7.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Goto x7\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))\n 8. \\<And>m a.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Empty\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))\n 9. \\<And>m a.\n       \\<lbrakk>wf_chain \\<Gamma> (Rule m a # process_call \\<Gamma> rs);\n        \\<forall>a\\<in>ran \\<Gamma> \\<union> {Rule m a # rs}.\n           wf_chain \\<Gamma> a;\n        r = Rule m a; a = Unknown\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (process_call \\<Gamma> (Rule m a # rs))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a x5.\n       \\<lbrakk>wf_chain \\<Gamma>\n                 (Rule m (Call x5) # process_call \\<Gamma> rs);\n        wf_chain \\<Gamma> (Rule m (Call x5) # rs) \\<and>\n        (\\<forall>x\\<in>ran \\<Gamma>. wf_chain \\<Gamma> x);\n        r = Rule m (Call x5); a = Call x5\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (add_match m (process_ret (the (\\<Gamma> x5))) @\n                           process_call \\<Gamma> rs)", "apply(simp add: wf_chain_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a x5.\n       \\<lbrakk>wf_chain \\<Gamma>\n                 (Rule m (Call x5) # process_call \\<Gamma> rs);\n        wf_chain \\<Gamma> (Rule m (Call x5) # rs) \\<and>\n        (\\<forall>x\\<in>ran \\<Gamma>. wf_chain \\<Gamma> x);\n        r = Rule m (Call x5); a = Call x5\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (add_match m\n                            (process_ret (the (\\<Gamma> x5)))) \\<and>\n                         wf_chain \\<Gamma> (process_call \\<Gamma> rs)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a x5.\n       \\<lbrakk>wf_chain \\<Gamma>\n                 (Rule m (Call x5) # process_call \\<Gamma> rs);\n        r = Rule m (Call x5); wf_chain \\<Gamma> (Rule m (Call x5) # rs);\n        \\<forall>x\\<in>ran \\<Gamma>. wf_chain \\<Gamma> x\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (add_match m\n                            (process_ret (the (\\<Gamma> x5)))) \\<and>\n                         wf_chain \\<Gamma> (process_call \\<Gamma> rs)", "apply(simp add: \\<open>wf_chain \\<Gamma> (process_call \\<Gamma> rs)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m x5.\n       \\<lbrakk>wf_chain \\<Gamma>\n                 (Rule m (Call x5) # process_call \\<Gamma> rs);\n        r = Rule m (Call x5); wf_chain \\<Gamma> (Rule m (Call x5) # rs);\n        Ball (ran \\<Gamma>) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma>\n                          (add_match m (process_ret (the (\\<Gamma> x5))))", "apply(rule wf_chain_add_match)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m x5.\n       \\<lbrakk>wf_chain \\<Gamma>\n                 (Rule m (Call x5) # process_call \\<Gamma> rs);\n        r = Rule m (Call x5); wf_chain \\<Gamma> (Rule m (Call x5) # rs);\n        Ball (ran \\<Gamma>) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (process_ret (the (\\<Gamma> x5)))", "apply(rule wf_chain_process_ret)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m x5.\n       \\<lbrakk>wf_chain \\<Gamma>\n                 (Rule m (Call x5) # process_call \\<Gamma> rs);\n        r = Rule m (Call x5); wf_chain \\<Gamma> (Rule m (Call x5) # rs);\n        Ball (ran \\<Gamma>) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> wf_chain \\<Gamma> (the (\\<Gamma> x5))", "apply(simp add: wf_chain_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m x5.\n       \\<lbrakk>(\\<exists>y. \\<Gamma> x5 = Some y) \\<and>\n                (\\<forall>r\\<in>set (process_call \\<Gamma> rs).\n                    \\<forall>chain.\n                       get_action r = Call chain \\<longrightarrow>\n                       (\\<exists>y. \\<Gamma> chain = Some y));\n        r = Rule m (Call x5);\n        \\<forall>r\\<in>set rs.\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<forall>x\\<in>ran \\<Gamma>.\n           \\<forall>r\\<in>set x.\n              \\<forall>chain.\n                 get_action r = Call chain \\<longrightarrow>\n                 (\\<exists>y. \\<Gamma> chain = Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r\\<in>set (the (\\<Gamma> x5)).\n                            \\<forall>chain.\n                               get_action r = Call chain \\<longrightarrow>\n                               (\\<exists>y. \\<Gamma> chain = Some y)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m x5 ra chain y.\n       \\<lbrakk>r = Rule m (Call x5);\n        \\<forall>r\\<in>set rs.\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<forall>x\\<in>ran \\<Gamma>.\n           \\<forall>r\\<in>set x.\n              \\<forall>chain.\n                 get_action r = Call chain \\<longrightarrow>\n                 (\\<exists>y. \\<Gamma> chain = Some y);\n        ra \\<in> set (the (\\<Gamma> x5));\n        \\<forall>r\\<in>set (process_call \\<Gamma> rs).\n           \\<forall>chain.\n              get_action r = Call chain \\<longrightarrow>\n              (\\<exists>y. \\<Gamma> chain = Some y);\n        \\<Gamma> x5 = Some y; get_action ra = Call chain\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<Gamma> chain = Some y", "by (metis ranI option.sel)"], ["proof (state)\nthis:\n  wf_chain \\<Gamma> (process_call \\<Gamma> (r # rs))\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>Ball (ran \\<Gamma> \\<union> {rs})\n                 (wf_chain \\<Gamma>) \\<Longrightarrow>\n                Ball (ran \\<Gamma> \\<union> {process_call \\<Gamma> rs})\n                 (wf_chain \\<Gamma>);\n        Ball (ran \\<Gamma> \\<union> {a # rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (ran \\<Gamma> \\<union>\n                           {process_call \\<Gamma> (a # rs)})\n                          (wf_chain \\<Gamma>)", "from this \\<open>\\<forall>a\\<in>ran \\<Gamma>. wf_chain \\<Gamma> a\\<close>"], ["proof (chain)\npicking this:\n  wf_chain \\<Gamma> (process_call \\<Gamma> (r # rs))\n  \\<forall>a\\<in>ran \\<Gamma>. wf_chain \\<Gamma> a", "show ?case"], ["proof (prove)\nusing this:\n  wf_chain \\<Gamma> (process_call \\<Gamma> (r # rs))\n  \\<forall>a\\<in>ran \\<Gamma>. wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> (r # rs)}.\n       wf_chain \\<Gamma> a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> (r # rs)}.\n     wf_chain \\<Gamma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n     wf_chain \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   Ball (ran \\<Gamma> \\<union> {rs})\n                    (wf_chain \\<Gamma>) \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                        \\<Gamma> ^^\n                       n)\n                       rs, s\\<rangle> \\<Rightarrow> t =\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        Ball (ran \\<Gamma> \\<union> {rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                              \\<Gamma> ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "from this Suc.IH[of \"((process_call \\<Gamma>) rs)\"]"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n     wf_chain \\<Gamma> a\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n     wf_chain \\<Gamma> a \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      (process_call \\<Gamma> rs), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs, s\\<rangle> \\<Rightarrow> t", "have \n        \"\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n) (process_call \\<Gamma> rs), s\\<rangle> \\<Rightarrow> t = \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma> rs, s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n     wf_chain \\<Gamma> a\n  \\<forall>a\\<in>ran \\<Gamma> \\<union> {process_call \\<Gamma> rs}.\n     wf_chain \\<Gamma> a \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      (process_call \\<Gamma> rs), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n        (process_call \\<Gamma> rs), s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n        rs, s\\<rangle> \\<Rightarrow> t", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      (process_call \\<Gamma> rs), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   Ball (ran \\<Gamma> \\<union> {rs})\n                    (wf_chain \\<Gamma>) \\<Longrightarrow>\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                        \\<Gamma> ^^\n                       n)\n                       rs, s\\<rangle> \\<Rightarrow> t =\n                   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        Ball (ran \\<Gamma> \\<union> {rs}) (wf_chain \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n                              \\<Gamma> ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "from this"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      (process_call \\<Gamma> rs), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs, s\\<rangle> \\<Rightarrow> t", "show ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ n)\n      (process_call \\<Gamma> rs), s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>process_call \\<Gamma>\n      rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^\n        Suc n)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "by (simp add: Suc.prems funpow_swap1 unfolding_sound_complete)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call \\<Gamma> ^^ Suc n)\n      rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["", "text_raw\\<open>\n\\begin{verbatim}\nloops in the linux kernel:\nhttp://lxr.linux.no/linux+v3.2/net/ipv4/netfilter/ip_tables.c#L464\n/* Figures out from what hook each rule can be called: returns 0 if\n   there are loops.  Puts hook bitmask in comefrom. */\n   static int mark_source_chains(const struct xt_table_info *newinfo,\n                   unsigned int valid_hooks, void *entry0)\n\ndiscussion: http://marc.info/?l=netfilter-devel&m=105190848425334&w=2\n\\end{verbatim}\n\\<close>"], ["", "text\\<open>Example\\<close>"], ["", "lemma \"process_call [''X'' \\<mapsto> [Rule (Match b) Return, Rule (Match c) Accept]] [Rule (Match a) (Call ''X'')] =\n       [Rule (MatchAnd (Match a) (MatchAnd (MatchNot (Match b)) (Match c))) Accept]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_call\n     [''X'' \\<mapsto> [Rule (Match b) Return, Rule (Match c) Accept]]\n     [Rule (Match a) (Call ''X'')] =\n    [Rule (MatchAnd (Match a) (MatchAnd (MatchNot (Match b)) (Match c)))\n      Accept]", "by (simp add: add_match_def)"], ["", "text\\<open>This is how a firewall processes a ruleset. \n       It starts at a certain chain, usually INPUT, FORWARD, or OUTPUT (called @{term chain_name} in the lemma).\n       The firewall has a default action of accept or drop.\n      We can check @{const sanity_wf_ruleset} and the other assumptions at runtime.\n      Consequently, we can apply @{const repeat_stabilize} as often as we want.\n\\<close>"], ["", "theorem repeat_stabilize_process_call:\n    assumes \"sanity_wf_ruleset \\<Gamma>\" and \"chain_name \\<in> set (map fst \\<Gamma>)\" and \"default_action = Accept \\<or> default_action = Drop\"\n    shows \"(map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n (process_call (map_of \\<Gamma>)) [Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n           (map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "have x: \"sanity_wf_ruleset \\<Gamma> \\<Longrightarrow> rs \\<in> ran (map_of \\<Gamma>) \\<Longrightarrow> wf_chain (map_of \\<Gamma>) rs\" for \\<Gamma> and rs::\"'a rule list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sanity_wf_ruleset \\<Gamma>;\n     rs \\<in> ran (map_of \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> wf_chain (map_of \\<Gamma>) rs", "apply(simp add: sanity_wf_ruleset_def wf_chain_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst \\<Gamma>) \\<and>\n             (\\<forall>rs\\<in>ran (map_of \\<Gamma>).\n                 \\<forall>r\\<in>set rs.\n                    case get_action r of\n                    Call chain \\<Rightarrow>\n                      chain \\<in> dom (map_of \\<Gamma>)\n                    | Goto chain \\<Rightarrow>\n                        chain \\<in> dom (map_of \\<Gamma>)\n                    | Unknown \\<Rightarrow> False | _ \\<Rightarrow> True);\n     rs \\<in> ran (map_of \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r\\<in>set rs.\n                         \\<forall>chain.\n                            get_action r = Call chain \\<longrightarrow>\n                            (\\<exists>y. (chain, y) \\<in> set \\<Gamma>)", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>sanity_wf_ruleset ?\\<Gamma>;\n   ?rs \\<in> ran (map_of ?\\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> wf_chain (map_of ?\\<Gamma>) ?rs\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "from assms(1)"], ["proof (chain)\npicking this:\n  sanity_wf_ruleset \\<Gamma>", "have 1: \"\\<forall>rsg \\<in> ran (map_of \\<Gamma>). wf_chain (map_of \\<Gamma>) rsg\""], ["proof (prove)\nusing this:\n  sanity_wf_ruleset \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>rsg\\<in>ran (map_of \\<Gamma>). wf_chain (map_of \\<Gamma>) rsg", "apply(intro ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rsg.\n       \\<lbrakk>sanity_wf_ruleset \\<Gamma>;\n        rsg \\<in> ran (map_of \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> wf_chain (map_of \\<Gamma>) rsg", "apply(drule x, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rsg.\n       \\<lbrakk>rsg \\<in> ran (map_of \\<Gamma>);\n        wf_chain (map_of \\<Gamma>) rsg\\<rbrakk>\n       \\<Longrightarrow> wf_chain (map_of \\<Gamma>) rsg", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>rsg\\<in>ran (map_of \\<Gamma>). wf_chain (map_of \\<Gamma>) rsg\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "let ?rs=\"[Rule MatchAny (Call chain_name), Rule MatchAny default_action]::'a rule list\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "from assms(2,3)"], ["proof (chain)\npicking this:\n  chain_name \\<in> set (map fst \\<Gamma>)\n  default_action = Accept \\<or> default_action = Drop", "have 2: \"wf_chain (map_of \\<Gamma>) ?rs\""], ["proof (prove)\nusing this:\n  chain_name \\<in> set (map fst \\<Gamma>)\n  default_action = Accept \\<or> default_action = Drop\n\ngoal (1 subgoal):\n 1. wf_chain (map_of \\<Gamma>)\n     [Rule MatchAny (Call chain_name), Rule MatchAny default_action]", "apply(simp add: wf_chain_def domD dom_map_of_conv_image_fst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chain_name \\<in> fst ` set \\<Gamma>;\n     default_action = Accept \\<or> default_action = Drop\\<rbrakk>\n    \\<Longrightarrow> \\<forall>chain.\n                         default_action = Call chain \\<longrightarrow>\n                         (\\<exists>y. map_of \\<Gamma> chain = Some y)", "by blast"], ["proof (state)\nthis:\n  wf_chain (map_of \\<Gamma>)\n   [Rule MatchAny (Call chain_name), Rule MatchAny default_action]\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "have \"\\<forall>rsg \\<in> ran \\<Gamma> \\<union> {rs}. wf_chain \\<Gamma> rsg \\<Longrightarrow> \n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n (process_call \\<Gamma>) rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\" for \\<Gamma> rs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>rsg\\<in>ran \\<Gamma> \\<union> {rs}.\n       wf_chain \\<Gamma> rsg \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n        (process_call \\<Gamma>) rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "by(simp add: repeat_stabilize_funpow unfolding_n_sound_complete)"], ["proof (state)\nthis:\n  \\<forall>rsg\\<in>ran ?\\<Gamma> \\<union> {?rs}.\n     wf_chain ?\\<Gamma> rsg \\<Longrightarrow>\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n       (process_call ?\\<Gamma>) ?rs, s\\<rangle> \\<Rightarrow> t =\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "moreover"], ["proof (state)\nthis:\n  \\<forall>rsg\\<in>ran ?\\<Gamma> \\<union> {?rs}.\n     wf_chain ?\\<Gamma> rsg \\<Longrightarrow>\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n       (process_call ?\\<Gamma>) ?rs, s\\<rangle> \\<Rightarrow> t =\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "from 1 2"], ["proof (chain)\npicking this:\n  \\<forall>rsg\\<in>ran (map_of \\<Gamma>). wf_chain (map_of \\<Gamma>) rsg\n  wf_chain (map_of \\<Gamma>)\n   [Rule MatchAny (Call chain_name), Rule MatchAny default_action]", "have \"\\<forall>rsg \\<in> ran (map_of \\<Gamma>) \\<union> {?rs}. wf_chain (map_of \\<Gamma>) rsg\""], ["proof (prove)\nusing this:\n  \\<forall>rsg\\<in>ran (map_of \\<Gamma>). wf_chain (map_of \\<Gamma>) rsg\n  wf_chain (map_of \\<Gamma>)\n   [Rule MatchAny (Call chain_name), Rule MatchAny default_action]\n\ngoal (1 subgoal):\n 1. \\<forall>rsg\\<in>ran (map_of \\<Gamma>) \\<union>\n                     {[Rule MatchAny (Call chain_name),\n                       Rule MatchAny default_action]}.\n       wf_chain (map_of \\<Gamma>) rsg", "by simp"], ["proof (state)\nthis:\n  \\<forall>rsg\\<in>ran (map_of \\<Gamma>) \\<union>\n                   {[Rule MatchAny (Call chain_name),\n                     Rule MatchAny default_action]}.\n     wf_chain (map_of \\<Gamma>) rsg\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>rsg\\<in>ran ?\\<Gamma> \\<union> {?rs}.\n     wf_chain ?\\<Gamma> rsg \\<Longrightarrow>\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n       (process_call ?\\<Gamma>) ?rs, s\\<rangle> \\<Rightarrow> t =\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, s\\<rangle> \\<Rightarrow> t\n  \\<forall>rsg\\<in>ran (map_of \\<Gamma>) \\<union>\n                   {[Rule MatchAny (Call chain_name),\n                     Rule MatchAny default_action]}.\n     wf_chain (map_of \\<Gamma>) rsg", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>rsg\\<in>ran ?\\<Gamma> \\<union> {?rs}.\n     wf_chain ?\\<Gamma> rsg \\<Longrightarrow>\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n       (process_call ?\\<Gamma>) ?rs, s\\<rangle> \\<Rightarrow> t =\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, s\\<rangle> \\<Rightarrow> t\n  \\<forall>rsg\\<in>ran (map_of \\<Gamma>) \\<union>\n                   {[Rule MatchAny (Call chain_name),\n                     Rule MatchAny default_action]}.\n     wf_chain (map_of \\<Gamma>) rsg\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "by simp"], ["proof (state)\nthis:\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize n\n       (process_call (map_of \\<Gamma>))\n       [Rule MatchAny (Call chain_name),\n        Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n        (Call chain_name),\n       Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition unfold_optimize_ruleset_CHAIN\n  :: \"('a match_expr \\<Rightarrow> 'a match_expr) \\<Rightarrow> string \\<Rightarrow> action \\<Rightarrow> 'a ruleset \\<Rightarrow> 'a rule list option\"\nwhere\n\"unfold_optimize_ruleset_CHAIN optimize chain_name default_action rs = (let rs =\n  (repeat_stabilize 1000 (optimize_matches opt_MatchAny_match_expr)\n    (optimize_matches optimize\n      (rw_Reject (rm_LogEmpty (repeat_stabilize 10000 (process_call rs)\n        [Rule MatchAny (Call chain_name), Rule MatchAny default_action]\n  )))))\n  in if simple_ruleset rs then Some rs else None)\""], ["", "lemma unfold_optimize_ruleset_CHAIN:\n    assumes \"sanity_wf_ruleset \\<Gamma>\" and \"chain_name \\<in> set (map fst \\<Gamma>)\"\n    and \"default_action = Accept \\<or> default_action = Drop\"\n    and \"\\<And>m. matches \\<gamma> (optimize m) p = matches \\<gamma> m p\"\n    and \"unfold_optimize_ruleset_CHAIN optimize chain_name default_action (map_of \\<Gamma>) = Some rs\"\n    shows \"(map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow>\n           (map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "from assms(5)"], ["proof (chain)\npicking this:\n  unfold_optimize_ruleset_CHAIN optimize chain_name default_action\n   (map_of \\<Gamma>) =\n  Some rs", "have rs: \"rs = repeat_stabilize 1000 (optimize_matches opt_MatchAny_match_expr)\n      (optimize_matches optimize\n        (rw_Reject\n          (rm_LogEmpty\n            (repeat_stabilize 10000 (process_call (map_of \\<Gamma>)) [Rule MatchAny (Call chain_name), Rule MatchAny default_action]))))\""], ["proof (prove)\nusing this:\n  unfold_optimize_ruleset_CHAIN optimize chain_name default_action\n   (map_of \\<Gamma>) =\n  Some rs\n\ngoal (1 subgoal):\n 1. rs =\n    repeat_stabilize 1000 (optimize_matches opt_MatchAny_match_expr)\n     (optimize_matches optimize\n       (rw_Reject\n         (rm_LogEmpty\n           (repeat_stabilize 10000 (process_call (map_of \\<Gamma>))\n             [Rule MatchAny (Call chain_name),\n              Rule MatchAny default_action]))))", "by(simp add: unfold_optimize_ruleset_CHAIN_def Let_def split: if_split_asm)"], ["proof (state)\nthis:\n  rs =\n  repeat_stabilize 1000 (optimize_matches opt_MatchAny_match_expr)\n   (optimize_matches optimize\n     (rw_Reject\n       (rm_LogEmpty\n         (repeat_stabilize 10000 (process_call (map_of \\<Gamma>))\n           [Rule MatchAny (Call chain_name),\n            Rule MatchAny default_action]))))\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "have optimize_matches_generic_funpow_helper: \"(\\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p) \\<Longrightarrow>\n        \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ n) rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\"\n    for \\<Gamma> f n rs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        matches \\<gamma> (f m) p = matches \\<gamma> m p) \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ n)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "proof(induction n arbitrary:)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m.\n        matches \\<gamma> (f m) p = matches \\<gamma> m p) \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ 0)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>n.\n       \\<lbrakk>(\\<And>m.\n                    matches \\<gamma> (f m) p =\n                    matches \\<gamma> m p) \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                     f ^^\n                    n)\n                    rs, s\\<rangle> \\<Rightarrow> t =\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                              f ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "case 0"], ["proof (state)\nthis:\n  matches \\<gamma> (f ?m) p = matches \\<gamma> ?m p\n\ngoal (2 subgoals):\n 1. (\\<And>m.\n        matches \\<gamma> (f m) p = matches \\<gamma> m p) \\<Longrightarrow>\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ 0)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n 2. \\<And>n.\n       \\<lbrakk>(\\<And>m.\n                    matches \\<gamma> (f m) p =\n                    matches \\<gamma> m p) \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                     f ^^\n                    n)\n                    rs, s\\<rangle> \\<Rightarrow> t =\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                              f ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  matches \\<gamma> (f ?m) p = matches \\<gamma> ?m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ 0)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ 0)\n      rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<And>m.\n                    matches \\<gamma> (f m) p =\n                    matches \\<gamma> m p) \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                     f ^^\n                    n)\n                    rs, s\\<rangle> \\<Rightarrow> t =\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                              f ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<And>m.\n                    matches \\<gamma> (f m) p =\n                    matches \\<gamma> m p) \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                     f ^^\n                    n)\n                    rs, s\\<rangle> \\<Rightarrow> t =\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                              f ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "case (Suc n)"], ["proof (state)\nthis:\n  (\\<And>m.\n      matches \\<gamma> (f m) p = matches \\<gamma> m p) \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ n)\n      rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n  matches \\<gamma> (f ?m) p = matches \\<gamma> ?m p\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<And>m.\n                    matches \\<gamma> (f m) p =\n                    matches \\<gamma> m p) \\<Longrightarrow>\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                     f ^^\n                    n)\n                    rs, s\\<rangle> \\<Rightarrow> t =\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                              f ^^\n                             Suc n)\n                             rs, s\\<rangle> \\<Rightarrow> t =\n                         \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<And>m.\n      matches \\<gamma> (f m) p = matches \\<gamma> m p) \\<Longrightarrow>\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ n)\n      rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n  matches \\<gamma> (f ?m) p = matches \\<gamma> ?m p\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ Suc n)\n        rs, s\\<rangle> \\<Rightarrow> t =\n    \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^\n                 n)\n                 rs, s\\<rangle> \\<Rightarrow> t =\n             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n     \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>optimize_matches\n                          f ((optimize_matches f ^^ n)\n                              rs), s\\<rangle> \\<Rightarrow> t =\n                      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "apply(subst optimize_matches_generic[where P=\"\\<lambda>_. True\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^\n                 n)\n                 rs, s\\<rangle> \\<Rightarrow> t =\n             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n     \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r\\<in>set ((optimize_matches f ^^ n) rs).\n                         True\n 2. \\<And>m.\n       \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                     f ^^\n                    n)\n                    rs, s\\<rangle> \\<Rightarrow> t =\n                \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n        \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p;\n        True\\<rbrakk>\n       \\<Longrightarrow> matches \\<gamma> (f m) p = matches \\<gamma> m p\n 3. \\<lbrakk>\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^\n                 n)\n                 rs, s\\<rangle> \\<Rightarrow> t =\n             \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t;\n     \\<And>m. matches \\<gamma> (f m) p = matches \\<gamma> m p\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n                           f ^^\n                          n)\n                          rs, s\\<rangle> \\<Rightarrow> t =\n                      \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t", "by simp_all"], ["proof (state)\nthis:\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches f ^^ Suc n)\n      rs, s\\<rangle> \\<Rightarrow> t =\n  \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<And>m.\n      matches \\<gamma> (?f m) p = matches \\<gamma> m p) \\<Longrightarrow>\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches ?f ^^ ?n)\n       ?rs, s\\<rangle> \\<Rightarrow> t =\n  ?\\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>?rs, s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "have \"(map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t \\<longleftrightarrow> map_of \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize 10000 (process_call (map_of \\<Gamma>))\n    [Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize 10000\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "apply(simp add: rs repeat_stabilize_funpow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(optimize_matches\n          opt_MatchAny_match_expr ^^\n         1000)\n         (optimize_matches optimize\n           (rw_Reject\n             (rm_LogEmpty\n               ((process_call (map_of \\<Gamma>) ^^ 10000)\n                 [Rule MatchAny (Call chain_name),\n                  Rule MatchAny\n                   default_action])))), s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n          (map_of \\<Gamma>) ^^\n         10000)\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "apply(subst optimize_matches_generic_funpow_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       matches \\<gamma> (opt_MatchAny_match_expr m) p = matches \\<gamma> m p\n 2. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>optimize_matches optimize\n         (rw_Reject\n           (rm_LogEmpty\n             ((process_call (map_of \\<Gamma>) ^^ 10000)\n               [Rule MatchAny (Call chain_name),\n                Rule MatchAny\n                 default_action]))), s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n          (map_of \\<Gamma>) ^^\n         10000)\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "apply (simp add: opt_MatchAny_match_expr_correct; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>optimize_matches optimize\n         (rw_Reject\n           (rm_LogEmpty\n             ((process_call (map_of \\<Gamma>) ^^ 10000)\n               [Rule MatchAny (Call chain_name),\n                Rule MatchAny\n                 default_action]))), s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n          (map_of \\<Gamma>) ^^\n         10000)\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "apply(subst optimize_matches_generic[where P=\"\\<lambda>_. True\"], simp_all add: assms(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rw_Reject\n         (rm_LogEmpty\n           ((process_call (map_of \\<Gamma>) ^^ 10000)\n             [Rule MatchAny (Call chain_name),\n              Rule MatchAny default_action])), s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>(process_call\n          (map_of \\<Gamma>) ^^\n         10000)\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "apply(simp add: iptables_bigstep_rw_Reject iptables_bigstep_rm_LogEmpty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize 10000\n       (process_call (map_of \\<Gamma>))\n       [Rule MatchAny (Call chain_name),\n        Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "also"], ["proof (state)\nthis:\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize 10000\n       (process_call (map_of \\<Gamma>))\n       [Rule MatchAny (Call chain_name),\n        Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "have \"\\<dots> \\<longleftrightarrow> (map_of \\<Gamma>),\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny (Call chain_name), Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize 10000\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "using assms(1,2,3)"], ["proof (prove)\nusing this:\n  sanity_wf_ruleset \\<Gamma>\n  chain_name \\<in> set (map fst \\<Gamma>)\n  default_action = Accept \\<or> default_action = Drop\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize 10000\n         (process_call (map_of \\<Gamma>))\n         [Rule MatchAny (Call chain_name),\n          Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "by(intro repeat_stabilize_process_call[of \\<Gamma> chain_name default_action \\<gamma> p 10000 s t]) simp_all"], ["proof (state)\nthis:\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>repeat_stabilize 10000\n       (process_call (map_of \\<Gamma>))\n       [Rule MatchAny (Call chain_name),\n        Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t =\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n        (Call chain_name),\n       Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "finally"], ["proof (chain)\npicking this:\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n        (Call chain_name),\n       Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n        (Call chain_name),\n       Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n    map_of\n     \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n          (Call chain_name),\n         Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t", "."], ["proof (state)\nthis:\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>rs, s\\<rangle> \\<Rightarrow> t =\n  map_of\n   \\<Gamma>,\\<gamma>,p\\<turnstile> \\<langle>[Rule MatchAny\n        (Call chain_name),\n       Rule MatchAny default_action], s\\<rangle> \\<Rightarrow> t\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}