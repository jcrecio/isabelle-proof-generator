{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/Code_Interface.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma \"quote_rewrite (''foo''@[char_of_nat 34]) = ''foo~''\"", "lemma \"(unfold_ruleset_CHAIN_safe chain a rs = Some rs') \\<Longrightarrow> simple_ruleset rs'\"", "lemma \"let fw = [''FORWARD'' \\<mapsto> []] in\n  unfold_ruleset_FORWARD action.Drop fw\n  = [Rule (MatchAny :: 32 common_primitive match_expr) action.Drop]\"", "lemma \"compress_parsed_extra\n    (map Pos [Extra ''-m'', (Extra ''recent'' :: 32 common_primitive),\n              Extra ''--update'', Extra ''--seconds'', Extra ''60'',\n              IIface (Iface ''foobar''),\n              Extra ''--name'', Extra ''DEFAULT'', Extra ''--rsource'']) =\n     map Pos [Extra ''-m recent --update --seconds 60'',\n              IIface (Iface ''foobar''),\n              Extra ''--name DEFAULT --rsource'']\"", "lemma eval_ternary_And_Unknown_Unkown:\n    \"eval_ternary_And TernaryUnknown (eval_ternary_And TernaryUnknown tv) =\n        eval_ternary_And TernaryUnknown tv\"", "lemma is_pos_Extra_alist_and:\n    \"is_pos_Extra a \\<Longrightarrow> alist_and (a#as) = MatchAnd (Match (Extra (get_pos_Extra a))) (alist_and as)\"", "lemma compress_parsed_extra_matchexpr_helper:\n    \"ternary_ternary_eval (map_match_tac common_matcher p (alist_and (compress_parsed_extra as))) =\n         ternary_ternary_eval (map_match_tac common_matcher p (alist_and as))\"", "lemma compress_parsed_extra_matchexpr:\n    \"matches (common_matcher, \\<alpha>) (alist_and (compress_parsed_extra as)) =\n        matches (common_matcher, \\<alpha>) (alist_and as)\"", "lemma \"fill_l4_protocol_raw TCP [Neg (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)), Pos (Src_Ports (L4Ports 0 [(22,22)]))] =\n          [Neg (Dst (IpAddrNetmask 0x7F000000 8)), Pos (Src_Ports (L4Ports 6 [(0x16, 0x16)]))]\"", "lemma \"fill_l4_protocol [ Neg (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8))\n                                , Neg (Prot (Proto UDP))\n                                , Pos (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8))\n                                , Pos (Prot (Proto TCP))\n                                , Pos (Extra ''foo'')\n                                , Pos (Src_Ports (L4Ports 0 [(22,22)]))\n                                , Neg (Extra ''Bar'')] =\n  [ Neg (Dst (IpAddrNetmask 0x7F000000 8))\n  , Neg (Prot (Proto UDP))\n  , Pos (Src (IpAddrNetmask 0x7F000000 8))\n  , Pos (Prot (Proto TCP))\n  , Pos (Extra ''foo'')\n  , Pos (Src_Ports (L4Ports TCP [(0x16, 0x16)]))\n  , Neg (Extra ''Bar'')]\"", "lemma \"prefix_to_strange_inverse_cisco_mask 8 = (0, 255, 255, 255)\"", "lemma \"prefix_to_strange_inverse_cisco_mask 16 = (0, 0, 255, 255)\"", "lemma \"prefix_to_strange_inverse_cisco_mask 24 = (0, 0, 0, 255)\"", "lemma \"prefix_to_strange_inverse_cisco_mask 32 = (0, 0, 0, 0)\""], "translations": [["", "lemma \"quote_rewrite (''foo''@[char_of_nat 34]) = ''foo~''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quote_rewrite (''foo'' @ [char_of_nat 34]) = ''foo~''", "by eval"], ["", "text\\<open>The parser returns the @{typ \"'i::len common_primitive ruleset\"} not as a map but as an association list.\n      This function converts it\\<close>"], ["", "(*this is only to tighten the types*)"], ["", "definition map_of_string_ipv4\n  :: \"(string \\<times> 32 common_primitive rule list) list \\<Rightarrow> string \\<rightharpoonup> 32 common_primitive rule list\" where\n  \"map_of_string_ipv4 rs = map_of rs\""], ["", "definition map_of_string_ipv6\n  :: \"(string \\<times> 128 common_primitive rule list) list \\<Rightarrow> string \\<rightharpoonup> 128 common_primitive rule list\" where\n  \"map_of_string_ipv6 rs = map_of rs\""], ["", "definition map_of_string\n  :: \"(string \\<times> 'i common_primitive rule list) list \\<Rightarrow> string \\<rightharpoonup> 'i common_primitive rule list\" where\n  \"map_of_string rs = map_of rs\""], ["", "definition unfold_ruleset_CHAIN_safe :: \"string \\<Rightarrow> action \\<Rightarrow> 'i::len common_primitive ruleset \\<Rightarrow> 'i common_primitive rule list option\" where\n\"unfold_ruleset_CHAIN_safe = unfold_optimize_ruleset_CHAIN optimize_primitive_univ\""], ["", "lemma \"(unfold_ruleset_CHAIN_safe chain a rs = Some rs') \\<Longrightarrow> simple_ruleset rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_ruleset_CHAIN_safe chain a rs = Some rs' \\<Longrightarrow>\n    simple_ruleset rs'", "by(simp add: Let_def unfold_ruleset_CHAIN_safe_def unfold_optimize_ruleset_CHAIN_def split: if_split_asm)"], ["", "(*This is just for legacy code compatibility. Use the new _safe function instead*)"], ["", "definition unfold_ruleset_CHAIN :: \"string \\<Rightarrow> action \\<Rightarrow> 'i::len common_primitive ruleset \\<Rightarrow> 'i common_primitive rule list\" where\n  \"unfold_ruleset_CHAIN chain default_action rs = the (unfold_ruleset_CHAIN_safe chain default_action rs)\""], ["", "definition unfold_ruleset_FORWARD :: \"action \\<Rightarrow> 'i::len common_primitive ruleset \\<Rightarrow> 'i::len common_primitive rule list\" where\n  \"unfold_ruleset_FORWARD = unfold_ruleset_CHAIN ''FORWARD''\""], ["", "definition unfold_ruleset_INPUT :: \"action \\<Rightarrow> 'i::len common_primitive ruleset \\<Rightarrow> 'i::len common_primitive rule list\" where\n  \"unfold_ruleset_INPUT = unfold_ruleset_CHAIN ''INPUT''\""], ["", "definition unfold_ruleset_OUTPUT :: \"action \\<Rightarrow> 'i::len common_primitive ruleset \\<Rightarrow> 'i::len common_primitive rule list\" where\n  \"unfold_ruleset_OUTPUT \\<equiv> unfold_ruleset_CHAIN ''OUTPUT''\""], ["", "lemma \"let fw = [''FORWARD'' \\<mapsto> []] in\n  unfold_ruleset_FORWARD action.Drop fw\n  = [Rule (MatchAny :: 32 common_primitive match_expr) action.Drop]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let fw = [''FORWARD'' \\<mapsto> []]\n    in unfold_ruleset_FORWARD action.Drop fw = [Rule MatchAny action.Drop]", "by eval"], ["", "(* only used for ML/Haskell code to convert types *)"], ["", "definition nat_to_8word :: \"nat \\<Rightarrow> 8 word\" where\n  \"nat_to_8word i \\<equiv> of_nat i\""], ["", "definition nat_to_16word :: \"nat \\<Rightarrow> 16 word\" where\n  \"nat_to_16word i \\<equiv> of_nat i\""], ["", "definition integer_to_16word :: \"integer \\<Rightarrow> 16 word\" where\n  \"integer_to_16word i \\<equiv> nat_to_16word (nat_of_integer i)\""], ["", "context\nbegin"], ["", "private"], ["", "definition is_pos_Extra :: \"'i::len common_primitive negation_type \\<Rightarrow> bool\" where\n    \"is_pos_Extra a \\<equiv> (case a of Pos (Extra _) \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "private"], ["", "definition get_pos_Extra :: \"'i::len common_primitive negation_type \\<Rightarrow> string\" where\n    \"get_pos_Extra a \\<equiv> (case a of Pos (Extra e) \\<Rightarrow> e | _ \\<Rightarrow> undefined)\""], ["", "fun compress_parsed_extra\n    :: \"'i::len common_primitive negation_type list \\<Rightarrow> 'i common_primitive negation_type list\" where\n    \"compress_parsed_extra [] = []\" |\n    \"compress_parsed_extra (a1#a2#as) = (if is_pos_Extra a1 \\<and> is_pos_Extra a2\n        then compress_parsed_extra (Pos (Extra (get_pos_Extra a1@'' ''@get_pos_Extra a2))#as)\n        else a1#compress_parsed_extra (a2#as)\n        )\" |\n    \"compress_parsed_extra (a#as) = a#compress_parsed_extra as\""], ["", "lemma \"compress_parsed_extra\n    (map Pos [Extra ''-m'', (Extra ''recent'' :: 32 common_primitive),\n              Extra ''--update'', Extra ''--seconds'', Extra ''60'',\n              IIface (Iface ''foobar''),\n              Extra ''--name'', Extra ''DEFAULT'', Extra ''--rsource'']) =\n     map Pos [Extra ''-m recent --update --seconds 60'',\n              IIface (Iface ''foobar''),\n              Extra ''--name DEFAULT --rsource'']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_parsed_extra\n     (map Pos\n       [Extra ''-m'', Extra ''recent'', Extra ''--update'',\n        Extra ''--seconds'', Extra ''60'', IIface (Iface ''foobar''),\n        Extra ''--name'', Extra ''DEFAULT'', Extra ''--rsource'']) =\n    map Pos\n     [Extra ''-m recent --update --seconds 60'', IIface (Iface ''foobar''),\n      Extra ''--name DEFAULT --rsource'']", "by eval"], ["", "private"], ["", "lemma eval_ternary_And_Unknown_Unkown:\n    \"eval_ternary_And TernaryUnknown (eval_ternary_And TernaryUnknown tv) =\n        eval_ternary_And TernaryUnknown tv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_ternary_And TernaryUnknown (eval_ternary_And TernaryUnknown tv) =\n    eval_ternary_And TernaryUnknown tv", "by(cases tv) (simp_all)"], ["", "private"], ["", "lemma is_pos_Extra_alist_and:\n    \"is_pos_Extra a \\<Longrightarrow> alist_and (a#as) = MatchAnd (Match (Extra (get_pos_Extra a))) (alist_and as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pos_Extra a \\<Longrightarrow>\n    alist_and (a # as) =\n    MatchAnd (Match (Extra (get_pos_Extra a))) (alist_and as)", "apply(cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_pos_Extra a; a = Pos x1\\<rbrakk>\n       \\<Longrightarrow> alist_and (a # as) =\n                         MatchAnd (Match (Extra (get_pos_Extra a)))\n                          (alist_and as)\n 2. \\<And>x2.\n       \\<lbrakk>is_pos_Extra a; a = Neg x2\\<rbrakk>\n       \\<Longrightarrow> alist_and (a # as) =\n                         MatchAnd (Match (Extra (get_pos_Extra a)))\n                          (alist_and as)", "apply(simp_all add: get_pos_Extra_def is_pos_Extra_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       \\<lbrakk>case x1 of Extra x \\<Rightarrow> True\n                | _ \\<Rightarrow> False;\n        a = Pos x1\\<rbrakk>\n       \\<Longrightarrow> x1 = Extra (case x1 of Extra e \\<Rightarrow> e)", "apply(rename_tac e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>case e of Extra x \\<Rightarrow> True\n                | _ \\<Rightarrow> False;\n        a = Pos e\\<rbrakk>\n       \\<Longrightarrow> e = Extra (case e of Extra e \\<Rightarrow> e)", "by(case_tac e)(simp_all)"], ["", "private"], ["", "lemma compress_parsed_extra_matchexpr_helper:\n    \"ternary_ternary_eval (map_match_tac common_matcher p (alist_and (compress_parsed_extra as))) =\n         ternary_ternary_eval (map_match_tac common_matcher p (alist_and as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ternary_ternary_eval\n     (map_match_tac common_matcher p\n       (alist_and (compress_parsed_extra as))) =\n    ternary_ternary_eval (map_match_tac common_matcher p (alist_and as))", "proof(induction as rule: compress_parsed_extra.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. ternary_ternary_eval\n     (map_match_tac common_matcher p\n       (alist_and (compress_parsed_extra []))) =\n    ternary_ternary_eval (map_match_tac common_matcher p (alist_and []))\n 2. \\<And>a1 a2 as.\n       \\<lbrakk>is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (compress_parsed_extra\n                       (Pos (Extra\n                              (get_pos_Extra a1 @\n                               '' '' @ get_pos_Extra a2)) #\n                        as)))) =\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (Pos (Extra\n                            (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) #\n                      as)));\n        \\<not> (is_pos_Extra a1 \\<and> is_pos_Extra a2) \\<Longrightarrow>\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (alist_and (compress_parsed_extra (a2 # as)))) =\n        ternary_ternary_eval\n         (map_match_tac common_matcher p (alist_and (a2 # as)))\\<rbrakk>\n       \\<Longrightarrow> ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and\n                              (compress_parsed_extra (a1 # a2 # as)))) =\n                         ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and (a1 # a2 # as)))\n 3. \\<And>a.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra []))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (alist_and [])) \\<Longrightarrow>\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra [a]))) =\n       ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a]))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ternary_ternary_eval\n     (map_match_tac common_matcher p\n       (alist_and (compress_parsed_extra []))) =\n    ternary_ternary_eval (map_match_tac common_matcher p (alist_and []))\n 2. \\<And>a1 a2 as.\n       \\<lbrakk>is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (compress_parsed_extra\n                       (Pos (Extra\n                              (get_pos_Extra a1 @\n                               '' '' @ get_pos_Extra a2)) #\n                        as)))) =\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (Pos (Extra\n                            (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) #\n                      as)));\n        \\<not> (is_pos_Extra a1 \\<and> is_pos_Extra a2) \\<Longrightarrow>\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (alist_and (compress_parsed_extra (a2 # as)))) =\n        ternary_ternary_eval\n         (map_match_tac common_matcher p (alist_and (a2 # as)))\\<rbrakk>\n       \\<Longrightarrow> ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and\n                              (compress_parsed_extra (a1 # a2 # as)))) =\n                         ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and (a1 # a2 # as)))\n 3. \\<And>a.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra []))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (alist_and [])) \\<Longrightarrow>\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra [a]))) =\n       ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a]))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ternary_ternary_eval\n     (map_match_tac common_matcher p\n       (alist_and (compress_parsed_extra []))) =\n    ternary_ternary_eval (map_match_tac common_matcher p (alist_and []))", "by(simp)"], ["proof (state)\nthis:\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (alist_and (compress_parsed_extra []))) =\n  ternary_ternary_eval (map_match_tac common_matcher p (alist_and []))\n\ngoal (2 subgoals):\n 1. \\<And>a1 a2 as.\n       \\<lbrakk>is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (compress_parsed_extra\n                       (Pos (Extra\n                              (get_pos_Extra a1 @\n                               '' '' @ get_pos_Extra a2)) #\n                        as)))) =\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (Pos (Extra\n                            (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) #\n                      as)));\n        \\<not> (is_pos_Extra a1 \\<and> is_pos_Extra a2) \\<Longrightarrow>\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (alist_and (compress_parsed_extra (a2 # as)))) =\n        ternary_ternary_eval\n         (map_match_tac common_matcher p (alist_and (a2 # as)))\\<rbrakk>\n       \\<Longrightarrow> ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and\n                              (compress_parsed_extra (a1 # a2 # as)))) =\n                         ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and (a1 # a2 # as)))\n 2. \\<And>a.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra []))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (alist_and [])) \\<Longrightarrow>\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra [a]))) =\n       ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a1 a2 as.\n       \\<lbrakk>is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (compress_parsed_extra\n                       (Pos (Extra\n                              (get_pos_Extra a1 @\n                               '' '' @ get_pos_Extra a2)) #\n                        as)))) =\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (Pos (Extra\n                            (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) #\n                      as)));\n        \\<not> (is_pos_Extra a1 \\<and> is_pos_Extra a2) \\<Longrightarrow>\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (alist_and (compress_parsed_extra (a2 # as)))) =\n        ternary_ternary_eval\n         (map_match_tac common_matcher p (alist_and (a2 # as)))\\<rbrakk>\n       \\<Longrightarrow> ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and\n                              (compress_parsed_extra (a1 # a2 # as)))) =\n                         ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and (a1 # a2 # as)))\n 2. \\<And>a.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra []))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (alist_and [])) \\<Longrightarrow>\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra [a]))) =\n       ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a]))", "case (2 a1 a2)"], ["proof (state)\nthis:\n  is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n  ternary_ternary_eval\n   (map_match_tac common_matcher p\n     (alist_and\n       (compress_parsed_extra\n         (Pos (Extra (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) #\n          as_)))) =\n  ternary_ternary_eval\n   (map_match_tac common_matcher p\n     (alist_and\n       (Pos (Extra (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) # as_)))\n  \\<not> (is_pos_Extra a1 \\<and> is_pos_Extra a2) \\<Longrightarrow>\n  ternary_ternary_eval\n   (map_match_tac common_matcher p\n     (alist_and (compress_parsed_extra (a2 # as_)))) =\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (alist_and (a2 # as_)))\n\ngoal (2 subgoals):\n 1. \\<And>a1 a2 as.\n       \\<lbrakk>is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (compress_parsed_extra\n                       (Pos (Extra\n                              (get_pos_Extra a1 @\n                               '' '' @ get_pos_Extra a2)) #\n                        as)))) =\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (Pos (Extra\n                            (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) #\n                      as)));\n        \\<not> (is_pos_Extra a1 \\<and> is_pos_Extra a2) \\<Longrightarrow>\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (alist_and (compress_parsed_extra (a2 # as)))) =\n        ternary_ternary_eval\n         (map_match_tac common_matcher p (alist_and (a2 # as)))\\<rbrakk>\n       \\<Longrightarrow> ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and\n                              (compress_parsed_extra (a1 # a2 # as)))) =\n                         ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and (a1 # a2 # as)))\n 2. \\<And>a.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra []))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (alist_and [])) \\<Longrightarrow>\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra [a]))) =\n       ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a]))", "thus ?case"], ["proof (prove)\nusing this:\n  is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n  ternary_ternary_eval\n   (map_match_tac common_matcher p\n     (alist_and\n       (compress_parsed_extra\n         (Pos (Extra (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) #\n          as_)))) =\n  ternary_ternary_eval\n   (map_match_tac common_matcher p\n     (alist_and\n       (Pos (Extra (get_pos_Extra a1 @ '' '' @ get_pos_Extra a2)) # as_)))\n  \\<not> (is_pos_Extra a1 \\<and> is_pos_Extra a2) \\<Longrightarrow>\n  ternary_ternary_eval\n   (map_match_tac common_matcher p\n     (alist_and (compress_parsed_extra (a2 # as_)))) =\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (alist_and (a2 # as_)))\n\ngoal (1 subgoal):\n 1. ternary_ternary_eval\n     (map_match_tac common_matcher p\n       (alist_and (compress_parsed_extra (a1 # a2 # as_)))) =\n    ternary_ternary_eval\n     (map_match_tac common_matcher p (alist_and (a1 # a2 # as_)))", "apply(simp add: is_pos_Extra_alist_and)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n             ternary_ternary_eval\n              (map_match_tac common_matcher p\n                (alist_and\n                  (compress_parsed_extra\n                    (Pos (Extra\n                           (get_pos_Extra a1 @\n                            CHR '' '' # get_pos_Extra a2)) #\n                     as_)))) =\n             eval_ternary_And TernaryUnknown\n              (ternary_ternary_eval\n                (map_match_tac common_matcher p (alist_and as_)));\n     is_pos_Extra a1 \\<longrightarrow>\n     \\<not> is_pos_Extra a2 \\<Longrightarrow>\n     ternary_ternary_eval\n      (map_match_tac common_matcher p\n        (alist_and (compress_parsed_extra (a2 # as_)))) =\n     ternary_ternary_eval\n      (map_match_tac common_matcher p (alist_and (a2 # as_)))\\<rbrakk>\n    \\<Longrightarrow> (is_pos_Extra a1 \\<and>\n                       is_pos_Extra a2 \\<longrightarrow>\n                       eval_ternary_And TernaryUnknown\n                        (ternary_ternary_eval\n                          (map_match_tac common_matcher p\n                            (alist_and as_))) =\n                       eval_ternary_And TernaryUnknown\n                        (eval_ternary_And TernaryUnknown\n                          (ternary_ternary_eval\n                            (map_match_tac common_matcher p\n                              (alist_and as_))))) \\<and>\n                      ((is_pos_Extra a1 \\<longrightarrow>\n                        \\<not> is_pos_Extra a2) \\<longrightarrow>\n                       ternary_ternary_eval\n                        (map_match_tac common_matcher p\n                          (alist_and\n                            (a1 # compress_parsed_extra (a2 # as_)))) =\n                       ternary_ternary_eval\n                        (map_match_tac common_matcher p\n                          (alist_and (a1 # a2 # as_))))", "apply(cases a1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (compress_parsed_extra\n                       (Pos (Extra\n                              (get_pos_Extra a1 @\n                               CHR '' '' # get_pos_Extra a2)) #\n                        as_)))) =\n                eval_ternary_And TernaryUnknown\n                 (ternary_ternary_eval\n                   (map_match_tac common_matcher p (alist_and as_)));\n        is_pos_Extra a1 \\<longrightarrow>\n        \\<not> is_pos_Extra a2 \\<Longrightarrow>\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (alist_and (compress_parsed_extra (a2 # as_)))) =\n        ternary_ternary_eval\n         (map_match_tac common_matcher p (alist_and (a2 # as_)));\n        a1 = Pos x1\\<rbrakk>\n       \\<Longrightarrow> (is_pos_Extra a1 \\<and>\n                          is_pos_Extra a2 \\<longrightarrow>\n                          eval_ternary_And TernaryUnknown\n                           (ternary_ternary_eval\n                             (map_match_tac common_matcher p\n                               (alist_and as_))) =\n                          eval_ternary_And TernaryUnknown\n                           (eval_ternary_And TernaryUnknown\n                             (ternary_ternary_eval\n                               (map_match_tac common_matcher p\n                                 (alist_and as_))))) \\<and>\n                         ((is_pos_Extra a1 \\<longrightarrow>\n                           \\<not> is_pos_Extra a2) \\<longrightarrow>\n                          ternary_ternary_eval\n                           (map_match_tac common_matcher p\n                             (alist_and\n                               (a1 # compress_parsed_extra (a2 # as_)))) =\n                          ternary_ternary_eval\n                           (map_match_tac common_matcher p\n                             (alist_and (a1 # a2 # as_))))\n 2. \\<And>x2.\n       \\<lbrakk>is_pos_Extra a1 \\<and> is_pos_Extra a2 \\<Longrightarrow>\n                ternary_ternary_eval\n                 (map_match_tac common_matcher p\n                   (alist_and\n                     (compress_parsed_extra\n                       (Pos (Extra\n                              (get_pos_Extra a1 @\n                               CHR '' '' # get_pos_Extra a2)) #\n                        as_)))) =\n                eval_ternary_And TernaryUnknown\n                 (ternary_ternary_eval\n                   (map_match_tac common_matcher p (alist_and as_)));\n        is_pos_Extra a1 \\<longrightarrow>\n        \\<not> is_pos_Extra a2 \\<Longrightarrow>\n        ternary_ternary_eval\n         (map_match_tac common_matcher p\n           (alist_and (compress_parsed_extra (a2 # as_)))) =\n        ternary_ternary_eval\n         (map_match_tac common_matcher p (alist_and (a2 # as_)));\n        a1 = Neg x2\\<rbrakk>\n       \\<Longrightarrow> (is_pos_Extra a1 \\<and>\n                          is_pos_Extra a2 \\<longrightarrow>\n                          eval_ternary_And TernaryUnknown\n                           (ternary_ternary_eval\n                             (map_match_tac common_matcher p\n                               (alist_and as_))) =\n                          eval_ternary_And TernaryUnknown\n                           (eval_ternary_And TernaryUnknown\n                             (ternary_ternary_eval\n                               (map_match_tac common_matcher p\n                                 (alist_and as_))))) \\<and>\n                         ((is_pos_Extra a1 \\<longrightarrow>\n                           \\<not> is_pos_Extra a2) \\<longrightarrow>\n                          ternary_ternary_eval\n                           (map_match_tac common_matcher p\n                             (alist_and\n                               (a1 # compress_parsed_extra (a2 # as_)))) =\n                          ternary_ternary_eval\n                           (map_match_tac common_matcher p\n                             (alist_and (a1 # a2 # as_))))", "apply(simp_all add: eval_ternary_And_Unknown_Unkown)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ternary_ternary_eval\n   (map_match_tac common_matcher p\n     (alist_and (compress_parsed_extra (a1 # a2 # as_)))) =\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (alist_and (a1 # a2 # as_)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra []))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (alist_and [])) \\<Longrightarrow>\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra [a]))) =\n       ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra []))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (alist_and [])) \\<Longrightarrow>\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra [a]))) =\n       ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a]))", "case 3"], ["proof (state)\nthis:\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (alist_and (compress_parsed_extra []))) =\n  ternary_ternary_eval (map_match_tac common_matcher p (alist_and []))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra []))) =\n       ternary_ternary_eval\n        (map_match_tac common_matcher p (alist_and [])) \\<Longrightarrow>\n       ternary_ternary_eval\n        (map_match_tac common_matcher p\n          (alist_and (compress_parsed_extra [a]))) =\n       ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a]))", "thus ?case"], ["proof (prove)\nusing this:\n  ternary_ternary_eval\n   (map_match_tac common_matcher p (alist_and (compress_parsed_extra []))) =\n  ternary_ternary_eval (map_match_tac common_matcher p (alist_and []))\n\ngoal (1 subgoal):\n 1. ternary_ternary_eval\n     (map_match_tac common_matcher p\n       (alist_and (compress_parsed_extra [a_]))) =\n    ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a_]))", "by(simp)"], ["proof (state)\nthis:\n  ternary_ternary_eval\n   (map_match_tac common_matcher p\n     (alist_and (compress_parsed_extra [a_]))) =\n  ternary_ternary_eval (map_match_tac common_matcher p (alist_and [a_]))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>This lemma justifies that it is okay to fold together the parsed unknown tokens\\<close>"], ["", "lemma compress_parsed_extra_matchexpr:\n    \"matches (common_matcher, \\<alpha>) (alist_and (compress_parsed_extra as)) =\n        matches (common_matcher, \\<alpha>) (alist_and as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matching_Ternary.matches (common_matcher, \\<alpha>)\n     (alist_and (compress_parsed_extra as)) =\n    Matching_Ternary.matches (common_matcher, \\<alpha>) (alist_and as)", "apply(simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       Matching_Ternary.matches (common_matcher, \\<alpha>)\n        (alist_and (compress_parsed_extra as)) x xa =\n       Matching_Ternary.matches (common_matcher, \\<alpha>) (alist_and as) x\n        xa", "apply(intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       Matching_Ternary.matches (common_matcher, \\<alpha>)\n        (alist_and (compress_parsed_extra as)) x xa =\n       Matching_Ternary.matches (common_matcher, \\<alpha>) (alist_and as) x\n        xa", "apply(rule matches_iff_apply_f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       ternary_ternary_eval\n        (map_match_tac common_matcher xa\n          (alist_and (compress_parsed_extra as))) =\n       ternary_ternary_eval (map_match_tac common_matcher xa (alist_and as))", "apply(simp add: compress_parsed_extra_matchexpr_helper)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection\\<open>L4 Ports Parser Helper\\<close>"], ["", "context\nbegin"], ["", "text\\<open>Replace all matches on ports with the unspecified @{term 0} protocol with the given @{typ primitive_protocol}.\\<close>"], ["", "private"], ["", "definition fill_l4_protocol_raw\n    :: \"primitive_protocol \\<Rightarrow> 'i::len common_primitive negation_type list \\<Rightarrow> 'i common_primitive negation_type list\"\n  where\n    \"fill_l4_protocol_raw protocol \\<equiv> NegPos_map\n      (\\<lambda> m. case m of Src_Ports (L4Ports x pts) \\<Rightarrow> if x \\<noteq> 0 then undefined else Src_Ports (L4Ports protocol pts)\n                   |  Dst_Ports (L4Ports x pts) \\<Rightarrow> if x \\<noteq> 0 then undefined else Dst_Ports (L4Ports protocol pts)\n                   |  MultiportPorts (L4Ports x pts) \\<Rightarrow> if x \\<noteq> 0 then undefined else MultiportPorts (L4Ports protocol pts)\n                   |  Prot _ \\<Rightarrow> undefined \\<comment> \\<open>there should be no more match on the protocol if it was parsed from an iptables-save line\\<close>\n                   | m \\<Rightarrow> m\n      )\""], ["", "lemma \"fill_l4_protocol_raw TCP [Neg (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)), Pos (Src_Ports (L4Ports 0 [(22,22)]))] =\n          [Neg (Dst (IpAddrNetmask 0x7F000000 8)), Pos (Src_Ports (L4Ports 6 [(0x16, 0x16)]))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill_l4_protocol_raw TCP\n     [Neg (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)),\n      Pos (Src_Ports (L4Ports 0 [(22, 22)]))] =\n    [Neg (Dst (IpAddrNetmask 2130706432 8)),\n     Pos (Src_Ports (L4Ports 6 [(22, 22)]))]", "by eval"], ["", "fun fill_l4_protocol\n    :: \"'i::len common_primitive negation_type list \\<Rightarrow> 'i::len common_primitive negation_type list\"\n  where\n    \"fill_l4_protocol [] = []\" |\n    \"fill_l4_protocol (Pos (Prot (Proto protocol)) # ms) = Pos (Prot (Proto protocol)) # fill_l4_protocol_raw protocol ms\" |\n    \"fill_l4_protocol (Pos (Src_Ports _) # _) = undefined\" | (*need to find proto first*)\n    \"fill_l4_protocol (Pos (Dst_Ports _) # _) = undefined\" |\n    \"fill_l4_protocol (Pos (MultiportPorts _) # _) = undefined\" |\n    \"fill_l4_protocol (Neg (Src_Ports _) # _) = undefined\" |\n    \"fill_l4_protocol (Neg (Dst_Ports _) # _) = undefined\" |\n    \"fill_l4_protocol (Neg (MultiportPorts _) # _) = undefined\" |\n    \"fill_l4_protocol (m # ms) = m # fill_l4_protocol ms\""], ["", "lemma \"fill_l4_protocol [ Neg (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8))\n                                , Neg (Prot (Proto UDP))\n                                , Pos (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8))\n                                , Pos (Prot (Proto TCP))\n                                , Pos (Extra ''foo'')\n                                , Pos (Src_Ports (L4Ports 0 [(22,22)]))\n                                , Neg (Extra ''Bar'')] =\n  [ Neg (Dst (IpAddrNetmask 0x7F000000 8))\n  , Neg (Prot (Proto UDP))\n  , Pos (Src (IpAddrNetmask 0x7F000000 8))\n  , Pos (Prot (Proto TCP))\n  , Pos (Extra ''foo'')\n  , Pos (Src_Ports (L4Ports TCP [(0x16, 0x16)]))\n  , Neg (Extra ''Bar'')]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fill_l4_protocol\n     [Neg (Dst (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)),\n      Neg (Prot (Proto UDP)),\n      Pos (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)),\n      Pos (Prot (Proto TCP)), Pos (Extra ''foo''),\n      Pos (Src_Ports (L4Ports 0 [(22, 22)])), Neg (Extra ''Bar'')] =\n    [Neg (Dst (IpAddrNetmask 2130706432 8)), Neg (Prot (Proto UDP)),\n     Pos (Src (IpAddrNetmask 2130706432 8)), Pos (Prot (Proto TCP)),\n     Pos (Extra ''foo''), Pos (Src_Ports (L4Ports TCP [(22, 22)])),\n     Neg (Extra ''Bar'')]", "by eval"], ["", "end"], ["", "(*currently unused and unverifed. may be needed for future use*)"], ["", "definition prefix_to_strange_inverse_cisco_mask:: \"nat \\<Rightarrow> (nat \\<times> nat \\<times> nat \\<times> nat)\" where\n \"prefix_to_strange_inverse_cisco_mask n \\<equiv> dotdecimal_of_ipv4addr ( (NOT (((mask n)::ipv4addr) << (32 - n))) )\""], ["", "lemma \"prefix_to_strange_inverse_cisco_mask 8 = (0, 255, 255, 255)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_strange_inverse_cisco_mask 8 = (0, 255, 255, 255)", "by eval"], ["", "lemma \"prefix_to_strange_inverse_cisco_mask 16 = (0, 0, 255, 255)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_strange_inverse_cisco_mask 16 = (0, 0, 255, 255)", "by eval"], ["", "lemma \"prefix_to_strange_inverse_cisco_mask 24 = (0, 0, 0, 255)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_strange_inverse_cisco_mask 24 = (0, 0, 0, 255)", "by eval"], ["", "lemma \"prefix_to_strange_inverse_cisco_mask 32 = (0, 0, 0, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_strange_inverse_cisco_mask 32 = (0, 0, 0, 0)", "by eval"], ["", "end"]]}