{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/Routing_IpAssmt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma ipcidr_union_cidr_split[simp]: \"ipcidr_union_set (set (cidr_split x)) = wordinterval_to_set x\"", "lemma map_of_map_Iface: \"map_of (map (\\<lambda>x. (Iface (fst x), f (snd x))) xs) (Iface ifce) = \n        map_option f ((map_of xs) ifce)\"", "lemma \"routing_ipassmt_wi ([]::32 prefix_routing) = [(output_iface (routing_action (undefined :: 32 routing_rule)), WordInterval 0 0xFFFFFFFF)]\"", "lemma routing_ipassmt: \"\n    valid_prefixes rt \\<Longrightarrow>\n    output_iface (routing_table_semantics rt (p_dst p)) = p_oiface p \\<Longrightarrow>\n    \\<exists>p_ips. map_of (routing_ipassmt rt) (Iface (p_oiface p)) = Some p_ips \\<and> p_dst p \\<in> ipcidr_union_set (set p_ips)\"", "lemma routing_ipassmt_ipassmt_sanity_disjoint: \"valid_prefixes (rt::('i::len) prefix_routing) \\<Longrightarrow>\n    ipassmt_sanity_disjoint (map_of (routing_ipassmt rt))\"", "lemma routing_ipassmt_distinct: \"distinct (map fst (routing_ipassmt rtbl))\""], "translations": [["", "lemma ipcidr_union_cidr_split[simp]: \"ipcidr_union_set (set (cidr_split x)) = wordinterval_to_set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (cidr_split x)) = wordinterval_to_set x", "apply(subst cidr_split_prefix[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set (set (cidr_split x)) =\n    \\<Union> (uncurry ipset_from_cidr ` set (cidr_split x))", "apply(fact ipcidr_union_set_uncurry)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma map_of_map_Iface: \"map_of (map (\\<lambda>x. (Iface (fst x), f (snd x))) xs) (Iface ifce) = \n        map_option f ((map_of xs) ifce)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>x. (Iface (fst x), f (snd x))) xs) (Iface ifce) =\n    map_option f (map_of xs ifce)", "by (induct xs) (auto)"], ["", "lemma \"routing_ipassmt_wi ([]::32 prefix_routing) = [(output_iface (routing_action (undefined :: 32 routing_rule)), WordInterval 0 0xFFFFFFFF)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routing_ipassmt_wi [] =\n    [(routing_oiface undefined, WordInterval 0 4294967295)]", "by code_simp"], ["", "lemma routing_ipassmt: \"\n    valid_prefixes rt \\<Longrightarrow>\n    output_iface (routing_table_semantics rt (p_dst p)) = p_oiface p \\<Longrightarrow>\n    \\<exists>p_ips. map_of (routing_ipassmt rt) (Iface (p_oiface p)) = Some p_ips \\<and> p_dst p \\<in> ipcidr_union_set (set p_ips)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt;\n     output_iface (routing_table_semantics rt (p_dst p)) =\n     p_oiface p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p_ips.\n                         map_of (routing_ipassmt rt) (Iface (p_oiface p)) =\n                         Some p_ips \\<and>\n                         p_dst p \\<in> ipcidr_union_set (set p_ips)", "apply(simp add: routing_ipassmt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt;\n     output_iface (routing_table_semantics rt (p_dst p)) =\n     p_oiface p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p_ips.\n                         map_of\n                          (map ((apfst Iface \\<circ>\\<circ> apsnd)\n                                 cidr_split)\n                            (routing_ipassmt_wi rt))\n                          (Iface (p_oiface p)) =\n                         Some p_ips \\<and>\n                         p_dst p \\<in> ipcidr_union_set (set p_ips)", "apply(drule routing_ipassmt_wi[where output_port=\"p_oiface p\" and k=\"p_dst p\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>output_iface (routing_table_semantics rt (p_dst p)) =\n             p_oiface p;\n     (output_iface (routing_table_semantics rt (p_dst p)) = p_oiface p) =\n     (\\<exists>ip_range.\n         p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n         (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p_ips.\n                         map_of\n                          (map ((apfst Iface \\<circ>\\<circ> apsnd)\n                                 cidr_split)\n                            (routing_ipassmt_wi rt))\n                          (Iface (p_oiface p)) =\n                         Some p_ips \\<and>\n                         p_dst p \\<in> ipcidr_union_set (set p_ips)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ip_range.\n                p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n                (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt);\n     output_iface (routing_table_semantics rt (p_dst p)) =\n     p_oiface p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p_ips.\n                         map_of\n                          (map ((apfst Iface \\<circ>\\<circ> apsnd)\n                                 cidr_split)\n                            (routing_ipassmt_wi rt))\n                          (Iface (p_oiface p)) =\n                         Some p_ips \\<and>\n                         p_dst p \\<in> ipcidr_union_set (set p_ips)", "apply(elim exE, rename_tac ip_range)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip_range.\n       \\<lbrakk>output_iface (routing_table_semantics rt (p_dst p)) =\n                p_oiface p;\n        p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n        (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p_ips.\n                            map_of\n                             (map ((apfst Iface \\<circ>\\<circ> apsnd)\n                                    cidr_split)\n                               (routing_ipassmt_wi rt))\n                             (Iface (p_oiface p)) =\n                            Some p_ips \\<and>\n                            p_dst p \\<in> ipcidr_union_set (set p_ips)", "apply(rule_tac x=\"cidr_split ip_range\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip_range.\n       \\<lbrakk>output_iface (routing_table_semantics rt (p_dst p)) =\n                p_oiface p;\n        p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n        (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt)\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map ((apfst Iface \\<circ>\\<circ> apsnd)\n                                 cidr_split)\n                            (routing_ipassmt_wi rt))\n                          (Iface (p_oiface p)) =\n                         Some (cidr_split ip_range) \\<and>\n                         p_dst p\n                         \\<in> ipcidr_union_set (set (cidr_split ip_range))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip_range.\n       \\<lbrakk>output_iface (routing_table_semantics rt (p_dst p)) =\n                p_oiface p;\n        p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n        (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt)\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map ((apfst Iface \\<circ>\\<circ> apsnd)\n                                 cidr_split)\n                            (routing_ipassmt_wi rt))\n                          (Iface (p_oiface p)) =\n                         Some (cidr_split ip_range)", "apply(simp add: comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip_range.\n       \\<lbrakk>output_iface (routing_table_semantics rt (p_dst p)) =\n                p_oiface p;\n        p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n        (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt)\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>x.\n                                   (Iface (fst x), cidr_split (snd x)))\n                            (routing_ipassmt_wi rt))\n                          (Iface (p_oiface p)) =\n                         Some (cidr_split ip_range)", "apply(simp add: map_of_map_Iface)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip_range.\n       \\<lbrakk>output_iface (routing_table_semantics rt (p_dst p)) =\n                p_oiface p;\n        p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n        (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z.\n                            map_of (routing_ipassmt_wi rt) (p_oiface p) =\n                            Some z \\<and>\n                            cidr_split z = cidr_split ip_range", "apply(rule_tac x=\"ip_range\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip_range.\n       \\<lbrakk>output_iface (routing_table_semantics rt (p_dst p)) =\n                p_oiface p;\n        p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n        (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt)\\<rbrakk>\n       \\<Longrightarrow> map_of (routing_ipassmt_wi rt) (p_oiface p) =\n                         Some ip_range \\<and>\n                         cidr_split ip_range = cidr_split ip_range", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip_range.\n       \\<lbrakk>output_iface (routing_table_semantics rt (p_dst p)) =\n                p_oiface p;\n        p_dst p \\<in> wordinterval_to_set ip_range \\<and>\n        (p_oiface p, ip_range) \\<in> set (routing_ipassmt_wi rt)\\<rbrakk>\n       \\<Longrightarrow> map_of (routing_ipassmt_wi rt) (p_oiface p) =\n                         Some ip_range", "by (simp add: routing_ipassmt_wi_distinct)"], ["", "lemma routing_ipassmt_ipassmt_sanity_disjoint: \"valid_prefixes (rt::('i::len) prefix_routing) \\<Longrightarrow>\n    ipassmt_sanity_disjoint (map_of (routing_ipassmt rt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefixes rt \\<Longrightarrow>\n    ipassmt_sanity_disjoint (map_of (routing_ipassmt rt))", "unfolding ipassmt_sanity_disjoint_def routing_ipassmt_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefixes rt \\<Longrightarrow>\n    \\<forall>i1\\<in>dom (map_of\n                          (map (\\<lambda>x.\n                                   apfst Iface (apsnd cidr_split x))\n                            (routing_ipassmt_wi rt))).\n       \\<forall>i2\\<in>dom (map_of\n                             (map (\\<lambda>x.\napfst Iface (apsnd cidr_split x))\n                               (routing_ipassmt_wi rt))).\n          i1 \\<noteq> i2 \\<longrightarrow>\n          ipcidr_union_set\n           (set (the (map_of\n                       (map (\\<lambda>x. apfst Iface (apsnd cidr_split x))\n                         (routing_ipassmt_wi rt))\n                       i1))) \\<inter>\n          ipcidr_union_set\n           (set (the (map_of\n                       (map (\\<lambda>x. apfst Iface (apsnd cidr_split x))\n                         (routing_ipassmt_wi rt))\n                       i2))) =\n          {}", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i1 i2 y ya.\n       \\<lbrakk>valid_prefixes rt;\n        map_of\n         (map (\\<lambda>x. (Iface (fst x), cidr_split (snd x)))\n           (routing_ipassmt_wi rt))\n         i1 =\n        Some y;\n        map_of\n         (map (\\<lambda>x. (Iface (fst x), cidr_split (snd x)))\n           (routing_ipassmt_wi rt))\n         i2 =\n        Some ya;\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> ipcidr_union_set (set y) \\<inter>\n                         ipcidr_union_set (set ya) =\n                         {}", "apply(drule map_of_SomeD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i1 i2 y ya.\n       \\<lbrakk>valid_prefixes rt; i1 \\<noteq> i2;\n        (i1, y)\n        \\<in> set (map (\\<lambda>x. (Iface (fst x), cidr_split (snd x)))\n                    (routing_ipassmt_wi rt));\n        (i2, ya)\n        \\<in> set (map (\\<lambda>x. (Iface (fst x), cidr_split (snd x)))\n                    (routing_ipassmt_wi rt))\\<rbrakk>\n       \\<Longrightarrow> ipcidr_union_set (set y) \\<inter>\n                         ipcidr_union_set (set ya) =\n                         {}", "apply(clarsimp split: iface.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>valid_prefixes rt; (a, b) \\<in> set (routing_ipassmt_wi rt);\n        (aa, ba) \\<in> set (routing_ipassmt_wi rt);\n        wordinterval_to_set b \\<inter> wordinterval_to_set ba \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> a = aa", "using routing_ipassmt_wi_disjoint[where 'i = 'i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_prefixes ?tbl; ?a1.0 \\<noteq> ?a2.0;\n   (?a1.0, ?b1.0) \\<in> set (routing_ipassmt_wi ?tbl);\n   (?a2.0, ?b2.0) \\<in> set (routing_ipassmt_wi ?tbl)\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?b1.0 \\<inter>\n                    wordinterval_to_set ?b2.0 =\n                    {}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>valid_prefixes rt; (a, b) \\<in> set (routing_ipassmt_wi rt);\n        (aa, ba) \\<in> set (routing_ipassmt_wi rt);\n        wordinterval_to_set b \\<inter> wordinterval_to_set ba \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> a = aa", "by meson"], ["", "lemma routing_ipassmt_distinct: \"distinct (map fst (routing_ipassmt rtbl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (routing_ipassmt rtbl))", "using routing_ipassmt_wi_distinct[of rtbl]"], ["proof (prove)\nusing this:\n  distinct (map fst (routing_ipassmt_wi rtbl))\n\ngoal (1 subgoal):\n 1. distinct (map fst (routing_ipassmt rtbl))", "unfolding routing_ipassmt_def"], ["proof (prove)\nusing this:\n  distinct (map fst (routing_ipassmt_wi rtbl))\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map ((apfst Iface \\<circ>\\<circ> apsnd) cidr_split)\n         (routing_ipassmt_wi rtbl)))", "apply(simp add: comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (routing_ipassmt_wi rtbl)) \\<Longrightarrow>\n    distinct (map (\\<lambda>x. Iface (fst x)) (routing_ipassmt_wi rtbl))", "apply(subst distinct_map[where f = Iface and xs = \"map fst (routing_ipassmt_wi rtbl)\", simplified, unfolded comp_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (routing_ipassmt_wi rtbl)) \\<Longrightarrow>\n    distinct (map fst (routing_ipassmt_wi rtbl)) \\<and>\n    inj_on Iface (fst ` set (routing_ipassmt_wi rtbl))", "apply(auto intro: inj_onI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}