{"file_name": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics/Primitive_Matchers/No_Spoof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Iptables_Semantics", "problem_names": ["lemma \"no_spoofing TYPE(unit) ipassmt rs \\<longleftrightarrow>\n    (\\<forall> iface \\<in> dom ipassmt. \\<forall>p :: 32 tagged_packet.\n      ((common_matcher, in_doubt_allow),p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow)\n         \\<longrightarrow> p_src p \\<in> (ipcidr_union_set (set (the (ipassmt iface)))))\"", "lemma \"primitive_extractor (is_Src, src_sel)\n      (MatchAnd (Match (Src (IpAddrNetmask (0::ipv4addr) 30))) (Match (IIface (Iface ''eth0'')))) =\n      ([Pos (IpAddrNetmask 0 30)], MatchAnd MatchAny (Match (IIface (Iface ''eth0''))))\"", "lemma get_exists_matching_src_ips_subset: \n    assumes \"normalized_nnf_match m\"\n    shows \"{ip. (\\<exists>p :: ('i::len, 'a) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m a (p\\<lparr>p_iiface:= iface_sel iface, p_src:= ip\\<rparr>))} \\<subseteq>\n           get_exists_matching_src_ips iface m\"", "lemma common_primitive_not_has_primitive_expand: \n        \"\\<not> has_primitive (m::'i::len common_primitive match_expr) \\<longleftrightarrow>\n         \\<not> has_disc is_Dst m \\<and> \n         \\<not> has_disc is_Src m \\<and>\n         \\<not> has_disc is_Iiface m \\<and>\n         \\<not> has_disc is_Oiface m \\<and>\n         \\<not> has_disc is_Prot m \\<and>\n         \\<not> has_disc is_Src_Ports m \\<and>\n         \\<not> has_disc is_Dst_Ports m \\<and>\n         \\<not> has_disc is_MultiportPorts m \\<and>\n         \\<not> has_disc is_L4_Flags m \\<and>\n         \\<not> has_disc is_CT_State m \\<and>\n         \\<not> has_disc is_Extra m\"", "lemma \"\\<not> has_primitive m \\<and> matcheq_matchAny m \\<longleftrightarrow> (if \\<not> has_primitive m then matcheq_matchAny m else False)\"", "lemma get_all_matching_src_ips: \n    assumes \"normalized_nnf_match m\"\n    shows \"get_all_matching_src_ips iface m \\<subseteq>\n            {ip. (\\<forall>p::('i::len, 'a) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m a (p\\<lparr>p_iiface:= iface_sel iface, p_src:= ip\\<rparr>))}\"", "lemma get_exists_matching_src_ips_executable: \n    \"wordinterval_to_set (get_exists_matching_src_ips_executable iface m) = get_exists_matching_src_ips iface m\"", "lemma \"(get_exists_matching_src_ips_executable (Iface ''eth0'')\n      (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0''))))) =\n      RangeUnion (WordInterval 0 0xC0A7FFFF) (WordInterval 0xC0A80100 0xFFFFFFFF)\"", "lemma get_all_matching_src_ips_executable: \n    \"wordinterval_to_set (get_all_matching_src_ips_executable iface m) = get_all_matching_src_ips iface m\"", "lemma \"(get_all_matching_src_ips_executable (Iface ''eth0'')\n      (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0''))))) = \n      RangeUnion (WordInterval 0 0xC0A7FFFF) (WordInterval 0xC0A80100 0xFFFFFFFF)\"", "lemma no_spoofing_algorithm_executable: \"no_spoofing_algorithm_executable iface ipassmt rs allowed denied \\<longleftrightarrow> \n         no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed) (wordinterval_to_set denied)\"", "lemma nospoof_setbydecision:\n    fixes rs :: \"'i::len common_primitive rule list\"\n    shows \"nospoof TYPE('pkt_ext) iface ipassmt rs \\<longleftrightarrow> \n          setbydecision TYPE('pkt_ext) iface rs FinalAllow \\<subseteq> (ipcidr_union_set (set (the (ipassmt iface))))\"", "lemma setbydecision_setbydecision_all_Allow: \n    \"(setbydecision TYPE('pkt_ext) iface rs FinalAllow - setbydecision_all TYPE('pkt_ext) iface rs FinalDeny) = \n      setbydecision TYPE('pkt_ext) iface rs FinalAllow\"", "lemma setbydecision_setbydecision_all_Deny: \n    \"(setbydecision TYPE('pkt_ext) iface rs FinalDeny - setbydecision_all TYPE('pkt_ext) iface rs FinalAllow) = \n      setbydecision TYPE('pkt_ext) iface rs FinalDeny\"", "lemma setbydecision_append:\n    \"simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n      setbydecision TYPE('pkt_ext) iface (rs1 @ rs2) FinalAllow =\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<union> {ip. \\<exists>p :: ('i::len,'pkt_ext) tagged_packet_scheme. approximating_bigstep_fun (common_matcher, in_doubt_allow) \n         (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs2 Undecided = Decision FinalAllow \\<and>\n          approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs1 Undecided = Undecided}\"", "lemma not_FinalAllow: \"foo \\<noteq> Decision FinalAllow \\<longleftrightarrow> foo = Decision FinalDeny \\<or> foo = Undecided\"", "lemma setbydecision_all_appendAccept: \"simple_ruleset (rs @ [Rule r Accept]) \\<Longrightarrow> \n    setbydecision_all TYPE('pkt_ext) iface rs FinalDeny = setbydecision_all TYPE('pkt_ext) iface (rs @ [Rule r Accept]) FinalDeny\"", "lemma setbydecision_all_append_subset: \"simple_ruleset (rs1 @ rs2) \\<Longrightarrow> \n            setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union> {ip. \\<forall>p :: ('i::len,'pkt_ext) tagged_packet_scheme.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs2 Undecided = Decision FinalDeny \\<and>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs1 Undecided = Undecided}\n            \\<subseteq>\n            setbydecision_all TYPE('pkt_ext) iface (rs1 @ rs2) FinalDeny\"", "lemma \"setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n                 {ip. \\<forall>p :: ('i::len,'pkt_ext) tagged_packet_scheme.\n                 approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1 Undecided = Undecided}\n                 \\<subseteq>\n                 - setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\"", "lemma Collect_minus_eq: \"{x. P x} - {x. Q x} = {x. P x \\<and> \\<not> Q x}\"", "lemma setbydecision_all_append_subset2:\n      \"simple_ruleset (rs1 @ rs2) \\<Longrightarrow> \n       setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union> \n      (setbydecision_all TYPE('pkt_ext) iface rs2 FinalDeny - \n       setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)\n     \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ rs2) FinalDeny\"", "lemma \"setbydecision_all TYPE('pkt_ext) iface rs FinalDeny \\<subseteq> - setbydecision TYPE('pkt_ext) iface rs FinalAllow\"", "lemma no_spoofing_algorithm_sound_generalized:\n  fixes rs1 :: \"'i::len common_primitive rule list\"\n  shows \"simple_ruleset rs1 \\<Longrightarrow> simple_ruleset rs2 \\<Longrightarrow>\n        (\\<forall>r \\<in> set rs2. normalized_nnf_match (get_match r)) \\<Longrightarrow>\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed \\<Longrightarrow>\n        denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<Longrightarrow>\n        no_spoofing_algorithm iface ipassmt rs2 allowed denied1 \\<Longrightarrow>\n        nospoof TYPE('pkt_ext) iface ipassmt (rs1@rs2)\"", "lemma[code]: \"no_spoofing_iface iface ipassmt rs = \n      no_spoofing_algorithm_executable iface ipassmt rs Empty_WordInterval Empty_WordInterval\"", "lemma nospoof: \"simple_ruleset rs \\<Longrightarrow> (\\<forall>iface \\<in> dom ipassmt. nospoof TYPE('pkt_ext) iface ipassmt rs) \\<longleftrightarrow> no_spoofing TYPE('pkt_ext) ipassmt rs\"", "theorem no_spoofing_iface: \"simple_ruleset rs \\<Longrightarrow> \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r) \\<Longrightarrow>\n        \\<forall>iface \\<in> dom ipassmt. no_spoofing_iface iface ipassmt rs  \\<Longrightarrow> no_spoofing TYPE('pkt_ext) ipassmt rs\"", "lemma \"no_spoofing_iface\n      (Iface ''eth0'') \n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (Match (IIface (Iface ''eth0'')))) action.Accept,\n           Rule MatchAny action.Drop]\"", "lemma \"no_spoofing TYPE('pkt_ext)\n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (Match (IIface (Iface ''eth0'')))) action.Accept,\n           Rule MatchAny action.Drop]\"", "lemma \"no_spoofing TYPE('pkt_ext)\n      [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n      [Rule (MatchAnd (Match (IIface (Iface ''wlan+''))) (Match (Extra ''no idea what this is''))) action.Accept, \\<comment> \\<open>not interesting for spoofing\\<close>\n       Rule (MatchNot (Match (IIface (Iface ''eth0+'')))) action.Accept, \\<comment> \\<open>not interesting for spoofing\\<close>\n       Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0'')))) action.Drop, \\<comment> \\<open>spoof-protect here\\<close>\n       Rule MatchAny action.Accept]\n          \"", "lemma \"\\<not> no_spoofing TYPE('pkt_ext)\n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) action.Accept, \\<comment> \\<open>accidently allow everything for eth0\\<close>\n           Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0'')))) action.Drop,\n           Rule MatchAny action.Accept]\n          \"", "lemma \"\\<not> no_spoofing_iface \n          (Iface ''eth0'') \n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) action.Accept, \\<comment> \\<open>accidently allow everything for eth0\\<close>\n           Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0'')))) action.Drop,\n           Rule MatchAny action.Accept]\n          \"", "lemma \"\\<not> no_spoofing TYPE('pkt_ext) [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (MatchNot (Match (IIface (Iface ''eth0''))))) action.Drop,\n           Rule MatchAny action.Accept]\"", "lemma \"\\<not> no_spoofing_iface \n          (Iface ''eth0'') \n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (MatchNot (Match (IIface (Iface ''eth0''))))) action.Drop,\n           Rule MatchAny action.Accept]\"", "lemma \"no_spoofing TYPE('pkt_ext) [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                          (Match (Prot (Proto TCP))))) action.Drop,\n           Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                          (MatchNot (Match (Prot (Proto TCP)))))) action.Drop,\n           Rule MatchAny action.Accept]\" (is \"no_spoofing TYPE('pkt_ext) ?ipassmt ?rs\")", "lemma \"\\<not> no_spoofing_iface\n          (Iface ''eth0'') \n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                (Match (Prot (Proto TCP))))) action.Drop,\n           Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                (MatchNot (Match (Prot (Proto TCP)))))) action.Drop,\n           Rule MatchAny action.Accept]\"", "lemma \"no_spoofing_iface (Iface ''eth1.1011'')\n                         ([Iface ''eth1.1011'' \\<mapsto> [(ipv4addr_of_dotdecimal (131,159,14,0), 24)]]:: 32 ipassignment)\n  [Rule (MatchNot (Match (IIface (Iface ''eth1.1011+'')))) action.Accept,\n   Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (131,159,14,0)) 24)))) (Match (IIface (Iface ''eth1.1011'')))) action.Drop,\n   Rule MatchAny action.Accept]\"", "lemma \"no_spoofing_iface (Iface ''eth1.1011'')\n                         ([Iface ''eth1.1011'' \\<mapsto> [(ipv4addr_of_dotdecimal (131,159,14,0), 24)]]:: 32 ipassignment)\n  [Rule (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8))) Drop]\""], "translations": [["", "lemma \"no_spoofing TYPE(unit) ipassmt rs \\<longleftrightarrow>\n    (\\<forall> iface \\<in> dom ipassmt. \\<forall>p :: 32 tagged_packet.\n      ((common_matcher, in_doubt_allow),p\\<lparr>p_iiface:=iface_sel iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow)\n         \\<longrightarrow> p_src p \\<in> (ipcidr_union_set (set (the (ipassmt iface)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing TYPE(unit) ipassmt rs =\n    (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           (common_matcher, in_doubt_allow),p\n           \\<lparr>p_iiface :=\n                     iface_sel\n                      iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface))))", "unfolding no_spoofing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           (common_matcher, in_doubt_allow),p\n           \\<lparr>p_iiface :=\n                     iface_sel\n                      iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))) =\n    (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           (common_matcher, in_doubt_allow),p\n           \\<lparr>p_iiface :=\n                     iface_sel\n                      iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface))))", "by blast"], ["", "text\\<open>The definition is sound (if that can be said about a definition):\n          if @{const no_spoofing} certifies your ruleset, then your ruleset prohibits spoofing.\n         The definition may not be complete:\n          @{const no_spoofing} may return @{const False} even though your ruleset prevents spoofing\n          (should only occur if some strange and unknown primitives occur)\\<close>"], ["", "text\\<open>Technical note: The definition can can be thought of as protection from OUTGOING spoofing.\n        OUTGOING means: I define my interfaces and their IP addresses. For all interfaces,\n                        only the assigned IP addresses may pass the firewall.\n                        This definition is simple for e.g. local sub-networks.\n                        Example: @{term \"[Iface ''eth0'' \\<mapsto> {(ipv4addr_of_dotdecimal (192,168,0,0), 24)}]\"}\n\n        If I want spoofing protection from the Internet, I need to specify the range of the Internet IP addresses.\n        Example: @{term \"[Iface ''evil_internet'' \\<mapsto> {everything_that_does_not_belong_to_me}]\"}.\n          This is also a good opportunity to exclude the private IP space, link local, and probably multicast space.\n        See @{const all_but_those_ips} to easily specify these ranges.\n\n        See examples below. Check Example 3 why it can be thought of as OUTGOING spoofing.\\<close>"], ["", "(*\nand now code to check spoofing protection\n*)"], ["", "context\nbegin"], ["", "text\\<open>The set of any ip addresses which may match for a fixed \\<open>iface\\<close> (overapproximation)\\<close>"], ["", "private"], ["", "definition get_exists_matching_src_ips :: \"iface \\<Rightarrow> 'i::len common_primitive match_expr \\<Rightarrow> 'i word set\" where\n    \"get_exists_matching_src_ips iface m \\<equiv> let (i_matches, _) = (primitive_extractor (is_Iiface, iiface_sel) m) in\n              if (\\<forall> is \\<in> set i_matches. (case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                                                  | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)))\n              then\n                (let (ip_matches, _) = (primitive_extractor (is_Src, src_sel) m) in\n                if ip_matches = []\n                then\n                  UNIV\n                else\n                  \\<Inter> ips \\<in> set (ip_matches). (case ips of Pos ip \\<Rightarrow> ipt_iprange_to_set ip | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip))\n              else\n                {}\""], ["", "(*when we replace the set by a 32 wordinterval, we should get executable code*)"], ["", "lemma \"primitive_extractor (is_Src, src_sel)\n      (MatchAnd (Match (Src (IpAddrNetmask (0::ipv4addr) 30))) (Match (IIface (Iface ''eth0'')))) =\n      ([Pos (IpAddrNetmask 0 30)], MatchAnd MatchAny (Match (IIface (Iface ''eth0''))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_extractor (is_Src, src_sel)\n     (MatchAnd (Match (Src (IpAddrNetmask 0 30)))\n       (Match (IIface (Iface ''eth0'')))) =\n    ([Pos (IpAddrNetmask 0 30)],\n     MatchAnd MatchAny (Match (IIface (Iface ''eth0''))))", "by eval"], ["", "private"], ["", "lemma get_exists_matching_src_ips_subset: \n    assumes \"normalized_nnf_match m\"\n    shows \"{ip. (\\<exists>p :: ('i::len, 'a) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m a (p\\<lparr>p_iiface:= iface_sel iface, p_src:= ip\\<rparr>))} \\<subseteq>\n           get_exists_matching_src_ips iface m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "let ?\\<gamma>=\"(common_matcher, in_doubt_allow)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "fix ip_matches rest src_ip i_matches rest2 and p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (state)\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "assume a1: \"primitive_extractor (is_Src, src_sel) m = (ip_matches, rest)\"\n      and a2: \"matches ?\\<gamma> m a (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\""], ["proof (state)\nthis:\n  primitive_extractor (is_Src, src_sel) m = (ip_matches, rest)\n  matches (common_matcher, in_doubt_allow) m a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "let ?p=\"(p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "from primitive_extractor_negation_type_matching1[OF wf_disc_sel_common_primitive(3) assms a1 a2]\n           match_simplematcher_SrcDst[where p = ?p] match_simplematcher_SrcDst_not[where p=\"?p\"]"], ["proof (chain)\npicking this:\n  (\\<forall>m\\<in>set (map Src (getPos ip_matches)).\n      matches (common_matcher, in_doubt_allow) (Match m) a\n       (p\\<lparr>p_iiface := iface_sel iface,\n            p_src := src_ip\\<rparr>)) \\<and>\n  (\\<forall>m\\<in>set (map Src (getNeg ip_matches)).\n      matches (common_matcher, in_doubt_allow) (MatchNot (Match m)) a\n       (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>))\n  matches (common_matcher, ?\\<alpha>) (Match (Src ?X)) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n   \\<in> ipt_iprange_to_set ?X)\n  matches (common_matcher, ?\\<alpha>) (Match (Dst ?X)) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (p_dst (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n   \\<in> ipt_iprange_to_set ?X)\n  matches (common_matcher, ?\\<alpha>) (MatchNot (Match (Src ?X))) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n   \\<notin> ipt_iprange_to_set ?X)\n  matches (common_matcher, ?\\<alpha>) (MatchNot (Match (Dst ?X))) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (p_dst (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n   \\<notin> ipt_iprange_to_set ?X)", "have ip_matches: \"(\\<forall>ip\\<in>set (getPos ip_matches). p_src ?p \\<in> ipt_iprange_to_set ip) \\<and>\n                         (\\<forall>ip\\<in>set (getNeg ip_matches). p_src ?p \\<in> - ipt_iprange_to_set ip)\""], ["proof (prove)\nusing this:\n  (\\<forall>m\\<in>set (map Src (getPos ip_matches)).\n      matches (common_matcher, in_doubt_allow) (Match m) a\n       (p\\<lparr>p_iiface := iface_sel iface,\n            p_src := src_ip\\<rparr>)) \\<and>\n  (\\<forall>m\\<in>set (map Src (getNeg ip_matches)).\n      matches (common_matcher, in_doubt_allow) (MatchNot (Match m)) a\n       (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>))\n  matches (common_matcher, ?\\<alpha>) (Match (Src ?X)) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n   \\<in> ipt_iprange_to_set ?X)\n  matches (common_matcher, ?\\<alpha>) (Match (Dst ?X)) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (p_dst (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n   \\<in> ipt_iprange_to_set ?X)\n  matches (common_matcher, ?\\<alpha>) (MatchNot (Match (Src ?X))) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n   \\<notin> ipt_iprange_to_set ?X)\n  matches (common_matcher, ?\\<alpha>) (MatchNot (Match (Dst ?X))) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (p_dst (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n   \\<notin> ipt_iprange_to_set ?X)\n\ngoal (1 subgoal):\n 1. (\\<forall>ip\\<in>set (getPos ip_matches).\n        p_src\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n        \\<in> ipt_iprange_to_set ip) \\<and>\n    (\\<forall>ip\\<in>set (getNeg ip_matches).\n        p_src\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n        \\<in> - ipt_iprange_to_set ip)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>ip\\<in>set (getPos ip_matches).\n      p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n      \\<in> ipt_iprange_to_set ip) \\<and>\n  (\\<forall>ip\\<in>set (getNeg ip_matches).\n      p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n      \\<in> - ipt_iprange_to_set ip)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "from ip_matches"], ["proof (chain)\npicking this:\n  (\\<forall>ip\\<in>set (getPos ip_matches).\n      p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n      \\<in> ipt_iprange_to_set ip) \\<and>\n  (\\<forall>ip\\<in>set (getNeg ip_matches).\n      p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n      \\<in> - ipt_iprange_to_set ip)", "have \"\\<forall>x \\<in> set ip_matches. src_ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\""], ["proof (prove)\nusing this:\n  (\\<forall>ip\\<in>set (getPos ip_matches).\n      p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n      \\<in> ipt_iprange_to_set ip) \\<and>\n  (\\<forall>ip\\<in>set (getNeg ip_matches).\n      p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n      \\<in> - ipt_iprange_to_set ip)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set ip_matches.\n       src_ip\n       \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n              | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ip\\<in>set (getPos ip_matches).\n        src_ip \\<in> ipt_iprange_to_set ip) \\<and>\n    (\\<forall>ip\\<in>set (getNeg ip_matches).\n        src_ip \\<notin> ipt_iprange_to_set ip) \\<Longrightarrow>\n    \\<forall>x\\<in>set ip_matches.\n       src_ip\n       \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n              | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)", "apply(simp  split: negation_type.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ip\\<in>set (getPos ip_matches).\n        src_ip \\<in> ipt_iprange_to_set ip) \\<and>\n    (\\<forall>ip\\<in>set (getNeg ip_matches).\n        src_ip \\<notin> ipt_iprange_to_set ip) \\<Longrightarrow>\n    \\<forall>x\\<in>set ip_matches.\n       (\\<forall>x1.\n           x = Pos x1 \\<longrightarrow>\n           src_ip \\<in> ipt_iprange_to_set x1) \\<and>\n       (\\<forall>x2.\n           x = Neg x2 \\<longrightarrow>\n           src_ip \\<notin> ipt_iprange_to_set x2)", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>Pos x1 \\<in> set ip_matches;\n        \\<forall>ip\\<in>set (getPos ip_matches).\n           src_ip \\<in> ipt_iprange_to_set ip;\n        \\<forall>ip\\<in>set (getNeg ip_matches).\n           src_ip \\<notin> ipt_iprange_to_set ip\\<rbrakk>\n       \\<Longrightarrow> src_ip \\<in> ipt_iprange_to_set x1\n 2. \\<And>x x2.\n       \\<lbrakk>Neg x2 \\<in> set ip_matches;\n        \\<forall>ip\\<in>set (getPos ip_matches).\n           src_ip \\<in> ipt_iprange_to_set ip;\n        \\<forall>ip\\<in>set (getNeg ip_matches).\n           src_ip \\<notin> ipt_iprange_to_set ip;\n        src_ip \\<in> ipt_iprange_to_set x2\\<rbrakk>\n       \\<Longrightarrow> False", "using NegPos_set"], ["proof (prove)\nusing this:\n  (Pos ?a \\<in> set ?x) = (?a \\<in> set (getPos ?x))\n  (Neg ?a \\<in> set ?x) = (?a \\<in> set (getNeg ?x))\n  (set ?x \\<subseteq> set ?x') =\n  (set (getPos ?x) \\<subseteq> set (getPos ?x') \\<and>\n   set (getNeg ?x) \\<subseteq> set (getNeg ?x'))\n  Pos ` set (getPos ?x) \\<subseteq> set ?x\n  Neg ` set (getNeg ?x) \\<subseteq> set ?x\n\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>Pos x1 \\<in> set ip_matches;\n        \\<forall>ip\\<in>set (getPos ip_matches).\n           src_ip \\<in> ipt_iprange_to_set ip;\n        \\<forall>ip\\<in>set (getNeg ip_matches).\n           src_ip \\<notin> ipt_iprange_to_set ip\\<rbrakk>\n       \\<Longrightarrow> src_ip \\<in> ipt_iprange_to_set x1\n 2. \\<And>x x2.\n       \\<lbrakk>Neg x2 \\<in> set ip_matches;\n        \\<forall>ip\\<in>set (getPos ip_matches).\n           src_ip \\<in> ipt_iprange_to_set ip;\n        \\<forall>ip\\<in>set (getNeg ip_matches).\n           src_ip \\<notin> ipt_iprange_to_set ip;\n        src_ip \\<in> ipt_iprange_to_set x2\\<rbrakk>\n       \\<Longrightarrow> False", "apply fast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ip_matches.\n     src_ip\n     \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n            | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "}"], ["proof (state)\nthis:\n  \\<lbrakk>primitive_extractor (is_Src, src_sel) m = (?ip_matches3, ?rest3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?ip_matches3.\n                       ?src_ip3\n                       \\<in> (case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "note 1=this"], ["proof (state)\nthis:\n  \\<lbrakk>primitive_extractor (is_Src, src_sel) m = (?ip_matches3, ?rest3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?ip_matches3.\n                       ?src_ip3\n                       \\<in> (case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "{"], ["proof (state)\nthis:\n  \\<lbrakk>primitive_extractor (is_Src, src_sel) m = (?ip_matches3, ?rest3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?ip_matches3.\n                       ?src_ip3\n                       \\<in> (case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "fix ip_matches rest src_ip i_matches rest2 and p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (state)\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "assume a1: \"primitive_extractor (is_Iiface, iiface_sel) m = (i_matches, rest2)\"\n         and a2: \"matches ?\\<gamma> m a (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\""], ["proof (state)\nthis:\n  primitive_extractor (is_Iiface, iiface_sel) m = (i_matches, rest2)\n  matches (common_matcher, in_doubt_allow) m a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "let ?p=\"(p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "from primitive_extractor_negation_type_matching1[OF wf_disc_sel_common_primitive(5) assms a1 a2]\n           primitive_matcher_generic.Iface_single[OF primitive_matcher_generic_common_matcher, where p = ?p]\n           primitive_matcher_generic.Iface_single_not[OF primitive_matcher_generic_common_matcher, where p = ?p]"], ["proof (chain)\npicking this:\n  (\\<forall>m\\<in>set (map IIface (getPos i_matches)).\n      matches (common_matcher, in_doubt_allow) (Match m) a\n       (p\\<lparr>p_iiface := iface_sel iface,\n            p_src := src_ip\\<rparr>)) \\<and>\n  (\\<forall>m\\<in>set (map IIface (getNeg i_matches)).\n      matches (common_matcher, in_doubt_allow) (MatchNot (Match m)) a\n       (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>))\n  matches (common_matcher, ?\\<alpha>) (Match (IIface ?X)) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  match_iface ?X\n   (p_iiface\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>))\n  matches (common_matcher, ?\\<alpha>) (Match (OIface ?X)) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  match_iface ?X\n   (p_oiface\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>))\n  matches (common_matcher, ?\\<alpha>) (MatchNot (Match (IIface ?X))) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (\\<not> match_iface ?X\n           (p_iiface\n             (p\\<lparr>p_iiface := iface_sel iface,\n                  p_src := src_ip\\<rparr>)))\n  matches (common_matcher, ?\\<alpha>) (MatchNot (Match (OIface ?X))) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (\\<not> match_iface ?X\n           (p_oiface\n             (p\\<lparr>p_iiface := iface_sel iface,\n                  p_src := src_ip\\<rparr>)))", "have iface_matches: \"(\\<forall>i\\<in>set (getPos i_matches). match_iface i (p_iiface ?p)) \\<and>\n                           (\\<forall>i\\<in>set (getNeg i_matches). \\<not> match_iface i (p_iiface ?p))\""], ["proof (prove)\nusing this:\n  (\\<forall>m\\<in>set (map IIface (getPos i_matches)).\n      matches (common_matcher, in_doubt_allow) (Match m) a\n       (p\\<lparr>p_iiface := iface_sel iface,\n            p_src := src_ip\\<rparr>)) \\<and>\n  (\\<forall>m\\<in>set (map IIface (getNeg i_matches)).\n      matches (common_matcher, in_doubt_allow) (MatchNot (Match m)) a\n       (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>))\n  matches (common_matcher, ?\\<alpha>) (Match (IIface ?X)) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  match_iface ?X\n   (p_iiface\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>))\n  matches (common_matcher, ?\\<alpha>) (Match (OIface ?X)) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  match_iface ?X\n   (p_oiface\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>))\n  matches (common_matcher, ?\\<alpha>) (MatchNot (Match (IIface ?X))) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (\\<not> match_iface ?X\n           (p_iiface\n             (p\\<lparr>p_iiface := iface_sel iface,\n                  p_src := src_ip\\<rparr>)))\n  matches (common_matcher, ?\\<alpha>) (MatchNot (Match (OIface ?X))) ?a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := src_ip\\<rparr>) =\n  (\\<not> match_iface ?X\n           (p_oiface\n             (p\\<lparr>p_iiface := iface_sel iface,\n                  p_src := src_ip\\<rparr>)))\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>set (getPos i_matches).\n        match_iface i\n         (p_iiface\n           (p\\<lparr>p_iiface := iface_sel iface,\n                p_src := src_ip\\<rparr>))) \\<and>\n    (\\<forall>i\\<in>set (getNeg i_matches).\n        \\<not> match_iface i\n                (p_iiface\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := src_ip\\<rparr>)))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>set (getPos i_matches).\n      match_iface i\n       (p_iiface\n         (p\\<lparr>p_iiface := iface_sel iface,\n              p_src := src_ip\\<rparr>))) \\<and>\n  (\\<forall>i\\<in>set (getNeg i_matches).\n      \\<not> match_iface i\n              (p_iiface\n                (p\\<lparr>p_iiface := iface_sel iface,\n                     p_src := src_ip\\<rparr>)))\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "hence 2: \"(\\<forall>x\\<in>set i_matches. case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface) | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface))\""], ["proof (prove)\nusing this:\n  (\\<forall>i\\<in>set (getPos i_matches).\n      match_iface i\n       (p_iiface\n         (p\\<lparr>p_iiface := iface_sel iface,\n              p_src := src_ip\\<rparr>))) \\<and>\n  (\\<forall>i\\<in>set (getNeg i_matches).\n      \\<not> match_iface i\n              (p_iiface\n                (p\\<lparr>p_iiface := iface_sel iface,\n                     p_src := src_ip\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set i_matches.\n       case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)", "apply(simp add: split: negation_type.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>set (getPos i_matches).\n        match_iface i (iface_sel iface)) \\<and>\n    (\\<forall>i\\<in>set (getNeg i_matches).\n        \\<not> match_iface i (iface_sel iface)) \\<Longrightarrow>\n    \\<forall>x\\<in>set i_matches.\n       (\\<forall>x1.\n           x = Pos x1 \\<longrightarrow>\n           match_iface x1 (iface_sel iface)) \\<and>\n       (\\<forall>x2.\n           x = Neg x2 \\<longrightarrow>\n           \\<not> match_iface x2 (iface_sel iface))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>Pos x1 \\<in> set i_matches;\n        \\<forall>i\\<in>set (getPos i_matches).\n           match_iface i (iface_sel iface);\n        \\<forall>i\\<in>set (getNeg i_matches).\n           \\<not> match_iface i (iface_sel iface)\\<rbrakk>\n       \\<Longrightarrow> match_iface x1 (iface_sel iface)\n 2. \\<And>x x2.\n       \\<lbrakk>Neg x2 \\<in> set i_matches;\n        \\<forall>i\\<in>set (getPos i_matches).\n           match_iface i (iface_sel iface);\n        \\<forall>i\\<in>set (getNeg i_matches).\n           \\<not> match_iface i (iface_sel iface);\n        match_iface x2 (iface_sel iface)\\<rbrakk>\n       \\<Longrightarrow> False", "using NegPos_set"], ["proof (prove)\nusing this:\n  (Pos ?a \\<in> set ?x) = (?a \\<in> set (getPos ?x))\n  (Neg ?a \\<in> set ?x) = (?a \\<in> set (getNeg ?x))\n  (set ?x \\<subseteq> set ?x') =\n  (set (getPos ?x) \\<subseteq> set (getPos ?x') \\<and>\n   set (getNeg ?x) \\<subseteq> set (getNeg ?x'))\n  Pos ` set (getPos ?x) \\<subseteq> set ?x\n  Neg ` set (getNeg ?x) \\<subseteq> set ?x\n\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>Pos x1 \\<in> set i_matches;\n        \\<forall>i\\<in>set (getPos i_matches).\n           match_iface i (iface_sel iface);\n        \\<forall>i\\<in>set (getNeg i_matches).\n           \\<not> match_iface i (iface_sel iface)\\<rbrakk>\n       \\<Longrightarrow> match_iface x1 (iface_sel iface)\n 2. \\<And>x x2.\n       \\<lbrakk>Neg x2 \\<in> set i_matches;\n        \\<forall>i\\<in>set (getPos i_matches).\n           match_iface i (iface_sel iface);\n        \\<forall>i\\<in>set (getNeg i_matches).\n           \\<not> match_iface i (iface_sel iface);\n        match_iface x2 (iface_sel iface)\\<rbrakk>\n       \\<Longrightarrow> False", "apply fast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set i_matches.\n     case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n     | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "}"], ["proof (state)\nthis:\n  \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n           (?i_matches3, ?rest2.3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?i_matches3.\n                       case x of\n                       Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                       | Neg i \\<Rightarrow>\n                           \\<not> match_iface i (iface_sel iface)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "note 2=this"], ["proof (state)\nthis:\n  \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n           (?i_matches3, ?rest2.3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?i_matches3.\n                       case x of\n                       Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                       | Neg i \\<Rightarrow>\n                           \\<not> match_iface i (iface_sel iface)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "from 1 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>primitive_extractor (is_Src, src_sel) m = (?ip_matches3, ?rest3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?ip_matches3.\n                       ?src_ip3\n                       \\<in> (case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)\n  \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n           (?i_matches3, ?rest2.3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?i_matches3.\n                       case x of\n                       Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                       | Neg i \\<Rightarrow>\n                           \\<not> match_iface i (iface_sel iface)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>primitive_extractor (is_Src, src_sel) m = (?ip_matches3, ?rest3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?ip_matches3.\n                       ?src_ip3\n                       \\<in> (case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)\n  \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n           (?i_matches3, ?rest2.3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?i_matches3.\n                       case x of\n                       Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                       | Neg i \\<Rightarrow>\n                           \\<not> match_iface i (iface_sel iface)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> get_exists_matching_src_ips iface m", "unfolding get_exists_matching_src_ips_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>primitive_extractor (is_Src, src_sel) m = (?ip_matches3, ?rest3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?ip_matches3.\n                       ?src_ip3\n                       \\<in> (case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)\n  \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n           (?i_matches3, ?rest2.3);\n   matches (common_matcher, in_doubt_allow) m a\n    (?p3\\<lparr>p_iiface := iface_sel iface,\n           p_src := ?src_ip3\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?i_matches3.\n                       case x of\n                       Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                       | Neg i \\<Rightarrow>\n                           \\<not> match_iface i (iface_sel iface)\n\ngoal (1 subgoal):\n 1. {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> (let (i_matches, uu_) =\n                       primitive_extractor (is_Iiface, iiface_sel) m\n                 in if \\<forall>is\\<in>set i_matches.\n                          case is of\n                          Pos i \\<Rightarrow>\n                            match_iface i (iface_sel iface)\n                          | Neg i \\<Rightarrow>\n                              \\<not> match_iface i (iface_sel iface)\n                    then let (ip_matches, uu_) =\n                               primitive_extractor (is_Src, src_sel) m\n                         in if ip_matches = [] then UNIV\n                            else \\<Inter>ips\\<in>set ip_matches.\n                                    case ips of\n                                    Pos ip \\<Rightarrow>\nipt_iprange_to_set ip\n                                    | Neg ip \\<Rightarrow>\n  - ipt_iprange_to_set ip\n                    else {})", "by(clarsimp)"], ["proof (state)\nthis:\n  {ip.\n   \\<exists>p.\n      matches (common_matcher, in_doubt_allow) m a\n       (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n  \\<subseteq> get_exists_matching_src_ips iface m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma common_primitive_not_has_primitive_expand: \n        \"\\<not> has_primitive (m::'i::len common_primitive match_expr) \\<longleftrightarrow>\n         \\<not> has_disc is_Dst m \\<and> \n         \\<not> has_disc is_Src m \\<and>\n         \\<not> has_disc is_Iiface m \\<and>\n         \\<not> has_disc is_Oiface m \\<and>\n         \\<not> has_disc is_Prot m \\<and>\n         \\<not> has_disc is_Src_Ports m \\<and>\n         \\<not> has_disc is_Dst_Ports m \\<and>\n         \\<not> has_disc is_MultiportPorts m \\<and>\n         \\<not> has_disc is_L4_Flags m \\<and>\n         \\<not> has_disc is_CT_State m \\<and>\n         \\<not> has_disc is_Extra m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> has_primitive m) =\n    (\\<not> has_disc is_Dst m \\<and>\n     \\<not> has_disc is_Src m \\<and>\n     \\<not> has_disc is_Iiface m \\<and>\n     \\<not> has_disc is_Oiface m \\<and>\n     \\<not> has_disc is_Prot m \\<and>\n     \\<not> has_disc is_Src_Ports m \\<and>\n     \\<not> has_disc is_Dst_Ports m \\<and>\n     \\<not> has_disc is_MultiportPorts m \\<and>\n     \\<not> has_disc is_L4_Flags m \\<and>\n     \\<not> has_disc is_CT_State m \\<and> \\<not> has_disc is_Extra m)", "apply(induction m)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       (\\<not> has_primitive (Match x)) =\n       (\\<not> has_disc is_Dst (Match x) \\<and>\n        \\<not> has_disc is_Src (Match x) \\<and>\n        \\<not> has_disc is_Iiface (Match x) \\<and>\n        \\<not> has_disc is_Oiface (Match x) \\<and>\n        \\<not> has_disc is_Prot (Match x) \\<and>\n        \\<not> has_disc is_Src_Ports (Match x) \\<and>\n        \\<not> has_disc is_Dst_Ports (Match x) \\<and>\n        \\<not> has_disc is_MultiportPorts (Match x) \\<and>\n        \\<not> has_disc is_L4_Flags (Match x) \\<and>\n        \\<not> has_disc is_CT_State (Match x) \\<and>\n        \\<not> has_disc is_Extra (Match x))\n 2. \\<And>m.\n       (\\<not> has_primitive m) =\n       (\\<not> has_disc is_Dst m \\<and>\n        \\<not> has_disc is_Src m \\<and>\n        \\<not> has_disc is_Iiface m \\<and>\n        \\<not> has_disc is_Oiface m \\<and>\n        \\<not> has_disc is_Prot m \\<and>\n        \\<not> has_disc is_Src_Ports m \\<and>\n        \\<not> has_disc is_Dst_Ports m \\<and>\n        \\<not> has_disc is_MultiportPorts m \\<and>\n        \\<not> has_disc is_L4_Flags m \\<and>\n        \\<not> has_disc is_CT_State m \\<and>\n        \\<not> has_disc is_Extra m) \\<Longrightarrow>\n       (\\<not> has_primitive (MatchNot m)) =\n       (\\<not> has_disc is_Dst (MatchNot m) \\<and>\n        \\<not> has_disc is_Src (MatchNot m) \\<and>\n        \\<not> has_disc is_Iiface (MatchNot m) \\<and>\n        \\<not> has_disc is_Oiface (MatchNot m) \\<and>\n        \\<not> has_disc is_Prot (MatchNot m) \\<and>\n        \\<not> has_disc is_Src_Ports (MatchNot m) \\<and>\n        \\<not> has_disc is_Dst_Ports (MatchNot m) \\<and>\n        \\<not> has_disc is_MultiportPorts (MatchNot m) \\<and>\n        \\<not> has_disc is_L4_Flags (MatchNot m) \\<and>\n        \\<not> has_disc is_CT_State (MatchNot m) \\<and>\n        \\<not> has_disc is_Extra (MatchNot m))\n 3. \\<And>m1 m2.\n       \\<lbrakk>(\\<not> has_primitive m1) =\n                (\\<not> has_disc is_Dst m1 \\<and>\n                 \\<not> has_disc is_Src m1 \\<and>\n                 \\<not> has_disc is_Iiface m1 \\<and>\n                 \\<not> has_disc is_Oiface m1 \\<and>\n                 \\<not> has_disc is_Prot m1 \\<and>\n                 \\<not> has_disc is_Src_Ports m1 \\<and>\n                 \\<not> has_disc is_Dst_Ports m1 \\<and>\n                 \\<not> has_disc is_MultiportPorts m1 \\<and>\n                 \\<not> has_disc is_L4_Flags m1 \\<and>\n                 \\<not> has_disc is_CT_State m1 \\<and>\n                 \\<not> has_disc is_Extra m1);\n        (\\<not> has_primitive m2) =\n        (\\<not> has_disc is_Dst m2 \\<and>\n         \\<not> has_disc is_Src m2 \\<and>\n         \\<not> has_disc is_Iiface m2 \\<and>\n         \\<not> has_disc is_Oiface m2 \\<and>\n         \\<not> has_disc is_Prot m2 \\<and>\n         \\<not> has_disc is_Src_Ports m2 \\<and>\n         \\<not> has_disc is_Dst_Ports m2 \\<and>\n         \\<not> has_disc is_MultiportPorts m2 \\<and>\n         \\<not> has_disc is_L4_Flags m2 \\<and>\n         \\<not> has_disc is_CT_State m2 \\<and>\n         \\<not> has_disc is_Extra m2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_primitive (MatchAnd m1 m2)) =\n                         (\\<not> has_disc is_Dst (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_Src (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_Iiface (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_Oiface (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_Prot (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_Src_Ports\n                                  (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_Dst_Ports\n                                  (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_MultiportPorts\n                                  (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_L4_Flags\n                                  (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_CT_State\n                                  (MatchAnd m1 m2) \\<and>\n                          \\<not> has_disc is_Extra (MatchAnd m1 m2))\n 4. (\\<not> has_primitive MatchAny) =\n    (\\<not> has_disc is_Dst MatchAny \\<and>\n     \\<not> has_disc is_Src MatchAny \\<and>\n     \\<not> has_disc is_Iiface MatchAny \\<and>\n     \\<not> has_disc is_Oiface MatchAny \\<and>\n     \\<not> has_disc is_Prot MatchAny \\<and>\n     \\<not> has_disc is_Src_Ports MatchAny \\<and>\n     \\<not> has_disc is_Dst_Ports MatchAny \\<and>\n     \\<not> has_disc is_MultiportPorts MatchAny \\<and>\n     \\<not> has_disc is_L4_Flags MatchAny \\<and>\n     \\<not> has_disc is_CT_State MatchAny \\<and>\n     \\<not> has_disc is_Extra MatchAny)", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_Dst x \\<or>\n       is_Src x \\<or>\n       is_Iiface x \\<or>\n       is_Oiface x \\<or>\n       is_Prot x \\<or>\n       is_Src_Ports x \\<or>\n       is_Dst_Ports x \\<or>\n       is_MultiportPorts x \\<or>\n       is_L4_Flags x \\<or> is_CT_State x \\<or> is_Extra x\n 2. \\<And>m1 m2.\n       \\<lbrakk>(\\<not> has_primitive m1) =\n                (\\<not> has_disc is_Dst m1 \\<and>\n                 \\<not> has_disc is_Src m1 \\<and>\n                 \\<not> has_disc is_Iiface m1 \\<and>\n                 \\<not> has_disc is_Oiface m1 \\<and>\n                 \\<not> has_disc is_Prot m1 \\<and>\n                 \\<not> has_disc is_Src_Ports m1 \\<and>\n                 \\<not> has_disc is_Dst_Ports m1 \\<and>\n                 \\<not> has_disc is_MultiportPorts m1 \\<and>\n                 \\<not> has_disc is_L4_Flags m1 \\<and>\n                 \\<not> has_disc is_CT_State m1 \\<and>\n                 \\<not> has_disc is_Extra m1);\n        (\\<not> has_primitive m2) =\n        (\\<not> has_disc is_Dst m2 \\<and>\n         \\<not> has_disc is_Src m2 \\<and>\n         \\<not> has_disc is_Iiface m2 \\<and>\n         \\<not> has_disc is_Oiface m2 \\<and>\n         \\<not> has_disc is_Prot m2 \\<and>\n         \\<not> has_disc is_Src_Ports m2 \\<and>\n         \\<not> has_disc is_Dst_Ports m2 \\<and>\n         \\<not> has_disc is_MultiportPorts m2 \\<and>\n         \\<not> has_disc is_L4_Flags m2 \\<and>\n         \\<not> has_disc is_CT_State m2 \\<and>\n         \\<not> has_disc is_Extra m2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc is_Dst m1 \\<and>\n                          \\<not> has_disc is_Src m1 \\<and>\n                          \\<not> has_disc is_Iiface m1 \\<and>\n                          \\<not> has_disc is_Oiface m1 \\<and>\n                          \\<not> has_disc is_Prot m1 \\<and>\n                          \\<not> has_disc is_Src_Ports m1 \\<and>\n                          \\<not> has_disc is_Dst_Ports m1 \\<and>\n                          \\<not> has_disc is_MultiportPorts m1 \\<and>\n                          \\<not> has_disc is_L4_Flags m1 \\<and>\n                          \\<not> has_disc is_CT_State m1 \\<and>\n                          \\<not> has_disc is_Extra m1 \\<and>\n                          \\<not> has_disc is_Dst m2 \\<and>\n                          \\<not> has_disc is_Src m2 \\<and>\n                          \\<not> has_disc is_Iiface m2 \\<and>\n                          \\<not> has_disc is_Oiface m2 \\<and>\n                          \\<not> has_disc is_Prot m2 \\<and>\n                          \\<not> has_disc is_Src_Ports m2 \\<and>\n                          \\<not> has_disc is_Dst_Ports m2 \\<and>\n                          \\<not> has_disc is_MultiportPorts m2 \\<and>\n                          \\<not> has_disc is_L4_Flags m2 \\<and>\n                          \\<not> has_disc is_CT_State m2 \\<and>\n                          \\<not> has_disc is_Extra m2) =\n                         (\\<not> has_disc is_Dst m1 \\<and>\n                          \\<not> has_disc is_Dst m2 \\<and>\n                          \\<not> has_disc is_Src m1 \\<and>\n                          \\<not> has_disc is_Src m2 \\<and>\n                          \\<not> has_disc is_Iiface m1 \\<and>\n                          \\<not> has_disc is_Iiface m2 \\<and>\n                          \\<not> has_disc is_Oiface m1 \\<and>\n                          \\<not> has_disc is_Oiface m2 \\<and>\n                          \\<not> has_disc is_Prot m1 \\<and>\n                          \\<not> has_disc is_Prot m2 \\<and>\n                          \\<not> has_disc is_Src_Ports m1 \\<and>\n                          \\<not> has_disc is_Src_Ports m2 \\<and>\n                          \\<not> has_disc is_Dst_Ports m1 \\<and>\n                          \\<not> has_disc is_Dst_Ports m2 \\<and>\n                          \\<not> has_disc is_MultiportPorts m1 \\<and>\n                          \\<not> has_disc is_MultiportPorts m2 \\<and>\n                          \\<not> has_disc is_L4_Flags m1 \\<and>\n                          \\<not> has_disc is_L4_Flags m2 \\<and>\n                          \\<not> has_disc is_CT_State m1 \\<and>\n                          \\<not> has_disc is_CT_State m2 \\<and>\n                          \\<not> has_disc is_Extra m1 \\<and>\n                          \\<not> has_disc is_Extra m2)", "apply(rename_tac x, case_tac x, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m1 m2.\n       \\<lbrakk>(\\<not> has_primitive m1) =\n                (\\<not> has_disc is_Dst m1 \\<and>\n                 \\<not> has_disc is_Src m1 \\<and>\n                 \\<not> has_disc is_Iiface m1 \\<and>\n                 \\<not> has_disc is_Oiface m1 \\<and>\n                 \\<not> has_disc is_Prot m1 \\<and>\n                 \\<not> has_disc is_Src_Ports m1 \\<and>\n                 \\<not> has_disc is_Dst_Ports m1 \\<and>\n                 \\<not> has_disc is_MultiportPorts m1 \\<and>\n                 \\<not> has_disc is_L4_Flags m1 \\<and>\n                 \\<not> has_disc is_CT_State m1 \\<and>\n                 \\<not> has_disc is_Extra m1);\n        (\\<not> has_primitive m2) =\n        (\\<not> has_disc is_Dst m2 \\<and>\n         \\<not> has_disc is_Src m2 \\<and>\n         \\<not> has_disc is_Iiface m2 \\<and>\n         \\<not> has_disc is_Oiface m2 \\<and>\n         \\<not> has_disc is_Prot m2 \\<and>\n         \\<not> has_disc is_Src_Ports m2 \\<and>\n         \\<not> has_disc is_Dst_Ports m2 \\<and>\n         \\<not> has_disc is_MultiportPorts m2 \\<and>\n         \\<not> has_disc is_L4_Flags m2 \\<and>\n         \\<not> has_disc is_CT_State m2 \\<and>\n         \\<not> has_disc is_Extra m2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> has_disc is_Dst m1 \\<and>\n                          \\<not> has_disc is_Src m1 \\<and>\n                          \\<not> has_disc is_Iiface m1 \\<and>\n                          \\<not> has_disc is_Oiface m1 \\<and>\n                          \\<not> has_disc is_Prot m1 \\<and>\n                          \\<not> has_disc is_Src_Ports m1 \\<and>\n                          \\<not> has_disc is_Dst_Ports m1 \\<and>\n                          \\<not> has_disc is_MultiportPorts m1 \\<and>\n                          \\<not> has_disc is_L4_Flags m1 \\<and>\n                          \\<not> has_disc is_CT_State m1 \\<and>\n                          \\<not> has_disc is_Extra m1 \\<and>\n                          \\<not> has_disc is_Dst m2 \\<and>\n                          \\<not> has_disc is_Src m2 \\<and>\n                          \\<not> has_disc is_Iiface m2 \\<and>\n                          \\<not> has_disc is_Oiface m2 \\<and>\n                          \\<not> has_disc is_Prot m2 \\<and>\n                          \\<not> has_disc is_Src_Ports m2 \\<and>\n                          \\<not> has_disc is_Dst_Ports m2 \\<and>\n                          \\<not> has_disc is_MultiportPorts m2 \\<and>\n                          \\<not> has_disc is_L4_Flags m2 \\<and>\n                          \\<not> has_disc is_CT_State m2 \\<and>\n                          \\<not> has_disc is_Extra m2) =\n                         (\\<not> has_disc is_Dst m1 \\<and>\n                          \\<not> has_disc is_Dst m2 \\<and>\n                          \\<not> has_disc is_Src m1 \\<and>\n                          \\<not> has_disc is_Src m2 \\<and>\n                          \\<not> has_disc is_Iiface m1 \\<and>\n                          \\<not> has_disc is_Iiface m2 \\<and>\n                          \\<not> has_disc is_Oiface m1 \\<and>\n                          \\<not> has_disc is_Oiface m2 \\<and>\n                          \\<not> has_disc is_Prot m1 \\<and>\n                          \\<not> has_disc is_Prot m2 \\<and>\n                          \\<not> has_disc is_Src_Ports m1 \\<and>\n                          \\<not> has_disc is_Src_Ports m2 \\<and>\n                          \\<not> has_disc is_Dst_Ports m1 \\<and>\n                          \\<not> has_disc is_Dst_Ports m2 \\<and>\n                          \\<not> has_disc is_MultiportPorts m1 \\<and>\n                          \\<not> has_disc is_MultiportPorts m2 \\<and>\n                          \\<not> has_disc is_L4_Flags m1 \\<and>\n                          \\<not> has_disc is_L4_Flags m2 \\<and>\n                          \\<not> has_disc is_CT_State m1 \\<and>\n                          \\<not> has_disc is_CT_State m2 \\<and>\n                          \\<not> has_disc is_Extra m1 \\<and>\n                          \\<not> has_disc is_Extra m2)", "by blast"], ["", "(*matcheq_matchAny is undefined for primitives. this is the proper way to call it!*)"], ["", "lemma \"\\<not> has_primitive m \\<and> matcheq_matchAny m \\<longleftrightarrow> (if \\<not> has_primitive m then matcheq_matchAny m else False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> has_primitive m \\<and> matcheq_matchAny m) =\n    (if \\<not> has_primitive m then matcheq_matchAny m else False)", "by simp"], ["", "text\\<open>The set of ip addresses which definitely match for a fixed \\<open>iface\\<close> (underapproximation)\\<close>"], ["", "private"], ["", "definition get_all_matching_src_ips :: \"iface \\<Rightarrow> 'i::len common_primitive match_expr \\<Rightarrow> 'i word set\" where\n    \"get_all_matching_src_ips iface m \\<equiv> let (i_matches, rest1) = (primitive_extractor (is_Iiface, iiface_sel) m) in\n              if (\\<forall> is \\<in> set i_matches. (case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                                                  | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)))\n              then\n                (let (ip_matches, rest2) = (primitive_extractor (is_Src, src_sel) rest1) in\n                if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n                then\n                  if ip_matches = []\n                  then\n                    UNIV\n                  else\n                    \\<Inter> ips \\<in> set (ip_matches). (case ips of Pos ip \\<Rightarrow> ipt_iprange_to_set ip | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\n                else\n                  {})\n              else\n                {}\""], ["", "private"], ["", "lemma get_all_matching_src_ips: \n    assumes \"normalized_nnf_match m\"\n    shows \"get_all_matching_src_ips iface m \\<subseteq>\n            {ip. (\\<forall>p::('i::len, 'a) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m a (p\\<lparr>p_iiface:= iface_sel iface, p_src:= ip\\<rparr>))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_all_matching_src_ips iface m\n    \\<subseteq> {ip.\n                 \\<forall>p.\n                    matches (common_matcher, in_doubt_allow) m a\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> get_all_matching_src_ips iface m \\<Longrightarrow>\n       x \\<in> {ip.\n                \\<forall>p.\n                   matches (common_matcher, in_doubt_allow) m a\n                    (p\\<lparr>p_iiface := iface_sel iface,\n                         p_src := ip\\<rparr>)}", "fix ip"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> get_all_matching_src_ips iface m \\<Longrightarrow>\n       x \\<in> {ip.\n                \\<forall>p.\n                   matches (common_matcher, in_doubt_allow) m a\n                    (p\\<lparr>p_iiface := iface_sel iface,\n                         p_src := ip\\<rparr>)}", "assume a: \"ip \\<in> get_all_matching_src_ips iface m\""], ["proof (state)\nthis:\n  ip \\<in> get_all_matching_src_ips iface m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> get_all_matching_src_ips iface m \\<Longrightarrow>\n       x \\<in> {ip.\n                \\<forall>p.\n                   matches (common_matcher, in_doubt_allow) m a\n                    (p\\<lparr>p_iiface := iface_sel iface,\n                         p_src := ip\\<rparr>)}", "obtain i_matches rest1 where select1: \"primitive_extractor (is_Iiface, iiface_sel) m = (i_matches, rest1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i_matches rest1.\n        primitive_extractor (is_Iiface, iiface_sel) m =\n        (i_matches, rest1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (is_Iiface, iiface_sel) m = (i_matches, rest1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> get_all_matching_src_ips iface m \\<Longrightarrow>\n       x \\<in> {ip.\n                \\<forall>p.\n                   matches (common_matcher, in_doubt_allow) m a\n                    (p\\<lparr>p_iiface := iface_sel iface,\n                         p_src := ip\\<rparr>)}", "show \"ip \\<in> {ip. \\<forall>p :: ('i, 'a) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m a (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "proof(cases \"\\<forall> is \\<in> set i_matches. (case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                                                 | Neg i \\<Rightarrow> \\<not>match_iface i (iface_sel iface))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}\n 2. \\<not> (\\<forall>is\\<in>set i_matches.\n               case is of\n               Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n               | Neg i \\<Rightarrow>\n                   \\<not> match_iface i (iface_sel iface)) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>is\\<in>set i_matches.\n             case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n             | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface))\n\ngoal (2 subgoals):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}\n 2. \\<not> (\\<forall>is\\<in>set i_matches.\n               case is of\n               Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n               | Neg i \\<Rightarrow>\n                   \\<not> match_iface i (iface_sel iface)) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "have \"get_all_matching_src_ips iface m = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_all_matching_src_ips iface m = {}", "unfolding get_all_matching_src_ips_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (i_matches, rest1) = primitive_extractor (is_Iiface, iiface_sel) m\n     in if \\<forall>is\\<in>set i_matches.\n              case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n              | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)\n        then let (ip_matches, rest2) =\n                   primitive_extractor (is_Src, src_sel) rest1\n             in if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n                then if ip_matches = [] then UNIV\n                     else \\<Inter>ips\\<in>set ip_matches.\n                             case ips of\n                             Pos ip \\<Rightarrow> ipt_iprange_to_set ip\n                             | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip\n                else {}\n        else {}) =\n    {}", "using select1 False"], ["proof (prove)\nusing this:\n  primitive_extractor (is_Iiface, iiface_sel) m = (i_matches, rest1)\n  \\<not> (\\<forall>is\\<in>set i_matches.\n             case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n             | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface))\n\ngoal (1 subgoal):\n 1. (let (i_matches, rest1) = primitive_extractor (is_Iiface, iiface_sel) m\n     in if \\<forall>is\\<in>set i_matches.\n              case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n              | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)\n        then let (ip_matches, rest2) =\n                   primitive_extractor (is_Src, src_sel) rest1\n             in if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n                then if ip_matches = [] then UNIV\n                     else \\<Inter>ips\\<in>set ip_matches.\n                             case ips of\n                             Pos ip \\<Rightarrow> ipt_iprange_to_set ip\n                             | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip\n                else {}\n        else {}) =\n    {}", "by auto"], ["proof (state)\nthis:\n  get_all_matching_src_ips iface m = {}\n\ngoal (2 subgoals):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}\n 2. \\<not> (\\<forall>is\\<in>set i_matches.\n               case is of\n               Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n               | Neg i \\<Rightarrow>\n                   \\<not> match_iface i (iface_sel iface)) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "with a"], ["proof (chain)\npicking this:\n  ip \\<in> get_all_matching_src_ips iface m\n  get_all_matching_src_ips iface m = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ip \\<in> get_all_matching_src_ips iface m\n  get_all_matching_src_ips iface m = {}\n\ngoal (1 subgoal):\n 1. ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "by simp"], ["proof (state)\nthis:\n  ip \\<in> {ip.\n            \\<forall>p.\n               matches (common_matcher, in_doubt_allow) m a\n                (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "case True"], ["proof (state)\nthis:\n  \\<forall>is\\<in>set i_matches.\n     case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n     | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)\n\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "let ?\\<gamma>=\"(common_matcher, in_doubt_allow) :: ('i::len common_primitive, ('i, 'a) tagged_packet_scheme) match_tac\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "let ?p=\"\\<lambda>p::('i, 'a) tagged_packet_scheme. p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "obtain ip_matches rest2 where select2: \"primitive_extractor (is_Src, src_sel) rest1 = (ip_matches, rest2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ip_matches rest2.\n        primitive_extractor (is_Src, src_sel) rest1 =\n        (ip_matches, rest2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  primitive_extractor (is_Src, src_sel) rest1 = (ip_matches, rest2)\n\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "let ?noDisc=\"\\<not> has_primitive rest2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "have get_all_matching_src_ips_caseTrue: \"get_all_matching_src_ips iface m =\n            (if ?noDisc \\<and> matcheq_matchAny rest2\n             then if ip_matches = []\n                  then UNIV\n                  else \\<Inter>((case_negation_type ipt_iprange_to_set (\\<lambda>ip. - ipt_iprange_to_set ip) ` (set ip_matches)))\n              else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_all_matching_src_ips iface m =\n    (if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n     then if ip_matches = [] then UNIV\n          else \\<Inter>\n                (case_negation_type ipt_iprange_to_set\n                  (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                 set ip_matches)\n     else {})", "unfolding get_all_matching_src_ips_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (i_matches, rest1) = primitive_extractor (is_Iiface, iiface_sel) m\n     in if \\<forall>is\\<in>set i_matches.\n              case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n              | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)\n        then let (ip_matches, rest2) =\n                   primitive_extractor (is_Src, src_sel) rest1\n             in if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n                then if ip_matches = [] then UNIV\n                     else \\<Inter>ips\\<in>set ip_matches.\n                             case ips of\n                             Pos ip \\<Rightarrow> ipt_iprange_to_set ip\n                             | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip\n                else {}\n        else {}) =\n    (if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n     then if ip_matches = [] then UNIV\n          else \\<Inter>\n                (case_negation_type ipt_iprange_to_set\n                  (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                 set ip_matches)\n     else {})", "by(simp add: True select1 select2)"], ["proof (state)\nthis:\n  get_all_matching_src_ips iface m =\n  (if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n   then if ip_matches = [] then UNIV\n        else \\<Inter>\n              (case_negation_type ipt_iprange_to_set\n                (\\<lambda>ip. - ipt_iprange_to_set ip) `\n               set ip_matches)\n   else {})\n\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "from True"], ["proof (chain)\npicking this:\n  \\<forall>is\\<in>set i_matches.\n     case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n     | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)", "have \"(\\<forall>m\\<in>set (getPos i_matches). matches ?\\<gamma> (Match (IIface m)) a (?p p)) \\<and>\n                      (\\<forall>m\\<in>set (getNeg i_matches). matches ?\\<gamma> (MatchNot (Match (IIface m))) a (?p p))\"\n       for p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (prove)\nusing this:\n  \\<forall>is\\<in>set i_matches.\n     case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n     | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface)\n\ngoal (1 subgoal):\n 1. (\\<forall>m\\<in>set (getPos i_matches).\n        matches (common_matcher, in_doubt_allow) (Match (IIface m)) a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)) \\<and>\n    (\\<forall>m\\<in>set (getNeg i_matches).\n        matches (common_matcher, in_doubt_allow)\n         (MatchNot (Match (IIface m))) a\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>))", "by(simp add: negation_type_forall_split\n            primitive_matcher_generic.Iface_single[OF primitive_matcher_generic_common_matcher]\n            primitive_matcher_generic.Iface_single_not[OF primitive_matcher_generic_common_matcher])"], ["proof (state)\nthis:\n  (\\<forall>m\\<in>set (getPos i_matches).\n      matches (common_matcher, in_doubt_allow) (Match (IIface m)) a\n       (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)) \\<and>\n  (\\<forall>m\\<in>set (getNeg i_matches).\n      matches (common_matcher, in_doubt_allow) (MatchNot (Match (IIface m)))\n       a (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "hence matches_iface: \"matches ?\\<gamma> (alist_and (NegPos_map IIface i_matches)) a (?p p)\"\n        for p :: \"('i,'a) tagged_packet_scheme\""], ["proof (prove)\nusing this:\n  (\\<forall>m\\<in>set (getPos i_matches).\n      matches (common_matcher, in_doubt_allow) (Match (IIface m)) a\n       (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)) \\<and>\n  (\\<forall>m\\<in>set (getNeg i_matches).\n      matches (common_matcher, in_doubt_allow) (MatchNot (Match (IIface m)))\n       a (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>))\n\ngoal (1 subgoal):\n 1. matches (common_matcher, in_doubt_allow)\n     (alist_and (NegPos_map IIface i_matches)) a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "by(simp add: matches_alist_and NegPos_map_simps)"], ["proof (state)\nthis:\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map IIface i_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<forall>is\\<in>set i_matches.\n       case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n       | Neg i \\<Rightarrow>\n           \\<not> match_iface i (iface_sel iface) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "proof(cases \"?noDisc \\<and> matcheq_matchAny rest2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}\n 2. \\<not> (\\<not> has_primitive rest2 \\<and>\n            matcheq_matchAny rest2) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2)\n\ngoal (2 subgoals):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}\n 2. \\<not> (\\<not> has_primitive rest2 \\<and>\n            matcheq_matchAny rest2) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "assume F: \"\\<not> (?noDisc \\<and> matcheq_matchAny rest2)\""], ["proof (state)\nthis:\n  \\<not> (\\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2)\n\ngoal (2 subgoals):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}\n 2. \\<not> (\\<not> has_primitive rest2 \\<and>\n            matcheq_matchAny rest2) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "with get_all_matching_src_ips_caseTrue"], ["proof (chain)\npicking this:\n  get_all_matching_src_ips iface m =\n  (if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n   then if ip_matches = [] then UNIV\n        else \\<Inter>\n              (case_negation_type ipt_iprange_to_set\n                (\\<lambda>ip. - ipt_iprange_to_set ip) `\n               set ip_matches)\n   else {})\n  \\<not> (\\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2)", "have \"get_all_matching_src_ips iface m = {}\""], ["proof (prove)\nusing this:\n  get_all_matching_src_ips iface m =\n  (if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n   then if ip_matches = [] then UNIV\n        else \\<Inter>\n              (case_negation_type ipt_iprange_to_set\n                (\\<lambda>ip. - ipt_iprange_to_set ip) `\n               set ip_matches)\n   else {})\n  \\<not> (\\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2)\n\ngoal (1 subgoal):\n 1. get_all_matching_src_ips iface m = {}", "by presburger"], ["proof (state)\nthis:\n  get_all_matching_src_ips iface m = {}\n\ngoal (2 subgoals):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}\n 2. \\<not> (\\<not> has_primitive rest2 \\<and>\n            matcheq_matchAny rest2) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "with a"], ["proof (chain)\npicking this:\n  ip \\<in> get_all_matching_src_ips iface m\n  get_all_matching_src_ips iface m = {}", "have False"], ["proof (prove)\nusing this:\n  ip \\<in> get_all_matching_src_ips iface m\n  get_all_matching_src_ips iface m = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}\n 2. \\<not> (\\<not> has_primitive rest2 \\<and>\n            matcheq_matchAny rest2) \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", ".."], ["proof (state)\nthis:\n  ip \\<in> {ip.\n            \\<forall>p.\n               matches (common_matcher, in_doubt_allow) m a\n                (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "case True"], ["proof (state)\nthis:\n  \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "assume F: \"?noDisc \\<and> matcheq_matchAny rest2\""], ["proof (state)\nthis:\n  \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "with get_all_matching_src_ips_caseTrue"], ["proof (chain)\npicking this:\n  get_all_matching_src_ips iface m =\n  (if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n   then if ip_matches = [] then UNIV\n        else \\<Inter>\n              (case_negation_type ipt_iprange_to_set\n                (\\<lambda>ip. - ipt_iprange_to_set ip) `\n               set ip_matches)\n   else {})\n  \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2", "have \"get_all_matching_src_ips iface m = \n            (if ip_matches = []\n             then UNIV\n             else \\<Inter>((case_negation_type ipt_iprange_to_set (\\<lambda>ip. - ipt_iprange_to_set ip) ` (set ip_matches))))\""], ["proof (prove)\nusing this:\n  get_all_matching_src_ips iface m =\n  (if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n   then if ip_matches = [] then UNIV\n        else \\<Inter>\n              (case_negation_type ipt_iprange_to_set\n                (\\<lambda>ip. - ipt_iprange_to_set ip) `\n               set ip_matches)\n   else {})\n  \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n\ngoal (1 subgoal):\n 1. get_all_matching_src_ips iface m =\n    (if ip_matches = [] then UNIV\n     else \\<Inter>\n           (case_negation_type ipt_iprange_to_set\n             (\\<lambda>ip. - ipt_iprange_to_set ip) `\n            set ip_matches))", "by presburger"], ["proof (state)\nthis:\n  get_all_matching_src_ips iface m =\n  (if ip_matches = [] then UNIV\n   else \\<Inter>\n         (case_negation_type ipt_iprange_to_set\n           (\\<lambda>ip. - ipt_iprange_to_set ip) `\n          set ip_matches))\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "from primitive_extractor_correct[OF assms wf_disc_sel_common_primitive(5) select1]"], ["proof (chain)\npicking this:\n  (matches ?\\<gamma> (alist_and (NegPos_map IIface i_matches)) ?a ?p \\<and>\n   matches ?\\<gamma> rest1 ?a ?p) =\n  matches ?\\<gamma> m ?a ?p\n  normalized_nnf_match rest1\n  \\<not> has_disc is_Iiface rest1\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 rest1\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) ?P m \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) ?P rest1\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg rest1\n  (\\<not> has_disc is_Iiface m) = (i_matches = [] \\<and> rest1 = m)\n  (\\<not> has_disc_negated is_Iiface False m) = (getNeg i_matches = [])\n  has_disc is_Iiface m \\<Longrightarrow> i_matches \\<noteq> []", "have\n          select1_matches: \"matches ?\\<gamma> (alist_and (NegPos_map IIface i_matches)) a p \\<and> matches ?\\<gamma> rest1 a p \\<longleftrightarrow> matches ?\\<gamma> m a p\"\n          and normalized1: \"normalized_nnf_match rest1\" for p :: \"('i,'a) tagged_packet_scheme\""], ["proof (prove)\nusing this:\n  (matches ?\\<gamma> (alist_and (NegPos_map IIface i_matches)) ?a ?p \\<and>\n   matches ?\\<gamma> rest1 ?a ?p) =\n  matches ?\\<gamma> m ?a ?p\n  normalized_nnf_match rest1\n  \\<not> has_disc is_Iiface rest1\n  \\<forall>disc2.\n     \\<not> has_disc disc2 m \\<longrightarrow> \\<not> has_disc disc2 rest1\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) ?P m \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) ?P rest1\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg m \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg rest1\n  (\\<not> has_disc is_Iiface m) = (i_matches = [] \\<and> rest1 = m)\n  (\\<not> has_disc_negated is_Iiface False m) = (getNeg i_matches = [])\n  has_disc is_Iiface m \\<Longrightarrow> i_matches \\<noteq> []\n\ngoal (1 subgoal):\n 1. (matches (common_matcher, in_doubt_allow)\n      (alist_and (NegPos_map IIface i_matches)) a p \\<and>\n     matches (common_matcher, in_doubt_allow) rest1 a p) =\n    matches (common_matcher, in_doubt_allow) m a p &&&\n    normalized_nnf_match rest1", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>\\<gamma> a p.\n                (matches \\<gamma> (alist_and (NegPos_map IIface i_matches))\n                  a p \\<and>\n                 matches \\<gamma> rest1 a p) =\n                matches \\<gamma> m a p;\n     normalized_nnf_match rest1; \\<not> has_disc is_Iiface rest1;\n     \\<forall>disc2.\n        \\<not> has_disc disc2 m \\<longrightarrow>\n        \\<not> has_disc disc2 rest1;\n     \\<And>P.\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) P rest1;\n     \\<And>neg.\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rest1;\n     (\\<not> has_disc is_Iiface m) = (i_matches = [] \\<and> rest1 = m);\n     (\\<not> has_disc_negated is_Iiface False m) = (getNeg i_matches = []);\n     has_disc is_Iiface m \\<Longrightarrow> i_matches \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (matches (common_matcher, in_doubt_allow)\n                        (alist_and (NegPos_map IIface i_matches)) a p \\<and>\n                       matches (common_matcher, in_doubt_allow) rest1 a p) =\n                      matches (common_matcher, in_doubt_allow) m a p\n 2. \\<lbrakk>\\<And>\\<gamma> a p.\n                (matches \\<gamma> (alist_and (NegPos_map IIface i_matches))\n                  a p \\<and>\n                 matches \\<gamma> rest1 a p) =\n                matches \\<gamma> m a p;\n     normalized_nnf_match rest1; \\<not> has_disc is_Iiface rest1;\n     \\<forall>disc2.\n        \\<not> has_disc disc2 m \\<longrightarrow>\n        \\<not> has_disc disc2 rest1;\n     \\<And>P.\n        \\<forall>disc2 sel2.\n           normalized_n_primitive (disc2, sel2) P m \\<longrightarrow>\n           normalized_n_primitive (disc2, sel2) P rest1;\n     \\<And>neg.\n        \\<forall>disc2.\n           \\<not> has_disc_negated disc2 neg m \\<longrightarrow>\n           \\<not> has_disc_negated disc2 neg rest1;\n     (\\<not> has_disc is_Iiface m) = (i_matches = [] \\<and> rest1 = m);\n     (\\<not> has_disc_negated is_Iiface False m) = (getNeg i_matches = []);\n     has_disc is_Iiface m \\<Longrightarrow> i_matches \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> normalized_nnf_match rest1", "apply fast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (matches (common_matcher, in_doubt_allow)\n    (alist_and (NegPos_map IIface i_matches)) a ?p \\<and>\n   matches (common_matcher, in_doubt_allow) rest1 a ?p) =\n  matches (common_matcher, in_doubt_allow) m a ?p\n  normalized_nnf_match rest1\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "from select1_matches matches_iface"], ["proof (chain)\npicking this:\n  (matches (common_matcher, in_doubt_allow)\n    (alist_and (NegPos_map IIface i_matches)) a ?p \\<and>\n   matches (common_matcher, in_doubt_allow) rest1 a ?p) =\n  matches (common_matcher, in_doubt_allow) m a ?p\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map IIface i_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "have\n          rest1_matches: \"matches ?\\<gamma> rest1 a (?p p) \\<longleftrightarrow> matches ?\\<gamma> m a (?p p)\" for p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (prove)\nusing this:\n  (matches (common_matcher, in_doubt_allow)\n    (alist_and (NegPos_map IIface i_matches)) a ?p \\<and>\n   matches (common_matcher, in_doubt_allow) rest1 a ?p) =\n  matches (common_matcher, in_doubt_allow) m a ?p\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map IIface i_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. matches (common_matcher, in_doubt_allow) rest1 a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n    matches (common_matcher, in_doubt_allow) m a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "by blast"], ["proof (state)\nthis:\n  matches (common_matcher, in_doubt_allow) rest1 a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n  matches (common_matcher, in_doubt_allow) m a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "from primitive_extractor_correct[OF normalized1 wf_disc_sel_common_primitive(3) select2]"], ["proof (chain)\npicking this:\n  (matches ?\\<gamma> (alist_and (NegPos_map Src ip_matches)) ?a ?p \\<and>\n   matches ?\\<gamma> rest2 ?a ?p) =\n  matches ?\\<gamma> rest1 ?a ?p\n  normalized_nnf_match rest2\n  \\<not> has_disc is_Src rest2\n  \\<forall>disc2.\n     \\<not> has_disc disc2 rest1 \\<longrightarrow>\n     \\<not> has_disc disc2 rest2\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) ?P rest1 \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) ?P rest2\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg rest1 \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg rest2\n  (\\<not> has_disc is_Src rest1) = (ip_matches = [] \\<and> rest2 = rest1)\n  (\\<not> has_disc_negated is_Src False rest1) = (getNeg ip_matches = [])\n  has_disc is_Src rest1 \\<Longrightarrow> ip_matches \\<noteq> []", "have\n          select2_matches: \"matches ?\\<gamma> (alist_and (NegPos_map Src ip_matches)) a p \\<and> matches ?\\<gamma> rest2 a p \\<longleftrightarrow> \n                            matches ?\\<gamma> rest1 a p\" for p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (prove)\nusing this:\n  (matches ?\\<gamma> (alist_and (NegPos_map Src ip_matches)) ?a ?p \\<and>\n   matches ?\\<gamma> rest2 ?a ?p) =\n  matches ?\\<gamma> rest1 ?a ?p\n  normalized_nnf_match rest2\n  \\<not> has_disc is_Src rest2\n  \\<forall>disc2.\n     \\<not> has_disc disc2 rest1 \\<longrightarrow>\n     \\<not> has_disc disc2 rest2\n  \\<forall>disc2 sel2.\n     normalized_n_primitive (disc2, sel2) ?P rest1 \\<longrightarrow>\n     normalized_n_primitive (disc2, sel2) ?P rest2\n  \\<forall>disc2.\n     \\<not> has_disc_negated disc2 ?neg rest1 \\<longrightarrow>\n     \\<not> has_disc_negated disc2 ?neg rest2\n  (\\<not> has_disc is_Src rest1) = (ip_matches = [] \\<and> rest2 = rest1)\n  (\\<not> has_disc_negated is_Src False rest1) = (getNeg ip_matches = [])\n  has_disc is_Src rest1 \\<Longrightarrow> ip_matches \\<noteq> []\n\ngoal (1 subgoal):\n 1. (matches (common_matcher, in_doubt_allow)\n      (alist_and (NegPos_map Src ip_matches)) a p \\<and>\n     matches (common_matcher, in_doubt_allow) rest2 a p) =\n    matches (common_matcher, in_doubt_allow) rest1 a p", "by fast"], ["proof (state)\nthis:\n  (matches (common_matcher, in_doubt_allow)\n    (alist_and (NegPos_map Src ip_matches)) a ?p \\<and>\n   matches (common_matcher, in_doubt_allow) rest2 a ?p) =\n  matches (common_matcher, in_doubt_allow) rest1 a ?p\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "with F matcheq_matchAny"], ["proof (chain)\npicking this:\n  \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n  \\<not> has_primitive ?m \\<Longrightarrow>\n  matcheq_matchAny ?m = matches ?\\<gamma> ?m ?a ?p\n  (matches (common_matcher, in_doubt_allow)\n    (alist_and (NegPos_map Src ip_matches)) a ?p \\<and>\n   matches (common_matcher, in_doubt_allow) rest2 a ?p) =\n  matches (common_matcher, in_doubt_allow) rest1 a ?p", "have \"matches ?\\<gamma> rest2 a p\" for p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (prove)\nusing this:\n  \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n  \\<not> has_primitive ?m \\<Longrightarrow>\n  matcheq_matchAny ?m = matches ?\\<gamma> ?m ?a ?p\n  (matches (common_matcher, in_doubt_allow)\n    (alist_and (NegPos_map Src ip_matches)) a ?p \\<and>\n   matches (common_matcher, in_doubt_allow) rest2 a ?p) =\n  matches (common_matcher, in_doubt_allow) rest1 a ?p\n\ngoal (1 subgoal):\n 1. matches (common_matcher, in_doubt_allow) rest2 a p", "by metis"], ["proof (state)\nthis:\n  matches (common_matcher, in_doubt_allow) rest2 a ?p\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "with select2_matches rest1_matches"], ["proof (chain)\npicking this:\n  (matches (common_matcher, in_doubt_allow)\n    (alist_and (NegPos_map Src ip_matches)) a ?p \\<and>\n   matches (common_matcher, in_doubt_allow) rest2 a ?p) =\n  matches (common_matcher, in_doubt_allow) rest1 a ?p\n  matches (common_matcher, in_doubt_allow) rest1 a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n  matches (common_matcher, in_doubt_allow) m a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n  matches (common_matcher, in_doubt_allow) rest2 a ?p", "have ip_src_matches: \n          \"matches ?\\<gamma> (alist_and (NegPos_map Src ip_matches)) a (?p p) \\<longleftrightarrow> matches ?\\<gamma> m a (?p p)\"\n          for p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (prove)\nusing this:\n  (matches (common_matcher, in_doubt_allow)\n    (alist_and (NegPos_map Src ip_matches)) a ?p \\<and>\n   matches (common_matcher, in_doubt_allow) rest2 a ?p) =\n  matches (common_matcher, in_doubt_allow) rest1 a ?p\n  matches (common_matcher, in_doubt_allow) rest1 a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n  matches (common_matcher, in_doubt_allow) m a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n  matches (common_matcher, in_doubt_allow) rest2 a ?p\n\ngoal (1 subgoal):\n 1. matches (common_matcher, in_doubt_allow)\n     (alist_and (NegPos_map Src ip_matches)) a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n    matches (common_matcher, in_doubt_allow) m a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n  matches (common_matcher, in_doubt_allow) m a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "have case_nil: \"\\<And>p. ip_matches = [] \\<Longrightarrow> matches ?\\<gamma> (alist_and (NegPos_map Src ip_matches)) a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       ip_matches = [] \\<Longrightarrow>\n       matches (common_matcher, in_doubt_allow)\n        (alist_and (NegPos_map Src ip_matches)) a p", "by(simp add: bunch_of_lemmata_about_matches)"], ["proof (state)\nthis:\n  ip_matches = [] \\<Longrightarrow>\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a ?p\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "have case_list: \"\\<And>p. \\<forall>x\\<in>set ip_matches. (case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n                                                          | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i) \\<Longrightarrow>\n            matches ?\\<gamma> (alist_and (NegPos_map Src ip_matches)) a (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>x\\<in>set ip_matches.\n          case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n          | Neg i \\<Rightarrow>\n              ip \\<in> - ipt_iprange_to_set i \\<Longrightarrow>\n       matches (common_matcher, in_doubt_allow)\n        (alist_and (NegPos_map Src ip_matches)) a\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "apply(simp add: matches_alist_and NegPos_map_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>x\\<in>set ip_matches.\n          case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n          | Neg i \\<Rightarrow>\n              ip \\<in> - ipt_iprange_to_set i \\<Longrightarrow>\n       (\\<forall>m\\<in>set (getPos ip_matches).\n           matches (common_matcher, in_doubt_allow) (Match (Src m)) a\n            (p\\<lparr>p_iiface := iface_sel iface,\n                 p_src := ip\\<rparr>)) \\<and>\n       (\\<forall>m\\<in>set (getNeg ip_matches).\n           matches (common_matcher, in_doubt_allow)\n            (MatchNot (Match (Src m))) a\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>))", "apply(simp add: negation_type_forall_split match_simplematcher_SrcDst_not match_simplematcher_SrcDst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ip_matches.\n     case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n     | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i \\<Longrightarrow>\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<not> has_primitive rest2 \\<and>\n    matcheq_matchAny rest2 \\<Longrightarrow>\n    ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "from a"], ["proof (chain)\npicking this:\n  ip \\<in> get_all_matching_src_ips iface m", "show \"ip \\<in> {ip. \\<forall>p :: ('i, 'a) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m a (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\""], ["proof (prove)\nusing this:\n  ip \\<in> get_all_matching_src_ips iface m\n\ngoal (1 subgoal):\n 1. ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "unfolding get_all_matching_src_ips_caseTrue"], ["proof (prove)\nusing this:\n  ip \\<in> (if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n            then if ip_matches = [] then UNIV\n                 else \\<Inter>\n                       (case_negation_type ipt_iprange_to_set\n                         (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                        set ip_matches)\n            else {})\n\ngoal (1 subgoal):\n 1. ip \\<in> {ip.\n              \\<forall>p.\n                 matches (common_matcher, in_doubt_allow) m a\n                  (p\\<lparr>p_iiface := iface_sel iface,\n                       p_src := ip\\<rparr>)}", "proof(clarsimp split: if_split_asm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches = []\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)\n 2. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "fix p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches = []\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)\n 2. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "assume \"ip_matches = []\""], ["proof (state)\nthis:\n  ip_matches = []\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches = []\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)\n 2. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "with case_nil"], ["proof (chain)\npicking this:\n  ip_matches = [] \\<Longrightarrow>\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a ?p\n  ip_matches = []", "have \"matches ?\\<gamma> (alist_and (NegPos_map Src ip_matches)) a (?p p)\""], ["proof (prove)\nusing this:\n  ip_matches = [] \\<Longrightarrow>\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a ?p\n  ip_matches = []\n\ngoal (1 subgoal):\n 1. matches (common_matcher, in_doubt_allow)\n     (alist_and (NegPos_map Src ip_matches)) a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches = []\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)\n 2. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "with ip_src_matches"], ["proof (chain)\npicking this:\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n  matches (common_matcher, in_doubt_allow) m a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "show \"matches ?\\<gamma> m a (?p p)\""], ["proof (prove)\nusing this:\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n  matches (common_matcher, in_doubt_allow) m a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. matches (common_matcher, in_doubt_allow) m a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  matches (common_matcher, in_doubt_allow) m a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "fix p :: \"('i, 'a) tagged_packet_scheme\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "assume \"\\<forall>x\\<in>set ip_matches. ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ip_matches.\n     ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n               | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "hence \"\\<forall>x\\<in>set ip_matches. case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ip_matches.\n     ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n               | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set ip_matches.\n       case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n       | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i", "by(simp_all split: negation_type.split negation_type.split_asm)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ip_matches.\n     case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n     | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "with case_list"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set ip_matches.\n     case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n     | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i \\<Longrightarrow>\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n  \\<forall>x\\<in>set ip_matches.\n     case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n     | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i", "have \"matches ?\\<gamma> (alist_and (NegPos_map Src ip_matches)) a (?p p)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ip_matches.\n     case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n     | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i \\<Longrightarrow>\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n  \\<forall>x\\<in>set ip_matches.\n     case x of Pos i \\<Rightarrow> ip \\<in> ipt_iprange_to_set i\n     | Neg i \\<Rightarrow> ip \\<in> - ipt_iprange_to_set i\n\ngoal (1 subgoal):\n 1. matches (common_matcher, in_doubt_allow)\n     (alist_and (NegPos_map Src ip_matches)) a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "."], ["proof (state)\nthis:\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<not> has_primitive rest2; matcheq_matchAny rest2;\n        ip_matches \\<noteq> [];\n        \\<forall>x\\<in>set ip_matches.\n           ip \\<in> (case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow>\n                         - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> matches (common_matcher, in_doubt_allow) m a\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := ip\\<rparr>)", "with ip_src_matches"], ["proof (chain)\npicking this:\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n  matches (common_matcher, in_doubt_allow) m a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "show \"matches ?\\<gamma> m a (?p p)\""], ["proof (prove)\nusing this:\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) =\n  matches (common_matcher, in_doubt_allow) m a\n   (?p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n  matches (common_matcher, in_doubt_allow)\n   (alist_and (NegPos_map Src ip_matches)) a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal (1 subgoal):\n 1. matches (common_matcher, in_doubt_allow) m a\n     (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  matches (common_matcher, in_doubt_allow) m a\n   (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ip \\<in> {ip.\n            \\<forall>p.\n               matches (common_matcher, in_doubt_allow) m a\n                (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ip \\<in> {ip.\n            \\<forall>p.\n               matches (common_matcher, in_doubt_allow) m a\n                (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ip \\<in> {ip.\n            \\<forall>p.\n               matches (common_matcher, in_doubt_allow) m a\n                (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition get_exists_matching_src_ips_executable\n    :: \"iface \\<Rightarrow> 'i::len common_primitive match_expr \\<Rightarrow> 'i wordinterval\" where\n    \"get_exists_matching_src_ips_executable iface m \\<equiv> let (i_matches, _) = (primitive_extractor (is_Iiface, iiface_sel) m) in\n              if (\\<forall> is \\<in> set i_matches. (case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                                                  | Neg i \\<Rightarrow> \\<not>match_iface i (iface_sel iface)))\n              then\n                (let (ip_matches, _) = (primitive_extractor (is_Src, src_sel) m) in\n                if ip_matches = []\n                then\n                  wordinterval_UNIV\n                else\n                  l2wi_negation_type_intersect (NegPos_map ipt_iprange_to_interval ip_matches))\n              else\n                Empty_WordInterval\""], ["", "(*WOW, such horrible proof!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*)"], ["", "lemma get_exists_matching_src_ips_executable: \n    \"wordinterval_to_set (get_exists_matching_src_ips_executable iface m) = get_exists_matching_src_ips iface m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (get_exists_matching_src_ips_executable iface m) =\n    get_exists_matching_src_ips iface m", "apply(simp add: get_exists_matching_src_ips_executable_def get_exists_matching_src_ips_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (case primitive_extractor (is_Iiface, iiface_sel) m of\n      (i_matches, uu_) \\<Rightarrow>\n        if Ball (set i_matches)\n            (case_negation_type\n              (\\<lambda>i. match_iface i (iface_sel iface))\n              (\\<lambda>i. \\<not> match_iface i (iface_sel iface)))\n        then let (ip_matches, uu_) = primitive_extractor (is_Src, src_sel) m\n             in if ip_matches = [] then wordinterval_UNIV\n                else l2wi_negation_type_intersect\n                      (NegPos_map ipt_iprange_to_interval ip_matches)\n        else Empty_WordInterval) =\n    (case primitive_extractor (is_Iiface, iiface_sel) m of\n     (i_matches, uu_) \\<Rightarrow>\n       if Ball (set i_matches)\n           (case_negation_type (\\<lambda>i. match_iface i (iface_sel iface))\n             (\\<lambda>i. \\<not> match_iface i (iface_sel iface)))\n       then let (ip_matches, uu_) = primitive_extractor (is_Src, src_sel) m\n            in if ip_matches = [] then UNIV\n               else \\<Inter>\n                     (case_negation_type ipt_iprange_to_set\n                       (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                      set ip_matches)\n       else {})", "apply(case_tac \"primitive_extractor (is_Iiface, iiface_sel) m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       primitive_extractor (is_Iiface, iiface_sel) m =\n       (a, b) \\<Longrightarrow>\n       wordinterval_to_set\n        (case primitive_extractor (is_Iiface, iiface_sel) m of\n         (i_matches, uu_) \\<Rightarrow>\n           if Ball (set i_matches)\n               (case_negation_type\n                 (\\<lambda>i. match_iface i (iface_sel iface))\n                 (\\<lambda>i. \\<not> match_iface i (iface_sel iface)))\n           then let (ip_matches, uu_) =\n                      primitive_extractor (is_Src, src_sel) m\n                in if ip_matches = [] then wordinterval_UNIV\n                   else l2wi_negation_type_intersect\n                         (NegPos_map ipt_iprange_to_interval ip_matches)\n           else Empty_WordInterval) =\n       (case primitive_extractor (is_Iiface, iiface_sel) m of\n        (i_matches, uu_) \\<Rightarrow>\n          if Ball (set i_matches)\n              (case_negation_type\n                (\\<lambda>i. match_iface i (iface_sel iface))\n                (\\<lambda>i. \\<not> match_iface i (iface_sel iface)))\n          then let (ip_matches, uu_) =\n                     primitive_extractor (is_Src, src_sel) m\n               in if ip_matches = [] then UNIV\n                  else \\<Inter>\n                        (case_negation_type ipt_iprange_to_set\n                          (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                         set ip_matches)\n          else {})", "apply(case_tac \"primitive_extractor (is_Src, src_sel) m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (case primitive_extractor (is_Iiface, iiface_sel)\n                                 m of\n                           (i_matches, uu_) \\<Rightarrow>\n                             if Ball (set i_matches)\n                                 (case_negation_type\n                                   (\\<lambda>i.\n match_iface i (iface_sel iface))\n                                   (\\<lambda>i.\n \\<not> match_iface i (iface_sel iface)))\n                             then let (ip_matches, uu_) =\n  primitive_extractor (is_Src, src_sel) m\n                                  in if ip_matches = []\n                                     then wordinterval_UNIV\n                                     else l2wi_negation_type_intersect\n     (NegPos_map ipt_iprange_to_interval ip_matches)\n                             else Empty_WordInterval) =\n                         (case primitive_extractor (is_Iiface, iiface_sel)\n                                m of\n                          (i_matches, uu_) \\<Rightarrow>\n                            if Ball (set i_matches)\n                                (case_negation_type\n                                  (\\<lambda>i.\nmatch_iface i (iface_sel iface))\n                                  (\\<lambda>i.\n\\<not> match_iface i (iface_sel iface)))\n                            then let (ip_matches, uu_) =\n primitive_extractor (is_Src, src_sel) m\n                                 in if ip_matches = [] then UNIV\n                                    else \\<Inter>\n    (case_negation_type ipt_iprange_to_set\n      (\\<lambda>ip. - ipt_iprange_to_set ip) `\n     set ip_matches)\n                            else {})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x\\<in>set a.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          aa \\<noteq> [] \\<longrightarrow>\n                          wordinterval_to_set\n                           (l2wi_negation_type_intersect\n                             (NegPos_map ipt_iprange_to_interval aa)) =\n                          \\<Inter>\n                           (case_negation_type ipt_iprange_to_set\n                             (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                            set aa)) \\<and>\n                         ((\\<exists>x\\<in>set a.\n                              \\<not> (case x of\nPos i \\<Rightarrow> match_iface i (iface_sel iface)\n| Neg i \\<Rightarrow>\n    \\<not> match_iface i (iface_sel iface))) \\<longrightarrow>\n                          aa \\<noteq> [] \\<longrightarrow>\n                          Ball (set a)\n                           (case_negation_type\n                             (\\<lambda>i. match_iface i (iface_sel iface))\n                             (\\<lambda>i.\n                                 \\<not> match_iface i\n   (iface_sel iface))) \\<longrightarrow>\n                          wordinterval_to_set\n                           (l2wi_negation_type_intersect\n                             (NegPos_map ipt_iprange_to_interval aa)) =\n                          \\<Inter>\n                           (case_negation_type ipt_iprange_to_set\n                             (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                            set aa))", "apply(simp add: l2wi_negation_type_intersect)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x\\<in>set a.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          aa \\<noteq> [] \\<longrightarrow>\n                          (\\<Inter>x\\<in>set\n    (getPos (NegPos_map ipt_iprange_to_interval aa)).\n                              case x of (i, j) \\<Rightarrow> {i..j}) -\n                          (\\<Union>x\\<in>set\n    (getNeg (NegPos_map ipt_iprange_to_interval aa)).\n                              case x of (i, j) \\<Rightarrow> {i..j}) =\n                          (\\<Inter>x\\<in>set aa.\n                              case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)) \\<and>\n                         ((\\<exists>x\\<in>set a.\n                              \\<not> (case x of\nPos i \\<Rightarrow> match_iface i (iface_sel iface)\n| Neg i \\<Rightarrow>\n    \\<not> match_iface i (iface_sel iface))) \\<longrightarrow>\n                          aa \\<noteq> [] \\<longrightarrow>\n                          (\\<forall>x\\<in>set a.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          (\\<Inter>x\\<in>set\n    (getPos (NegPos_map ipt_iprange_to_interval aa)).\n                              case x of (i, j) \\<Rightarrow> {i..j}) -\n                          (\\<Union>x\\<in>set\n    (getNeg (NegPos_map ipt_iprange_to_interval aa)).\n                              case x of (i, j) \\<Rightarrow> {i..j}) =\n                          (\\<Inter>x\\<in>set aa.\n                              case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip))", "apply(simp add: NegPos_map_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x\\<in>set a.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          aa \\<noteq> [] \\<longrightarrow>\n                          (\\<Inter>a\\<in>set (getPos aa).\n                              case ipt_iprange_to_interval a of\n                              (x, xa) \\<Rightarrow> {x..xa}) -\n                          (\\<Union>a\\<in>set (getNeg aa).\n                              case ipt_iprange_to_interval a of\n                              (x, xa) \\<Rightarrow> {x..xa}) =\n                          (\\<Inter>x\\<in>set aa.\n                              case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)) \\<and>\n                         ((\\<exists>x\\<in>set a.\n                              \\<not> (case x of\nPos i \\<Rightarrow> match_iface i (iface_sel iface)\n| Neg i \\<Rightarrow>\n    \\<not> match_iface i (iface_sel iface))) \\<longrightarrow>\n                          aa \\<noteq> [] \\<longrightarrow>\n                          (\\<forall>x\\<in>set a.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          (\\<Inter>a\\<in>set (getPos aa).\n                              case ipt_iprange_to_interval a of\n                              (x, xa) \\<Rightarrow> {x..xa}) -\n                          (\\<Union>a\\<in>set (getNeg aa).\n                              case ipt_iprange_to_interval a of\n                              (x, xa) \\<Rightarrow> {x..xa}) =\n                          (\\<Inter>x\\<in>set aa.\n                              case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip))", "apply(safe)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba x xa.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> []; xa \\<in> set aa;\n        x \\<in> (\\<Inter>a\\<in>set (getPos aa).\n                    case ipt_iprange_to_interval a of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        x \\<notin> (\\<Union>a\\<in>set (getNeg aa).\n                       case ipt_iprange_to_interval a of\n                       (x, xa) \\<Rightarrow> {x..xa})\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 2. \\<And>a b aa ba x ab ac bb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        x \\<in> (\\<Inter>x\\<in>set aa.\n                    case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getPos aa);\n        ipt_iprange_to_interval ab = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {ac..bb}\n 3. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        x \\<in> (\\<Inter>x\\<in>set aa.\n                    case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> {xa..y}\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b aa ba x xa xb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba); x \\<in> set a;\n        \\<not> (case x of\n                Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                | Neg i \\<Rightarrow>\n                    \\<not> match_iface i (iface_sel iface));\n        aa \\<noteq> [];\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xb \\<in> set aa;\n        xa \\<in> (\\<Inter>a\\<in>set (getPos aa).\n                     case ipt_iprange_to_interval a of\n                     (x, xa) \\<Rightarrow> {x..xa});\n        xa \\<notin> (\\<Union>a\\<in>set (getNeg aa).\n                        case ipt_iprange_to_interval a of\n                        (x, xa) \\<Rightarrow> {x..xa})\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> (case xb of\n                                   Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                   | Neg ip \\<Rightarrow>\n - ipt_iprange_to_set ip)\n 5. \\<And>a b aa ba x xa ab ac bb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba); x \\<in> set a;\n        \\<not> (case x of\n                Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                | Neg i \\<Rightarrow>\n                    \\<not> match_iface i (iface_sel iface));\n        aa \\<noteq> [];\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> (\\<Inter>x\\<in>set aa.\n                     case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getPos aa);\n        ipt_iprange_to_interval ab = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {ac..bb}\n 6. \\<And>a b aa ba x xa ab xb y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba); x \\<in> set a;\n        \\<not> (case x of\n                Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                | Neg i \\<Rightarrow>\n                    \\<not> match_iface i (iface_sel iface));\n        aa \\<noteq> [];\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> (\\<Inter>x\\<in>set aa.\n                     case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xb, y);\n        xa \\<in> {xb..y}\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all add: ipt_iprange_to_interval)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba x xa.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> []; xa \\<in> set aa;\n        \\<forall>xa\\<in>set (getPos aa).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg aa).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa})\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 2. \\<And>a b aa ba x ab ac bb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getPos aa);\n        ipt_iprange_to_interval ab = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set ab\n 3. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac i_matches rest1 a b x xa)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i_matches rest1 a b x xa.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; xa \\<in> set a;\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa})\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 2. \\<And>a b aa ba x ab ac bb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getPos aa);\n        ipt_iprange_to_interval ab = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set ab\n 3. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac xa)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i_matches rest1 a b x xa x1.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; xa \\<in> set a;\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Pos x1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 2. \\<And>i_matches rest1 a b x xa x2.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; xa \\<in> set a;\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Neg x2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 3. \\<And>a b aa ba x ab ac bb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getPos aa);\n        ipt_iprange_to_interval ab = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set ab\n 4. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all add: NegPos_set)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i_matches rest1 a b x xa x1.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; x1 \\<in> set (getPos a);\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Pos x1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set x1\n 2. \\<And>i_matches rest1 a b x xa x2.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; x2 \\<in> set (getNeg a);\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Neg x2\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ipt_iprange_to_set x2\n 3. \\<And>a b aa ba x ab ac bb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getPos aa);\n        ipt_iprange_to_interval ab = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set ab\n 4. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "using ipt_iprange_to_interval"], ["proof (prove)\nusing this:\n  ipt_iprange_to_interval ?ip = (?s, ?e) \\<Longrightarrow>\n  {?s..?e} = ipt_iprange_to_set ?ip\n\ngoal (4 subgoals):\n 1. \\<And>i_matches rest1 a b x xa x1.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; x1 \\<in> set (getPos a);\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Pos x1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set x1\n 2. \\<And>i_matches rest1 a b x xa x2.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; x2 \\<in> set (getNeg a);\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Neg x2\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ipt_iprange_to_set x2\n 3. \\<And>a b aa ba x ab ac bb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getPos aa);\n        ipt_iprange_to_interval ab = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set ab\n 4. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "apply fast+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba x ab ac bb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getPos aa);\n        ipt_iprange_to_interval ab = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set ab\n 2. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac i_matches rest1 a b x aa ab ba)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> [];\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 2. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"Pos aa\" in ballE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba);\n        x \\<in> (case Pos aa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                 | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 2. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) m = (a, b);\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        a \\<noteq> []; aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba);\n        Pos aa \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 3. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all add: NegPos_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "using NegPos_set(2)"], ["proof (prove)\nusing this:\n  (Neg ?a \\<in> set ?x) = (?a \\<in> set (getNeg ?x))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba x ab xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m = (a, b);\n        primitive_extractor (is_Src, src_sel) m = (aa, ba);\n        \\<forall>x\\<in>set a.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<noteq> [];\n        \\<forall>xa\\<in>set aa.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        ab \\<in> set (getNeg aa); ipt_iprange_to_interval ab = (xa, y);\n        x \\<in> ipt_iprange_to_set ab\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["", "lemma \"(get_exists_matching_src_ips_executable (Iface ''eth0'')\n      (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0''))))) =\n      RangeUnion (WordInterval 0 0xC0A7FFFF) (WordInterval 0xC0A80100 0xFFFFFFFF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_exists_matching_src_ips_executable (Iface ''eth0'')\n     (MatchAnd\n       (MatchNot\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24))))\n       (Match (IIface (Iface ''eth0'')))) =\n    RangeUnion (WordInterval 0 3232235519)\n     (WordInterval 3232235776 4294967295)", "by eval"], ["", "private"], ["", "definition get_all_matching_src_ips_executable\n    :: \"iface \\<Rightarrow> 'i::len common_primitive match_expr \\<Rightarrow> 'i wordinterval\" where\n    \"get_all_matching_src_ips_executable iface m \\<equiv> let (i_matches, rest1) = (primitive_extractor (is_Iiface, iiface_sel) m) in\n              if (\\<forall> is \\<in> set i_matches. (case is of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                                                  | Neg i \\<Rightarrow> \\<not>match_iface i (iface_sel iface)))\n              then\n                (let (ip_matches, rest2) = (primitive_extractor (is_Src, src_sel) rest1) in\n                if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n                then\n                  if ip_matches = []\n                  then\n                    wordinterval_UNIV\n                  else\n                    l2wi_negation_type_intersect (NegPos_map ipt_iprange_to_interval ip_matches)\n                else\n                  Empty_WordInterval)\n              else\n                Empty_WordInterval\""], ["", "(*WOW, such horrible proof!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*)"], ["", "lemma get_all_matching_src_ips_executable: \n    \"wordinterval_to_set (get_all_matching_src_ips_executable iface m) = get_all_matching_src_ips iface m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (get_all_matching_src_ips_executable iface m) =\n    get_all_matching_src_ips iface m", "apply(simp add: get_all_matching_src_ips_executable_def get_all_matching_src_ips_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (case primitive_extractor (is_Iiface, iiface_sel) m of\n      (i_matches, rest1) \\<Rightarrow>\n        if Ball (set i_matches)\n            (case_negation_type\n              (\\<lambda>i. match_iface i (iface_sel iface))\n              (\\<lambda>i. \\<not> match_iface i (iface_sel iface)))\n        then let (ip_matches, rest2) =\n                   primitive_extractor (is_Src, src_sel) rest1\n             in if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n                then if ip_matches = [] then wordinterval_UNIV\n                     else l2wi_negation_type_intersect\n                           (NegPos_map ipt_iprange_to_interval ip_matches)\n                else Empty_WordInterval\n        else Empty_WordInterval) =\n    (case primitive_extractor (is_Iiface, iiface_sel) m of\n     (i_matches, rest1) \\<Rightarrow>\n       if Ball (set i_matches)\n           (case_negation_type (\\<lambda>i. match_iface i (iface_sel iface))\n             (\\<lambda>i. \\<not> match_iface i (iface_sel iface)))\n       then let (ip_matches, rest2) =\n                  primitive_extractor (is_Src, src_sel) rest1\n            in if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n               then if ip_matches = [] then UNIV\n                    else \\<Inter>\n                          (case_negation_type ipt_iprange_to_set\n                            (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                           set ip_matches)\n               else {}\n       else {})", "apply(case_tac \"primitive_extractor (is_Iiface, iiface_sel) m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       primitive_extractor (is_Iiface, iiface_sel) m =\n       (a, b) \\<Longrightarrow>\n       wordinterval_to_set\n        (case primitive_extractor (is_Iiface, iiface_sel) m of\n         (i_matches, rest1) \\<Rightarrow>\n           if Ball (set i_matches)\n               (case_negation_type\n                 (\\<lambda>i. match_iface i (iface_sel iface))\n                 (\\<lambda>i. \\<not> match_iface i (iface_sel iface)))\n           then let (ip_matches, rest2) =\n                      primitive_extractor (is_Src, src_sel) rest1\n                in if \\<not> has_primitive rest2 \\<and>\n                      matcheq_matchAny rest2\n                   then if ip_matches = [] then wordinterval_UNIV\n                        else l2wi_negation_type_intersect\n                              (NegPos_map ipt_iprange_to_interval\n                                ip_matches)\n                   else Empty_WordInterval\n           else Empty_WordInterval) =\n       (case primitive_extractor (is_Iiface, iiface_sel) m of\n        (i_matches, rest1) \\<Rightarrow>\n          if Ball (set i_matches)\n              (case_negation_type\n                (\\<lambda>i. match_iface i (iface_sel iface))\n                (\\<lambda>i. \\<not> match_iface i (iface_sel iface)))\n          then let (ip_matches, rest2) =\n                     primitive_extractor (is_Src, src_sel) rest1\n               in if \\<not> has_primitive rest2 \\<and>\n                     matcheq_matchAny rest2\n                  then if ip_matches = [] then UNIV\n                       else \\<Inter>\n                             (case_negation_type ipt_iprange_to_set\n                               (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                              set ip_matches)\n                  else {}\n          else {})", "apply(simp, rename_tac i_matches rest1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i_matches rest1.\n       primitive_extractor (is_Iiface, iiface_sel) m =\n       (i_matches, rest1) \\<Longrightarrow>\n       ((\\<forall>x\\<in>set i_matches.\n            case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n            | Neg i \\<Rightarrow>\n                \\<not> match_iface i (iface_sel iface)) \\<longrightarrow>\n        wordinterval_to_set\n         (case primitive_extractor (is_Src, src_sel) rest1 of\n          (ip_matches, rest2) \\<Rightarrow>\n            if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n            then if ip_matches = [] then wordinterval_UNIV\n                 else l2wi_negation_type_intersect\n                       (NegPos_map ipt_iprange_to_interval ip_matches)\n            else Empty_WordInterval) =\n        (case primitive_extractor (is_Src, src_sel) rest1 of\n         (ip_matches, rest2) \\<Rightarrow>\n           if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n           then if ip_matches = [] then UNIV\n                else \\<Inter>\n                      (case_negation_type ipt_iprange_to_set\n                        (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                       set ip_matches)\n           else {})) \\<and>\n       ((\\<exists>x\\<in>set i_matches.\n            \\<not> (case x of\n                    Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                    | Neg i \\<Rightarrow>\n                        \\<not> match_iface i\n                                (iface_sel iface))) \\<longrightarrow>\n        Ball (set i_matches)\n         (case_negation_type (\\<lambda>i. match_iface i (iface_sel iface))\n           (\\<lambda>i.\n               \\<not> match_iface i (iface_sel iface))) \\<longrightarrow>\n        wordinterval_to_set\n         (case primitive_extractor (is_Src, src_sel) rest1 of\n          (ip_matches, rest2) \\<Rightarrow>\n            if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n            then if ip_matches = [] then wordinterval_UNIV\n                 else l2wi_negation_type_intersect\n                       (NegPos_map ipt_iprange_to_interval ip_matches)\n            else Empty_WordInterval) =\n        (case primitive_extractor (is_Src, src_sel) rest1 of\n         (ip_matches, rest2) \\<Rightarrow>\n           if \\<not> has_primitive rest2 \\<and> matcheq_matchAny rest2\n           then if ip_matches = [] then UNIV\n                else \\<Inter>\n                      (case_negation_type ipt_iprange_to_set\n                        (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                       set ip_matches)\n           else {}))", "apply(case_tac \"primitive_extractor (is_Src, src_sel) rest1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i_matches rest1 a b.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x\\<in>set i_matches.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          wordinterval_to_set\n                           (case primitive_extractor (is_Src, src_sel)\n                                  rest1 of\n                            (ip_matches, rest2) \\<Rightarrow>\n                              if \\<not> has_primitive rest2 \\<and>\n                                 matcheq_matchAny rest2\n                              then if ip_matches = [] then wordinterval_UNIV\n                                   else l2wi_negation_type_intersect\n   (NegPos_map ipt_iprange_to_interval ip_matches)\n                              else Empty_WordInterval) =\n                          (case primitive_extractor (is_Src, src_sel)\n                                 rest1 of\n                           (ip_matches, rest2) \\<Rightarrow>\n                             if \\<not> has_primitive rest2 \\<and>\n                                matcheq_matchAny rest2\n                             then if ip_matches = [] then UNIV\n                                  else \\<Inter>\n  (case_negation_type ipt_iprange_to_set\n    (\\<lambda>ip. - ipt_iprange_to_set ip) `\n   set ip_matches)\n                             else {})) \\<and>\n                         ((\\<exists>x\\<in>set i_matches.\n                              \\<not> (case x of\nPos i \\<Rightarrow> match_iface i (iface_sel iface)\n| Neg i \\<Rightarrow>\n    \\<not> match_iface i (iface_sel iface))) \\<longrightarrow>\n                          Ball (set i_matches)\n                           (case_negation_type\n                             (\\<lambda>i. match_iface i (iface_sel iface))\n                             (\\<lambda>i.\n                                 \\<not> match_iface i\n   (iface_sel iface))) \\<longrightarrow>\n                          wordinterval_to_set\n                           (case primitive_extractor (is_Src, src_sel)\n                                  rest1 of\n                            (ip_matches, rest2) \\<Rightarrow>\n                              if \\<not> has_primitive rest2 \\<and>\n                                 matcheq_matchAny rest2\n                              then if ip_matches = [] then wordinterval_UNIV\n                                   else l2wi_negation_type_intersect\n   (NegPos_map ipt_iprange_to_interval ip_matches)\n                              else Empty_WordInterval) =\n                          (case primitive_extractor (is_Src, src_sel)\n                                 rest1 of\n                           (ip_matches, rest2) \\<Rightarrow>\n                             if \\<not> has_primitive rest2 \\<and>\n                                matcheq_matchAny rest2\n                             then if ip_matches = [] then UNIV\n                                  else \\<Inter>\n  (case_negation_type ipt_iprange_to_set\n    (\\<lambda>ip. - ipt_iprange_to_set ip) `\n   set ip_matches)\n                             else {}))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i_matches rest1 a b.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> [] \\<longrightarrow>\n                         \\<not> has_primitive b \\<and>\n                         matcheq_matchAny b \\<longrightarrow>\n                         (Ball (set i_matches)\n                           (case_negation_type\n                             (\\<lambda>i. match_iface i (iface_sel iface))\n                             (\\<lambda>i.\n                                 \\<not> match_iface i\n   (iface_sel iface))) \\<longrightarrow>\n                          wordinterval_to_set\n                           (l2wi_negation_type_intersect\n                             (NegPos_map ipt_iprange_to_interval a)) =\n                          \\<Inter>\n                           (case_negation_type ipt_iprange_to_set\n                             (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                            set a)) \\<and>\n                         ((\\<exists>x\\<in>set i_matches.\n                              \\<not> (case x of\nPos i \\<Rightarrow> match_iface i (iface_sel iface)\n| Neg i \\<Rightarrow>\n    \\<not> match_iface i (iface_sel iface))) \\<longrightarrow>\n                          Ball (set i_matches)\n                           (case_negation_type\n                             (\\<lambda>i. match_iface i (iface_sel iface))\n                             (\\<lambda>i.\n                                 \\<not> match_iface i\n   (iface_sel iface))) \\<longrightarrow>\n                          wordinterval_to_set\n                           (l2wi_negation_type_intersect\n                             (NegPos_map ipt_iprange_to_interval a)) =\n                          \\<Inter>\n                           (case_negation_type ipt_iprange_to_set\n                             (\\<lambda>ip. - ipt_iprange_to_set ip) `\n                            set a))", "apply(simp add: l2wi_negation_type_intersect)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i_matches rest1 a b.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> [] \\<longrightarrow>\n                         \\<not> has_primitive b \\<and>\n                         matcheq_matchAny b \\<longrightarrow>\n                         ((\\<forall>x\\<in>set i_matches.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          (\\<Inter>x\\<in>set\n    (getPos (NegPos_map ipt_iprange_to_interval a)).\n                              case x of (i, j) \\<Rightarrow> {i..j}) -\n                          (\\<Union>x\\<in>set\n    (getNeg (NegPos_map ipt_iprange_to_interval a)).\n                              case x of (i, j) \\<Rightarrow> {i..j}) =\n                          (\\<Inter>x\\<in>set a.\n                              case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)) \\<and>\n                         ((\\<exists>x\\<in>set i_matches.\n                              \\<not> (case x of\nPos i \\<Rightarrow> match_iface i (iface_sel iface)\n| Neg i \\<Rightarrow>\n    \\<not> match_iface i (iface_sel iface))) \\<longrightarrow>\n                          (\\<forall>x\\<in>set i_matches.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          (\\<Inter>x\\<in>set\n    (getPos (NegPos_map ipt_iprange_to_interval a)).\n                              case x of (i, j) \\<Rightarrow> {i..j}) -\n                          (\\<Union>x\\<in>set\n    (getNeg (NegPos_map ipt_iprange_to_interval a)).\n                              case x of (i, j) \\<Rightarrow> {i..j}) =\n                          (\\<Inter>x\\<in>set a.\n                              case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip))", "apply(simp add: NegPos_map_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i_matches rest1 a b.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> [] \\<longrightarrow>\n                         \\<not> has_primitive b \\<and>\n                         matcheq_matchAny b \\<longrightarrow>\n                         ((\\<forall>x\\<in>set i_matches.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          (\\<Inter>a\\<in>set (getPos a).\n                              case ipt_iprange_to_interval a of\n                              (x, xa) \\<Rightarrow> {x..xa}) -\n                          (\\<Union>a\\<in>set (getNeg a).\n                              case ipt_iprange_to_interval a of\n                              (x, xa) \\<Rightarrow> {x..xa}) =\n                          (\\<Inter>x\\<in>set a.\n                              case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip)) \\<and>\n                         ((\\<exists>x\\<in>set i_matches.\n                              \\<not> (case x of\nPos i \\<Rightarrow> match_iface i (iface_sel iface)\n| Neg i \\<Rightarrow>\n    \\<not> match_iface i (iface_sel iface))) \\<longrightarrow>\n                          (\\<forall>x\\<in>set i_matches.\n                              case x of\n                              Pos i \\<Rightarrow>\n                                match_iface i (iface_sel iface)\n                              | Neg i \\<Rightarrow>\n                                  \\<not> match_iface i\n    (iface_sel iface)) \\<longrightarrow>\n                          (\\<Inter>a\\<in>set (getPos a).\n                              case ipt_iprange_to_interval a of\n                              (x, xa) \\<Rightarrow> {x..xa}) -\n                          (\\<Union>a\\<in>set (getNeg a).\n                              case ipt_iprange_to_interval a of\n                              (x, xa) \\<Rightarrow> {x..xa}) =\n                          (\\<Inter>x\\<in>set a.\n                              case x of\n                              Pos x \\<Rightarrow> ipt_iprange_to_set x\n                              | Neg ip \\<Rightarrow>\n                                  - ipt_iprange_to_set ip))", "apply(safe)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>i_matches rest1 a b x xa.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> set a;\n        x \\<in> (\\<Inter>a\\<in>set (getPos a).\n                    case ipt_iprange_to_interval a of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        x \\<notin> (\\<Union>a\\<in>set (getNeg a).\n                       case ipt_iprange_to_interval a of\n                       (x, xa) \\<Rightarrow> {x..xa})\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 2. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        x \\<in> (\\<Inter>x\\<in>set a.\n                    case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {ab..ba}\n 3. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        x \\<in> (\\<Inter>x\\<in>set a.\n                    case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> {xa..y}\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>i_matches rest1 a b x xa xb.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b; x \\<in> set i_matches;\n        \\<not> (case x of\n                Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                | Neg i \\<Rightarrow>\n                    \\<not> match_iface i (iface_sel iface));\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xb \\<in> set a;\n        xa \\<in> (\\<Inter>a\\<in>set (getPos a).\n                     case ipt_iprange_to_interval a of\n                     (x, xa) \\<Rightarrow> {x..xa});\n        xa \\<notin> (\\<Union>a\\<in>set (getNeg a).\n                        case ipt_iprange_to_interval a of\n                        (x, xa) \\<Rightarrow> {x..xa})\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> (case xb of\n                                   Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                   | Neg ip \\<Rightarrow>\n - ipt_iprange_to_set ip)\n 5. \\<And>i_matches rest1 a b x xa aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b; x \\<in> set i_matches;\n        \\<not> (case x of\n                Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                | Neg i \\<Rightarrow>\n                    \\<not> match_iface i (iface_sel iface));\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> (\\<Inter>x\\<in>set a.\n                     case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {ab..ba}\n 6. \\<And>i_matches rest1 a b x xa aa xb y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b; x \\<in> set i_matches;\n        \\<not> (case x of\n                Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n                | Neg i \\<Rightarrow>\n                    \\<not> match_iface i (iface_sel iface));\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> (\\<Inter>x\\<in>set a.\n                     case x of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                     | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xb, y);\n        xa \\<in> {xb..y}\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all add: ipt_iprange_to_interval)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i_matches rest1 a b x xa.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> set a;\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa})\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 2. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 3. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac i_matches rest1 a b x xa)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i_matches rest1 a b x xa.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> set a;\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa})\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 2. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 3. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac xa)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i_matches rest1 a b x xa x1.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> set a;\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Pos x1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 2. \\<And>i_matches rest1 a b x xa x2.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        xa \\<in> set a;\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Neg x2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (case xa of\n                                  Pos x \\<Rightarrow> ipt_iprange_to_set x\n                                  | Neg ip \\<Rightarrow>\n- ipt_iprange_to_set ip)\n 3. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 4. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all add: NegPos_set)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i_matches rest1 a b x xa x1.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        x1 \\<in> set (getPos a);\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Pos x1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set x1\n 2. \\<And>i_matches rest1 a b x xa x2.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        x2 \\<in> set (getNeg a);\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Neg x2\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ipt_iprange_to_set x2\n 3. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 4. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "using ipt_iprange_to_interval"], ["proof (prove)\nusing this:\n  ipt_iprange_to_interval ?ip = (?s, ?e) \\<Longrightarrow>\n  {?s..?e} = ipt_iprange_to_set ?ip\n\ngoal (4 subgoals):\n 1. \\<And>i_matches rest1 a b x xa x1.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        x1 \\<in> set (getPos a);\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Pos x1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set x1\n 2. \\<And>i_matches rest1 a b x xa x2.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        x2 \\<in> set (getNeg a);\n        \\<forall>xa\\<in>set (getPos a).\n           x \\<in> (case ipt_iprange_to_interval xa of\n                    (x, xa) \\<Rightarrow> {x..xa});\n        \\<forall>xa\\<in>set (getNeg a).\n           x \\<notin> (case ipt_iprange_to_interval xa of\n                       (x, xa) \\<Rightarrow> {x..xa});\n        xa = Neg x2\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ipt_iprange_to_set x2\n 3. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 4. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply fast+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 2. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac i_matches rest1 a b x aa ab ba)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getPos a);\n        ipt_iprange_to_interval aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 2. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"Pos aa\" in ballE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<in> set (getPos a); ipt_iprange_to_interval aa = (ab, ba);\n        x \\<in> (case Pos aa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                 | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 2. \\<And>i_matches rest1 a b x aa ab ba.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<in> set (getPos a); ipt_iprange_to_interval aa = (ab, ba);\n        Pos aa \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipt_iprange_to_set aa\n 3. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all add: NegPos_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        \\<forall>xa\\<in>set a.\n           x \\<in> (case xa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                    | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"Neg aa\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa;\n        x \\<in> (case Neg aa of Pos x \\<Rightarrow> ipt_iprange_to_set x\n                 | Neg ip \\<Rightarrow> - ipt_iprange_to_set ip)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i_matches rest1 a b x aa xa y.\n       \\<lbrakk>primitive_extractor (is_Iiface, iiface_sel) m =\n                (i_matches, rest1);\n        primitive_extractor (is_Src, src_sel) rest1 = (a, b); a \\<noteq> [];\n        \\<not> has_primitive b; matcheq_matchAny b;\n        \\<forall>x\\<in>set i_matches.\n           case x of Pos i \\<Rightarrow> match_iface i (iface_sel iface)\n           | Neg i \\<Rightarrow> \\<not> match_iface i (iface_sel iface);\n        aa \\<in> set (getNeg a); ipt_iprange_to_interval aa = (xa, y);\n        x \\<in> ipt_iprange_to_set aa; Neg aa \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all add: NegPos_set)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"(get_all_matching_src_ips_executable (Iface ''eth0'')\n      (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0''))))) = \n      RangeUnion (WordInterval 0 0xC0A7FFFF) (WordInterval 0xC0A80100 0xFFFFFFFF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_all_matching_src_ips_executable (Iface ''eth0'')\n     (MatchAnd\n       (MatchNot\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24))))\n       (Match (IIface (Iface ''eth0'')))) =\n    RangeUnion (WordInterval 0 3232235519)\n     (WordInterval 3232235776 4294967295)", "by eval"], ["", "text\\<open>The following algorithm sound but not complete.\\<close>"], ["", "(*alowed: set ip ips potentially allowed for iface\n    denied: set of ips definitely dropped for iface*)\n  private"], ["", "fun no_spoofing_algorithm\n    :: \"iface \\<Rightarrow> 'i::len ipassignment \\<Rightarrow> 'i common_primitive rule list \\<Rightarrow> 'i word set \\<Rightarrow> 'i word set \\<Rightarrow> bool\" where\n    \"no_spoofing_algorithm iface ipassmt [] allowed denied1  \\<longleftrightarrow> \n      (allowed - denied1) \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\" |\n    \"no_spoofing_algorithm iface ipassmt ((Rule m Accept)#rs) allowed denied1 = no_spoofing_algorithm iface ipassmt rs \n        (allowed \\<union> get_exists_matching_src_ips iface m) denied1\" |\n    \"no_spoofing_algorithm iface ipassmt ((Rule m Drop)#rs) allowed denied1 = no_spoofing_algorithm iface ipassmt rs\n         allowed (denied1 \\<union> (get_all_matching_src_ips iface m - allowed))\"  |\n    \"no_spoofing_algorithm _ _ _ _ _  = undefined\""], ["", "private"], ["", "fun no_spoofing_algorithm_executable\n    :: \"iface \\<Rightarrow> (iface \\<rightharpoonup> ('i::len word \\<times> nat) list) \\<Rightarrow> 'i common_primitive rule list\n          \\<Rightarrow> 'i wordinterval \\<Rightarrow> 'i wordinterval \\<Rightarrow> bool\" where\n    \"no_spoofing_algorithm_executable iface ipassmt [] allowed denied1  \\<longleftrightarrow> \n      wordinterval_subset (wordinterval_setminus allowed denied1) (l2wi (map ipcidr_to_interval (the (ipassmt iface))))\" |\n    \"no_spoofing_algorithm_executable iface ipassmt ((Rule m Accept)#rs) allowed denied1 = no_spoofing_algorithm_executable iface ipassmt rs \n        (wordinterval_union allowed (get_exists_matching_src_ips_executable iface m)) denied1\" |\n    \"no_spoofing_algorithm_executable iface ipassmt ((Rule m Drop)#rs) allowed denied1 = no_spoofing_algorithm_executable iface ipassmt rs\n         allowed (wordinterval_union denied1 (wordinterval_setminus (get_all_matching_src_ips_executable iface m) allowed))\"  |\n    \"no_spoofing_algorithm_executable _ _ _ _ _  = undefined\""], ["", "lemma no_spoofing_algorithm_executable: \"no_spoofing_algorithm_executable iface ipassmt rs allowed denied \\<longleftrightarrow> \n         no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed) (wordinterval_to_set denied)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing_algorithm_executable iface ipassmt rs allowed denied =\n    no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n     (wordinterval_to_set denied)", "proof(induction iface ipassmt rs allowed denied rule: no_spoofing_algorithm_executable.induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>iface ipassmt allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt [] allowed denied1 =\n       no_spoofing_algorithm iface ipassmt [] (wordinterval_to_set allowed)\n        (wordinterval_to_set denied1)\n 2. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs\n        (wordinterval_union allowed\n          (get_exists_matching_src_ips_executable iface m))\n        denied1 =\n       no_spoofing_algorithm iface ipassmt rs\n        (wordinterval_to_set\n          (wordinterval_union allowed\n            (get_exists_matching_src_ips_executable iface m)))\n        (wordinterval_to_set denied1) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Accept # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Accept # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 3. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 4. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 9. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 10. \\<And>uu_ uv_ vb va ux_ uy_.\n        no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n         uy_ =\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n         (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "case (1 iface ipassmt allowed denied1)"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>iface ipassmt allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt [] allowed denied1 =\n       no_spoofing_algorithm iface ipassmt [] (wordinterval_to_set allowed)\n        (wordinterval_to_set denied1)\n 2. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs\n        (wordinterval_union allowed\n          (get_exists_matching_src_ips_executable iface m))\n        denied1 =\n       no_spoofing_algorithm iface ipassmt rs\n        (wordinterval_to_set\n          (wordinterval_union allowed\n            (get_exists_matching_src_ips_executable iface m)))\n        (wordinterval_to_set denied1) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Accept # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Accept # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 3. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 4. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 9. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 10. \\<And>uu_ uv_ vb va ux_ uy_.\n        no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n         uy_ =\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n         (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "have \"(\\<Union>a\\<in>set (the (ipassmt iface)). case ipcidr_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) = \n          (\\<Union>x\\<in>set (the (ipassmt iface)). uncurry ipset_from_cidr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>set (the (ipassmt iface)).\n        case ipcidr_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n    \\<Union> (uncurry ipset_from_cidr ` set (the (ipassmt iface)))", "by(simp add: ipcidr_to_interval_def uncurry_def ipset_from_cidr_ipcidr_to_interval)"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>set (the (ipassmt iface)).\n      case ipcidr_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n  \\<Union> (uncurry ipset_from_cidr ` set (the (ipassmt iface)))\n\ngoal (10 subgoals):\n 1. \\<And>iface ipassmt allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt [] allowed denied1 =\n       no_spoofing_algorithm iface ipassmt [] (wordinterval_to_set allowed)\n        (wordinterval_to_set denied1)\n 2. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs\n        (wordinterval_union allowed\n          (get_exists_matching_src_ips_executable iface m))\n        denied1 =\n       no_spoofing_algorithm iface ipassmt rs\n        (wordinterval_to_set\n          (wordinterval_union allowed\n            (get_exists_matching_src_ips_executable iface m)))\n        (wordinterval_to_set denied1) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Accept # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Accept # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 3. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 4. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 9. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 10. \\<And>uu_ uv_ vb va ux_ uy_.\n        no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n         uy_ =\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n         (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "with 1"], ["proof (chain)\npicking this:\n  (\\<Union>a\\<in>set (the (ipassmt iface)).\n      case ipcidr_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n  \\<Union> (uncurry ipset_from_cidr ` set (the (ipassmt iface)))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Union>a\\<in>set (the (ipassmt iface)).\n      case ipcidr_to_interval a of (x, xa) \\<Rightarrow> {x..xa}) =\n  \\<Union> (uncurry ipset_from_cidr ` set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. no_spoofing_algorithm_executable iface ipassmt [] allowed denied1 =\n    no_spoofing_algorithm iface ipassmt [] (wordinterval_to_set allowed)\n     (wordinterval_to_set denied1)", "by(simp add: ipcidr_union_set_uncurry l2wi)"], ["proof (state)\nthis:\n  no_spoofing_algorithm_executable iface ipassmt [] allowed denied1 =\n  no_spoofing_algorithm iface ipassmt [] (wordinterval_to_set allowed)\n   (wordinterval_to_set denied1)\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs\n        (wordinterval_union allowed\n          (get_exists_matching_src_ips_executable iface m))\n        denied1 =\n       no_spoofing_algorithm iface ipassmt rs\n        (wordinterval_to_set\n          (wordinterval_union allowed\n            (get_exists_matching_src_ips_executable iface m)))\n        (wordinterval_to_set denied1) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Accept # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Accept # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 2. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 3. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 4. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 9. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs\n        (wordinterval_union allowed\n          (get_exists_matching_src_ips_executable iface m))\n        denied1 =\n       no_spoofing_algorithm iface ipassmt rs\n        (wordinterval_to_set\n          (wordinterval_union allowed\n            (get_exists_matching_src_ips_executable iface m)))\n        (wordinterval_to_set denied1) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Accept # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Accept # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 2. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 3. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 4. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 9. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "case 2"], ["proof (state)\nthis:\n  no_spoofing_algorithm_executable iface_ ipassmt_ rs_\n   (wordinterval_union allowed_\n     (get_exists_matching_src_ips_executable iface_ m_))\n   denied1_ =\n  no_spoofing_algorithm iface_ ipassmt_ rs_\n   (wordinterval_to_set\n     (wordinterval_union allowed_\n       (get_exists_matching_src_ips_executable iface_ m_)))\n   (wordinterval_to_set denied1_)\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs\n        (wordinterval_union allowed\n          (get_exists_matching_src_ips_executable iface m))\n        denied1 =\n       no_spoofing_algorithm iface ipassmt rs\n        (wordinterval_to_set\n          (wordinterval_union allowed\n            (get_exists_matching_src_ips_executable iface m)))\n        (wordinterval_to_set denied1) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Accept # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Accept # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 2. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 3. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 4. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 9. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "thus ?case"], ["proof (prove)\nusing this:\n  no_spoofing_algorithm_executable iface_ ipassmt_ rs_\n   (wordinterval_union allowed_\n     (get_exists_matching_src_ips_executable iface_ m_))\n   denied1_ =\n  no_spoofing_algorithm iface_ ipassmt_ rs_\n   (wordinterval_to_set\n     (wordinterval_union allowed_\n       (get_exists_matching_src_ips_executable iface_ m_)))\n   (wordinterval_to_set denied1_)\n\ngoal (1 subgoal):\n 1. no_spoofing_algorithm_executable iface_ ipassmt_ (Rule m_ Accept # rs_)\n     allowed_ denied1_ =\n    no_spoofing_algorithm iface_ ipassmt_ (Rule m_ Accept # rs_)\n     (wordinterval_to_set allowed_) (wordinterval_to_set denied1_)", "by(simp add: get_exists_matching_src_ips_executable get_all_matching_src_ips_executable)"], ["proof (state)\nthis:\n  no_spoofing_algorithm_executable iface_ ipassmt_ (Rule m_ Accept # rs_)\n   allowed_ denied1_ =\n  no_spoofing_algorithm iface_ ipassmt_ (Rule m_ Accept # rs_)\n   (wordinterval_to_set allowed_) (wordinterval_to_set denied1_)\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 2. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 3. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 4. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 2. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 3. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 4. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "case 3"], ["proof (state)\nthis:\n  no_spoofing_algorithm_executable iface_ ipassmt_ rs_ allowed_\n   (wordinterval_union denied1_\n     (wordinterval_setminus (get_all_matching_src_ips_executable iface_ m_)\n       allowed_)) =\n  no_spoofing_algorithm iface_ ipassmt_ rs_ (wordinterval_to_set allowed_)\n   (wordinterval_to_set\n     (wordinterval_union denied1_\n       (wordinterval_setminus\n         (get_all_matching_src_ips_executable iface_ m_) allowed_)))\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1.\n       no_spoofing_algorithm_executable iface ipassmt rs allowed\n        (wordinterval_union denied1\n          (wordinterval_setminus\n            (get_all_matching_src_ips_executable iface m) allowed)) =\n       no_spoofing_algorithm iface ipassmt rs (wordinterval_to_set allowed)\n        (wordinterval_to_set\n          (wordinterval_union denied1\n            (wordinterval_setminus\n              (get_all_matching_src_ips_executable iface m)\n              allowed))) \\<Longrightarrow>\n       no_spoofing_algorithm_executable iface ipassmt (Rule m Drop # rs)\n        allowed denied1 =\n       no_spoofing_algorithm iface ipassmt (Rule m Drop # rs)\n        (wordinterval_to_set allowed) (wordinterval_to_set denied1)\n 2. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 3. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 4. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 8. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "thus ?case"], ["proof (prove)\nusing this:\n  no_spoofing_algorithm_executable iface_ ipassmt_ rs_ allowed_\n   (wordinterval_union denied1_\n     (wordinterval_setminus (get_all_matching_src_ips_executable iface_ m_)\n       allowed_)) =\n  no_spoofing_algorithm iface_ ipassmt_ rs_ (wordinterval_to_set allowed_)\n   (wordinterval_to_set\n     (wordinterval_union denied1_\n       (wordinterval_setminus\n         (get_all_matching_src_ips_executable iface_ m_) allowed_)))\n\ngoal (1 subgoal):\n 1. no_spoofing_algorithm_executable iface_ ipassmt_ (Rule m_ Drop # rs_)\n     allowed_ denied1_ =\n    no_spoofing_algorithm iface_ ipassmt_ (Rule m_ Drop # rs_)\n     (wordinterval_to_set allowed_) (wordinterval_to_set denied1_)", "by(simp add: get_exists_matching_src_ips_executable get_all_matching_src_ips_executable)"], ["proof (state)\nthis:\n  no_spoofing_algorithm_executable iface_ ipassmt_ (Rule m_ Drop # rs_)\n   allowed_ denied1_ =\n  no_spoofing_algorithm iface_ ipassmt_ (Rule m_ Drop # rs_)\n   (wordinterval_to_set allowed_) (wordinterval_to_set denied1_)\n\ngoal (7 subgoals):\n 1. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Log # va) ux_ uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Log # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 2. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Reject # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 3. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Call vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 4. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Return # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Return # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 5. \\<And>uu_ uv_ vb vd va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb (Goto vd) # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 6. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Empty # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)\n 7. \\<And>uu_ uv_ vb va ux_ uy_.\n       no_spoofing_algorithm_executable uu_ uv_ (Rule vb Unknown # va) ux_\n        uy_ =\n       no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va)\n        (wordinterval_to_set ux_) (wordinterval_to_set uy_)", "qed(simp_all)"], ["", "private"], ["", "definition \"nospoof TYPE('pkt_ext) iface ipassmt rs = (\\<forall>p :: ('i::len,'pkt_ext) tagged_packet_scheme.\n          (approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface:=iface_sel iface\\<rparr>) rs Undecided = Decision FinalAllow) \\<longrightarrow>\n              p_src p \\<in> (ipcidr_union_set (set (the (ipassmt iface)))))\""], ["", "private"], ["", "definition \"setbydecision TYPE('pkt_ext) iface rs dec = {ip. \\<exists>p :: ('i::len,'pkt_ext) tagged_packet_scheme. approximating_bigstep_fun (common_matcher, in_doubt_allow) \n                           (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs Undecided = Decision dec}\""], ["", "private"], ["", "lemma nospoof_setbydecision:\n    fixes rs :: \"'i::len common_primitive rule list\"\n    shows \"nospoof TYPE('pkt_ext) iface ipassmt rs \\<longleftrightarrow> \n          setbydecision TYPE('pkt_ext) iface rs FinalAllow \\<subseteq> (ipcidr_union_set (set (the (ipassmt iface))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) iface ipassmt rs =\n    (setbydecision TYPE('pkt_ext) iface rs FinalAllow\n     \\<subseteq> ipcidr_union_set (set (the (ipassmt iface))))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nospoof TYPE('pkt_ext) iface ipassmt rs \\<Longrightarrow>\n    setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n 2. setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set\n                 (set (the (ipassmt iface))) \\<Longrightarrow>\n    nospoof TYPE('pkt_ext) iface ipassmt rs", "assume a: \"nospoof TYPE('pkt_ext) iface ipassmt rs\""], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) iface ipassmt rs\n\ngoal (2 subgoals):\n 1. nospoof TYPE('pkt_ext) iface ipassmt rs \\<Longrightarrow>\n    setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n 2. setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set\n                 (set (the (ipassmt iface))) \\<Longrightarrow>\n    nospoof TYPE('pkt_ext) iface ipassmt rs", "have packet_update_iface_simp: \"p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr> = p\\<lparr>p_src := x, p_iiface := iface_sel iface\\<rparr>\"\n      for p::\"('i::len, 'p) tagged_packet_scheme\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr> = p\n    \\<lparr>p_src := x, p_iiface := iface_sel iface\\<rparr>", "by simp"], ["proof (state)\nthis:\n  ?p1\\<lparr>p_iiface := iface_sel iface, p_src := ?x1\\<rparr> = ?p1\n  \\<lparr>p_src := ?x1, p_iiface := iface_sel iface\\<rparr>\n\ngoal (2 subgoals):\n 1. nospoof TYPE('pkt_ext) iface ipassmt rs \\<Longrightarrow>\n    setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n 2. setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set\n                 (set (the (ipassmt iface))) \\<Longrightarrow>\n    nospoof TYPE('pkt_ext) iface ipassmt rs", "from a"], ["proof (chain)\npicking this:\n  nospoof TYPE('pkt_ext) iface ipassmt rs", "show \"setbydecision TYPE('pkt_ext) iface rs FinalAllow \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\nusing this:\n  nospoof TYPE('pkt_ext) iface ipassmt rs\n\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "apply(simp add: nospoof_def setbydecision_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       approximating_bigstep_fun (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n       Decision FinalAllow \\<longrightarrow>\n       p_src p\n       \\<in> ipcidr_union_set (set (the (ipassmt iface))) \\<Longrightarrow>\n    {ip.\n     \\<exists>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n         Undecided =\n        Decision FinalAllow}\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "apply(safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<forall>p.\n                   approximating_bigstep_fun\n                    (common_matcher, in_doubt_allow)\n                    (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs\n                    Undecided =\n                   Decision FinalAllow \\<longrightarrow>\n                   p_src p\n                   \\<in> ipcidr_union_set (set (the (ipassmt iface)));\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs\n         Undecided =\n        Decision FinalAllow\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipcidr_union_set\n                                  (set (the (ipassmt iface)))", "apply(rename_tac x p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<forall>p.\n                   approximating_bigstep_fun\n                    (common_matcher, in_doubt_allow)\n                    (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs\n                    Undecided =\n                   Decision FinalAllow \\<longrightarrow>\n                   p_src p\n                   \\<in> ipcidr_union_set (set (the (ipassmt iface)));\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs\n         Undecided =\n        Decision FinalAllow\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipcidr_union_set\n                                  (set (the (ipassmt iface)))", "apply(erule_tac x=\"p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>approximating_bigstep_fun (common_matcher, in_doubt_allow)\n                 (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>)\n                 rs Undecided =\n                Decision FinalAllow;\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x,\n              p_iiface := iface_sel iface\\<rparr>)\n         rs Undecided =\n        Decision FinalAllow \\<longrightarrow>\n        p_src (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>)\n        \\<in> ipcidr_union_set (set (the (ipassmt iface)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipcidr_union_set\n                                  (set (the (ipassmt iface)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>approximating_bigstep_fun (common_matcher, in_doubt_allow)\n                 (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>)\n                 rs Undecided =\n                Decision FinalAllow;\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_src := x, p_iiface := iface_sel iface\\<rparr>) rs\n         Undecided =\n        Decision FinalAllow \\<longrightarrow>\n        x \\<in> ipcidr_union_set (set (the (ipassmt iface)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ipcidr_union_set\n                                  (set (the (ipassmt iface)))", "apply(simp add: packet_update_iface_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  setbydecision TYPE('pkt_ext) iface rs FinalAllow\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set\n                 (set (the (ipassmt iface))) \\<Longrightarrow>\n    nospoof TYPE('pkt_ext) iface ipassmt rs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set\n                 (set (the (ipassmt iface))) \\<Longrightarrow>\n    nospoof TYPE('pkt_ext) iface ipassmt rs", "assume a1: \"setbydecision TYPE('pkt_ext) iface rs FinalAllow \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (state)\nthis:\n  setbydecision TYPE('pkt_ext) iface rs FinalAllow\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface rs FinalAllow\n    \\<subseteq> ipcidr_union_set\n                 (set (the (ipassmt iface))) \\<Longrightarrow>\n    nospoof TYPE('pkt_ext) iface ipassmt rs", "show \"nospoof TYPE('pkt_ext) iface ipassmt rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) iface ipassmt rs", "unfolding nospoof_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       approximating_bigstep_fun (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n       Decision FinalAllow \\<longrightarrow>\n       p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "proof(safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       approximating_bigstep_fun (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n       Decision FinalAllow \\<Longrightarrow>\n       p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "fix p :: \"('i::len,'pkt_ext) tagged_packet_scheme\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       approximating_bigstep_fun (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n       Decision FinalAllow \\<Longrightarrow>\n       p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "assume a2: \"approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided = Decision FinalAllow\"\n        \\<comment> \\<open>In @{text setbydecision_fix_p}the @{text \\<exists>} quantifier is gone and we consider this set for @{term p}.\\<close>"], ["proof (state)\nthis:\n  approximating_bigstep_fun (common_matcher, in_doubt_allow)\n   (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n  Decision FinalAllow\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       approximating_bigstep_fun (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n       Decision FinalAllow \\<Longrightarrow>\n       p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "let ?setbydecision_fix_p=\"{ip. approximating_bigstep_fun (common_matcher, in_doubt_allow) \n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs Undecided = Decision FinalAllow}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       approximating_bigstep_fun (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n       Decision FinalAllow \\<Longrightarrow>\n       p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "from a1 a2"], ["proof (chain)\npicking this:\n  setbydecision TYPE('pkt_ext) iface rs FinalAllow\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n  approximating_bigstep_fun (common_matcher, in_doubt_allow)\n   (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n  Decision FinalAllow", "have 1: \"?setbydecision_fix_p \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\nusing this:\n  setbydecision TYPE('pkt_ext) iface rs FinalAllow\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n  approximating_bigstep_fun (common_matcher, in_doubt_allow)\n   (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n  Decision FinalAllow\n\ngoal (1 subgoal):\n 1. {ip.\n     approximating_bigstep_fun (common_matcher, in_doubt_allow)\n      (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n      Undecided =\n     Decision FinalAllow}\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "by(simp add: nospoof_def setbydecision_def) blast"], ["proof (state)\nthis:\n  {ip.\n   approximating_bigstep_fun (common_matcher, in_doubt_allow)\n    (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n    Undecided =\n   Decision FinalAllow}\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       approximating_bigstep_fun (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n       Decision FinalAllow \\<Longrightarrow>\n       p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "from a2"], ["proof (chain)\npicking this:\n  approximating_bigstep_fun (common_matcher, in_doubt_allow)\n   (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n  Decision FinalAllow", "have 2: \"p_src p \\<in> ?setbydecision_fix_p\""], ["proof (prove)\nusing this:\n  approximating_bigstep_fun (common_matcher, in_doubt_allow)\n   (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n  Decision FinalAllow\n\ngoal (1 subgoal):\n 1. p_src p\n    \\<in> {ip.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n            Undecided =\n           Decision FinalAllow}", "by simp"], ["proof (state)\nthis:\n  p_src p\n  \\<in> {ip.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n          Undecided =\n         Decision FinalAllow}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       approximating_bigstep_fun (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n       Decision FinalAllow \\<Longrightarrow>\n       p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "from 1 2"], ["proof (chain)\npicking this:\n  {ip.\n   approximating_bigstep_fun (common_matcher, in_doubt_allow)\n    (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n    Undecided =\n   Decision FinalAllow}\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n  p_src p\n  \\<in> {ip.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n          Undecided =\n         Decision FinalAllow}", "show \"p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\nusing this:\n  {ip.\n   approximating_bigstep_fun (common_matcher, in_doubt_allow)\n    (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n    Undecided =\n   Decision FinalAllow}\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n  p_src p\n  \\<in> {ip.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n          Undecided =\n         Decision FinalAllow}\n\ngoal (1 subgoal):\n 1. p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))", "by blast"], ["proof (state)\nthis:\n  p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) iface ipassmt rs\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition \"setbydecision_all TYPE('pkt_ext) iface rs dec = {ip. \\<forall>p :: ('i::len,'pkt_ext) tagged_packet_scheme.\n    approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs Undecided = Decision dec}\""], ["", "private"], ["", "lemma setbydecision_setbydecision_all_Allow: \n    \"(setbydecision TYPE('pkt_ext) iface rs FinalAllow - setbydecision_all TYPE('pkt_ext) iface rs FinalDeny) = \n      setbydecision TYPE('pkt_ext) iface rs FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface rs FinalAllow -\n    setbydecision_all TYPE('pkt_ext) iface rs FinalDeny =\n    setbydecision TYPE('pkt_ext) iface rs FinalAllow", "apply(safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> setbydecision TYPE('pkt_ext) iface rs FinalAllow;\n        x \\<in> setbydecision_all TYPE('pkt_ext) iface rs FinalDeny\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: setbydecision_def setbydecision_all_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma setbydecision_setbydecision_all_Deny: \n    \"(setbydecision TYPE('pkt_ext) iface rs FinalDeny - setbydecision_all TYPE('pkt_ext) iface rs FinalAllow) = \n      setbydecision TYPE('pkt_ext) iface rs FinalDeny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface rs FinalDeny -\n    setbydecision_all TYPE('pkt_ext) iface rs FinalAllow =\n    setbydecision TYPE('pkt_ext) iface rs FinalDeny", "apply(safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> setbydecision TYPE('pkt_ext) iface rs FinalDeny;\n        x \\<in> setbydecision_all TYPE('pkt_ext) iface rs\n                 FinalAllow\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: setbydecision_def setbydecision_all_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma setbydecision_append:\n    \"simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n      setbydecision TYPE('pkt_ext) iface (rs1 @ rs2) FinalAllow =\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<union> {ip. \\<exists>p :: ('i::len,'pkt_ext) tagged_packet_scheme. approximating_bigstep_fun (common_matcher, in_doubt_allow) \n         (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs2 Undecided = Decision FinalAllow \\<and>\n          approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs1 Undecided = Undecided}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    setbydecision TYPE('pkt_ext) iface (rs1 @ rs2) FinalAllow =\n    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<union>\n    {ip.\n     \\<exists>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n         Undecided =\n        Decision FinalAllow \\<and>\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}", "apply(simp add: setbydecision_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    {ip.\n     \\<exists>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n         (rs1 @ rs2) Undecided =\n        Decision FinalAllow} =\n    {ip.\n     \\<exists>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Decision FinalAllow} \\<union>\n    {ip.\n     \\<exists>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n         Undecided =\n        Decision FinalAllow \\<and>\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}", "apply(subst Set.Collect_disj_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    {ip.\n     \\<exists>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n         (rs1 @ rs2) Undecided =\n        Decision FinalAllow} =\n    {x. (\\<exists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalAllow) \\<or>\n        (\\<exists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalAllow \\<and>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided)}", "apply(rule Set.Collect_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<exists>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n            (rs1 @ rs2) Undecided =\n           Decision FinalAllow) =\n       ((\\<exists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n             Undecided =\n            Decision FinalAllow) \\<or>\n        (\\<exists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n             Undecided =\n            Decision FinalAllow \\<and>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n             Undecided =\n            Undecided))", "apply(subst approximating_bigstep_fun_seq_Undecided_t_wf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ip p.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       wf_ruleset (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n        (rs1 @ rs2)\n 2. \\<And>ip.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<exists>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n            Undecided =\n           Undecided \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n            Undecided =\n           Decision FinalAllow \\<or>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n            Undecided =\n           Decision FinalAllow \\<and>\n           Decision FinalAllow \\<noteq> Undecided) =\n       ((\\<exists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n             Undecided =\n            Decision FinalAllow) \\<or>\n        (\\<exists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n             Undecided =\n            Decision FinalAllow \\<and>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n             Undecided =\n            Undecided))", "apply(simp add: simple_imp_good_ruleset good_imp_wf_ruleset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<exists>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n            Undecided =\n           Undecided \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n            Undecided =\n           Decision FinalAllow \\<or>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n            Undecided =\n           Decision FinalAllow \\<and>\n           Decision FinalAllow \\<noteq> Undecided) =\n       ((\\<exists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n             Undecided =\n            Decision FinalAllow) \\<or>\n        (\\<exists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n             Undecided =\n            Decision FinalAllow \\<and>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n             Undecided =\n            Undecided))", "by blast"], ["", "private"], ["", "lemma not_FinalAllow: \"foo \\<noteq> Decision FinalAllow \\<longleftrightarrow> foo = Decision FinalDeny \\<or> foo = Undecided\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foo \\<noteq> Decision FinalAllow) =\n    (foo = Decision FinalDeny \\<or> foo = Undecided)", "apply(cases foo)"], ["proof (prove)\ngoal (2 subgoals):\n 1. foo = Undecided \\<Longrightarrow>\n    (foo \\<noteq> Decision FinalAllow) =\n    (foo = Decision FinalDeny \\<or> foo = Undecided)\n 2. \\<And>x2.\n       foo = Decision x2 \\<Longrightarrow>\n       (foo \\<noteq> Decision FinalAllow) =\n       (foo = Decision FinalDeny \\<or> foo = Undecided)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       foo = Decision x2 \\<Longrightarrow>\n       (x2 \\<noteq> FinalAllow) = (x2 = FinalDeny)", "apply(rename_tac x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       foo = Decision x2 \\<Longrightarrow>\n       (x2 \\<noteq> FinalAllow) = (x2 = FinalDeny)", "apply(case_tac x2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>foo = Decision x2; x2 = FinalAllow\\<rbrakk>\n       \\<Longrightarrow> (x2 \\<noteq> FinalAllow) = (x2 = FinalDeny)\n 2. \\<And>x2.\n       \\<lbrakk>foo = Decision x2; x2 = FinalDeny\\<rbrakk>\n       \\<Longrightarrow> (x2 \\<noteq> FinalAllow) = (x2 = FinalDeny)", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma setbydecision_all_appendAccept: \"simple_ruleset (rs @ [Rule r Accept]) \\<Longrightarrow> \n    setbydecision_all TYPE('pkt_ext) iface rs FinalDeny = setbydecision_all TYPE('pkt_ext) iface (rs @ [Rule r Accept]) FinalDeny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs @ [Rule r Accept]) \\<Longrightarrow>\n    setbydecision_all TYPE('pkt_ext) iface rs FinalDeny =\n    setbydecision_all TYPE('pkt_ext) iface (rs @ [Rule r Accept]) FinalDeny", "apply(simp add: setbydecision_all_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs @ [Rule r Accept]) \\<Longrightarrow>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n         Undecided =\n        Decision FinalDeny} =\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n         (rs @ [Rule r Accept]) Undecided =\n        Decision FinalDeny}", "apply(rule Set.Collect_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip.\n       simple_ruleset (rs @ [Rule r Accept]) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n            Undecided =\n           Decision FinalDeny) =\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n            (rs @ [Rule r Accept]) Undecided =\n           Decision FinalDeny)", "apply(subst approximating_bigstep_fun_seq_Undecided_t_wf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ip p.\n       simple_ruleset (rs @ [Rule r Accept]) \\<Longrightarrow>\n       wf_ruleset (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n        (rs @ [Rule r Accept])\n 2. \\<And>ip.\n       simple_ruleset (rs @ [Rule r Accept]) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n            Undecided =\n           Decision FinalDeny) =\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n            Undecided =\n           Undecided \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n            [Rule r Accept] Undecided =\n           Decision FinalDeny \\<or>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n            Undecided =\n           Decision FinalDeny \\<and>\n           Decision FinalDeny \\<noteq> Undecided)", "apply(simp add: simple_imp_good_ruleset good_imp_wf_ruleset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip.\n       simple_ruleset (rs @ [Rule r Accept]) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n            Undecided =\n           Decision FinalDeny) =\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n            Undecided =\n           Undecided \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)\n            [Rule r Accept] Undecided =\n           Decision FinalDeny \\<or>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n            Undecided =\n           Decision FinalDeny \\<and>\n           Decision FinalDeny \\<noteq> Undecided)", "apply(simp add: not_FinalAllow)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma setbydecision_all_append_subset: \"simple_ruleset (rs1 @ rs2) \\<Longrightarrow> \n            setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union> {ip. \\<forall>p :: ('i::len,'pkt_ext) tagged_packet_scheme.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs2 Undecided = Decision FinalDeny \\<and>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface:=iface_sel iface, p_src := ip\\<rparr>) rs1 Undecided = Undecided}\n            \\<subseteq>\n            setbydecision_all TYPE('pkt_ext) iface (rs1 @ rs2) FinalDeny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n         Undecided =\n        Decision FinalDeny \\<and>\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}\n    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ rs2) FinalDeny", "unfolding setbydecision_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Decision FinalDeny} \\<union>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n         Undecided =\n        Decision FinalDeny \\<and>\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}\n    \\<subseteq> {ip.\n                 \\<forall>p.\n                    approximating_bigstep_fun\n                     (common_matcher, in_doubt_allow)\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)\n                     (rs1 @ rs2) Undecided =\n                    Decision FinalDeny}", "apply(subst Set.Collect_disj_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    {x. (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny \\<and>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided)}\n    \\<subseteq> {ip.\n                 \\<forall>p.\n                    approximating_bigstep_fun\n                     (common_matcher, in_doubt_allow)\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)\n                     (rs1 @ rs2) Undecided =\n                    Decision FinalDeny}", "apply(rule Set.Collect_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny) \\<or>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Undecided) \\<longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>)\n            (rs1 @ rs2) Undecided =\n           Decision FinalDeny)", "apply(subst approximating_bigstep_fun_seq_Undecided_t_wf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x p.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       wf_ruleset (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>)\n        (rs1 @ rs2)\n 2. \\<And>x.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny) \\<or>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Undecided) \\<longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Undecided \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny \\<or>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny \\<and>\n           Decision FinalDeny \\<noteq> Undecided)", "apply(simp add: simple_imp_good_ruleset good_imp_wf_ruleset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny) \\<or>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Undecided) \\<longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Undecided \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny \\<or>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny \\<and>\n           Decision FinalDeny \\<noteq> Undecided)", "apply(simp add: not_FinalAllow)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma \"setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n                 {ip. \\<forall>p :: ('i::len,'pkt_ext) tagged_packet_scheme.\n                 approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1 Undecided = Undecided}\n                 \\<subseteq>\n                 - setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}\n    \\<subseteq> - setbydecision TYPE('pkt_ext) iface rs1 FinalAllow", "unfolding setbydecision_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Decision FinalDeny} \\<union>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}\n    \\<subseteq> - setbydecision TYPE('pkt_ext) iface rs1 FinalAllow", "unfolding setbydecision_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Decision FinalDeny} \\<union>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}\n    \\<subseteq> - {ip.\n                   \\<exists>p.\n                      approximating_bigstep_fun\n                       (common_matcher, in_doubt_allow)\n                       (p\\<lparr>p_iiface := iface_sel iface,\n                            p_src := ip\\<rparr>)\n                       rs1 Undecided =\n                      Decision FinalAllow}", "apply(subst Set.Collect_neg_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Decision FinalDeny} \\<union>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}\n    \\<subseteq> {x. \\<nexists>p.\n                       approximating_bigstep_fun\n                        (common_matcher, in_doubt_allow)\n                        (p\\<lparr>p_iiface := iface_sel iface,\n                             p_src := x\\<rparr>)\n                        rs1 Undecided =\n                       Decision FinalAllow}", "apply(subst Set.Collect_disj_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided)}\n    \\<subseteq> {x. \\<nexists>p.\n                       approximating_bigstep_fun\n                        (common_matcher, in_doubt_allow)\n                        (p\\<lparr>p_iiface := iface_sel iface,\n                             p_src := x\\<rparr>)\n                        rs1 Undecided =\n                       Decision FinalAllow}", "apply(rule Set.Collect_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny) \\<or>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Undecided) \\<longrightarrow>\n       (\\<nexists>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalAllow)", "by(simp)"], ["", "private"], ["", "lemma Collect_minus_eq: \"{x. P x} - {x. Q x} = {x. P x \\<and> \\<not> Q x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. P x} - {x. Q x} = {x. P x \\<and> \\<not> Q x}", "by blast"], ["", "private"], ["", "lemma setbydecision_all_append_subset2:\n      \"simple_ruleset (rs1 @ rs2) \\<Longrightarrow> \n       setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union> \n      (setbydecision_all TYPE('pkt_ext) iface rs2 FinalDeny - \n       setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)\n     \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ rs2) FinalDeny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n    (setbydecision_all TYPE('pkt_ext) iface rs2 FinalDeny -\n     setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)\n    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ rs2) FinalDeny", "unfolding setbydecision_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Decision FinalDeny} \\<union>\n    ({ip.\n      \\<forall>p.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n          Undecided =\n         Decision FinalDeny} -\n     setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)\n    \\<subseteq> {ip.\n                 \\<forall>p.\n                    approximating_bigstep_fun\n                     (common_matcher, in_doubt_allow)\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)\n                     (rs1 @ rs2) Undecided =\n                    Decision FinalDeny}", "unfolding setbydecision_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Decision FinalDeny} \\<union>\n    ({ip.\n      \\<forall>p.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs2\n          Undecided =\n         Decision FinalDeny} -\n     {ip.\n      \\<exists>p.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n          Undecided =\n         Decision FinalAllow})\n    \\<subseteq> {ip.\n                 \\<forall>p.\n                    approximating_bigstep_fun\n                     (common_matcher, in_doubt_allow)\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)\n                     (rs1 @ rs2) Undecided =\n                    Decision FinalDeny}", "apply(subst Collect_minus_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Decision FinalDeny} \\<union>\n    {x. (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<nexists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalAllow)}\n    \\<subseteq> {ip.\n                 \\<forall>p.\n                    approximating_bigstep_fun\n                     (common_matcher, in_doubt_allow)\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)\n                     (rs1 @ rs2) Undecided =\n                    Decision FinalDeny}", "apply(subst Set.Collect_disj_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n    {x. (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<nexists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalAllow)}\n    \\<subseteq> {ip.\n                 \\<forall>p.\n                    approximating_bigstep_fun\n                     (common_matcher, in_doubt_allow)\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)\n                     (rs1 @ rs2) Undecided =\n                    Decision FinalDeny}", "apply(rule Set.Collect_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny) \\<or>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny) \\<and>\n       (\\<nexists>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalAllow) \\<longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>)\n            (rs1 @ rs2) Undecided =\n           Decision FinalDeny)", "apply(subst approximating_bigstep_fun_seq_Undecided_t_wf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x p.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       wf_ruleset (common_matcher, in_doubt_allow)\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>)\n        (rs1 @ rs2)\n 2. \\<And>x.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny) \\<or>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny) \\<and>\n       (\\<nexists>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalAllow) \\<longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Undecided \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny \\<or>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny \\<and>\n           Decision FinalDeny \\<noteq> Undecided)", "apply(simp add: simple_imp_good_ruleset good_imp_wf_ruleset; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       simple_ruleset (rs1 @ rs2) \\<Longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny) \\<or>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny) \\<and>\n       (\\<nexists>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalAllow) \\<longrightarrow>\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Undecided \\<and>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n            Undecided =\n           Decision FinalDeny \\<or>\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny \\<and>\n           Decision FinalDeny \\<noteq> Undecided)", "apply(intro impI allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<nexists>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalAllow)\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny \\<and>\n                         Decision FinalDeny \\<noteq> Undecided", "apply(simp add: not_FinalAllow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided)\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "apply(case_tac \"approximating_bigstep_fun (common_matcher, in_doubt_allow) (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1 Undecided\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x p.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Undecided\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny\n 2. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_ruleset (rs1 @ rs2);\n     (\\<forall>p.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := x_\\<rparr>) rs1\n          Undecided =\n         Decision FinalDeny) \\<or>\n     (\\<forall>p.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := x_\\<rparr>) rs2\n          Undecided =\n         Decision FinalDeny) \\<and>\n     (\\<forall>p.\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := x_\\<rparr>) rs1\n          Undecided =\n         Decision FinalDeny \\<or>\n         approximating_bigstep_fun (common_matcher, in_doubt_allow)\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := x_\\<rparr>) rs1\n          Undecided =\n         Undecided);\n     approximating_bigstep_fun (common_matcher, in_doubt_allow)\n      (p_\\<lparr>p_iiface := iface_sel iface, p_src := x_\\<rparr>) rs1\n      Undecided =\n     Undecided\\<rbrakk>\n    \\<Longrightarrow> approximating_bigstep_fun\n                       (common_matcher, in_doubt_allow)\n                       (p_\\<lparr>p_iiface := iface_sel iface,\n                             p_src := x_\\<rparr>)\n                       rs1 Undecided =\n                      Undecided \\<and>\n                      approximating_bigstep_fun\n                       (common_matcher, in_doubt_allow)\n                       (p_\\<lparr>p_iiface := iface_sel iface,\n                             p_src := x_\\<rparr>)\n                       rs2 Undecided =\n                      Decision FinalDeny \\<or>\n                      approximating_bigstep_fun\n                       (common_matcher, in_doubt_allow)\n                       (p_\\<lparr>p_iiface := iface_sel iface,\n                             p_src := x_\\<rparr>)\n                       rs1 Undecided =\n                      Decision FinalDeny", "by(elim disjE) simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "apply(rename_tac x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "apply(case_tac x2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2;\n        x2 = FinalAllow\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny\n 2. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2;\n        x2 = FinalDeny\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2;\n        x2 = FinalDeny\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny\n 2. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2;\n        x2 = FinalAllow\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny) \\<or>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2;\n        x2 = FinalAllow\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "apply(elim disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2;\n        x2 = FinalAllow;\n        \\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n            Undecided =\n           Decision FinalDeny\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny\n 2. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2;\n        x2 = FinalAllow;\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided)\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p x2.\n       \\<lbrakk>simple_ruleset (rs1 @ rs2);\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n         Undecided =\n        Decision x2;\n        x2 = FinalAllow;\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs2\n             Undecided =\n            Decision FinalDeny) \\<and>\n        (\\<forall>p.\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Decision FinalDeny \\<or>\n            approximating_bigstep_fun (common_matcher, in_doubt_allow)\n             (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs1\n             Undecided =\n            Undecided)\\<rbrakk>\n       \\<Longrightarrow> approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Undecided \\<and>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs2 Undecided =\n                         Decision FinalDeny \\<or>\n                         approximating_bigstep_fun\n                          (common_matcher, in_doubt_allow)\n                          (p\\<lparr>p_iiface := iface_sel iface,\n                               p_src := x\\<rparr>)\n                          rs1 Undecided =\n                         Decision FinalDeny", "by blast"], ["", "private"], ["", "lemma \"setbydecision_all TYPE('pkt_ext) iface rs FinalDeny \\<subseteq> - setbydecision TYPE('pkt_ext) iface rs FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setbydecision_all TYPE('pkt_ext) iface rs FinalDeny\n    \\<subseteq> - setbydecision TYPE('pkt_ext) iface rs FinalAllow", "apply(simp add: setbydecision_def setbydecision_all_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n         Undecided =\n        Decision FinalDeny}\n    \\<subseteq> - {ip.\n                   \\<exists>p.\n                      approximating_bigstep_fun\n                       (common_matcher, in_doubt_allow)\n                       (p\\<lparr>p_iiface := iface_sel iface,\n                            p_src := ip\\<rparr>)\n                       rs Undecided =\n                      Decision FinalAllow}", "apply(subst Set.Collect_neg_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ip.\n     \\<forall>p.\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs\n         Undecided =\n        Decision FinalDeny}\n    \\<subseteq> {x. \\<nexists>p.\n                       approximating_bigstep_fun\n                        (common_matcher, in_doubt_allow)\n                        (p\\<lparr>p_iiface := iface_sel iface,\n                             p_src := x\\<rparr>)\n                        rs Undecided =\n                       Decision FinalAllow}", "apply(rule Set.Collect_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs\n            Undecided =\n           Decision FinalDeny) \\<longrightarrow>\n       (\\<nexists>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface, p_src := x\\<rparr>) rs\n            Undecided =\n           Decision FinalAllow)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma no_spoofing_algorithm_sound_generalized:\n  fixes rs1 :: \"'i::len common_primitive rule list\"\n  shows \"simple_ruleset rs1 \\<Longrightarrow> simple_ruleset rs2 \\<Longrightarrow>\n        (\\<forall>r \\<in> set rs2. normalized_nnf_match (get_match r)) \\<Longrightarrow>\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed \\<Longrightarrow>\n        denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<Longrightarrow>\n        no_spoofing_algorithm iface ipassmt rs2 allowed denied1 \\<Longrightarrow>\n        nospoof TYPE('pkt_ext) iface ipassmt (rs1@rs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_ruleset rs1; simple_ruleset rs2;\n     \\<forall>r\\<in>set rs2. normalized_nnf_match (get_match r);\n     setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed;\n     denied1\n     \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n     no_spoofing_algorithm iface ipassmt rs2 allowed denied1\\<rbrakk>\n    \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ rs2)", "proof(induction iface ipassmt rs2 allowed denied1 arbitrary: rs1 allowed denied1 rule: no_spoofing_algorithm.induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>iface ipassmt allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset [];\n        \\<forall>r\\<in>set []. normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt [] alloweda denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ [])\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 3. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 8. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 10. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n        \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n         \\<forall>r\\<in>set (Rule vb Unknown # va).\n            normalized_nnf_match (get_match r);\n         setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow\n         \\<subseteq> allowed;\n         denied1\n         \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n         no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n          denied1\\<rbrakk>\n        \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                           (rs1 @ Rule vb Unknown # va)", "case (1 iface ipassmt)"], ["proof (state)\nthis:\n  simple_ruleset rs1\n  simple_ruleset []\n  \\<forall>r\\<in>set []. normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt [] allowed denied1\n\ngoal (10 subgoals):\n 1. \\<And>iface ipassmt allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset [];\n        \\<forall>r\\<in>set []. normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt [] alloweda denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ [])\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 3. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 8. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 10. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n        \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n         \\<forall>r\\<in>set (Rule vb Unknown # va).\n            normalized_nnf_match (get_match r);\n         setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow\n         \\<subseteq> allowed;\n         denied1\n         \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n         no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n          denied1\\<rbrakk>\n        \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                           (rs1 @ Rule vb Unknown # va)", "from 1"], ["proof (chain)\npicking this:\n  simple_ruleset rs1\n  simple_ruleset []\n  \\<forall>r\\<in>set []. normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt [] allowed denied1", "have \"allowed - denied1 \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset []\n  \\<forall>r\\<in>set []. normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt [] allowed denied1\n\ngoal (1 subgoal):\n 1. allowed - denied1\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "by(simp)"], ["proof (state)\nthis:\n  allowed - denied1 \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (10 subgoals):\n 1. \\<And>iface ipassmt allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset [];\n        \\<forall>r\\<in>set []. normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt [] alloweda denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ [])\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 3. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 8. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 10. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n        \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n         \\<forall>r\\<in>set (Rule vb Unknown # va).\n            normalized_nnf_match (get_match r);\n         setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow\n         \\<subseteq> allowed;\n         denied1\n         \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n         no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n          denied1\\<rbrakk>\n        \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                           (rs1 @ Rule vb Unknown # va)", "with 1"], ["proof (chain)\npicking this:\n  simple_ruleset rs1\n  simple_ruleset []\n  \\<forall>r\\<in>set []. normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt [] allowed denied1\n  allowed - denied1 \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "have \"setbydecision TYPE('pkt_ext) iface rs1 FinalAllow - setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n          \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\""], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset []\n  \\<forall>r\\<in>set []. normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt [] allowed denied1\n  allowed - denied1 \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface rs1 FinalAllow -\n    setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n    \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))", "by blast"], ["proof (state)\nthis:\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow -\n  setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (10 subgoals):\n 1. \\<And>iface ipassmt allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset [];\n        \\<forall>r\\<in>set []. normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt [] alloweda denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ [])\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 3. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 8. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 10. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n        \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n         \\<forall>r\\<in>set (Rule vb Unknown # va).\n            normalized_nnf_match (get_match r);\n         setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow\n         \\<subseteq> allowed;\n         denied1\n         \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n         no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n          denied1\\<rbrakk>\n        \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                           (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow -\n  setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  \\<subseteq> ipcidr_union_set (set (the (ipassmt iface)))\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ [])", "by(simp add: nospoof_setbydecision setbydecision_setbydecision_all_Allow)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ [])\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case (2 iface ipassmt m rs)"], ["proof (state)\nthis:\n  \\<lbrakk>simple_ruleset ?rs1.0; simple_ruleset rs;\n   \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n   setbydecision TYPE('pkt_ext) iface ?rs1.0 FinalAllow\n   \\<subseteq> ?allowed;\n   ?denied1.0\n   \\<subseteq> setbydecision_all TYPE('pkt_ext) iface ?rs1.0 FinalDeny;\n   no_spoofing_algorithm iface ipassmt rs ?allowed ?denied1.0\\<rbrakk>\n  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (?rs1.0 @ rs)\n  simple_ruleset rs1\n  simple_ruleset (Rule m Accept # rs)\n  \\<forall>r\\<in>set (Rule m Accept # rs).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) allowed denied1\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 2(2)"], ["proof (chain)\npicking this:\n  simple_ruleset rs1", "have simple_rs1: \"simple_ruleset rs1\""], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n\ngoal (1 subgoal):\n 1. simple_ruleset rs1", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  simple_ruleset rs1\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "hence simple_rs': \"simple_ruleset (rs1 @ [Rule m Accept])\""], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ [Rule m Accept])", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  simple_ruleset (rs1 @ [Rule m Accept])\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 2(3)"], ["proof (chain)\npicking this:\n  simple_ruleset (Rule m Accept # rs)", "have simple_rs: \"simple_ruleset rs\""], ["proof (prove)\nusing this:\n  simple_ruleset (Rule m Accept # rs)\n\ngoal (1 subgoal):\n 1. simple_ruleset rs", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  simple_ruleset rs\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>simple_ruleset ?rs1.0; simple_ruleset rs;\n   \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n   setbydecision TYPE('pkt_ext) iface ?rs1.0 FinalAllow\n   \\<subseteq> ?allowed;\n   ?denied1.0\n   \\<subseteq> setbydecision_all TYPE('pkt_ext) iface ?rs1.0 FinalDeny;\n   no_spoofing_algorithm iface ipassmt rs ?allowed ?denied1.0\\<rbrakk>\n  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (?rs1.0 @ rs)\n  simple_ruleset rs1\n  simple_ruleset (Rule m Accept # rs)\n  \\<forall>r\\<in>set (Rule m Accept # rs).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) allowed denied1\n  simple_ruleset rs", "have IH: \"\\<And>rs' allowed denied1.\n      simple_ruleset rs' \\<Longrightarrow>\n      setbydecision TYPE('pkt_ext) iface rs' FinalAllow \\<subseteq> allowed \\<Longrightarrow>\n      denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs' FinalDeny \\<Longrightarrow> \n      no_spoofing_algorithm iface ipassmt rs allowed denied1 \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs' @ rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>simple_ruleset ?rs1.0; simple_ruleset rs;\n   \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n   setbydecision TYPE('pkt_ext) iface ?rs1.0 FinalAllow\n   \\<subseteq> ?allowed;\n   ?denied1.0\n   \\<subseteq> setbydecision_all TYPE('pkt_ext) iface ?rs1.0 FinalDeny;\n   no_spoofing_algorithm iface ipassmt rs ?allowed ?denied1.0\\<rbrakk>\n  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (?rs1.0 @ rs)\n  simple_ruleset rs1\n  simple_ruleset (Rule m Accept # rs)\n  \\<forall>r\\<in>set (Rule m Accept # rs).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) allowed denied1\n  simple_ruleset rs\n\ngoal (1 subgoal):\n 1. \\<And>rs' allowed denied1.\n       \\<lbrakk>simple_ruleset rs';\n        setbydecision TYPE('pkt_ext) iface rs' FinalAllow\n        \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs' FinalDeny;\n        no_spoofing_algorithm iface ipassmt rs allowed denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs' @ rs)", "by(simp)"], ["proof (state)\nthis:\n  \\<lbrakk>simple_ruleset ?rs';\n   setbydecision TYPE('pkt_ext) iface ?rs' FinalAllow \\<subseteq> ?allowed;\n   ?denied1.0\n   \\<subseteq> setbydecision_all TYPE('pkt_ext) iface ?rs' FinalDeny;\n   no_spoofing_algorithm iface ipassmt rs ?allowed ?denied1.0\\<rbrakk>\n  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (?rs' @ rs)\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 2(5)"], ["proof (chain)\npicking this:\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed", "have \"setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalAllow \\<subseteq> \n      (allowed \\<union> {ip. \\<exists>p :: ('i::len,'pkt_ext) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m Accept (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)})\""], ["proof (prove)\nusing this:\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalAllow\n    \\<subseteq> allowed \\<union>\n                {ip.\n                 \\<exists>p.\n                    matches (common_matcher, in_doubt_allow) m Accept\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)}", "apply(simp add: setbydecision_append[OF simple_rs'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n    \\<subseteq> allowed \\<Longrightarrow>\n    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n    \\<subseteq> allowed \\<union>\n                {ip.\n                 \\<exists>p.\n                    matches (common_matcher, in_doubt_allow) m Accept\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)} \\<and>\n    {ip.\n     \\<exists>p.\n        matches (common_matcher, in_doubt_allow) m Accept\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) \\<and>\n        approximating_bigstep_fun (common_matcher, in_doubt_allow)\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>) rs1\n         Undecided =\n        Undecided}\n    \\<subseteq> allowed \\<union>\n                {ip.\n                 \\<exists>p.\n                    matches (common_matcher, in_doubt_allow) m Accept\n                     (p\\<lparr>p_iiface := iface_sel iface,\n                          p_src := ip\\<rparr>)}", "by blast"], ["proof (state)\nthis:\n  setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalAllow\n  \\<subseteq> allowed \\<union>\n              {ip.\n               \\<exists>p.\n                  matches (common_matcher, in_doubt_allow) m Accept\n                   (p\\<lparr>p_iiface := iface_sel iface,\n                        p_src := ip\\<rparr>)}\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "with get_exists_matching_src_ips_subset 2(4)"], ["proof (chain)\npicking this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  {ip.\n   \\<exists>p.\n      matches (common_matcher, in_doubt_allow) ?m ?a\n       (p\\<lparr>p_iiface := iface_sel ?iface, p_src := ip\\<rparr>)}\n  \\<subseteq> get_exists_matching_src_ips ?iface ?m\n  \\<forall>r\\<in>set (Rule m Accept # rs).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalAllow\n  \\<subseteq> allowed \\<union>\n              {ip.\n               \\<exists>p.\n                  matches (common_matcher, in_doubt_allow) m Accept\n                   (p\\<lparr>p_iiface := iface_sel iface,\n                        p_src := ip\\<rparr>)}", "have allowed: \"setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalAllow \\<subseteq> (allowed \\<union> get_exists_matching_src_ips iface m)\""], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  {ip.\n   \\<exists>p.\n      matches (common_matcher, in_doubt_allow) ?m ?a\n       (p\\<lparr>p_iiface := iface_sel ?iface, p_src := ip\\<rparr>)}\n  \\<subseteq> get_exists_matching_src_ips ?iface ?m\n  \\<forall>r\\<in>set (Rule m Accept # rs).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalAllow\n  \\<subseteq> allowed \\<union>\n              {ip.\n               \\<exists>p.\n                  matches (common_matcher, in_doubt_allow) m Accept\n                   (p\\<lparr>p_iiface := iface_sel iface,\n                        p_src := ip\\<rparr>)}\n\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalAllow\n    \\<subseteq> allowed \\<union> get_exists_matching_src_ips iface m", "by fastforce"], ["proof (state)\nthis:\n  setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalAllow\n  \\<subseteq> allowed \\<union> get_exists_matching_src_ips iface m\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 2(6) setbydecision_all_appendAccept[OF simple_rs', where 'pkt_ext = 'pkt_ext]"], ["proof (chain)\npicking this:\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  setbydecision_all TYPE('pkt_ext) ?iface rs1 FinalDeny =\n  setbydecision_all TYPE('pkt_ext) ?iface (rs1 @ [Rule m Accept]) FinalDeny", "have denied1:\n      \"denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Accept]) FinalDeny\""], ["proof (prove)\nusing this:\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  setbydecision_all TYPE('pkt_ext) ?iface rs1 FinalDeny =\n  setbydecision_all TYPE('pkt_ext) ?iface (rs1 @ [Rule m Accept]) FinalDeny\n\ngoal (1 subgoal):\n 1. denied1\n    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface\n                 (rs1 @ [Rule m Accept]) FinalDeny", "by simp"], ["proof (state)\nthis:\n  denied1\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Accept])\n               FinalDeny\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 2(7)"], ["proof (chain)\npicking this:\n  no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) allowed denied1", "have no_spoofing_algorithm_prems: \"no_spoofing_algorithm iface ipassmt rs\n         (allowed \\<union> get_exists_matching_src_ips iface m) denied1\""], ["proof (prove)\nusing this:\n  no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) allowed denied1\n\ngoal (1 subgoal):\n 1. no_spoofing_algorithm iface ipassmt rs\n     (allowed \\<union> get_exists_matching_src_ips iface m) denied1", "by(simp)"], ["proof (state)\nthis:\n  no_spoofing_algorithm iface ipassmt rs\n   (allowed \\<union> get_exists_matching_src_ips iface m) denied1\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from IH[OF simple_rs' allowed denied1 no_spoofing_algorithm_prems]"], ["proof (chain)\npicking this:\n  nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Accept]) @ rs)", "have \"nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Accept]) @ rs)\""], ["proof (prove)\nusing this:\n  nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Accept]) @ rs)\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Accept]) @ rs)", "by blast"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Accept]) @ rs)\n\ngoal (9 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Accept # rs);\n        \\<forall>r\\<in>set (Rule m Accept # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Accept # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Accept # rs)\n 2. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 7. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 9. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Accept]) @ rs)\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ Rule m Accept # rs)", "by(simp)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ Rule m Accept # rs)\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case (3 iface ipassmt m rs)"], ["proof (state)\nthis:\n  \\<lbrakk>simple_ruleset ?rs1.0; simple_ruleset rs;\n   \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n   setbydecision TYPE('pkt_ext) iface ?rs1.0 FinalAllow\n   \\<subseteq> ?allowed;\n   ?denied1.0\n   \\<subseteq> setbydecision_all TYPE('pkt_ext) iface ?rs1.0 FinalDeny;\n   no_spoofing_algorithm iface ipassmt rs ?allowed ?denied1.0\\<rbrakk>\n  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (?rs1.0 @ rs)\n  simple_ruleset rs1\n  simple_ruleset (Rule m Drop # rs)\n  \\<forall>r\\<in>set (Rule m Drop # rs). normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) allowed denied1\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 3(2)"], ["proof (chain)\npicking this:\n  simple_ruleset rs1", "have simple_rs1: \"simple_ruleset rs1\""], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n\ngoal (1 subgoal):\n 1. simple_ruleset rs1", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  simple_ruleset rs1\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "hence simple_rs': \"simple_ruleset (rs1 @ [Rule m Drop])\""], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n\ngoal (1 subgoal):\n 1. simple_ruleset (rs1 @ [Rule m Drop])", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  simple_ruleset (rs1 @ [Rule m Drop])\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 3(3)"], ["proof (chain)\npicking this:\n  simple_ruleset (Rule m Drop # rs)", "have simple_rs: \"simple_ruleset rs\""], ["proof (prove)\nusing this:\n  simple_ruleset (Rule m Drop # rs)\n\ngoal (1 subgoal):\n 1. simple_ruleset rs", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  simple_ruleset rs\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>simple_ruleset ?rs1.0; simple_ruleset rs;\n   \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n   setbydecision TYPE('pkt_ext) iface ?rs1.0 FinalAllow\n   \\<subseteq> ?allowed;\n   ?denied1.0\n   \\<subseteq> setbydecision_all TYPE('pkt_ext) iface ?rs1.0 FinalDeny;\n   no_spoofing_algorithm iface ipassmt rs ?allowed ?denied1.0\\<rbrakk>\n  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (?rs1.0 @ rs)\n  simple_ruleset rs1\n  simple_ruleset (Rule m Drop # rs)\n  \\<forall>r\\<in>set (Rule m Drop # rs). normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) allowed denied1\n  simple_ruleset rs", "have IH: \"\\<And>rs' allowed denied1.\n      simple_ruleset rs' \\<Longrightarrow>\n      setbydecision TYPE('pkt_ext) iface rs' FinalAllow \\<subseteq> allowed \\<Longrightarrow>\n      denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs' FinalDeny \\<Longrightarrow> \n      no_spoofing_algorithm iface ipassmt rs allowed denied1 \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs' @ rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>simple_ruleset ?rs1.0; simple_ruleset rs;\n   \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n   setbydecision TYPE('pkt_ext) iface ?rs1.0 FinalAllow\n   \\<subseteq> ?allowed;\n   ?denied1.0\n   \\<subseteq> setbydecision_all TYPE('pkt_ext) iface ?rs1.0 FinalDeny;\n   no_spoofing_algorithm iface ipassmt rs ?allowed ?denied1.0\\<rbrakk>\n  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (?rs1.0 @ rs)\n  simple_ruleset rs1\n  simple_ruleset (Rule m Drop # rs)\n  \\<forall>r\\<in>set (Rule m Drop # rs). normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) allowed denied1\n  simple_ruleset rs\n\ngoal (1 subgoal):\n 1. \\<And>rs' allowed denied1.\n       \\<lbrakk>simple_ruleset rs';\n        setbydecision TYPE('pkt_ext) iface rs' FinalAllow\n        \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs' FinalDeny;\n        no_spoofing_algorithm iface ipassmt rs allowed denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (rs' @ rs)", "by(simp)"], ["proof (state)\nthis:\n  \\<lbrakk>simple_ruleset ?rs';\n   setbydecision TYPE('pkt_ext) iface ?rs' FinalAllow \\<subseteq> ?allowed;\n   ?denied1.0\n   \\<subseteq> setbydecision_all TYPE('pkt_ext) iface ?rs' FinalDeny;\n   no_spoofing_algorithm iface ipassmt rs ?allowed ?denied1.0\\<rbrakk>\n  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt (?rs' @ rs)\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 3(5) simple_rs'"], ["proof (chain)\npicking this:\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  simple_ruleset (rs1 @ [Rule m Drop])", "have allowed: \"setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Drop]) FinalAllow \\<subseteq> allowed \""], ["proof (prove)\nusing this:\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  simple_ruleset (rs1 @ [Rule m Drop])\n\ngoal (1 subgoal):\n 1. setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Drop]) FinalAllow\n    \\<subseteq> allowed", "by(simp add: setbydecision_append)"], ["proof (state)\nthis:\n  setbydecision TYPE('pkt_ext) iface (rs1 @ [Rule m Drop]) FinalAllow\n  \\<subseteq> allowed\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "have \"{ip. \\<forall>p :: ('i,'pkt_ext) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m Drop (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} \\<subseteq> \n          setbydecision_all TYPE('pkt_ext) iface [Rule m Drop] FinalDeny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ip.\n     \\<forall>p.\n        matches (common_matcher, in_doubt_allow) m Drop\n         (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface [Rule m Drop]\n                 FinalDeny", "by(simp add: setbydecision_all_def)"], ["proof (state)\nthis:\n  {ip.\n   \\<forall>p.\n      matches (common_matcher, in_doubt_allow) m Drop\n       (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface [Rule m Drop] FinalDeny\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "with 3(5)"], ["proof (chain)\npicking this:\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  {ip.\n   \\<forall>p.\n      matches (common_matcher, in_doubt_allow) m Drop\n       (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface [Rule m Drop] FinalDeny", "have \"setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union> ({ip. \\<forall>p :: ('i,'pkt_ext) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m Drop (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} - allowed) \\<subseteq>\n          setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union> (setbydecision_all TYPE('pkt_ext) iface [Rule m Drop] FinalDeny - setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)\""], ["proof (prove)\nusing this:\n  setbydecision TYPE('pkt_ext) iface rs1 FinalAllow \\<subseteq> allowed\n  {ip.\n   \\<forall>p.\n      matches (common_matcher, in_doubt_allow) m Drop\n       (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)}\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface [Rule m Drop] FinalDeny\n\ngoal (1 subgoal):\n 1. setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n    ({ip.\n      \\<forall>p.\n         matches (common_matcher, in_doubt_allow) m Drop\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} -\n     allowed)\n    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                 FinalDeny \\<union>\n                (setbydecision_all TYPE('pkt_ext) iface [Rule m Drop]\n                  FinalDeny -\n                 setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)", "by blast"], ["proof (state)\nthis:\n  setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n  ({ip.\n    \\<forall>p.\n       matches (common_matcher, in_doubt_allow) m Drop\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} -\n   allowed)\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n              (setbydecision_all TYPE('pkt_ext) iface [Rule m Drop]\n                FinalDeny -\n               setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "with 3(6) setbydecision_all_append_subset2[OF simple_rs', of iface]"], ["proof (chain)\npicking this:\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  setbydecision_all TYPE(?'pkt_ext) iface rs1 FinalDeny \\<union>\n  (setbydecision_all TYPE(?'pkt_ext) iface [Rule m Drop] FinalDeny -\n   setbydecision TYPE(?'pkt_ext) iface rs1 FinalAllow)\n  \\<subseteq> setbydecision_all TYPE(?'pkt_ext) iface (rs1 @ [Rule m Drop])\n               FinalDeny\n  setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n  ({ip.\n    \\<forall>p.\n       matches (common_matcher, in_doubt_allow) m Drop\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} -\n   allowed)\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n              (setbydecision_all TYPE('pkt_ext) iface [Rule m Drop]\n                FinalDeny -\n               setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)", "have\n     \"denied1 \\<union> ({ip. \\<forall>p :: ('i,'pkt_ext) tagged_packet_scheme. matches (common_matcher, in_doubt_allow) m Drop (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} - allowed) \\<subseteq>\n      setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Drop]) FinalDeny\""], ["proof (prove)\nusing this:\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny\n  setbydecision_all TYPE(?'pkt_ext) iface rs1 FinalDeny \\<union>\n  (setbydecision_all TYPE(?'pkt_ext) iface [Rule m Drop] FinalDeny -\n   setbydecision TYPE(?'pkt_ext) iface rs1 FinalAllow)\n  \\<subseteq> setbydecision_all TYPE(?'pkt_ext) iface (rs1 @ [Rule m Drop])\n               FinalDeny\n  setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n  ({ip.\n    \\<forall>p.\n       matches (common_matcher, in_doubt_allow) m Drop\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} -\n   allowed)\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny \\<union>\n              (setbydecision_all TYPE('pkt_ext) iface [Rule m Drop]\n                FinalDeny -\n               setbydecision TYPE('pkt_ext) iface rs1 FinalAllow)\n\ngoal (1 subgoal):\n 1. denied1 \\<union>\n    ({ip.\n      \\<forall>p.\n         matches (common_matcher, in_doubt_allow) m Drop\n          (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} -\n     allowed)\n    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Drop])\n                 FinalDeny", "by blast"], ["proof (state)\nthis:\n  denied1 \\<union>\n  ({ip.\n    \\<forall>p.\n       matches (common_matcher, in_doubt_allow) m Drop\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} -\n   allowed)\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Drop])\n               FinalDeny\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "with get_all_matching_src_ips 3(4)"], ["proof (chain)\npicking this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  get_all_matching_src_ips ?iface ?m\n  \\<subseteq> {ip.\n               \\<forall>p.\n                  matches (common_matcher, in_doubt_allow) ?m ?a\n                   (p\\<lparr>p_iiface := iface_sel ?iface,\n                        p_src := ip\\<rparr>)}\n  \\<forall>r\\<in>set (Rule m Drop # rs). normalized_nnf_match (get_match r)\n  denied1 \\<union>\n  ({ip.\n    \\<forall>p.\n       matches (common_matcher, in_doubt_allow) m Drop\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} -\n   allowed)\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Drop])\n               FinalDeny", "have denied1:\n     \"denied1 \\<union> (get_all_matching_src_ips iface m - allowed) \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Drop]) FinalDeny\""], ["proof (prove)\nusing this:\n  normalized_nnf_match ?m \\<Longrightarrow>\n  get_all_matching_src_ips ?iface ?m\n  \\<subseteq> {ip.\n               \\<forall>p.\n                  matches (common_matcher, in_doubt_allow) ?m ?a\n                   (p\\<lparr>p_iiface := iface_sel ?iface,\n                        p_src := ip\\<rparr>)}\n  \\<forall>r\\<in>set (Rule m Drop # rs). normalized_nnf_match (get_match r)\n  denied1 \\<union>\n  ({ip.\n    \\<forall>p.\n       matches (common_matcher, in_doubt_allow) m Drop\n        (p\\<lparr>p_iiface := iface_sel iface, p_src := ip\\<rparr>)} -\n   allowed)\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Drop])\n               FinalDeny\n\ngoal (1 subgoal):\n 1. denied1 \\<union> (get_all_matching_src_ips iface m - allowed)\n    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Drop])\n                 FinalDeny", "by force"], ["proof (state)\nthis:\n  denied1 \\<union> (get_all_matching_src_ips iface m - allowed)\n  \\<subseteq> setbydecision_all TYPE('pkt_ext) iface (rs1 @ [Rule m Drop])\n               FinalDeny\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from 3(7)"], ["proof (chain)\npicking this:\n  no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) allowed denied1", "have no_spoofing_algorithm_prems: \"no_spoofing_algorithm iface ipassmt rs allowed\n     (denied1 \\<union> (get_all_matching_src_ips iface m - allowed))\""], ["proof (prove)\nusing this:\n  no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) allowed denied1\n\ngoal (1 subgoal):\n 1. no_spoofing_algorithm iface ipassmt rs allowed\n     (denied1 \\<union> (get_all_matching_src_ips iface m - allowed))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  no_spoofing_algorithm iface ipassmt rs allowed\n   (denied1 \\<union> (get_all_matching_src_ips iface m - allowed))\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "from IH[OF simple_rs' allowed denied1 no_spoofing_algorithm_prems]"], ["proof (chain)\npicking this:\n  nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Drop]) @ rs)", "have \"nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Drop]) @ rs)\""], ["proof (prove)\nusing this:\n  nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Drop]) @ rs)\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Drop]) @ rs)", "by blast"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Drop]) @ rs)\n\ngoal (8 subgoals):\n 1. \\<And>iface ipassmt m rs allowed denied1 rs1 alloweda denied1a.\n       \\<lbrakk>\\<And>rs1 allowed denied1.\n                   \\<lbrakk>simple_ruleset rs1; simple_ruleset rs;\n                    \\<forall>r\\<in>set rs.\n                       normalized_nnf_match (get_match r);\n                    setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n                    \\<subseteq> allowed;\n                    denied1\n                    \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1\n                                 FinalDeny;\n                    no_spoofing_algorithm iface ipassmt rs allowed\n                     denied1\\<rbrakk>\n                   \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n(rs1 @ rs);\n        simple_ruleset rs1; simple_ruleset (Rule m Drop # rs);\n        \\<forall>r\\<in>set (Rule m Drop # rs).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) iface rs1 FinalAllow\n        \\<subseteq> alloweda;\n        denied1a\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) iface rs1 FinalDeny;\n        no_spoofing_algorithm iface ipassmt (Rule m Drop # rs) alloweda\n         denied1a\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt\n                          (rs1 @ Rule m Drop # rs)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 6. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 8. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  nospoof TYPE('pkt_ext) iface ipassmt ((rs1 @ [Rule m Drop]) @ rs)\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ Rule m Drop # rs)", "by(simp)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) iface ipassmt (rs1 @ Rule m Drop # rs)\n\ngoal (7 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 3. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 3. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case \"4_1\""], ["proof (state)\nthis:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Log # va_)\n  \\<forall>r\\<in>set (Rule vb_ Log # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Log # va_) allowed denied1\n\ngoal (7 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Log # va);\n        \\<forall>r\\<in>set (Rule vb Log # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Log # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Log # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 3. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 5. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 7. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Log # va_)\n  \\<forall>r\\<in>set (Rule vb_ Log # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Log # va_) allowed denied1\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Log # va_)", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Log # va_)\n\ngoal (6 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 2. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 2. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case \"4_2\""], ["proof (state)\nthis:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Reject # va_)\n  \\<forall>r\\<in>set (Rule vb_ Reject # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Reject # va_) allowed denied1\n\ngoal (6 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Reject # va);\n        \\<forall>r\\<in>set (Rule vb Reject # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Reject # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Reject # va)\n 2. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 4. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 6. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Reject # va_)\n  \\<forall>r\\<in>set (Rule vb_ Reject # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Reject # va_) allowed denied1\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Reject # va_)", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Reject # va_)\n\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 3. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 3. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case \"4_3\""], ["proof (state)\nthis:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ (Call vd_) # va_)\n  \\<forall>r\\<in>set (Rule vb_ (Call vd_) # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ (Call vd_) # va_) allowed denied1\n\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Call vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Call vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Call vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Call vd) # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 3. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 5. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ (Call vd_) # va_)\n  \\<forall>r\\<in>set (Rule vb_ (Call vd_) # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ (Call vd_) # va_) allowed denied1\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ (Call vd_) # va_)", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ (Call vd_) # va_)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 2. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 2. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case \"4_4\""], ["proof (state)\nthis:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Return # va_)\n  \\<forall>r\\<in>set (Rule vb_ Return # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Return # va_) allowed denied1\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Return # va);\n        \\<forall>r\\<in>set (Rule vb Return # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Return # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Return # va)\n 2. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 4. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Return # va_)\n  \\<forall>r\\<in>set (Rule vb_ Return # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Return # va_) allowed denied1\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Return # va_)", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Return # va_)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case \"4_5\""], ["proof (state)\nthis:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ (Goto vd_) # va_)\n  \\<forall>r\\<in>set (Rule vb_ (Goto vd_) # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ (Goto vd_) # va_) allowed denied1\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ vb vd va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb (Goto vd) # va);\n        \\<forall>r\\<in>set (Rule vb (Goto vd) # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb (Goto vd) # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb (Goto vd) # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 3. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ (Goto vd_) # va_)\n  \\<forall>r\\<in>set (Rule vb_ (Goto vd_) # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ (Goto vd_) # va_) allowed denied1\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ (Goto vd_) # va_)", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ (Goto vd_) # va_)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case \"4_6\""], ["proof (state)\nthis:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Empty # va_)\n  \\<forall>r\\<in>set (Rule vb_ Empty # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Empty # va_) allowed denied1\n\ngoal (2 subgoals):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Empty # va);\n        \\<forall>r\\<in>set (Rule vb Empty # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Empty # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Empty # va)\n 2. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Empty # va_)\n  \\<forall>r\\<in>set (Rule vb_ Empty # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Empty # va_) allowed denied1\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Empty # va_)", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Empty # va_)\n\ngoal (1 subgoal):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "case \"4_7\""], ["proof (state)\nthis:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Unknown # va_)\n  \\<forall>r\\<in>set (Rule vb_ Unknown # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Unknown # va_) allowed denied1\n\ngoal (1 subgoal):\n 1. \\<And>uu_ uv_ vb va _ _ rs1 allowed denied1.\n       \\<lbrakk>simple_ruleset rs1; simple_ruleset (Rule vb Unknown # va);\n        \\<forall>r\\<in>set (Rule vb Unknown # va).\n           normalized_nnf_match (get_match r);\n        setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed;\n        denied1\n        \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny;\n        no_spoofing_algorithm uu_ uv_ (Rule vb Unknown # va) allowed\n         denied1\\<rbrakk>\n       \\<Longrightarrow> nospoof TYPE('pkt_ext) uu_ uv_\n                          (rs1 @ Rule vb Unknown # va)", "thus ?case"], ["proof (prove)\nusing this:\n  simple_ruleset rs1\n  simple_ruleset (Rule vb_ Unknown # va_)\n  \\<forall>r\\<in>set (Rule vb_ Unknown # va_).\n     normalized_nnf_match (get_match r)\n  setbydecision TYPE('pkt_ext) uu_ rs1 FinalAllow \\<subseteq> allowed\n  denied1 \\<subseteq> setbydecision_all TYPE('pkt_ext) uu_ rs1 FinalDeny\n  no_spoofing_algorithm uu_ uv_ (Rule vb_ Unknown # va_) allowed denied1\n\ngoal (1 subgoal):\n 1. nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Unknown # va_)", "by(simp add: simple_ruleset_def)"], ["proof (state)\nthis:\n  nospoof TYPE('pkt_ext) uu_ uv_ (rs1 @ Rule vb_ Unknown # va_)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition no_spoofing_iface :: \"iface \\<Rightarrow> 'i::len ipassignment \\<Rightarrow> 'i common_primitive rule list \\<Rightarrow> bool\" where\n    \"no_spoofing_iface iface ipassmt rs \\<equiv> no_spoofing_algorithm iface ipassmt rs {} {}\""], ["", "lemma[code]: \"no_spoofing_iface iface ipassmt rs = \n      no_spoofing_algorithm_executable iface ipassmt rs Empty_WordInterval Empty_WordInterval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing_iface iface ipassmt rs =\n    no_spoofing_algorithm_executable iface ipassmt rs Empty_WordInterval\n     Empty_WordInterval", "by(simp add: no_spoofing_iface_def no_spoofing_algorithm_executable)"], ["", "private"], ["", "corollary no_spoofing_algorithm_sound: \"simple_ruleset rs \\<Longrightarrow> \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r) \\<Longrightarrow>\n        no_spoofing_iface iface ipassmt rs  \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_iface iface ipassmt rs\\<rbrakk>\n    \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt rs", "unfolding no_spoofing_iface_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> nospoof TYPE('pkt_ext) iface ipassmt rs", "apply(rule no_spoofing_algorithm_sound_generalized[of \"[]\" rs iface \"{}\" \"{}\", simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> simple_ruleset []\n 2. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> simple_ruleset rs\n 3. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r\\<in>set rs.\n                         normalized_nnf_match (get_match r)\n 4. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> setbydecision TYPE('pkt_ext) iface [] FinalAllow = {}\n 5. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> no_spoofing_algorithm iface ipassmt rs {} {}", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> simple_ruleset []\n 2. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> setbydecision TYPE('pkt_ext) iface [] FinalAllow = {}", "apply(simp add: simple_ruleset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     no_spoofing_algorithm iface ipassmt rs {} {}\\<rbrakk>\n    \\<Longrightarrow> setbydecision TYPE('pkt_ext) iface [] FinalAllow = {}", "apply(simp add: setbydecision_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>The @{const nospoof} definition used throughout the proofs corresponds to checking @{const no_spoofing} for all interfaces\\<close>"], ["", "private"], ["", "lemma nospoof: \"simple_ruleset rs \\<Longrightarrow> (\\<forall>iface \\<in> dom ipassmt. nospoof TYPE('pkt_ext) iface ipassmt rs) \\<longleftrightarrow> no_spoofing TYPE('pkt_ext) ipassmt rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset rs \\<Longrightarrow>\n    (\\<forall>iface\\<in>dom ipassmt.\n        nospoof TYPE('pkt_ext) iface ipassmt rs) =\n    no_spoofing TYPE('pkt_ext) ipassmt rs", "unfolding nospoof_def no_spoofing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_ruleset rs \\<Longrightarrow>\n    (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n           Decision FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))) =\n    (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           (common_matcher, in_doubt_allow),p\n           \\<lparr>p_iiface :=\n                     iface_sel\n                      iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface))))", "apply(drule simple_imp_good_ruleset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. good_ruleset rs \\<Longrightarrow>\n    (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n           Decision FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))) =\n    (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           (common_matcher, in_doubt_allow),p\n           \\<lparr>p_iiface :=\n                     iface_sel\n                      iface\\<rparr>\\<turnstile> \\<langle>rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                                  FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface))))", "apply(subst approximating_semantics_iff_fun_good_ruleset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p iface. good_ruleset rs \\<Longrightarrow> good_ruleset rs\n 2. good_ruleset rs \\<Longrightarrow>\n    (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n           Decision FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface)))) =\n    (\\<forall>iface\\<in>dom ipassmt.\n        \\<forall>p.\n           approximating_bigstep_fun (common_matcher, in_doubt_allow)\n            (p\\<lparr>p_iiface := iface_sel iface\\<rparr>) rs Undecided =\n           Decision FinalAllow \\<longrightarrow>\n           p_src p \\<in> ipcidr_union_set (set (the (ipassmt iface))))", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem no_spoofing_iface: \"simple_ruleset rs \\<Longrightarrow> \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r) \\<Longrightarrow>\n        \\<forall>iface \\<in> dom ipassmt. no_spoofing_iface iface ipassmt rs  \\<Longrightarrow> no_spoofing TYPE('pkt_ext) ipassmt rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_ruleset rs;\n     \\<forall>r\\<in>set rs. normalized_nnf_match (get_match r);\n     \\<forall>iface\\<in>dom ipassmt.\n        no_spoofing_iface iface ipassmt rs\\<rbrakk>\n    \\<Longrightarrow> no_spoofing TYPE('pkt_ext) ipassmt rs", "by(auto dest: nospoof no_spoofing_algorithm_sound)"], ["", "text\\<open>Examples\\<close>"], ["", "text\\<open>Example 1:\n    Ruleset: Accept all non-spoofed packets, drop rest.\n  \\<close>"], ["", "lemma \"no_spoofing_iface\n      (Iface ''eth0'') \n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (Match (IIface (Iface ''eth0'')))) action.Accept,\n           Rule MatchAny action.Drop]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing_iface (Iface ''eth0'')\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (Match (IIface (Iface ''eth0''))))\n       Accept,\n      Rule MatchAny Drop]", "by eval"], ["", "lemma \"no_spoofing TYPE('pkt_ext)\n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (Match (IIface (Iface ''eth0'')))) action.Accept,\n           Rule MatchAny action.Drop]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing TYPE('pkt_ext)\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (Match (IIface (Iface ''eth0''))))\n       Accept,\n      Rule MatchAny Drop]", "apply(rule no_spoofing_iface)"], ["proof (prove)\ngoal (3 subgoals):\n 1. simple_ruleset\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (Match (IIface (Iface ''eth0''))))\n       Accept,\n      Rule MatchAny Drop]\n 2. \\<forall>r\\<in>set [Rule\n                         (MatchAnd\n                           (Match\n                             (Src (IpAddrNetmask\n                                    (ipv4addr_of_dotdecimal\n(192, 168, 0, 0))\n                                    24)))\n                           (Match (IIface (Iface ''eth0''))))\n                         Accept,\n                        Rule MatchAny Drop].\n       normalized_nnf_match (get_match r)\n 3. \\<forall>iface\n             \\<in>dom [Iface ''eth0'' \\<mapsto>\n                       [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]].\n       no_spoofing_iface iface\n        [Iface ''eth0'' \\<mapsto>\n         [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n        [Rule\n          (MatchAnd\n            (Match\n              (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                     24)))\n            (Match (IIface (Iface ''eth0''))))\n          Accept,\n         Rule MatchAny Drop]", "apply(simp_all add: simple_ruleset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing_iface (Iface ''eth0'')\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (Match (IIface (Iface ''eth0''))))\n       Accept,\n      Rule MatchAny Drop]", "(*simple and nnf*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing_iface (Iface ''eth0'')\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (Match (IIface (Iface ''eth0''))))\n       Accept,\n      Rule MatchAny Drop]", "by eval"], ["", "(*executable spoofing alogorithm*)"], ["", "text\\<open>Example 2:\n    Ruleset: Drop packets from a spoofed IP range, allow rest.\n    Handles negated interfaces correctly.\n  \\<close>"], ["", "lemma \"no_spoofing TYPE('pkt_ext)\n      [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n      [Rule (MatchAnd (Match (IIface (Iface ''wlan+''))) (Match (Extra ''no idea what this is''))) action.Accept, \\<comment> \\<open>not interesting for spoofing\\<close>\n       Rule (MatchNot (Match (IIface (Iface ''eth0+'')))) action.Accept, \\<comment> \\<open>not interesting for spoofing\\<close>\n       Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0'')))) action.Drop, \\<comment> \\<open>spoof-protect here\\<close>\n       Rule MatchAny action.Accept]\n          \""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing TYPE('pkt_ext)\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd (Match (IIface (Iface ''wlan+'')))\n         (Match (Extra ''no idea what this is'')))\n       Accept,\n      Rule (MatchNot (Match (IIface (Iface ''eth0+'')))) Accept,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (Match (IIface (Iface ''eth0''))))\n       Drop,\n      Rule MatchAny Accept]", "apply(rule no_spoofing_iface)"], ["proof (prove)\ngoal (3 subgoals):\n 1. simple_ruleset\n     [Rule\n       (MatchAnd (Match (IIface (Iface ''wlan+'')))\n         (Match (Extra ''no idea what this is'')))\n       Accept,\n      Rule (MatchNot (Match (IIface (Iface ''eth0+'')))) Accept,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (Match (IIface (Iface ''eth0''))))\n       Drop,\n      Rule MatchAny Accept]\n 2. \\<forall>r\\<in>set [Rule\n                         (MatchAnd (Match (IIface (Iface ''wlan+'')))\n                           (Match (Extra ''no idea what this is'')))\n                         Accept,\n                        Rule (MatchNot (Match (IIface (Iface ''eth0+''))))\n                         Accept,\n                        Rule\n                         (MatchAnd\n                           (MatchNot\n                             (Match\n                               (Src (IpAddrNetmask\n(ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n                           (Match (IIface (Iface ''eth0''))))\n                         Drop,\n                        Rule MatchAny Accept].\n       normalized_nnf_match (get_match r)\n 3. \\<forall>iface\n             \\<in>dom [Iface ''eth0'' \\<mapsto>\n                       [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]].\n       no_spoofing_iface iface\n        [Iface ''eth0'' \\<mapsto>\n         [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n        [Rule\n          (MatchAnd (Match (IIface (Iface ''wlan+'')))\n            (Match (Extra ''no idea what this is'')))\n          Accept,\n         Rule (MatchNot (Match (IIface (Iface ''eth0+'')))) Accept,\n         Rule\n          (MatchAnd\n            (MatchNot\n              (Match\n                (Src (IpAddrNetmask\n                       (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n            (Match (IIface (Iface ''eth0''))))\n          Drop,\n         Rule MatchAny Accept]", "apply(simp_all add: simple_ruleset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing_iface (Iface ''eth0'')\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd (Match (IIface (Iface ''wlan+'')))\n         (Match (Extra ''no idea what this is'')))\n       Accept,\n      Rule (MatchNot (Match (IIface (Iface ''eth0+'')))) Accept,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (Match (IIface (Iface ''eth0''))))\n       Drop,\n      Rule MatchAny Accept]", "by eval"], ["", "text\\<open>Example 3:\n    Accidentally, matching on wlan+, spoofed packets for eth0 are allowed.\n    First, we prove that there actually is no spoofing protection. Then we show that our algorithm finds out.\n\\<close>"], ["", "lemma \"\\<not> no_spoofing TYPE('pkt_ext)\n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) action.Accept, \\<comment> \\<open>accidently allow everything for eth0\\<close>\n           Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0'')))) action.Drop,\n           Rule MatchAny action.Accept]\n          \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> no_spoofing TYPE('pkt_ext)\n            [Iface ''eth0'' \\<mapsto>\n             [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n            [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n             Rule\n              (MatchAnd\n                (MatchNot\n                  (Match\n                    (Src (IpAddrNetmask\n                           (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n                (Match (IIface (Iface ''eth0''))))\n              Drop,\n             Rule MatchAny Accept]", "apply(simp add: no_spoofing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       (common_matcher, in_doubt_allow),p\n       \\<lparr>p_iiface :=\n                 ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n                   (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n                  Rule\n                   (MatchAnd\n                     (MatchNot\n                       (Match\n                         (Src (IpAddrNetmask\n                                (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                                24))))\n                     (Match (IIface (Iface ''eth0''))))\n                   Drop,\n                  Rule MatchAny\n                   Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n FinalAllow \\<and>\n       p_src p\n       \\<notin> ipcidr_union_set\n                 {(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)}", "apply(rule_tac x=\"p\\<lparr>p_src := 0\\<rparr>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_src := 0,\n       p_iiface :=\n         ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n           (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n          Rule\n           (MatchAnd\n             (MatchNot\n               (Match\n                 (Src (IpAddrNetmask\n                        (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n             (Match (IIface (Iface ''eth0''))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow \\<and>\n    p_src (p\\<lparr>p_src := 0\\<rparr>)\n    \\<notin> ipcidr_union_set\n              {(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)}", "(*any p*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_src := 0,\n       p_iiface :=\n         ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n           (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n          Rule\n           (MatchAnd\n             (MatchNot\n               (Match\n                 (Src (IpAddrNetmask\n                        (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n             (Match (IIface (Iface ''eth0''))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow \\<and>\n    p_src (p\\<lparr>p_src := 0\\<rparr>)\n    \\<notin> ipcidr_union_set\n              {(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)}", "apply(simp add: range_0_max_UNIV ipcidr_union_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_src := 0,\n       p_iiface :=\n         ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n           (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n          Rule\n           (MatchAnd\n             (MatchNot\n               (Match\n                 (Src (IpAddrNetmask\n                        (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n             (Match (IIface (Iface ''eth0''))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow \\<and>\n    0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_src := 0,\n       p_iiface :=\n         ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n           (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n          Rule\n           (MatchAnd\n             (MatchNot\n               (Match\n                 (Src (IpAddrNetmask\n                        (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n             (Match (IIface (Iface ''eth0''))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow\n 2. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(subst approximating_semantics_iff_fun_good_ruleset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. good_ruleset\n     [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (Match (IIface (Iface ''eth0''))))\n       Drop,\n      Rule MatchAny Accept]\n 2. approximating_bigstep_fun (common_matcher, in_doubt_allow)\n     (p\\<lparr>p_src := 0, p_iiface := ''eth0''\\<rparr>)\n     [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (Match (IIface (Iface ''eth0''))))\n       Drop,\n      Rule MatchAny Accept]\n     Undecided =\n    Decision FinalAllow\n 3. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(simp add: good_ruleset_def; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. approximating_bigstep_fun (common_matcher, in_doubt_allow)\n     (p\\<lparr>p_src := 0, p_iiface := ''eth0''\\<rparr>)\n     [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (Match (IIface (Iface ''eth0''))))\n       Drop,\n      Rule MatchAny Accept]\n     Undecided =\n    Decision FinalAllow\n 2. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(simp add: bunch_of_lemmata_about_matches\n          match_simplematcher_SrcDst_not\n          primitive_matcher_generic.Iface_single[OF primitive_matcher_generic_common_matcher]\n          primitive_matcher_generic.Iface_single_not[OF primitive_matcher_generic_common_matcher])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                24 \\<and>\n    match_iface (Iface ''eth0'') ''eth0'' \\<longrightarrow>\n    \\<not> match_iface (Iface ''wlan+'') ''eth0''\n 2. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(intro impI, thin_tac _)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> match_iface (Iface ''wlan+'') ''eth0''\n 2. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply eval"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<not> no_spoofing_iface \n          (Iface ''eth0'') \n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) action.Accept, \\<comment> \\<open>accidently allow everything for eth0\\<close>\n           Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24)))) (Match (IIface (Iface ''eth0'')))) action.Drop,\n           Rule MatchAny action.Accept]\n          \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> no_spoofing_iface (Iface ''eth0'')\n            [Iface ''eth0'' \\<mapsto>\n             [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n            [Rule (MatchNot (Match (IIface (Iface ''wlan+'')))) Accept,\n             Rule\n              (MatchAnd\n                (MatchNot\n                  (Match\n                    (Src (IpAddrNetmask\n                           (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n                (Match (IIface (Iface ''eth0''))))\n              Drop,\n             Rule MatchAny Accept]", "by eval"], ["", "text\\<open>Example 4:\n    Ruleset: Drop packets coming from the wrong interface, allow the rest.\n    Warning: this does not prevent spoofing for eth0!\n    Explanation: someone on eth0 can send a packet e.g. with source IP 8.8.8.8\n    The ruleset only prevents spoofing of 192.168.0.0/24 for other interfaces\n\\<close>"], ["", "lemma \"\\<not> no_spoofing TYPE('pkt_ext) [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (MatchNot (Match (IIface (Iface ''eth0''))))) action.Drop,\n           Rule MatchAny action.Accept]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> no_spoofing TYPE('pkt_ext)\n            [Iface ''eth0'' \\<mapsto>\n             [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n            [Rule\n              (MatchAnd\n                (Match\n                  (Src (IpAddrNetmask\n                         (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24)))\n                (MatchNot (Match (IIface (Iface ''eth0'')))))\n              Drop,\n             Rule MatchAny Accept]", "apply(simp add: no_spoofing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       (common_matcher, in_doubt_allow),p\n       \\<lparr>p_iiface :=\n                 ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n                   (MatchAnd\n                     (Match\n                       (Src (IpAddrNetmask\n                              (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                              24)))\n                     (MatchNot (Match (IIface (Iface ''eth0'')))))\n                   Drop,\n                  Rule MatchAny\n                   Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n FinalAllow \\<and>\n       p_src p\n       \\<notin> ipcidr_union_set\n                 {(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)}", "apply(rule_tac x=\"p\\<lparr>p_src := 0\\<rparr>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_src := 0,\n       p_iiface :=\n         ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n           (MatchAnd\n             (Match\n               (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                      24)))\n             (MatchNot (Match (IIface (Iface ''eth0'')))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow \\<and>\n    p_src (p\\<lparr>p_src := 0\\<rparr>)\n    \\<notin> ipcidr_union_set\n              {(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)}", "(*any p*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_src := 0,\n       p_iiface :=\n         ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n           (MatchAnd\n             (Match\n               (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                      24)))\n             (MatchNot (Match (IIface (Iface ''eth0'')))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow \\<and>\n    p_src (p\\<lparr>p_src := 0\\<rparr>)\n    \\<notin> ipcidr_union_set\n              {(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)}", "apply(simp add: range_0_max_UNIV ipcidr_union_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_src := 0,\n       p_iiface :=\n         ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n           (MatchAnd\n             (Match\n               (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                      24)))\n             (MatchNot (Match (IIface (Iface ''eth0'')))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow \\<and>\n    0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (common_matcher, in_doubt_allow),p\n    \\<lparr>p_src := 0,\n       p_iiface :=\n         ''eth0''\\<rparr>\\<turnstile> \\<langle>[Rule\n           (MatchAnd\n             (Match\n               (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                      24)))\n             (MatchNot (Match (IIface (Iface ''eth0'')))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow\n 2. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(subst approximating_semantics_iff_fun_good_ruleset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. good_ruleset\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (MatchNot (Match (IIface (Iface ''eth0'')))))\n       Drop,\n      Rule MatchAny Accept]\n 2. approximating_bigstep_fun (common_matcher, in_doubt_allow)\n     (p\\<lparr>p_src := 0, p_iiface := ''eth0''\\<rparr>)\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (MatchNot (Match (IIface (Iface ''eth0'')))))\n       Drop,\n      Rule MatchAny Accept]\n     Undecided =\n    Decision FinalAllow\n 3. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(simp add: good_ruleset_def; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. approximating_bigstep_fun (common_matcher, in_doubt_allow)\n     (p\\<lparr>p_src := 0, p_iiface := ''eth0''\\<rparr>)\n     [Rule\n       (MatchAnd\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24)))\n         (MatchNot (Match (IIface (Iface ''eth0'')))))\n       Drop,\n      Rule MatchAny Accept]\n     Undecided =\n    Decision FinalAllow\n 2. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(simp add: bunch_of_lemmata_about_matches\n          primitive_matcher_generic.Iface_single[OF primitive_matcher_generic_common_matcher]\n          primitive_matcher_generic.Iface_single_not[OF primitive_matcher_generic_common_matcher])"], ["proof (prove)\ngoal (2 subgoals):\n 1. matches (common_matcher, in_doubt_allow)\n     (Match\n       (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24)))\n     Drop\n     (p\\<lparr>p_src := 0, p_iiface := ''eth0''\\<rparr>) \\<longrightarrow>\n    match_iface (Iface ''eth0'') ''eth0''\n 2. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(intro impI, thin_tac _)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match_iface (Iface ''eth0'') ''eth0''\n 2. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply eval"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Our algorithm detects it.\\<close>"], ["", "lemma \"\\<not> no_spoofing_iface \n          (Iface ''eth0'') \n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))) (MatchNot (Match (IIface (Iface ''eth0''))))) action.Drop,\n           Rule MatchAny action.Accept]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> no_spoofing_iface (Iface ''eth0'')\n            [Iface ''eth0'' \\<mapsto>\n             [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n            [Rule\n              (MatchAnd\n                (Match\n                  (Src (IpAddrNetmask\n                         (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24)))\n                (MatchNot (Match (IIface (Iface ''eth0'')))))\n              Drop,\n             Rule MatchAny Accept]", "by eval"], ["", "text\\<open>Example 5:\n    Spoofing protection but the algorithm fails.\n    The algorithm @{const no_spoofing_iface} is only sound, not complete.\n    The ruleset first drops spoofed packets for TCP and then drops spoofed packets for \\<open>\\<not> TCP\\<close>.\n    The algorithm cannot detect that \\<open>TCP \\<union> \\<not>TCP\\<close> together will match all spoofed packets.\\<close>"], ["", "lemma \"no_spoofing TYPE('pkt_ext) [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                          (Match (Prot (Proto TCP))))) action.Drop,\n           Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                          (MatchNot (Match (Prot (Proto TCP)))))) action.Drop,\n           Rule MatchAny action.Accept]\" (is \"no_spoofing TYPE('pkt_ext) ?ipassmt ?rs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing TYPE('pkt_ext)\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (MatchAnd (Match (IIface (Iface ''eth0'')))\n           (Match (Prot (Proto TCP)))))\n       Drop,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (MatchAnd (Match (IIface (Iface ''eth0'')))\n           (MatchNot (Match (Prot (Proto TCP))))))\n       Drop,\n      Rule MatchAny Accept]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_spoofing TYPE('pkt_ext)\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (MatchAnd (Match (IIface (Iface ''eth0'')))\n           (Match (Prot (Proto TCP)))))\n       Drop,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (MatchAnd (Match (IIface (Iface ''eth0'')))\n           (MatchNot (Match (Prot (Proto TCP))))))\n       Drop,\n      Rule MatchAny Accept]", "have 1: \"\\<forall>p. (common_matcher, in_doubt_allow),p\\<turnstile> \\<langle>?rs, Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision FinalAllow \\<longleftrightarrow>\n                 approximating_bigstep_fun (common_matcher, in_doubt_allow) p ?rs Undecided = Decision FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       (common_matcher,\n        in_doubt_allow),p\\<turnstile> \\<langle>[Rule\n           (MatchAnd\n             (MatchNot\n               (Match\n                 (Src (IpAddrNetmask\n                        (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n             (MatchAnd (Match (IIface (Iface ''eth0'')))\n               (Match (Prot (Proto TCP)))))\n           Drop,\n          Rule\n           (MatchAnd\n             (MatchNot\n               (Match\n                 (Src (IpAddrNetmask\n                        (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n             (MatchAnd (Match (IIface (Iface ''eth0'')))\n               (MatchNot (Match (Prot (Proto TCP))))))\n           Drop,\n          Rule MatchAny\n           Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                               FinalAllow =\n       (approximating_bigstep_fun (common_matcher, in_doubt_allow) p\n         [Rule\n           (MatchAnd\n             (MatchNot\n               (Match\n                 (Src (IpAddrNetmask\n                        (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n             (MatchAnd (Match (IIface (Iface ''eth0'')))\n               (Match (Prot (Proto TCP)))))\n           Drop,\n          Rule\n           (MatchAnd\n             (MatchNot\n               (Match\n                 (Src (IpAddrNetmask\n                        (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n             (MatchAnd (Match (IIface (Iface ''eth0'')))\n               (MatchNot (Match (Prot (Proto TCP))))))\n           Drop,\n          Rule MatchAny Accept]\n         Undecided =\n        Decision FinalAllow)", "by(subst approximating_semantics_iff_fun_good_ruleset) (simp_all add: good_ruleset_def)"], ["proof (state)\nthis:\n  \\<forall>p.\n     (common_matcher,\n      in_doubt_allow),p\\<turnstile> \\<langle>[Rule\n         (MatchAnd\n           (MatchNot\n             (Match\n               (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                      24))))\n           (MatchAnd (Match (IIface (Iface ''eth0'')))\n             (Match (Prot (Proto TCP)))))\n         Drop,\n        Rule\n         (MatchAnd\n           (MatchNot\n             (Match\n               (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                      24))))\n           (MatchAnd (Match (IIface (Iface ''eth0'')))\n             (MatchNot (Match (Prot (Proto TCP))))))\n         Drop,\n        Rule MatchAny\n         Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n                             FinalAllow =\n     (approximating_bigstep_fun (common_matcher, in_doubt_allow) p\n       [Rule\n         (MatchAnd\n           (MatchNot\n             (Match\n               (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                      24))))\n           (MatchAnd (Match (IIface (Iface ''eth0'')))\n             (Match (Prot (Proto TCP)))))\n         Drop,\n        Rule\n         (MatchAnd\n           (MatchNot\n             (Match\n               (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                      24))))\n           (MatchAnd (Match (IIface (Iface ''eth0'')))\n             (MatchNot (Match (Prot (Proto TCP))))))\n         Drop,\n        Rule MatchAny Accept]\n       Undecided =\n      Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. no_spoofing TYPE('pkt_ext)\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (MatchAnd (Match (IIface (Iface ''eth0'')))\n           (Match (Prot (Proto TCP)))))\n       Drop,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (MatchAnd (Match (IIface (Iface ''eth0'')))\n           (MatchNot (Match (Prot (Proto TCP))))))\n       Drop,\n      Rule MatchAny Accept]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing TYPE('pkt_ext)\n     [Iface ''eth0'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n     [Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (MatchAnd (Match (IIface (Iface ''eth0'')))\n           (Match (Prot (Proto TCP)))))\n       Drop,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         (MatchAnd (Match (IIface (Iface ''eth0'')))\n           (MatchNot (Match (Prot (Proto TCP))))))\n       Drop,\n      Rule MatchAny Accept]", "unfolding no_spoofing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>iface\n             \\<in>dom [Iface ''eth0'' \\<mapsto>\n                       [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]].\n       \\<forall>p.\n          (common_matcher, in_doubt_allow),p\n          \\<lparr>p_iiface :=\n                    iface_sel\n                     iface\\<rparr>\\<turnstile> \\<langle>[Rule\n                    (MatchAnd\n                      (MatchNot\n                        (Match\n                          (Src (IpAddrNetmask\n                                 (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                                 24))))\n                      (MatchAnd (Match (IIface (Iface ''eth0'')))\n                        (Match (Prot (Proto TCP)))))\n                    Drop,\n                   Rule\n                    (MatchAnd\n                      (MatchNot\n                        (Match\n                          (Src (IpAddrNetmask\n                                 (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                                 24))))\n                      (MatchAnd (Match (IIface (Iface ''eth0'')))\n                        (MatchNot (Match (Prot (Proto TCP))))))\n                    Drop,\n                   Rule MatchAny\n                    Accept], Undecided\\<rangle> \\<Rightarrow>\\<^sub>\\<alpha> Decision\n  FinalAllow \\<longrightarrow>\n          p_src p\n          \\<in> ipcidr_union_set\n                 (set (the ([Iface ''eth0'' \\<mapsto>\n                             [(ipv4addr_of_dotdecimal (192, 168, 0, 0),\n                               24)]]\n                             iface)))", "apply(simp add: 1 ipcidr_union_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       matches (common_matcher, in_doubt_allow) MatchAny Accept\n        (p\\<lparr>p_iiface := ''eth0''\\<rparr>) \\<longrightarrow>\n       \\<not> matches (common_matcher, in_doubt_allow)\n               (MatchAnd\n                 (MatchNot\n                   (Match\n                     (Src (IpAddrNetmask\n                            (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n                 (MatchAnd (Match (IIface (Iface ''eth0'')))\n                   (MatchNot (Match (Prot (Proto TCP))))))\n               Drop\n               (p\\<lparr>p_iiface := ''eth0''\\<rparr>) \\<longrightarrow>\n       \\<not> matches (common_matcher, in_doubt_allow)\n               (MatchAnd\n                 (MatchNot\n                   (Match\n                     (Src (IpAddrNetmask\n                            (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n                 (MatchAnd (Match (IIface (Iface ''eth0'')))\n                   (Match (Prot (Proto TCP)))))\n               Drop\n               (p\\<lparr>p_iiface := ''eth0''\\<rparr>) \\<longrightarrow>\n       p_src p\n       \\<in> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(simp add: bunch_of_lemmata_about_matches\n          primitive_matcher_generic.Iface_single[OF primitive_matcher_generic_common_matcher]\n          primitive_matcher_generic.Iface_single_not[OF primitive_matcher_generic_common_matcher])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       (match_iface (Iface ''eth0'') ''eth0'' \\<longrightarrow>\n        matches (common_matcher, in_doubt_allow)\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         Drop (p\\<lparr>p_iiface := ''eth0''\\<rparr>) \\<longrightarrow>\n        \\<not> matches (common_matcher, in_doubt_allow)\n                (MatchNot (Match (Prot (Proto TCP)))) Drop\n                (p\\<lparr>p_iiface := ''eth0''\\<rparr>)) \\<longrightarrow>\n       (match_iface (Iface ''eth0'') ''eth0'' \\<longrightarrow>\n        matches (common_matcher, in_doubt_allow)\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                    24))))\n         Drop (p\\<lparr>p_iiface := ''eth0''\\<rparr>) \\<longrightarrow>\n        \\<not> matches (common_matcher, in_doubt_allow)\n                (Match (Prot (Proto TCP))) Drop\n                (p\\<lparr>p_iiface := ''eth0''\\<rparr>)) \\<longrightarrow>\n       p_src p\n       \\<in> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24", "apply(simp add: match_iface.simps match_simplematcher_SrcDst_not\n                      primitive_matcher_generic.Prot_single[OF primitive_matcher_generic_common_matcher]\n                      primitive_matcher_generic.Prot_single_not[OF primitive_matcher_generic_common_matcher])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  no_spoofing TYPE('pkt_ext)\n   [Iface ''eth0'' \\<mapsto>\n    [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n   [Rule\n     (MatchAnd\n       (MatchNot\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24))))\n       (MatchAnd (Match (IIface (Iface ''eth0'')))\n         (Match (Prot (Proto TCP)))))\n     Drop,\n    Rule\n     (MatchAnd\n       (MatchNot\n         (Match\n           (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192, 168, 0, 0))\n                  24))))\n       (MatchAnd (Match (IIface (Iface ''eth0'')))\n         (MatchNot (Match (Prot (Proto TCP))))))\n     Drop,\n    Rule MatchAny Accept]\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Spoofing protection but the algorithm cannot certify spoofing protection.\\<close>"], ["", "lemma \"\\<not> no_spoofing_iface\n          (Iface ''eth0'') \n          [Iface ''eth0'' \\<mapsto> [(ipv4addr_of_dotdecimal (192,168,0,0), 24)]]\n          [Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                (Match (Prot (Proto TCP))))) action.Drop,\n           Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (192,168,0,0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                (MatchNot (Match (Prot (Proto TCP)))))) action.Drop,\n           Rule MatchAny action.Accept]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> no_spoofing_iface (Iface ''eth0'')\n            [Iface ''eth0'' \\<mapsto>\n             [(ipv4addr_of_dotdecimal (192, 168, 0, 0), 24)]]\n            [Rule\n              (MatchAnd\n                (MatchNot\n                  (Match\n                    (Src (IpAddrNetmask\n                           (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                  (Match (Prot (Proto TCP)))))\n              Drop,\n             Rule\n              (MatchAnd\n                (MatchNot\n                  (Match\n                    (Src (IpAddrNetmask\n                           (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 24))))\n                (MatchAnd (Match (IIface (Iface ''eth0'')))\n                  (MatchNot (Match (Prot (Proto TCP))))))\n              Drop,\n             Rule MatchAny Accept]", "by eval"], ["", "end"], ["", "lemma \"no_spoofing_iface (Iface ''eth1.1011'')\n                         ([Iface ''eth1.1011'' \\<mapsto> [(ipv4addr_of_dotdecimal (131,159,14,0), 24)]]:: 32 ipassignment)\n  [Rule (MatchNot (Match (IIface (Iface ''eth1.1011+'')))) action.Accept,\n   Rule (MatchAnd (MatchNot (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (131,159,14,0)) 24)))) (Match (IIface (Iface ''eth1.1011'')))) action.Drop,\n   Rule MatchAny action.Accept]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing_iface (Iface ''eth1.1011'')\n     [Iface ''eth1.1011'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (131, 159, 14, 0), 24)]]\n     [Rule (MatchNot (Match (IIface (Iface ''eth1.1011+'')))) Accept,\n      Rule\n       (MatchAnd\n         (MatchNot\n           (Match\n             (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (131, 159, 14, 0))\n                    24))))\n         (Match (IIface (Iface ''eth1.1011''))))\n       Drop,\n      Rule MatchAny Accept]", "by eval"], ["", "text\\<open>We only check accepted packets.\n      If there is no default rule (this will never happen if parsed from iptables!), the result is unfinished.\\<close>"], ["", "lemma \"no_spoofing_iface (Iface ''eth1.1011'')\n                         ([Iface ''eth1.1011'' \\<mapsto> [(ipv4addr_of_dotdecimal (131,159,14,0), 24)]]:: 32 ipassignment)\n  [Rule (Match (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8))) Drop]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_spoofing_iface (Iface ''eth1.1011'')\n     [Iface ''eth1.1011'' \\<mapsto>\n      [(ipv4addr_of_dotdecimal (131, 159, 14, 0), 24)]]\n     [Rule\n       (Match\n         (Src (IpAddrNetmask (ipv4addr_of_dotdecimal (127, 0, 0, 0)) 8)))\n       Drop]", "by eval"], ["", "end"]]}