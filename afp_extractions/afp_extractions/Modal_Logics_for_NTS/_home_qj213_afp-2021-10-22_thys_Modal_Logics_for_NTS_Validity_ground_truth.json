{"file_name": "/home/qj213/afp-2021-10-22/thys/Modal_Logics_for_NTS/Validity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modal_Logics_for_NTS", "problem_names": ["lemma alpha_Tree_relI [simp]:\n  assumes \"x =\\<^sub>\\<alpha> y\" shows \"(x,y) \\<in> alpha_Tree_rel\"", "lemma alpha_Tree_relE:\n  assumes \"(x,y) \\<in> alpha_Tree_rel\" and \"x =\\<^sub>\\<alpha> y \\<Longrightarrow> P\"\n  shows P", "lemma wf_alpha_Tree_rel_hull_rel_Tree_wf:\n  \"wf (alpha_Tree_rel O hull_rel O Tree_wf)\"", "lemma alpha_Tree_rel_relcomp_trivialI [simp]:\n  assumes \"(x, y) \\<in> R\"\n  shows \"(x, y) \\<in> alpha_Tree_rel O R\"", "lemma alpha_Tree_rel_relcompI [simp]:\n  assumes \"x =\\<^sub>\\<alpha> x'\" and \"(x', y) \\<in> R\"\n  shows \"(x, y) \\<in> alpha_Tree_rel O R\"", "lemma valid_Tree_eqvt': \"valid_Tree P t \\<longleftrightarrow> valid_Tree (p \\<bullet> P) (p \\<bullet> t)\"", "lemma valid_Tree_eqvt (*[eqvt]*):\n    assumes \"valid_Tree P t\" shows \"valid_Tree (p \\<bullet> P) (p \\<bullet> t)\"", "lemma alpha_Tree_valid_Tree:\n    assumes \"t1 =\\<^sub>\\<alpha> t2\"\n    shows \"valid_Tree P t1 \\<longleftrightarrow> valid_Tree P t2\"", "lemma valid_Tree\\<^sub>\\<alpha>_eqvt (*[eqvt]*):\n    assumes \"valid_Tree\\<^sub>\\<alpha> P t\" shows \"valid_Tree\\<^sub>\\<alpha> (p \\<bullet> P) (p \\<bullet> t)\"", "lemma valid_Tree\\<^sub>\\<alpha>_Conj\\<^sub>\\<alpha> [simp]: \"valid_Tree\\<^sub>\\<alpha> P (Conj\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>) \\<longleftrightarrow> (\\<forall>t\\<^sub>\\<alpha>\\<in>set_bset tset\\<^sub>\\<alpha>. valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>)\"", "lemma valid_Tree\\<^sub>\\<alpha>_Not\\<^sub>\\<alpha> [simp]: \"valid_Tree\\<^sub>\\<alpha> P (Not\\<^sub>\\<alpha> t\\<^sub>\\<alpha>) \\<longleftrightarrow> \\<not> valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>\"", "lemma valid_Tree\\<^sub>\\<alpha>_Pred\\<^sub>\\<alpha> [simp]: \"valid_Tree\\<^sub>\\<alpha> P (Pred\\<^sub>\\<alpha> \\<phi>) \\<longleftrightarrow> P \\<turnstile> \\<phi>\"", "lemma valid_Tree\\<^sub>\\<alpha>_Act\\<^sub>\\<alpha> [simp]: \"valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>) \\<longleftrightarrow> (\\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'. Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> = Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>')\"", "lemma valid_eqvt (*[eqvt]*):\n    assumes \"P \\<Turnstile> x\" shows \"(p \\<bullet> P) \\<Turnstile> (p \\<bullet> x)\"", "lemma valid_Conj [simp]:\n    assumes \"finite (supp xset)\"\n    shows \"P \\<Turnstile> Conj xset \\<longleftrightarrow> (\\<forall>x\\<in>set_bset xset. P \\<Turnstile> x)\"", "lemma valid_Not [simp]: \"P \\<Turnstile> Not x \\<longleftrightarrow> \\<not> P \\<Turnstile> x\"", "lemma valid_Pred [simp]: \"P \\<Turnstile> Pred \\<phi> \\<longleftrightarrow> P \\<turnstile> \\<phi>\"", "lemma valid_Act: \"P \\<Turnstile> Act \\<alpha> x \\<longleftrightarrow> (\\<exists>\\<alpha>' x' P'. Act \\<alpha> x = Act \\<alpha>' x' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> P' \\<Turnstile> x')\"", "lemma valid_Act_strong:\n    assumes \"finite (supp X)\"\n    shows \"P \\<Turnstile> Act \\<alpha> x \\<longleftrightarrow> (\\<exists>\\<alpha>' x' P'. Act \\<alpha> x = Act \\<alpha>' x' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X)\"", "lemma valid_Act_fresh:\n    assumes \"bn \\<alpha> \\<sharp>* P\"\n    shows \"P \\<Turnstile> Act \\<alpha> x \\<longleftrightarrow> (\\<exists>P'. P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and> P' \\<Turnstile> x)\""], "translations": [["", "lemma alpha_Tree_relI [simp]:\n  assumes \"x =\\<^sub>\\<alpha> y\" shows \"(x,y) \\<in> alpha_Tree_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> Validity.alpha_Tree_rel", "using assms"], ["proof (prove)\nusing this:\n  x =\\<^sub>\\<alpha> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> Validity.alpha_Tree_rel", "unfolding alpha_Tree_rel_def"], ["proof (prove)\nusing this:\n  x =\\<^sub>\\<alpha> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> {(x, y). x =\\<^sub>\\<alpha> y}", "by simp"], ["", "lemma alpha_Tree_relE:\n  assumes \"(x,y) \\<in> alpha_Tree_rel\" and \"x =\\<^sub>\\<alpha> y \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> Validity.alpha_Tree_rel\n  x =\\<^sub>\\<alpha> y \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "unfolding alpha_Tree_rel_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(x, y). x =\\<^sub>\\<alpha> y}\n  x =\\<^sub>\\<alpha> y \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["", "lemma wf_alpha_Tree_rel_hull_rel_Tree_wf:\n  \"wf (alpha_Tree_rel O hull_rel O Tree_wf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (Validity.alpha_Tree_rel O hull_rel O Tree_wf)", "proof (rule wf_relcomp_compatible)"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (hull_rel O Tree_wf)\n 2. (hull_rel O Tree_wf) O Validity.alpha_Tree_rel\n    \\<subseteq> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "show \"wf (hull_rel O Tree_wf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (hull_rel O Tree_wf)", "by (metis Tree_wf_eqvt' wf_Tree_wf wf_hull_rel_relcomp)"], ["proof (state)\nthis:\n  wf (hull_rel O Tree_wf)\n\ngoal (1 subgoal):\n 1. (hull_rel O Tree_wf) O Validity.alpha_Tree_rel\n    \\<subseteq> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (hull_rel O Tree_wf) O Validity.alpha_Tree_rel\n    \\<subseteq> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "show \"(hull_rel O Tree_wf) O alpha_Tree_rel \\<subseteq> alpha_Tree_rel O (hull_rel O Tree_wf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hull_rel O Tree_wf) O Validity.alpha_Tree_rel\n    \\<subseteq> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (hull_rel O Tree_wf) O\n               Validity.alpha_Tree_rel \\<Longrightarrow>\n       x \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "fix x :: \"('d, 'e, 'f) Tree \\<times> ('d, 'e, 'f) Tree\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (hull_rel O Tree_wf) O\n               Validity.alpha_Tree_rel \\<Longrightarrow>\n       x \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "assume \"x \\<in> (hull_rel O Tree_wf) O alpha_Tree_rel\""], ["proof (state)\nthis:\n  x \\<in> (hull_rel O Tree_wf) O Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (hull_rel O Tree_wf) O\n               Validity.alpha_Tree_rel \\<Longrightarrow>\n       x \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "then"], ["proof (chain)\npicking this:\n  x \\<in> (hull_rel O Tree_wf) O Validity.alpha_Tree_rel", "obtain x1 x2 x3 x4 where x: \"x = (x1,x4)\" and 1: \"(x1,x2) \\<in> hull_rel\" and 2: \"(x2,x3) \\<in> Tree_wf\" and 3: \"(x3,x4) \\<in> alpha_Tree_rel\""], ["proof (prove)\nusing this:\n  x \\<in> (hull_rel O Tree_wf) O Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x4 x2 x3.\n        \\<lbrakk>x = (x1, x4); (x1, x2) \\<in> hull_rel;\n         (x2, x3) \\<in> Tree_wf;\n         (x3, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = (x1, x4)\n  (x1, x2) \\<in> hull_rel\n  (x2, x3) \\<in> Tree_wf\n  (x3, x4) \\<in> Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (hull_rel O Tree_wf) O\n               Validity.alpha_Tree_rel \\<Longrightarrow>\n       x \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from 2"], ["proof (chain)\npicking this:\n  (x2, x3) \\<in> Tree_wf", "have \"(x1,x4) \\<in> alpha_Tree_rel O hull_rel O Tree_wf\""], ["proof (prove)\nusing this:\n  (x2, x3) \\<in> Tree_wf\n\ngoal (1 subgoal):\n 1. (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "using 1 and 3"], ["proof (prove)\nusing this:\n  (x2, x3) \\<in> Tree_wf\n  (x1, x2) \\<in> hull_rel\n  (x3, x4) \\<in> Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "proof (induct rule: Tree_wf.induct)\n        \\<comment> \\<open>@{const tConj}\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "fix t and tset :: \"('d,'e,'f) Tree set['d]\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "assume *: \"t \\<in> set_bset tset\" and **: \"(x1,t) \\<in> hull_rel\" and ***: \"(tConj tset, x4) \\<in> alpha_Tree_rel\""], ["proof (state)\nthis:\n  t \\<in> set_bset tset\n  (x1, t) \\<in> hull_rel\n  (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from \"**\""], ["proof (chain)\npicking this:\n  (x1, t) \\<in> hull_rel", "obtain p where x1: \"x1 = p \\<bullet> t\""], ["proof (prove)\nusing this:\n  (x1, t) \\<in> hull_rel\n\ngoal (1 subgoal):\n 1. (\\<And>p. x1 = p \\<bullet> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hull_rel.cases"], ["proof (prove)\nusing this:\n  (x1, t) \\<in> hull_rel\n  \\<lbrakk>(?a1.0, ?a2.0) \\<in> hull_rel;\n   \\<And>p x.\n      \\<lbrakk>?a1.0 = p \\<bullet> x; ?a2.0 = x\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>p. x1 = p \\<bullet> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x1 = p \\<bullet> t\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from \"***\""], ["proof (chain)\npicking this:\n  (tConj tset, x4) \\<in> Validity.alpha_Tree_rel", "have \"tConj tset =\\<^sub>\\<alpha> x4\""], ["proof (prove)\nusing this:\n  (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. tConj tset =\\<^sub>\\<alpha> x4", "by (rule alpha_Tree_relE)"], ["proof (state)\nthis:\n  tConj tset =\\<^sub>\\<alpha> x4\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "then"], ["proof (chain)\npicking this:\n  tConj tset =\\<^sub>\\<alpha> x4", "obtain tset' where x4: \"x4 = tConj tset'\" and \"rel_bset (=\\<^sub>\\<alpha>) tset tset'\""], ["proof (prove)\nusing this:\n  tConj tset =\\<^sub>\\<alpha> x4\n\ngoal (1 subgoal):\n 1. (\\<And>tset'.\n        \\<lbrakk>x4 = tConj tset';\n         rel_bset (=\\<^sub>\\<alpha>) tset tset'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"x4\") simp_all"], ["proof (state)\nthis:\n  x4 = tConj tset'\n  rel_bset (=\\<^sub>\\<alpha>) tset tset'\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "with \"*\""], ["proof (chain)\npicking this:\n  t \\<in> set_bset tset\n  x4 = tConj tset'\n  rel_bset (=\\<^sub>\\<alpha>) tset tset'", "obtain t' where t': \"t' \\<in> set_bset tset'\" and \"t =\\<^sub>\\<alpha> t'\""], ["proof (prove)\nusing this:\n  t \\<in> set_bset tset\n  x4 = tConj tset'\n  rel_bset (=\\<^sub>\\<alpha>) tset tset'\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> set_bset tset'; t =\\<^sub>\\<alpha> t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis rel_bset.rep_eq rel_set_def)"], ["proof (state)\nthis:\n  t' \\<in> set_bset tset'\n  t =\\<^sub>\\<alpha> t'\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "with x1"], ["proof (chain)\npicking this:\n  x1 = p \\<bullet> t\n  t' \\<in> set_bset tset'\n  t =\\<^sub>\\<alpha> t'", "have \"(x1, p \\<bullet> t') \\<in> alpha_Tree_rel\""], ["proof (prove)\nusing this:\n  x1 = p \\<bullet> t\n  t' \\<in> set_bset tset'\n  t =\\<^sub>\\<alpha> t'\n\ngoal (1 subgoal):\n 1. (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel", "by (metis Tree\\<^sub>\\<alpha>.abs_eq_iff alpha_Tree_relI permute_Tree\\<^sub>\\<alpha>.abs_eq)"], ["proof (state)\nthis:\n  (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "moreover"], ["proof (state)\nthis:\n  (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "have \"(p \\<bullet> t', t') \\<in> hull_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> t', t') \\<in> hull_rel", "by (rule hull_rel.intros)"], ["proof (state)\nthis:\n  (p \\<bullet> t', t') \\<in> hull_rel\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "moreover"], ["proof (state)\nthis:\n  (p \\<bullet> t', t') \\<in> hull_rel\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from x4 and t'"], ["proof (chain)\npicking this:\n  x4 = tConj tset'\n  t' \\<in> set_bset tset'", "have \"(t', x4) \\<in> Tree_wf\""], ["proof (prove)\nusing this:\n  x4 = tConj tset'\n  t' \\<in> set_bset tset'\n\ngoal (1 subgoal):\n 1. (t', x4) \\<in> Tree_wf", "by (simp add: Tree_wf.intros(1))"], ["proof (state)\nthis:\n  (t', x4) \\<in> Tree_wf\n\ngoal (3 subgoals):\n 1. \\<And>t tset.\n       \\<lbrakk>t \\<in> set_bset tset; (x1, t) \\<in> hull_rel;\n        (tConj tset, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 3. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "ultimately"], ["proof (chain)\npicking this:\n  (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n  (p \\<bullet> t', t') \\<in> hull_rel\n  (t', x4) \\<in> Tree_wf", "show \"(x1,x4) \\<in> alpha_Tree_rel O hull_rel O Tree_wf\""], ["proof (prove)\nusing this:\n  (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n  (p \\<bullet> t', t') \\<in> hull_rel\n  (t', x4) \\<in> Tree_wf\n\ngoal (1 subgoal):\n 1. (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "by auto"], ["proof (state)\nthis:\n  (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "next\n        \\<comment> \\<open>@{const tNot}\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "assume *: \"(x1,t) \\<in> hull_rel\" and **: \"(tNot t, x4) \\<in> alpha_Tree_rel\""], ["proof (state)\nthis:\n  (x1, t) \\<in> hull_rel\n  (tNot t, x4) \\<in> Validity.alpha_Tree_rel\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from \"*\""], ["proof (chain)\npicking this:\n  (x1, t) \\<in> hull_rel", "obtain p where x1: \"x1 = p \\<bullet> t\""], ["proof (prove)\nusing this:\n  (x1, t) \\<in> hull_rel\n\ngoal (1 subgoal):\n 1. (\\<And>p. x1 = p \\<bullet> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hull_rel.cases"], ["proof (prove)\nusing this:\n  (x1, t) \\<in> hull_rel\n  \\<lbrakk>(?a1.0, ?a2.0) \\<in> hull_rel;\n   \\<And>p x.\n      \\<lbrakk>?a1.0 = p \\<bullet> x; ?a2.0 = x\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>p. x1 = p \\<bullet> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x1 = p \\<bullet> t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from \"**\""], ["proof (chain)\npicking this:\n  (tNot t, x4) \\<in> Validity.alpha_Tree_rel", "have \"tNot t =\\<^sub>\\<alpha> x4\""], ["proof (prove)\nusing this:\n  (tNot t, x4) \\<in> Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. tNot t =\\<^sub>\\<alpha> x4", "by (rule alpha_Tree_relE)"], ["proof (state)\nthis:\n  tNot t =\\<^sub>\\<alpha> x4\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "then"], ["proof (chain)\npicking this:\n  tNot t =\\<^sub>\\<alpha> x4", "obtain t' where x4: \"x4 = tNot t'\" and \"t =\\<^sub>\\<alpha> t'\""], ["proof (prove)\nusing this:\n  tNot t =\\<^sub>\\<alpha> x4\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>x4 = tNot t'; t =\\<^sub>\\<alpha> t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"x4\") simp_all"], ["proof (state)\nthis:\n  x4 = tNot t'\n  t =\\<^sub>\\<alpha> t'\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "with x1"], ["proof (chain)\npicking this:\n  x1 = p \\<bullet> t\n  x4 = tNot t'\n  t =\\<^sub>\\<alpha> t'", "have \"(x1, p \\<bullet> t') \\<in> alpha_Tree_rel\""], ["proof (prove)\nusing this:\n  x1 = p \\<bullet> t\n  x4 = tNot t'\n  t =\\<^sub>\\<alpha> t'\n\ngoal (1 subgoal):\n 1. (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel", "by (metis Tree\\<^sub>\\<alpha>.abs_eq_iff alpha_Tree_relI permute_Tree\\<^sub>\\<alpha>.abs_eq x1)"], ["proof (state)\nthis:\n  (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "moreover"], ["proof (state)\nthis:\n  (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "have \"(p \\<bullet> t', t') \\<in> hull_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> t', t') \\<in> hull_rel", "by (rule hull_rel.intros)"], ["proof (state)\nthis:\n  (p \\<bullet> t', t') \\<in> hull_rel\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "moreover"], ["proof (state)\nthis:\n  (p \\<bullet> t', t') \\<in> hull_rel\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from x4"], ["proof (chain)\npicking this:\n  x4 = tNot t'", "have \"(t', x4) \\<in> Tree_wf\""], ["proof (prove)\nusing this:\n  x4 = tNot t'\n\ngoal (1 subgoal):\n 1. (t', x4) \\<in> Tree_wf", "using Tree_wf.intros(2)"], ["proof (prove)\nusing this:\n  x4 = tNot t'\n  (?t, tNot ?t) \\<in> Tree_wf\n\ngoal (1 subgoal):\n 1. (t', x4) \\<in> Tree_wf", "by blast"], ["proof (state)\nthis:\n  (t', x4) \\<in> Tree_wf\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tNot t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n 2. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "ultimately"], ["proof (chain)\npicking this:\n  (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n  (p \\<bullet> t', t') \\<in> hull_rel\n  (t', x4) \\<in> Tree_wf", "show \"(x1,x4) \\<in> alpha_Tree_rel O hull_rel O Tree_wf\""], ["proof (prove)\nusing this:\n  (x1, p \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n  (p \\<bullet> t', t') \\<in> hull_rel\n  (t', x4) \\<in> Tree_wf\n\ngoal (1 subgoal):\n 1. (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "by auto"], ["proof (state)\nthis:\n  (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "next\n        \\<comment> \\<open>@{const tAct}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "fix \\<alpha> t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "assume *: \"(x1,t) \\<in> hull_rel\" and **: \"(tAct \\<alpha> t, x4) \\<in> alpha_Tree_rel\""], ["proof (state)\nthis:\n  (x1, t) \\<in> hull_rel\n  (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from \"*\""], ["proof (chain)\npicking this:\n  (x1, t) \\<in> hull_rel", "obtain p where x1: \"x1 = p \\<bullet> t\""], ["proof (prove)\nusing this:\n  (x1, t) \\<in> hull_rel\n\ngoal (1 subgoal):\n 1. (\\<And>p. x1 = p \\<bullet> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hull_rel.cases"], ["proof (prove)\nusing this:\n  (x1, t) \\<in> hull_rel\n  \\<lbrakk>(?a1.0, ?a2.0) \\<in> hull_rel;\n   \\<And>p x.\n      \\<lbrakk>?a1.0 = p \\<bullet> x; ?a2.0 = x\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>p. x1 = p \\<bullet> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x1 = p \\<bullet> t\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from \"**\""], ["proof (chain)\npicking this:\n  (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel", "have \"tAct \\<alpha> t =\\<^sub>\\<alpha> x4\""], ["proof (prove)\nusing this:\n  (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. tAct \\<alpha> t =\\<^sub>\\<alpha> x4", "by (rule alpha_Tree_relE)"], ["proof (state)\nthis:\n  tAct \\<alpha> t =\\<^sub>\\<alpha> x4\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "then"], ["proof (chain)\npicking this:\n  tAct \\<alpha> t =\\<^sub>\\<alpha> x4", "obtain q t' where x4: \"x4 = tAct (q \\<bullet> \\<alpha>) t'\" and \"q \\<bullet> t =\\<^sub>\\<alpha> t'\""], ["proof (prove)\nusing this:\n  tAct \\<alpha> t =\\<^sub>\\<alpha> x4\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>x4 = tAct (q \\<bullet> \\<alpha>) t';\n         q \\<bullet> t =\\<^sub>\\<alpha> t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"x4\") (auto simp add: alpha_set)"], ["proof (state)\nthis:\n  x4 = tAct (q \\<bullet> \\<alpha>) t'\n  q \\<bullet> t =\\<^sub>\\<alpha> t'\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "with x1"], ["proof (chain)\npicking this:\n  x1 = p \\<bullet> t\n  x4 = tAct (q \\<bullet> \\<alpha>) t'\n  q \\<bullet> t =\\<^sub>\\<alpha> t'", "have \"(x1, p \\<bullet> -q \\<bullet> t') \\<in> alpha_Tree_rel\""], ["proof (prove)\nusing this:\n  x1 = p \\<bullet> t\n  x4 = tAct (q \\<bullet> \\<alpha>) t'\n  q \\<bullet> t =\\<^sub>\\<alpha> t'\n\ngoal (1 subgoal):\n 1. (x1, p \\<bullet> - q \\<bullet> t') \\<in> Validity.alpha_Tree_rel", "by (metis Tree\\<^sub>\\<alpha>.abs_eq_iff alpha_Tree_relI permute_Tree\\<^sub>\\<alpha>.abs_eq permute_minus_cancel(1))"], ["proof (state)\nthis:\n  (x1, p \\<bullet> - q \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "moreover"], ["proof (state)\nthis:\n  (x1, p \\<bullet> - q \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "have \"(p \\<bullet> -q \\<bullet> t', t') \\<in> hull_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> - q \\<bullet> t', t') \\<in> hull_rel", "by (metis hull_rel.simps permute_plus)"], ["proof (state)\nthis:\n  (p \\<bullet> - q \\<bullet> t', t') \\<in> hull_rel\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "moreover"], ["proof (state)\nthis:\n  (p \\<bullet> - q \\<bullet> t', t') \\<in> hull_rel\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "from x4"], ["proof (chain)\npicking this:\n  x4 = tAct (q \\<bullet> \\<alpha>) t'", "have \"(t', x4) \\<in> Tree_wf\""], ["proof (prove)\nusing this:\n  x4 = tAct (q \\<bullet> \\<alpha>) t'\n\ngoal (1 subgoal):\n 1. (t', x4) \\<in> Tree_wf", "by (simp add: Tree_wf.intros(3))"], ["proof (state)\nthis:\n  (t', x4) \\<in> Tree_wf\n\ngoal (1 subgoal):\n 1. \\<And>t \\<alpha>.\n       \\<lbrakk>(x1, t) \\<in> hull_rel;\n        (tAct \\<alpha> t, x4) \\<in> Validity.alpha_Tree_rel\\<rbrakk>\n       \\<Longrightarrow> (x1, x4)\n                         \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "ultimately"], ["proof (chain)\npicking this:\n  (x1, p \\<bullet> - q \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n  (p \\<bullet> - q \\<bullet> t', t') \\<in> hull_rel\n  (t', x4) \\<in> Tree_wf", "show \"(x1,x4) \\<in> alpha_Tree_rel O hull_rel O Tree_wf\""], ["proof (prove)\nusing this:\n  (x1, p \\<bullet> - q \\<bullet> t') \\<in> Validity.alpha_Tree_rel\n  (p \\<bullet> - q \\<bullet> t', t') \\<in> hull_rel\n  (t', x4) \\<in> Tree_wf\n\ngoal (1 subgoal):\n 1. (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "by auto"], ["proof (state)\nthis:\n  (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (hull_rel O Tree_wf) O\n               Validity.alpha_Tree_rel \\<Longrightarrow>\n       x \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "with x"], ["proof (chain)\npicking this:\n  x = (x1, x4)\n  (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "show \"x \\<in> alpha_Tree_rel O hull_rel O Tree_wf\""], ["proof (prove)\nusing this:\n  x = (x1, x4)\n  (x1, x4) \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n\ngoal (1 subgoal):\n 1. x \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf", "by simp"], ["proof (state)\nthis:\n  x \\<in> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (hull_rel O Tree_wf) O Validity.alpha_Tree_rel\n  \\<subseteq> Validity.alpha_Tree_rel O hull_rel O Tree_wf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alpha_Tree_rel_relcomp_trivialI [simp]:\n  assumes \"(x, y) \\<in> R\"\n  shows \"(x, y) \\<in> alpha_Tree_rel O R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> Validity.alpha_Tree_rel O R", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> Validity.alpha_Tree_rel O R", "unfolding alpha_Tree_rel_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> {(x, y). x =\\<^sub>\\<alpha> y} O R", "by (metis Tree\\<^sub>\\<alpha>.abs_eq_iff case_prodI mem_Collect_eq relcomp.relcompI)"], ["", "lemma alpha_Tree_rel_relcompI [simp]:\n  assumes \"x =\\<^sub>\\<alpha> x'\" and \"(x', y) \\<in> R\"\n  shows \"(x, y) \\<in> alpha_Tree_rel O R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> Validity.alpha_Tree_rel O R", "using assms"], ["proof (prove)\nusing this:\n  x =\\<^sub>\\<alpha> x'\n  (x', y) \\<in> R\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> Validity.alpha_Tree_rel O R", "unfolding alpha_Tree_rel_def"], ["proof (prove)\nusing this:\n  x =\\<^sub>\\<alpha> x'\n  (x', y) \\<in> R\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> {(x, y). x =\\<^sub>\\<alpha> y} O R", "by (metis case_prodI mem_Collect_eq relcomp.relcompI)"], ["", "subsection \\<open>Validity for infinitely branching trees\\<close>"], ["", "context nominal_ts\nbegin"], ["", "text \\<open>Since we defined formulas via a manual quotient construction, we also need to define\n  validity via lifting from the underlying type of infinitely branching trees. We cannot use\n  {\\bf nominal\\_function} because that generates proof obligations where, for formulas of the\n  form~@{term \"Conj xset\"}, the assumption that~@{term xset} has finite support is missing.\\<close>"], ["", "declare conj_cong [fundef_cong]"], ["", "function valid_Tree :: \"'state \\<Rightarrow> ('idx,'pred,'act) Tree \\<Rightarrow> bool\" where\n    \"valid_Tree P (tConj tset) \\<longleftrightarrow> (\\<forall>t\\<in>set_bset tset. valid_Tree P t)\"\n  | \"valid_Tree P (tNot t) \\<longleftrightarrow> \\<not> valid_Tree P t\"\n  | \"valid_Tree P (tPred \\<phi>) \\<longleftrightarrow> P \\<turnstile> \\<phi>\"\n  | \"valid_Tree P (tAct \\<alpha> t) \\<longleftrightarrow> (\\<exists>\\<alpha>' t' P'. tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t')\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>Pa tset. x = (Pa, tConj tset) \\<Longrightarrow> P;\n        \\<And>Pa t. x = (Pa, tNot t) \\<Longrightarrow> P;\n        \\<And>Pa \\<phi>. x = (Pa, tPred \\<phi>) \\<Longrightarrow> P;\n        \\<And>Pa \\<alpha> t.\n           x = (Pa, tAct \\<alpha> t) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>P tset Pa tseta.\n       (P, tConj tset) = (Pa, tConj tseta) \\<Longrightarrow>\n       (\\<forall>x1\\<in>set_bset tset. valid_Tree_sumC (P, x1)) =\n       (\\<forall>x1\\<in>set_bset tseta. valid_Tree_sumC (Pa, x1))\n 3. \\<And>P tset Pa t.\n       (P, tConj tset) = (Pa, tNot t) \\<Longrightarrow>\n       (\\<forall>x1\\<in>set_bset tset. valid_Tree_sumC (P, x1)) =\n       (\\<not> valid_Tree_sumC (Pa, t))\n 4. \\<And>P tset Pa \\<phi>.\n       (P, tConj tset) = (Pa, tPred \\<phi>) \\<Longrightarrow>\n       (\\<forall>x1\\<in>set_bset tset. valid_Tree_sumC (P, x1)) =\n       Pa \\<turnstile> \\<phi>\n 5. \\<And>P tset Pa \\<alpha> t.\n       (P, tConj tset) = (Pa, tAct \\<alpha> t) \\<Longrightarrow>\n       (\\<forall>x1\\<in>set_bset tset. valid_Tree_sumC (P, x1)) =\n       (\\<exists>\\<alpha>' t' P'.\n           tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n           Pa \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n           valid_Tree_sumC (P', t'))\n 6. \\<And>P t Pa ta.\n       (P, tNot t) = (Pa, tNot ta) \\<Longrightarrow>\n       (\\<not> valid_Tree_sumC (P, t)) = (\\<not> valid_Tree_sumC (Pa, ta))\n 7. \\<And>P t Pa \\<phi>.\n       (P, tNot t) = (Pa, tPred \\<phi>) \\<Longrightarrow>\n       (\\<not> valid_Tree_sumC (P, t)) = Pa \\<turnstile> \\<phi>\n 8. \\<And>P t Pa \\<alpha> ta.\n       (P, tNot t) = (Pa, tAct \\<alpha> ta) \\<Longrightarrow>\n       (\\<not> valid_Tree_sumC (P, t)) =\n       (\\<exists>\\<alpha>' t' P'.\n           tAct \\<alpha> ta =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n           Pa \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n           valid_Tree_sumC (P', t'))\n 9. \\<And>P \\<phi> Pa \\<phi>'.\n       (P, tPred \\<phi>) = (Pa, tPred \\<phi>') \\<Longrightarrow>\n       P \\<turnstile> \\<phi> = Pa \\<turnstile> \\<phi>'\n 10. \\<And>P \\<phi> Pa \\<alpha> t.\n        (P, tPred \\<phi>) = (Pa, tAct \\<alpha> t) \\<Longrightarrow>\n        P \\<turnstile> \\<phi> =\n        (\\<exists>\\<alpha>' t' P'.\n            tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n            Pa \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n            valid_Tree_sumC (P', t'))\nA total of 11 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All valid_Tree_dom", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?R\n 2. \\<And>P tset x.\n       x \\<in> set_bset tset \\<Longrightarrow>\n       ((P, x), P, tConj tset) \\<in> ?R\n 3. \\<And>P t. ((P, t), P, tNot t) \\<in> ?R\n 4. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t) \\<in> ?R", "let ?R = \"inv_image (alpha_Tree_rel O hull_rel O Tree_wf) snd\""], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?R\n 2. \\<And>P tset x.\n       x \\<in> set_bset tset \\<Longrightarrow>\n       ((P, x), P, tConj tset) \\<in> ?R\n 3. \\<And>P t. ((P, t), P, tNot t) \\<in> ?R\n 4. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t) \\<in> ?R", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?R\n 2. \\<And>P tset x.\n       x \\<in> set_bset tset \\<Longrightarrow>\n       ((P, x), P, tConj tset) \\<in> ?R\n 3. \\<And>P t. ((P, t), P, tNot t) \\<in> ?R\n 4. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t) \\<in> ?R", "show \"wf ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd)", "by (metis wf_alpha_Tree_rel_hull_rel_Tree_wf wf_inv_image)"], ["proof (state)\nthis:\n  wf (inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd)\n\ngoal (3 subgoals):\n 1. \\<And>P tset x.\n       x \\<in> set_bset tset \\<Longrightarrow>\n       ((P, x), P, tConj tset)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 2. \\<And>P t.\n       ((P, t), P, tNot t)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 3. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P tset x.\n       x \\<in> set_bset tset \\<Longrightarrow>\n       ((P, x), P, tConj tset)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 2. \\<And>P t.\n       ((P, t), P, tNot t)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 3. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "fix P :: 'state and tset :: \"('idx,'pred,'act) Tree set['idx]\" and t"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P tset x.\n       x \\<in> set_bset tset \\<Longrightarrow>\n       ((P, x), P, tConj tset)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 2. \\<And>P t.\n       ((P, t), P, tNot t)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 3. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "assume \"t \\<in> set_bset tset\""], ["proof (state)\nthis:\n  t \\<in> set_bset tset\n\ngoal (3 subgoals):\n 1. \\<And>P tset x.\n       x \\<in> set_bset tset \\<Longrightarrow>\n       ((P, x), P, tConj tset)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 2. \\<And>P t.\n       ((P, t), P, tNot t)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 3. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "then"], ["proof (chain)\npicking this:\n  t \\<in> set_bset tset", "show \"((P, t), (P, tConj tset)) \\<in> ?R\""], ["proof (prove)\nusing this:\n  t \\<in> set_bset tset\n\ngoal (1 subgoal):\n 1. ((P, t), P, tConj tset)\n    \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd", "by (simp add: Tree_wf.intros(1))"], ["proof (state)\nthis:\n  ((P, t), P, tConj tset)\n  \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n\ngoal (2 subgoals):\n 1. \\<And>P t.\n       ((P, t), P, tNot t)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 2. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P t.\n       ((P, t), P, tNot t)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 2. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "fix P :: 'state and t :: \"('idx,'pred,'act) Tree\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P t.\n       ((P, t), P, tNot t)\n       \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n 2. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "show \"((P, t), (P, tNot t)) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P, t), P, tNot t)\n    \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd", "by (simp add: Tree_wf.intros(2))"], ["proof (state)\nthis:\n  ((P, t), P, tNot t)\n  \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n\ngoal (1 subgoal):\n 1. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "fix P1 P2 :: 'state and \\<alpha>1 \\<alpha>2 :: 'act and t1 t2 :: \"('idx,'pred,'act) Tree\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "assume \"tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\""], ["proof (state)\nthis:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\n\ngoal (1 subgoal):\n 1. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "then"], ["proof (chain)\npicking this:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2", "obtain p where \"t2 =\\<^sub>\\<alpha> p \\<bullet> t1\""], ["proof (prove)\nusing this:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        t2 =\\<^sub>\\<alpha> p \\<bullet> t1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: alphas) (metis alpha_Tree_symp sympE)"], ["proof (state)\nthis:\n  t2 =\\<^sub>\\<alpha> p \\<bullet> t1\n\ngoal (1 subgoal):\n 1. \\<And>P \\<alpha> t x xa xb.\n       \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n        P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa), P, tAct \\<alpha> t)\n                         \\<in> inv_image\n                                (Validity.alpha_Tree_rel O\n                                 hull_rel O Tree_wf)\n                                snd", "then"], ["proof (chain)\npicking this:\n  t2 =\\<^sub>\\<alpha> p \\<bullet> t1", "show \"((P2, t2), (P1, tAct \\<alpha>1 t1)) \\<in> ?R\""], ["proof (prove)\nusing this:\n  t2 =\\<^sub>\\<alpha> p \\<bullet> t1\n\ngoal (1 subgoal):\n 1. ((P2, t2), P1, tAct \\<alpha>1 t1)\n    \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd", "by (simp add: Tree_wf.intros(3))"], ["proof (state)\nthis:\n  ((P2, t2), P1, tAct \\<alpha>1 t1)\n  \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  tAct ?\\<alpha>1.8 ?t1.8 =\\<^sub>\\<alpha>\n  tAct ?\\<alpha>2.8 ?t2.8 \\<Longrightarrow>\n  ((?P2.8, ?t2.8), ?P1.8, tAct ?\\<alpha>1.8 ?t1.8)\n  \\<in> inv_image (Validity.alpha_Tree_rel O hull_rel O Tree_wf) snd\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{const valid_Tree} is equivariant.\\<close>"], ["", "lemma valid_Tree_eqvt': \"valid_Tree P t \\<longleftrightarrow> valid_Tree (p \\<bullet> P) (p \\<bullet> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree P t = valid_Tree (p \\<bullet> P) (p \\<bullet> t)", "proof (induction P t rule: valid_Tree.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>P tset.\n       (\\<And>x.\n           x \\<in> set_bset tset \\<Longrightarrow>\n           valid_Tree P x =\n           valid_Tree (p \\<bullet> P) (p \\<bullet> x)) \\<Longrightarrow>\n       valid_Tree P (tConj tset) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. \\<And>P t.\n       valid_Tree P t =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> t) \\<Longrightarrow>\n       valid_Tree P (tNot t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tNot t)\n 3. \\<And>P \\<phi>.\n       valid_Tree P (tPred \\<phi>) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tPred \\<phi>)\n 4. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "case (1 P tset)"], ["proof (state)\nthis:\n  ?x5 \\<in> set_bset tset \\<Longrightarrow>\n  valid_Tree P ?x5 = valid_Tree (p \\<bullet> P) (p \\<bullet> ?x5)\n\ngoal (4 subgoals):\n 1. \\<And>P tset.\n       (\\<And>x.\n           x \\<in> set_bset tset \\<Longrightarrow>\n           valid_Tree P x =\n           valid_Tree (p \\<bullet> P) (p \\<bullet> x)) \\<Longrightarrow>\n       valid_Tree P (tConj tset) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. \\<And>P t.\n       valid_Tree P t =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> t) \\<Longrightarrow>\n       valid_Tree P (tNot t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tNot t)\n 3. \\<And>P \\<phi>.\n       valid_Tree P (tPred \\<phi>) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tPred \\<phi>)\n 4. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree P (tConj tset) =\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_Tree P (tConj tset) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "assume *: \"valid_Tree P (tConj tset)\""], ["proof (state)\nthis:\n  valid_Tree P (tConj tset)\n\ngoal (2 subgoals):\n 1. valid_Tree P (tConj tset) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "{"], ["proof (state)\nthis:\n  valid_Tree P (tConj tset)\n\ngoal (2 subgoals):\n 1. valid_Tree P (tConj tset) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_Tree P (tConj tset) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "assume \"t \\<in> p \\<bullet> set_bset tset\""], ["proof (state)\nthis:\n  t \\<in> p \\<bullet> set_bset tset\n\ngoal (2 subgoals):\n 1. valid_Tree P (tConj tset) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "with \"1.IH\" and \"*\""], ["proof (chain)\npicking this:\n  ?x5 \\<in> set_bset tset \\<Longrightarrow>\n  valid_Tree P ?x5 = valid_Tree (p \\<bullet> P) (p \\<bullet> ?x5)\n  valid_Tree P (tConj tset)\n  t \\<in> p \\<bullet> set_bset tset", "have \"valid_Tree (p \\<bullet> P) t\""], ["proof (prove)\nusing this:\n  ?x5 \\<in> set_bset tset \\<Longrightarrow>\n  valid_Tree P ?x5 = valid_Tree (p \\<bullet> P) (p \\<bullet> ?x5)\n  valid_Tree P (tConj tset)\n  t \\<in> p \\<bullet> set_bset tset\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) t", "by (metis (no_types, lifting) imageE permute_set_eq_image valid_Tree.simps(1))"], ["proof (state)\nthis:\n  valid_Tree (p \\<bullet> P) t\n\ngoal (2 subgoals):\n 1. valid_Tree P (tConj tset) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "}"], ["proof (state)\nthis:\n  ?ta7 \\<in> p \\<bullet> set_bset tset \\<Longrightarrow>\n  valid_Tree (p \\<bullet> P) ?ta7\n\ngoal (2 subgoals):\n 1. valid_Tree P (tConj tset) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n 2. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "then"], ["proof (chain)\npicking this:\n  ?ta7 \\<in> p \\<bullet> set_bset tset \\<Longrightarrow>\n  valid_Tree (p \\<bullet> P) ?ta7", "show \"valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\""], ["proof (prove)\nusing this:\n  ?ta7 \\<in> p \\<bullet> set_bset tset \\<Longrightarrow>\n  valid_Tree (p \\<bullet> P) ?ta7\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)", "by simp"], ["proof (state)\nthis:\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "assume *: \"valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\""], ["proof (state)\nthis:\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "{"], ["proof (state)\nthis:\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "assume \"t \\<in> set_bset tset\""], ["proof (state)\nthis:\n  t \\<in> set_bset tset\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "with \"1.IH\" and \"*\""], ["proof (chain)\npicking this:\n  ?x5 \\<in> set_bset tset \\<Longrightarrow>\n  valid_Tree P ?x5 = valid_Tree (p \\<bullet> P) (p \\<bullet> ?x5)\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n  t \\<in> set_bset tset", "have \"valid_Tree P t\""], ["proof (prove)\nusing this:\n  ?x5 \\<in> set_bset tset \\<Longrightarrow>\n  valid_Tree P ?x5 = valid_Tree (p \\<bullet> P) (p \\<bullet> ?x5)\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n  t \\<in> set_bset tset\n\ngoal (1 subgoal):\n 1. valid_Tree P t", "by (metis mem_permute_iff permute_Tree_tConj set_bset_eqvt valid_Tree.simps(1))"], ["proof (state)\nthis:\n  valid_Tree P t\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "}"], ["proof (state)\nthis:\n  ?ta7 \\<in> set_bset tset \\<Longrightarrow> valid_Tree P ?ta7\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset) \\<Longrightarrow>\n    valid_Tree P (tConj tset)", "then"], ["proof (chain)\npicking this:\n  ?ta7 \\<in> set_bset tset \\<Longrightarrow> valid_Tree P ?ta7", "show \"valid_Tree P (tConj tset)\""], ["proof (prove)\nusing this:\n  ?ta7 \\<in> set_bset tset \\<Longrightarrow> valid_Tree P ?ta7\n\ngoal (1 subgoal):\n 1. valid_Tree P (tConj tset)", "by simp"], ["proof (state)\nthis:\n  valid_Tree P (tConj tset)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_Tree P (tConj tset) =\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tConj tset)\n\ngoal (3 subgoals):\n 1. \\<And>P t.\n       valid_Tree P t =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> t) \\<Longrightarrow>\n       valid_Tree P (tNot t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tNot t)\n 2. \\<And>P \\<phi>.\n       valid_Tree P (tPred \\<phi>) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tPred \\<phi>)\n 3. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P t.\n       valid_Tree P t =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> t) \\<Longrightarrow>\n       valid_Tree P (tNot t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tNot t)\n 2. \\<And>P \\<phi>.\n       valid_Tree P (tPred \\<phi>) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tPred \\<phi>)\n 3. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "case 2"], ["proof (state)\nthis:\n  valid_Tree P_ t_ = valid_Tree (p \\<bullet> P_) (p \\<bullet> t_)\n\ngoal (3 subgoals):\n 1. \\<And>P t.\n       valid_Tree P t =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> t) \\<Longrightarrow>\n       valid_Tree P (tNot t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tNot t)\n 2. \\<And>P \\<phi>.\n       valid_Tree P (tPred \\<phi>) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tPred \\<phi>)\n 3. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "then"], ["proof (chain)\npicking this:\n  valid_Tree P_ t_ = valid_Tree (p \\<bullet> P_) (p \\<bullet> t_)", "show ?case"], ["proof (prove)\nusing this:\n  valid_Tree P_ t_ = valid_Tree (p \\<bullet> P_) (p \\<bullet> t_)\n\ngoal (1 subgoal):\n 1. valid_Tree P_ (tNot t_) =\n    valid_Tree (p \\<bullet> P_) (p \\<bullet> tNot t_)", "by simp"], ["proof (state)\nthis:\n  valid_Tree P_ (tNot t_) =\n  valid_Tree (p \\<bullet> P_) (p \\<bullet> tNot t_)\n\ngoal (2 subgoals):\n 1. \\<And>P \\<phi>.\n       valid_Tree P (tPred \\<phi>) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tPred \\<phi>)\n 2. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P \\<phi>.\n       valid_Tree P (tPred \\<phi>) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tPred \\<phi>)\n 2. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>P \\<phi>.\n       valid_Tree P (tPred \\<phi>) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tPred \\<phi>)\n 2. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree P_ (tPred \\<phi>_) =\n    valid_Tree (p \\<bullet> P_) (p \\<bullet> tPred \\<phi>_)", "by simp (metis permute_minus_cancel(2) satisfies_eqvt)"], ["proof (state)\nthis:\n  valid_Tree P_ (tPred \\<phi>_) =\n  valid_Tree (p \\<bullet> P_) (p \\<bullet> tPred \\<phi>_)\n\ngoal (1 subgoal):\n 1. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "case (4 P \\<alpha> t)"], ["proof (state)\nthis:\n  \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct ?x5 ?xa5;\n   P \\<rightarrow> \\<langle>?x5,?xb5\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?xb5 ?xa5 =\n                    valid_Tree (p \\<bullet> ?xb5) (p \\<bullet> ?xa5)\n\ngoal (1 subgoal):\n 1. \\<And>P \\<alpha> t.\n       (\\<And>x xa xb.\n           \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct x xa;\n            P \\<rightarrow> \\<langle>x,xb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> valid_Tree xb xa =\n                             valid_Tree (p \\<bullet> xb)\n                              (p \\<bullet> xa)) \\<Longrightarrow>\n       valid_Tree P (tAct \\<alpha> t) =\n       valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha> t) =\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n 2. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "assume \"valid_Tree P (tAct \\<alpha> t)\""], ["proof (state)\nthis:\n  valid_Tree P (tAct \\<alpha> t)\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n 2. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "then"], ["proof (chain)\npicking this:\n  valid_Tree P (tAct \\<alpha> t)", "obtain \\<alpha>' t' P' where *: \"tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\""], ["proof (prove)\nusing this:\n  valid_Tree P (tAct \\<alpha> t)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>' t' P'.\n        tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n        P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n        valid_Tree P' t' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n 2. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "with \"4.IH\""], ["proof (chain)\npicking this:\n  \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct ?x5 ?xa5;\n   P \\<rightarrow> \\<langle>?x5,?xb5\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?xb5 ?xa5 =\n                    valid_Tree (p \\<bullet> ?xb5) (p \\<bullet> ?xa5)\n  tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'", "have \"valid_Tree (p \\<bullet> P') (p \\<bullet> t')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct ?x5 ?xa5;\n   P \\<rightarrow> \\<langle>?x5,?xb5\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?xb5 ?xa5 =\n                    valid_Tree (p \\<bullet> ?xb5) (p \\<bullet> ?xa5)\n  tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P') (p \\<bullet> t')", "by blast"], ["proof (state)\nthis:\n  valid_Tree (p \\<bullet> P') (p \\<bullet> t')\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n 2. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "moreover"], ["proof (state)\nthis:\n  valid_Tree (p \\<bullet> P') (p \\<bullet> t')\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n 2. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "from \"*\""], ["proof (chain)\npicking this:\n  tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'", "have \"p \\<bullet> P \\<rightarrow> \\<langle>p \\<bullet> \\<alpha>', p \\<bullet> P'\\<rangle>\""], ["proof (prove)\nusing this:\n  tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. p \\<bullet> P \\<rightarrow>\n    \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle>", "by (metis transition_eqvt')"], ["proof (state)\nthis:\n  p \\<bullet> P \\<rightarrow>\n  \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle>\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n 2. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "moreover"], ["proof (state)\nthis:\n  p \\<bullet> P \\<rightarrow>\n  \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle>\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n 2. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "from \"*\""], ["proof (chain)\npicking this:\n  tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'", "have \"p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha> tAct (p \\<bullet> \\<alpha>') (p \\<bullet> t')\""], ["proof (prove)\nusing this:\n  tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha>\n    tAct (p \\<bullet> \\<alpha>') (p \\<bullet> t')", "by (metis alpha_Tree_eqvt permute_Tree.simps(4))"], ["proof (state)\nthis:\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha>\n  tAct (p \\<bullet> \\<alpha>') (p \\<bullet> t')\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n 2. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "ultimately"], ["proof (chain)\npicking this:\n  valid_Tree (p \\<bullet> P') (p \\<bullet> t')\n  p \\<bullet> P \\<rightarrow>\n  \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle>\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha>\n  tAct (p \\<bullet> \\<alpha>') (p \\<bullet> t')", "show \"valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\""], ["proof (prove)\nusing this:\n  valid_Tree (p \\<bullet> P') (p \\<bullet> t')\n  p \\<bullet> P \\<rightarrow>\n  \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle>\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha>\n  tAct (p \\<bullet> \\<alpha>') (p \\<bullet> t')\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "by auto"], ["proof (state)\nthis:\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "assume \"valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\""], ["proof (state)\nthis:\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "then"], ["proof (chain)\npicking this:\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)", "obtain \\<alpha>' t' P' where *: \"p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and> (p \\<bullet> P) \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\""], ["proof (prove)\nusing this:\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>' t' P'.\n        p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha>\n        tAct \\<alpha>' t' \\<and>\n        p \\<bullet> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n        valid_Tree P' t' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  p \\<bullet> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n  valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "then"], ["proof (chain)\npicking this:\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  p \\<bullet> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n  valid_Tree P' t'", "have eq: \"tAct \\<alpha> t =\\<^sub>\\<alpha> tAct (-p \\<bullet> \\<alpha>') (-p \\<bullet> t')\""], ["proof (prove)\nusing this:\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  p \\<bullet> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n  valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. tAct \\<alpha> t =\\<^sub>\\<alpha>\n    tAct (- p \\<bullet> \\<alpha>') (- p \\<bullet> t')", "by (metis alpha_Tree_eqvt permute_Tree.simps(4) permute_minus_cancel(2))"], ["proof (state)\nthis:\n  tAct \\<alpha> t =\\<^sub>\\<alpha>\n  tAct (- p \\<bullet> \\<alpha>') (- p \\<bullet> t')\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "moreover"], ["proof (state)\nthis:\n  tAct \\<alpha> t =\\<^sub>\\<alpha>\n  tAct (- p \\<bullet> \\<alpha>') (- p \\<bullet> t')\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "from \"*\""], ["proof (chain)\npicking this:\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  p \\<bullet> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n  valid_Tree P' t'", "have \"P \\<rightarrow> \\<langle>-p \\<bullet> \\<alpha>', -p \\<bullet> P'\\<rangle>\""], ["proof (prove)\nusing this:\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  p \\<bullet> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n  valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. P \\<rightarrow>\n    \\<langle>- p \\<bullet> \\<alpha>',- p \\<bullet> P'\\<rangle>", "by (metis permute_minus_cancel(2) transition_eqvt')"], ["proof (state)\nthis:\n  P \\<rightarrow> \\<langle>- p \\<bullet> \\<alpha>',- p \\<bullet> P'\\<rangle>\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "moreover"], ["proof (state)\nthis:\n  P \\<rightarrow> \\<langle>- p \\<bullet> \\<alpha>',- p \\<bullet> P'\\<rangle>\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "with \"4.IH\""], ["proof (chain)\npicking this:\n  \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct ?x5 ?xa5;\n   P \\<rightarrow> \\<langle>?x5,?xb5\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?xb5 ?xa5 =\n                    valid_Tree (p \\<bullet> ?xb5) (p \\<bullet> ?xa5)\n  P \\<rightarrow> \\<langle>- p \\<bullet> \\<alpha>',- p \\<bullet> P'\\<rangle>", "have \"valid_Tree (-p \\<bullet> P') (-p \\<bullet> t')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct ?x5 ?xa5;\n   P \\<rightarrow> \\<langle>?x5,?xb5\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?xb5 ?xa5 =\n                    valid_Tree (p \\<bullet> ?xb5) (p \\<bullet> ?xa5)\n  P \\<rightarrow> \\<langle>- p \\<bullet> \\<alpha>',- p \\<bullet> P'\\<rangle>\n\ngoal (1 subgoal):\n 1. valid_Tree (- p \\<bullet> P') (- p \\<bullet> t')", "using eq and \"*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tAct \\<alpha> t =\\<^sub>\\<alpha> tAct ?x5 ?xa5;\n   P \\<rightarrow> \\<langle>?x5,?xb5\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?xb5 ?xa5 =\n                    valid_Tree (p \\<bullet> ?xb5) (p \\<bullet> ?xa5)\n  P \\<rightarrow> \\<langle>- p \\<bullet> \\<alpha>',- p \\<bullet> P'\\<rangle>\n  tAct \\<alpha> t =\\<^sub>\\<alpha>\n  tAct (- p \\<bullet> \\<alpha>') (- p \\<bullet> t')\n  p \\<bullet> tAct \\<alpha> t =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  p \\<bullet> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n  valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. valid_Tree (- p \\<bullet> P') (- p \\<bullet> t')", "by simp"], ["proof (state)\nthis:\n  valid_Tree (- p \\<bullet> P') (- p \\<bullet> t')\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P)\n     (p \\<bullet> tAct \\<alpha> t) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha> t)", "ultimately"], ["proof (chain)\npicking this:\n  tAct \\<alpha> t =\\<^sub>\\<alpha>\n  tAct (- p \\<bullet> \\<alpha>') (- p \\<bullet> t')\n  P \\<rightarrow> \\<langle>- p \\<bullet> \\<alpha>',- p \\<bullet> P'\\<rangle>\n  valid_Tree (- p \\<bullet> P') (- p \\<bullet> t')", "show \"valid_Tree P (tAct \\<alpha> t)\""], ["proof (prove)\nusing this:\n  tAct \\<alpha> t =\\<^sub>\\<alpha>\n  tAct (- p \\<bullet> \\<alpha>') (- p \\<bullet> t')\n  P \\<rightarrow> \\<langle>- p \\<bullet> \\<alpha>',- p \\<bullet> P'\\<rangle>\n  valid_Tree (- p \\<bullet> P') (- p \\<bullet> t')\n\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha> t)", "by auto"], ["proof (state)\nthis:\n  valid_Tree P (tAct \\<alpha> t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_Tree P (tAct \\<alpha> t) =\n  valid_Tree (p \\<bullet> P) (p \\<bullet> tAct \\<alpha> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Tree_eqvt (*[eqvt]*):\n    assumes \"valid_Tree P t\" shows \"valid_Tree (p \\<bullet> P) (p \\<bullet> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> t)", "using assms"], ["proof (prove)\nusing this:\n  valid_Tree P t\n\ngoal (1 subgoal):\n 1. valid_Tree (p \\<bullet> P) (p \\<bullet> t)", "by (metis valid_Tree_eqvt')"], ["", "text \\<open>$\\alpha$-equivalent trees validate the same states.\\<close>"], ["", "lemma alpha_Tree_valid_Tree:\n    assumes \"t1 =\\<^sub>\\<alpha> t2\"\n    shows \"valid_Tree P t1 \\<longleftrightarrow> valid_Tree P t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree P t1 = valid_Tree P t2", "using assms"], ["proof (prove)\nusing this:\n  t1 =\\<^sub>\\<alpha> t2\n\ngoal (1 subgoal):\n 1. valid_Tree P t1 = valid_Tree P t2", "proof (induction t1 t2 arbitrary: P rule: alpha_Tree_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>tset1 tset2 P.\n       \\<lbrakk>\\<And>a b P.\n                   \\<lbrakk>a \\<in> set_bset tset1; b \\<in> set_bset tset2;\n                    a =\\<^sub>\\<alpha> b\\<rbrakk>\n                   \\<Longrightarrow> valid_Tree P a = valid_Tree P b;\n        rel_bset (=\\<^sub>\\<alpha>) tset1 tset2\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tConj tset1) =\n                         valid_Tree P (tConj tset2)\n 2. \\<And>t1 t2 P.\n       \\<lbrakk>t1 =\\<^sub>\\<alpha> t2;\n        \\<And>P. valid_Tree P t1 = valid_Tree P t2\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tNot t1) = valid_Tree P (tNot t2)\n 3. \\<And>\\<phi> P.\n       valid_Tree P (tPred \\<phi>) = valid_Tree P (tPred \\<phi>)\n 4. \\<And>\\<alpha>1 t1 \\<alpha>2 t2 P.\n       \\<lbrakk>\\<And>p P.\n                   p \\<bullet> t1 =\\<^sub>\\<alpha> t2 \\<Longrightarrow>\n                   valid_Tree P (p \\<bullet> t1) = valid_Tree P t2;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t1 =\\<^sub>\\<alpha>\n           t1 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t1) =\n           valid_Tree P t1;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t2 =\\<^sub>\\<alpha>\n           t2 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t2) =\n           valid_Tree P t2;\n        \\<exists>p.\n           (bn \\<alpha>1,\n            t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n           (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n           (bn \\<alpha>1,\n            \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2,\n          \\<alpha>2)\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tAct \\<alpha>1 t1) =\n                         valid_Tree P (tAct \\<alpha>2 t2)", "case tConj"], ["proof (state)\nthis:\n  \\<lbrakk>?a5 \\<in> set_bset tset1_; ?b5 \\<in> set_bset tset2_;\n   ?a5 =\\<^sub>\\<alpha> ?b5\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?P5 ?a5 = valid_Tree ?P5 ?b5\n  rel_bset (=\\<^sub>\\<alpha>) tset1_ tset2_\n\ngoal (4 subgoals):\n 1. \\<And>tset1 tset2 P.\n       \\<lbrakk>\\<And>a b P.\n                   \\<lbrakk>a \\<in> set_bset tset1; b \\<in> set_bset tset2;\n                    a =\\<^sub>\\<alpha> b\\<rbrakk>\n                   \\<Longrightarrow> valid_Tree P a = valid_Tree P b;\n        rel_bset (=\\<^sub>\\<alpha>) tset1 tset2\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tConj tset1) =\n                         valid_Tree P (tConj tset2)\n 2. \\<And>t1 t2 P.\n       \\<lbrakk>t1 =\\<^sub>\\<alpha> t2;\n        \\<And>P. valid_Tree P t1 = valid_Tree P t2\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tNot t1) = valid_Tree P (tNot t2)\n 3. \\<And>\\<phi> P.\n       valid_Tree P (tPred \\<phi>) = valid_Tree P (tPred \\<phi>)\n 4. \\<And>\\<alpha>1 t1 \\<alpha>2 t2 P.\n       \\<lbrakk>\\<And>p P.\n                   p \\<bullet> t1 =\\<^sub>\\<alpha> t2 \\<Longrightarrow>\n                   valid_Tree P (p \\<bullet> t1) = valid_Tree P t2;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t1 =\\<^sub>\\<alpha>\n           t1 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t1) =\n           valid_Tree P t1;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t2 =\\<^sub>\\<alpha>\n           t2 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t2) =\n           valid_Tree P t2;\n        \\<exists>p.\n           (bn \\<alpha>1,\n            t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n           (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n           (bn \\<alpha>1,\n            \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2,\n          \\<alpha>2)\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tAct \\<alpha>1 t1) =\n                         valid_Tree P (tAct \\<alpha>2 t2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a5 \\<in> set_bset tset1_; ?b5 \\<in> set_bset tset2_;\n   ?a5 =\\<^sub>\\<alpha> ?b5\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?P5 ?a5 = valid_Tree ?P5 ?b5\n  rel_bset (=\\<^sub>\\<alpha>) tset1_ tset2_", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a5 \\<in> set_bset tset1_; ?b5 \\<in> set_bset tset2_;\n   ?a5 =\\<^sub>\\<alpha> ?b5\\<rbrakk>\n  \\<Longrightarrow> valid_Tree ?P5 ?a5 = valid_Tree ?P5 ?b5\n  rel_bset (=\\<^sub>\\<alpha>) tset1_ tset2_\n\ngoal (1 subgoal):\n 1. valid_Tree P (tConj tset1_) = valid_Tree P (tConj tset2_)", "by auto (metis (mono_tags) rel_bset.rep_eq rel_set_def)+"], ["proof (state)\nthis:\n  valid_Tree P (tConj tset1_) = valid_Tree P (tConj tset2_)\n\ngoal (3 subgoals):\n 1. \\<And>t1 t2 P.\n       \\<lbrakk>t1 =\\<^sub>\\<alpha> t2;\n        \\<And>P. valid_Tree P t1 = valid_Tree P t2\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tNot t1) = valid_Tree P (tNot t2)\n 2. \\<And>\\<phi> P.\n       valid_Tree P (tPred \\<phi>) = valid_Tree P (tPred \\<phi>)\n 3. \\<And>\\<alpha>1 t1 \\<alpha>2 t2 P.\n       \\<lbrakk>\\<And>p P.\n                   p \\<bullet> t1 =\\<^sub>\\<alpha> t2 \\<Longrightarrow>\n                   valid_Tree P (p \\<bullet> t1) = valid_Tree P t2;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t1 =\\<^sub>\\<alpha>\n           t1 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t1) =\n           valid_Tree P t1;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t2 =\\<^sub>\\<alpha>\n           t2 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t2) =\n           valid_Tree P t2;\n        \\<exists>p.\n           (bn \\<alpha>1,\n            t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n           (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n           (bn \\<alpha>1,\n            \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2,\n          \\<alpha>2)\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tAct \\<alpha>1 t1) =\n                         valid_Tree P (tAct \\<alpha>2 t2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t1 t2 P.\n       \\<lbrakk>t1 =\\<^sub>\\<alpha> t2;\n        \\<And>P. valid_Tree P t1 = valid_Tree P t2\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tNot t1) = valid_Tree P (tNot t2)\n 2. \\<And>\\<phi> P.\n       valid_Tree P (tPred \\<phi>) = valid_Tree P (tPred \\<phi>)\n 3. \\<And>\\<alpha>1 t1 \\<alpha>2 t2 P.\n       \\<lbrakk>\\<And>p P.\n                   p \\<bullet> t1 =\\<^sub>\\<alpha> t2 \\<Longrightarrow>\n                   valid_Tree P (p \\<bullet> t1) = valid_Tree P t2;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t1 =\\<^sub>\\<alpha>\n           t1 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t1) =\n           valid_Tree P t1;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t2 =\\<^sub>\\<alpha>\n           t2 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t2) =\n           valid_Tree P t2;\n        \\<exists>p.\n           (bn \\<alpha>1,\n            t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n           (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n           (bn \\<alpha>1,\n            \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2,\n          \\<alpha>2)\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tAct \\<alpha>1 t1) =\n                         valid_Tree P (tAct \\<alpha>2 t2)", "case (tAct \\<alpha>1 t1 \\<alpha>2 t2)"], ["proof (state)\nthis:\n  ?p5 \\<bullet> t1 =\\<^sub>\\<alpha> t2 \\<Longrightarrow>\n  valid_Tree ?P5 (?p5 \\<bullet> t1) = valid_Tree ?P5 t2\n  (?a5 \\<rightleftharpoons> ?b5) \\<bullet> t1 =\\<^sub>\\<alpha>\n  t1 \\<Longrightarrow>\n  valid_Tree ?P5 ((?a5 \\<rightleftharpoons> ?b5) \\<bullet> t1) =\n  valid_Tree ?P5 t1\n  (?a5 \\<rightleftharpoons> ?b5) \\<bullet> t2 =\\<^sub>\\<alpha>\n  t2 \\<Longrightarrow>\n  valid_Tree ?P5 ((?a5 \\<rightleftharpoons> ?b5) \\<bullet> t2) =\n  valid_Tree ?P5 t2\n  \\<exists>p.\n     (bn \\<alpha>1,\n      t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n     (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n     (bn \\<alpha>1,\n      \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2, \\<alpha>2)\n\ngoal (3 subgoals):\n 1. \\<And>t1 t2 P.\n       \\<lbrakk>t1 =\\<^sub>\\<alpha> t2;\n        \\<And>P. valid_Tree P t1 = valid_Tree P t2\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tNot t1) = valid_Tree P (tNot t2)\n 2. \\<And>\\<phi> P.\n       valid_Tree P (tPred \\<phi>) = valid_Tree P (tPred \\<phi>)\n 3. \\<And>\\<alpha>1 t1 \\<alpha>2 t2 P.\n       \\<lbrakk>\\<And>p P.\n                   p \\<bullet> t1 =\\<^sub>\\<alpha> t2 \\<Longrightarrow>\n                   valid_Tree P (p \\<bullet> t1) = valid_Tree P t2;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t1 =\\<^sub>\\<alpha>\n           t1 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t1) =\n           valid_Tree P t1;\n        \\<And>a b P.\n           (a \\<rightleftharpoons> b) \\<bullet> t2 =\\<^sub>\\<alpha>\n           t2 \\<Longrightarrow>\n           valid_Tree P ((a \\<rightleftharpoons> b) \\<bullet> t2) =\n           valid_Tree P t2;\n        \\<exists>p.\n           (bn \\<alpha>1,\n            t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n           (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n           (bn \\<alpha>1,\n            \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2,\n          \\<alpha>2)\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tAct \\<alpha>1 t1) =\n                         valid_Tree P (tAct \\<alpha>2 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>1 t1) = valid_Tree P (tAct \\<alpha>2 t2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha>1 t1) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>2 t2)\n 2. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "assume \"valid_Tree P (tAct \\<alpha>1 t1)\""], ["proof (state)\nthis:\n  valid_Tree P (tAct \\<alpha>1 t1)\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha>1 t1) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>2 t2)\n 2. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "then"], ["proof (chain)\npicking this:\n  valid_Tree P (tAct \\<alpha>1 t1)", "obtain \\<alpha>' t' P' where \"tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\""], ["proof (prove)\nusing this:\n  valid_Tree P (tAct \\<alpha>1 t1)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>' t' P'.\n        tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n        P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n        valid_Tree P' t' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha>1 t1) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>2 t2)\n 2. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "moreover"], ["proof (state)\nthis:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha>1 t1) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>2 t2)\n 2. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "from tAct.hyps"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     (bn \\<alpha>1,\n      t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n     (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n     (bn \\<alpha>1,\n      \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2, \\<alpha>2)", "have \"tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\""], ["proof (prove)\nusing this:\n  \\<exists>p.\n     (bn \\<alpha>1,\n      t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n     (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n     (bn \\<alpha>1,\n      \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2, \\<alpha>2)\n\ngoal (1 subgoal):\n 1. tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2", "using alpha_tAct"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     (bn \\<alpha>1,\n      t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n     (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n     (bn \\<alpha>1,\n      \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2, \\<alpha>2)\n  (tAct ?\\<alpha>1.0 ?t1.0 =\\<^sub>\\<alpha> tAct ?\\<alpha>2.0 ?t2.0) =\n  (\\<exists>p.\n      (bn ?\\<alpha>1.0,\n       ?t1.0) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n         (=\\<^sub>\\<alpha>) p (bn ?\\<alpha>2.0, ?t2.0) \\<and>\n      (bn ?\\<alpha>1.0,\n       ?\\<alpha>1.0) \\<approx>set (=) supp p (bn ?\\<alpha>2.0,\n        ?\\<alpha>2.0))\n\ngoal (1 subgoal):\n 1. tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2", "by blast"], ["proof (state)\nthis:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\n\ngoal (2 subgoals):\n 1. valid_Tree P (tAct \\<alpha>1 t1) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>2 t2)\n 2. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "ultimately"], ["proof (chain)\npicking this:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2", "show \"valid_Tree P (tAct \\<alpha>2 t2)\""], ["proof (prove)\nusing this:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\n\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>2 t2)", "by (metis Tree\\<^sub>\\<alpha>.abs_eq_iff valid_Tree.simps(4))"], ["proof (state)\nthis:\n  valid_Tree P (tAct \\<alpha>2 t2)\n\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "assume \"valid_Tree P (tAct \\<alpha>2 t2)\""], ["proof (state)\nthis:\n  valid_Tree P (tAct \\<alpha>2 t2)\n\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "then"], ["proof (chain)\npicking this:\n  valid_Tree P (tAct \\<alpha>2 t2)", "obtain \\<alpha>' t' P' where \"tAct \\<alpha>2 t2 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\""], ["proof (prove)\nusing this:\n  valid_Tree P (tAct \\<alpha>2 t2)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>' t' P'.\n        tAct \\<alpha>2 t2 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n        P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n        valid_Tree P' t' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tAct \\<alpha>2 t2 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "moreover"], ["proof (state)\nthis:\n  tAct \\<alpha>2 t2 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "from tAct.hyps"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     (bn \\<alpha>1,\n      t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n     (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n     (bn \\<alpha>1,\n      \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2, \\<alpha>2)", "have \"tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\""], ["proof (prove)\nusing this:\n  \\<exists>p.\n     (bn \\<alpha>1,\n      t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n     (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n     (bn \\<alpha>1,\n      \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2, \\<alpha>2)\n\ngoal (1 subgoal):\n 1. tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2", "using alpha_tAct"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     (bn \\<alpha>1,\n      t1) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n     (=\\<^sub>\\<alpha>) p (bn \\<alpha>2, t2) \\<and>\n     (bn \\<alpha>1,\n      \\<alpha>1) \\<approx>set (=) supp p (bn \\<alpha>2, \\<alpha>2)\n  (tAct ?\\<alpha>1.0 ?t1.0 =\\<^sub>\\<alpha> tAct ?\\<alpha>2.0 ?t2.0) =\n  (\\<exists>p.\n      (bn ?\\<alpha>1.0,\n       ?t1.0) \\<approx>set (=\\<^sub>\\<alpha>) supp_rel\n         (=\\<^sub>\\<alpha>) p (bn ?\\<alpha>2.0, ?t2.0) \\<and>\n      (bn ?\\<alpha>1.0,\n       ?\\<alpha>1.0) \\<approx>set (=) supp p (bn ?\\<alpha>2.0,\n        ?\\<alpha>2.0))\n\ngoal (1 subgoal):\n 1. tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2", "by blast"], ["proof (state)\nthis:\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\n\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>2 t2) \\<Longrightarrow>\n    valid_Tree P (tAct \\<alpha>1 t1)", "ultimately"], ["proof (chain)\npicking this:\n  tAct \\<alpha>2 t2 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2", "show \"valid_Tree P (tAct \\<alpha>1 t1)\""], ["proof (prove)\nusing this:\n  tAct \\<alpha>2 t2 =\\<^sub>\\<alpha> tAct \\<alpha>' t' \\<and>\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree P' t'\n  tAct \\<alpha>1 t1 =\\<^sub>\\<alpha> tAct \\<alpha>2 t2\n\ngoal (1 subgoal):\n 1. valid_Tree P (tAct \\<alpha>1 t1)", "by (metis Tree\\<^sub>\\<alpha>.abs_eq_iff valid_Tree.simps(4))"], ["proof (state)\nthis:\n  valid_Tree P (tAct \\<alpha>1 t1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_Tree P (tAct \\<alpha>1 t1) = valid_Tree P (tAct \\<alpha>2 t2)\n\ngoal (2 subgoals):\n 1. \\<And>t1 t2 P.\n       \\<lbrakk>t1 =\\<^sub>\\<alpha> t2;\n        \\<And>P. valid_Tree P t1 = valid_Tree P t2\\<rbrakk>\n       \\<Longrightarrow> valid_Tree P (tNot t1) = valid_Tree P (tNot t2)\n 2. \\<And>\\<phi> P.\n       valid_Tree P (tPred \\<phi>) = valid_Tree P (tPred \\<phi>)", "qed simp_all"], ["", "subsection \\<open>Validity for trees modulo \\texorpdfstring{$\\alpha$}{alpha}-equivalence\\<close>"], ["", "lift_definition valid_Tree\\<^sub>\\<alpha> :: \"'state \\<Rightarrow> ('idx,'pred,'act) Tree\\<^sub>\\<alpha> \\<Rightarrow> bool\" is\n    valid_Tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>state Tree1 Tree2.\n       Tree1 =\\<^sub>\\<alpha> Tree2 \\<Longrightarrow>\n       valid_Tree state Tree1 = valid_Tree state Tree2", "by (fact alpha_Tree_valid_Tree)"], ["", "lemma valid_Tree\\<^sub>\\<alpha>_eqvt (*[eqvt]*):\n    assumes \"valid_Tree\\<^sub>\\<alpha> P t\" shows \"valid_Tree\\<^sub>\\<alpha> (p \\<bullet> P) (p \\<bullet> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> (p \\<bullet> P) (p \\<bullet> t)", "using assms"], ["proof (prove)\nusing this:\n  valid_Tree\\<^sub>\\<alpha> P t\n\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> (p \\<bullet> P) (p \\<bullet> t)", "by transfer (fact valid_Tree_eqvt)"], ["", "lemma valid_Tree\\<^sub>\\<alpha>_Conj\\<^sub>\\<alpha> [simp]: \"valid_Tree\\<^sub>\\<alpha> P (Conj\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>) \\<longleftrightarrow> (\\<forall>t\\<^sub>\\<alpha>\\<in>set_bset tset\\<^sub>\\<alpha>. valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> P (Conj\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>) =\n    (\\<forall>t\\<^sub>\\<alpha>\\<in>set_bset tset\\<^sub>\\<alpha>.\n        valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> P (Conj\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>) =\n    (\\<forall>t\\<^sub>\\<alpha>\\<in>set_bset tset\\<^sub>\\<alpha>.\n        valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>)", "have \"valid_Tree P (rep_Tree\\<^sub>\\<alpha> (abs_Tree\\<^sub>\\<alpha> (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>)))) \\<longleftrightarrow> valid_Tree P (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree P\n     (rep_Tree\\<^sub>\\<alpha>\n       (abs_Tree\\<^sub>\\<alpha>\n         (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>)))) =\n    valid_Tree P\n     (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>))", "by (metis Tree\\<^sub>\\<alpha>_rep_abs alpha_Tree_valid_Tree)"], ["proof (state)\nthis:\n  valid_Tree P\n   (rep_Tree\\<^sub>\\<alpha>\n     (abs_Tree\\<^sub>\\<alpha>\n       (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>)))) =\n  valid_Tree P\n   (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>))\n\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> P (Conj\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>) =\n    (\\<forall>t\\<^sub>\\<alpha>\\<in>set_bset tset\\<^sub>\\<alpha>.\n        valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>)", "then"], ["proof (chain)\npicking this:\n  valid_Tree P\n   (rep_Tree\\<^sub>\\<alpha>\n     (abs_Tree\\<^sub>\\<alpha>\n       (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>)))) =\n  valid_Tree P\n   (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>))", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_Tree P\n   (rep_Tree\\<^sub>\\<alpha>\n     (abs_Tree\\<^sub>\\<alpha>\n       (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>)))) =\n  valid_Tree P\n   (tConj (map_bset rep_Tree\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>))\n\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> P (Conj\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>) =\n    (\\<forall>t\\<^sub>\\<alpha>\\<in>set_bset tset\\<^sub>\\<alpha>.\n        valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>)", "by (simp add: valid_Tree\\<^sub>\\<alpha>_def Conj\\<^sub>\\<alpha>_def map_bset.rep_eq)"], ["proof (state)\nthis:\n  valid_Tree\\<^sub>\\<alpha> P (Conj\\<^sub>\\<alpha> tset\\<^sub>\\<alpha>) =\n  (\\<forall>t\\<^sub>\\<alpha>\\<in>set_bset tset\\<^sub>\\<alpha>.\n      valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Tree\\<^sub>\\<alpha>_Not\\<^sub>\\<alpha> [simp]: \"valid_Tree\\<^sub>\\<alpha> P (Not\\<^sub>\\<alpha> t\\<^sub>\\<alpha>) \\<longleftrightarrow> \\<not> valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> P (Not\\<^sub>\\<alpha> t\\<^sub>\\<alpha>) =\n    (\\<not> valid_Tree\\<^sub>\\<alpha> P t\\<^sub>\\<alpha>)", "by transfer simp"], ["", "lemma valid_Tree\\<^sub>\\<alpha>_Pred\\<^sub>\\<alpha> [simp]: \"valid_Tree\\<^sub>\\<alpha> P (Pred\\<^sub>\\<alpha> \\<phi>) \\<longleftrightarrow> P \\<turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> P (Pred\\<^sub>\\<alpha> \\<phi>) =\n    P \\<turnstile> \\<phi>", "by transfer simp"], ["", "lemma valid_Tree\\<^sub>\\<alpha>_Act\\<^sub>\\<alpha> [simp]: \"valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>) \\<longleftrightarrow> (\\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'. Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> = Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>) =\n    (\\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n        Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n        Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n        P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n        valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>) \\<Longrightarrow>\n    \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n 2. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "assume \"valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)\""], ["proof (state)\nthis:\n  valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)\n\ngoal (2 subgoals):\n 1. valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>) \\<Longrightarrow>\n    \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n 2. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "moreover"], ["proof (state)\nthis:\n  valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)\n\ngoal (2 subgoals):\n 1. valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>) \\<Longrightarrow>\n    \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n 2. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "have \"Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> = abs_Tree\\<^sub>\\<alpha> (tAct \\<alpha> (rep_Tree\\<^sub>\\<alpha> t\\<^sub>\\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n    abs_Tree\\<^sub>\\<alpha>\n     (tAct \\<alpha> (rep_Tree\\<^sub>\\<alpha> t\\<^sub>\\<alpha>))", "by (metis Act\\<^sub>\\<alpha>.abs_eq Tree\\<^sub>\\<alpha>_abs_rep)"], ["proof (state)\nthis:\n  Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n  abs_Tree\\<^sub>\\<alpha>\n   (tAct \\<alpha> (rep_Tree\\<^sub>\\<alpha> t\\<^sub>\\<alpha>))\n\ngoal (2 subgoals):\n 1. valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>) \\<Longrightarrow>\n    \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n 2. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "ultimately"], ["proof (chain)\npicking this:\n  valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)\n  Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n  abs_Tree\\<^sub>\\<alpha>\n   (tAct \\<alpha> (rep_Tree\\<^sub>\\<alpha> t\\<^sub>\\<alpha>))", "show \"\\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'. Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> = Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\""], ["proof (prove)\nusing this:\n  valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)\n  Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n  abs_Tree\\<^sub>\\<alpha>\n   (tAct \\<alpha> (rep_Tree\\<^sub>\\<alpha> t\\<^sub>\\<alpha>))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'", "by (metis Act\\<^sub>\\<alpha>.abs_eq Tree\\<^sub>\\<alpha>.abs_eq_iff valid_Tree.simps(4) valid_Tree\\<^sub>\\<alpha>.abs_eq)"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n     Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n     Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "assume \"\\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'. Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> = Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\""], ["proof (state)\nthis:\n  \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n     Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n     Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "moreover"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n     Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n     Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "have \"\\<And>\\<alpha>' t\\<^sub>\\<alpha>'. Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' = abs_Tree\\<^sub>\\<alpha> (tAct \\<alpha>' (rep_Tree\\<^sub>\\<alpha> t\\<^sub>\\<alpha>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>' t\\<^sub>\\<alpha>'.\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' =\n       abs_Tree\\<^sub>\\<alpha>\n        (tAct \\<alpha>' (rep_Tree\\<^sub>\\<alpha> t\\<^sub>\\<alpha>'))", "by (metis Act\\<^sub>\\<alpha>.abs_eq Tree\\<^sub>\\<alpha>_abs_rep)"], ["proof (state)\nthis:\n  Act\\<^sub>\\<alpha> ?\\<alpha>'6 ?t\\<^sub>\\<alpha>'6 =\n  abs_Tree\\<^sub>\\<alpha>\n   (tAct ?\\<alpha>'6 (rep_Tree\\<^sub>\\<alpha> ?t\\<^sub>\\<alpha>'6))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n       Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n       Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>' \\<Longrightarrow>\n    valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n     Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n     Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n  Act\\<^sub>\\<alpha> ?\\<alpha>'6 ?t\\<^sub>\\<alpha>'6 =\n  abs_Tree\\<^sub>\\<alpha>\n   (tAct ?\\<alpha>'6 (rep_Tree\\<^sub>\\<alpha> ?t\\<^sub>\\<alpha>'6))", "show \"valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>' t\\<^sub>\\<alpha>' P'.\n     Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha> =\n     Act\\<^sub>\\<alpha> \\<alpha>' t\\<^sub>\\<alpha>' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     valid_Tree\\<^sub>\\<alpha> P' t\\<^sub>\\<alpha>'\n  Act\\<^sub>\\<alpha> ?\\<alpha>'6 ?t\\<^sub>\\<alpha>'6 =\n  abs_Tree\\<^sub>\\<alpha>\n   (tAct ?\\<alpha>'6 (rep_Tree\\<^sub>\\<alpha> ?t\\<^sub>\\<alpha>'6))\n\ngoal (1 subgoal):\n 1. valid_Tree\\<^sub>\\<alpha> P\n     (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)", "by (metis Tree\\<^sub>\\<alpha>.abs_eq_iff valid_Tree.simps(4) valid_Tree\\<^sub>\\<alpha>.abs_eq valid_Tree\\<^sub>\\<alpha>.rep_eq)"], ["proof (state)\nthis:\n  valid_Tree\\<^sub>\\<alpha> P (Act\\<^sub>\\<alpha> \\<alpha> t\\<^sub>\\<alpha>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Validity for infinitary formulas\\<close>"], ["", "lift_definition valid :: \"'state \\<Rightarrow> ('idx,'pred,'act) formula \\<Rightarrow> bool\" (infix \"\\<Turnstile>\" 70) is\n    valid_Tree\\<^sub>\\<alpha>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma valid_eqvt (*[eqvt]*):\n    assumes \"P \\<Turnstile> x\" shows \"(p \\<bullet> P) \\<Turnstile> (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> P \\<Turnstile> p \\<bullet> x", "using assms"], ["proof (prove)\nusing this:\n  P \\<Turnstile> x\n\ngoal (1 subgoal):\n 1. p \\<bullet> P \\<Turnstile> p \\<bullet> x", "by transfer (metis valid_Tree\\<^sub>\\<alpha>_eqvt)"], ["", "lemma valid_Conj [simp]:\n    assumes \"finite (supp xset)\"\n    shows \"P \\<Turnstile> Conj xset \\<longleftrightarrow> (\\<forall>x\\<in>set_bset xset. P \\<Turnstile> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Turnstile> Conj xset =\n    (\\<forall>x\\<in>set_bset xset. P \\<Turnstile> x)", "using assms"], ["proof (prove)\nusing this:\n  finite (supp xset)\n\ngoal (1 subgoal):\n 1. P \\<Turnstile> Conj xset =\n    (\\<forall>x\\<in>set_bset xset. P \\<Turnstile> x)", "by (simp add: valid_def Conj_def map_bset.rep_eq)"], ["", "lemma valid_Not [simp]: \"P \\<Turnstile> Not x \\<longleftrightarrow> \\<not> P \\<Turnstile> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Turnstile> Formula.Not x = (\\<not> P \\<Turnstile> x)", "by transfer simp"], ["", "lemma valid_Pred [simp]: \"P \\<Turnstile> Pred \\<phi> \\<longleftrightarrow> P \\<turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Turnstile> Pred \\<phi> = P \\<turnstile> \\<phi>", "by transfer simp"], ["", "lemma valid_Act: \"P \\<Turnstile> Act \\<alpha> x \\<longleftrightarrow> (\\<exists>\\<alpha>' x' P'. Act \\<alpha> x = Act \\<alpha>' x' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> P' \\<Turnstile> x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Turnstile> Act \\<alpha> x =\n    (\\<exists>\\<alpha>' x' P'.\n        Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n        P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n        P' \\<Turnstile> x')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x'\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "assume \"P \\<Turnstile> Act \\<alpha> x\""], ["proof (state)\nthis:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x'\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "moreover"], ["proof (state)\nthis:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x'\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "have \"Rep_formula (Abs_formula (Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x))) = Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula\n     (Abs_formula (Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x))) =\n    Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x)", "by (metis Act.rep_eq Rep_formula_inverse)"], ["proof (state)\nthis:\n  Rep_formula (Abs_formula (Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x))) =\n  Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x)\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x'\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "ultimately"], ["proof (chain)\npicking this:\n  P \\<Turnstile> Act \\<alpha> x\n  Rep_formula (Abs_formula (Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x))) =\n  Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x)", "show \"\\<exists>\\<alpha>' x' P'. Act \\<alpha> x = Act \\<alpha>' x' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> P' \\<Turnstile> x'\""], ["proof (prove)\nusing this:\n  P \\<Turnstile> Act \\<alpha> x\n  Rep_formula (Abs_formula (Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x))) =\n  Act\\<^sub>\\<alpha> \\<alpha> (Rep_formula x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x'", "by (auto simp add: valid_def Act_def) (metis Abs_formula_inverse Rep_formula' hereditarily_fs_alpha_renaming)"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>' x' P'.\n     Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     P' \\<Turnstile> x'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "assume \"\\<exists>\\<alpha>' x' P'. Act \\<alpha> x = Act \\<alpha>' x' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> P' \\<Turnstile> x'\""], ["proof (state)\nthis:\n  \\<exists>\\<alpha>' x' P'.\n     Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     P' \\<Turnstile> x'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>' x' P'.\n     Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     P' \\<Turnstile> x'", "show \"P \\<Turnstile> Act \\<alpha> x\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>' x' P'.\n     Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     P' \\<Turnstile> x'\n\ngoal (1 subgoal):\n 1. P \\<Turnstile> Act \\<alpha> x", "by (metis Act.rep_eq valid.rep_eq valid_Tree\\<^sub>\\<alpha>_Act\\<^sub>\\<alpha>)"], ["proof (state)\nthis:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The binding names in the alpha-variant that witnesses validity may be chosen fresh for any\n  finitely supported context.\\<close>"], ["", "lemma valid_Act_strong:\n    assumes \"finite (supp X)\"\n    shows \"P \\<Turnstile> Act \\<alpha> x \\<longleftrightarrow> (\\<exists>\\<alpha>' x' P'. Act \\<alpha> x = Act \\<alpha>' x' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Turnstile> Act \\<alpha> x =\n    (\\<exists>\\<alpha>' x' P'.\n        Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n        P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n        P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "assume \"P \\<Turnstile> Act \\<alpha> x\""], ["proof (state)\nthis:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  P \\<Turnstile> Act \\<alpha> x", "obtain \\<alpha>' x' P' where eq: \"Act \\<alpha> x = Act \\<alpha>' x'\" and trans: \"P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>\" and valid: \"P' \\<Turnstile> x'\""], ["proof (prove)\nusing this:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>' x' P'.\n        \\<lbrakk>Act \\<alpha> x = Act \\<alpha>' x';\n         P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>;\n         P' \\<Turnstile> x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis valid_Act)"], ["proof (state)\nthis:\n  Act \\<alpha> x = Act \\<alpha>' x'\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>\n  P' \\<Turnstile> x'\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "have \"finite (bn \\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bn \\<alpha>')", "by (fact bn_finite)"], ["proof (state)\nthis:\n  finite (bn \\<alpha>')\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "moreover"], ["proof (state)\nthis:\n  finite (bn \\<alpha>')\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "note \\<open>finite (supp X)\\<close>"], ["proof (state)\nthis:\n  finite (supp X)\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "moreover"], ["proof (state)\nthis:\n  finite (supp X)\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "have \"finite (supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>))", "by (metis finite_Diff finite_UnI finite_supp supp_Pair supp_abs_residual_pair)"], ["proof (state)\nthis:\n  finite (supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>))\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "moreover"], ["proof (state)\nthis:\n  finite (supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>))\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "have \"bn \\<alpha>' \\<sharp>* (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn \\<alpha>' \\<sharp>* (Act \\<alpha>' x',\n                            \\<langle>\\<alpha>',P'\\<rangle>)", "by (auto simp add: fresh_star_def fresh_def supp_Pair supp_abs_residual_pair)"], ["proof (state)\nthis:\n  bn \\<alpha>' \\<sharp>* (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>)\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "ultimately"], ["proof (chain)\npicking this:\n  finite (bn \\<alpha>')\n  finite (supp X)\n  finite (supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>))\n  bn \\<alpha>' \\<sharp>* (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>)", "obtain p where fresh_X: \"(p \\<bullet> bn \\<alpha>') \\<sharp>* X\" and \"supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>) \\<sharp>* p\""], ["proof (prove)\nusing this:\n  finite (bn \\<alpha>')\n  finite (supp X)\n  finite (supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>))\n  bn \\<alpha>' \\<sharp>* (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(p \\<bullet> bn \\<alpha>') \\<sharp>* X;\n         supp\n          (Act \\<alpha>' x',\n           \\<langle>\\<alpha>',P'\\<rangle>) \\<sharp>* p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis at_set_avoiding2)"], ["proof (state)\nthis:\n  (p \\<bullet> bn \\<alpha>') \\<sharp>* X\n  supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>) \\<sharp>* p\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  (p \\<bullet> bn \\<alpha>') \\<sharp>* X\n  supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>) \\<sharp>* p", "have \"supp (Act \\<alpha>' x') \\<sharp>* p\" and \"supp \\<langle>\\<alpha>',P'\\<rangle> \\<sharp>* p\""], ["proof (prove)\nusing this:\n  (p \\<bullet> bn \\<alpha>') \\<sharp>* X\n  supp (Act \\<alpha>' x', \\<langle>\\<alpha>',P'\\<rangle>) \\<sharp>* p\n\ngoal (1 subgoal):\n 1. supp (Act \\<alpha>' x') \\<sharp>* p &&&\n    supp \\<langle>\\<alpha>',P'\\<rangle> \\<sharp>* p", "by (metis fresh_star_Un supp_Pair)+"], ["proof (state)\nthis:\n  supp (Act \\<alpha>' x') \\<sharp>* p\n  supp \\<langle>\\<alpha>',P'\\<rangle> \\<sharp>* p\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  supp (Act \\<alpha>' x') \\<sharp>* p\n  supp \\<langle>\\<alpha>',P'\\<rangle> \\<sharp>* p", "have \"Act (p \\<bullet> \\<alpha>') (p \\<bullet> x') = Act \\<alpha>' x'\" and \"\\<langle>p \\<bullet> \\<alpha>', p \\<bullet> P'\\<rangle> = \\<langle>\\<alpha>',P'\\<rangle>\""], ["proof (prove)\nusing this:\n  supp (Act \\<alpha>' x') \\<sharp>* p\n  supp \\<langle>\\<alpha>',P'\\<rangle> \\<sharp>* p\n\ngoal (1 subgoal):\n 1. Act (p \\<bullet> \\<alpha>') (p \\<bullet> x') = Act \\<alpha>' x' &&&\n    \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle> =\n    \\<langle>\\<alpha>',P'\\<rangle>", "by (metis Act_eqvt supp_perm_eq, metis abs_residual_pair_eqvt supp_perm_eq)"], ["proof (state)\nthis:\n  Act (p \\<bullet> \\<alpha>') (p \\<bullet> x') = Act \\<alpha>' x'\n  \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle> =\n  \\<langle>\\<alpha>',P'\\<rangle>\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n 2. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  Act (p \\<bullet> \\<alpha>') (p \\<bullet> x') = Act \\<alpha>' x'\n  \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle> =\n  \\<langle>\\<alpha>',P'\\<rangle>", "show \"\\<exists>\\<alpha>' x' P'. Act \\<alpha> x = Act \\<alpha>' x' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\""], ["proof (prove)\nusing this:\n  Act (p \\<bullet> \\<alpha>') (p \\<bullet> x') = Act \\<alpha>' x'\n  \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle> =\n  \\<langle>\\<alpha>',P'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X", "using eq and trans and valid and fresh_X"], ["proof (prove)\nusing this:\n  Act (p \\<bullet> \\<alpha>') (p \\<bullet> x') = Act \\<alpha>' x'\n  \\<langle>p \\<bullet> \\<alpha>',p \\<bullet> P'\\<rangle> =\n  \\<langle>\\<alpha>',P'\\<rangle>\n  Act \\<alpha> x = Act \\<alpha>' x'\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>\n  P' \\<Turnstile> x'\n  (p \\<bullet> bn \\<alpha>') \\<sharp>* X\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X", "by (metis bn_eqvt valid_eqvt)"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>' x' P'.\n     Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "assume \"\\<exists>\\<alpha>' x' P'. Act \\<alpha> x = Act \\<alpha>' x' \\<and> P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and> P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\""], ["proof (state)\nthis:\n  \\<exists>\\<alpha>' x' P'.\n     Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>' x' P'.\n       Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n       P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n       P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>' x' P'.\n     Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X", "show \"P \\<Turnstile> Act \\<alpha> x\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>' x' P'.\n     Act \\<alpha> x = Act \\<alpha>' x' \\<and>\n     P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle> \\<and>\n     P' \\<Turnstile> x' \\<and> bn \\<alpha>' \\<sharp>* X\n\ngoal (1 subgoal):\n 1. P \\<Turnstile> Act \\<alpha> x", "by (metis valid_Act)"], ["proof (state)\nthis:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Act_fresh:\n    assumes \"bn \\<alpha> \\<sharp>* P\"\n    shows \"P \\<Turnstile> Act \\<alpha> x \\<longleftrightarrow> (\\<exists>P'. P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and> P' \\<Turnstile> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Turnstile> Act \\<alpha> x =\n    (\\<exists>P'.\n        P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n        P' \\<Turnstile> x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "assume \"P \\<Turnstile> Act \\<alpha> x\""], ["proof (state)\nthis:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "moreover"], ["proof (state)\nthis:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "have \"finite (supp P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp P)", "by (fact finite_supp)"], ["proof (state)\nthis:\n  finite (supp P)\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "ultimately"], ["proof (chain)\npicking this:\n  P \\<Turnstile> Act \\<alpha> x\n  finite (supp P)", "obtain \\<alpha>' x' P' where\n      eq: \"Act \\<alpha> x = Act \\<alpha>' x'\" and trans: \"P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>\" and valid: \"P' \\<Turnstile> x'\" and fresh: \"bn \\<alpha>' \\<sharp>* P\""], ["proof (prove)\nusing this:\n  P \\<Turnstile> Act \\<alpha> x\n  finite (supp P)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>' x' P'.\n        \\<lbrakk>Act \\<alpha> x = Act \\<alpha>' x';\n         P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>; P' \\<Turnstile> x';\n         bn \\<alpha>' \\<sharp>* P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis valid_Act_strong)"], ["proof (state)\nthis:\n  Act \\<alpha> x = Act \\<alpha>' x'\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>\n  P' \\<Turnstile> x'\n  bn \\<alpha>' \\<sharp>* P\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "from eq"], ["proof (chain)\npicking this:\n  Act \\<alpha> x = Act \\<alpha>' x'", "obtain p where p_\\<alpha>: \"\\<alpha>' = p \\<bullet> \\<alpha>\" and p_x: \"x' = p \\<bullet> x\" and supp_p: \"supp p \\<subseteq> bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>\""], ["proof (prove)\nusing this:\n  Act \\<alpha> x = Act \\<alpha>' x'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>\\<alpha>' = p \\<bullet> \\<alpha>; x' = p \\<bullet> x;\n         supp p\n         \\<subseteq> bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Act_eq_iff_perm_renaming)"], ["proof (state)\nthis:\n  \\<alpha>' = p \\<bullet> \\<alpha>\n  x' = p \\<bullet> x\n  supp p \\<subseteq> bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "from assms and fresh"], ["proof (chain)\npicking this:\n  bn \\<alpha> \\<sharp>* P\n  bn \\<alpha>' \\<sharp>* P", "have \"(bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>) \\<sharp>* P\""], ["proof (prove)\nusing this:\n  bn \\<alpha> \\<sharp>* P\n  bn \\<alpha>' \\<sharp>* P\n\ngoal (1 subgoal):\n 1. (bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>) \\<sharp>* P", "using p_\\<alpha>"], ["proof (prove)\nusing this:\n  bn \\<alpha> \\<sharp>* P\n  bn \\<alpha>' \\<sharp>* P\n  \\<alpha>' = p \\<bullet> \\<alpha>\n\ngoal (1 subgoal):\n 1. (bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>) \\<sharp>* P", "by (metis bn_eqvt fresh_star_Un)"], ["proof (state)\nthis:\n  (bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>) \\<sharp>* P\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  (bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>) \\<sharp>* P", "have \"supp p \\<sharp>* P\""], ["proof (prove)\nusing this:\n  (bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>) \\<sharp>* P\n\ngoal (1 subgoal):\n 1. supp p \\<sharp>* P", "using supp_p"], ["proof (prove)\nusing this:\n  (bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>) \\<sharp>* P\n  supp p \\<subseteq> bn \\<alpha> \\<union> p \\<bullet> bn \\<alpha>\n\ngoal (1 subgoal):\n 1. supp p \\<sharp>* P", "by (metis fresh_star_def subset_eq)"], ["proof (state)\nthis:\n  supp p \\<sharp>* P\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  supp p \\<sharp>* P", "have p_P: \"-p \\<bullet> P = P\""], ["proof (prove)\nusing this:\n  supp p \\<sharp>* P\n\ngoal (1 subgoal):\n 1. - p \\<bullet> P = P", "by (metis perm_supp_eq supp_minus_perm)"], ["proof (state)\nthis:\n  - p \\<bullet> P = P\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "from trans"], ["proof (chain)\npicking this:\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>", "have \"P \\<rightarrow> \\<langle>\\<alpha>,-p \\<bullet> P'\\<rangle>\""], ["proof (prove)\nusing this:\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<rightarrow> \\<langle>\\<alpha>,- p \\<bullet> P'\\<rangle>", "using p_P p_\\<alpha>"], ["proof (prove)\nusing this:\n  P \\<rightarrow> \\<langle>\\<alpha>',P'\\<rangle>\n  - p \\<bullet> P = P\n  \\<alpha>' = p \\<bullet> \\<alpha>\n\ngoal (1 subgoal):\n 1. P \\<rightarrow> \\<langle>\\<alpha>,- p \\<bullet> P'\\<rangle>", "by (metis permute_minus_cancel(1) transition_eqvt')"], ["proof (state)\nthis:\n  P \\<rightarrow> \\<langle>\\<alpha>,- p \\<bullet> P'\\<rangle>\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "moreover"], ["proof (state)\nthis:\n  P \\<rightarrow> \\<langle>\\<alpha>,- p \\<bullet> P'\\<rangle>\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "from valid"], ["proof (chain)\npicking this:\n  P' \\<Turnstile> x'", "have \"-p \\<bullet> P' \\<Turnstile> x\""], ["proof (prove)\nusing this:\n  P' \\<Turnstile> x'\n\ngoal (1 subgoal):\n 1. - p \\<bullet> P' \\<Turnstile> x", "using p_x"], ["proof (prove)\nusing this:\n  P' \\<Turnstile> x'\n  x' = p \\<bullet> x\n\ngoal (1 subgoal):\n 1. - p \\<bullet> P' \\<Turnstile> x", "by (metis permute_minus_cancel(1) valid_eqvt)"], ["proof (state)\nthis:\n  - p \\<bullet> P' \\<Turnstile> x\n\ngoal (2 subgoals):\n 1. P \\<Turnstile> Act \\<alpha> x \\<Longrightarrow>\n    \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x\n 2. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "ultimately"], ["proof (chain)\npicking this:\n  P \\<rightarrow> \\<langle>\\<alpha>,- p \\<bullet> P'\\<rangle>\n  - p \\<bullet> P' \\<Turnstile> x", "show \"\\<exists>P'. P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and> P' \\<Turnstile> x\""], ["proof (prove)\nusing this:\n  P \\<rightarrow> \\<langle>\\<alpha>,- p \\<bullet> P'\\<rangle>\n  - p \\<bullet> P' \\<Turnstile> x\n\ngoal (1 subgoal):\n 1. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x", "by meson"], ["proof (state)\nthis:\n  \\<exists>P'.\n     P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and> P' \\<Turnstile> x\n\ngoal (1 subgoal):\n 1. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "assume \"\\<exists>P'. P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and> P' \\<Turnstile> x\""], ["proof (state)\nthis:\n  \\<exists>P'.\n     P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and> P' \\<Turnstile> x\n\ngoal (1 subgoal):\n 1. \\<exists>P'.\n       P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and>\n       P' \\<Turnstile> x \\<Longrightarrow>\n    P \\<Turnstile> Act \\<alpha> x", "then"], ["proof (chain)\npicking this:\n  \\<exists>P'.\n     P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and> P' \\<Turnstile> x", "show \"P \\<Turnstile> Act \\<alpha> x\""], ["proof (prove)\nusing this:\n  \\<exists>P'.\n     P \\<rightarrow> \\<langle>\\<alpha>,P'\\<rangle> \\<and> P' \\<Turnstile> x\n\ngoal (1 subgoal):\n 1. P \\<Turnstile> Act \\<alpha> x", "by (metis valid_Act)"], ["proof (state)\nthis:\n  P \\<Turnstile> Act \\<alpha> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}