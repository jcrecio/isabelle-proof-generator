{"file_name": "/home/qj213/afp-2021-10-22/thys/Modal_Logics_for_NTS/Nominal_Bounded_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modal_Logics_for_NTS", "problem_names": ["lemma Abs_bset_inverse' [simp]:\n  assumes \"|A| <o natLeq +c |UNIV :: 'k set|\"\n  shows \"set_bset (Abs_bset A :: 'a set['k]) = A\"", "lemma Abs_bset_eqvt [simp]:\n  assumes \"|A| <o natLeq +c |UNIV :: 'k set|\"\n  shows \"p \\<bullet> (Abs_bset A :: 'a::pt set['k]) = Abs_bset (p \\<bullet> A)\"", "lemma supp_Abs_bset [simp]:\n  assumes \"|A| <o natLeq +c |UNIV :: 'k set|\"\n  shows \"supp (Abs_bset A :: 'a::pt set['k]) = supp A\"", "lemma map_bset_permute: \"p \\<bullet> B = map_bset (permute p) B\"", "lemma set_bset_eqvt [eqvt]:\n  \"p \\<bullet> set_bset B = set_bset (p \\<bullet> B)\"", "lemma map_bset_eqvt [eqvt]:\n  \"p \\<bullet> map_bset f B = map_bset (p \\<bullet> f) (p \\<bullet> B)\"", "lemma bempty_eqvt [eqvt]: \"p \\<bullet> bempty = bempty\"", "lemma binsert_eqvt [eqvt]: \"p \\<bullet> (binsert x B) = binsert (p \\<bullet> x) (p \\<bullet> B)\"", "lemma bsingleton_eqvt [eqvt]: \"p \\<bullet> bsingleton x = bsingleton (p \\<bullet> x)\""], "translations": [["", "lemma Abs_bset_inverse' [simp]:\n  assumes \"|A| <o natLeq +c |UNIV :: 'k set|\"\n  shows \"set_bset (Abs_bset A :: 'a set['k]) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bset (Abs_bset A) = A", "by (metis Abs_bset_inverse assms mem_Collect_eq)"], ["", "text \\<open>Bounded sets are equipped with a permutation action, provided their elements are.\\<close>"], ["", "instantiation bset :: (pt,type) pt\nbegin"], ["", "lift_definition permute_bset :: \"perm \\<Rightarrow> 'a set['b] \\<Rightarrow> 'a set['b]\" is\n    permute"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>perm set.\n       |set| <o natLeq +c |UNIV| \\<Longrightarrow>\n       |perm \\<bullet> set| <o natLeq +c |UNIV|", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>perm set.\n       |set| <o natLeq +c |UNIV| \\<Longrightarrow>\n       |perm \\<bullet> set| <o natLeq +c |UNIV|", "fix p and A :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>perm set.\n       |set| <o natLeq +c |UNIV| \\<Longrightarrow>\n       |perm \\<bullet> set| <o natLeq +c |UNIV|", "have \"|p \\<bullet> A| \\<le>o |A|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |p \\<bullet> A| \\<le>o |A|", "by (simp add: permute_set_eq_image)"], ["proof (state)\nthis:\n  |p \\<bullet> A| \\<le>o |A|\n\ngoal (1 subgoal):\n 1. \\<And>perm set.\n       |set| <o natLeq +c |UNIV| \\<Longrightarrow>\n       |perm \\<bullet> set| <o natLeq +c |UNIV|", "also"], ["proof (state)\nthis:\n  |p \\<bullet> A| \\<le>o |A|\n\ngoal (1 subgoal):\n 1. \\<And>perm set.\n       |set| <o natLeq +c |UNIV| \\<Longrightarrow>\n       |perm \\<bullet> set| <o natLeq +c |UNIV|", "assume \"|A| <o natLeq +c |UNIV :: 'b set|\""], ["proof (state)\nthis:\n  |A| <o natLeq +c |UNIV|\n\ngoal (1 subgoal):\n 1. \\<And>perm set.\n       |set| <o natLeq +c |UNIV| \\<Longrightarrow>\n       |perm \\<bullet> set| <o natLeq +c |UNIV|", "finally"], ["proof (chain)\npicking this:\n  |p \\<bullet> A| <o natLeq +c |UNIV|", "show \"|p \\<bullet> A| <o natLeq +c |UNIV :: 'b set|\""], ["proof (prove)\nusing this:\n  |p \\<bullet> A| <o natLeq +c |UNIV|\n\ngoal (1 subgoal):\n 1. |p \\<bullet> A| <o natLeq +c |UNIV|", "."], ["proof (state)\nthis:\n  |p \\<bullet> A| <o natLeq +c |UNIV|\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set['b], pt_class)", "by standard (transfer, simp)+"], ["", "end"], ["", "lemma Abs_bset_eqvt [simp]:\n  assumes \"|A| <o natLeq +c |UNIV :: 'k set|\"\n  shows \"p \\<bullet> (Abs_bset A :: 'a::pt set['k]) = Abs_bset (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> Abs_bset A = Abs_bset (p \\<bullet> A)", "by (simp add: permute_bset_def map_bset_def image_def permute_set_def) (metis (no_types, lifting) Abs_bset_inverse' assms)"], ["", "lemma supp_Abs_bset [simp]:\n  assumes \"|A| <o natLeq +c |UNIV :: 'k set|\"\n  shows \"supp (Abs_bset A :: 'a::pt set['k]) = supp A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Abs_bset A) = supp A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. supp (Abs_bset A) = supp A", "from assms"], ["proof (chain)\npicking this:\n  |A| <o natLeq +c |UNIV|", "have \"\\<And>p. p \\<bullet> (Abs_bset A :: 'a::pt set['k]) \\<noteq> Abs_bset A \\<longleftrightarrow> p \\<bullet> A \\<noteq> A\""], ["proof (prove)\nusing this:\n  |A| <o natLeq +c |UNIV|\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (p \\<bullet> Abs_bset A \\<noteq> Abs_bset A) =\n       (p \\<bullet> A \\<noteq> A)", "by simp (metis map_bset.rep_eq permute_set_eq_image set_bset_inverse set_bset_to_set_bset)"], ["proof (state)\nthis:\n  (?p \\<bullet> Abs_bset A \\<noteq> Abs_bset A) =\n  (?p \\<bullet> A \\<noteq> A)\n\ngoal (1 subgoal):\n 1. supp (Abs_bset A) = supp A", "then"], ["proof (chain)\npicking this:\n  (?p \\<bullet> Abs_bset A \\<noteq> Abs_bset A) =\n  (?p \\<bullet> A \\<noteq> A)", "show ?thesis"], ["proof (prove)\nusing this:\n  (?p \\<bullet> Abs_bset A \\<noteq> Abs_bset A) =\n  (?p \\<bullet> A \\<noteq> A)\n\ngoal (1 subgoal):\n 1. supp (Abs_bset A) = supp A", "unfolding supp_def"], ["proof (prove)\nusing this:\n  (?p \\<bullet> Abs_bset A \\<noteq> Abs_bset A) =\n  (?p \\<bullet> A \\<noteq> A)\n\ngoal (1 subgoal):\n 1. {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> Abs_bset A \\<noteq>\n             Abs_bset A}} =\n    {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> A \\<noteq> A}}", "by simp"], ["proof (state)\nthis:\n  supp (Abs_bset A) = supp A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_bset_permute: \"p \\<bullet> B = map_bset (permute p) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> B = map_bset (permute p) B", "by transfer (auto simp add: image_def permute_set_def)"], ["", "lemma set_bset_eqvt [eqvt]:\n  \"p \\<bullet> set_bset B = set_bset (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> set_bset B = set_bset (p \\<bullet> B)", "by transfer simp"], ["", "lemma map_bset_eqvt [eqvt]:\n  \"p \\<bullet> map_bset f B = map_bset (p \\<bullet> f) (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> map_bset f B = map_bset (p \\<bullet> f) (p \\<bullet> B)", "by transfer simp"], ["", "lemma bempty_eqvt [eqvt]: \"p \\<bullet> bempty = bempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> bempty = bempty", "by transfer simp"], ["", "lemma binsert_eqvt [eqvt]: \"p \\<bullet> (binsert x B) = binsert (p \\<bullet> x) (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> binsert x B = binsert (p \\<bullet> x) (p \\<bullet> B)", "by transfer simp"], ["", "lemma bsingleton_eqvt [eqvt]: \"p \\<bullet> bsingleton x = bsingleton (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> bsingleton x = bsingleton (p \\<bullet> x)", "by (simp add: map_bset_permute)"], ["", "end"]]}