{"file_name": "/home/qj213/afp-2021-10-22/thys/Stern_Brocot/Bird_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stern_Brocot", "problem_names": ["lemma bird_unfold:\n  \"bird = Node (1, 1) (pure recip \\<diamondop> (pure succ \\<diamondop> bird)) (pure succ \\<diamondop> (pure recip \\<diamondop> bird))\"", "lemma bird_simps [simp]:\n  \"root bird = (1, 1)\"\n  \"left bird = pure recip \\<diamondop> (pure succ \\<diamondop> bird)\"\n  \"right bird = pure succ \\<diamondop> (pure recip \\<diamondop> bird)\"", "lemma mirror_bird: \"mirror bird = pure recip \\<diamondop> bird\" (is \"?lhs = ?rhs\")", "lemma even_mirror_simps [simp]:\n  \"root (even_mirror t) = root t\"\n  \"left (even_mirror t) = odd_mirror (right t)\"\n  \"right (even_mirror t) = odd_mirror (left t)\"\n  and odd_mirror_simps [simp]:\n  \"root (odd_mirror t) = root t\"\n  \"left (odd_mirror t) = even_mirror (left t)\"\n  \"right (odd_mirror t) = even_mirror (right t)\"", "lemma even_odd_mirror_pure [simp]: fixes even shows\n  \"even_odd_mirror even (pure_tree x) = pure_tree x\"", "lemma even_odd_mirror_ap_tree [simp]: fixes even shows\n  \"even_odd_mirror even (f \\<diamondop> x) = even_odd_mirror even f \\<diamondop> even_odd_mirror even x\"", "lemma [simp]:\n  shows even_mirror_pure: \"even_mirror (pure_tree x) = pure_tree x\"\n  and odd_mirror_pure: \"odd_mirror (pure_tree x) = pure_tree x\"", "lemma [simp]:\n  shows even_mirror_ap_tree: \"even_mirror (f \\<diamondop> x) = even_mirror f \\<diamondop> even_mirror x\"\n  and odd_mirror_ap_tree: \"odd_mirror (f \\<diamondop> x) = odd_mirror f \\<diamondop> odd_mirror x\"", "lemma even_mirror_traverse_tree [simp]: \n  \"root (traverse_tree path (even_mirror t)) = root (traverse_tree (even_mirror_path path) t)\"\n  and odd_mirror_traverse_tree [simp]:\n  \"root (traverse_tree path (odd_mirror t)) = root (traverse_tree (odd_mirror_path path) t)\"", "lemma even_odd_mirror_path_involution [simp]:\n  \"even_mirror_path (even_mirror_path path) = path\"\n  \"odd_mirror_path (odd_mirror_path path) = path\"", "lemma even_odd_mirror_path_injective [simp]:\n  \"even_mirror_path path = even_mirror_path path' \\<longleftrightarrow> path = path'\"\n  \"odd_mirror_path path = odd_mirror_path path' \\<longleftrightarrow> path = path'\"", "lemma odd_mirror_bird_stern_brocot:\n  \"odd_mirror bird = stern_brocot_recurse\"", "theorem bird_rationals:\n  assumes \"m > 0\" \"n > 0\"\n  shows \"root (traverse_tree (odd_mirror_path (mk_path m n)) (pure rat_of \\<diamondop> bird)) = Fract (int m) (int n)\"", "theorem bird_rationals_not_repeated:\n  \"root (traverse_tree path (pure rat_of \\<diamondop> bird)) = root (traverse_tree path' (pure rat_of \\<diamondop> bird))\n  \\<Longrightarrow> path = path'\""], "translations": [["", "lemma bird_unfold:\n  \"bird = Node (1, 1) (pure recip \\<diamondop> (pure succ \\<diamondop> bird)) (pure succ \\<diamondop> (pure recip \\<diamondop> bird))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bird =\n    Node (1, 1) (pure recip \\<diamondop> (pure succ \\<diamondop> bird))\n     (pure succ \\<diamondop> (pure recip \\<diamondop> bird))", "using bird.code"], ["proof (prove)\nusing this:\n  bird =\n  Node (1, 1) (map_tree recip (map_tree succ bird))\n   (map_tree succ (map_tree recip bird))\n\ngoal (1 subgoal):\n 1. bird =\n    Node (1, 1) (pure recip \\<diamondop> (pure succ \\<diamondop> bird))\n     (pure succ \\<diamondop> (pure recip \\<diamondop> bird))", "unfolding map_tree_ap_tree_pure_tree[symmetric]"], ["proof (prove)\nusing this:\n  bird =\n  Node (1, 1) (pure recip \\<diamondop> (pure succ \\<diamondop> bird))\n   (pure succ \\<diamondop> (pure recip \\<diamondop> bird))\n\ngoal (1 subgoal):\n 1. bird =\n    Node (1, 1) (pure recip \\<diamondop> (pure succ \\<diamondop> bird))\n     (pure succ \\<diamondop> (pure recip \\<diamondop> bird))", "."], ["", "lemma bird_simps [simp]:\n  \"root bird = (1, 1)\"\n  \"left bird = pure recip \\<diamondop> (pure succ \\<diamondop> bird)\"\n  \"right bird = pure succ \\<diamondop> (pure recip \\<diamondop> bird)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root bird = (1, 1) &&&\n    left bird = pure recip \\<diamondop> (pure succ \\<diamondop> bird) &&&\n    right bird = pure succ \\<diamondop> (pure recip \\<diamondop> bird)", "by(subst bird_unfold, simp)+"], ["", "lemma mirror_bird: \"mirror bird = pure recip \\<diamondop> bird\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror bird = pure recip \\<diamondop> bird", "proof(rule sym)"], ["proof (state)\ngoal (1 subgoal):\n 1. pure recip \\<diamondop> bird = mirror bird", "let ?F = \"\\<lambda>t. Node (1, 1) (map_tree succ (map_tree recip t)) (map_tree recip (map_tree succ t))\""], ["proof (state)\ngoal (1 subgoal):\n 1. pure recip \\<diamondop> bird = mirror bird", "have *: \"mirror bird = ?F (mirror bird)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror bird =\n    Node (1, 1) (map_tree succ (map_tree recip (mirror bird)))\n     (map_tree recip (map_tree succ (mirror bird)))", "by(rule tree.expand; simp add: mirror_ap_tree mirror_pure map_tree_ap_tree_pure_tree[symmetric])"], ["proof (state)\nthis:\n  mirror bird =\n  Node (1, 1) (map_tree succ (map_tree recip (mirror bird)))\n   (map_tree recip (map_tree succ (mirror bird)))\n\ngoal (1 subgoal):\n 1. pure recip \\<diamondop> bird = mirror bird", "show \"t = mirror bird\" when \"t = ?F t\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = mirror bird", "using that"], ["proof (prove)\nusing this:\n  t =\n  Node (1, 1) (map_tree succ (map_tree recip t))\n   (map_tree recip (map_tree succ t))\n\ngoal (1 subgoal):\n 1. t = mirror bird", "by corec_unique (fact *)"], ["proof (state)\nthis:\n  ?t =\n  Node (1, 1) (map_tree succ (map_tree recip ?t))\n   (map_tree recip (map_tree succ ?t)) \\<Longrightarrow>\n  ?t = mirror bird\n\ngoal (1 subgoal):\n 1. pure recip \\<diamondop> bird =\n    Node (1, 1)\n     (map_tree succ (map_tree recip (pure recip \\<diamondop> bird)))\n     (map_tree recip (map_tree succ (pure recip \\<diamondop> bird)))", "show \"pure recip \\<diamondop> bird = ?F (pure recip \\<diamondop> bird)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure recip \\<diamondop> bird =\n    Node (1, 1)\n     (map_tree succ (map_tree recip (pure recip \\<diamondop> bird)))\n     (map_tree recip (map_tree succ (pure recip \\<diamondop> bird)))", "by(rule tree.expand; simp add: map_tree_ap_tree_pure_tree; applicative_lifting; simp add: split_beta)"], ["proof (state)\nthis:\n  pure recip \\<diamondop> bird =\n  Node (1, 1)\n   (map_tree succ (map_tree recip (pure recip \\<diamondop> bird)))\n   (map_tree recip (map_tree succ (pure recip \\<diamondop> bird)))\n\ngoal:\nNo subgoals!", "qed"], ["", "primcorec even_odd_mirror :: \"bool \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\"\nwhere\n  \"\\<And>even. root (even_odd_mirror even t) = root t\"\n| \"\\<And>even. left (even_odd_mirror even t) = even_odd_mirror (\\<not> even) (if even then right t else left t)\"\n| \"\\<And>even. right (even_odd_mirror even t) = even_odd_mirror (\\<not> even) (if even then left t else right t)\""], ["", "definition even_mirror :: \"'a tree \\<Rightarrow> 'a tree\"\nwhere \"even_mirror = even_odd_mirror True\""], ["", "definition odd_mirror :: \"'a tree \\<Rightarrow> 'a tree\"\nwhere \"odd_mirror = even_odd_mirror False\""], ["", "lemma even_mirror_simps [simp]:\n  \"root (even_mirror t) = root t\"\n  \"left (even_mirror t) = odd_mirror (right t)\"\n  \"right (even_mirror t) = odd_mirror (left t)\"\n  and odd_mirror_simps [simp]:\n  \"root (odd_mirror t) = root t\"\n  \"left (odd_mirror t) = even_mirror (left t)\"\n  \"right (odd_mirror t) = even_mirror (right t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (root (even_mirror t) = root t &&&\n     left (even_mirror t) = odd_mirror (right t) &&&\n     right (even_mirror t) = odd_mirror (left t)) &&&\n    root (odd_mirror t) = root t &&&\n    left (odd_mirror t) = even_mirror (left t) &&&\n    right (odd_mirror t) = even_mirror (right t)", "by(simp_all add: even_mirror_def odd_mirror_def)"], ["", "lemma even_odd_mirror_pure [simp]: fixes even shows\n  \"even_odd_mirror even (pure_tree x) = pure_tree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even_odd_mirror even (pure x) = pure x", "by(coinduction arbitrary: even) auto"], ["", "lemma even_odd_mirror_ap_tree [simp]: fixes even shows\n  \"even_odd_mirror even (f \\<diamondop> x) = even_odd_mirror even f \\<diamondop> even_odd_mirror even x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even_odd_mirror even (f \\<diamondop> x) =\n    even_odd_mirror even f \\<diamondop> even_odd_mirror even x", "by(coinduction arbitrary: even f x) auto"], ["", "lemma [simp]:\n  shows even_mirror_pure: \"even_mirror (pure_tree x) = pure_tree x\"\n  and odd_mirror_pure: \"odd_mirror (pure_tree x) = pure_tree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even_mirror (pure x) = pure x &&& odd_mirror (pure x) = pure x", "by(simp_all add: even_mirror_def odd_mirror_def)"], ["", "lemma [simp]:\n  shows even_mirror_ap_tree: \"even_mirror (f \\<diamondop> x) = even_mirror f \\<diamondop> even_mirror x\"\n  and odd_mirror_ap_tree: \"odd_mirror (f \\<diamondop> x) = odd_mirror f \\<diamondop> odd_mirror x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even_mirror (f \\<diamondop> x) =\n    even_mirror f \\<diamondop> even_mirror x &&&\n    odd_mirror (f \\<diamondop> x) = odd_mirror f \\<diamondop> odd_mirror x", "by(simp_all add: even_mirror_def odd_mirror_def)"], ["", "fun even_mirror_path :: \"path \\<Rightarrow> path\"\n  and odd_mirror_path :: \"path \\<Rightarrow> path\"\nwhere\n  \"even_mirror_path [] = []\"\n| \"even_mirror_path (d # ds) = (case d of L \\<Rightarrow> R | R \\<Rightarrow> L) # odd_mirror_path ds\"\n| \"odd_mirror_path [] = []\"\n| \"odd_mirror_path (d # ds) = d # even_mirror_path ds\""], ["", "lemma even_mirror_traverse_tree [simp]: \n  \"root (traverse_tree path (even_mirror t)) = root (traverse_tree (even_mirror_path path) t)\"\n  and odd_mirror_traverse_tree [simp]:\n  \"root (traverse_tree path (odd_mirror t)) = root (traverse_tree (odd_mirror_path path) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (traverse_tree path (even_mirror t)) =\n    root (traverse_tree (even_mirror_path path) t) &&&\n    root (traverse_tree path (odd_mirror t)) =\n    root (traverse_tree (odd_mirror_path path) t)", "by (induct path arbitrary: t) (simp_all split: dir.splits)"], ["", "lemma even_odd_mirror_path_involution [simp]:\n  \"even_mirror_path (even_mirror_path path) = path\"\n  \"odd_mirror_path (odd_mirror_path path) = path\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even_mirror_path (even_mirror_path path) = path &&&\n    odd_mirror_path (odd_mirror_path path) = path", "by (induct path) (simp_all split: dir.splits)"], ["", "lemma even_odd_mirror_path_injective [simp]:\n  \"even_mirror_path path = even_mirror_path path' \\<longleftrightarrow> path = path'\"\n  \"odd_mirror_path path = odd_mirror_path path' \\<longleftrightarrow> path = path'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even_mirror_path path = even_mirror_path path') = (path = path') &&&\n    (odd_mirror_path path = odd_mirror_path path') = (path = path')", "by (induct path arbitrary: path') (case_tac path', simp_all split: dir.splits)+"], ["", "lemma odd_mirror_bird_stern_brocot:\n  \"odd_mirror bird = stern_brocot_recurse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_mirror bird = stern_brocot_recurse", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd_mirror bird = stern_brocot_recurse", "let ?rsrs = \"map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ)\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd_mirror bird = stern_brocot_recurse", "let ?rssr = \"map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip)\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd_mirror bird = stern_brocot_recurse", "let ?srrs = \"map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ)\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd_mirror bird = stern_brocot_recurse", "let ?srsr = \"map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip)\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd_mirror bird = stern_brocot_recurse", "let ?R = \"\\<lambda>t. Node (1, 1) (Node (1, 2) (?rssr t) (?rsrs t)) (Node (2, 1) (?srsr t) (?srrs t))\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd_mirror bird = stern_brocot_recurse", "have *: \"stern_brocot_recurse = ?R stern_brocot_recurse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot_recurse =\n    Node (1, 1)\n     (Node (1, 2)\n       (map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip)\n         stern_brocot_recurse)\n       (map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ)\n         stern_brocot_recurse))\n     (Node (2, 1)\n       (map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip)\n         stern_brocot_recurse)\n       (map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ)\n         stern_brocot_recurse))", "by(rule tree.expand; simp; intro conjI; rule tree.expand; simp; intro conjI) \\<comment> \\<open>Expand the tree twice\\<close>\n      (applicative_lifting, simp add: split_beta)+"], ["proof (state)\nthis:\n  stern_brocot_recurse =\n  Node (1, 1)\n   (Node (1, 2)\n     (map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip)\n       stern_brocot_recurse)\n     (map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ)\n       stern_brocot_recurse))\n   (Node (2, 1)\n     (map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip)\n       stern_brocot_recurse)\n     (map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ)\n       stern_brocot_recurse))\n\ngoal (1 subgoal):\n 1. odd_mirror bird = stern_brocot_recurse", "show \"f = stern_brocot_recurse\" when \"f = ?R f\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = stern_brocot_recurse", "using that *"], ["proof (prove)\nusing this:\n  f =\n  Node (1, 1)\n   (Node (1, 2) (map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip) f)\n     (map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ) f))\n   (Node (2, 1) (map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip) f)\n     (map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ) f))\n  stern_brocot_recurse =\n  Node (1, 1)\n   (Node (1, 2)\n     (map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip)\n       stern_brocot_recurse)\n     (map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ)\n       stern_brocot_recurse))\n   (Node (2, 1)\n     (map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip)\n       stern_brocot_recurse)\n     (map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ)\n       stern_brocot_recurse))\n\ngoal (1 subgoal):\n 1. f = stern_brocot_recurse", "by corec_unique"], ["proof (state)\nthis:\n  ?f =\n  Node (1, 1)\n   (Node (1, 2)\n     (map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip) ?f)\n     (map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ) ?f))\n   (Node (2, 1)\n     (map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip) ?f)\n     (map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ)\n       ?f)) \\<Longrightarrow>\n  ?f = stern_brocot_recurse\n\ngoal (1 subgoal):\n 1. odd_mirror bird =\n    Node (1, 1)\n     (Node (1, 2)\n       (map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip)\n         (odd_mirror bird))\n       (map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ)\n         (odd_mirror bird)))\n     (Node (2, 1)\n       (map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip)\n         (odd_mirror bird))\n       (map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ)\n         (odd_mirror bird)))", "show \"odd_mirror bird = ?R (odd_mirror bird)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_mirror bird =\n    Node (1, 1)\n     (Node (1, 2)\n       (map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip)\n         (odd_mirror bird))\n       (map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ)\n         (odd_mirror bird)))\n     (Node (2, 1)\n       (map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip)\n         (odd_mirror bird))\n       (map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ)\n         (odd_mirror bird)))", "by(rule tree.expand; simp; intro conjI; rule tree.expand; simp; intro conjI) \\<comment> \\<open>Expand the tree twice\\<close>\n      (applicative_lifting; simp)+"], ["proof (state)\nthis:\n  odd_mirror bird =\n  Node (1, 1)\n   (Node (1, 2)\n     (map_tree (recip \\<circ> succ \\<circ> succ \\<circ> recip)\n       (odd_mirror bird))\n     (map_tree (recip \\<circ> succ \\<circ> recip \\<circ> succ)\n       (odd_mirror bird)))\n   (Node (2, 1)\n     (map_tree (succ \\<circ> recip \\<circ> succ \\<circ> recip)\n       (odd_mirror bird))\n     (map_tree (succ \\<circ> recip \\<circ> recip \\<circ> succ)\n       (odd_mirror bird)))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem bird_rationals:\n  assumes \"m > 0\" \"n > 0\"\n  shows \"root (traverse_tree (odd_mirror_path (mk_path m n)) (pure rat_of \\<diamondop> bird)) = Fract (int m) (int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root\n     (traverse_tree (odd_mirror_path (mk_path m n))\n       (pure rat_of \\<diamondop> bird)) =\n    Fract (int m) (int n)", "using stern_brocot_rationals[OF assms]"], ["proof (prove)\nusing this:\n  root\n   (traverse_tree (mk_path m n)\n     (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n  Fract (int m) (int n)\n\ngoal (1 subgoal):\n 1. root\n     (traverse_tree (odd_mirror_path (mk_path m n))\n       (pure rat_of \\<diamondop> bird)) =\n    Fract (int m) (int n)", "by (simp add: odd_mirror_bird_stern_brocot[symmetric])"], ["", "theorem bird_rationals_not_repeated:\n  \"root (traverse_tree path (pure rat_of \\<diamondop> bird)) = root (traverse_tree path' (pure rat_of \\<diamondop> bird))\n  \\<Longrightarrow> path = path'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (traverse_tree path (pure rat_of \\<diamondop> bird)) =\n    root\n     (traverse_tree path' (pure rat_of \\<diamondop> bird)) \\<Longrightarrow>\n    path = path'", "using stern_brocot_rationals_not_repeated[where path=\"odd_mirror_path path\" and path'=\"odd_mirror_path path'\"]"], ["proof (prove)\nusing this:\n  root\n   (traverse_tree (odd_mirror_path path)\n     (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n  root\n   (traverse_tree (odd_mirror_path path')\n     (pure rat_of \\<diamondop> stern_brocot_recurse)) \\<Longrightarrow>\n  odd_mirror_path path = odd_mirror_path path'\n\ngoal (1 subgoal):\n 1. root (traverse_tree path (pure rat_of \\<diamondop> bird)) =\n    root\n     (traverse_tree path' (pure rat_of \\<diamondop> bird)) \\<Longrightarrow>\n    path = path'", "by (simp add: odd_mirror_bird_stern_brocot[symmetric])"], ["", "end"]]}