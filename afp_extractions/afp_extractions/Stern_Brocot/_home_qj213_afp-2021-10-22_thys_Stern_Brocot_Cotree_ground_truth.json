{"file_name": "/home/qj213/afp-2021-10-22/thys/Stern_Brocot/Cotree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stern_Brocot", "problem_names": ["lemma rel_treeD:\n  assumes \"rel_tree A x y\"\n  shows rel_tree_rootD: \"A (root x) (root y)\"\n  and rel_tree_leftD: \"rel_tree A (left x) (left y)\"\n  and rel_tree_rightD: \"rel_tree A (right x) (right y)\"", "lemmas [simp] = tree.map_sel tree.map_comp", "lemma set_tree_induct[consumes 1, case_names root left right]:\n  assumes x: \"x \\<in> set_tree t\"\n  and root: \"\\<And>t. P (root t) t\"\n  and left: \"\\<And>x t. \\<lbrakk> x \\<in> set_tree (left t); P x (left t) \\<rbrakk> \\<Longrightarrow> P x t\"\n  and right: \"\\<And>x t. \\<lbrakk> x \\<in> set_tree (right t); P x (right t) \\<rbrakk> \\<Longrightarrow> P x t\"\n  shows \"P x t\"", "lemma corec_tree_cong:\n  assumes \"\\<And>x. stopL x \\<Longrightarrow> STOPL x = STOPL' x\"\n  and \"\\<And>x. ~ stopL x \\<Longrightarrow> LEFT x = LEFT' x\"\n  and \"\\<And>x. stopR x \\<Longrightarrow> STOPR x = STOPR' x\"\n  and \"\\<And>x. \\<not> stopR x \\<Longrightarrow> RIGHT x = RIGHT' x\"\n  shows \"corec_tree ROOT stopL STOPL LEFT stopR STOPR RIGHT = \n         corec_tree ROOT stopL STOPL' LEFT' stopR STOPR' RIGHT'\"\n  (is \"?lhs = ?rhs\")", "lemma unfold_tree_simps [simp]:\n  \"root (unfold_tree a) = g1 a\"\n  \"left (unfold_tree a) = unfold_tree (g22 a)\"\n  \"right (unfold_tree a) = unfold_tree (g32 a)\"", "lemma unfold_tree_unique:\n  assumes \"\\<And>s. root (f s) = ROOT s\"\n  and \"\\<And>s. left (f s) = f (LEFT s)\"\n  and \"\\<And>s. right (f s) = f (RIGHT s)\"\n  shows \"f s = unfold_tree ROOT LEFT RIGHT s\"", "lemmas pure_tree_unfold = pure_tree.code", "lemma pure_tree_simps [simp]: \n  \"root (pure_tree x) = x\"\n  \"left (pure_tree x) = pure_tree x\"\n  \"right (pure_tree x) = pure_tree x\"", "lemma pure_tree_parametric [transfer_rule]: \"(rel_fun A (rel_tree A)) pure pure\"", "lemma map_pure_tree [simp]: \"map_tree f (pure x) = pure (f x)\"", "lemmas pure_tree_unique = pure_tree.unique", "lemma ap_tree_pure_Node [simp]:\n  \"pure f \\<diamondop> Node x l r = Node (f x) (pure f \\<diamondop> l) (pure f \\<diamondop> r)\"", "lemma ap_tree_Node_Node [simp]:\n  \"Node f fl fr \\<diamondop> Node x l r = Node (f x) (fl \\<diamondop> l) (fr \\<diamondop> r)\"", "lemma map_tree_ap_tree_pure_tree:\n  \"pure f \\<diamondop> u = map_tree f u\"", "lemma ap_tree_identity: \"pure id \\<diamondop> t = t\"", "lemma ap_tree_composition:\n  \"pure (\\<circ>) \\<diamondop> r1 \\<diamondop> r2 \\<diamondop> r3 = r1 \\<diamondop> (r2 \\<diamondop> r3)\"", "lemma ap_tree_homomorphism:\n  \"pure f \\<diamondop> pure x = pure (f x)\"", "lemma ap_tree_interchange:\n  \"t \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> t\"", "lemma ap_tree_K_tree: \"pure (\\<lambda>x y. x) \\<diamondop> u \\<diamondop> v = u\"", "lemma ap_tree_C_tree: \"pure (\\<lambda>f x y. f y x) \\<diamondop> u \\<diamondop> v \\<diamondop> w = u \\<diamondop> w \\<diamondop> v\"", "lemma ap_tree_W_tree: \"pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x = f \\<diamondop> x \\<diamondop> x\"", "lemma ap_tree_strong_extensional:\n  \"(\\<And>x. f \\<diamondop> pure x = g \\<diamondop> pure x) \\<Longrightarrow> f = g\"", "lemma ap_tree_extensional:\n  \"(\\<And>x. f \\<diamondop> x = g \\<diamondop> x) \\<Longrightarrow> f = g\"", "lemma map_unfold_tree [simp]: fixes l r x\n defines \"unf \\<equiv> unfold_tree (\\<lambda>f. f x) (\\<lambda>f. f \\<circ> l) (\\<lambda>f. f \\<circ> r)\"\n shows \"map_tree G (unf F) = unf (G \\<circ> F)\"", "lemma tree_recurse_simps [simp]:\n  \"root (tree_recurse l r x) = x\"\n  \"left (tree_recurse l r x) = map_tree l (tree_recurse l r x)\"\n  \"right (tree_recurse l r x) = map_tree r (tree_recurse l r x)\"", "lemma tree_recurse_unfold:\n  \"tree_recurse l r x = Node x (map_tree l (tree_recurse l r x)) (map_tree r (tree_recurse l r x))\"", "lemma tree_recurse_fusion:\n  assumes \"h \\<circ> l = l' \\<circ> h\" and \"h \\<circ> r = r' \\<circ> h\"\n  shows \"map_tree h (tree_recurse l r x) = tree_recurse l' r' (h x)\"", "lemma unfold_tree_tree_iterate:\n  \"unfold_tree out l r = map_tree out \\<circ> tree_iterate l r\"", "lemma tree_iterate_fusion:\n  assumes \"h \\<circ> l = l' \\<circ> h\"\n  assumes \"h \\<circ> r = r' \\<circ> h\"\n  shows \"map_tree h (tree_iterate l r x) = tree_iterate l' r' (h x)\"", "lemma traverse_tree_simps[simp]:\n  \"traverse_tree [] = id\"\n  \"traverse_tree (d # path) = traverse_tree path \\<circ> (case d of L \\<Rightarrow> left | R \\<Rightarrow> right)\"", "lemma traverse_tree_map_tree [simp]:\n  \"traverse_tree path (map_tree f t) = map_tree f (traverse_tree path t)\"", "lemma traverse_tree_append [simp]:\n  \"traverse_tree (path @ ext) t = traverse_tree ext (traverse_tree path t)\"", "lemma traverse_tree_pure_tree [simp]:\n  \"traverse_tree path (pure x) = pure x\"", "lemma traverse_tree_ap [simp]:\n  \"traverse_tree path (f \\<diamondop> x) = traverse_tree path f \\<diamondop> traverse_tree path x\"", "lemma traverse_tree_tree_iterate:\n  \"traverse_tree path (tree_iterate l r s) =\n   tree_iterate l r (traverse_path l r path s)\"", "lemma tree_recurse_iterate:\n  assumes monoid:\n    \"\\<And>x y z. f (f x y) z = f x (f y z)\"\n    \"\\<And>x. f x \\<epsilon> = x\"\n    \"\\<And>x. f \\<epsilon> x = x\"\n  shows \"tree_recurse (f l) (f r) \\<epsilon> = tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>\"", "lemma mirror_unfold: \"mirror (Node x l r) = Node x (mirror r) (mirror l)\"", "lemma mirror_pure: \"mirror (pure x) = pure x\"", "lemma mirror_ap_tree: \"mirror (f \\<diamondop> x) = mirror f \\<diamondop> mirror x\""], "translations": [["", "lemma rel_treeD:\n  assumes \"rel_tree A x y\"\n  shows rel_tree_rootD: \"A (root x) (root y)\"\n  and rel_tree_leftD: \"rel_tree A (left x) (left y)\"\n  and rel_tree_rightD: \"rel_tree A (right x) (right y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (root x) (root y) &&&\n    rel_tree A (left x) (left y) &&& rel_tree A (right x) (right y)", "using assms"], ["proof (prove)\nusing this:\n  rel_tree A x y\n\ngoal (1 subgoal):\n 1. A (root x) (root y) &&&\n    rel_tree A (left x) (left y) &&& rel_tree A (right x) (right y)", "by(cases x y rule: tree.exhaust[case_product tree.exhaust], simp_all)+"], ["", "lemmas [simp] = tree.map_sel tree.map_comp"], ["", "lemma set_tree_induct[consumes 1, case_names root left right]:\n  assumes x: \"x \\<in> set_tree t\"\n  and root: \"\\<And>t. P (root t) t\"\n  and left: \"\\<And>x t. \\<lbrakk> x \\<in> set_tree (left t); P x (left t) \\<rbrakk> \\<Longrightarrow> P x t\"\n  and right: \"\\<And>x t. \\<lbrakk> x \\<in> set_tree (right t); P x (right t) \\<rbrakk> \\<Longrightarrow> P x t\"\n  shows \"P x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x t", "using x"], ["proof (prove)\nusing this:\n  x \\<in> set_tree t\n\ngoal (1 subgoal):\n 1. P x t", "proof(rule tree.set_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>z1 z2 z3. P z1 (Node z1 z2 z3)\n 2. \\<And>z1 z2 z3 xa.\n       \\<lbrakk>xa \\<in> set_tree z2; P xa z2\\<rbrakk>\n       \\<Longrightarrow> P xa (Node z1 z2 z3)\n 3. \\<And>z1 z2 z3 xb.\n       \\<lbrakk>xb \\<in> set_tree z3; P xb z3\\<rbrakk>\n       \\<Longrightarrow> P xb (Node z1 z2 z3)", "fix l x r"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>z1 z2 z3. P z1 (Node z1 z2 z3)\n 2. \\<And>z1 z2 z3 xa.\n       \\<lbrakk>xa \\<in> set_tree z2; P xa z2\\<rbrakk>\n       \\<Longrightarrow> P xa (Node z1 z2 z3)\n 3. \\<And>z1 z2 z3 xb.\n       \\<lbrakk>xb \\<in> set_tree z3; P xb z3\\<rbrakk>\n       \\<Longrightarrow> P xb (Node z1 z2 z3)", "from root[of \"Node x l r\"]"], ["proof (chain)\npicking this:\n  P (root (Node x l r)) (Node x l r)", "show \"P x (Node x l r)\""], ["proof (prove)\nusing this:\n  P (root (Node x l r)) (Node x l r)\n\ngoal (1 subgoal):\n 1. P x (Node x l r)", "by simp"], ["proof (state)\nthis:\n  P x (Node x l r)\n\ngoal (2 subgoals):\n 1. \\<And>z1 z2 z3 xa.\n       \\<lbrakk>xa \\<in> set_tree z2; P xa z2\\<rbrakk>\n       \\<Longrightarrow> P xa (Node z1 z2 z3)\n 2. \\<And>z1 z2 z3 xb.\n       \\<lbrakk>xb \\<in> set_tree z3; P xb z3\\<rbrakk>\n       \\<Longrightarrow> P xb (Node z1 z2 z3)", "qed(auto intro: left right)"], ["", "lemma corec_tree_cong:\n  assumes \"\\<And>x. stopL x \\<Longrightarrow> STOPL x = STOPL' x\"\n  and \"\\<And>x. ~ stopL x \\<Longrightarrow> LEFT x = LEFT' x\"\n  and \"\\<And>x. stopR x \\<Longrightarrow> STOPR x = STOPR' x\"\n  and \"\\<And>x. \\<not> stopR x \\<Longrightarrow> RIGHT x = RIGHT' x\"\n  shows \"corec_tree ROOT stopL STOPL LEFT stopR STOPR RIGHT = \n         corec_tree ROOT stopL STOPL' LEFT' stopR STOPR' RIGHT'\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. corec_tree ROOT stopL STOPL LEFT stopR STOPR RIGHT =\n    corec_tree ROOT stopL STOPL' LEFT' stopR STOPR' RIGHT'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       corec_tree ROOT stopL STOPL LEFT stopR STOPR RIGHT x =\n       corec_tree ROOT stopL STOPL' LEFT' stopR STOPR' RIGHT' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       corec_tree ROOT stopL STOPL LEFT stopR STOPR RIGHT x =\n       corec_tree ROOT stopL STOPL' LEFT' stopR STOPR' RIGHT' x", "show \"?lhs x = ?rhs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corec_tree ROOT stopL STOPL LEFT stopR STOPR RIGHT x =\n    corec_tree ROOT stopL STOPL' LEFT' stopR STOPR' RIGHT' x", "by(coinduction arbitrary: x rule: tree.coinduct_strong)(auto simp add: assms)"], ["proof (state)\nthis:\n  corec_tree ROOT stopL STOPL LEFT stopR STOPR RIGHT x =\n  corec_tree ROOT stopL STOPL' LEFT' stopR STOPR' RIGHT' x\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  fixes g1 :: \"'a \\<Rightarrow> 'b\"\n  and g22 :: \"'a \\<Rightarrow> 'a\"\n  and g32 :: \"'a \\<Rightarrow> 'a\"\nbegin"], ["", "corec unfold_tree :: \"'a \\<Rightarrow> 'b tree\"\nwhere \"unfold_tree a = Node (g1 a) (unfold_tree (g22 a)) (unfold_tree (g32 a))\""], ["", "lemma unfold_tree_simps [simp]:\n  \"root (unfold_tree a) = g1 a\"\n  \"left (unfold_tree a) = unfold_tree (g22 a)\"\n  \"right (unfold_tree a) = unfold_tree (g32 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (local.unfold_tree a) = g1 a &&&\n    left (local.unfold_tree a) = local.unfold_tree (g22 a) &&&\n    right (local.unfold_tree a) = local.unfold_tree (g32 a)", "by(subst unfold_tree.code; simp; fail)+"], ["", "end"], ["", "lemma unfold_tree_unique:\n  assumes \"\\<And>s. root (f s) = ROOT s\"\n  and \"\\<And>s. left (f s) = f (LEFT s)\"\n  and \"\\<And>s. right (f s) = f (RIGHT s)\"\n  shows \"f s = unfold_tree ROOT LEFT RIGHT s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f s = unfold_tree ROOT LEFT RIGHT s", "by(rule unfold_tree.unique[THEN fun_cong])(auto simp add: fun_eq_iff assms intro: tree.expand)"], ["", "subsection \\<open>Applicative functor for @{typ \"'a tree\"}\\<close>"], ["", "context fixes x :: \"'a\" begin"], ["", "corec pure_tree :: \"'a tree\"\nwhere \"pure_tree = Node x pure_tree pure_tree\""], ["", "end"], ["", "lemmas pure_tree_unfold = pure_tree.code"], ["", "lemma pure_tree_simps [simp]: \n  \"root (pure_tree x) = x\"\n  \"left (pure_tree x) = pure_tree x\"\n  \"right (pure_tree x) = pure_tree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (pure_tree x) = x &&&\n    left (pure_tree x) = pure_tree x &&& right (pure_tree x) = pure_tree x", "by(subst pure_tree_unfold; simp; fail)+"], ["", "adhoc_overloading pure pure_tree"], ["", "lemma pure_tree_parametric [transfer_rule]: \"(rel_fun A (rel_tree A)) pure pure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun A (rel_tree A) pure pure", "by(rule rel_funI)(coinduction, auto)"], ["", "lemma map_pure_tree [simp]: \"map_tree f (pure x) = pure (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree f (pure x) = pure (f x)", "by(coinduction arbitrary: x) auto"], ["", "lemmas pure_tree_unique = pure_tree.unique"], ["", "primcorec (transfer) ap_tree :: \"('a \\<Rightarrow> 'b) tree \\<Rightarrow> 'a tree \\<Rightarrow> 'b tree\"\nwhere\n  \"root (ap_tree f x) = root f (root x)\"\n| \"left (ap_tree f x) = ap_tree (left f) (left x)\"\n| \"right (ap_tree f x) = ap_tree (right f) (right x)\""], ["", "adhoc_overloading Applicative.ap ap_tree"], ["", "unbundle applicative_syntax"], ["", "lemma ap_tree_pure_Node [simp]:\n  \"pure f \\<diamondop> Node x l r = Node (f x) (pure f \\<diamondop> l) (pure f \\<diamondop> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure f \\<diamondop> Node x l r =\n    Node (f x) (pure f \\<diamondop> l) (pure f \\<diamondop> r)", "by(rule tree.expand) auto"], ["", "lemma ap_tree_Node_Node [simp]:\n  \"Node f fl fr \\<diamondop> Node x l r = Node (f x) (fl \\<diamondop> l) (fr \\<diamondop> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Node f fl fr \\<diamondop> Node x l r =\n    Node (f x) (fl \\<diamondop> l) (fr \\<diamondop> r)", "by(rule tree.expand) auto"], ["", "text \\<open>Applicative functor laws\\<close>"], ["", "lemma map_tree_ap_tree_pure_tree:\n  \"pure f \\<diamondop> u = map_tree f u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure f \\<diamondop> u = map_tree f u", "by(coinduction arbitrary: u) auto"], ["", "lemma ap_tree_identity: \"pure id \\<diamondop> t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure id \\<diamondop> t = t", "by(simp add: map_tree_ap_tree_pure_tree tree.map_id)"], ["", "lemma ap_tree_composition:\n  \"pure (\\<circ>) \\<diamondop> r1 \\<diamondop> r2 \\<diamondop> r3 = r1 \\<diamondop> (r2 \\<diamondop> r3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<circ>) \\<diamondop> r1 \\<diamondop> r2 \\<diamondop> r3 =\n    r1 \\<diamondop> (r2 \\<diamondop> r3)", "by(coinduction arbitrary: r1 r2 r3) auto"], ["", "lemma ap_tree_homomorphism:\n  \"pure f \\<diamondop> pure x = pure (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure f \\<diamondop> pure x = pure (f x)", "by(simp add: map_tree_ap_tree_pure_tree)"], ["", "lemma ap_tree_interchange:\n  \"t \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> t", "by(coinduction arbitrary: t) auto"], ["", "lemma ap_tree_K_tree: \"pure (\\<lambda>x y. x) \\<diamondop> u \\<diamondop> v = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>x y. x) \\<diamondop> u \\<diamondop> v = u", "by(coinduction arbitrary: u v)(auto)"], ["", "lemma ap_tree_C_tree: \"pure (\\<lambda>f x y. f y x) \\<diamondop> u \\<diamondop> v \\<diamondop> w = u \\<diamondop> w \\<diamondop> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>f x y. f y x) \\<diamondop> u \\<diamondop> v \\<diamondop>\n    w =\n    u \\<diamondop> w \\<diamondop> v", "by(coinduction arbitrary: u v w)(auto)"], ["", "lemma ap_tree_W_tree: \"pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x = f \\<diamondop> x \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n    f \\<diamondop> x \\<diamondop> x", "by(coinduction arbitrary: f x)(auto)"], ["", "applicative tree (K, W) for\n  pure: pure_tree\n  ap: ap_tree\n  rel: rel_tree\n  set: set_tree"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x y. pure (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>f x. f \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> f\n 6. \\<And>R. rel_fun R (rel_tree R) pure pure\n 7. \\<And>R f g x.\n       rel_tree (rel_fun (eq_on (set_tree x)) R) f g \\<Longrightarrow>\n       rel_tree R (f \\<diamondop> x) (g \\<diamondop> x)", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x y. pure (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>f x. f \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> f\n 6. \\<And>R. rel_fun R (rel_tree R) pure pure\n 7. \\<And>R f g x.\n       rel_tree (rel_fun (eq_on (set_tree x)) R) f g \\<Longrightarrow>\n       rel_tree R (f \\<diamondop> x) (g \\<diamondop> x)", "fix R :: \"'b \\<Rightarrow> 'c \\<Rightarrow> bool\" and f :: \"('a \\<Rightarrow> 'b) tree\" and g x"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x y. pure (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>f x. f \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> f\n 6. \\<And>R. rel_fun R (rel_tree R) pure pure\n 7. \\<And>R f g x.\n       rel_tree (rel_fun (eq_on (set_tree x)) R) f g \\<Longrightarrow>\n       rel_tree R (f \\<diamondop> x) (g \\<diamondop> x)", "assume [transfer_rule]: \"rel_tree (rel_fun (eq_on (set_tree x)) R) f g\""], ["proof (state)\nthis:\n  rel_tree (rel_fun (eq_on (set_tree x)) R) f g\n\ngoal (7 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x y. pure (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>f x. f \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> f\n 6. \\<And>R. rel_fun R (rel_tree R) pure pure\n 7. \\<And>R f g x.\n       rel_tree (rel_fun (eq_on (set_tree x)) R) f g \\<Longrightarrow>\n       rel_tree R (f \\<diamondop> x) (g \\<diamondop> x)", "have [transfer_rule]: \"rel_tree (eq_on (set_tree x)) x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_tree (eq_on (set_tree x)) x x", "by(rule tree.rel_refl_strong) simp"], ["proof (state)\nthis:\n  rel_tree (eq_on (set_tree x)) x x\n\ngoal (7 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x y. pure (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>f x. f \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> f\n 6. \\<And>R. rel_fun R (rel_tree R) pure pure\n 7. \\<And>R f g x.\n       rel_tree (rel_fun (eq_on (set_tree x)) R) f g \\<Longrightarrow>\n       rel_tree R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"rel_tree R (f \\<diamondop> x) (g \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_tree R (f \\<diamondop> x) (g \\<diamondop> x)", "by transfer_prover"], ["proof (state)\nthis:\n  rel_tree R (f \\<diamondop> x) (g \\<diamondop> x)\n\ngoal (6 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x y. pure (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>f x. f \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> f\n 6. \\<And>R. rel_fun R (rel_tree R) pure pure", "qed(rule ap_tree_homomorphism ap_tree_composition[unfolded o_def[abs_def]] ap_tree_K_tree ap_tree_W_tree ap_tree_interchange pure_tree_parametric)+"], ["", "declare map_tree_ap_tree_pure_tree[symmetric, applicative_unfold]"], ["", "lemma ap_tree_strong_extensional:\n  \"(\\<And>x. f \\<diamondop> pure x = g \\<diamondop> pure x) \\<Longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        f \\<diamondop> pure x = g \\<diamondop> pure x) \\<Longrightarrow>\n    f = g", "proof(coinduction arbitrary: f g)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "case [rule_format]: (Eq_tree f g)"], ["proof (state)\nthis:\n  f \\<diamondop> pure ?x = g \\<diamondop> pure ?x\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "have \"root f = root g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root f = root g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. root f x = root g x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. root f x = root g x", "show \"root f x = root g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root f x = root g x", "using Eq_tree[of x]"], ["proof (prove)\nusing this:\n  f \\<diamondop> pure x = g \\<diamondop> pure x\n\ngoal (1 subgoal):\n 1. root f x = root g x", "by(subst (asm) (1 2) ap_tree.ctr) simp"], ["proof (state)\nthis:\n  root f x = root g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root f = root g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "moreover"], ["proof (state)\nthis:\n  root f = root g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "{"], ["proof (state)\nthis:\n  root f = root g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "have \"left f \\<diamondop> pure x = left g \\<diamondop> pure x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left f \\<diamondop> pure x = left g \\<diamondop> pure x", "using Eq_tree[of x]"], ["proof (prove)\nusing this:\n  f \\<diamondop> pure x = g \\<diamondop> pure x\n\ngoal (1 subgoal):\n 1. left f \\<diamondop> pure x = left g \\<diamondop> pure x", "by(subst (asm) (1 2) ap_tree.ctr) simp"], ["proof (state)\nthis:\n  left f \\<diamondop> pure x = left g \\<diamondop> pure x\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "}"], ["proof (state)\nthis:\n  left f \\<diamondop> pure ?x2 = left g \\<diamondop> pure ?x2\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "moreover"], ["proof (state)\nthis:\n  left f \\<diamondop> pure ?x2 = left g \\<diamondop> pure ?x2\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "{"], ["proof (state)\nthis:\n  left f \\<diamondop> pure ?x2 = left g \\<diamondop> pure ?x2\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "have \"right f \\<diamondop> pure x = right g \\<diamondop> pure x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right f \\<diamondop> pure x = right g \\<diamondop> pure x", "using Eq_tree[of x]"], ["proof (prove)\nusing this:\n  f \\<diamondop> pure x = g \\<diamondop> pure x\n\ngoal (1 subgoal):\n 1. right f \\<diamondop> pure x = right g \\<diamondop> pure x", "by(subst (asm) (1 2) ap_tree.ctr) simp"], ["proof (state)\nthis:\n  right f \\<diamondop> pure x = right g \\<diamondop> pure x\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "}"], ["proof (state)\nthis:\n  right f \\<diamondop> pure ?x2 = right g \\<diamondop> pure ?x2\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<forall>x.\n          f \\<diamondop> pure x = g \\<diamondop> pure x \\<Longrightarrow>\n       root f = root g \\<and>\n       (\\<exists>fa ga.\n           left f = fa \\<and>\n           left g = ga \\<and>\n           (\\<forall>x.\n               fa \\<diamondop> pure x = ga \\<diamondop> pure x)) \\<and>\n       (\\<exists>fa ga.\n           right f = fa \\<and>\n           right g = ga \\<and>\n           (\\<forall>x. fa \\<diamondop> pure x = ga \\<diamondop> pure x))", "ultimately"], ["proof (chain)\npicking this:\n  root f = root g\n  left f \\<diamondop> pure ?x2 = left g \\<diamondop> pure ?x2\n  right f \\<diamondop> pure ?x2 = right g \\<diamondop> pure ?x2", "show ?case"], ["proof (prove)\nusing this:\n  root f = root g\n  left f \\<diamondop> pure ?x2 = left g \\<diamondop> pure ?x2\n  right f \\<diamondop> pure ?x2 = right g \\<diamondop> pure ?x2\n\ngoal (1 subgoal):\n 1. root f = root g \\<and>\n    (\\<exists>f g.\n        left f = f \\<and>\n        left g = g \\<and>\n        (\\<forall>x. f \\<diamondop> pure x = g \\<diamondop> pure x)) \\<and>\n    (\\<exists>f g.\n        right f = f \\<and>\n        right g = g \\<and>\n        (\\<forall>x. f \\<diamondop> pure x = g \\<diamondop> pure x))", "by simp"], ["proof (state)\nthis:\n  root f = root g \\<and>\n  (\\<exists>f g.\n      left f = f \\<and>\n      left g = g \\<and>\n      (\\<forall>x. f \\<diamondop> pure x = g \\<diamondop> pure x)) \\<and>\n  (\\<exists>f g.\n      right f = f \\<and>\n      right g = g \\<and>\n      (\\<forall>x. f \\<diamondop> pure x = g \\<diamondop> pure x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ap_tree_extensional:\n  \"(\\<And>x. f \\<diamondop> x = g \\<diamondop> x) \\<Longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f \\<diamondop> x = g \\<diamondop> x) \\<Longrightarrow> f = g", "by(rule ap_tree_strong_extensional) simp"], ["", "subsection \\<open>Standard tree combinators\\<close>"], ["", "subsubsection \\<open>Recurse combinator\\<close>"], ["", "text \\<open>\n  This will be the main combinator to define trees recursively\n\n  Uniqueness for this gives us the unique fixed-point theorem for guarded recursive definitions.\n\\<close>"], ["", "lemma map_unfold_tree [simp]: fixes l r x\n defines \"unf \\<equiv> unfold_tree (\\<lambda>f. f x) (\\<lambda>f. f \\<circ> l) (\\<lambda>f. f \\<circ> r)\"\n shows \"map_tree G (unf F) = unf (G \\<circ> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree G (unf F) = unf (G \\<circ> F)", "by(coinduction arbitrary: F G)(auto 4 3 simp add: unf_def o_assoc)"], ["", "friend_of_corec map_tree :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n  \"map_tree f t = Node (f (root t)) (map_tree f (left t)) (map_tree f (right t))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. map_tree f t =\n    Node (f (root t)) (map_tree f (left t)) (map_tree f (right t))\n 2. rel_fun (rel_prod (=) (rel_prod R (rel_prod (=) (rel_prod R R))))\n     (rel_prod (=) (rel_prod (rel_ssig_tree_v1 R) (rel_ssig_tree_v1 R)))\n     (\\<lambda>(f, t).\n         (f (case snd t of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x2))),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x3)))))\n     (\\<lambda>(f, t).\n         (f (case snd t of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x2))),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x3)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree f t =\n    Node (f (root t)) (map_tree f (left t)) (map_tree f (right t))", "by (rule tree.expand; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_prod (=) (rel_prod R (rel_prod (=) (rel_prod R R))))\n     (rel_prod (=) (rel_prod (rel_ssig_tree_v1 R) (rel_ssig_tree_v1 R)))\n     (\\<lambda>(f, t).\n         (f (case snd t of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x2))),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x3)))))\n     (\\<lambda>(f, t).\n         (f (case snd t of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x2))),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x3)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_prod (=) (rel_prod R (rel_prod (=) (rel_prod R R))))\n     (rel_prod (=) (rel_prod (rel_ssig_tree_v1 R) (rel_ssig_tree_v1 R)))\n     (\\<lambda>(f, t).\n         (f (case snd t of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x2))),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x3)))))\n     (\\<lambda>(f, t).\n         (f (case snd t of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x2))),\n          tree.v1.Oper\n           (tree.v1.Sig\n             (Inr (f, case snd t of\n                      (x1, x2, x3) \\<Rightarrow> tree.v1.VLeaf x3)))))", "by (fold relator_eq; transfer_prover)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context fixes l :: \"'a \\<Rightarrow> 'a\" and r :: \"'a \\<Rightarrow> 'a\" and x :: \"'a\" begin"], ["", "corec tree_recurse :: \"'a tree\"\nwhere \"tree_recurse = Node x (map_tree l tree_recurse) (map_tree r tree_recurse)\""], ["", "end"], ["", "lemma tree_recurse_simps [simp]:\n  \"root (tree_recurse l r x) = x\"\n  \"left (tree_recurse l r x) = map_tree l (tree_recurse l r x)\"\n  \"right (tree_recurse l r x) = map_tree r (tree_recurse l r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (tree_recurse l r x) = x &&&\n    left (tree_recurse l r x) = map_tree l (tree_recurse l r x) &&&\n    right (tree_recurse l r x) = map_tree r (tree_recurse l r x)", "by(subst tree_recurse.code; simp; fail)+"], ["", "lemma tree_recurse_unfold:\n  \"tree_recurse l r x = Node x (map_tree l (tree_recurse l r x)) (map_tree r (tree_recurse l r x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_recurse l r x =\n    Node x (map_tree l (tree_recurse l r x))\n     (map_tree r (tree_recurse l r x))", "by(fact tree_recurse.code)"], ["", "lemma tree_recurse_fusion:\n  assumes \"h \\<circ> l = l' \\<circ> h\" and \"h \\<circ> r = r' \\<circ> h\"\n  shows \"map_tree h (tree_recurse l r x) = tree_recurse l' r' (h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree h (tree_recurse l r x) = tree_recurse l' r' (h x)", "by(rule tree_recurse.unique)(simp add: tree.expand assms)"], ["", "subsubsection \\<open>Tree iteration\\<close>"], ["", "context fixes l :: \"'a \\<Rightarrow> 'a\" and r :: \"'a \\<Rightarrow> 'a\" begin"], ["", "primcorec tree_iterate :: \" 'a \\<Rightarrow> 'a tree\"\nwhere \"tree_iterate s = Node s (tree_iterate (l s)) (tree_iterate (r s))\""], ["", "end"], ["", "lemma unfold_tree_tree_iterate:\n  \"unfold_tree out l r = map_tree out \\<circ> tree_iterate l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_tree out l r = map_tree out \\<circ> tree_iterate l r", "by(rule ext)(rule unfold_tree_unique[symmetric]; simp)"], ["", "lemma tree_iterate_fusion:\n  assumes \"h \\<circ> l = l' \\<circ> h\"\n  assumes \"h \\<circ> r = r' \\<circ> h\"\n  shows \"map_tree h (tree_iterate l r x) = tree_iterate l' r' (h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree h (tree_iterate l r x) = tree_iterate l' r' (h x)", "apply(coinduction arbitrary: x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       root (map_tree h (tree_iterate l r x)) =\n       root (tree_iterate l' r' (h x)) \\<and>\n       (\\<exists>xa.\n           left (map_tree h (tree_iterate l r x)) =\n           map_tree h (tree_iterate l r xa) \\<and>\n           left (tree_iterate l' r' (h x)) =\n           tree_iterate l' r' (h xa)) \\<and>\n       (\\<exists>xa.\n           right (map_tree h (tree_iterate l r x)) =\n           map_tree h (tree_iterate l r xa) \\<and>\n           right (tree_iterate l' r' (h x)) = tree_iterate l' r' (h xa))", "using assms"], ["proof (prove)\nusing this:\n  h \\<circ> l = l' \\<circ> h\n  h \\<circ> r = r' \\<circ> h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root (map_tree h (tree_iterate l r x)) =\n       root (tree_iterate l' r' (h x)) \\<and>\n       (\\<exists>xa.\n           left (map_tree h (tree_iterate l r x)) =\n           map_tree h (tree_iterate l r xa) \\<and>\n           left (tree_iterate l' r' (h x)) =\n           tree_iterate l' r' (h xa)) \\<and>\n       (\\<exists>xa.\n           right (map_tree h (tree_iterate l r x)) =\n           map_tree h (tree_iterate l r xa) \\<and>\n           right (tree_iterate l' r' (h x)) = tree_iterate l' r' (h xa))", "by(auto simp add: fun_eq_iff)"], ["", "subsubsection \\<open>Tree traversal\\<close>"], ["", "datatype dir = L | R"], ["", "type_synonym path = \"dir list\""], ["", "definition traverse_tree :: \"path \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\"\nwhere \"traverse_tree path \\<equiv> foldr (\\<lambda>d f. f \\<circ> case_dir left right d) path id\""], ["", "lemma traverse_tree_simps[simp]:\n  \"traverse_tree [] = id\"\n  \"traverse_tree (d # path) = traverse_tree path \\<circ> (case d of L \\<Rightarrow> left | R \\<Rightarrow> right)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse_tree [] = id &&&\n    traverse_tree (d # path) =\n    traverse_tree path \\<circ>\n    (case d of L \\<Rightarrow> left | R \\<Rightarrow> right)", "by (simp_all add: traverse_tree_def)"], ["", "lemma traverse_tree_map_tree [simp]:\n  \"traverse_tree path (map_tree f t) = map_tree f (traverse_tree path t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse_tree path (map_tree f t) = map_tree f (traverse_tree path t)", "by (induct path arbitrary: t) (simp_all split: dir.splits)"], ["", "lemma traverse_tree_append [simp]:\n  \"traverse_tree (path @ ext) t = traverse_tree ext (traverse_tree path t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse_tree (path @ ext) t = traverse_tree ext (traverse_tree path t)", "by (induct path arbitrary: t) simp_all"], ["", "text\\<open>@{const \"traverse_tree\"} is an applicative-functor homomorphism.\\<close>"], ["", "lemma traverse_tree_pure_tree [simp]:\n  \"traverse_tree path (pure x) = pure x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse_tree path (pure x) = pure x", "by (induct path arbitrary: x) (simp_all split: dir.splits)"], ["", "lemma traverse_tree_ap [simp]:\n  \"traverse_tree path (f \\<diamondop> x) = traverse_tree path f \\<diamondop> traverse_tree path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse_tree path (f \\<diamondop> x) =\n    traverse_tree path f \\<diamondop> traverse_tree path x", "by (induct path arbitrary: f x) (simp_all split: dir.splits)"], ["", "context fixes l r :: \"'a \\<Rightarrow> 'a\" begin"], ["", "primrec traverse_dir :: \"dir \\<Rightarrow> 'a \\<Rightarrow> 'a\"\nwhere\n  \"traverse_dir L = l\"\n| \"traverse_dir R = r\""], ["", "abbreviation traverse_path :: \"path \\<Rightarrow> 'a \\<Rightarrow> 'a\"\nwhere \"traverse_path \\<equiv> fold traverse_dir\""], ["", "end"], ["", "lemma traverse_tree_tree_iterate:\n  \"traverse_tree path (tree_iterate l r s) =\n   tree_iterate l r (traverse_path l r path s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse_tree path (tree_iterate l r s) =\n    tree_iterate l r (traverse_path l r path s)", "by (induct path arbitrary: s) (simp_all split: dir.splits)"], ["", "text\\<open>\n\n\\citeauthor{DBLP:journals/jfp/Hinze09} shows that if the tree\nconstruction function is suitably monoidal then recursion and\niteration define the same tree.\n\n\\<close>"], ["", "lemma tree_recurse_iterate:\n  assumes monoid:\n    \"\\<And>x y z. f (f x y) z = f x (f y z)\"\n    \"\\<And>x. f x \\<epsilon> = x\"\n    \"\\<And>x. f \\<epsilon> x = x\"\n  shows \"tree_recurse (f l) (f r) \\<epsilon> = tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_recurse (f l) (f r) \\<epsilon> =\n    tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>", "apply(rule tree_recurse.unique[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon> =\n    Node \\<epsilon>\n     (map_tree (f l)\n       (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>))\n     (map_tree (f r)\n       (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>))", "apply(rule tree.expand)"], ["proof (prove)\ngoal (1 subgoal):\n 1. root (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>) =\n    root\n     (Node \\<epsilon>\n       (map_tree (f l)\n         (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>))\n       (map_tree (f r)\n         (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r)\n           \\<epsilon>))) \\<and>\n    left (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>) =\n    left\n     (Node \\<epsilon>\n       (map_tree (f l)\n         (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>))\n       (map_tree (f r)\n         (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r)\n           \\<epsilon>))) \\<and>\n    right\n     (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>) =\n    right\n     (Node \\<epsilon>\n       (map_tree (f l)\n         (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>))\n       (map_tree (f r)\n         (tree_iterate (\\<lambda>x. f x l) (\\<lambda>x. f x r) \\<epsilon>)))", "apply(simp add: tree_iterate_fusion[where r'=\"\\<lambda>x. f x r\" and l'=\"\\<lambda>x. f x l\"] fun_eq_iff monoid)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Mirroring\\<close>"], ["", "primcorec mirror :: \"'a tree \\<Rightarrow> 'a tree\"\nwhere\n  \"root (mirror t) = root t\"\n| \"left (mirror t) = mirror (right t)\"\n| \"right (mirror t) = mirror (left t)\""], ["", "lemma mirror_unfold: \"mirror (Node x l r) = Node x (mirror r) (mirror l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror (Node x l r) = Node x (mirror r) (mirror l)", "by(rule tree.expand) simp"], ["", "lemma mirror_pure: \"mirror (pure x) = pure x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror (pure x) = pure x", "by(coinduction rule: tree.coinduct) simp"], ["", "lemma mirror_ap_tree: \"mirror (f \\<diamondop> x) = mirror f \\<diamondop> mirror x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror (f \\<diamondop> x) = mirror f \\<diamondop> mirror x", "by(coinduction arbitrary: f x) auto"], ["", "end"]]}