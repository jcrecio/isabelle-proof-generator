{"file_name": "/home/qj213/afp-2021-10-22/thys/Stern_Brocot/Stern_Brocot_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stern_Brocot", "problem_names": ["lemma stern_brocot_unfold:\n  \"stern_brocot_recurse =\n   Node (1, 1)\n        (pure recip \\<diamondop> (pure succ \\<diamondop> (pure recip \\<diamondop> stern_brocot_recurse)))\n        (pure succ \\<diamondop> stern_brocot_recurse)\"", "lemma stern_brocot_simps [simp]:\n  \"root stern_brocot_recurse = (1, 1)\"\n  \"left stern_brocot_recurse = pure recip \\<diamondop> (pure succ \\<diamondop> (pure recip \\<diamondop> stern_brocot_recurse))\"\n  \"right stern_brocot_recurse = pure succ \\<diamondop> stern_brocot_recurse\"", "lemma stern_brocot_conv:\n  \"stern_brocot_recurse = tree_recurse (recip \\<circ> succ \\<circ> recip) succ (1, 1)\"", "lemma stern_brocot_denominator_non_zero:\n  \"case root (traverse_tree path stern_brocot_recurse) of (m, n) \\<Rightarrow> m > 0 \\<and> n > 0\"", "lemma stern_brocot_coprime:\n  \"case root (traverse_tree path stern_brocot_recurse) of (m, n) \\<Rightarrow> coprime m n\"", "lemmas mk_path_induct[case_names equal less greater] = mk_path.induct", "theorem stern_brocot_rationals:\n  \"\\<lbrakk> m > 0; n > 0 \\<rbrakk> \\<Longrightarrow>\n  root (traverse_tree (mk_path m n) (pure rat_of \\<diamondop> stern_brocot_recurse)) = Fract (int m) (int n)\"", "lemma Dets [iff]:\n  \"Det I = 1\"\n  \"Det LL = 1\"\n  \"Det UR = 1\"", "lemma LL_UR_Det:\n  \"Det m = 1 \\<Longrightarrow> Det (m \\<otimes> LL) = 1\"\n  \"Det m = 1 \\<Longrightarrow> Det (LL \\<otimes> m) = 1\"\n  \"Det m = 1 \\<Longrightarrow> Det (m \\<otimes> UR) = 1\"\n  \"Det m = 1 \\<Longrightarrow> Det (UR \\<otimes> m) = 1\"", "lemma mediant_I_F [simp]:\n  \"mediant F = (1, 1)\"\n  \"mediant I = (1, 1)\"", "lemma times_matrix_I [simp]:\n  \"I \\<otimes> x = x\"\n  \"x \\<otimes> I = x\"", "lemma times_matrix_assoc [simp]:\n  \"(x \\<otimes> y) \\<otimes> z = x \\<otimes> (y \\<otimes> z)\"", "lemma LL_UR_pos:\n  \"0 < snd (mediant m) \\<Longrightarrow> 0 < snd (mediant (m \\<otimes> LL))\"\n  \"0 < snd (mediant m) \\<Longrightarrow> 0 < snd (mediant (m \\<otimes> UR))\"", "lemma recip_succ_recip: \"recip \\<circ> succ \\<circ> recip = (\\<lambda>(x, y). (x, x + y))\"", "lemma stern_brocot_recurse_iterate: \"stern_brocot_recurse = stern_brocot_iterate\" (is \"?lhs = ?rhs\")", "lemma tree_ordering_left:\n  assumes DX: \"Det X = 1\"\n  assumes DY: \"Det Y = 1\"\n  assumes MX: \"0 < snd (mediant X)\"\n  shows \"rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)\"", "lemma tree_ordering_right:\n  assumes DX: \"Det X = 1\"\n  assumes DY: \"Det Y = 1\"\n  assumes MX: \"0 < snd (mediant X)\"\n  shows \"rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))\"", "lemma stern_brocot_iterate_aux_Det:\n  assumes \"Det m = 1\" \"0 < snd (mediant m)\"\n  shows \"Det (root (traverse_tree path (stern_brocot_iterate_aux m))) = 1\"\n  and \"0 < snd (mediant (root (traverse_tree path (stern_brocot_iterate_aux m))))\"", "lemma stern_brocot_iterate_aux_decompose:\n  \"\\<exists>m''. m \\<otimes> m'' = root (traverse_tree path (stern_brocot_iterate_aux m)) \\<and> Det m'' = 1\"", "lemma stern_brocot_fractions_not_repeated_strict_prefix:\n  assumes \"root (traverse_tree path stern_brocot_iterate) = root (traverse_tree path' stern_brocot_iterate)\"\n  assumes pp': \"strict_prefix path path'\"\n  shows False", "lemma stern_brocot_fractions_not_repeated_parallel:\n  assumes \"root (traverse_tree path stern_brocot_iterate) = root (traverse_tree path' stern_brocot_iterate)\"\n  assumes p: \"path = pref @ d # ds\"\n  assumes p': \"path' = pref @ d' # ds'\"\n  assumes dd': \"d \\<noteq> d'\"\n  shows False", "lemma lists_not_eq:\n  assumes \"xs \\<noteq> ys\"\n  obtains\n    (c1) \"strict_prefix xs ys\"\n  | (c2) \"strict_prefix ys xs\"\n  | (c3) ps x y xs' ys'\n          where \"xs = ps @ x # xs'\" and \"ys = ps @ y # ys'\" and \"x \\<noteq> y\"", "lemma stern_brocot_fractions_not_repeated:\n  assumes \"root (traverse_tree path stern_brocot_iterate) = root (traverse_tree path' stern_brocot_iterate)\"\n  shows \"path = path'\"", "lemma rat_inv_eq:\n  assumes \"Fract a b = Fract c d\"\n  assumes \"b > 0\"\n  assumes \"d > 0\"\n  assumes \"coprime a b\"\n  assumes \"coprime c d\"\n  shows \"a = c \\<and> b = d\"", "theorem stern_brocot_rationals_not_repeated:\n  assumes \"root (traverse_tree path (pure rat_of \\<diamondop> stern_brocot_recurse))\n         = root (traverse_tree path' (pure rat_of \\<diamondop> stern_brocot_recurse))\"\n  shows \"path = path'\"", "lemma mediant_times_F: \"mediant \\<circ> (\\<lambda>s. s \\<otimes> F) = mediant\"", "lemma stern_brocot_iterate: \"stern_brocot = stern_brocot_iterate\"", "theorem stern_brocot_mediant_recurse: \"stern_brocot = stern_brocot_recurse\"", "lemma tree_chop_sel [simp]:\n  \"root (tree_chop t) = root (left t)\"\n  \"left (tree_chop t) = right t\"\n  \"right (tree_chop t) = tree_chop (left t)\"", "lemma tree_chop_pure_tree [simp]:\n  \"tree_chop (pure x) = pure x\"", "lemma tree_chop_ap_tree [simp]:\n  \"tree_chop (f \\<diamondop> x) = tree_chop f \\<diamondop> tree_chop x\"", "lemma tree_chop_plus: \"tree_chop (t + t') = tree_chop t + tree_chop t'\"", "lemma stream_sel [simp]:\n  \"shd (stream t) = root t\"\n  \"stl (stream t) = stream (tree_chop t)\"", "lemma stream_pure [simp]: \"stream (pure x) = pure x\"", "lemma stream_ap [simp]: \"stream (f \\<diamondop> x) = stream f \\<diamondop> stream x\"", "lemma stream_plus [simp]: \"stream (t + t') = stream t + stream t'\"", "lemma stream_minus [simp]: \"stream (t - t') = stream t - stream t'\"", "lemma stream_times [simp]: \"stream (t * t') = stream t * stream t'\"", "lemma stream_mod [simp]: \"stream (t mod t') = stream t mod stream t'\"", "lemma stream_1 [simp]: \"stream 1 = 1\"", "lemma stream_numeral [simp]: \"stream (numeral n) = numeral n\"", "lemma num_unfold: \"num = Node 1 num (num + den)\"", "lemma den_unfold: \"den = Node 1 (num + den) den\"", "lemma num_simps [simp]:\n  \"root num = 1\"\n  \"left num = num\"\n  \"right num = num + den\"", "lemma den_simps [simp]:\n  \"root den = 1\"\n  \"left den = num + den\"\n  \"right den = den\"", "lemma stern_brocot_num_den:\n  \"pure_tree Pair \\<diamondop> num \\<diamondop> den = stern_brocot_recurse\"", "lemma den_eq_chop_num: \"den = tree_chop num\"", "lemma num_conv: \"num = pure fst \\<diamondop> stern_brocot_recurse\"", "lemma den_conv: \"den = pure snd \\<diamondop> stern_brocot_recurse\"", "lemma num_mod_den_simps [simp]:\n  \"root num_mod_den = 0\"\n  \"left num_mod_den = num\"\n  \"right num_mod_den = num_mod_den\"", "lemma mod_tree_lemma1:\n  fixes x :: \"nat tree\"\n  assumes \"\\<forall>i\\<in>set_tree y. 0 < i\"\n  shows \"x mod (x + y) = x\"", "lemma mod_tree_lemma2:\n  fixes x y :: \"'a :: unique_euclidean_semiring tree\"\n  shows \"(x + y) mod y = x mod y\"", "lemma set_tree_pathD: \"x \\<in> set_tree t \\<Longrightarrow> \\<exists>p. x = root (traverse_tree p t)\"", "lemma den_gt_0: \"0 < x\" if \"x \\<in> set_tree den\"", "lemma num_mod_den: \"num mod den = num_mod_den\"", "lemma tree_chop_den: \"tree_chop den = num + den - 2 * (num mod den)\"", "lemmas stern_brocot_loopless_rec = stern_brocot_loopless.code", "lemma fusc_unfold: \"fusc = 1 ## fusc'\"", "lemma fusc'_unfold: \"fusc' = 1 ## (fusc + fusc' - 2 * (fusc mod fusc'))\"", "lemma fusc_simps [simp]:\n  \"shd fusc = 1\"\n  \"stl fusc = fusc'\"", "lemma fusc'_simps [simp]:\n  \"shd fusc' = 1\"\n  \"stl fusc' = fusc + fusc' - 2 * (fusc mod fusc')\"", "lemma stern_brocot_loopless_siterate: \"stern_brocot_loopless = siterate step (1, 1)\"", "lemma fusc_fusc'_iterate: \"pure Pair \\<diamondop> fusc \\<diamondop> fusc' = stern_brocot_loopless\"", "theorem stern_brocot_loopless:\n  \"stream stern_brocot_recurse = stern_brocot_loopless\" (is \"?lhs = ?rhs\")"], "translations": [["", "lemma stern_brocot_unfold:\n  \"stern_brocot_recurse =\n   Node (1, 1)\n        (pure recip \\<diamondop> (pure succ \\<diamondop> (pure recip \\<diamondop> stern_brocot_recurse)))\n        (pure succ \\<diamondop> stern_brocot_recurse)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot_recurse =\n    Node (1, 1)\n     (pure recip \\<diamondop>\n      (pure succ \\<diamondop>\n       (pure recip \\<diamondop> stern_brocot_recurse)))\n     (pure succ \\<diamondop> stern_brocot_recurse)", "by(fact stern_brocot_recurse.code[unfolded map_tree_ap_tree_pure_tree[symmetric]])"], ["", "lemma stern_brocot_simps [simp]:\n  \"root stern_brocot_recurse = (1, 1)\"\n  \"left stern_brocot_recurse = pure recip \\<diamondop> (pure succ \\<diamondop> (pure recip \\<diamondop> stern_brocot_recurse))\"\n  \"right stern_brocot_recurse = pure succ \\<diamondop> stern_brocot_recurse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root stern_brocot_recurse = (1, 1) &&&\n    left stern_brocot_recurse =\n    pure recip \\<diamondop>\n    (pure succ \\<diamondop>\n     (pure recip \\<diamondop> stern_brocot_recurse)) &&&\n    right stern_brocot_recurse = pure succ \\<diamondop> stern_brocot_recurse", "by (subst stern_brocot_unfold, simp)+"], ["", "lemma stern_brocot_conv:\n  \"stern_brocot_recurse = tree_recurse (recip \\<circ> succ \\<circ> recip) succ (1, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot_recurse =\n    tree_recurse (recip \\<circ> succ \\<circ> recip) succ (1, 1)", "apply(rule tree_recurse.unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot_recurse =\n    Node (1, 1)\n     (map_tree (recip \\<circ> succ \\<circ> recip) stern_brocot_recurse)\n     (map_tree succ stern_brocot_recurse)", "apply(subst stern_brocot_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Node (1, 1)\n     (pure recip \\<diamondop>\n      (pure succ \\<diamondop>\n       (pure recip \\<diamondop> stern_brocot_recurse)))\n     (pure succ \\<diamondop> stern_brocot_recurse) =\n    Node (1, 1)\n     (map_tree (recip \\<circ> succ \\<circ> recip) stern_brocot_recurse)\n     (map_tree succ stern_brocot_recurse)", "apply(simp add: o_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure recip \\<diamondop>\n    (pure succ \\<diamondop>\n     (pure recip \\<diamondop> stern_brocot_recurse)) =\n    map_tree (recip \\<circ> succ \\<circ> recip) stern_brocot_recurse \\<and>\n    pure succ \\<diamondop> stern_brocot_recurse =\n    map_tree succ stern_brocot_recurse", "apply(rule conjI; applicative_nf; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Basic properties\\<close>"], ["", "text \\<open>\n  The recursive definition is useful for showing some basic properties of the tree, \n  such as that the pairs of numbers at each node are coprime, and have non-zero denominators.\n  Both are simple inductions on the path.\n\\<close>"], ["", "lemma stern_brocot_denominator_non_zero:\n  \"case root (traverse_tree path stern_brocot_recurse) of (m, n) \\<Rightarrow> m > 0 \\<and> n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case root (traverse_tree path stern_brocot_recurse) of\n    (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n", "by(induct path)(auto split: dir.splits)"], ["", "lemma stern_brocot_coprime:\n  \"case root (traverse_tree path stern_brocot_recurse) of (m, n) \\<Rightarrow> coprime m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case root (traverse_tree path stern_brocot_recurse) of\n    (m, n) \\<Rightarrow> coprime m n", "by (induct path) (auto split: dir.splits simp add: coprime_iff_gcd_eq_1, metis gcd.commute gcd_add1)"], ["", "subsection \\<open>All the rationals\\<close>"], ["", "text\\<open>\n  For every pair of positive naturals, we can construct a path into the Stern-Brocot tree such that the naturals at the end of the path define the same rational as the pair we started with.\n  Intuitively, the choices made by Euclid's algorithm define this path.\n\\<close>"], ["", "function mk_path :: \"nat \\<Rightarrow> nat \\<Rightarrow> path\" where\n  \"m = n \\<Longrightarrow> mk_path (Suc m) (Suc n) = []\"\n| \"m < n \\<Longrightarrow> mk_path (Suc m) (Suc n) = L # mk_path (Suc m) (n - m)\"\n| \"m > n \\<Longrightarrow> mk_path (Suc m) (Suc n) = R # mk_path (m - n) (Suc n)\"\n| \"mk_path 0 _ = undefined\"\n| \"mk_path _ 0 = undefined\""], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m = n; x = (Suc m, Suc n)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>m n.\n           \\<lbrakk>m < n; x = (Suc m, Suc n)\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>m n.\n           \\<lbrakk>n < m; x = (Suc m, Suc n)\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>uu_. x = (0, uu_) \\<Longrightarrow> P;\n        \\<And>uv_. x = (uv_, 0) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>m n ma na.\n       \\<lbrakk>m = n; ma = na; (Suc m, Suc n) = (Suc ma, Suc na)\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 3. \\<And>m n ma na.\n       \\<lbrakk>m = n; ma < na; (Suc m, Suc n) = (Suc ma, Suc na)\\<rbrakk>\n       \\<Longrightarrow> [] = L # mk_path_sumC (Suc ma, na - ma)\n 4. \\<And>m n ma na.\n       \\<lbrakk>m = n; na < ma; (Suc m, Suc n) = (Suc ma, Suc na)\\<rbrakk>\n       \\<Longrightarrow> [] = R # mk_path_sumC (ma - na, Suc na)\n 5. \\<And>m n uu_.\n       \\<lbrakk>m = n; (Suc m, Suc n) = (0, uu_)\\<rbrakk>\n       \\<Longrightarrow> [] = undefined\n 6. \\<And>m n uv_.\n       \\<lbrakk>m = n; (Suc m, Suc n) = (uv_, 0)\\<rbrakk>\n       \\<Longrightarrow> [] = undefined\n 7. \\<And>m n ma na.\n       \\<lbrakk>m < n; ma < na; (Suc m, Suc n) = (Suc ma, Suc na)\\<rbrakk>\n       \\<Longrightarrow> L # mk_path_sumC (Suc m, n - m) =\n                         L # mk_path_sumC (Suc ma, na - ma)\n 8. \\<And>m n ma na.\n       \\<lbrakk>m < n; na < ma; (Suc m, Suc n) = (Suc ma, Suc na)\\<rbrakk>\n       \\<Longrightarrow> L # mk_path_sumC (Suc m, n - m) =\n                         R # mk_path_sumC (ma - na, Suc na)\n 9. \\<And>m n uu_.\n       \\<lbrakk>m < n; (Suc m, Suc n) = (0, uu_)\\<rbrakk>\n       \\<Longrightarrow> L # mk_path_sumC (Suc m, n - m) = undefined\n 10. \\<And>m n uv_.\n        \\<lbrakk>m < n; (Suc m, Suc n) = (uv_, 0)\\<rbrakk>\n        \\<Longrightarrow> L # mk_path_sumC (Suc m, n - m) = undefined\nA total of 16 subgoals...", "by atomize_elim(auto, arith)"], ["", "termination mk_path"], ["proof (prove)\ngoal (1 subgoal):\n 1. All mk_path_dom", "by lexicographic_order"], ["", "lemmas mk_path_induct[case_names equal less greater] = mk_path.induct"], ["", "abbreviation rat_of :: \"fraction \\<Rightarrow> rat\"\nwhere \"rat_of \\<equiv> \\<lambda>(x, y). Fract (int x) (int y)\""], ["", "theorem stern_brocot_rationals:\n  \"\\<lbrakk> m > 0; n > 0 \\<rbrakk> \\<Longrightarrow>\n  root (traverse_tree (mk_path m n) (pure rat_of \\<diamondop> stern_brocot_recurse)) = Fract (int m) (int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; 0 < n\\<rbrakk>\n    \\<Longrightarrow> root\n                       (traverse_tree (mk_path m n)\n                         (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n                      Fract (int m) (int n)", "proof(induction m n rule: mk_path_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m = n; 0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 2. \\<And>m n.\n       \\<lbrakk>m < n;\n        \\<lbrakk>0 < Suc m; 0 < n - m\\<rbrakk>\n        \\<Longrightarrow> root\n                           (traverse_tree (mk_path (Suc m) (n - m))\n                             (pure rat_of \\<diamondop>\n                              stern_brocot_recurse)) =\n                          Fract (int (Suc m)) (int (n - m));\n        0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 3. \\<And>m n.\n       \\<lbrakk>n < m;\n        \\<lbrakk>0 < m - n; 0 < Suc n\\<rbrakk>\n        \\<Longrightarrow> root\n                           (traverse_tree (mk_path (m - n) (Suc n))\n                             (pure rat_of \\<diamondop>\n                              stern_brocot_recurse)) =\n                          Fract (int (m - n)) (int (Suc n));\n        0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 4. \\<And>uu_.\n       \\<lbrakk>0 < 0; 0 < uu_\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path 0 uu_)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int 0) (int uu_)\n 5. \\<And>uv_.\n       \\<lbrakk>0 < uv_; 0 < 0\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path uv_ 0)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int uv_) (int 0)", "case (less m n)"], ["proof (state)\nthis:\n  m < n\n  \\<lbrakk>0 < Suc m; 0 < n - m\\<rbrakk>\n  \\<Longrightarrow> root\n                     (traverse_tree (mk_path (Suc m) (n - m))\n                       (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n                    Fract (int (Suc m)) (int (n - m))\n  0 < Suc m\n  0 < Suc n\n\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m = n; 0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 2. \\<And>m n.\n       \\<lbrakk>m < n;\n        \\<lbrakk>0 < Suc m; 0 < n - m\\<rbrakk>\n        \\<Longrightarrow> root\n                           (traverse_tree (mk_path (Suc m) (n - m))\n                             (pure rat_of \\<diamondop>\n                              stern_brocot_recurse)) =\n                          Fract (int (Suc m)) (int (n - m));\n        0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 3. \\<And>m n.\n       \\<lbrakk>n < m;\n        \\<lbrakk>0 < m - n; 0 < Suc n\\<rbrakk>\n        \\<Longrightarrow> root\n                           (traverse_tree (mk_path (m - n) (Suc n))\n                             (pure rat_of \\<diamondop>\n                              stern_brocot_recurse)) =\n                          Fract (int (m - n)) (int (Suc n));\n        0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 4. \\<And>uu_.\n       \\<lbrakk>0 < 0; 0 < uu_\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path 0 uu_)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int 0) (int uu_)\n 5. \\<And>uv_.\n       \\<lbrakk>0 < uv_; 0 < 0\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path uv_ 0)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int uv_) (int 0)", "with stern_brocot_denominator_non_zero[where path=\"mk_path (Suc m) (n - m)\"]"], ["proof (chain)\npicking this:\n  case root\n        (traverse_tree (mk_path (Suc m) (n - m)) stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n\n  m < n\n  \\<lbrakk>0 < Suc m; 0 < n - m\\<rbrakk>\n  \\<Longrightarrow> root\n                     (traverse_tree (mk_path (Suc m) (n - m))\n                       (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n                    Fract (int (Suc m)) (int (n - m))\n  0 < Suc m\n  0 < Suc n", "show ?case"], ["proof (prove)\nusing this:\n  case root\n        (traverse_tree (mk_path (Suc m) (n - m)) stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n\n  m < n\n  \\<lbrakk>0 < Suc m; 0 < n - m\\<rbrakk>\n  \\<Longrightarrow> root\n                     (traverse_tree (mk_path (Suc m) (n - m))\n                       (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n                    Fract (int (Suc m)) (int (n - m))\n  0 < Suc m\n  0 < Suc n\n\ngoal (1 subgoal):\n 1. root\n     (traverse_tree (mk_path (Suc m) (Suc n))\n       (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n    Fract (int (Suc m)) (int (Suc n))", "by (simp add: eq_rat field_simps of_nat_diff split: prod.split_asm)"], ["proof (state)\nthis:\n  root\n   (traverse_tree (mk_path (Suc m) (Suc n))\n     (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n  Fract (int (Suc m)) (int (Suc n))\n\ngoal (4 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m = n; 0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 2. \\<And>m n.\n       \\<lbrakk>n < m;\n        \\<lbrakk>0 < m - n; 0 < Suc n\\<rbrakk>\n        \\<Longrightarrow> root\n                           (traverse_tree (mk_path (m - n) (Suc n))\n                             (pure rat_of \\<diamondop>\n                              stern_brocot_recurse)) =\n                          Fract (int (m - n)) (int (Suc n));\n        0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 3. \\<And>uu_.\n       \\<lbrakk>0 < 0; 0 < uu_\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path 0 uu_)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int 0) (int uu_)\n 4. \\<And>uv_.\n       \\<lbrakk>0 < uv_; 0 < 0\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path uv_ 0)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int uv_) (int 0)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m = n; 0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 2. \\<And>m n.\n       \\<lbrakk>n < m;\n        \\<lbrakk>0 < m - n; 0 < Suc n\\<rbrakk>\n        \\<Longrightarrow> root\n                           (traverse_tree (mk_path (m - n) (Suc n))\n                             (pure rat_of \\<diamondop>\n                              stern_brocot_recurse)) =\n                          Fract (int (m - n)) (int (Suc n));\n        0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 3. \\<And>uu_.\n       \\<lbrakk>0 < 0; 0 < uu_\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path 0 uu_)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int 0) (int uu_)\n 4. \\<And>uv_.\n       \\<lbrakk>0 < uv_; 0 < 0\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path uv_ 0)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int uv_) (int 0)", "case (greater m n)"], ["proof (state)\nthis:\n  n < m\n  \\<lbrakk>0 < m - n; 0 < Suc n\\<rbrakk>\n  \\<Longrightarrow> root\n                     (traverse_tree (mk_path (m - n) (Suc n))\n                       (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n                    Fract (int (m - n)) (int (Suc n))\n  0 < Suc m\n  0 < Suc n\n\ngoal (4 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m = n; 0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 2. \\<And>m n.\n       \\<lbrakk>n < m;\n        \\<lbrakk>0 < m - n; 0 < Suc n\\<rbrakk>\n        \\<Longrightarrow> root\n                           (traverse_tree (mk_path (m - n) (Suc n))\n                             (pure rat_of \\<diamondop>\n                              stern_brocot_recurse)) =\n                          Fract (int (m - n)) (int (Suc n));\n        0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 3. \\<And>uu_.\n       \\<lbrakk>0 < 0; 0 < uu_\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path 0 uu_)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int 0) (int uu_)\n 4. \\<And>uv_.\n       \\<lbrakk>0 < uv_; 0 < 0\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path uv_ 0)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int uv_) (int 0)", "with stern_brocot_denominator_non_zero[where path=\"mk_path (m - n) (Suc n)\"]"], ["proof (chain)\npicking this:\n  case root\n        (traverse_tree (mk_path (m - n) (Suc n)) stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n\n  n < m\n  \\<lbrakk>0 < m - n; 0 < Suc n\\<rbrakk>\n  \\<Longrightarrow> root\n                     (traverse_tree (mk_path (m - n) (Suc n))\n                       (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n                    Fract (int (m - n)) (int (Suc n))\n  0 < Suc m\n  0 < Suc n", "show ?case"], ["proof (prove)\nusing this:\n  case root\n        (traverse_tree (mk_path (m - n) (Suc n)) stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n\n  n < m\n  \\<lbrakk>0 < m - n; 0 < Suc n\\<rbrakk>\n  \\<Longrightarrow> root\n                     (traverse_tree (mk_path (m - n) (Suc n))\n                       (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n                    Fract (int (m - n)) (int (Suc n))\n  0 < Suc m\n  0 < Suc n\n\ngoal (1 subgoal):\n 1. root\n     (traverse_tree (mk_path (Suc m) (Suc n))\n       (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n    Fract (int (Suc m)) (int (Suc n))", "by (simp add: eq_rat field_simps of_nat_diff split: prod.split_asm)"], ["proof (state)\nthis:\n  root\n   (traverse_tree (mk_path (Suc m) (Suc n))\n     (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n  Fract (int (Suc m)) (int (Suc n))\n\ngoal (3 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m = n; 0 < Suc m; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path (Suc m) (Suc n))\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int (Suc m)) (int (Suc n))\n 2. \\<And>uu_.\n       \\<lbrakk>0 < 0; 0 < uu_\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path 0 uu_)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int 0) (int uu_)\n 3. \\<And>uv_.\n       \\<lbrakk>0 < uv_; 0 < 0\\<rbrakk>\n       \\<Longrightarrow> root\n                          (traverse_tree (mk_path uv_ 0)\n                            (pure rat_of \\<diamondop>\n                             stern_brocot_recurse)) =\n                         Fract (int uv_) (int 0)", "qed (simp_all add: eq_rat)"], ["", "subsection \\<open>No repetitions\\<close>"], ["", "text \\<open>\n  We establish that the Stern-Brocot tree does not contain repetitions, i.e.,\n  that each rational number appears at most once in it.\n  Note that this property is stronger than merely requiring that pairs of naturals not be repeated,\n  though it is implied by that property and @{thm [source] \"stern_brocot_coprime\"}.\n  \n  Intuitively, the tree enjoys the \\emph{binary search tree} ordering property when we map our\n  pairs of naturals into rationals. This suffices to show that each rational appears at most once\n  in the tree. To establish this seems to require more structure than is present in the recursion\n  equations, and so we follow \\citet{BackhouseFerreira2008MPC} and \\citet{Hinze2009JFP} by\n  introducing another definition of the tree, which summarises the path to each node using a matrix.\n\n  We then derive an iterative version and use invariant reasoning on that.\n  We begin by defining some matrix machinery.\n  This is all elementary and primitive (we do not need much algebra).\n\\<close>"], ["", "type_synonym matrix = \"fraction \\<times> fraction\""], ["", "type_synonym vector = fraction"], ["", "definition times_matrix :: \"matrix \\<Rightarrow> matrix \\<Rightarrow> matrix\" (infixl \"\\<otimes>\" 70)\nwhere \"times_matrix = (\\<lambda>((a, c), (b, d)) ((a', c'), (b', d')).\n       ((a * a' + b * c', c * a' + d * c'),\n        (a * b' + b * d', c * b' + d * d')))\""], ["", "definition times_vector :: \"matrix \\<Rightarrow> vector \\<Rightarrow> vector\" (infixr \"\\<odot>\" 70)\nwhere \"times_vector = (\\<lambda>((a, c), (b, d)) (a', c'). (a * a' + b * c', c * a' + d * c'))\""], ["", "context begin"], ["", "private"], ["", "definition F :: matrix where \"F = ((0, 1), (1, 0))\""], ["", "private"], ["", "definition I :: matrix where \"I = ((1, 0), (0, 1))\""], ["", "private"], ["", "definition LL :: matrix where \"LL = ((1, 1), (0, 1))\""], ["", "private"], ["", "definition UR :: matrix where \"UR = ((1, 0), (1, 1))\""], ["", "definition Det :: \"matrix \\<Rightarrow> nat\" where \"Det \\<equiv> \\<lambda>((a, c), (b, d)). a * d - b * c\""], ["", "lemma Dets [iff]:\n  \"Det I = 1\"\n  \"Det LL = 1\"\n  \"Det UR = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det I = 1 &&& Det LL = 1 &&& Det UR = 1", "unfolding Det_def I_def LL_def UR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ((1, 0), 0, 1) of\n     (x, xa) \\<Rightarrow>\n       (case x of (a, c) \\<Rightarrow> \\<lambda>(b, d). a * d - b * c) xa) =\n    1 &&&\n    (case ((1, 1), 0, 1) of\n     (x, xa) \\<Rightarrow>\n       (case x of (a, c) \\<Rightarrow> \\<lambda>(b, d). a * d - b * c) xa) =\n    1 &&&\n    (case ((1, 0), 1, 1) of\n     (x, xa) \\<Rightarrow>\n       (case x of (a, c) \\<Rightarrow> \\<lambda>(b, d). a * d - b * c) xa) =\n    1", "by simp_all"], ["", "lemma LL_UR_Det:\n  \"Det m = 1 \\<Longrightarrow> Det (m \\<otimes> LL) = 1\"\n  \"Det m = 1 \\<Longrightarrow> Det (LL \\<otimes> m) = 1\"\n  \"Det m = 1 \\<Longrightarrow> Det (m \\<otimes> UR) = 1\"\n  \"Det m = 1 \\<Longrightarrow> Det (UR \\<otimes> m) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Det m = 1 \\<Longrightarrow> Det (m \\<otimes> LL) = 1) &&&\n     (Det m = 1 \\<Longrightarrow> Det (LL \\<otimes> m) = 1)) &&&\n    (Det m = 1 \\<Longrightarrow> Det (m \\<otimes> UR) = 1) &&&\n    (Det m = 1 \\<Longrightarrow> Det (UR \\<otimes> m) = 1)", "by (cases m, simp add: Det_def LL_def UR_def times_matrix_def split_def field_simps)+"], ["", "lemma mediant_I_F [simp]:\n  \"mediant F = (1, 1)\"\n  \"mediant I = (1, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mediant F = (1, 1) &&& mediant I = (1, 1)", "by (simp_all add: F_def I_def mediant_def)"], ["", "lemma times_matrix_I [simp]:\n  \"I \\<otimes> x = x\"\n  \"x \\<otimes> I = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<otimes> x = x &&& x \\<otimes> I = x", "by (simp_all add: times_matrix_def I_def split_def)"], ["", "lemma times_matrix_assoc [simp]:\n  \"(x \\<otimes> y) \\<otimes> z = x \\<otimes> (y \\<otimes> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<otimes> y \\<otimes> z = x \\<otimes> (y \\<otimes> z)", "by (simp add: times_matrix_def field_simps split_def)"], ["", "lemma LL_UR_pos:\n  \"0 < snd (mediant m) \\<Longrightarrow> 0 < snd (mediant (m \\<otimes> LL))\"\n  \"0 < snd (mediant m) \\<Longrightarrow> 0 < snd (mediant (m \\<otimes> UR))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < snd (mediant m) \\<Longrightarrow>\n     0 < snd (mediant (m \\<otimes> LL))) &&&\n    (0 < snd (mediant m) \\<Longrightarrow>\n     0 < snd (mediant (m \\<otimes> UR)))", "by (cases m) (simp_all add: LL_def UR_def times_matrix_def split_def field_simps mediant_def)"], ["", "lemma recip_succ_recip: \"recip \\<circ> succ \\<circ> recip = (\\<lambda>(x, y). (x, x + y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recip \\<circ> succ \\<circ> recip = (\\<lambda>(x, y). (x, x + y))", "by (clarsimp simp: fun_eq_iff)"], ["", "text \\<open>\n  \\citeauthor{BackhouseFerreira2008MPC} work with the identity matrix @{const \"I\"} at the root.\n  This has the advantage that all relevant matrices have determinants of @{term \"1 :: nat\"}.\n\\<close>"], ["", "definition stern_brocot_iterate_aux :: \"matrix \\<Rightarrow> matrix tree\"\nwhere \"stern_brocot_iterate_aux \\<equiv> tree_iterate (\\<lambda>s. s \\<otimes> LL) (\\<lambda>s. s \\<otimes> UR)\""], ["", "definition stern_brocot_iterate :: \"fraction tree\"\nwhere \"stern_brocot_iterate \\<equiv> map_tree mediant (stern_brocot_iterate_aux I)\""], ["", "lemma stern_brocot_recurse_iterate: \"stern_brocot_recurse = stern_brocot_iterate\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot_recurse = stern_brocot_iterate", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stern_brocot_recurse = stern_brocot_iterate", "have \"?rhs = map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot_iterate =\n    map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I)", "using tree_recurse_iterate[where f=\"(\\<otimes>)\" and l=\"LL\" and r=\"UR\" and \\<epsilon>=\"I\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z.\n              x \\<otimes> y \\<otimes> z = x \\<otimes> (y \\<otimes> z);\n   \\<And>x. x \\<otimes> I = x; \\<And>x. I \\<otimes> x = x\\<rbrakk>\n  \\<Longrightarrow> tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I =\n                    tree_iterate (\\<lambda>x. x \\<otimes> LL)\n                     (\\<lambda>x. x \\<otimes> UR) I\n\ngoal (1 subgoal):\n 1. stern_brocot_iterate =\n    map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I)", "by (simp add: stern_brocot_iterate_def stern_brocot_iterate_aux_def)"], ["proof (state)\nthis:\n  stern_brocot_iterate =\n  map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I)\n\ngoal (1 subgoal):\n 1. stern_brocot_recurse = stern_brocot_iterate", "also"], ["proof (state)\nthis:\n  stern_brocot_iterate =\n  map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I)\n\ngoal (1 subgoal):\n 1. stern_brocot_recurse = stern_brocot_iterate", "have \"\\<dots> = tree_recurse ((\\<odot>) LL) ((\\<odot>) UR) (1, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I) =\n    tree_recurse ((\\<odot>) LL) ((\\<odot>) UR) (1, 1)", "unfolding mediant_I_F(2)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I) =\n    tree_recurse ((\\<odot>) LL) ((\\<odot>) UR) (mediant I)", "by (rule tree_recurse_fusion)(simp_all add: fun_eq_iff mediant_def times_matrix_def times_vector_def LL_def UR_def)[2]"], ["proof (state)\nthis:\n  map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I) =\n  tree_recurse ((\\<odot>) LL) ((\\<odot>) UR) (1, 1)\n\ngoal (1 subgoal):\n 1. stern_brocot_recurse = stern_brocot_iterate", "also"], ["proof (state)\nthis:\n  map_tree mediant (tree_recurse ((\\<otimes>) LL) ((\\<otimes>) UR) I) =\n  tree_recurse ((\\<odot>) LL) ((\\<odot>) UR) (1, 1)\n\ngoal (1 subgoal):\n 1. stern_brocot_recurse = stern_brocot_iterate", "have \"\\<dots> = ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_recurse ((\\<odot>) LL) ((\\<odot>) UR) (1, 1) = stern_brocot_recurse", "by (simp add: stern_brocot_conv recip_succ_recip times_vector_def LL_def UR_def)"], ["proof (state)\nthis:\n  tree_recurse ((\\<odot>) LL) ((\\<odot>) UR) (1, 1) = stern_brocot_recurse\n\ngoal (1 subgoal):\n 1. stern_brocot_recurse = stern_brocot_iterate", "finally"], ["proof (chain)\npicking this:\n  stern_brocot_iterate = stern_brocot_recurse", "show ?thesis"], ["proof (prove)\nusing this:\n  stern_brocot_iterate = stern_brocot_recurse\n\ngoal (1 subgoal):\n 1. stern_brocot_recurse = stern_brocot_iterate", "by simp"], ["proof (state)\nthis:\n  stern_brocot_recurse = stern_brocot_iterate\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  The following are the key ordering properties derived by \\citet{BackhouseFerreira2008MPC}.\n  They hinge on the matrices containing only natural numbers.\n\\<close>"], ["", "lemma tree_ordering_left:\n  assumes DX: \"Det X = 1\"\n  assumes DY: \"Det Y = 1\"\n  assumes MX: \"0 < snd (mediant X)\"\n  shows \"rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)", "from DX DY"], ["proof (chain)\npicking this:\n  Det X = 1\n  Det Y = 1", "have F: \"0 < snd (mediant (X \\<otimes> LL \\<otimes> Y))\""], ["proof (prove)\nusing this:\n  Det X = 1\n  Det Y = 1\n\ngoal (1 subgoal):\n 1. 0 < snd (mediant (X \\<otimes> LL \\<otimes> Y))", "by (auto simp: Det_def times_matrix_def LL_def split_def mediant_def)"], ["proof (state)\nthis:\n  0 < snd (mediant (X \\<otimes> LL \\<otimes> Y))\n\ngoal (1 subgoal):\n 1. rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)", "obtain x11 x12 x21 x22 where X: \"X = ((x11, x12), (x21, x22))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x11 x12 x21 x22.\n        X = ((x11, x12), x21, x22) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases X) auto"], ["proof (state)\nthis:\n  X = ((x11, x12), x21, x22)\n\ngoal (1 subgoal):\n 1. rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)", "obtain y11 y12 y21 y22 where Y: \"Y = ((y11, y12), (y21, y22))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y11 y12 y21 y22.\n        Y = ((y11, y12), y21, y22) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases Y) auto"], ["proof (state)\nthis:\n  Y = ((y11, y12), y21, y22)\n\ngoal (1 subgoal):\n 1. rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)", "from DX DY"], ["proof (chain)\npicking this:\n  Det X = 1\n  Det Y = 1", "have *: \"(x12 * x21) * (y12 + y22) < (x11 * x22) * (y12 + y22)\""], ["proof (prove)\nusing this:\n  Det X = 1\n  Det Y = 1\n\ngoal (1 subgoal):\n 1. x12 * x21 * (y12 + y22) < x11 * x22 * (y12 + y22)", "by(simp add: X Y Det_def)(cases y12, simp_all add: field_simps)"], ["proof (state)\nthis:\n  x12 * x21 * (y12 + y22) < x11 * x22 * (y12 + y22)\n\ngoal (1 subgoal):\n 1. rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)", "from DX DY MX F"], ["proof (chain)\npicking this:\n  Det X = 1\n  Det Y = 1\n  0 < snd (mediant X)\n  0 < snd (mediant (X \\<otimes> LL \\<otimes> Y))", "show ?thesis"], ["proof (prove)\nusing this:\n  Det X = 1\n  Det Y = 1\n  0 < snd (mediant X)\n  0 < snd (mediant (X \\<otimes> LL \\<otimes> Y))\n\ngoal (1 subgoal):\n 1. rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)", "apply (simp add: split_def X Y of_nat_mult [symmetric] del: of_nat_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Det ((x11, x12), x21, x22) = Suc 0;\n     Det ((y11, y12), y21, y22) = Suc 0;\n     0 < snd (mediant ((x11, x12), x21, x22));\n     0 < snd (mediant\n               (((x11, x12), x21, x22) \\<otimes>\n                (LL \\<otimes> ((y11, y12), y21, y22))))\\<rbrakk>\n    \\<Longrightarrow> fst (mediant\n                            (((x11, x12), x21, x22) \\<otimes>\n                             (LL \\<otimes> ((y11, y12), y21, y22)))) *\n                      snd (mediant ((x11, x12), x21, x22))\n                      < fst (mediant ((x11, x12), x21, x22)) *\n                        snd (mediant\n                              (((x11, x12), x21, x22) \\<otimes>\n                               (LL \\<otimes> ((y11, y12), y21, y22))))", "apply (clarsimp simp: Det_def times_matrix_def LL_def UR_def mediant_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x11 * x22 - x21 * x12 = Suc 0; y11 * y22 - y21 * y12 = Suc 0;\n     0 < x12 \\<or> 0 < x22;\n     0 < x12 \\<and> 0 < y11 \\<or>\n     0 < x22 \\<and> (0 < y11 \\<or> 0 < y12) \\<or>\n     0 < x12 \\<and> 0 < y21 \\<or>\n     0 < x22 \\<and> (0 < y21 \\<or> 0 < y22)\\<rbrakk>\n    \\<Longrightarrow> (x11 * y11 + x21 * (y11 + y12) +\n                       (x11 * y21 + x21 * (y21 + y22))) *\n                      (x12 + x22)\n                      < (x11 + x21) *\n                        (x12 * y11 + x22 * (y11 + y12) +\n                         (x12 * y21 + x22 * (y21 + y22)))", "using *"], ["proof (prove)\nusing this:\n  x12 * x21 * (y12 + y22) < x11 * x22 * (y12 + y22)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x11 * x22 - x21 * x12 = Suc 0; y11 * y22 - y21 * y12 = Suc 0;\n     0 < x12 \\<or> 0 < x22;\n     0 < x12 \\<and> 0 < y11 \\<or>\n     0 < x22 \\<and> (0 < y11 \\<or> 0 < y12) \\<or>\n     0 < x12 \\<and> 0 < y21 \\<or>\n     0 < x22 \\<and> (0 < y21 \\<or> 0 < y22)\\<rbrakk>\n    \\<Longrightarrow> (x11 * y11 + x21 * (y11 + y12) +\n                       (x11 * y21 + x21 * (y21 + y22))) *\n                      (x12 + x22)\n                      < (x11 + x21) *\n                        (x12 * y11 + x22 * (y11 + y12) +\n                         (x12 * y21 + x22 * (y21 + y22)))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  rat_of (mediant (X \\<otimes> LL \\<otimes> Y)) < rat_of (mediant X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_ordering_right:\n  assumes DX: \"Det X = 1\"\n  assumes DY: \"Det Y = 1\"\n  assumes MX: \"0 < snd (mediant X)\"\n  shows \"rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))", "from DX DY"], ["proof (chain)\npicking this:\n  Det X = 1\n  Det Y = 1", "have F: \"0 < snd (mediant (X \\<otimes> UR \\<otimes> Y))\""], ["proof (prove)\nusing this:\n  Det X = 1\n  Det Y = 1\n\ngoal (1 subgoal):\n 1. 0 < snd (mediant (X \\<otimes> UR \\<otimes> Y))", "by (auto simp: Det_def times_matrix_def UR_def split_def mediant_def)"], ["proof (state)\nthis:\n  0 < snd (mediant (X \\<otimes> UR \\<otimes> Y))\n\ngoal (1 subgoal):\n 1. rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))", "obtain x11 x12 x21 x22 where X: \"X = ((x11, x12), (x21, x22))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x11 x12 x21 x22.\n        X = ((x11, x12), x21, x22) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases X) auto"], ["proof (state)\nthis:\n  X = ((x11, x12), x21, x22)\n\ngoal (1 subgoal):\n 1. rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))", "obtain y11 y12 y21 y22 where Y: \"Y = ((y11, y12), (y21, y22))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y11 y12 y21 y22.\n        Y = ((y11, y12), y21, y22) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases Y) auto"], ["proof (state)\nthis:\n  Y = ((y11, y12), y21, y22)\n\ngoal (1 subgoal):\n 1. rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))", "using DX DY MX F"], ["proof (prove)\nusing this:\n  Det X = 1\n  Det Y = 1\n  0 < snd (mediant X)\n  0 < snd (mediant (X \\<otimes> UR \\<otimes> Y))\n\ngoal (1 subgoal):\n 1. rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))", "apply (simp add: X Y split_def of_nat_mult [symmetric] del: of_nat_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Det ((x11, x12), x21, x22) = Suc 0;\n     Det ((y11, y12), y21, y22) = Suc 0;\n     0 < snd (mediant ((x11, x12), x21, x22));\n     0 < snd (mediant\n               (((x11, x12), x21, x22) \\<otimes>\n                (UR \\<otimes> ((y11, y12), y21, y22))))\\<rbrakk>\n    \\<Longrightarrow> fst (mediant ((x11, x12), x21, x22)) *\n                      snd (mediant\n                            (((x11, x12), x21, x22) \\<otimes>\n                             (UR \\<otimes> ((y11, y12), y21, y22))))\n                      < fst (mediant\n                              (((x11, x12), x21, x22) \\<otimes>\n                               (UR \\<otimes> ((y11, y12), y21, y22)))) *\n                        snd (mediant ((x11, x12), x21, x22))", "apply (simp add: Det_def times_matrix_def LL_def UR_def mediant_def split_def algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x11 * x22 - x12 * x21 = Suc 0; y11 * y22 - y12 * y21 = Suc 0;\n     0 < x12 \\<or> 0 < x22;\n     0 < x12 \\<and> 0 < y11 \\<or>\n     0 < x12 \\<and> 0 < y12 \\<or>\n     0 < x12 \\<and> 0 < y21 \\<or>\n     0 < x12 \\<and> 0 < y22 \\<or>\n     0 < x22 \\<and> 0 < y12 \\<or> 0 < x22 \\<and> 0 < y22\\<rbrakk>\n    \\<Longrightarrow> x12 * (x21 * y11) + x12 * (x21 * y21)\n                      < x11 * (x22 * y11) + x11 * (x22 * y21)", "apply (simp add: add_mult_distrib2[symmetric] mult.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x11 * x22 - x12 * x21 = Suc 0; y11 * y22 - y12 * y21 = Suc 0;\n     0 < x12 \\<or> 0 < x22;\n     0 < x12 \\<and> 0 < y11 \\<or>\n     0 < x12 \\<and> 0 < y12 \\<or>\n     0 < x12 \\<and> 0 < y21 \\<or>\n     0 < x12 \\<and> 0 < y22 \\<or>\n     0 < x22 \\<and> 0 < y12 \\<or> 0 < x22 \\<and> 0 < y22\\<rbrakk>\n    \\<Longrightarrow> (0 < y11 \\<or> 0 < y21) \\<and> x12 * x21 < x11 * x22", "apply (cases y21; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rat_of (mediant X) < rat_of (mediant (X \\<otimes> UR \\<otimes> Y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stern_brocot_iterate_aux_Det:\n  assumes \"Det m = 1\" \"0 < snd (mediant m)\"\n  shows \"Det (root (traverse_tree path (stern_brocot_iterate_aux m))) = 1\"\n  and \"0 < snd (mediant (root (traverse_tree path (stern_brocot_iterate_aux m))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det (root (traverse_tree path (stern_brocot_iterate_aux m))) = 1 &&&\n    0 < snd (mediant\n              (root (traverse_tree path (stern_brocot_iterate_aux m))))", "using assms"], ["proof (prove)\nusing this:\n  Det m = 1\n  0 < snd (mediant m)\n\ngoal (1 subgoal):\n 1. Det (root (traverse_tree path (stern_brocot_iterate_aux m))) = 1 &&&\n    0 < snd (mediant\n              (root (traverse_tree path (stern_brocot_iterate_aux m))))", "by (induct path arbitrary: m)\n   (simp_all add: stern_brocot_iterate_aux_def LL_UR_Det LL_UR_pos split: dir.splits)"], ["", "lemma stern_brocot_iterate_aux_decompose:\n  \"\\<exists>m''. m \\<otimes> m'' = root (traverse_tree path (stern_brocot_iterate_aux m)) \\<and> Det m'' = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m''.\n       m \\<otimes> m'' =\n       root (traverse_tree path (stern_brocot_iterate_aux m)) \\<and>\n       Det m'' = 1", "proof(induction path arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<exists>m''.\n          m \\<otimes> m'' =\n          root (traverse_tree [] (stern_brocot_iterate_aux m)) \\<and>\n          Det m'' = 1\n 2. \\<And>a path m.\n       (\\<And>m.\n           \\<exists>m''.\n              m \\<otimes> m'' =\n              root (traverse_tree path (stern_brocot_iterate_aux m)) \\<and>\n              Det m'' = 1) \\<Longrightarrow>\n       \\<exists>m''.\n          m \\<otimes> m'' =\n          root\n           (traverse_tree (a # path) (stern_brocot_iterate_aux m)) \\<and>\n          Det m'' = 1", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<exists>m''.\n          m \\<otimes> m'' =\n          root (traverse_tree [] (stern_brocot_iterate_aux m)) \\<and>\n          Det m'' = 1\n 2. \\<And>a path m.\n       (\\<And>m.\n           \\<exists>m''.\n              m \\<otimes> m'' =\n              root (traverse_tree path (stern_brocot_iterate_aux m)) \\<and>\n              Det m'' = 1) \\<Longrightarrow>\n       \\<exists>m''.\n          m \\<otimes> m'' =\n          root\n           (traverse_tree (a # path) (stern_brocot_iterate_aux m)) \\<and>\n          Det m'' = 1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m''.\n       m \\<otimes> m'' =\n       root (traverse_tree [] (stern_brocot_iterate_aux m)) \\<and>\n       Det m'' = 1", "by (auto simp add: stern_brocot_iterate_aux_def intro: exI[where x=I] simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>m''.\n     m \\<otimes> m'' =\n     root (traverse_tree [] (stern_brocot_iterate_aux m)) \\<and>\n     Det m'' = 1\n\ngoal (1 subgoal):\n 1. \\<And>a path m.\n       (\\<And>m.\n           \\<exists>m''.\n              m \\<otimes> m'' =\n              root (traverse_tree path (stern_brocot_iterate_aux m)) \\<and>\n              Det m'' = 1) \\<Longrightarrow>\n       \\<exists>m''.\n          m \\<otimes> m'' =\n          root\n           (traverse_tree (a # path) (stern_brocot_iterate_aux m)) \\<and>\n          Det m'' = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a path m.\n       (\\<And>m.\n           \\<exists>m''.\n              m \\<otimes> m'' =\n              root (traverse_tree path (stern_brocot_iterate_aux m)) \\<and>\n              Det m'' = 1) \\<Longrightarrow>\n       \\<exists>m''.\n          m \\<otimes> m'' =\n          root\n           (traverse_tree (a # path) (stern_brocot_iterate_aux m)) \\<and>\n          Det m'' = 1", "case (Cons d ds m)"], ["proof (state)\nthis:\n  \\<exists>m''.\n     ?m \\<otimes> m'' =\n     root (traverse_tree ds (stern_brocot_iterate_aux ?m)) \\<and>\n     Det m'' = 1\n\ngoal (1 subgoal):\n 1. \\<And>a path m.\n       (\\<And>m.\n           \\<exists>m''.\n              m \\<otimes> m'' =\n              root (traverse_tree path (stern_brocot_iterate_aux m)) \\<and>\n              Det m'' = 1) \\<Longrightarrow>\n       \\<exists>m''.\n          m \\<otimes> m'' =\n          root\n           (traverse_tree (a # path) (stern_brocot_iterate_aux m)) \\<and>\n          Det m'' = 1", "from Cons.IH[where m=\"m \\<otimes> UR\"] Cons.IH[where m=\"m \\<otimes> LL\"]"], ["proof (chain)\npicking this:\n  \\<exists>m''.\n     m \\<otimes> UR \\<otimes> m'' =\n     root\n      (traverse_tree ds (stern_brocot_iterate_aux (m \\<otimes> UR))) \\<and>\n     Det m'' = 1\n  \\<exists>m''.\n     m \\<otimes> LL \\<otimes> m'' =\n     root\n      (traverse_tree ds (stern_brocot_iterate_aux (m \\<otimes> LL))) \\<and>\n     Det m'' = 1", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>m''.\n     m \\<otimes> UR \\<otimes> m'' =\n     root\n      (traverse_tree ds (stern_brocot_iterate_aux (m \\<otimes> UR))) \\<and>\n     Det m'' = 1\n  \\<exists>m''.\n     m \\<otimes> LL \\<otimes> m'' =\n     root\n      (traverse_tree ds (stern_brocot_iterate_aux (m \\<otimes> LL))) \\<and>\n     Det m'' = 1\n\ngoal (1 subgoal):\n 1. \\<exists>m''.\n       m \\<otimes> m'' =\n       root (traverse_tree (d # ds) (stern_brocot_iterate_aux m)) \\<and>\n       Det m'' = 1", "by(simp add: stern_brocot_iterate_aux_def split: dir.splits del: split_paired_Ex)(fastforce simp: LL_UR_Det)"], ["proof (state)\nthis:\n  \\<exists>m''.\n     m \\<otimes> m'' =\n     root (traverse_tree (d # ds) (stern_brocot_iterate_aux m)) \\<and>\n     Det m'' = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stern_brocot_fractions_not_repeated_strict_prefix:\n  assumes \"root (traverse_tree path stern_brocot_iterate) = root (traverse_tree path' stern_brocot_iterate)\"\n  assumes pp': \"strict_prefix path path'\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from pp'"], ["proof (chain)\npicking this:\n  strict_prefix path path'", "obtain d ds where pp': \"path' = path @ [d] @ ds\""], ["proof (prove)\nusing this:\n  strict_prefix path path'\n\ngoal (1 subgoal):\n 1. (\\<And>d ds.\n        path' = path @ [d] @ ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: strict_prefixE')"], ["proof (state)\nthis:\n  path' = path @ [d] @ ds\n\ngoal (1 subgoal):\n 1. False", "define m where \"m = root (traverse_tree path (stern_brocot_iterate_aux I))\""], ["proof (state)\nthis:\n  m = root (traverse_tree path (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  m = root (traverse_tree path (stern_brocot_iterate_aux I))", "have Dm: \"Det m = 1\" and Pm: \"0 < snd (mediant m)\""], ["proof (prove)\nusing this:\n  m = root (traverse_tree path (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. Det m = 1 &&& 0 < snd (mediant m)", "using stern_brocot_iterate_aux_Det[where path=\"path\" and m=\"I\"]"], ["proof (prove)\nusing this:\n  m = root (traverse_tree path (stern_brocot_iterate_aux I))\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> Det (root\n                          (traverse_tree path\n                            (stern_brocot_iterate_aux I))) =\n                    1\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> 0 < snd (mediant\n                              (root\n                                (traverse_tree path\n                                  (stern_brocot_iterate_aux I))))\n\ngoal (1 subgoal):\n 1. Det m = 1 &&& 0 < snd (mediant m)", "by simp_all"], ["proof (state)\nthis:\n  Det m = 1\n  0 < snd (mediant m)\n\ngoal (1 subgoal):\n 1. False", "define m' where \"m' = root (traverse_tree path' (stern_brocot_iterate_aux I))\""], ["proof (state)\nthis:\n  m' = root (traverse_tree path' (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  m' = root (traverse_tree path' (stern_brocot_iterate_aux I))", "have Dm': \"Det m' = 1\""], ["proof (prove)\nusing this:\n  m' = root (traverse_tree path' (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. Det m' = 1", "using stern_brocot_iterate_aux_Det[where path=path' and m=\"I\"]"], ["proof (prove)\nusing this:\n  m' = root (traverse_tree path' (stern_brocot_iterate_aux I))\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> Det (root\n                          (traverse_tree path'\n                            (stern_brocot_iterate_aux I))) =\n                    1\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> 0 < snd (mediant\n                              (root\n                                (traverse_tree path'\n                                  (stern_brocot_iterate_aux I))))\n\ngoal (1 subgoal):\n 1. Det m' = 1", "by simp"], ["proof (state)\nthis:\n  Det m' = 1\n\ngoal (1 subgoal):\n 1. False", "let ?M = \"case d of L \\<Rightarrow> m \\<otimes> LL | R \\<Rightarrow> m \\<otimes> UR\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from pp'"], ["proof (chain)\npicking this:\n  path' = path @ [d] @ ds", "have \"root (traverse_tree ds (stern_brocot_iterate_aux ?M)) = m'\""], ["proof (prove)\nusing this:\n  path' = path @ [d] @ ds\n\ngoal (1 subgoal):\n 1. root\n     (traverse_tree ds\n       (stern_brocot_iterate_aux\n         (case d of L \\<Rightarrow> m \\<otimes> LL\n          | R \\<Rightarrow> m \\<otimes> UR))) =\n    m'", "by(simp add: m_def m'_def stern_brocot_iterate_aux_def traverse_tree_tree_iterate split: dir.splits)"], ["proof (state)\nthis:\n  root\n   (traverse_tree ds\n     (stern_brocot_iterate_aux\n       (case d of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  m'\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  root\n   (traverse_tree ds\n     (stern_brocot_iterate_aux\n       (case d of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  m'", "obtain m'' where mm'm'': \"?M \\<otimes> m''= m'\" and Dm'': \"Det m'' = 1\""], ["proof (prove)\nusing this:\n  root\n   (traverse_tree ds\n     (stern_brocot_iterate_aux\n       (case d of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  m'\n\ngoal (1 subgoal):\n 1. (\\<And>m''.\n        \\<lbrakk>(case d of L \\<Rightarrow> m \\<otimes> LL\n                  | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n                 m'' =\n                 m';\n         Det m'' = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using stern_brocot_iterate_aux_decompose[where path=\"ds\" and m=\"?M\"]"], ["proof (prove)\nusing this:\n  root\n   (traverse_tree ds\n     (stern_brocot_iterate_aux\n       (case d of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  m'\n  \\<exists>m''.\n     (case d of L \\<Rightarrow> m \\<otimes> LL\n      | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n     m'' =\n     root\n      (traverse_tree ds\n        (stern_brocot_iterate_aux\n          (case d of L \\<Rightarrow> m \\<otimes> LL\n           | R \\<Rightarrow> m \\<otimes> UR))) \\<and>\n     Det m'' = 1\n\ngoal (1 subgoal):\n 1. (\\<And>m''.\n        \\<lbrakk>(case d of L \\<Rightarrow> m \\<otimes> LL\n                  | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n                 m'' =\n                 m';\n         Det m'' = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  (case d of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  m'' =\n  m'\n  Det m'' = 1\n\ngoal (1 subgoal):\n 1. False", "hence \"case d of L \\<Rightarrow> rat_of (mediant m') < rat_of (mediant m) | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant m')\""], ["proof (prove)\nusing this:\n  (case d of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  m'' =\n  m'\n  Det m'' = 1\n\ngoal (1 subgoal):\n 1. case d of L \\<Rightarrow> rat_of (mediant m') < rat_of (mediant m)\n    | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant m')", "using tree_ordering_left[OF Dm Dm'' Pm] tree_ordering_right[OF Dm Dm'' Pm]"], ["proof (prove)\nusing this:\n  (case d of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  m'' =\n  m'\n  Det m'' = 1\n  rat_of (mediant (m \\<otimes> LL \\<otimes> m'')) < rat_of (mediant m)\n  rat_of (mediant m) < rat_of (mediant (m \\<otimes> UR \\<otimes> m''))\n\ngoal (1 subgoal):\n 1. case d of L \\<Rightarrow> rat_of (mediant m') < rat_of (mediant m)\n    | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant m')", "by (simp split: dir.splits)"], ["proof (state)\nthis:\n  case d of L \\<Rightarrow> rat_of (mediant m') < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant m')\n\ngoal (1 subgoal):\n 1. False", "with assms"], ["proof (chain)\npicking this:\n  root (traverse_tree path stern_brocot_iterate) =\n  root (traverse_tree path' stern_brocot_iterate)\n  strict_prefix path path'\n  case d of L \\<Rightarrow> rat_of (mediant m') < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant m')", "show False"], ["proof (prove)\nusing this:\n  root (traverse_tree path stern_brocot_iterate) =\n  root (traverse_tree path' stern_brocot_iterate)\n  strict_prefix path path'\n  case d of L \\<Rightarrow> rat_of (mediant m') < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant m')\n\ngoal (1 subgoal):\n 1. False", "by (simp add: stern_brocot_iterate_def m_def m'_def split: dir.splits)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stern_brocot_fractions_not_repeated_parallel:\n  assumes \"root (traverse_tree path stern_brocot_iterate) = root (traverse_tree path' stern_brocot_iterate)\"\n  assumes p: \"path = pref @ d # ds\"\n  assumes p': \"path' = pref @ d' # ds'\"\n  assumes dd': \"d \\<noteq> d'\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define m where \"m = root (traverse_tree pref (stern_brocot_iterate_aux I))\""], ["proof (state)\nthis:\n  m = root (traverse_tree pref (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  m = root (traverse_tree pref (stern_brocot_iterate_aux I))", "have Dm: \"Det m = 1\" and Pm: \"0 < snd (mediant m)\""], ["proof (prove)\nusing this:\n  m = root (traverse_tree pref (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. Det m = 1 &&& 0 < snd (mediant m)", "using stern_brocot_iterate_aux_Det[where path=\"pref\" and m=\"I\"]"], ["proof (prove)\nusing this:\n  m = root (traverse_tree pref (stern_brocot_iterate_aux I))\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> Det (root\n                          (traverse_tree pref\n                            (stern_brocot_iterate_aux I))) =\n                    1\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> 0 < snd (mediant\n                              (root\n                                (traverse_tree pref\n                                  (stern_brocot_iterate_aux I))))\n\ngoal (1 subgoal):\n 1. Det m = 1 &&& 0 < snd (mediant m)", "by simp_all"], ["proof (state)\nthis:\n  Det m = 1\n  0 < snd (mediant m)\n\ngoal (1 subgoal):\n 1. False", "define pm where \"pm = root (traverse_tree path (stern_brocot_iterate_aux I))\""], ["proof (state)\nthis:\n  pm = root (traverse_tree path (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  pm = root (traverse_tree path (stern_brocot_iterate_aux I))", "have Dpm: \"Det pm = 1\""], ["proof (prove)\nusing this:\n  pm = root (traverse_tree path (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. Det pm = 1", "using stern_brocot_iterate_aux_Det[where path=path and m=\"I\"]"], ["proof (prove)\nusing this:\n  pm = root (traverse_tree path (stern_brocot_iterate_aux I))\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> Det (root\n                          (traverse_tree path\n                            (stern_brocot_iterate_aux I))) =\n                    1\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> 0 < snd (mediant\n                              (root\n                                (traverse_tree path\n                                  (stern_brocot_iterate_aux I))))\n\ngoal (1 subgoal):\n 1. Det pm = 1", "by simp"], ["proof (state)\nthis:\n  Det pm = 1\n\ngoal (1 subgoal):\n 1. False", "let ?M = \"case d of L \\<Rightarrow> m \\<otimes> LL | R \\<Rightarrow> m \\<otimes> UR\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from p"], ["proof (chain)\npicking this:\n  path = pref @ d # ds", "have \"root (traverse_tree ds (stern_brocot_iterate_aux ?M)) = pm\""], ["proof (prove)\nusing this:\n  path = pref @ d # ds\n\ngoal (1 subgoal):\n 1. root\n     (traverse_tree ds\n       (stern_brocot_iterate_aux\n         (case d of L \\<Rightarrow> m \\<otimes> LL\n          | R \\<Rightarrow> m \\<otimes> UR))) =\n    pm", "by(simp add: stern_brocot_iterate_aux_def m_def pm_def traverse_tree_tree_iterate split: dir.splits)"], ["proof (state)\nthis:\n  root\n   (traverse_tree ds\n     (stern_brocot_iterate_aux\n       (case d of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  pm\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  root\n   (traverse_tree ds\n     (stern_brocot_iterate_aux\n       (case d of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  pm", "obtain pm'\n    where pm': \"?M \\<otimes> pm'= pm\" and Dpm': \"Det pm' = 1\""], ["proof (prove)\nusing this:\n  root\n   (traverse_tree ds\n     (stern_brocot_iterate_aux\n       (case d of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  pm\n\ngoal (1 subgoal):\n 1. (\\<And>pm'.\n        \\<lbrakk>(case d of L \\<Rightarrow> m \\<otimes> LL\n                  | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n                 pm' =\n                 pm;\n         Det pm' = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using stern_brocot_iterate_aux_decompose[where path=\"ds\" and m=\"?M\"]"], ["proof (prove)\nusing this:\n  root\n   (traverse_tree ds\n     (stern_brocot_iterate_aux\n       (case d of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  pm\n  \\<exists>m''.\n     (case d of L \\<Rightarrow> m \\<otimes> LL\n      | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n     m'' =\n     root\n      (traverse_tree ds\n        (stern_brocot_iterate_aux\n          (case d of L \\<Rightarrow> m \\<otimes> LL\n           | R \\<Rightarrow> m \\<otimes> UR))) \\<and>\n     Det m'' = 1\n\ngoal (1 subgoal):\n 1. (\\<And>pm'.\n        \\<lbrakk>(case d of L \\<Rightarrow> m \\<otimes> LL\n                  | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n                 pm' =\n                 pm;\n         Det pm' = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  (case d of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  pm' =\n  pm\n  Det pm' = 1\n\ngoal (1 subgoal):\n 1. False", "hence \"case d of L \\<Rightarrow> rat_of (mediant pm) < rat_of (mediant m) | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant pm)\""], ["proof (prove)\nusing this:\n  (case d of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  pm' =\n  pm\n  Det pm' = 1\n\ngoal (1 subgoal):\n 1. case d of L \\<Rightarrow> rat_of (mediant pm) < rat_of (mediant m)\n    | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant pm)", "using tree_ordering_left[OF Dm Dpm' Pm, unfolded pm']\n          tree_ordering_right[OF Dm Dpm' Pm, unfolded pm']"], ["proof (prove)\nusing this:\n  (case d of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  pm' =\n  pm\n  Det pm' = 1\n  rat_of (mediant (m \\<otimes> LL \\<otimes> pm')) < rat_of (mediant m)\n  rat_of (mediant m) < rat_of (mediant (m \\<otimes> UR \\<otimes> pm'))\n\ngoal (1 subgoal):\n 1. case d of L \\<Rightarrow> rat_of (mediant pm) < rat_of (mediant m)\n    | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant pm)", "by (simp split: dir.splits)"], ["proof (state)\nthis:\n  case d of L \\<Rightarrow> rat_of (mediant pm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant pm)\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  case d of L \\<Rightarrow> rat_of (mediant pm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant pm)\n\ngoal (1 subgoal):\n 1. False", "define p'm where \"p'm = root (traverse_tree path' (stern_brocot_iterate_aux I))\""], ["proof (state)\nthis:\n  p'm = root (traverse_tree path' (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  p'm = root (traverse_tree path' (stern_brocot_iterate_aux I))", "have Dp'm: \"Det p'm = 1\""], ["proof (prove)\nusing this:\n  p'm = root (traverse_tree path' (stern_brocot_iterate_aux I))\n\ngoal (1 subgoal):\n 1. Det p'm = 1", "using stern_brocot_iterate_aux_Det[where path=path' and m=\"I\"]"], ["proof (prove)\nusing this:\n  p'm = root (traverse_tree path' (stern_brocot_iterate_aux I))\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> Det (root\n                          (traverse_tree path'\n                            (stern_brocot_iterate_aux I))) =\n                    1\n  \\<lbrakk>Det I = 1; 0 < snd (mediant I)\\<rbrakk>\n  \\<Longrightarrow> 0 < snd (mediant\n                              (root\n                                (traverse_tree path'\n                                  (stern_brocot_iterate_aux I))))\n\ngoal (1 subgoal):\n 1. Det p'm = 1", "by simp"], ["proof (state)\nthis:\n  Det p'm = 1\n\ngoal (1 subgoal):\n 1. False", "let ?M' = \"case d' of L \\<Rightarrow> m \\<otimes> LL | R \\<Rightarrow> m \\<otimes> UR\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from p'"], ["proof (chain)\npicking this:\n  path' = pref @ d' # ds'", "have \"root (traverse_tree ds' (stern_brocot_iterate_aux ?M')) = p'm\""], ["proof (prove)\nusing this:\n  path' = pref @ d' # ds'\n\ngoal (1 subgoal):\n 1. root\n     (traverse_tree ds'\n       (stern_brocot_iterate_aux\n         (case d' of L \\<Rightarrow> m \\<otimes> LL\n          | R \\<Rightarrow> m \\<otimes> UR))) =\n    p'm", "by(simp add: stern_brocot_iterate_aux_def m_def p'm_def traverse_tree_tree_iterate split: dir.splits)"], ["proof (state)\nthis:\n  root\n   (traverse_tree ds'\n     (stern_brocot_iterate_aux\n       (case d' of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  p'm\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  root\n   (traverse_tree ds'\n     (stern_brocot_iterate_aux\n       (case d' of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  p'm", "obtain p'm'\n    where p'm': \"?M' \\<otimes> p'm' = p'm\" and Dp'm': \"Det p'm' = 1\""], ["proof (prove)\nusing this:\n  root\n   (traverse_tree ds'\n     (stern_brocot_iterate_aux\n       (case d' of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  p'm\n\ngoal (1 subgoal):\n 1. (\\<And>p'm'.\n        \\<lbrakk>(case d' of L \\<Rightarrow> m \\<otimes> LL\n                  | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n                 p'm' =\n                 p'm;\n         Det p'm' = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using stern_brocot_iterate_aux_decompose[where path=\"ds'\" and m=\"?M'\"]"], ["proof (prove)\nusing this:\n  root\n   (traverse_tree ds'\n     (stern_brocot_iterate_aux\n       (case d' of L \\<Rightarrow> m \\<otimes> LL\n        | R \\<Rightarrow> m \\<otimes> UR))) =\n  p'm\n  \\<exists>m''.\n     (case d' of L \\<Rightarrow> m \\<otimes> LL\n      | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n     m'' =\n     root\n      (traverse_tree ds'\n        (stern_brocot_iterate_aux\n          (case d' of L \\<Rightarrow> m \\<otimes> LL\n           | R \\<Rightarrow> m \\<otimes> UR))) \\<and>\n     Det m'' = 1\n\ngoal (1 subgoal):\n 1. (\\<And>p'm'.\n        \\<lbrakk>(case d' of L \\<Rightarrow> m \\<otimes> LL\n                  | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n                 p'm' =\n                 p'm;\n         Det p'm' = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  (case d' of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  p'm' =\n  p'm\n  Det p'm' = 1\n\ngoal (1 subgoal):\n 1. False", "hence \"case d' of L \\<Rightarrow> rat_of (mediant p'm) < rat_of (mediant m) | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant p'm)\""], ["proof (prove)\nusing this:\n  (case d' of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  p'm' =\n  p'm\n  Det p'm' = 1\n\ngoal (1 subgoal):\n 1. case d' of L \\<Rightarrow> rat_of (mediant p'm) < rat_of (mediant m)\n    | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant p'm)", "using tree_ordering_left[OF Dm Dp'm' Pm, unfolded pm']\n          tree_ordering_right[OF Dm Dp'm' Pm, unfolded pm']"], ["proof (prove)\nusing this:\n  (case d' of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  p'm' =\n  p'm\n  Det p'm' = 1\n  rat_of (mediant (m \\<otimes> LL \\<otimes> p'm')) < rat_of (mediant m)\n  rat_of (mediant m) < rat_of (mediant (m \\<otimes> UR \\<otimes> p'm'))\n\ngoal (1 subgoal):\n 1. case d' of L \\<Rightarrow> rat_of (mediant p'm) < rat_of (mediant m)\n    | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant p'm)", "by (simp split: dir.splits)"], ["proof (state)\nthis:\n  case d' of L \\<Rightarrow> rat_of (mediant p'm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant p'm)\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  case d of L \\<Rightarrow> rat_of (mediant pm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant pm)\n  case d' of L \\<Rightarrow> rat_of (mediant p'm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant p'm)", "show False"], ["proof (prove)\nusing this:\n  case d of L \\<Rightarrow> rat_of (mediant pm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant pm)\n  case d' of L \\<Rightarrow> rat_of (mediant p'm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant p'm)\n\ngoal (1 subgoal):\n 1. False", "using pm' p'm' assms"], ["proof (prove)\nusing this:\n  case d of L \\<Rightarrow> rat_of (mediant pm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant pm)\n  case d' of L \\<Rightarrow> rat_of (mediant p'm) < rat_of (mediant m)\n  | R \\<Rightarrow> rat_of (mediant m) < rat_of (mediant p'm)\n  (case d of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  pm' =\n  pm\n  (case d' of L \\<Rightarrow> m \\<otimes> LL\n   | R \\<Rightarrow> m \\<otimes> UR) \\<otimes>\n  p'm' =\n  p'm\n  root (traverse_tree path stern_brocot_iterate) =\n  root (traverse_tree path' stern_brocot_iterate)\n  path = pref @ d # ds\n  path' = pref @ d' # ds'\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. False", "by(simp add: m_def pm_def p'm_def stern_brocot_iterate_def split: dir.splits)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lists_not_eq:\n  assumes \"xs \\<noteq> ys\"\n  obtains\n    (c1) \"strict_prefix xs ys\"\n  | (c2) \"strict_prefix ys xs\"\n  | (c3) ps x y xs' ys'\n          where \"xs = ps @ x # xs'\" and \"ys = ps @ y # ys'\" and \"x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_prefix xs ys \\<Longrightarrow> thesis;\n     strict_prefix ys xs \\<Longrightarrow> thesis;\n     \\<And>ps x xs' y ys'.\n        \\<lbrakk>xs = ps @ x # xs'; ys = ps @ y # ys'; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_prefix xs ys \\<Longrightarrow> thesis;\n     strict_prefix ys xs \\<Longrightarrow> thesis;\n     \\<And>ps x xs' y ys'.\n        \\<lbrakk>xs = ps @ x # xs'; ys = ps @ y # ys'; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases xs ys rule: prefix_cases)\n   (blast dest: parallel_decomp prefix_order.neq_le_trans)+"], ["", "lemma stern_brocot_fractions_not_repeated:\n  assumes \"root (traverse_tree path stern_brocot_iterate) = root (traverse_tree path' stern_brocot_iterate)\"\n  shows \"path = path'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path = path'", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. path \\<noteq> path' \\<Longrightarrow> False", "assume \"path \\<noteq> path'\""], ["proof (state)\nthis:\n  path \\<noteq> path'\n\ngoal (1 subgoal):\n 1. path \\<noteq> path' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path \\<noteq> path'", "show False"], ["proof (prove)\nusing this:\n  path \\<noteq> path'\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  path \\<noteq> path'\n  root (traverse_tree path stern_brocot_iterate) =\n  root (traverse_tree path' stern_brocot_iterate)\n\ngoal (1 subgoal):\n 1. False", "by (cases path path' rule: lists_not_eq)\n       (blast intro: stern_brocot_fractions_not_repeated_strict_prefix sym\n                     stern_brocot_fractions_not_repeated_parallel)+"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> The function @{const Fract} is injective under certain conditions. \\<close>"], ["", "lemma rat_inv_eq:\n  assumes \"Fract a b = Fract c d\"\n  assumes \"b > 0\"\n  assumes \"d > 0\"\n  assumes \"coprime a b\"\n  assumes \"coprime c d\"\n  shows \"a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "from \\<open>b > 0\\<close> \\<open>d > 0\\<close> \\<open>Fract a b = Fract c d\\<close>"], ["proof (chain)\npicking this:\n  0 < b\n  0 < d\n  Fract a b = Fract c d", "have *: \"a * d = c * b\""], ["proof (prove)\nusing this:\n  0 < b\n  0 < d\n  Fract a b = Fract c d\n\ngoal (1 subgoal):\n 1. a * d = c * b", "by (simp add: eq_rat)"], ["proof (state)\nthis:\n  a * d = c * b\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "from arg_cong[where f=sgn, OF this] \\<open>b > 0\\<close> \\<open>d > 0\\<close>"], ["proof (chain)\npicking this:\n  sgn (a * d) = sgn (c * b)\n  0 < b\n  0 < d", "have \"sgn a = sgn c\""], ["proof (prove)\nusing this:\n  sgn (a * d) = sgn (c * b)\n  0 < b\n  0 < d\n\ngoal (1 subgoal):\n 1. sgn a = sgn c", "by (simp add: sgn_mult)"], ["proof (state)\nthis:\n  sgn a = sgn c\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "with *"], ["proof (chain)\npicking this:\n  a * d = c * b\n  sgn a = sgn c", "show ?thesis"], ["proof (prove)\nusing this:\n  a * d = c * b\n  sgn a = sgn c\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "using \\<open>b > 0\\<close> \\<open>d > 0\\<close> coprime_crossproduct_int[OF \\<open>coprime a b\\<close> \\<open>coprime c d\\<close>]"], ["proof (prove)\nusing this:\n  a * d = c * b\n  sgn a = sgn c\n  0 < b\n  0 < d\n  (\\<bar>a\\<bar> * \\<bar>d\\<bar> = \\<bar>c\\<bar> * \\<bar>b\\<bar>) =\n  (\\<bar>a\\<bar> = \\<bar>c\\<bar> \\<and> \\<bar>d\\<bar> = \\<bar>b\\<bar>)\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "by (simp add: abs_sgn)"], ["proof (state)\nthis:\n  a = c \\<and> b = d\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem stern_brocot_rationals_not_repeated:\n  assumes \"root (traverse_tree path (pure rat_of \\<diamondop> stern_brocot_recurse))\n         = root (traverse_tree path' (pure rat_of \\<diamondop> stern_brocot_recurse))\"\n  shows \"path = path'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path = path'", "using assms"], ["proof (prove)\nusing this:\n  root\n   (traverse_tree path (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n  root (traverse_tree path' (pure rat_of \\<diamondop> stern_brocot_recurse))\n\ngoal (1 subgoal):\n 1. path = path'", "using stern_brocot_coprime[where path=path]\n      stern_brocot_coprime[where path=path']\n      stern_brocot_denominator_non_zero[where path=path]\n      stern_brocot_denominator_non_zero[where path=path']"], ["proof (prove)\nusing this:\n  root\n   (traverse_tree path (pure rat_of \\<diamondop> stern_brocot_recurse)) =\n  root (traverse_tree path' (pure rat_of \\<diamondop> stern_brocot_recurse))\n  case root (traverse_tree path stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> coprime m n\n  case root (traverse_tree path' stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> coprime m n\n  case root (traverse_tree path stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n\n  case root (traverse_tree path' stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n\n\ngoal (1 subgoal):\n 1. path = path'", "by(auto simp: gcd_int_def dest!: rat_inv_eq intro: stern_brocot_fractions_not_repeated simp add: stern_brocot_recurse_iterate[symmetric] split: prod.splits)"], ["", "subsection \\<open>Equivalence of recursive and iterative version \\label{section:eq:rec:iterative}\\<close>"], ["", "text \\<open>\n  \\citeauthor{Hinze2009JFP} shows that it does not matter whether we use @{const I} or\n  @{const \"F\"} at the root provided we swap the left and right matrices too.\n\\<close>"], ["", "definition stern_brocot_Hinze_iterate :: \"fraction tree\"\nwhere \"stern_brocot_Hinze_iterate = map_tree mediant (tree_iterate (\\<lambda>s. s \\<otimes> UR) (\\<lambda>s. s \\<otimes> LL) F)\""], ["", "lemma mediant_times_F: \"mediant \\<circ> (\\<lambda>s. s \\<otimes> F) = mediant\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mediant \\<circ> (\\<lambda>s. s \\<otimes> F) = mediant", "by(simp add: times_matrix_def F_def mediant_def split_def o_def add.commute)"], ["", "lemma stern_brocot_iterate: \"stern_brocot = stern_brocot_iterate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_iterate", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_iterate", "have \"stern_brocot = stern_brocot_Hinze_iterate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_Hinze_iterate", "unfolding stern_brocot_def stern_brocot_Hinze_iterate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_tree (\\<lambda>(lb, ub). mediant (lb, ub))\n     (\\<lambda>(lb, ub). (lb, mediant (lb, ub)))\n     (\\<lambda>(lb, ub). (mediant (lb, ub), ub)) ((0, 1), 1, 0) =\n    map_tree mediant\n     (tree_iterate (\\<lambda>s. s \\<otimes> UR) (\\<lambda>s. s \\<otimes> LL)\n       F)", "by(subst unfold_tree_tree_iterate)(simp add: F_def times_matrix_def mediant_def UR_def LL_def split_def)"], ["proof (state)\nthis:\n  stern_brocot = stern_brocot_Hinze_iterate\n\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_iterate", "also"], ["proof (state)\nthis:\n  stern_brocot = stern_brocot_Hinze_iterate\n\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_iterate", "have \"\\<dots> = map_tree mediant (map_tree (\\<lambda>s. s \\<otimes> F) (tree_iterate (\\<lambda>s. s \\<otimes> LL) (\\<lambda>s. s \\<otimes> UR) I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot_Hinze_iterate =\n    map_tree mediant\n     (map_tree (\\<lambda>s. s \\<otimes> F)\n       (tree_iterate (\\<lambda>s. s \\<otimes> LL)\n         (\\<lambda>s. s \\<otimes> UR) I))", "unfolding stern_brocot_Hinze_iterate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree mediant\n     (tree_iterate (\\<lambda>s. s \\<otimes> UR) (\\<lambda>s. s \\<otimes> LL)\n       F) =\n    map_tree mediant\n     (map_tree (\\<lambda>s. s \\<otimes> F)\n       (tree_iterate (\\<lambda>s. s \\<otimes> LL)\n         (\\<lambda>s. s \\<otimes> UR) I))", "by(subst tree_iterate_fusion[where l'=\"\\<lambda>s. s \\<otimes> UR\" and r'=\"\\<lambda>s. s \\<otimes> LL\"])\n      (simp_all add: fun_eq_iff times_matrix_def UR_def LL_def F_def I_def)"], ["proof (state)\nthis:\n  stern_brocot_Hinze_iterate =\n  map_tree mediant\n   (map_tree (\\<lambda>s. s \\<otimes> F)\n     (tree_iterate (\\<lambda>s. s \\<otimes> LL) (\\<lambda>s. s \\<otimes> UR)\n       I))\n\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_iterate", "also"], ["proof (state)\nthis:\n  stern_brocot_Hinze_iterate =\n  map_tree mediant\n   (map_tree (\\<lambda>s. s \\<otimes> F)\n     (tree_iterate (\\<lambda>s. s \\<otimes> LL) (\\<lambda>s. s \\<otimes> UR)\n       I))\n\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_iterate", "have \"\\<dots> = stern_brocot_iterate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree mediant\n     (map_tree (\\<lambda>s. s \\<otimes> F)\n       (tree_iterate (\\<lambda>s. s \\<otimes> LL)\n         (\\<lambda>s. s \\<otimes> UR) I)) =\n    stern_brocot_iterate", "by(simp only: tree.map_comp mediant_times_F stern_brocot_iterate_def stern_brocot_iterate_aux_def)"], ["proof (state)\nthis:\n  map_tree mediant\n   (map_tree (\\<lambda>s. s \\<otimes> F)\n     (tree_iterate (\\<lambda>s. s \\<otimes> LL) (\\<lambda>s. s \\<otimes> UR)\n       I)) =\n  stern_brocot_iterate\n\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_iterate", "finally"], ["proof (chain)\npicking this:\n  stern_brocot = stern_brocot_iterate", "show ?thesis"], ["proof (prove)\nusing this:\n  stern_brocot = stern_brocot_iterate\n\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_iterate", "."], ["proof (state)\nthis:\n  stern_brocot = stern_brocot_iterate\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem stern_brocot_mediant_recurse: \"stern_brocot = stern_brocot_recurse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot = stern_brocot_recurse", "by(simp add: stern_brocot_recurse_iterate stern_brocot_iterate)"], ["", "end"], ["", "no_notation times_matrix (infixl \"\\<otimes>\" 70)\n  and times_vector (infixl \"\\<odot>\" 70)"], ["", "section \\<open>Linearising the Stern-Brocot Tree\\<close>"], ["", "subsection \\<open>Turning a tree into a stream\\<close>"], ["", "corec tree_chop :: \"'a tree \\<Rightarrow> 'a tree\"\nwhere \"tree_chop t = Node (root (left t)) (right t) (tree_chop (left t))\""], ["", "lemma tree_chop_sel [simp]:\n  \"root (tree_chop t) = root (left t)\"\n  \"left (tree_chop t) = right t\"\n  \"right (tree_chop t) = tree_chop (left t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (tree_chop t) = root (left t) &&&\n    left (tree_chop t) = right t &&&\n    right (tree_chop t) = tree_chop (left t)", "by(subst tree_chop.code; simp; fail)+"], ["", "text \\<open>@{const tree_chop} is a idiom homomorphism\\<close>"], ["", "lemma tree_chop_pure_tree [simp]:\n  \"tree_chop (pure x) = pure x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_chop (pure x) = pure x", "by(coinduction rule: tree.coinduct_strong) auto"], ["", "lemma tree_chop_ap_tree [simp]:\n  \"tree_chop (f \\<diamondop> x) = tree_chop f \\<diamondop> tree_chop x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_chop (f \\<diamondop> x) = tree_chop f \\<diamondop> tree_chop x", "by(coinduction arbitrary: f x rule: tree.coinduct_strong) auto"], ["", "lemma tree_chop_plus: \"tree_chop (t + t') = tree_chop t + tree_chop t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_chop (t + t') = tree_chop t + tree_chop t'", "by(simp add: plus_tree_def)"], ["", "corec stream :: \"'a tree \\<Rightarrow> 'a stream\"\nwhere \"stream t = root t ## stream (tree_chop t)\""], ["", "lemma stream_sel [simp]:\n  \"shd (stream t) = root t\"\n  \"stl (stream t) = stream (tree_chop t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (stream t) = root t &&& stl (stream t) = stream (tree_chop t)", "by(subst stream.code; simp; fail)+"], ["", "text\\<open>@{const \"stream\"} is an idiom homomorphism.\\<close>"], ["", "lemma stream_pure [simp]: \"stream (pure x) = pure x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream (pure x) = pure x", "by coinduction auto"], ["", "lemma stream_ap [simp]: \"stream (f \\<diamondop> x) = stream f \\<diamondop> stream x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream (f \\<diamondop> x) = stream f \\<diamondop> stream x", "by(coinduction arbitrary: f x) auto"], ["", "lemma stream_plus [simp]: \"stream (t + t') = stream t + stream t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream (t + t') = stream t + stream t'", "by(simp add: plus_stream_def plus_tree_def)"], ["", "lemma stream_minus [simp]: \"stream (t - t') = stream t - stream t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream (t - t') = stream t - stream t'", "by(simp add: minus_stream_def minus_tree_def)"], ["", "lemma stream_times [simp]: \"stream (t * t') = stream t * stream t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream (t * t') = stream t * stream t'", "by(simp add: times_stream_def times_tree_def)"], ["", "lemma stream_mod [simp]: \"stream (t mod t') = stream t mod stream t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream (t mod t') = stream t mod stream t'", "by(simp add: modulo_stream_def modulo_tree_def)"], ["", "lemma stream_1 [simp]: \"stream 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream 1 = 1", "by(simp add: one_tree_def one_stream_def)"], ["", "lemma stream_numeral [simp]: \"stream (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream (numeral n) = numeral n", "by(induct n)(simp_all only: numeral.simps stream_plus stream_1)"], ["", "subsection \\<open>Split the Stern-Brocot tree into numerators and denumerators\\<close>"], ["", "corec num_den :: \"bool \\<Rightarrow> nat tree\"\nwhere\n  \"num_den x =\n   Node 1\n     (if x then num_den True else num_den True + num_den False)\n     (if x then num_den True + num_den False else num_den False)\""], ["", "abbreviation num where \"num \\<equiv> num_den True\""], ["", "abbreviation den where \"den \\<equiv> num_den False\""], ["", "lemma num_unfold: \"num = Node 1 num (num + den)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num = Node 1 num (num + den)", "by(subst num_den.code; simp)"], ["", "lemma den_unfold: \"den = Node 1 (num + den) den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. den = Node 1 (num + den) den", "by(subst num_den.code; simp)"], ["", "lemma num_simps [simp]:\n  \"root num = 1\"\n  \"left num = num\"\n  \"right num = num + den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root num = 1 &&& left num = num &&& right num = num + den", "by(subst num_unfold, simp)+"], ["", "lemma den_simps [simp]:\n  \"root den = 1\"\n  \"left den = num + den\"\n  \"right den = den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root den = 1 &&& left den = num + den &&& right den = den", "by (subst den_unfold, simp)+"], ["", "lemma stern_brocot_num_den:\n  \"pure_tree Pair \\<diamondop> num \\<diamondop> den = stern_brocot_recurse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Pair \\<diamondop> num \\<diamondop> den = stern_brocot_recurse", "apply(rule stern_brocot_recurse.unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Pair \\<diamondop> num \\<diamondop> den =\n    Node (1, 1)\n     (map_tree recip\n       (map_tree succ\n         (map_tree recip (pure Pair \\<diamondop> num \\<diamondop> den))))\n     (map_tree succ (pure Pair \\<diamondop> num \\<diamondop> den))", "apply(subst den_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Pair \\<diamondop> num \\<diamondop> Node 1 (num + den) den =\n    Node (1, 1)\n     (map_tree recip\n       (map_tree succ\n         (map_tree recip (pure Pair \\<diamondop> num \\<diamondop> den))))\n     (map_tree succ (pure Pair \\<diamondop> num \\<diamondop> den))", "apply(subst num_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Pair \\<diamondop> Node 1 num (num + den) \\<diamondop>\n    Node 1 (num + den) den =\n    Node (1, 1)\n     (map_tree recip\n       (map_tree succ\n         (map_tree recip (pure Pair \\<diamondop> num \\<diamondop> den))))\n     (map_tree succ (pure Pair \\<diamondop> num \\<diamondop> den))", "apply(simp; intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pure Pair \\<diamondop> num \\<diamondop> (num + den) =\n    map_tree (recip \\<circ> (succ \\<circ> recip))\n     (pure Pair \\<diamondop> num \\<diamondop> den)\n 2. pure Pair \\<diamondop> (num + den) \\<diamondop> den =\n    map_tree succ (pure Pair \\<diamondop> num \\<diamondop> den)", "apply(applicative_lifting; simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma den_eq_chop_num: \"den = tree_chop num\""], ["proof (prove)\ngoal (1 subgoal):\n 1. den = tree_chop num", "by(coinduction rule: tree.coinduct_strong) simp"], ["", "lemma num_conv: \"num = pure fst \\<diamondop> stern_brocot_recurse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num = pure fst \\<diamondop> stern_brocot_recurse", "unfolding stern_brocot_num_den[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. num =\n    pure fst \\<diamondop> (pure Pair \\<diamondop> num \\<diamondop> den)", "apply(simp add: map_tree_ap_tree_pure_tree stern_brocot_num_den[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. num = map_tree fst (map_tree Pair num \\<diamondop> den)", "apply(applicative_lifting; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma den_conv: \"den = pure snd \\<diamondop> stern_brocot_recurse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. den = pure snd \\<diamondop> stern_brocot_recurse", "unfolding stern_brocot_num_den[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. den =\n    pure snd \\<diamondop> (pure Pair \\<diamondop> num \\<diamondop> den)", "apply(simp add: map_tree_ap_tree_pure_tree stern_brocot_num_den[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. den = map_tree snd (map_tree Pair num \\<diamondop> den)", "apply(applicative_lifting; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corec num_mod_den :: \"nat tree\"\nwhere \"num_mod_den = Node 0 num num_mod_den\""], ["", "lemma num_mod_den_simps [simp]:\n  \"root num_mod_den = 0\"\n  \"left num_mod_den = num\"\n  \"right num_mod_den = num_mod_den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root num_mod_den = 0 &&&\n    left num_mod_den = num &&& right num_mod_den = num_mod_den", "by(subst num_mod_den.code; simp; fail)+"], ["", "text\\<open>\n  The arithmetic transformations need the precondition that @{const den} contains only\n  positive numbers, no @{term \"0 :: nat\"}. \\citet[p502]{Hinze2009JFP} gets a bit sloppy here; it is\n  not straightforward to adapt his lifting framework \\cite{Hinze2010Lifting} to conditional equations.\n\\<close>"], ["", "lemma mod_tree_lemma1:\n  fixes x :: \"nat tree\"\n  assumes \"\\<forall>i\\<in>set_tree y. 0 < i\"\n  shows \"x mod (x + y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod (x + y) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x mod (x + y) = x", "have \"rel_tree (=) (x mod (x + y)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_tree (=) (x mod (x + y)) x", "by applicative_lifting(simp add: assms)"], ["proof (state)\nthis:\n  rel_tree (=) (x mod (x + y)) x\n\ngoal (1 subgoal):\n 1. x mod (x + y) = x", "thus ?thesis"], ["proof (prove)\nusing this:\n  rel_tree (=) (x mod (x + y)) x\n\ngoal (1 subgoal):\n 1. x mod (x + y) = x", "by(unfold tree.rel_eq)"], ["proof (state)\nthis:\n  x mod (x + y) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_tree_lemma2:\n  fixes x y :: \"'a :: unique_euclidean_semiring tree\"\n  shows \"(x + y) mod y = x mod y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) mod y = x mod y", "by applicative_lifting simp"], ["", "lemma set_tree_pathD: \"x \\<in> set_tree t \\<Longrightarrow> \\<exists>p. x = root (traverse_tree p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_tree t \\<Longrightarrow>\n    \\<exists>p. x = root (traverse_tree p t)", "by(induct rule: set_tree_induct)(auto intro: exI[where x=\"[]\"] exI[where x=\"L # p\" for p] exI[where x=\"R # p\" for p])"], ["", "lemma den_gt_0: \"0 < x\" if \"x \\<in> set_tree den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < x", "from that"], ["proof (chain)\npicking this:\n  x \\<in> set_tree den", "obtain p where \"x = root (traverse_tree p den)\""], ["proof (prove)\nusing this:\n  x \\<in> set_tree den\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        x = root (traverse_tree p den) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: set_tree_pathD)"], ["proof (state)\nthis:\n  x = root (traverse_tree p den)\n\ngoal (1 subgoal):\n 1. 0 < x", "with stern_brocot_denominator_non_zero[of p]"], ["proof (chain)\npicking this:\n  case root (traverse_tree p stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n\n  x = root (traverse_tree p den)", "show \"0 < x\""], ["proof (prove)\nusing this:\n  case root (traverse_tree p stern_brocot_recurse) of\n  (m, n) \\<Rightarrow> 0 < m \\<and> 0 < n\n  x = root (traverse_tree p den)\n\ngoal (1 subgoal):\n 1. 0 < x", "by(simp add: den_conv split_beta)"], ["proof (state)\nthis:\n  0 < x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma num_mod_den: \"num mod den = num_mod_den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num mod den = num_mod_den", "by(rule num_mod_den.unique)(rule tree.expand, simp add: mod_tree_lemma2 mod_tree_lemma1 den_gt_0)"], ["", "lemma tree_chop_den: \"tree_chop den = num + den - 2 * (num mod den)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have le: \"0 < y \\<Longrightarrow> 2 * (x mod y) \\<le> x + y\" for x y :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> 2 * (x mod y) \\<le> x + y", "by (simp add: mult_2 add_mono)"], ["proof (state)\nthis:\n  0 < ?y \\<Longrightarrow> 2 * (?x mod ?y) \\<le> ?x + ?y\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "text \\<open>We switch to @{typ int} such that all cancellation laws are available.\\<close>"], ["proof (state)\nthis:\n  0 < ?y \\<Longrightarrow> 2 * (?x mod ?y) \\<le> ?x + ?y\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "define den' where \"den' = pure int \\<diamondop> den\""], ["proof (state)\nthis:\n  den' = pure int \\<diamondop> den\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "define num' where \"num' = pure int \\<diamondop> num\""], ["proof (state)\nthis:\n  num' = pure int \\<diamondop> num\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "define num_mod_den' where \"num_mod_den' = pure int \\<diamondop> num_mod_den\""], ["proof (state)\nthis:\n  num_mod_den' = pure int \\<diamondop> num_mod_den\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have [simp]: \"root num' = 1\" \"left num' = num'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root num' = 1 &&& left num' = num'", "unfolding den'_def num'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root (pure int \\<diamondop> num) = 1 &&&\n    left (pure int \\<diamondop> num) = pure int \\<diamondop> num", "by simp_all"], ["proof (state)\nthis:\n  root num' = 1\n  left num' = num'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have [simp]: \"right num' = num' + den'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right num' = num' + den'", "unfolding den'_def num'_def ap_tree.sel pure_tree_simps num_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure int \\<diamondop> (num + den) =\n    pure int \\<diamondop> num + pure int \\<diamondop> den", "by applicative_lifting simp"], ["proof (state)\nthis:\n  right num' = num' + den'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have num_mod_den'_simps [simp]: \"root num_mod_den' = 0\" \"left num_mod_den' = num'\" \"right num_mod_den' = num_mod_den'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root num_mod_den' = 0 &&&\n    left num_mod_den' = num' &&& right num_mod_den' = num_mod_den'", "by(simp_all add: num_mod_den'_def num'_def)"], ["proof (state)\nthis:\n  root num_mod_den' = 0\n  left num_mod_den' = num'\n  right num_mod_den' = num_mod_den'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have den'_eq_chop_num': \"den' = tree_chop num'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. den' = tree_chop num'", "by(simp add: den'_def num'_def den_eq_chop_num)"], ["proof (state)\nthis:\n  den' = tree_chop num'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have num_mod_den'2_unique: \"\\<And>x. x = Node 0 (2 * num') x \\<Longrightarrow> x = 2 * num_mod_den'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x = Node 0 (2 * num') x \\<Longrightarrow> x = 2 * num_mod_den'", "by(corec_unique)(rule tree.expand; simp)"], ["proof (state)\nthis:\n  ?x = Node 0 (2 * num') ?x \\<Longrightarrow> ?x = 2 * num_mod_den'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have num'_plus_den'_minus_chop_den': \"num' + den' - tree_chop den' = 2 * num_mod_den'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num' + den' - tree_chop den' = 2 * num_mod_den'", "by(rule num_mod_den'2_unique)(rule tree.expand, simp add: tree_chop_plus den'_eq_chop_num')"], ["proof (state)\nthis:\n  num' + den' - tree_chop den' = 2 * num_mod_den'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have \"tree_chop den = pure nat \\<diamondop> (tree_chop den')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_chop den = pure nat \\<diamondop> tree_chop den'", "unfolding den_conv tree_chop_ap_tree tree_chop_pure_tree den'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure snd \\<diamondop> tree_chop stern_brocot_recurse =\n    pure nat \\<diamondop>\n    (pure int \\<diamondop>\n     (pure snd \\<diamondop> tree_chop stern_brocot_recurse))", "by applicative_nf simp"], ["proof (state)\nthis:\n  tree_chop den = pure nat \\<diamondop> tree_chop den'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "also"], ["proof (state)\nthis:\n  tree_chop den = pure nat \\<diamondop> tree_chop den'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have \"tree_chop den' = num' + den' - tree_chop den' + tree_chop den' - 2 * num_mod_den'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_chop den' =\n    num' + den' - tree_chop den' + tree_chop den' - 2 * num_mod_den'", "by(subst num'_plus_den'_minus_chop_den') simp"], ["proof (state)\nthis:\n  tree_chop den' =\n  num' + den' - tree_chop den' + tree_chop den' - 2 * num_mod_den'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "also"], ["proof (state)\nthis:\n  tree_chop den' =\n  num' + den' - tree_chop den' + tree_chop den' - 2 * num_mod_den'\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have \"\\<dots> = num' + den' - 2 * (num' mod den')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num' + den' - tree_chop den' + tree_chop den' - 2 * num_mod_den' =\n    num' + den' - 2 * (num' mod den')", "unfolding num_mod_den'_def num'_def den'_def num_mod_den[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure int \\<diamondop> num + pure int \\<diamondop> den -\n    tree_chop (pure int \\<diamondop> den) +\n    tree_chop (pure int \\<diamondop> den) -\n    2 * (pure int \\<diamondop> (num mod den)) =\n    pure int \\<diamondop> num + pure int \\<diamondop> den -\n    2 * (pure int \\<diamondop> num mod (pure int \\<diamondop> den))", "by applicative_lifting(simp add: zmod_int)"], ["proof (state)\nthis:\n  num' + den' - tree_chop den' + tree_chop den' - 2 * num_mod_den' =\n  num' + den' - 2 * (num' mod den')\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "also"], ["proof (state)\nthis:\n  num' + den' - tree_chop den' + tree_chop den' - 2 * num_mod_den' =\n  num' + den' - 2 * (num' mod den')\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have [unfolded tree.rel_eq]: \"rel_tree (=) \\<dots> (pure int \\<diamondop> (num + den - 2 * (num mod den)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_tree (=) (num' + den' - 2 * (num' mod den'))\n     (pure int \\<diamondop> (num + den - 2 * (num mod den)))", "unfolding num'_def den'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_tree (=)\n     (pure int \\<diamondop> num + pure int \\<diamondop> den -\n      2 * (pure int \\<diamondop> num mod (pure int \\<diamondop> den)))\n     (pure int \\<diamondop> (num + den - 2 * (num mod den)))", "by(applicative_lifting)(simp add: of_nat_diff zmod_int le den_gt_0)"], ["proof (state)\nthis:\n  num' + den' - 2 * (num' mod den') =\n  pure int \\<diamondop> (num + den - 2 * (num mod den))\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "also"], ["proof (state)\nthis:\n  num' + den' - 2 * (num' mod den') =\n  pure int \\<diamondop> (num + den - 2 * (num mod den))\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "have \"pure nat \\<diamondop> (pure int \\<diamondop> (num + den - 2 * (num mod den))) = num + den - 2 * (num mod den)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure nat \\<diamondop>\n    (pure int \\<diamondop> (num + den - 2 * (num mod den))) =\n    num + den - 2 * (num mod den)", "by(applicative_nf) simp"], ["proof (state)\nthis:\n  pure nat \\<diamondop>\n  (pure int \\<diamondop> (num + den - 2 * (num mod den))) =\n  num + den - 2 * (num mod den)\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "finally"], ["proof (chain)\npicking this:\n  tree_chop den = num + den - 2 * (num mod den)", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_chop den = num + den - 2 * (num mod den)\n\ngoal (1 subgoal):\n 1. tree_chop den = num + den - 2 * (num mod den)", "."], ["proof (state)\nthis:\n  tree_chop den = num + den - 2 * (num mod den)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Loopless linearisation of the Stern-Brocot tree.\\<close>"], ["", "text \\<open>\n  This is a loopless linearisation of the Stern-Brocot tree that gives Stern's diatomic sequence,\n  which is also known as Dijkstra's fusc function \\cite{Dijkstra1982EWD570,Dijkstra1982EWD578}.\n  Loopless \\`a la \\cite{Bird2006MPC} means that the first element of the stream can be computed in linear\n  time and every further element in constant time.\n\\<close>"], ["", "friend_of_corec smap :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a stream \\<Rightarrow> 'a stream\"\nwhere \"smap f xs = SCons (f (shd xs)) (smap f (stl xs))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. smap f xs = f (shd xs) ## smap f (stl xs)\n 2. rel_fun (rel_prod (=) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v1 R))\n     (\\<lambda>(f, xs).\n         (f (fst (snd xs)),\n          stream.v1.Oper\n           (stream.v1.Sig\n             (Inr (f, case snd xs of\n                      (x1, x2) \\<Rightarrow> stream.v1.VLeaf x2)))))\n     (\\<lambda>(f, xs).\n         (f (fst (snd xs)),\n          stream.v1.Oper\n           (stream.v1.Sig\n             (Inr (f, case snd xs of\n                      (x1, x2) \\<Rightarrow> stream.v1.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f xs = f (shd xs) ## smap f (stl xs)", "by(rule stream.expand) simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_prod (=) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v1 R))\n     (\\<lambda>(f, xs).\n         (f (fst (snd xs)),\n          stream.v1.Oper\n           (stream.v1.Sig\n             (Inr (f, case snd xs of\n                      (x1, x2) \\<Rightarrow> stream.v1.VLeaf x2)))))\n     (\\<lambda>(f, xs).\n         (f (fst (snd xs)),\n          stream.v1.Oper\n           (stream.v1.Sig\n             (Inr (f, case snd xs of\n                      (x1, x2) \\<Rightarrow> stream.v1.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_prod (=) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v1 R))\n     (\\<lambda>(f, xs).\n         (f (fst (snd xs)),\n          stream.v1.Oper\n           (stream.v1.Sig\n             (Inr (f, case snd xs of\n                      (x1, x2) \\<Rightarrow> stream.v1.VLeaf x2)))))\n     (\\<lambda>(f, xs).\n         (f (fst (snd xs)),\n          stream.v1.Oper\n           (stream.v1.Sig\n             (Inr (f, case snd xs of\n                      (x1, x2) \\<Rightarrow> stream.v1.VLeaf x2)))))", "by(fold relator_eq)(transfer_prover)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition step :: \"nat \\<times> nat \\<Rightarrow> nat \\<times> nat\"\nwhere \"step = (\\<lambda>(n, d). (d, n + d - 2 * (n mod d)))\""], ["", "corec stern_brocot_loopless :: \"fraction stream\"\nwhere \"stern_brocot_loopless = (1, 1) ## smap step stern_brocot_loopless\""], ["", "lemmas stern_brocot_loopless_rec = stern_brocot_loopless.code"], ["", "friend_of_corec plus where \"s + s' = (shd s + shd s') ## (stl s + stl s')\""], ["proof (prove)\ngoal (2 subgoals):\n 1. s + s' = (shd s + shd s') ## stl s + stl s'\n 2. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v2 R))\n     (\\<lambda>(s, s').\n         (fst (snd s) + fst (snd s'),\n          stream.v2.Oper\n           (stream.v2.Sig\n             (Inr (case snd s of (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2,\n                   case snd s' of\n                   (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2)))))\n     (\\<lambda>(s, s').\n         (fst (snd s) + fst (snd s'),\n          stream.v2.Oper\n           (stream.v2.Sig\n             (Inr (case snd s of (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2,\n                   case snd s' of\n                   (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s + s' = (shd s + shd s') ## stl s + stl s'", "by (rule stream.expand; simp add: plus_stream_shd plus_stream_stl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v2 R))\n     (\\<lambda>(s, s').\n         (fst (snd s) + fst (snd s'),\n          stream.v2.Oper\n           (stream.v2.Sig\n             (Inr (case snd s of (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2,\n                   case snd s' of\n                   (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2)))))\n     (\\<lambda>(s, s').\n         (fst (snd s) + fst (snd s'),\n          stream.v2.Oper\n           (stream.v2.Sig\n             (Inr (case snd s of (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2,\n                   case snd s' of\n                   (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v2 R))\n     (\\<lambda>(s, s').\n         (fst (snd s) + fst (snd s'),\n          stream.v2.Oper\n           (stream.v2.Sig\n             (Inr (case snd s of (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2,\n                   case snd s' of\n                   (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2)))))\n     (\\<lambda>(s, s').\n         (fst (snd s) + fst (snd s'),\n          stream.v2.Oper\n           (stream.v2.Sig\n             (Inr (case snd s of (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2,\n                   case snd s' of\n                   (x1, x2) \\<Rightarrow> stream.v2.VLeaf x2)))))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "friend_of_corec minus where \"t - t' = (shd t - shd t') ## (stl t - stl t')\""], ["proof (prove)\ngoal (2 subgoals):\n 1. t - t' = (shd t - shd t') ## stl t - stl t'\n 2. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v3 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) - fst (snd t'),\n          stream.v3.Oper\n           (stream.v3.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) - fst (snd t'),\n          stream.v3.Oper\n           (stream.v3.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. t - t' = (shd t - shd t') ## stl t - stl t'", "by (rule stream.expand; simp add: minus_stream_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v3 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) - fst (snd t'),\n          stream.v3.Oper\n           (stream.v3.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) - fst (snd t'),\n          stream.v3.Oper\n           (stream.v3.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v3 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) - fst (snd t'),\n          stream.v3.Oper\n           (stream.v3.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) - fst (snd t'),\n          stream.v3.Oper\n           (stream.v3.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v3.VLeaf x2)))))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "friend_of_corec times where \"t * t' = (shd t * shd t') ## (stl t * stl t')\""], ["proof (prove)\ngoal (2 subgoals):\n 1. t * t' = shd t * shd t' ## stl t * stl t'\n 2. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v4 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) * fst (snd t'),\n          stream.v4.Oper\n           (stream.v4.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) * fst (snd t'),\n          stream.v4.Oper\n           (stream.v4.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. t * t' = shd t * shd t' ## stl t * stl t'", "by (rule stream.expand; simp add: times_stream_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v4 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) * fst (snd t'),\n          stream.v4.Oper\n           (stream.v4.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) * fst (snd t'),\n          stream.v4.Oper\n           (stream.v4.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v4 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) * fst (snd t'),\n          stream.v4.Oper\n           (stream.v4.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) * fst (snd t'),\n          stream.v4.Oper\n           (stream.v4.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v4.VLeaf x2)))))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "friend_of_corec modulo where \"t mod t' = (shd t mod shd t') ## (stl t mod stl t')\""], ["proof (prove)\ngoal (2 subgoals):\n 1. t mod t' = shd t mod shd t' ## stl t mod stl t'\n 2. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v5 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) mod fst (snd t'),\n          stream.v5.Oper\n           (stream.v5.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) mod fst (snd t'),\n          stream.v5.Oper\n           (stream.v5.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. t mod t' = shd t mod shd t' ## stl t mod stl t'", "by (rule stream.expand; simp add: modulo_stream_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v5 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) mod fst (snd t'),\n          stream.v5.Oper\n           (stream.v5.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) mod fst (snd t'),\n          stream.v5.Oper\n           (stream.v5.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) R)) (rel_prod R (rel_prod (=) R)))\n     (rel_prod (=) (rel_ssig_stream_v5 R))\n     (\\<lambda>(t, t').\n         (fst (snd t) mod fst (snd t'),\n          stream.v5.Oper\n           (stream.v5.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2)))))\n     (\\<lambda>(t, t').\n         (fst (snd t) mod fst (snd t'),\n          stream.v5.Oper\n           (stream.v5.Sig\n             (Inr (case snd t of (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2,\n                   case snd t' of\n                   (x1, x2) \\<Rightarrow> stream.v5.VLeaf x2)))))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corec fusc' :: \"nat stream\"\nwhere \"fusc' = 1 ## (((1 ## fusc') + fusc') - 2 * ((1 ## fusc') mod fusc'))\""], ["", "definition fusc where \"fusc = 1 ## fusc'\""], ["", "lemma fusc_unfold: \"fusc = 1 ## fusc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fusc = 1 ## fusc'", "by(fact fusc_def)"], ["", "lemma fusc'_unfold: \"fusc' = 1 ## (fusc + fusc' - 2 * (fusc mod fusc'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fusc' = 1 ## fusc + fusc' - 2 * (fusc mod fusc')", "by(subst fusc'.code)(simp add: fusc_def)"], ["", "lemma fusc_simps [simp]:\n  \"shd fusc = 1\"\n  \"stl fusc = fusc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd fusc = 1 &&& stl fusc = fusc'", "by(simp_all add: fusc_unfold)"], ["", "lemma fusc'_simps [simp]:\n  \"shd fusc' = 1\"\n  \"stl fusc' = fusc + fusc' - 2 * (fusc mod fusc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd fusc' = 1 &&& stl fusc' = fusc + fusc' - 2 * (fusc mod fusc')", "by(subst fusc'_unfold, simp)+"], ["", "subsection \\<open>Equivalence with Dijkstra's fusc function\\<close>"], ["", "lemma stern_brocot_loopless_siterate: \"stern_brocot_loopless = siterate step (1, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stern_brocot_loopless = siterate step (1, 1)", "by(rule stern_brocot_loopless.unique[symmetric])(rule stream.expand; simp add: smap_siterate[symmetric])"], ["", "lemma fusc_fusc'_iterate: \"pure Pair \\<diamondop> fusc \\<diamondop> fusc' = stern_brocot_loopless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Pair \\<diamondop> fusc \\<diamondop> fusc' = stern_brocot_loopless", "apply(rule stern_brocot_loopless.unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Pair \\<diamondop> fusc \\<diamondop> fusc' =\n    (1, 1) ## smap step (pure Pair \\<diamondop> fusc \\<diamondop> fusc')", "apply(rule stream.expand; simp add: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Pair \\<diamondop> fusc' \\<diamondop>\n    (fusc + fusc' - 2 * (fusc mod fusc')) =\n    smap (\\<lambda>(n, d). (d, n + d - 2 * (n mod d)))\n     (pure Pair \\<diamondop> fusc \\<diamondop> fusc')", "apply(applicative_lifting; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem stern_brocot_loopless:\n  \"stream stern_brocot_recurse = stern_brocot_loopless\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream stern_brocot_recurse = stern_brocot_loopless", "proof(rule stern_brocot_loopless.unique)"], ["proof (state)\ngoal (1 subgoal):\n 1. stream stern_brocot_recurse =\n    (1, 1) ## smap step (stream stern_brocot_recurse)", "have eq: \"?lhs = stream (pure_tree Pair \\<diamondop> num \\<diamondop> den)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream stern_brocot_recurse =\n    stream (pure Pair \\<diamondop> num \\<diamondop> den)", "by (simp only: stern_brocot_num_den)"], ["proof (state)\nthis:\n  stream stern_brocot_recurse =\n  stream (pure Pair \\<diamondop> num \\<diamondop> den)\n\ngoal (1 subgoal):\n 1. stream stern_brocot_recurse =\n    (1, 1) ## smap step (stream stern_brocot_recurse)", "have num: \"stream num = 1 ## stream den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream num = 1 ## stream den", "by (rule stream.expand) (simp add: den_eq_chop_num)"], ["proof (state)\nthis:\n  stream num = 1 ## stream den\n\ngoal (1 subgoal):\n 1. stream stern_brocot_recurse =\n    (1, 1) ## smap step (stream stern_brocot_recurse)", "have den: \"stream den = 1 ## (stream num + stream den - 2 * (stream num mod stream den))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream den =\n    1 ## stream num + stream den - 2 * (stream num mod stream den)", "by (rule stream.expand)(simp add: tree_chop_den)"], ["proof (state)\nthis:\n  stream den =\n  1 ## stream num + stream den - 2 * (stream num mod stream den)\n\ngoal (1 subgoal):\n 1. stream stern_brocot_recurse =\n    (1, 1) ## smap step (stream stern_brocot_recurse)", "show \"?lhs = (1, 1) ## smap step ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream stern_brocot_recurse =\n    (1, 1) ## smap step (stream stern_brocot_recurse)", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream (pure Pair \\<diamondop> num \\<diamondop> den) =\n    (1, 1) ##\n    smap step (stream (pure Pair \\<diamondop> num \\<diamondop> den))", "by(rule stream.expand)(simp add: den_eq_chop_num[symmetric] tree_chop_den; applicative_lifting; simp add: step_def)"], ["proof (state)\nthis:\n  stream stern_brocot_recurse =\n  (1, 1) ## smap step (stream stern_brocot_recurse)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}