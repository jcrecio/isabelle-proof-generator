{"file_name": "/home/qj213/afp-2021-10-22/thys/Stern_Brocot/Cotree_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stern_Brocot", "problem_names": ["lemma plus_tree_simps [simp]:\n  \"root (t + t') = root t + root t'\"\n  \"left (t + t') = left t + left t'\"\n  \"right (t + t') = right t + right t'\"", "lemma minus_tree_simps [simp]:\n  \"root (t - t') = root t - root t'\"\n  \"left (t - t') = left t - left t'\"\n  \"right (t - t') = right t - right t'\"", "lemma times_tree_simps [simp]:\n  \"root (t * t') = root t * root t'\"\n  \"left (t * t') = left t * left t'\"\n  \"right (t * t') = right t * right t'\"", "lemma mod_tree_simps [simp]:\n  \"root (t mod t') = root t mod root t'\"\n  \"left (t mod t') = left t mod left t'\"\n  \"right (t mod t') = right t mod right t'\"", "lemma pure_tree_inject[simp]: \"pure_tree x = pure_tree y \\<longleftrightarrow> x = y\"", "lemma of_nat_tree: \"of_nat n = pure_tree (of_nat n)\"", "lemma numeral_tree_simps [simp]:\n  \"root (numeral n) = numeral n\"\n  \"left (numeral n) = numeral n\"\n  \"right (numeral n) = numeral n\"", "lemma numeral_tree_conv_pure [applicative_unfold]: \"numeral n = pure (numeral n)\""], "translations": [["", "lemma plus_tree_simps [simp]:\n  \"root (t + t') = root t + root t'\"\n  \"left (t + t') = left t + left t'\"\n  \"right (t + t') = right t + right t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (t + t') = root t + root t' &&&\n    left (t + t') = left t + left t' &&& right (t + t') = right t + right t'", "by(simp_all add: plus_tree_def)"], ["", "friend_of_corec plus where \"t + t' = Node (root t + root t') (left t + left t') (right t + right t')\""], ["proof (prove)\ngoal (2 subgoals):\n 1. t + t' = Node (root t + root t') (left t + left t') (right t + right t')\n 2. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) (rel_prod R R)))\n       (rel_prod R (rel_prod (=) (rel_prod R R))))\n     (rel_prod (=) (rel_prod (rel_ssig_tree_v2 R) (rel_ssig_tree_v2 R)))\n     (\\<lambda>(t, t').\n         ((case snd t of (x1, x2, x3) \\<Rightarrow> x1) +\n          (case snd t' of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2))),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3)))))\n     (\\<lambda>(t, t').\n         ((case snd t of (x1, x2, x3) \\<Rightarrow> x1) +\n          (case snd t' of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2))),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. t + t' = Node (root t + root t') (left t + left t') (right t + right t')", "by(rule tree.expand; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) (rel_prod R R)))\n       (rel_prod R (rel_prod (=) (rel_prod R R))))\n     (rel_prod (=) (rel_prod (rel_ssig_tree_v2 R) (rel_ssig_tree_v2 R)))\n     (\\<lambda>(t, t').\n         ((case snd t of (x1, x2, x3) \\<Rightarrow> x1) +\n          (case snd t' of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2))),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3)))))\n     (\\<lambda>(t, t').\n         ((case snd t of (x1, x2, x3) \\<Rightarrow> x1) +\n          (case snd t' of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2))),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_prod (rel_prod R (rel_prod (=) (rel_prod R R)))\n       (rel_prod R (rel_prod (=) (rel_prod R R))))\n     (rel_prod (=) (rel_prod (rel_ssig_tree_v2 R) (rel_ssig_tree_v2 R)))\n     (\\<lambda>(t, t').\n         ((case snd t of (x1, x2, x3) \\<Rightarrow> x1) +\n          (case snd t' of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2))),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3)))))\n     (\\<lambda>(t, t').\n         ((case snd t of (x1, x2, x3) \\<Rightarrow> x1) +\n          (case snd t' of (x1, x2, x3) \\<Rightarrow> x1),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x2))),\n          tree.v2.Oper\n           (tree.v2.Sig\n             (Inr (case snd t of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3,\n                   case snd t' of\n                   (x1, x2, x3) \\<Rightarrow> tree.v2.VLeaf x3)))))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation tree :: (minus) minus begin"], ["", "definition [applicative_unfold]: \"minus x y = pure (-) \\<diamondop> x \\<diamondop> (y :: 'a tree)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, minus_class)", ".."], ["", "end"], ["", "lemma minus_tree_simps [simp]:\n  \"root (t - t') = root t - root t'\"\n  \"left (t - t') = left t - left t'\"\n  \"right (t - t') = right t - right t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (t - t') = root t - root t' &&&\n    left (t - t') = left t - left t' &&& right (t - t') = right t - right t'", "by(simp_all add: minus_tree_def)"], ["", "instantiation tree :: (uminus) uminus begin"], ["", "definition [applicative_unfold tree]: \"uminus = ((\\<diamondop>) (pure uminus) :: 'a tree \\<Rightarrow> 'a tree)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, uminus_class)", ".."], ["", "end"], ["", "instantiation tree :: (times) times begin"], ["", "definition [applicative_unfold]: \"times x y = pure (*) \\<diamondop> x \\<diamondop> (y :: 'a tree)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, times_class)", ".."], ["", "end"], ["", "lemma times_tree_simps [simp]:\n  \"root (t * t') = root t * root t'\"\n  \"left (t * t') = left t * left t'\"\n  \"right (t * t') = right t * right t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (t * t') = root t * root t' &&&\n    left (t * t') = left t * left t' &&& right (t * t') = right t * right t'", "by(simp_all add: times_tree_def)"], ["", "instance tree :: (Rings.dvd) Rings.dvd"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, dvd_class)", ".."], ["", "instantiation tree :: (modulo) modulo begin"], ["", "definition [applicative_unfold]: \"x div y = pure_tree (div) \\<diamondop> x \\<diamondop> (y :: 'a tree)\""], ["", "definition [applicative_unfold]: \"x mod y = pure_tree (mod) \\<diamondop> x \\<diamondop> (y :: 'a tree)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, modulo_class)", ".."], ["", "end"], ["", "lemma mod_tree_simps [simp]:\n  \"root (t mod t') = root t mod root t'\"\n  \"left (t mod t') = left t mod left t'\"\n  \"right (t mod t') = right t mod right t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (t mod t') = root t mod root t' &&&\n    left (t mod t') = left t mod left t' &&&\n    right (t mod t') = right t mod right t'", "by(simp_all add: modulo_tree_def)"], ["", "subsubsection \\<open>Algebraic instances\\<close>"], ["", "instance tree :: (semigroup_add) semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semigroup_add_class)", "using add.assoc"], ["proof (prove)\nusing this:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semigroup_add_class)", "by intro_classes applicative_lifting"], ["", "instance tree :: (ab_semigroup_add) ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, ab_semigroup_add_class)", "using add.commute"], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. OFCLASS('a tree, ab_semigroup_add_class)", "by intro_classes applicative_lifting"], ["", "instance tree :: (semigroup_mult) semigroup_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semigroup_mult_class)", "using mult.assoc"], ["proof (prove)\nusing this:\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semigroup_mult_class)", "by intro_classes applicative_lifting"], ["", "instance tree :: (ab_semigroup_mult) ab_semigroup_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, ab_semigroup_mult_class)", "using mult.commute"], ["proof (prove)\nusing this:\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. OFCLASS('a tree, ab_semigroup_mult_class)", "by intro_classes applicative_lifting"], ["", "instance tree :: (monoid_add) monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, monoid_add_class)", "by intro_classes (applicative_lifting, simp)+"], ["", "instance tree :: (comm_monoid_add) comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_monoid_add_class)", "by intro_classes (applicative_lifting, simp)"], ["", "instance tree :: (comm_monoid_diff) comm_monoid_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_monoid_diff_class)", "by intro_classes (applicative_lifting, simp add: diff_diff_add)+"], ["", "instance tree :: (monoid_mult) monoid_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, monoid_mult_class)", "by intro_classes (applicative_lifting, simp)+"], ["", "instance tree :: (comm_monoid_mult) comm_monoid_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_monoid_mult_class)", "by intro_classes (applicative_lifting, simp)"], ["", "instance tree :: (cancel_semigroup_add) cancel_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, cancel_semigroup_add_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "fix a b c :: \"'a tree\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "assume \"a + b = a + c\""], ["proof (state)\nthis:\n  a + b = a + c\n\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "thus \"b = c\""], ["proof (prove)\nusing this:\n  a + b = a + c\n\ngoal (1 subgoal):\n 1. b = c", "proof (coinduction arbitrary: a b c)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       a + b = a + c \\<Longrightarrow>\n       root b = root c \\<and>\n       (\\<exists>a ba ca.\n           left b = ba \\<and> left c = ca \\<and> a + ba = a + ca) \\<and>\n       (\\<exists>a ba ca.\n           right b = ba \\<and> right c = ca \\<and> a + ba = a + ca)", "case (Eq_tree a b c)"], ["proof (state)\nthis:\n  a + b = a + c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       a + b = a + c \\<Longrightarrow>\n       root b = root c \\<and>\n       (\\<exists>a ba ca.\n           left b = ba \\<and> left c = ca \\<and> a + ba = a + ca) \\<and>\n       (\\<exists>a ba ca.\n           right b = ba \\<and> right c = ca \\<and> a + ba = a + ca)", "hence \"root (a + b) = root (a + c)\"\n          \"left (a + b) = left (a + c)\"\n          \"right (a + b) = right (a + c)\""], ["proof (prove)\nusing this:\n  a + b = a + c\n\ngoal (1 subgoal):\n 1. root (a + b) = root (a + c) &&&\n    left (a + b) = left (a + c) &&& right (a + b) = right (a + c)", "by simp_all"], ["proof (state)\nthis:\n  root (a + b) = root (a + c)\n  left (a + b) = left (a + c)\n  right (a + b) = right (a + c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       a + b = a + c \\<Longrightarrow>\n       root b = root c \\<and>\n       (\\<exists>a ba ca.\n           left b = ba \\<and> left c = ca \\<and> a + ba = a + ca) \\<and>\n       (\\<exists>a ba ca.\n           right b = ba \\<and> right c = ca \\<and> a + ba = a + ca)", "thus ?case"], ["proof (prove)\nusing this:\n  root (a + b) = root (a + c)\n  left (a + b) = left (a + c)\n  right (a + b) = right (a + c)\n\ngoal (1 subgoal):\n 1. root b = root c \\<and>\n    (\\<exists>a b c.\n        left b = b \\<and> left c = c \\<and> a + b = a + c) \\<and>\n    (\\<exists>a b c. right b = b \\<and> right c = c \\<and> a + b = a + c)", "by (auto)"], ["proof (state)\nthis:\n  root b = root c \\<and>\n  (\\<exists>a b c. left b = b \\<and> left c = c \\<and> a + b = a + c) \\<and>\n  (\\<exists>a b c. right b = b \\<and> right c = c \\<and> a + b = a + c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = c\n\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "fix a b c :: \"'a tree\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "assume \"b + a = c + a\""], ["proof (state)\nthis:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "thus \"b = c\""], ["proof (prove)\nusing this:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. b = c", "proof (coinduction arbitrary: a b c)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       b + a = c + a \\<Longrightarrow>\n       root b = root c \\<and>\n       (\\<exists>a ba ca.\n           left b = ba \\<and> left c = ca \\<and> ba + a = ca + a) \\<and>\n       (\\<exists>a ba ca.\n           right b = ba \\<and> right c = ca \\<and> ba + a = ca + a)", "case (Eq_tree a b c)"], ["proof (state)\nthis:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       b + a = c + a \\<Longrightarrow>\n       root b = root c \\<and>\n       (\\<exists>a ba ca.\n           left b = ba \\<and> left c = ca \\<and> ba + a = ca + a) \\<and>\n       (\\<exists>a ba ca.\n           right b = ba \\<and> right c = ca \\<and> ba + a = ca + a)", "hence \"root (b + a) = root (c + a)\"\n          \"left (b + a) = left (c + a)\"\n          \"right (b + a) = right (c + a)\""], ["proof (prove)\nusing this:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. root (b + a) = root (c + a) &&&\n    left (b + a) = left (c + a) &&& right (b + a) = right (c + a)", "by simp_all"], ["proof (state)\nthis:\n  root (b + a) = root (c + a)\n  left (b + a) = left (c + a)\n  right (b + a) = right (c + a)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       b + a = c + a \\<Longrightarrow>\n       root b = root c \\<and>\n       (\\<exists>a ba ca.\n           left b = ba \\<and> left c = ca \\<and> ba + a = ca + a) \\<and>\n       (\\<exists>a ba ca.\n           right b = ba \\<and> right c = ca \\<and> ba + a = ca + a)", "thus ?case"], ["proof (prove)\nusing this:\n  root (b + a) = root (c + a)\n  left (b + a) = left (c + a)\n  right (b + a) = right (c + a)\n\ngoal (1 subgoal):\n 1. root b = root c \\<and>\n    (\\<exists>a b c.\n        left b = b \\<and> left c = c \\<and> b + a = c + a) \\<and>\n    (\\<exists>a b c. right b = b \\<and> right c = c \\<and> b + a = c + a)", "by (auto)"], ["proof (state)\nthis:\n  root b = root c \\<and>\n  (\\<exists>a b c. left b = b \\<and> left c = c \\<and> b + a = c + a) \\<and>\n  (\\<exists>a b c. right b = b \\<and> right c = c \\<and> b + a = c + a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = c\n\ngoal:\nNo subgoals!", "qed"], ["", "instance tree :: (cancel_ab_semigroup_add) cancel_ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, cancel_ab_semigroup_add_class)", "by intro_classes (applicative_lifting, simp add: diff_diff_eq)+"], ["", "instance tree :: (cancel_comm_monoid_add) cancel_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, cancel_comm_monoid_add_class)", ".."], ["", "instance tree :: (group_add) group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, group_add_class)", "by intro_classes (applicative_lifting, simp)+"], ["", "instance tree :: (ab_group_add) ab_group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, ab_group_add_class)", "by intro_classes (applicative_lifting, simp)+"], ["", "instance tree :: (semiring) semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semiring_class)", "by intro_classes (applicative_lifting, simp add: ring_distribs)+"], ["", "instance tree :: (mult_zero) mult_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, mult_zero_class)", "by intro_classes (applicative_lifting, simp)+"], ["", "instance tree :: (semiring_0) semiring_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semiring_0_class)", ".."], ["", "instance tree :: (semiring_0_cancel) semiring_0_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semiring_0_cancel_class)", ".."], ["", "instance tree :: (comm_semiring) comm_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_semiring_class)", "by intro_classes(rule distrib_right)"], ["", "instance tree :: (comm_semiring_0) comm_semiring_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_semiring_0_class)", ".."], ["", "instance tree :: (comm_semiring_0_cancel) comm_semiring_0_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_semiring_0_cancel_class)", ".."], ["", "lemma pure_tree_inject[simp]: \"pure_tree x = pure_tree y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pure x = pure y) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pure x = pure y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> pure x = pure y", "assume \"pure_tree x = pure_tree y\""], ["proof (state)\nthis:\n  pure x = pure y\n\ngoal (2 subgoals):\n 1. pure x = pure y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> pure x = pure y", "hence \"root (pure_tree x) = root (pure_tree y)\""], ["proof (prove)\nusing this:\n  pure x = pure y\n\ngoal (1 subgoal):\n 1. root (pure x) = root (pure y)", "by simp"], ["proof (state)\nthis:\n  root (pure x) = root (pure y)\n\ngoal (2 subgoals):\n 1. pure x = pure y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> pure x = pure y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  root (pure x) = root (pure y)\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> pure x = pure y", "qed simp"], ["", "instance tree :: (zero_neq_one) zero_neq_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, zero_neq_one_class)", "by intro_classes (applicative_unfold tree)"], ["", "instance tree :: (semiring_1) semiring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semiring_1_class)", ".."], ["", "instance tree :: (comm_semiring_1) comm_semiring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_semiring_1_class)", ".."], ["", "instance tree :: (semiring_1_cancel) semiring_1_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semiring_1_cancel_class)", ".."], ["", "instance tree :: (comm_semiring_1_cancel) comm_semiring_1_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_semiring_1_cancel_class)", "by(intro_classes; applicative_lifting, rule right_diff_distrib')"], ["", "instance tree :: (ring) ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, ring_class)", ".."], ["", "instance tree :: (comm_ring) comm_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_ring_class)", ".."], ["", "instance tree :: (ring_1) ring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, ring_1_class)", ".."], ["", "instance tree :: (comm_ring_1) comm_ring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, comm_ring_1_class)", ".."], ["", "instance tree :: (numeral) numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, numeral_class)", ".."], ["", "instance tree :: (neg_numeral) neg_numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, neg_numeral_class)", ".."], ["", "instance tree :: (semiring_numeral) semiring_numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semiring_numeral_class)", ".."], ["", "lemma of_nat_tree: \"of_nat n = pure_tree (of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n = pure (of_nat n)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. of_nat 0 = pure (of_nat 0)\n 2. \\<And>n.\n       of_nat n = pure (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = pure (of_nat (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. of_nat 0 = pure (of_nat 0)\n 2. \\<And>n.\n       of_nat n = pure (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = pure (of_nat (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat 0 = pure (of_nat 0)", "by (simp add: zero_tree_def)"], ["proof (state)\nthis:\n  of_nat 0 = pure (of_nat 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = pure (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = pure (of_nat (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = pure (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = pure (of_nat (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  of_nat n = pure (of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = pure (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = pure (of_nat (Suc n))", "have \"1 + pure (of_nat n) = pure (1 + of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + pure (of_nat n) = pure ((1::'b) + of_nat n)", "by applicative_nf rule"], ["proof (state)\nthis:\n  1 + pure (of_nat n) = pure ((1::?'b1) + of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = pure (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = pure (of_nat (Suc n))", "with Suc.IH"], ["proof (chain)\npicking this:\n  of_nat n = pure (of_nat n)\n  1 + pure (of_nat n) = pure ((1::?'b1) + of_nat n)", "show ?case"], ["proof (prove)\nusing this:\n  of_nat n = pure (of_nat n)\n  1 + pure (of_nat n) = pure ((1::?'b1) + of_nat n)\n\ngoal (1 subgoal):\n 1. of_nat (Suc n) = pure (of_nat (Suc n))", "by simp"], ["proof (state)\nthis:\n  of_nat (Suc n) = pure (of_nat (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "instance tree :: (semiring_char_0) semiring_char_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, semiring_char_0_class)", "by intro_classes (simp add: inj_on_def of_nat_tree)"], ["", "lemma numeral_tree_simps [simp]:\n  \"root (numeral n) = numeral n\"\n  \"left (numeral n) = numeral n\"\n  \"right (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (numeral n) = numeral n &&&\n    left (numeral n) = numeral n &&& right (numeral n) = numeral n", "by(induct n)(auto simp add: numeral.simps plus_tree_def one_tree_def)"], ["", "lemma numeral_tree_conv_pure [applicative_unfold]: \"numeral n = pure (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n = pure (numeral n)", "by(rule pure_tree_unique)(rule tree.expand; simp)"], ["", "instance tree :: (ring_char_0) ring_char_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tree, ring_char_0_class)", ".."], ["", "end"]]}